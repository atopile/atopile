#pragma experiment("FOR_LOOP")
#pragma experiment("BRIDGE_CONNECT")

import ElectricPower
import ElectricLogic
import I2C
import SPI
import UART_Base
import Resistor
import Capacitor


module FakePowerTree:
    vin = new ElectricPower
    rail_3v3 = new ElectricPower
    rail_1v8 = new ElectricPower

    rail_3v3_source = new Resistor
    rail_3v3_source.resistance = 0.22ohm +/- 20%
    rail_3v3_source.package = "0402"
    vin.hv ~> rail_3v3_source ~> rail_3v3.hv

    rail_1v8_source = new Resistor
    rail_1v8_source.resistance = 0.47ohm +/- 20%
    rail_1v8_source.package = "0402"
    vin.hv ~> rail_1v8_source ~> rail_1v8.hv

    vin.lv ~ rail_3v3.lv
    vin.lv ~ rail_1v8.lv

    input_caps = new Capacitor[2]
    for cap in input_caps:
        cap.capacitance = 10uF +/- 20%
        cap.package = "0402"
        vin.hv ~> cap ~> vin.lv

    output_caps_3v3 = new Capacitor[2]
    for cap in output_caps_3v3:
        cap.capacitance = 4.7uF +/- 20%
        cap.package = "0402"
        rail_3v3.hv ~> cap ~> rail_3v3.lv

    output_caps_1v8 = new Capacitor[2]
    for cap in output_caps_1v8:
        cap.capacitance = 2.2uF +/- 20%
        cap.package = "0402"
        rail_1v8.hv ~> cap ~> rail_1v8.lv


module FakeProcessor:
    power = new ElectricPower
    i2c = new I2C
    spi = new SPI
    uart = new UART_Base
    irq = new ElectricLogic

    power.required = True
    power.is_power_sink = True
    assert power.voltage within 3.3V +/- 5%

    i2c.scl.reference ~ power
    i2c.sda.reference ~ power
    spi.sclk.reference ~ power
    spi.miso.reference ~ power
    spi.mosi.reference ~ power
    uart.tx.reference ~ power
    uart.rx.reference ~ power
    irq.reference ~ power

    core_caps = new Capacitor[2]
    for cap in core_caps:
        cap.capacitance = 100nF +/- 20%
        cap.package = "0402"
        power.hv ~> cap ~> power.lv

    i2c_scl_anchor = new Resistor
    i2c_scl_anchor.resistance = 100kohm +/- 5%
    i2c_scl_anchor.package = "0402"
    i2c.scl.line ~> i2c_scl_anchor ~> power.hv

    i2c_sda_anchor = new Resistor
    i2c_sda_anchor.resistance = 100kohm +/- 5%
    i2c_sda_anchor.package = "0402"
    i2c.sda.line ~> i2c_sda_anchor ~> power.hv

    spi_sclk_anchor = new Resistor
    spi_sclk_anchor.resistance = 100kohm +/- 5%
    spi_sclk_anchor.package = "0402"
    spi.sclk.line ~> spi_sclk_anchor ~> power.lv

    spi_mosi_anchor = new Resistor
    spi_mosi_anchor.resistance = 100kohm +/- 5%
    spi_mosi_anchor.package = "0402"
    spi.mosi.line ~> spi_mosi_anchor ~> power.lv

    spi_miso_anchor = new Resistor
    spi_miso_anchor.resistance = 100kohm +/- 5%
    spi_miso_anchor.package = "0402"
    spi.miso.line ~> spi_miso_anchor ~> power.lv

    uart_tx_anchor = new Resistor
    uart_tx_anchor.resistance = 100kohm +/- 5%
    uart_tx_anchor.package = "0402"
    uart.tx.line ~> uart_tx_anchor ~> power.lv

    uart_rx_anchor = new Resistor
    uart_rx_anchor.resistance = 100kohm +/- 5%
    uart_rx_anchor.package = "0402"
    uart.rx.line ~> uart_rx_anchor ~> power.lv

    irq_anchor = new Resistor
    irq_anchor.resistance = 100kohm +/- 5%
    irq_anchor.package = "0402"
    irq.line ~> irq_anchor ~> power.lv


module FakeSensorFrontEnd:
    power = new ElectricPower
    i2c = new I2C
    irq = new ElectricLogic

    power.required = True
    power.is_power_sink = True
    assert power.voltage within 3.3V +/- 5%

    i2c.scl.reference ~ power
    i2c.sda.reference ~ power
    irq.reference ~ power

    sensor_caps = new Capacitor[2]
    for cap in sensor_caps:
        cap.capacitance = 100nF +/- 20%
        cap.package = "0402"
        power.hv ~> cap ~> power.lv

    i2c_scl_anchor = new Resistor
    i2c_scl_anchor.resistance = 47kohm +/- 5%
    i2c_scl_anchor.package = "0402"
    i2c.scl.line ~> i2c_scl_anchor ~> power.lv

    i2c_sda_anchor = new Resistor
    i2c_sda_anchor.resistance = 47kohm +/- 5%
    i2c_sda_anchor.package = "0402"
    i2c.sda.line ~> i2c_sda_anchor ~> power.lv

    irq_anchor = new Resistor
    irq_anchor.resistance = 47kohm +/- 5%
    irq_anchor.package = "0402"
    irq.line ~> irq_anchor ~> power.hv


module FakeRadioLink:
    power = new ElectricPower
    uart = new UART_Base
    enable = new ElectricLogic

    power.required = True
    power.is_power_sink = True
    assert power.voltage within 3.3V +/- 5%

    uart.tx.reference ~ power
    uart.rx.reference ~ power
    enable.reference ~ power

    radio_caps = new Capacitor[2]
    for cap in radio_caps:
        cap.capacitance = 100nF +/- 20%
        cap.package = "0402"
        power.hv ~> cap ~> power.lv

    uart_tx_anchor = new Resistor
    uart_tx_anchor.resistance = 68kohm +/- 5%
    uart_tx_anchor.package = "0402"
    uart.tx.line ~> uart_tx_anchor ~> power.lv

    uart_rx_anchor = new Resistor
    uart_rx_anchor.resistance = 68kohm +/- 5%
    uart_rx_anchor.package = "0402"
    uart.rx.line ~> uart_rx_anchor ~> power.lv

    enable_anchor = new Resistor
    enable_anchor.resistance = 68kohm +/- 5%
    enable_anchor.package = "0402"
    enable.line ~> enable_anchor ~> power.hv


module FakeFlashStorage:
    power = new ElectricPower
    spi = new SPI

    power.required = True
    power.is_power_sink = True
    assert power.voltage within 3.3V +/- 5%

    spi.sclk.reference ~ power
    spi.miso.reference ~ power
    spi.mosi.reference ~ power

    flash_caps = new Capacitor[2]
    for cap in flash_caps:
        cap.capacitance = 100nF +/- 20%
        cap.package = "0402"
        power.hv ~> cap ~> power.lv

    spi_sclk_anchor = new Resistor
    spi_sclk_anchor.resistance = 82kohm +/- 5%
    spi_sclk_anchor.package = "0402"
    spi.sclk.line ~> spi_sclk_anchor ~> power.lv

    spi_mosi_anchor = new Resistor
    spi_mosi_anchor.resistance = 82kohm +/- 5%
    spi_mosi_anchor.package = "0402"
    spi.mosi.line ~> spi_mosi_anchor ~> power.lv

    spi_miso_anchor = new Resistor
    spi_miso_anchor.resistance = 82kohm +/- 5%
    spi_miso_anchor.package = "0402"
    spi.miso.line ~> spi_miso_anchor ~> power.lv


module BlockLevelDemo:
    input_power = new ElectricPower

    power_tree = new FakePowerTree
    processor = new FakeProcessor
    sensors = new FakeSensorFrontEnd
    radio = new FakeRadioLink
    flash = new FakeFlashStorage

    input_power ~ power_tree.vin

    power_tree.rail_3v3 ~ processor.power
    power_tree.rail_3v3 ~ sensors.power
    power_tree.rail_3v3 ~ radio.power
    power_tree.rail_3v3 ~ flash.power

    processor.i2c ~ sensors.i2c
    processor.spi ~ flash.spi
    processor.uart ~ radio.uart
    sensors.irq ~ processor.irq
    processor.irq ~ radio.enable

    input_power.hv.override_net_name = "VIN_MAIN"
    input_power.lv.override_net_name = "GND"
    power_tree.rail_3v3.hv.override_net_name = "VCC_3V3"
    power_tree.rail_3v3.lv.override_net_name = "GND"
    power_tree.rail_1v8.hv.override_net_name = "VCC_1V8"
    power_tree.rail_1v8.lv.override_net_name = "GND"
    processor.i2c.scl.line.override_net_name = "I2C_MAIN_SCL"
    processor.i2c.sda.line.override_net_name = "I2C_MAIN_SDA"
    processor.spi.sclk.line.override_net_name = "SPI_MAIN_SCLK"
    processor.spi.mosi.line.override_net_name = "SPI_MAIN_MOSI"
    processor.spi.miso.line.override_net_name = "SPI_MAIN_MISO"
    processor.uart.tx.line.override_net_name = "UART_TX"
    processor.uart.rx.line.override_net_name = "UART_RX"
    processor.irq.line.override_net_name = "IRQ_SHARED"

