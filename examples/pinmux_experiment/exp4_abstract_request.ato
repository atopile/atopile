"""
Experiment 4: "Give me AN I2C" - abstract peripheral request.

The dream UX: user says "I need an I2C" and the MCU module
figures out which one to give them. This requires the solver
to pick from options.

Current hypothesis: This is NOT possible in ato today because:
1. Connections (~) are static/structural, not solver-driven
2. There's no "or" or "choice" in the connection system
3. Array indexing must be literal, not a parameter

Let's verify this hypothesis by trying approaches that MIGHT work.
"""
#pragma experiment("FOR_LOOP")
#pragma experiment("BRIDGE_CONNECT")

import ElectricPower
import ElectricLogic
import I2C

# Approach A: Multiple separate I2C interfaces, user picks by connecting
module MCU_ApproachA:
    """Expose all I2C instances. User connects to whichever they want."""
    power = new ElectricPower
    gpio = new ElectricLogic[12]
    for io in gpio:
        io.reference ~ power

    # All possible I2C instances
    i2c1 = new I2C
    i2c1.scl ~ gpio[6]
    i2c1.sda ~ gpio[7]

    i2c2 = new I2C
    i2c2.scl ~ gpio[10]
    i2c2.sda ~ gpio[11]

    # Issue: ALL pins are "used" in the netlist even if user only connects i2c1.
    # The GPIO pins are physically wired to the I2C regardless.

# Approach B: Use a "wrapper" that only connects when the user does
module I2C_Port:
    """An I2C port that can be connected to an external bus."""
    external = new I2C
    internal_scl = new ElectricLogic
    internal_sda = new ElectricLogic

    # The connection from external to internal pins
    external.scl ~ internal_scl
    external.sda ~ internal_sda

module MCU_ApproachB:
    """Use I2C_Port wrappers to isolate peripheral-to-pin connections."""
    power = new ElectricPower
    gpio = new ElectricLogic[12]
    for io in gpio:
        io.reference ~ power

    i2c1 = new I2C_Port
    i2c1.internal_scl ~ gpio[6]
    i2c1.internal_sda ~ gpio[7]

    i2c2 = new I2C_Port
    i2c2.internal_scl ~ gpio[10]
    i2c2.internal_sda ~ gpio[11]


module App:
    power = new ElectricPower

    mcu = new MCU_ApproachB
    power ~ mcu.power

    # User: "I need one I2C for my sensor"
    sensor_i2c = new I2C
    sensor_i2c ~ mcu.i2c1.external

    # What we CAN'T do (but want to):
    # sensor_i2c ~ mcu.any_i2c()     # no functions in ato
    # sensor_i2c ~ mcu.i2c[auto]     # no dynamic indexing
