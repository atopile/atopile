"""
Experiment 2: Model alternate pin configurations as separate modules.

Key insight: Instead of one I2C instance with multiple possible pin mappings,
create "pin configuration" modules that each represent ONE valid mapping.
The user picks the config they want (or a resolver picks for them).

This tests: Can we decouple "which peripheral" from "which pins" cleanly?
"""
#pragma experiment("FOR_LOOP")
#pragma experiment("BRIDGE_CONNECT")

import ElectricPower
import ElectricLogic
import I2C

# A "pin config" is an interface that maps an I2C to specific GPIOs
interface I2C_PinConfig:
    """Maps one I2C peripheral instance to specific physical pins."""
    bus = new I2C
    scl_pin = new ElectricLogic
    sda_pin = new ElectricLogic


module TinyMCU:
    """MCU with I2C1 available on two alternate pin sets."""

    power = new ElectricPower

    # Physical pins
    gpio_b = new ElectricLogic[12]
    for io in gpio_b:
        io.reference ~ power

    # I2C1 has two possible pin configurations
    i2c1_config_a = new I2C_PinConfig
    i2c1_config_a.scl_pin ~ gpio_b[6]
    i2c1_config_a.sda_pin ~ gpio_b[7]

    i2c1_config_b = new I2C_PinConfig
    i2c1_config_b.scl_pin ~ gpio_b[8]
    i2c1_config_b.sda_pin ~ gpio_b[9]

    # I2C2 only has one config
    i2c2_config = new I2C_PinConfig
    i2c2_config.scl_pin ~ gpio_b[10]
    i2c2_config.sda_pin ~ gpio_b[11]

    # Public interfaces: user picks which config to use
    # by connecting to the appropriate config's .bus
    i2c1_a = new I2C
    i2c1_a ~ i2c1_config_a.bus

    i2c1_b = new I2C
    i2c1_b ~ i2c1_config_b.bus

    i2c2 = new I2C
    i2c2 ~ i2c2_config.bus


module App:
    power = new ElectricPower
    mcu = new TinyMCU
    power ~ mcu.power

    # User picks I2C1 on pins PB8/PB9 (config B)
    sensor = new I2C
    sensor ~ mcu.i2c1_b

    # And also I2C2 (no conflict since different pins)
    eeprom = new I2C
    eeprom ~ mcu.i2c2
