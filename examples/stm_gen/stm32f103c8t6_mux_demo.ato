"""
STM32F103C8T6 with PinMuxSelector — demonstrating solver-driven pin assignment.

This module replaces hardcoded peripheral→GPIO connections with PinMuxSelectors
for peripherals that have alternate pin configurations.

STM32F103 alternate function remaps:
  I2C1:   config 0 = PB6(SCL)/PB7(SDA)   | config 1 = PB8(SCL)/PB9(SDA)
  USART1: config 0 = PA9(TX)/PA10(RX)     | config 1 = PB6(TX)/PB7(RX)
  SPI1:   config 0 = PA5(SCK)/PA6(MISO)/PA7(MOSI) | config 1 = PB3(SCK)/PB4(MISO)/PB5(MOSI)

Note: USART1 config 1 (PB6/PB7) conflicts with I2C1 config 0 (PB6/PB7)!
The PinMuxSelector makes this conflict visible and manageable.
"""

#pragma experiment("MODULE_TEMPLATING")
#pragma experiment("BRIDGE_CONNECT")
#pragma experiment("FOR_LOOP")
#pragma experiment("TRAITS")

import Capacitor
import ElectricLogic
import ElectricPower
import I2C
import PinMuxSelector
import SPI
import SWD
import UART
import USB2_0
import XtalIF

from "parts/STMicroelectronics_STM32F103C8T6/STMicroelectronics_STM32F103C8T6.ato" import STMicroelectronics_STM32F103C8T6_package

module ST_STM32F103C8T6_Mux:
    """
    STMicroelectronics STM32F103C8T6 with PinMuxSelector-based pin assignment.
    Arm Cortex-M3 up to 72 MHz, 64 KB Flash, 20 KB SRAM, LQFP48.

    Peripherals with alternate configs use PinMuxSelector so the solver
    can resolve which physical pins to use.
    """

    # --- Package ---
    package = new STMicroelectronics_STM32F103C8T6_package

    # ===================================================================
    # Power domains
    # ===================================================================

    power_3v3 = new ElectricPower
    """Primary supply domain (2.0V to 3.6V)."""
    power_3v3.required = True
    assert power_3v3.voltage within 2.0V to 3.6V

    power_analog = new ElectricPower
    """Analog supply domain (VDDA/VSSA)."""

    vbat = new ElectricPower
    """Backup battery domain (VBAT)."""

    power_3v3 ~ power_analog

    # ===================================================================
    # GPIO arrays by port
    # ===================================================================

    gpio_a = new ElectricLogic[16]
    """Port A: all 16 pins bonded out."""

    gpio_b = new ElectricLogic[16]
    """Port B: all 16 pins bonded out."""

    gpio_c = new ElectricLogic[16]
    """Port C: 3 of 16 pins bonded out."""

    gpio_d = new ElectricLogic[2]
    """Port D: all 2 pins bonded out."""

    # ===================================================================
    # Fixed interfaces (no alternate pins)
    # ===================================================================

    swd = new SWD
    """Program/debug via Serial Wire Debug."""

    usb = new USB2_0
    """USB 2.0 Full-Speed device."""

    hse = new XtalIF
    """High-speed external crystal oscillator."""

    lse = new XtalIF
    """Low-speed external crystal (32.768 kHz for RTC)."""

    # ===================================================================
    # Muxed peripheral interfaces
    # ===================================================================

    # --- I2C1: 2 configs, 2 wires (SCL, SDA) ---
    i2c1 = new I2C
    """I2C1 with alternate pin configurations."""

    i2c1_mux = new PinMuxSelector<configs=2, width=2, default_config=0>
    """
    I2C1 pin mux:
      config 0: PB6(SCL), PB7(SDA)  — default
      config 1: PB8(SCL), PB9(SDA)  — remap
    """

    # Config 0: PB6 (SCL), PB7 (SDA)
    i2c1_mux.config_pins[0] ~ gpio_b[6].line
    i2c1_mux.config_pins[1] ~ gpio_b[7].line

    # Config 1: PB8 (SCL), PB9 (SDA)
    i2c1_mux.config_pins[2] ~ gpio_b[8].line
    i2c1_mux.config_pins[3] ~ gpio_b[9].line

    # Connect I2C signals through the mux
    i2c1.scl.line ~ i2c1_mux.peripheral_pins[0]
    i2c1.sda.line ~ i2c1_mux.peripheral_pins[1]

    # --- I2C2: only one option, no mux needed ---
    i2c2 = new I2C
    """I2C2 on PB10(SCL)/PB11(SDA) — no remap available."""
    i2c2.scl ~ gpio_b[10]
    i2c2.sda ~ gpio_b[11]

    # --- Convenience: "give me an I2C" ---
    i2c = new I2C[2]
    """Connect to i2c[0] or i2c[1] — don't worry about which peripheral."""
    i2c[0] ~ i2c1
    i2c[1] ~ i2c2

    # --- USART1: 2 configs, 2 wires (TX, RX) ---
    usart1 = new UART
    """USART1 with alternate pin configurations."""

    usart1_mux = new PinMuxSelector<configs=2, width=2, default_config=0>
    """
    USART1 pin mux:
      config 0: PA9(TX), PA10(RX)   — default
      config 1: PB6(TX), PB7(RX)    — remap (CONFLICTS with I2C1 config 0!)
    """

    # Config 0: PA9 (TX), PA10 (RX)
    usart1_mux.config_pins[0] ~ gpio_a[9].line
    usart1_mux.config_pins[1] ~ gpio_a[10].line

    # Config 1: PB6 (TX), PB7 (RX) — same pins as I2C1 config 0!
    usart1_mux.config_pins[2] ~ gpio_b[6].line
    usart1_mux.config_pins[3] ~ gpio_b[7].line

    # Connect UART signals through the mux
    usart1.base_uart.tx.line ~ usart1_mux.peripheral_pins[0]
    usart1.base_uart.rx.line ~ usart1_mux.peripheral_pins[1]

    # --- USART2: only one option on LQFP48 ---
    usart2 = new UART
    """USART2 on PA2(TX)/PA3(RX) — no remap on LQFP48."""
    usart2.base_uart.tx ~ gpio_a[2]
    usart2.base_uart.rx ~ gpio_a[3]

    # --- Convenience: "give me a UART" ---
    uart = new UART[2]
    """Connect to uart[0] or uart[1] — don't worry about which peripheral."""
    uart[0] ~ usart1
    uart[1] ~ usart2

    # --- SPI1: 2 configs, 3 wires (SCK, MISO, MOSI) ---
    spi1 = new SPI
    """SPI1 with alternate pin configurations."""

    spi1_mux = new PinMuxSelector<configs=2, width=3, default_config=0>
    """
    SPI1 pin mux:
      config 0: PA5(SCK), PA6(MISO), PA7(MOSI)  — default
      config 1: PB3(SCK), PB4(MISO), PB5(MOSI)  — remap
    """

    # Config 0: PA5 (SCK), PA6 (MISO), PA7 (MOSI)
    spi1_mux.config_pins[0] ~ gpio_a[5].line
    spi1_mux.config_pins[1] ~ gpio_a[6].line
    spi1_mux.config_pins[2] ~ gpio_a[7].line

    # Config 1: PB3 (SCK), PB4 (MISO), PB5 (MOSI)
    spi1_mux.config_pins[3] ~ gpio_b[3].line
    spi1_mux.config_pins[4] ~ gpio_b[4].line
    spi1_mux.config_pins[5] ~ gpio_b[5].line

    # Connect SPI signals through the mux
    spi1.sclk.line ~ spi1_mux.peripheral_pins[0]
    spi1.miso.line ~ spi1_mux.peripheral_pins[1]
    spi1.mosi.line ~ spi1_mux.peripheral_pins[2]

    # --- SPI2: only one option ---
    spi2 = new SPI
    """SPI2 on PB13(SCK)/PB14(MISO)/PB15(MOSI) — no remap."""
    spi2.sclk ~ gpio_b[13]
    spi2.miso ~ gpio_b[14]
    spi2.mosi ~ gpio_b[15]

    # --- Convenience: "give me a SPI" ---
    spi = new SPI[2]
    """Connect to spi[0] or spi[1] — don't worry about which peripheral."""
    spi[0] ~ spi1
    spi[1] ~ spi2

    # ===================================================================
    # Decoupling capacitors
    # ===================================================================

    decoupling_power_3v3_100nF = new Capacitor[3]
    for cap in decoupling_power_3v3_100nF:
        cap.capacitance = 100nF +/- 20%
        cap.package = "0402"
        power_3v3.hv ~> cap ~> power_3v3.lv

    decoupling_power_3v3_4p7uF = new Capacitor
    decoupling_power_3v3_4p7uF.capacitance = 4.7uF +/- 20%
    decoupling_power_3v3_4p7uF.package = "0402"
    power_3v3.hv ~> decoupling_power_3v3_4p7uF ~> power_3v3.lv

    decoupling_power_analog_1uF = new Capacitor
    decoupling_power_analog_1uF.capacitance = 1uF +/- 20%
    decoupling_power_analog_1uF.package = "0402"
    power_analog.hv ~> decoupling_power_analog_1uF ~> power_analog.lv

    decoupling_power_analog_100nF = new Capacitor
    decoupling_power_analog_100nF.capacitance = 100nF +/- 20%
    decoupling_power_analog_100nF.package = "0402"
    power_analog.hv ~> decoupling_power_analog_100nF ~> power_analog.lv

    decoupling_vbat_100nF = new Capacitor
    decoupling_vbat_100nF.capacitance = 100nF +/- 20%
    decoupling_vbat_100nF.package = "0402"
    vbat.hv ~> decoupling_vbat_100nF ~> vbat.lv

    # ===================================================================
    # Package power connections
    # ===================================================================

    package.VDD_1 ~ power_3v3.hv
    package.VDD_2 ~ power_3v3.hv
    package.VDD_3 ~ power_3v3.hv
    package.VSS_1 ~ power_3v3.lv
    package.VSS_2 ~ power_3v3.lv
    package.VSS_3 ~ power_3v3.lv

    package.VDDA ~ power_analog.hv
    package.VSSA ~ power_analog.lv

    package.VBAT ~ vbat.hv
    vbat.lv ~ power_3v3.lv

    # ===================================================================
    # Fixed interface pin assignments
    # ===================================================================

    # SWD debug (always PA13/PA14)
    swd.dio ~ gpio_a[13]
    swd.clk ~ gpio_a[14]

    # USB Full-Speed (always PA11/PA12)
    usb.usb_if.d.n ~ gpio_a[11]
    usb.usb_if.d.p ~ gpio_a[12]

    # ===================================================================
    # Crystal connections
    # ===================================================================

    hse.xin ~ package.PD0_OSC_IN
    hse.xout ~ package.PD1_OSC_OUT
    hse.gnd ~ power_3v3.lv

    lse.xin ~ package.PC14_OSC32_IN
    lse.xout ~ package.PC15_OSC32_OUT
    lse.gnd ~ power_3v3.lv

    # ===================================================================
    # GPIO-to-package pin mappings
    # ===================================================================

    # Port A
    package.PA0_WKUP ~ gpio_a[0].line
    package.PA1 ~ gpio_a[1].line
    package.PA2 ~ gpio_a[2].line
    package.PA3 ~ gpio_a[3].line
    package.PA4 ~ gpio_a[4].line
    package.PA5 ~ gpio_a[5].line
    package.PA6 ~ gpio_a[6].line
    package.PA7 ~ gpio_a[7].line
    package.PA8 ~ gpio_a[8].line
    package.PA9 ~ gpio_a[9].line
    package.PA10 ~ gpio_a[10].line
    package.PA11 ~ gpio_a[11].line
    package.PA12 ~ gpio_a[12].line
    package.PA13 ~ gpio_a[13].line
    package.PA14 ~ gpio_a[14].line
    package.PA15 ~ gpio_a[15].line

    # Port B
    package.PB0 ~ gpio_b[0].line
    package.PB1 ~ gpio_b[1].line
    package.PB2 ~ gpio_b[2].line
    package.PB3 ~ gpio_b[3].line
    package.PB4 ~ gpio_b[4].line
    package.PB5 ~ gpio_b[5].line
    package.PB6 ~ gpio_b[6].line
    package.PB7 ~ gpio_b[7].line
    package.PB8 ~ gpio_b[8].line
    package.PB9 ~ gpio_b[9].line
    package.PB10 ~ gpio_b[10].line
    package.PB11 ~ gpio_b[11].line
    package.PB12 ~ gpio_b[12].line
    package.PB13 ~ gpio_b[13].line
    package.PB14 ~ gpio_b[14].line
    package.PB15 ~ gpio_b[15].line

    # Port C
    package.PC13_TAMPER_RTC ~ gpio_c[13].line
    package.PC14_OSC32_IN ~ gpio_c[14].line
    package.PC15_OSC32_OUT ~ gpio_c[15].line

    # Port D
    package.PD0_OSC_IN ~ gpio_d[0].line
    package.PD1_OSC_OUT ~ gpio_d[1].line

    # ===================================================================
    # GPIO reference power connections
    # ===================================================================

    for io in gpio_a:
        io.reference ~ power_3v3
    for io in gpio_b:
        io.reference ~ power_3v3
    for io in gpio_c:
        io.reference ~ power_3v3
    for io in gpio_d:
        io.reference ~ power_3v3


# =====================================================================
# Example: sensor board using the mux-enabled F103
# =====================================================================

module Example_JustConnect:
    """
    Just connect your peripherals — the MCU figures out pins for you.

    No need to think about pin assignments. The mux defaults handle it.
    I2C1 → PB6/PB7, USART1 → PA9/PA10, SPI1 → PA5/PA6/PA7.
    """

    power_3v3 = new ElectricPower

    mcu = new ST_STM32F103C8T6_Mux
    power_3v3 ~ mcu.power_3v3

    # "Give me an I2C" — gets I2C1 on default pins
    sensor_i2c = new I2C
    sensor_i2c ~ mcu.i2c[0]

    # "Give me a UART" — gets USART1 on default pins
    gps_uart = new UART
    gps_uart ~ mcu.uart[0]

    # "Give me a SPI" — gets SPI1 on default pins
    flash_spi = new SPI
    flash_spi ~ mcu.spi[0]

    # Need more? Just grab the next one:
    second_i2c = new I2C
    second_i2c ~ mcu.i2c[1]


module Example_JustConnect_WithGPIO:
    """
    Connect peripherals AND grab some GPIOs for LEDs/buttons.

    All pin assignments are automatic via defaults.
    """

    power_3v3 = new ElectricPower

    mcu = new ST_STM32F103C8T6_Mux
    power_3v3 ~ mcu.power_3v3

    # Peripherals — just connect, defaults handle the rest
    sensor_i2c = new I2C
    sensor_i2c ~ mcu.i2c[0]

    gps_uart = new UART
    gps_uart ~ mcu.uart[0]

    # GPIOs — grab specific pins for LEDs, buttons, etc.
    led_pin = new ElectricLogic
    led_pin ~ mcu.gpio_c[13]

    button_pin = new ElectricLogic
    button_pin ~ mcu.gpio_a[0]


module Example_OverrideRemap:
    """
    Override a default: remap I2C1 to PB8/PB9 to free PB6/PB7.

    Most peripherals use defaults, but I2C1 is explicitly remapped.
    """

    power_3v3 = new ElectricPower

    mcu = new ST_STM32F103C8T6_Mux
    power_3v3 ~ mcu.power_3v3

    # I2C sensor — override to remap pins (PB8/PB9 instead of PB6/PB7)
    sensor_i2c = new I2C
    sensor_i2c ~ mcu.i2c1
    assert mcu.i2c1_mux.selection within 1 to 1

    # UART and SPI use defaults — no assertions needed
    gps_uart = new UART
    gps_uart ~ mcu.uart[0]

    flash_spi = new SPI
    flash_spi ~ mcu.spi[0]

    # SPI1 remap to free PA5-PA7 for ADC use
    assert mcu.spi1_mux.selection within 1 to 1
