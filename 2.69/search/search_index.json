{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p><code>atopile</code> brings the best of software development to the world of hardware design.</p> <p>We're starting with an electronics compiler and a new language called <code>ato</code>. Files with the <code>.ato</code> extension can be used to describe your circuit, and compiles it to netlists that can be laid out and fabricated.</p> <p>The <code>.ato</code> files are human readable and can be version controlled, so you can collaborate with your team on the design of your hardware. They're modular, so you can reuse components from other projects, and share them with the community. They provide a way to save the intelligence of your design and the validation required to make sure it works as intended, so you can be confident that your design will work as expected.</p>"},{"location":"#overview","title":"Overview","text":"<ol> <li> <p>Install tools: See the install section below.</p> </li> <li> <p>Project Setup: For instructions on creating a new ato project from the command line, refer to ato create). Highly recommended to use GitHub to store and version your project.</p> </li> <li> <p>Install Packages: For detailed instructions on finding and installing pre-made packages for your project, refer to the installation guide.</p> </li> <li> <p>Circuit Design with Code: Hook up your circuit features using the expressive <code>ato</code> language, transforming your design ideas into precise, codified representations.</p> </li> <li> <p>Version Control: Commit and merge your features using git, iterating through the design process by repeating the steps of adding features and refining your design.</p> </li> <li> <p>Build and Export: Use <code>ato build</code> to compile your design into a netlist, which can then be imported into KiCAD for layout.</p> </li> <li> <p>Sync and Layout: Import netlist into the linked kicad project. Our packages installed from packages.atopile.io have a linked layout that you can reuse verbatim or as a known good starting point for your design.   Layout reuse in atopile</p> </li> <li> <p>Finalize and Order: Commit and merge your layout changes, then download the CI build of your design to order your custom PCB from JLCPCB.</p> </li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>To run atopile, you will need the atopile compiler, the VSCode extension for syntax highlighting and git credential manager.</p>"},{"location":"#atopile-compiler-with-uv-recommended","title":"atopile compiler \u2014 with <code>uv</code> (recommended)","text":"<p>atopile is published as a python package on pypi. You can install it using <code>uv</code> from your command line.</p> <p>It's dead simple with <code>uv</code> <pre><code>uv tool install atopile\n</code></pre></p> <p>Run <code>ato --version</code> to ensure the install worked. You might need to open a new terminal window for the <code>ato</code> command to be recognized.</p> How do I install <code>uv</code>? <p><code>uv</code> has some dead simple installation instructions here: https://docs.astral.sh/uv/installation/</p> <p>atopile should be installed. You can verify that it worked with the following command which should give you the current version of atopile. <pre><code>ato --version\n</code></pre></p> <p> Getting started with atopile - get setup and build your first project from scratch \u2013  32m \u2013 We have a video of how to install atopile and setup your project here.</p>"},{"location":"#atopile-compiler-for-development","title":"atopile compiler \u2014 for development","text":"<p>atopile can be directly installed from GitHub by cloning the repository into a subfolder of your project root. This could be useful if you want to use the latest version of atopile:</p> <p>Start by making sure you have <code>uv</code> installed on your machine.</p> <pre><code>git clone https://github.com/atopile/atopile.git\n</code></pre> <p>This will create a repository with the latest version of atopile. You can install it using <code>uv</code>:</p> <pre><code>uv sync --dev\n</code></pre> <p>Activate the venv: <pre><code>source .venv/bin/activate\n</code></pre></p>"},{"location":"#vscode-extension-extension-store","title":"VSCode extension - extension store","text":"<p>We recommend using VSCode to run atopile as it will provide syntax highlighting.</p> <p>From VSCode, navigate to the VSCode extensions and install atopile.</p> <p></p> <p>The extension needs to know where your ato compiler's python interpreter is located. There are two ways to do this:</p>"},{"location":"#1-easy","title":"1. - Easy","text":"<p>If <code>ato</code> is in your PATH, the extension will find it automatically.</p>"},{"location":"#2-harder","title":"2. - Harder","text":"<p>If not, you can set the <code>atopile.interpreter</code> setting in your vscode settings to the path of the <code>ato</code> executable. eg. in your <code>settings.json</code> (): <pre><code>{\n    \"atopile.interpreter\": [\"/path/to/the/python/interpreter/used/for/ato\"]\n}\n</code></pre></p> <p>You can find <code>/path/to/the/python/interpreter/used/for/ato</code> by running <code>ato --python-path</code> in your terminal, where <code>ato</code> is available.</p>"},{"location":"#making-a-simple-circuit","title":"Making a simple circuit","text":"<p>To get you started quickly, here is an example of a simple atopile circuit. See the rest of the documentation on how to fully use the atopile language features.</p> <p>Let's build a voltage divider. Start by invoking <code>ato create</code> to create a new project.</p> <p>Once created, open elec/src/your-project.ato and modify it in the following way:</p> your-project.ato <pre><code>from \"generics/resistors.ato\" import Resistor\n\nmodule VoltageDivider:\n    signal top\n    signal out\n    signal bottom\n\n    r_top = new Resistor\n    r_top.footprint = \"R0402\"\n    r_top.value = 100kohm +/- 10%\n\n    r_bottom = new Resistor\n    r_bottom.footprint = \"R0402\"\n    r_bottom.value = 200kohm +/- 10%\n\n    top ~ r_top.p1; r_top.p2 ~ out\n    out ~ r_bottom.p1; r_bottom.p2 ~ bottom\n</code></pre> <p>Now you can build this project and get a voltage divider!</p> <p>Tip</p> <p>The generics library should be installed by default in <code>your-project/.ato/modules/generics</code> directory. If not, run <code>ato install generics</code></p>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":"<p>First of all we really appreciate your interest and involvement in this project.</p> <p>We define some basic rules for the participants of this community:</p> <ul> <li>Be respectful to others</li> <li>Try to help others</li> <li>Be open minded</li> <li>Have fun</li> </ul>"},{"location":"CODING_GUIDELINES/","title":"Coding guidelines","text":""},{"location":"CODING_GUIDELINES/#formatting-linting","title":"Formatting, Linting, ...","text":"<p>Make sure to install all development requirements by running <pre><code>uv sync --dev\n</code></pre></p> <p>Install pre-commit into your repository: <pre><code>pre-commit install\n</code></pre></p> <p>From now on when commiting, <code>pre-commit</code> will run our formatting &amp; linting tools.</p>"},{"location":"CONTRIBUTING/","title":"Contributing guidelines","text":""},{"location":"CONTRIBUTING/#contribution-process","title":"Contribution process","text":"<p>Please follow these steps to make a contribution:</p> <ol> <li>If there is no issue yet, make an issue and follow the instructions of the issue template.</li> <li>Comment on the issue you are going to work on and say you are working on it.</li> <li>Fork our repository and create a branch.</li> <li>Write your code following our coding guidelines and submit your pull request. Be sure to read and follow our pull request guidelines, otherwise it will not be accepted!</li> <li>Wait for your code to be reviewed and address any issues in a timely manner.</li> </ol> <p>We encourage people to review each others pull requests and issues, but please be kind, constructive and respectful to each other!</p>"},{"location":"CONTRIBUTING/#creating-a-new-issue","title":"Creating a new issue","text":"<p>To make it easy for you to fill in all the necessary information, we make use of Github forms.</p> <p>If you find a bug, or want to add or change a feature, go to issues page and follow the steps described there. Please be as elaborate as possible to have the issue resolved as soon as possible. We will add labels to your issue when it's reviewed.</p> <p>When in doubt, ask a question on our Discord community.</p>"},{"location":"CONTRIBUTING/#creating-a-pull-request","title":"Creating a pull request","text":"<p>Like with new issues, we use a template for creating pull requests. Please fill in the template and be elaborate so we can try to merge your pr as soon as possible.</p> <p>Run the Black code formatting tool before creating the pr!! <code>python -m black {source_file_or_directory}</code></p> <p>Be sure there is an issue linked to your pr.</p>"},{"location":"CONTRIBUTING/#labels","title":"Labels","text":"<p>Our labels are divided into three fields for ease of use. The format is as follows where \u23b5 denotes a single space character:</p> <p>\\\u23b5\\:\u23b5\\ <p>A list of labels can be found here</p>"},{"location":"building/","title":"Building your ato project","text":""},{"location":"building/#building-predefined-entry-points","title":"Building predefined entry points","text":"<p>The <code>ato.yaml</code> file can contain predefined build configurations. Those can be defined like so:</p> <p>ato.yml</p> <pre><code>...\nbuilds:\n    default:\n        entry: elec/src/your-project.ato:YourModule\n    build-2:\n        entry: elec/src/your-second-project.ato:YourSecondModule\n...\n</code></pre> <p>The <code>ato build</code> command will build the atopile modules for all of those entry points.</p> <p>For a specific build, you can use the -b or --build option like so: <pre><code>ato build -b build-name\n</code></pre> or <pre><code>ato build --build build-name\n</code></pre></p>"},{"location":"building/#building-a-given-entry-point","title":"Building a given entry point","text":"<p>A given entry point can be built like so from your atopile project directory:</p> <pre><code>ato build elec/src/your-project.ato:YourModule\n</code></pre>"},{"location":"building/#building-given-targets","title":"Building given targets","text":"<p>Those are the targets that can currently be built by atopile:</p> <ul> <li>Netlist (\"netlist\")</li> <li>Bill Of Material (\"bom\")</li> <li>Designator Map (\"designator-map\")</li> <li>Manufacturing Data (\"mfg-data\")</li> <li>Consolidate footprint (\"copy-footprints\")</li> <li>All of the above (\"all\")</li> </ul> <p>The target can be specified with the <code>-t</code> or <code>--target</code> like so:</p> <p><pre><code>ato build -t target-name\n</code></pre> or <pre><code>ato build --target target-name\n</code></pre></p>"},{"location":"ci/","title":"Generation of build outputs","text":"<p>Continuous integration / continuous distribution (CI/CD) is a powerful process to automatically export and deploy your project to production.</p>"},{"location":"ci/#continuous-integration-continuous-distribution","title":"Continuous integration / continuous distribution","text":"<p>Our CI pipeline will automatically generate the following outputs for you:</p> <ul> <li>Gerbers (with githash automatically stamped on it!)</li> <li>BOM</li> <li>Pick and place file</li> </ul> <p>Our template project has an example of a GitHub actions workflow.</p>"},{"location":"ci/#github-actions-artifacts","title":"GitHub actions artifacts","text":"<p>To download the artifacts, go to the github action page, find the pipeline with the commit you are interested in and download the build artifacts from it.</p>"},{"location":"class/","title":"Class, subclass and replace","text":""},{"location":"class/#class-and-subclass","title":"Class and subclass","text":"<p>Like classes in most modern languages, we can subclass and inherit from blocks.</p> <pre><code>module SomeModule:\n    signal some_signal\n    signal gnd\n    some_variable = \"some value\"\n\nmodule SubclassedModule from SomeModule:\n    # inherits all the signals and variables from SomeModule\n    # we don't need to declare the signals again,\n    # but we will replace the value of some_variable\n    some_variable = \"some other value\"\n\nmodule Test:\n    signal gnd\n    # creates an instance of the SubclassedModule\n    subclased_module = new SubclassedModule\n    # connects the some_signal of the SubclassedModule to the gnd of Test\n    subclased_module.gnd ~ gnd\n</code></pre> <p>note: we can subclass a module as a component, but not the other way around. A component is expected to represent a specific component.</p> <p>This subclassing is also useful for creating typed interfaces:</p> <pre><code>interface I2C:\n    signal sda\n    signal scl\n\nmodule SomeModule:\n    i2c = new I2C\n\nmodule Test:\n    a = new SomeModule\n    b = new SomeModule\n    a.i2c ~ b.i2c  # connects both sda and scl in one fell swoop\n</code></pre>"},{"location":"class/#-the-replace-operator","title":"<code>-&gt;</code> the replace operator","text":"<p>This operator allows you to increase the specificity of a block somewhere.</p> <p>Take the following example: 1. You want to create a reusable half-bridge module 2. If you spec the FETs within the module, you can't readily reuse the design in other projects with other FETs 3. If you don't declare the FETs at the bottom level it's a PITA to use, since every time you use it you need to remember to slot the FET in the right spot</p> <p>You want some way to say \"we're putting a FET here, but we'll tell you which FET later\"</p> <p>Subclassing is the way you say what a FET is, the replacement operator gives you the later.</p> <pre><code>component NFET:\n    signal gate\n    signal source\n    signal drain\n\nmodule HalfBridge:\n    signal high\n    signal low\n    signal output\n    signal high_gate\n    signal low_gate\n\n    high_fet = new NFET\n    low_fet = new NFET\n\n    # let's pretend we do something useful here like hook it all up\n\n# some time later... perhaps in another file\n\ncomponent SomeNFET from NFET:\n    footprint = \"TO-220-3_Vertical\"\n    # this isn't a legit package, but you get the idea\n\nmodule MotorController:\n    a = new HalfBridge\n    # ...\n    # replace the fets with a SomeNFET\n    a.high_fet -&gt; SomeNFET\n    a.low_fet -&gt; SomeNFET\n</code></pre>"},{"location":"component_selection/","title":"Automatic selection of components","text":"<p>atopile provides a feature to select basic components automatically - at the moment for <code>Resistor</code>, <code>Capacitor</code> and <code>Inductor</code>. Component selection will happen automatically if your component is an instance of a class (or an instance of a subclass) of <code>Resistor</code>, <code>Capacitor</code> or <code>Inductor</code> from the generics library.</p> <p>The fields that can be used for automatic selection are defined within the generics library. Generally speaking, you will want to set a value and a package to the components you wish to be selected. You are welcome to be more specific by specifying an operating temperature, a rated voltage, etc...</p> <p>If you set a <code>footprint</code> or an <code>mpn</code>, the selection won't happen. See the reason below.</p> How does the compiler know which components to select? <p>We use the \"dunder\" <code>__type__ = \"...\"</code> parameter to figure out if a component should be selected or not. You will notice that this field contains <code>resistor</code> for the <code>Resistor</code> class, <code>capacitor</code> for the <code>Capacitor</code> class, etc... Adding a <code>__type__</code> dunder to other component class won't enable selection of other components though. We will add those manually in the future as we increase the scope of selection to other components.</p>"},{"location":"component_selection/#package-vs-footprint","title":"Package vs Footprint","text":"<p>In atopile, <code>package</code> defines the standardized shape of the component you wish to select. <code>footprint</code> refers to the specific file that will be located on your board layout. Typically, each component will have one unique footprint attached to it, even for components with similar packages. That's why you will want to define the package for the selection to operate and not the footprint.</p>"},{"location":"component_selection/#lock-files","title":"Lock files","text":"<p>Once a component is selected, we store information linked to the selection in the <code>ato-lock.yaml</code> file. This ensures that subsequent builds use the same component, wether they happen locally, in CI or on someone else's computer. Make sure you add the <code>ato-lock.yaml</code> file to your repo to enable this.</p>"},{"location":"component_selection/#component-selection-api","title":"Component selection API","text":"<p>We are in the process of updating the component API. We'll share docs once we have them.</p>"},{"location":"config/","title":"Project configuration","text":""},{"location":"config/#versioning","title":"Versioning","text":"<p>Versions within atopile follow the semantic versioning 2.x schema. See https://semver.org for details Semantic versions may be prefixed with a \"v\", so <code>v1.0.0 == 1.0.0</code></p>"},{"location":"config/#atoyaml-project-config","title":"<code>ato.yaml</code> project config","text":"<p>The <code>ato.yaml</code> is significant indicator for a project:</p> <ol> <li>It marks the root of a project. The <code>ato</code> commands in the CLI is largely dependant upon the <code>ato.yaml</code> to know what project you're referring to.</li> <li>It contains project-level configuration information like where to build from, which layouts have what entry-points</li> <li>Lists project dependencies and the required versions of those dependencies</li> <li>Specifies what compiler version the project is intended to build with</li> </ol>"},{"location":"config/#build-key","title":"<code>build</code> key","text":"<p>This is for build-configuration information.</p> <p>Each key under <code>build:</code> is a layout name, and the value is a list of entry-points for that layout.</p> <p>eg. <pre><code>build:\n  my-build:\n    entry: \"elec/src/demo.ato:Demo\"  # This is the root of the build\n</code></pre></p> <p><code>fail_on_drcs</code> is a boolean value, defaulting to <code>false</code>. If set to <code>true</code>, the build will fail if any DRCs errors are found.</p>"},{"location":"config/#dependencies","title":"Dependencies","text":"<p>Each package listed under the <code>dependencies:</code> key is automatically downloaded and installed for users when they run the <code>ato install</code> command from within a project. These dependencies are anticipated to make the project run.</p> <p>Each dependency may have constraints on its version using the following operators:</p> <p>Assuming dependency says <code>my-package &lt;operator&gt;1.2.3</code> the following table describes whether each of the operators would match.</p> <p>They're in approximate order of usefulness/recommendation</p> Op <code>0.1.1</code> <code>1.1.0</code> <code>1.2.3</code> <code>1.2.4</code> <code>1.3.0</code> <code>1.4.0</code> <code>2.0.0</code> Description <code>^</code> \u2714 \u2714 \u2714 \u2714 &gt;=, up to the next major <code>~</code> \u2714 \u2714 &gt;=, up to the next minor <code>==</code> \u2714 Exactly <code>*</code> \u2714 \u2714 \u2714 \u2714 \u2714 \u2714 \u2714 Any <code>!</code> \u2714 \u2714 \u2714 \u2714 \u2714 \u2714 Not (usually used in combination with others) <p><code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code> all work, but have niche value. If you need to use them, something's probably broken.</p>"},{"location":"config/#compiler-version","title":"Compiler version","text":"<p>eg. <code>ato-version: v0.1.8</code></p> <p>The installed compiler is matched against this value to see if the project is buildable in the current environment.</p> <p>It's matched using either: - <code>~</code> if the installed compiler version <code>&lt;1.0.0</code> - else <code>^</code> (up to the next major)</p> <p>Practically, this means breaking compiler changes are indicated using the minor (eg. <code>0.1.0</code>, <code>0.2.0</code>, <code>0.3.0</code>, <code>0.4.0</code>) until version <code>1.0.0</code>.</p> <p>When you upgrade your compiler with breaking changes, you need to update your project to match the language changes, bumping this version in your project's <code>ato.yaml</code> file</p>"},{"location":"connect/","title":"Come join in","text":""},{"location":"connect/#discord","title":"Discord","text":""},{"location":"development/","title":"Development Guide","text":""},{"location":"development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install atopile via git</li> </ul>"},{"location":"development/#dev-tools","title":"Dev Tools","text":"<p>We recommend VSCode for development. If nothing else, it has heaps of high quality extensions and atopile language support, plus it's what we all use internally - so we know how to configure it for purpose.</p> <p>You should have at minimum: - VSCode - VSCode atopile extension - Python Extension for VSCode</p>"},{"location":"development/#verbosity","title":"Verbosity","text":"<p>You can increase the verbosity of atopile by using the <code>-v</code> of <code>-vv</code> flags, eg. <code>ato -vv build</code></p> <p>Flag Location</p> <p>Flags are placed after the <code>ato</code> command and before the command you want to run. For example, <code>ato -vv build</code> will run the build command with the verbose flag set to the highest level, while <code>ato build -vv</code> will not work.</p>"},{"location":"development/#debugging","title":"Debugging","text":"<p>You can start the CLI in debug mode by using the <code>--debug</code> flag, eg. <code>ato --debug build</code></p> <p>This will run a <code>debugpy</code> server on port <code>5678</code> which you can connect to with the VSCode built-in debugger.</p> <p></p> Syntax highlighting isn't working <p>If you're having trouble with syntax highlighting in the debugger, it might be because VSCode sets up a mapping between the remote and local file paths by default - remove it.</p>"},{"location":"development/#viewer-development","title":"Viewer development","text":""},{"location":"development/#building-the-viewer","title":"Building the viewer","text":"<p>You first need to build the viewer when installing atopile from it's repository directly. First, navigate to the viewer directly:</p> <pre><code>cd src/atopile/viewer\n</code></pre> <p>Then install the node dependencies:</p> <pre><code>npm install\n</code></pre> <p>Finally, build the viewer:</p> <pre><code>npm run build\n</code></pre> <p>This will create a <code>dist</code> directory within the viewer directory. Invoking the <code>ato view</code> command will point the server to it.</p>"},{"location":"development/#dev-viewer-server","title":"Dev viewer server","text":"<p>When working on the viewer, it is quite handy to use the following command to start a dev server:</p> <pre><code>npm run dev\n</code></pre> <p>As you save your work, vite will automatically rebuild your project and advertise it on a local address. Navigate to the address to inspect your work. We recommend running the <code>ato view</code> command from one of your existing projects, so you have a project to look at during development.</p>"},{"location":"doc-strings/","title":"Doc-strings","text":"<p>Doc-strings should be used to add in-code documentation of modules.</p> <p>eg. <pre><code>module MyModule:\n    \"\"\"\n    This is a hiiiiigh quality module!\n    \"\"\"\n</code></pre></p> <p>This documentation not only helps you remember what you did, but also means your package is searchable and useable by others.</p>"},{"location":"first_project/","title":"Creating an ato project","text":""},{"location":"first_project/#project-structure-setup","title":"Project structure setup","text":""},{"location":"first_project/#with-ato-create-recommended","title":"With <code>ato create</code> recommended","text":"<p>To create a project, you can run the command</p> <pre><code>ato create\n</code></pre> <p>This command will start by asking for a name to your project. It will then clone the project template on github. Once created on GitHub, paste your repository URL into the command line. Your project should be up and running!</p> <p>We also added a firmware and mech folder to store 3D designs or firmware associated with your project. Version controlling everything under the same project can be quite handy.</p>"},{"location":"first_project/#manually","title":"Manually","text":"<p>You can create your own project instead of using ato create. Perhaps you will want to setup the project and for it as you create your ato projects. Make sure to follow this project structure:</p> <pre><code>.\n\u251c\u2500\u2500 venv -&gt; (active) virtual environment with python^3.12 and atopile installed\n\u2514\u2500\u2500 your-project\n    \u251c\u2500\u2500 ato.yaml --&gt; definition file for your atopile project\n    \u251c\u2500\u2500 ato-lock.yaml --&gt; file managed by atopile. Used to store automatically selected components + component position in the schematic\n    \u251c\u2500\u2500 elec --&gt; files related to your electrical design\n    \u2502    \u251c\u2500\u2500 src\n    \u2502    \u2502   \u2514\u2500\u2500 file.ato\n    \u2502    \u2514\u2500\u2500 layout\n    \u2502        \u2514\u2500\u2500 default\n    \u2502            \u251c\u2500\u2500 kicad-project.kicad_pro\n    \u2502            \u251c\u2500\u2500 kicad-project.kicad_pcb\n    \u2502            \u251c\u2500\u2500 kicad-project.kicad_sch\n    \u2502            \u2514\u2500\u2500 fp-lib-table\n    \u2514\u2500\u2500 .github/workflows/ci_and_cd.yml file --&gt; useful for running jobs automatically on your repo through github actions\n</code></pre> <p>Tip</p> <p>Our template project contains example code for a github CI workflow to compile your ato files and access your manufacturing files from kicad. Find it here.</p>"},{"location":"first_project/#atoyaml-setup","title":"<code>ato.yaml</code> setup","text":"<p>The root of an ato project is marked by the presence of an <code>ato.yaml</code> file.</p> <p><code>ato.yaml</code> contains some project configuration information like the list of things you want to build. It's similar in concept to a package.json in js/node/npm land.</p> <p>Here's an example:</p> <pre><code># this line defines the version of compiler required to compile the project\nato-version: ^0.0.18\n# those lines define the elements that will be built by the compiler\nbuilds:\n  default:\n    entry: elec/src/your-project.ato:YourProject\n# The compiler version follows semantic versioning. The required version to compile your project can be specified using npm's standard.\n\n# Those lines define the package dependencies that your project might have. You can specify the exact package version you want using semantic versioning.\ndependencies:\n- generics^v1.0.0\n</code></pre> <p>Tip</p> <p>The compiler version follows sementic versioning. The required version to compile your project can be specified using npm's standard. The same applies to your dependencies.</p>"},{"location":"first_project/#building-the-project","title":"Building the project","text":"<p>To test that your project is building, run:</p> <p><code>ato build</code></p> <p>Tip</p> <p><code>ato build</code> will build the default module and kicad layout. You can specify a specific target with:</p> <p><code>ato build --build [name_of_your_build]</code></p> <p>The build name is defined in the <code>ato.yaml</code> file.</p> <p>You should see a build directory appear in your project structure. This is where atopile places the output files generated from compilation.</p>"},{"location":"git/","title":"Version control using git","text":"<p>git is a powerful way to version control your design and one of the key reason we started atopile. If you don't know about git, we strongly recommend learning it. There is a high chance you will end up loving it.</p>"},{"location":"git/#get-stuff-from-the-server-sync","title":"Get stuff from the server / sync","text":"<p>git fetch origin  git pull"},{"location":"git/#make-a-new-branch","title":"Make a new branch","text":"<p><code>git checkout -b &lt;branch-name&gt;</code></p> <p><code>git checkout -b &lt;branch-name&gt; &lt;from-branch&gt;</code></p> <p>eg. <code>git checkout -b mawildoer/new-feature origin/main</code></p>"},{"location":"git/#save-some-work","title":"Save some work","text":"<p>1.</p> <p><code>git add &lt;whatever-you-wanna-save&gt;</code></p> <p><code>git add .</code>  -- save everything I've changed (including perhaps things we forgot to <code>.gitignore</code>)</p> <p>2.</p> <p><code>git commit</code></p> <p><code>git commit -m \"&lt;message-here&gt;\"</code></p>"},{"location":"git/#push-it-back-for-everyone-else","title":"Push it back for everyone else","text":"<p><code>git push</code> works if you didn't spec a \"from\" branch in <code>git checkout -b ...</code></p> <p><code>git push -u origin HEAD</code> always works</p> <p>Will respond with a way to make a branch:</p> <pre><code>remote:\nremote: To create a merge request for mawildoer/dummy-branch, visit:\nremote:   https://gitlab.atopile.io/atopile/servo-drive/-/merge_requests/new?merge_request%5Bsource_branch%5D=mawildoer%2Fdummy-branch\nremote:\nTo gitlab.atopile.io:atopile/servo-drive.git\n</code></pre> <p>Cmd+ on the link to gitlab"},{"location":"how-to/","title":"How-Tos","text":""},{"location":"how-to/#pin-configuration","title":"Pin Configuration","text":"<p>Say you've got <code>SomeIC</code>, which has two signals (<code>configure_me</code> and <code>configure_me_too</code>) to set its I2C address. You want to write a module which supports all these addresses in a simple manner.</p> <p>You can do something like this!</p> <pre><code>module SomeIC:\n    signal configure_me ~ config.bit_0\n    signal configure_me_too ~ config.bit_1\n    # etc... (do power and what not as required)\n\n    # Replace me!\n    config = new _ConfigBase\n    # You could also enforce this with an\n    #   assertion if you really wanted to\n\n\nmodule _ConfigBase:  # &lt;--- Prefixed with the underscore implies private\n    \"\"\"Must be replaced with an actual configuration.\"\"\"\n    power = new Power\n    signal bit_0\n    signal bit_1\n\n\nmodule Config0x70 from _ConfigBase:\n    \"\"\"For selecting address 0x70\"\"\"\n    bit_0 ~ power.gnd\n    bit_1 ~ power.gnd\n\n\nmodule Config0x71 from _ConfigBase:\n    \"\"\"For selecting address 0x71\"\"\"\n    bit_0 ~ power.vdd  # &lt;--- see this bit is now high?\n    bit_1 ~ power.gnd\n\n\n# etc...\n</code></pre> <p>Then, when you go to use <code>SomeIC</code> you can just do:</p> <pre><code>some_ic = new SomeIC\nsome_ic.config -&gt; Config0x70\n</code></pre>"},{"location":"how-to/#make-a-component-with-your-own-footprint","title":"Make a component with your own footprint","text":""},{"location":"how-to/#footprint-files-in-project-recommended","title":"Footprint files in project [recommended]","text":"<p>Footprints are gathered on build, so as long as you place the footprint file within the project's directory, it'll be pulled at build time.</p> <p>To assign a footprint that's stored in your project, you can set <code>footprint = \"&lt;footprint_filename_without_extension&gt;\"</code></p>"},{"location":"how-to/#footprints-that-are-part-of-a-library-not-recommended","title":"Footprints that are part of a library [not recommended]","text":"<p>The reason this approach isn't recommended is that it's not very portable. You're relying upon someone else's system to also have the library installed.</p> <p>If you do want to do this, you can specify the library as well in the footprint field. For example, <code>footprint = \"&lt;library&gt;:&lt;footprint&gt;\"</code></p>"},{"location":"how-to/#attach-pins-in-atopile-to-footprints","title":"Attach pins in atopile to footprints","text":"<p>A pin is attached to a footprint via it's name.</p> <p>For example, if your footprint has a pad named <code>1</code>, your component is expected to have a <code>pin 1</code> as well.</p> <p>Pins can be: - An integer (e.g. <code>pin 1</code>, <code>pin 2</code>, <code>pin 3</code>) - A name (e.g. <code>pin vcc</code>, <code>pin gnd</code>, <code>pin sda</code>, <code>pin scl</code>) - A string (e.g. <code>pin \"1a\"</code>, <code>pin \"2b\"</code>, <code>pin \"3c\"</code>)</p>"},{"location":"how-to/#something-not-here","title":"Something not here?","text":"<p>If you're looking for a how-to that isn't here, please ask us on Discord or open an issue on GitHub!</p>"},{"location":"import/","title":"Imports","text":"<p>You can import assets by specifying what you want to import and where you want to import it from using the following syntax within your <code>.ato</code> files:</p> <p><code>from \"where.ato\" import What, Why, Wow</code></p> <p>Notes on that statement: - add quotes on the \"where.ato\" - it's a string - <code>What</code>, <code>Why</code> and <code>Wow</code> are capitalised because they are in the source file. It has to match precisely - it's a type and types should be capitalised, though this isn't enforced and you can import things other than types from other files</p> <p>The import statements are with respect to the current project (the root of which is where your <code>ato.yaml</code> is placed), or within the standard library (<code>.ato/modules/</code>)</p> <p>Warning</p> <p>You'll likely see import statements in the form of <code>import XYZ from \"abc.ato\"</code>. This is a legacy syntax and will be removed in the future. Please use the new syntax.</p> <p>It also doesn't support importing multiple things on the same line.</p>"},{"location":"install/","title":"Install dependencies","text":""},{"location":"install/#components","title":"Components","text":""},{"location":"install/#installing-components-from-jlcpcb","title":"Installing components from JLCPCB","text":"<p>Here is an example on how to install the RP2040 chip from JLCPCB:</p> <p><code>ato install --jlcpcb C2040</code></p> <p>The command will add your footprint and 3D representation to the KiCAD library (named lib in your folder structure) and create an ato file of the component in the elec/src directory.</p>"},{"location":"install/#adding-components-manually","title":"Adding components manually","text":"<p>See Make a component with your own footprint</p>"},{"location":"install/#packages","title":"Packages","text":""},{"location":"install/#browsing-packages","title":"Browsing packages","text":"<p>The atopile package registry contains a list of existing ato packages. Packages usually contain components, module footprints, and layouts that can be reused in other projects.</p> <p>A package usually points to a git repository that contains the design files, in a similar fashion to a standard atopile project.</p> <p>See an example of a package with the generics library.</p>"},{"location":"install/#installing-packages","title":"Installing packages","text":""},{"location":"install/#install-from-the-package-manager-recommended","title":"Install - from the package manager recommended","text":"<p>To install a package, run the following command:</p> <p><code>ato install &lt;your-package-name&gt;</code></p> <p>The package will be added in the .ato/modules/your-package-name directory. It's installed just like existing git repositories that means you can make changes to it and push those changes back to the remote, if you have permissions to do so.</p>"},{"location":"install/#install-from-a-git-repo","title":"Install - from a git repo","text":"<p>To install a package from a git repository, run the following command:</p> <p><code>ato install &lt;your-repository-url&gt;</code></p> <p>The package will be added will be added to your dependencies in a similar fashion than the procedure above. See below for the procedure to specify a specific package.</p>"},{"location":"install/#upgrading-packages-version-management","title":"Upgrading packages &amp; version management","text":"<p>You can pull the latest packages by running:</p> <p><code>ato install --upgrade</code></p> <p>This will pull the latest tag version for the packages. If you wish to further specify which version of the package you'd like to install, you can use semantic versioning in the <code>ato.yaml</code> file. For example, you can request the highest available version of the generics package 1.x.x:</p> <p>ato.yml</p> <pre><code>...\ndependencies:\n- generics^v1.0.0\n</code></pre> <p>Tip</p> <p>The compiler version follows sementic versioning. The required version of your dependencies can be specified using npm's standard.</p>"},{"location":"install/#adding-packages","title":"Adding packages","text":"<p>The top of the atopile package registry contains a form to add packages. Add the name and the link to the git repository (GitLab or GitHub for example) and click submit. Your package should now be available to the community!</p>"},{"location":"install/#adding-custom-footprints","title":"Adding custom footprints","text":"<p>In cases where you can't find the footprint that you'd want to use on JLCPCB or in the atopile package registry, you can also add it manually. KiCAD has a library of footprints you can use on GitLab (those should be installed locally already if you opt-in to install the default library when installing KiCAD, which we recommend you do). From there, you have two options:</p> <p>Add the footprint to your ato project</p> <p>If you have a footprint selected, you can move it to your <code>atopile</code> project in the <code>elec/footprints/footprint.pretty</code> directory. From your component, you can point to that footprint. You also need to connect the footprint pads to signals that you will use throughout your project. For example, if the footprint is called <code>my_footprint.kicad_mod</code> and the pads <code>PAD1</code> and <code>PAD2</code>:</p> <pre><code>component MyComponent:\n    footprint = \"my_footprint\"\n    signal in ~ pin PAD1\n    signal out ~ pin PAD2\n</code></pre> <p>Use footprints from the kicad default library</p> <p>The procedure would be the same as the one outlined above except that you don't have to add the footprint to the atopile <code>elec/footprints/footprint.pretty</code> directory. KiCAD will find it in it's own default library. This will only work if the KiCAD has the default library installed.</p> How to inspect your footprints? <p>To inspect a footprint, you can use KiCAD's footprint editor</p> <p></p> <p>You can also inspect the file itself and find the pads. Here is what they look like: <code>(pad \"1\" smd roundrect (at -0.48 0) (size 0.56 0.62) (layers \"F.Cu\" \"F.Paste\" \"F.Mask\") (roundrect_rratio 0.25) (tstamp f0d6bdbe-8dea-4984-9c52-f76168ceed26))</code></p> How to draw new footprints that aren't in existing libraries? <p>KiCAD provides documentation on how to draw custom footprints here.</p>"},{"location":"kicad/","title":"KiCAD layout","text":""},{"location":"kicad/#kicad-installation","title":"KiCAD installation","text":"<p>To use atopile, you will need to install KiCAD. You can find it on KiCAD's official website.</p>"},{"location":"kicad/#import-netlist-into-kicad","title":"Import netlist into KiCAD","text":"<p>Follow this procedure to import a netlist into KiCAD:</p> <ol> <li>File -&gt; Import Netlist </li> <li>Select the netlist you've just generated. The output is in the terminal, but it should approximately be servo-drive/build/servo-drive.net</li> <li>Make sure you're using unique IDs, rather than designators (though they should work too)</li> <li>Ruthlessly destroy stuff that's not supposed to be there (check boxes on the right) </li> <li>Check the errors - sometimes it's important</li> </ol> <p>In case you want to setup your own project, we have prepared a template with sample <code>ato</code> code and KiCAD project. Find it here.</p> <p>Tip</p> <p>KiCAD needs to know where to look for the project's footprint. The <code>fp-lib-table</code> file points it to <code>build/footprints/footprints.pretty</code> which contains all the footprints. Make sure that is the case under preferences&gt;manage footprint libraries. It should look like this: </p>"},{"location":"kicad/#layout-reuse","title":"Layout reuse","text":"<p>atopile allows you to reuse the layouts that are defined in your dependencies. You will need the atopile KiCAD plugin installed which should happen automatically when installing the atopile cli. You should see those three buttons at the top of your KiCAD interface.</p> <p></p> <p>Don't see the three buttons at the top?</p> <p>If you don't see the three buttons at the top of the screen, one of two things happened:      1. You declined the option to do so during installation     2. There was an issue in the system configuration script.  You can attempt to reinstall the plugin by running <code>ato configure</code> on your command line.</p> <p> atopile Layout Reuse \u2013  3m \u2013 atopile Layout Reuse.</p>"},{"location":"kicad/#steps","title":"Steps","text":"<p>1) Start by adding a module to your project using <code>ato install</code>.</p> <p>2) Add an instance of that package's module to your project and build the project</p> <p>3) Open your project's KiCAD layout and import the netlist</p> <p>4) Click the Reload Group button. This will recognize the modules that are in your layout and group them.</p> <p>5) Select the group that you want to apply the auto layout on.</p> <p>6) Click the Download button. This will apply the layout to that group.</p> <p>Groups will look like that:</p> <p></p> <p>Try it out with the RP2040 module!</p>"},{"location":"kicad/#button-function","title":"Button function","text":"<p> Download button: This button will apply the layout that is defined in your dependency to your current layout.</p> <p> Upload button: This button will save your current layout to the your module. This is useful if you have a module in your current layout that you would like to save in the module and share with other projects.</p> <p> Reload button: This button will create groups of components following the dependencies that you added for your project.</p>"},{"location":"kicad/#how-it-actually-works","title":"How it actually works","text":"<p>As you build your project, a <code>manifest.json</code> is created in the build directory. The manifest links your KiCAD pcb layout file to a <code>&lt;your-project&gt;.layouts.json</code>. This file lists out all the modules that are in your layout and the map of the unique IDs in the current project to the ones in the dependency that you are trying to pull the layout from. It also provides the address of where the layout reuse is located.</p>"},{"location":"maths/","title":"Units and tolerances, assertions and maths","text":"<p>Remember how NASA slung a rocket straight into Mars because of a metric/imperial boo boo?</p> <p>How about we don't do that again.</p>"},{"location":"maths/#units","title":"Units","text":"<p>Resistors's resistances must be a resistance; whether <code>1.23\u03a9</code> (option+Z on OSx), <code>1.23ohm</code>, <code>4.56Kohm</code>, <code>7.89Mohm</code> or similar.</p> <p>Any attribute of any block may have a unit attached written (without a space) after any number.</p> <p>Unsurprisingly, caps capacitances need to be a capacitance; eg. <code>23.4uF</code>, various limits in volts, amperes, degrees and so on.</p> <p>Add units.</p>"},{"location":"maths/#tolerances","title":"Tolerances","text":"<p>Another unfamiliar first-class language feature when dealing with the physical world is the ability (and generally requirement) to spec tolerances for attributes.</p> <p>You could try find a <code>10k\u03a9</code> resistor, but my money says you won't - it'll likely be at least <code>10k\u03a9 +/- 0.1%</code> (which you can write!)</p> <p>Tolerances can be written in the forms of: - <code>1V to 2V</code> - <code>3uF +/- 1uF</code> - <code>4Kohm +/- 1%</code></p> <p>These are hopefully sufficiently intuitive as to not warrant further explanation \ud83e\udd1e</p>"},{"location":"maths/#units-and-tolerances","title":"Units and Tolerances","text":"<p>With Units and Tolerances together, we can define Physical attributes.</p> <p>There's quite a few legal ways to combine them!</p> <ul> <li><code>3V to 3.6V</code> perhaps for a supply rail</li> <li><code>3V +/- 10mV</code> maybe for a reference</li> <li><code>4.7uF +/- 20%</code> for a generic cap</li> <li>even <code>25lb +/- 200g</code> \ud83e\udd23</li> </ul>"},{"location":"maths/#sweet-so-now-ive-got-all-these-values-around-the-place-what-can-i-do-with-them","title":"Sweet, so now I've got all these values around the place... what can I do with them?","text":"<p> Maths </p> <p>There are two things that atopile can do for you with these values: 1. Check that assertions about their relationships to one another are true 2. Solve systems of constraints based on these relationships for find component values</p> <p>This maths is all done including the units and tolerances, so you can be sure absolutely sure everything always works.</p> <p>Use the <code>assert</code> keyword to apply constraints on the values of attributes to one another.</p> <p>Supported operators are currently <code>&lt;</code>, <code>&gt;</code> and <code>within</code> (all are inclusive of the bounds).</p> <pre><code>a = 1 \u00b1 0.1\nb = 2 \u00b1 0.2\nc: resistance  # variable declaration without assignment\n\nassert a &lt; b  # always true before 0.9 and 1.1 (the bounds of a) are both lower than the bounds of b (1.8 and 2.2)\nassert a &gt; b  # always false --&gt; Will yield a failure at compile time\nassert c within 1Kohm to 10Kohm  # first solved for, then the solution is independently checked at the end of the build\n</code></pre>"},{"location":"maths/#assertion-checking","title":"Assertion checking","text":"<p>Who else has had conversations along the lines of \"Is it cool if I tweak the value of this resistor?\" \"Uhh... good question! I think so?\".</p> <p>Well, do we have a treat for you (both the person asking and the person being asked)!</p> <p>atopile will check all the assertions in your design for you - giving you a heap more freedom to play with the values of things, knowing your computer is taking care of checking it for you.</p> <p></p>"},{"location":"maths/#solving","title":"Solving","text":"<p>I'm not sure about you, but I (Matt) am pretty dumb and don't love working too hard. Perhaps you've got a better method, but generally when I'm trying to find resistor values for something even as simple as a voltage divider, I guess one that seems approximately right, then calculate the other - giving me something that doesn't exist, before finally checking through a few other options close-by until finding a pair that works.</p> <p>This is fine and dandy as long as you only care about the ratio of a voltage divider, but as soon as you need to check what that does for your regulators output voltage? Ergh, fine! What about the extremes of the tolerances on those resistors? Fine I'll do it once - but I swear if someone goes to tweak those values for whatever reason, I am unlikely to be pleased.</p> <p>So, let's get atopile to do it for us!</p> <p>atopile will automatically solve systems of constraints for you with free variables, and check that the values of attributes are within their tolerances.</p> <p></p>"},{"location":"maths/#all-together-now","title":"All together now!","text":"<p>The below script demos a little of how you might actually use these features in a real-world scenario.</p> <p>Which produces:</p> <p></p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>What the atopile core team are planning to make of this project and approximately how we're planning to get there.</p>"},{"location":"roadmap/#near-term-features","title":"Near-term Features","text":"<p>Within each category, the features are listed in approximate order of priority.</p> <p>The top-level features themselves are too, but we'll tackle the basics of some domains before the more advanced features of others.</p> <p>There's a lot to come</p> <p>This is a living document, not making promises, but it's a good place to start if you're interested in what's coming up. Additionally, there's a lot (more than not) that's not here yet, either because we haven't articulated it yet, and because this page would be enormous if we did.</p>"},{"location":"roadmap/#reuse","title":"Reuse","text":""},{"location":"roadmap/#language-features","title":"Language Features","text":"<ul> <li> Inheritance <code>from</code></li> <li> Retyping / Replacement <code>-&gt;</code></li> <li> Physical units <code>10kOhm</code> <code>1uF</code></li> <li> Tolerances <code>10kOhm +/- 1%</code></li> <li> Equations / Expressions; relate the parameters of components to specs and solve at compile time</li> <li> Composition / Traits</li> <li> Typing; what is allowed to or must be connected to what?</li> </ul>"},{"location":"roadmap/#component-selection","title":"Component Selection","text":"<ul> <li> MVP select jelly-beans from JLCPCB</li> <li> Move component database to cloud in order to support more components and component types</li> </ul>"},{"location":"roadmap/#quality-control","title":"Quality Control","text":"<ul> <li> Generate gerbers in CI</li> <li> Lock files (ensuring consistent builds)</li> <li> DRC in CI</li> <li> Check source code and layouts are in sync</li> </ul>"},{"location":"roadmap/#package-management","title":"Package Management","text":"<ul> <li> MVP -&gt; https://packages.atopile.io/</li> <li> Search function</li> <li> Package details page</li> <li> Package statistics</li> <li> Authentication for uploading packages</li> </ul>"},{"location":"roadmap/#dev-tools","title":"Dev tools","text":"<ul> <li> VSCode extension</li> <li> VSCode basic language server (goto definition)</li> <li> Linting</li> <li> Schematic viewer; imagine side-by-side with the code</li> <li> KiCAD extension</li> </ul>"},{"location":"roadmap/#non-goals","title":"Non-goals","text":"<p>Things we don't have planned out.</p> <ul> <li>GUI editor</li> <li>No compatibility with <code>xyz</code> ECAD tool: it takes away from the core of the project; to fundamentally change how hardware engineers work. Currently integrated tools are largely seen as stepping stones away from the explicit interfaces of the past.</li> </ul>"},{"location":"spin/","title":"SPIN","text":"<p>SPIN is a BLDC motor controller using the SimpleFOC library. Designed as a reference project, hopefully serving as a starting point for your own projects with motor control!</p> <p></p>"},{"location":"spin/#specs","title":"Specs","text":"<ul> <li>3-phase BLDC nema 17 motor</li> <li>12-24V power supply</li> <li>2A continuous current, 5A peak current</li> <li>14bit magnetic encoder (0.02\u00b0 resolution)</li> </ul>"},{"location":"spin/#features","title":"Features","text":"<ul> <li>XT30 power connector (x2 for daisy chaining)</li> <li>JST-GH 4-pin CAN bus connector (x2 for daisy chaining)</li> <li>Stemma/Qwiic I2C connector</li> <li>Addressable RGB LEDs for status indication</li> <li>USB-C for programming and debugging</li> </ul>"},{"location":"spin/#roadmap","title":"Roadmap","text":"<p>Second version of the board is currently in manufacturing to add CAN bus and I2C communication.</p> <ul> <li> Power supply bring-up</li> <li> Open loop velocity control</li> <li> Closed loop current control</li> <li> Position control with magnetic encoder</li> <li> CAN bus control (position, velocity, current)</li> <li> CAN bus motion profile</li> <li> I2C communication</li> <li> Enumeration with multiple devices</li> </ul>"},{"location":"spin/#documentation","title":"Documentation","text":"<p>Interested in building your own SPIN or helping out with the project? Check out the repo and discord for more information on how to get started!</p>"},{"location":"swoop/","title":"Swoop","text":"<p>Swoop is an open-source motion based flight controller for drones. It uses an IMU to generate commanded yaw, pitch, and roll angles, and sends these commands to the flight controller over ExpressLRS.</p> <p></p>"},{"location":"swoop/#specs","title":"Specs","text":"<ul> <li>9-axis IMU (mag, gyro, accel)</li> <li>RP2040 (sensor fusion, throttle, status indication)</li> <li>ESP32 S3 (ExpressLRS)</li> <li>SX1280 transceiver (compatible with ExpressLRS)</li> <li>Powered by 1000mah internal LiPo battery (~ 4hrs of flight time)</li> </ul>"},{"location":"swoop/#block-diagram","title":"Block Diagram","text":""},{"location":"swoop/#features","title":"Features","text":"<ul> <li>Status LEDs</li> <li>USB-C for programming and debugging</li> <li>hall-sensor for throttle control</li> </ul>"},{"location":"swoop/#roadmap","title":"Roadmap","text":"<p>Second version of the board is currently in manufacturing to add CAN bus and I2C communication.</p> <ul> <li> Power supply bring-up</li> <li> Battery charging circuit bring-up</li> <li> IMU bringup</li> <li> IMU calibration</li> <li> IMU sensor fusion</li> <li> ExpressLRS integration (FLRC)</li> <li> Binding with ExpressLRS receivers</li> <li> Add display and buttons for ExpressLRS configuration</li> </ul>"},{"location":"swoop/#initial-testing","title":"Initial Testing","text":""},{"location":"swoop/#documentation","title":"Documentation","text":"<p>Interested? We are looking for collaborators! Check out the repo and discord for more information on how to get started!</p>"},{"location":"types/","title":"Basic types &amp; Connections","text":"<p>There's a handful of major types that you'll use in your <code>.ato</code> files, falling into two categories: blocks and nodes.</p> <p>Blocks represent something that can contain other things. They provide an abstraction over their contents. For example, a block could be a power supply chip and all the passive components around it.</p> <p>Nodes are elements you can connect to.</p> <p>Block types are: - <code>component</code> - represents exactly one component - <code>module</code> - a collection of components and other modules - <code>interface</code> - walks the line between a block and a node. It's a connectable block that lets you connect multiple nodes at a time</p> <p>Node types are: - <code>pin</code> - represents a physical pin/pad on a package - <code>signal</code> - represents a logical signal that can be connected to other signals</p>"},{"location":"types/#block-definition","title":"Block definition","text":""},{"location":"types/#components","title":"Components","text":"<p>Here is an example of a block (in this case, a <code>component</code>) created within a file named <code>resistor.ato</code>:</p> <pre><code>component Resistor:\n    signal p1  # declare a signal named \"p1\"\n    p1 ~ pin 1  # connect that \"p1\" signal with pin 1\n    signal p2 ~ pin 2  # declare a signal named \"p2\" and connect it with pin 2 in one line\n    footprint = \"R0402\"\n</code></pre>"},{"location":"types/#footprints-for-resistors-and-capacitors","title":"Footprints for resistors and capacitors","text":"<p>For convenience, the footprints for resistors and caps can be defined like so</p> Package Resistor footprint Capacitor footprint 01005 R01005 C01005 0201 R0201 C0201 0402 R0402 C0402 0603 R0603 C0603 0805 R0805 C0805 1206 C1206"},{"location":"types/#modules","title":"Modules","text":"<p>Here is an example of a <code>module</code> definition, in this case a resistor divider:</p> <pre><code>from \"generics/resistors.ato\" import Resistor\n\nmodule YourModule:\n    signal top\n    signal out\n    signal bottom\n\n    r_top = new Resistor\n    r_top.footprint = \"R0402\"\n    r_bottom = new Resistor\n    r_bottom.footprint = \"R0402\"\n\n    top ~ r_top.p1; r_top.p2 ~ out\n    out ~ r_bottom.p1; r_bottom.p2 ~ bottom\n</code></pre> <p>A module can contain an arbitrary amount of components, modules, signals, and interface instances.</p>"},{"location":"types/#interfaces","title":"Interfaces","text":"<p>Here is an example of an <code>interface</code> definition; in this case, a CAN interface</p> <pre><code>interface YourInterface:\n    signal CANH\n    signal CANL\n</code></pre> <p>An interface can contain an arbitrary amount of signals.</p> <p>Interfaces can be connected together with the <code>~</code> operator like so:</p> <pre><code>interface_1 = new YourInterface\ninterface_2 = new YourInterface\n\ninterface_1 ~ interface_2\n</code></pre> <p>Two interfaces can be connected as long as they contain the same signals.</p>"},{"location":"types/#node-definition","title":"Node definition","text":""},{"location":"types/#signal-definition","title":"Signal definition","text":"<p>Signals can be useful as they allow you to name a connection point used throughout your design. Here is an example with a ground signal:</p> <pre><code>signal gnd\n</code></pre> <p>Signals can be connected in the following way:</p> <pre><code>signal enable_pin\nsignal vcc\nenable_pin ~ vcc\n</code></pre>"},{"location":"types/#pin-definition","title":"Pin definition","text":"<p>Pins can be defined in a similar way to signals. Pins are used specifically within components to tie your signals back to your footprints. The pin should have the same name as the copper pads in your footprint.</p> <p>We usually recommend creating a signal within your component and tying it to your pin. That gives you a meaningful signal to connect to instead of an ephemeral pin. For example:</p> <pre><code>signal vcc ~ pin 1\n</code></pre>"},{"location":"view/","title":"atopile viewer","text":"<p>To use the viewer, invoke the <code>ato view</code> cli command:</p> <pre><code>ato view\n</code></pre> <p>If you have multiple build configuration, specify the one you would like to view with:</p> <pre><code>ato view -b &lt;your-build-config-name&gt;\n</code></pre> <p>The viewer will spool up a server on your local machine at http://127.0.0.1:8080.</p>"},{"location":"view/#viewer-interfaces","title":"Viewer interfaces","text":""},{"location":"view/#block-diagram","title":"Block diagram","text":"<p>The block diagram is meant to provide a view that resembles your code structure. In the block diagram view, you will see the same signals and interfaces that are present in your code as well as how they interact with each other. This view will help you navigate through your project and it's structure.</p>"},{"location":"view/#saving-block-position","title":"Saving block position","text":"<p>We currently don't handle saving component position in the block diagram but we'll add this feature shortly. We do support that feature for the schematic though.</p>"},{"location":"view/#schematic","title":"Schematic","text":"<p>The schematic view follows a more standard view of your design. This view can be used for documentation or inspecting a more concrete view of your final circuit. The schematic view can be enabled by navigating with the block diagram to the block you want to inspect and pressing the schematic button. You can switch back to block diagram by pressing the same button.</p> <p>The schematic diagram will represent all the components that are at the level or below the current module.</p>"},{"location":"view/#supported-components","title":"Supported components","text":"<p>For a component to show up on the schematic, it needs to be an instance of a component in the generics library. Here are the current components we support:</p> <ul> <li>Resistor</li> <li>Inductor</li> <li>Capcitor</li> <li>LED</li> <li>Powr</li> <li>NPN</li> <li>PNP</li> <li>Diode</li> <li>SchottkyDide</li> <li>ZeneDiode</li> <li>NFET</li> <li>PFET</li> <li>Opamp</li> </ul> <p>Other larger components will show up as scattered signals that can be moved around to relevant places.</p>"},{"location":"view/#selecting-moving-rotating-mirroring-components","title":"Selecting, moving, rotating, mirroring components","text":"<p>To select a component, simply click on it. To select multiple components, press the cmd/ctrl key while selecting nodes. To rotate, select a component and press the <code>R</code> key. To mirror a signal, you can use the <code>F</code> key (only signals can be mirrored for the moment). To move a component, simply drag and drop it with your mouse.</p>"},{"location":"view/#saving-component-position","title":"Saving component position","text":"<p>As you move components around, the <code>ato-lock.yaml</code> file located in the root of your project will be updated to store the position, rotation angle and mirroring state of components. Make sure to add this file to your git repository if you'd like save those positions. Signals on the schematic can only be mirrored but not rotated. Components can only be rotated in increments of 90 degrees (0, 90, 180, 270) but not mirrored (yet). We don't currently handle saving position in the block diagram.</p>"},{"location":"view/#navigate-within-your-design","title":"Navigate within your design","text":"<p>To navigate within a module or component, simply click on it. return: This button brings you back to the parent module re-layout: This button re-lays out the modules for you schematic/block diagram: Switch between the two viewing modes reload: Loads the latest changes for your code. This feature hasn't been enabled from the block diagram yet.</p>"},{"location":"view/#inspect-links","title":"Inspect links","text":"<p>Clicking on a link in the block diagram will show the source and target address that the link is connection. Those could either be two signals or two compatible instances of an interface.</p>"},{"location":"view/#features-currently-not-supported-but-planned","title":"Features currently not supported (but planned)","text":"<ul> <li>Saving the position of blocks and components</li> <li>Inspecting a links pin to pin connections</li> <li>Expanding and contracting modules (instead of navigating in and out of modules)</li> <li>A decent way to see components and their pins</li> </ul> <p>Join us on discord if you have feedback about the viewer!</p>"},{"location":"yc-hardware-meetup/","title":"Welcome to the Unofficial YC Alum Hardware Reunion!","text":""},{"location":"yc-hardware-meetup/#how-to-reprogram-your-badge","title":"How to reprogram your badge","text":""},{"location":"yc-hardware-meetup/#1-get-an-nfc-tools-app","title":"1. Get an NFC tools app","text":"<p>We recommend using NFC Tools (iOS / Android)</p>"},{"location":"yc-hardware-meetup/#2-get-a-url-you-like","title":"2. Get a URL you like","text":"<p>If you want to use LinkedIn, it can be a good idea to shorten your URL first</p> <p></p> <p>Grab the URL from the app here</p>"},{"location":"yc-hardware-meetup/#3-stick-it-on-the-badge","title":"3. Stick it on the badge","text":"<p>Add a URI/URL record, then write it to the badge.</p> <p></p>"},{"location":"api/cli/","title":"CLI","text":""},{"location":"api/cli/#atopile.cli","title":"atopile.cli","text":""},{"location":"api/cli/#atopile.cli.build","title":"build","text":"<p>CLI command definition for <code>ato build</code>.</p>"},{"location":"api/cli/#atopile.cli.build.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.build.build","title":"build","text":"<pre><code>build(\n    entry=None,\n    build=[],\n    target=[],\n    option=[],\n    frozen=None,\n    keep_picked_parts=None,\n    keep_net_names=None,\n    standalone=False,\n)\n</code></pre> <p>Build the specified --target(s) or the targets specified by the build config. Optionally specify a different entrypoint with the argument ENTRY. eg. <code>ato build --target my_target path/to/source.ato:module.path</code></p> Source code in <code>src/atopile/cli/build.py</code> <pre><code>def build(\n    entry: Annotated[str | None, typer.Argument()] = None,\n    build: Annotated[list[str], typer.Option(\"--build\", \"-b\", envvar=\"ATO_BUILD\")] = [],\n    target: Annotated[\n        list[str], typer.Option(\"--target\", \"-t\", envvar=\"ATO_TARGET\")\n    ] = [],\n    option: Annotated[\n        list[str], typer.Option(\"--option\", \"-o\", envvar=\"ATO_OPTION\")\n    ] = [],\n    frozen: Annotated[\n        bool | None,\n        typer.Option(\n            help=\"PCB must be rebuilt without changes. Useful in CI\",\n            envvar=\"ATO_FROZEN\",\n        ),\n    ] = None,\n    keep_picked_parts: bool | None = None,\n    keep_net_names: bool | None = None,\n    standalone: bool = False,\n):\n    \"\"\"\n    Build the specified --target(s) or the targets specified by the build config.\n    Optionally specify a different entrypoint with the argument ENTRY.\n    eg. `ato build --target my_target path/to/source.ato:module.path`\n    \"\"\"\n    import json\n\n    import atopile.config\n    from atopile import buildutil\n    from atopile.cli.common import create_build_contexts\n    from atopile.config import BuildType\n    from faebryk.library import _F as F\n    from faebryk.libs.exceptions import accumulate, log_user_errors\n    from faebryk.libs.picker import lcsc\n\n    build_ctxs = create_build_contexts(entry, build, target, option, standalone)\n\n    for build_ctx in build_ctxs:\n        if keep_picked_parts is not None:\n            build_ctx.keep_picked_parts = keep_picked_parts\n\n        if keep_net_names is not None:\n            build_ctx.keep_net_names = keep_net_names\n\n        if frozen is not None:\n            build_ctx.frozen = frozen\n            if frozen:\n                if keep_picked_parts is False:  # is, ignores None\n                    raise errors.UserBadParameterError(\n                        \"`--keep-picked-parts` conflict with `--frozen`\"\n                    )\n\n                build_ctx.keep_picked_parts = True\n\n                if keep_net_names is False:  # is, ignores None\n                    raise errors.UserBadParameterError(\n                        \"`--keep-net-names` conflict with `--frozen`\"\n                    )\n\n                build_ctx.keep_net_names = True\n\n    with accumulate() as accumulator:\n        for build_ctx in build_ctxs:\n            logger.info(\"Building '%s'\", build_ctx.name)\n            with accumulator.collect(), log_user_errors(logger):\n                match build_ctx.build_type:\n                    case BuildType.ATO:\n                        app = _init_ato_app(build_ctx)\n                    case BuildType.PYTHON:\n                        app = _init_python_app(build_ctx)\n                        app.add(F.is_app_root())\n                    case _:\n                        raise ValueError(f\"Unknown build type: {build_ctx.build_type}\")\n\n                # TODO: these should be drawn from the buildcontext like everything else\n                lcsc.BUILD_FOLDER = build_ctx.paths.build\n                lcsc.LIB_FOLDER = build_ctx.paths.component_lib\n                lcsc.LIB_FOLDER.mkdir(exist_ok=True, parents=True)\n                lcsc.KICAD_PROJECT_PATH = build_ctx.paths.kicad_project.parent\n\n                # TODO: add a mechanism to override the following with custom build machinery # noqa: E501  # pre-existing\n                buildutil.build(build_ctx, app)\n\n        with accumulator.collect():\n            project_context = atopile.config.get_project_context()\n\n            # FIXME: this should be done elsewhere, but there's no other \"overview\"\n            # that can see all the builds simultaneously\n            manifest = {}\n            manifest[\"version\"] = \"2.0\"\n            for ctx in build_ctxs:\n                if ctx.paths.layout:\n                    by_layout_manifest = manifest.setdefault(\n                        \"by-layout\", {}\n                    ).setdefault(str(ctx.paths.layout), {})\n                    by_layout_manifest[\"layouts\"] = str(\n                        ctx.paths.output_base.with_suffix(\".layouts.json\")\n                    )\n\n            manifest_path = project_context.project_path / \"build\" / \"manifest.json\"\n            manifest_path.parent.mkdir(exist_ok=True, parents=True)\n            with open(manifest_path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(manifest, f)\n\n    logger.info(\"Build successful! \ud83d\ude80\")\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli","title":"cli","text":""},{"location":"api/cli/#atopile.cli.cli.app","title":"app  <code>module-attribute</code>","text":"<pre><code>app = Typer(\n    no_args_is_help=True,\n    pretty_exceptions_enable=bool(FLOG_FMT),\n)\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli.python_interpreter_path","title":"python_interpreter_path","text":"<pre><code>python_interpreter_path(ctx, value)\n</code></pre> <p>Print the current python interpreter path.</p> Source code in <code>src/atopile/cli/cli.py</code> <pre><code>def python_interpreter_path(ctx: typer.Context, value: bool):\n    \"\"\"Print the current python interpreter path.\"\"\"\n    if not value or ctx.resilient_parsing:\n        return\n    typer.echo(sys.executable)\n    raise typer.Exit()\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli.atopile_src_path","title":"atopile_src_path","text":"<pre><code>atopile_src_path(ctx, value)\n</code></pre> <p>Print the current python interpreter path.</p> Source code in <code>src/atopile/cli/cli.py</code> <pre><code>def atopile_src_path(ctx: typer.Context, value: bool):\n    \"\"\"Print the current python interpreter path.\"\"\"\n    if not value or ctx.resilient_parsing:\n        return\n    typer.echo(Path(__file__).parent.parent)\n    raise typer.Exit()\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli.version_callback","title":"version_callback","text":"<pre><code>version_callback(ctx, value)\n</code></pre> Source code in <code>src/atopile/cli/cli.py</code> <pre><code>def version_callback(ctx: typer.Context, value: bool):\n    if not value or ctx.resilient_parsing:\n        return\n    typer.echo(version(\"atopile\"))\n    raise typer.Exit()\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli.cli","title":"cli","text":"<pre><code>cli(\n    ctx,\n    non_interactive=False,\n    debug=False,\n    verbose=0,\n    python_path=False,\n    atopile_path=False,\n    version=None,\n)\n</code></pre> Source code in <code>src/atopile/cli/cli.py</code> <pre><code>@app.callback()\ndef cli(\n    ctx: typer.Context,\n    non_interactive: Annotated[\n        bool, typer.Option(\"--non-interactive\", envvar=\"ATO_NON_INTERACTIVE\")\n    ] = False,\n    debug: Annotated[\n        bool,\n        typer.Option(\"--debug\", help=\"Wait to attach debugger on start\"),\n    ] = False,\n    verbose: Annotated[\n        int,\n        typer.Option(\"--verbose\", \"-v\", count=True, help=\"Increase verbosity\"),\n    ] = 0,\n    python_path: Annotated[\n        bool, typer.Option(hidden=True, callback=python_interpreter_path)\n    ] = False,\n    atopile_path: Annotated[\n        bool, typer.Option(hidden=True, callback=atopile_src_path)\n    ] = False,\n    version: Annotated[\n        bool | None,\n        typer.Option(\"--version\", callback=version_callback, is_eager=True),\n    ] = None,\n):\n    if debug:\n        import debugpy  # pylint: disable=import-outside-toplevel\n\n        debug_port = 5678\n        debugpy.listen((\"localhost\", debug_port))\n        logger.info(\"Starting debugpy on port %s\", debug_port)\n        debugpy.wait_for_client()\n\n    # set the log level\n    if verbose == 1:\n        handler.hide_traceback_types = ()\n        handler.tracebacks_show_locals = True\n    elif verbose == 2:\n        handler.tracebacks_suppress_map = {}  # Traceback through atopile infra\n    elif verbose &gt;= 3:\n        logger.root.setLevel(logging.DEBUG)\n        handler.traceback_level = logging.WARNING\n\n    if ctx.invoked_subcommand:\n        check_for_update()\n\n        # Initialize telemetry\n        telemetry.setup_telemetry_data(ctx.invoked_subcommand)\n\n    if not non_interactive and ctx.invoked_subcommand != \"configure\":\n        configure.do_configure_if_needed()\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli.main","title":"main","text":"<pre><code>main()\n</code></pre> Source code in <code>src/atopile/cli/cli.py</code> <pre><code>def main():\n    app()\n</code></pre>"},{"location":"api/cli/#atopile.cli.common","title":"common","text":"<p>Common CLI writing utilities.</p>"},{"location":"api/cli/#atopile.cli.common.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.common.get_entry_arg_file_path","title":"get_entry_arg_file_path","text":"<pre><code>get_entry_arg_file_path(entry)\n</code></pre> Source code in <code>src/atopile/cli/common.py</code> <pre><code>def get_entry_arg_file_path(entry: str | None) -&gt; tuple[AddrStr | None, Path]:\n    # basic the entry address if provided, otherwise leave it as None\n\n    if entry is None:\n        entry_arg_file_path = Path.cwd()\n    else:\n        entry = AddrStr(entry)\n\n        if address.get_file(entry) is None:\n            raise errors.UserBadParameterError(\n                f\"Invalid entry address {entry} - entry must specify a file.\",\n                title=\"Bad 'entry' parameter\",\n            )\n\n        entry_arg_file_path = (\n            Path(address.get_file(entry)).expanduser().resolve().absolute()\n        )\n\n    return entry, entry_arg_file_path\n</code></pre>"},{"location":"api/cli/#atopile.cli.common.get_project_config","title":"get_project_config","text":"<pre><code>get_project_config(entry_arg_file_path)\n</code></pre> Source code in <code>src/atopile/cli/common.py</code> <pre><code>def get_project_config(entry_arg_file_path: Path) -&gt; atopile.config.ProjectConfig:\n    try:\n        project_config = atopile.config.get_project_config_from_addr(\n            str(entry_arg_file_path)\n        )\n    except FileNotFoundError as ex:\n        # FIXME: this raises an exception when the entry is not in a project\n        raise errors.UserBadParameterError(\n            f\"Could not find project from path {str(entry_arg_file_path)}. \"\n            \"Is this file path within a project?\"\n        ) from ex\n\n    return project_config\n</code></pre>"},{"location":"api/cli/#atopile.cli.common.check_entry_arg_file_path","title":"check_entry_arg_file_path","text":"<pre><code>check_entry_arg_file_path(entry, entry_arg_file_path)\n</code></pre> Source code in <code>src/atopile/cli/common.py</code> <pre><code>def check_entry_arg_file_path(\n    entry: AddrStr | None, entry_arg_file_path: Path\n) -&gt; AddrStr | None:\n    entry_addr_override = None\n\n    if entry:\n        if entry_arg_file_path.is_file():\n            if entry_section := address.get_entry_section(entry):\n                entry_addr_override = address.from_parts(\n                    str(entry_arg_file_path.absolute()),\n                    entry_section,\n                )\n            else:\n                raise errors.UserBadParameterError(\n                    \"If an entry of a file is specified, you must specify\"\n                    \" the node within it you want to build.\",\n                    title=\"Bad 'entry' parameter\",\n                )\n\n        elif entry_arg_file_path.is_dir():\n            pass\n\n        elif not entry_arg_file_path.exists():\n            raise errors.UserBadParameterError(\n                \"The entry you have specified does not exist.\",\n                title=\"Bad 'entry' parameter\",\n            )\n        else:\n            raise ValueError(\n                f\"Unexpected entry path type {entry_arg_file_path} - this should never happen!\"  # noqa: E501  # pre-existing\n            )\n\n    return entry_addr_override\n</code></pre>"},{"location":"api/cli/#atopile.cli.common.check_compiler_versions","title":"check_compiler_versions","text":"<pre><code>check_compiler_versions(config)\n</code></pre> <p>Check that the compiler version is compatible with the version used to build the project.</p> Source code in <code>src/atopile/cli/common.py</code> <pre><code>def check_compiler_versions(config: atopile.config.ProjectConfig):\n    \"\"\"\n    Check that the compiler version is compatible with the version\n    used to build the project.\n    \"\"\"\n    assert config.location is not None\n    dependency_cfgs = (\n        faebryk.libs.exceptions.downgrade(FileNotFoundError)(\n            atopile.config.get_project_config_from_path\n        )(p)\n        for p in config.location.glob(\".ato/modules/**/ato.yaml\")\n    )\n\n    for cltr, cfg in faebryk.libs.exceptions.iter_through_errors(\n        itertools.chain([config], dependency_cfgs)\n    ):\n        if cfg is None:\n            continue\n\n        with cltr():\n            semver_str = cfg.ato_version\n            # FIXME: this is a hack to the moment to get around us breaking\n            # the versioning scheme in the ato.yaml files\n            for operator in version.OPERATORS:\n                semver_str = semver_str.replace(operator, \"\")\n\n            built_with_version = version.parse(semver_str)\n\n            if not version.match_compiler_compatability(built_with_version):\n                raise version.VersionMismatchError(\n                    f\"{cfg.location} ({cfg.ato_version}) can't be\"\n                    \" built with this version of atopile \"\n                    f\"({version.get_installed_atopile_version()}).\"\n                )\n</code></pre>"},{"location":"api/cli/#atopile.cli.common.configure_project_context","title":"configure_project_context","text":"<pre><code>configure_project_context(entry, standalone=False)\n</code></pre> Source code in <code>src/atopile/cli/common.py</code> <pre><code>def configure_project_context(\n    entry: str | None, standalone: bool = False\n) -&gt; tuple[atopile.config.ProjectConfig, atopile.config.ProjectContext]:\n    entry, entry_arg_file_path = get_entry_arg_file_path(entry)\n\n    if standalone:\n        if not entry:\n            raise errors.UserBadParameterError(\n                \"You must specify an entry to build with the --standalone option\"\n            )\n        if not entry_arg_file_path.exists():\n            raise errors.UserBadParameterError(\n                f\"The file you have specified does not exist: {entry_arg_file_path}\"\n            )\n\n        project_config = atopile.config.ProjectConfig(\n            location=Path.cwd(),\n            ato_version=f\"^{version.get_installed_atopile_version()}\",\n            paths=atopile.config.ProjectPaths(\n                layout=Path.cwd() / \"standalone\",\n                src=Path.cwd(),\n            ),\n            builds={\"default\": atopile.config.ProjectBuildConfig(targets=[])},\n        )\n    else:\n        project_config = get_project_config(entry_arg_file_path)\n\n    # Make sure I an all my sub-configs have appropriate versions\n    check_compiler_versions(project_config)\n\n    log.info(\"Using project %s\", project_config.location)\n\n    # Configure project context\n    project_ctx = atopile.config.ProjectContext.from_config(project_config)\n    atopile.config.set_project_context(project_ctx)\n\n    return project_config, project_ctx\n</code></pre>"},{"location":"api/cli/#atopile.cli.common.create_build_contexts","title":"create_build_contexts","text":"<pre><code>create_build_contexts(\n    entry, build, target, option, standalone\n)\n</code></pre> Source code in <code>src/atopile/cli/common.py</code> <pre><code>def create_build_contexts(\n    entry: str | None,\n    build: Iterable[str],\n    target: Iterable[str],\n    option: Iterable[str],\n    standalone: bool,\n) -&gt; list[atopile.config.BuildContext]:\n    entry, entry_arg_file_path = get_entry_arg_file_path(entry)\n\n    config, project_ctx = configure_project_context(entry, standalone)\n\n    # These checks are only relevant if we're **building** standalone\n    # TODO: Some of the contents should be moved out of the project context\n    if standalone:\n        if not entry_arg_file_path.is_file():\n            raise errors.UserBadParameterError(\n                \"The path you're building with the --standalone\"\n                f\" option must be a file {entry_arg_file_path}\"\n            )\n        assert entry is not None  # Handled by configure_project_context\n        if not address.get_entry_section(entry):\n            raise errors.UserBadParameterError(\n                \"You must specify what to build within a file to build with the\"\n                \" --standalone option\"\n            )\n\n    # add custom config overrides\n    if option:\n        raise errors.UserNotImplementedError(\n            \"Custom config overrides have been removed in a refactor. \"\n            \"It's planned to re-add them in a future release. \"\n            \"If this is a blocker for you, please raise an issue. \"\n            \"In the meantime, you can use the `ato.yaml` file to set these options.\"\n        )\n\n    # if we set an entry-point, we now need to deal with that\n    entry_addr_override = check_entry_arg_file_path(entry, entry_arg_file_path)\n\n    # Make build contexts\n    if build_names := build or config.builds.keys():\n        build_ctxs: list[atopile.config.BuildContext] = [\n            atopile.config.BuildContext.from_config_name(config, build_name)\n            for build_name in build_names\n        ]\n    else:\n        build_ctxs = [\n            atopile.config.BuildContext.from_config(\n                \"default\", atopile.config.ProjectBuildConfig(), project_ctx\n            )\n        ]\n\n    for build_ctx in build_ctxs:\n        if entry_addr_override is not None:\n            build_ctx.entry = entry_addr_override\n        if target:\n            build_ctx.targets = list(target)\n\n    return build_ctxs\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure","title":"configure","text":"<p>Configure the user's system for atopile development.</p>"},{"location":"api/cli/#atopile.cli.configure.yaml","title":"yaml  <code>module-attribute</code>","text":"<pre><code>yaml = YAML()\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.CONFIGURED_FOR_PATH","title":"CONFIGURED_FOR_PATH  <code>module-attribute</code>","text":"<pre><code>CONFIGURED_FOR_PATH = absolute()\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.config","title":"config  <code>module-attribute</code>","text":"<pre><code>config = Config()\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.Config","title":"Config","text":""},{"location":"api/cli/#atopile.cli.configure.Config.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version = None\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.Config.install_kicad_plugin","title":"install_kicad_plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>install_kicad_plugin = None\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.get_configured_for_version","title":"get_configured_for_version","text":"<pre><code>get_configured_for_version()\n</code></pre> <p>Return the version of atopile that the user's system is configured for.</p> Source code in <code>src/atopile/cli/configure.py</code> <pre><code>def get_configured_for_version() -&gt; atopile.version.Version:\n    \"\"\"Return the version of atopile that the user's system is configured for.\"\"\"\n    return atopile.version.clean_version(atopile.version.Version.parse(config.version))\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.configure","title":"configure","text":"<pre><code>configure()\n</code></pre> <p>Configure the user's system for atopile development.</p> Source code in <code>src/atopile/cli/configure.py</code> <pre><code>def configure() -&gt; None:\n    \"\"\"\n    Configure the user's system for atopile development.\n    \"\"\"\n    logger.setLevel(logging.INFO)\n    _load_config()\n    do_configure()\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.do_configure_if_needed","title":"do_configure_if_needed","text":"<pre><code>do_configure_if_needed()\n</code></pre> <p>Configure the user's system for atopile development if it's not already configured.</p> Source code in <code>src/atopile/cli/configure.py</code> <pre><code>def do_configure_if_needed() -&gt; None:\n    \"\"\"Configure the user's system for atopile development if it's not already configured.\"\"\"  # noqa: E501  # pre-existing\n    if not CONFIGURED_FOR_PATH.exists():\n        rich.print(\n            dedent(\n                \"\"\"\n            Welcome! :partying_face:\n\n            Looks like you're new to atopile, there's some initial setup we need to do.\n            \"\"\"\n            )\n        )\n\n    _load_config()\n\n    try:\n        if config.version == atopile.version.get_installed_atopile_version():\n            return\n    except TypeError:\n        # Semver appears to do a __req__ by converting the lhs to a type, which\n        # doesn't work for None\n        pass\n\n    # Otherwise we're configured, but we might need to update\n    logger.setLevel(logging.WARNING)  # Quieten output for typical runs\n    do_configure()\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.do_configure","title":"do_configure","text":"<pre><code>do_configure()\n</code></pre> <p>Perform system configuration required for atopile.</p> Source code in <code>src/atopile/cli/configure.py</code> <pre><code>def do_configure() -&gt; None:\n    \"\"\"Perform system configuration required for atopile.\"\"\"\n    if config.install_kicad_plugin is None:\n        config.install_kicad_plugin = questionary.confirm(\n            \":wrench: Install KiCAD plugin?\", default=True\n        ).ask()\n\n    if config.install_kicad_plugin:\n        # FIXME: no idea what's up with this - but seem to help on Windows\n        install_kicad_plugin()\n\n    # final steps\n    config.version = str(\n        atopile.version.clean_version(atopile.version.get_installed_atopile_version())\n    )\n    _save_config()\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.install_kicad_plugin","title":"install_kicad_plugin","text":"<pre><code>install_kicad_plugin()\n</code></pre> <p>Install the kicad plugin.</p> Source code in <code>src/atopile/cli/configure.py</code> <pre><code>def install_kicad_plugin() -&gt; None:\n    \"\"\"Install the kicad plugin.\"\"\"\n    # Find the path to kicad's plugin directory\n    plugin_loader = f\"\"\"\n        plugin_path = r\"{Path(__file__).parent.parent}\"\n        import sys\n        import importlib\n\n        if plugin_path not in sys.path:\n            sys.path.append(plugin_path)\n\n        # if kicad_plugin is already in sys.modules, reload it\n        for module in sys.modules:\n            if \"kicad_plugin\" in module:\n                importlib.reload(sys.modules[module])\n\n        import kicad_plugin\n        \"\"\"\n\n    def _write_plugin(path: Path):\n        # Create the directory if it doesn't exist\n        path.mkdir(parents=True, exist_ok=True)\n\n        # Write the plugin loader\n        plugin_loader_content = dedent(plugin_loader)\n        plugin_loader_path = path / \"atopile.py\"\n\n        logger.info(\"Writing plugin loader to %s\", plugin_loader_path)\n        with plugin_loader_path.open(\"w\", encoding=\"utf-8\") as f:\n            f.write(plugin_loader_content)\n\n    kicad_config_search_path = [\"~/Documents/KiCad/\", \"~/.local/share/kicad/\"]\n    no_plugin_found = True\n    for sp in kicad_config_search_path:\n        config_path = Path(sp).expanduser().resolve()\n        if config_path.exists():\n            for p in config_path.glob(\"*/scripting/plugins\"):\n                try:\n                    _write_plugin(p)\n                except FileNotFoundError:\n                    _write_plugin(p)\n                no_plugin_found = False\n\n    if no_plugin_found:\n        logger.warning(\"KiCAD config path not found. Couldn't install plugin!\")\n</code></pre>"},{"location":"api/cli/#atopile.cli.console","title":"console","text":""},{"location":"api/cli/#atopile.cli.console.console","title":"console  <code>module-attribute</code>","text":"<pre><code>console = get_console()\n</code></pre>"},{"location":"api/cli/#atopile.cli.create","title":"create","text":""},{"location":"api/cli/#atopile.cli.create.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.PROJECT_TEMPLATE","title":"PROJECT_TEMPLATE  <code>module-attribute</code>","text":"<pre><code>PROJECT_TEMPLATE = (\n    \"https://github.com/atopile/project-template\"\n)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.create_app","title":"create_app  <code>module-attribute</code>","text":"<pre><code>create_app = Typer()\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.stuck_user_helper_generator","title":"stuck_user_helper_generator  <code>module-attribute</code>","text":"<pre><code>stuck_user_helper_generator = _stuck_user_helper()\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.ComponentType","title":"ComponentType","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"api/cli/#atopile.cli.create.ComponentType.ato","title":"ato  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ato = auto()\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.ComponentType.fab","title":"fab  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fab = auto()\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.check_name","title":"check_name","text":"<pre><code>check_name(name)\n</code></pre> <p>Check if a name is valid.</p> Source code in <code>src/atopile/cli/create.py</code> <pre><code>def check_name(name: str) -&gt; bool:\n    \"\"\"\n    Check if a name is valid.\n    \"\"\"\n    if re.match(r\"^[a-zA-Z][a-zA-Z0-9_-]*$\", name):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.help","title":"help","text":"<pre><code>help(text)\n</code></pre> <p>Print help text.</p> Source code in <code>src/atopile/cli/create.py</code> <pre><code>def help(text: str) -&gt; None:  # pylint: disable=redefined-builtin\n    \"\"\"Print help text.\"\"\"\n    rich.print(\"\\n\" + textwrap.dedent(text).strip() + \"\\n\")\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.project","title":"project","text":"<pre><code>project(name=None, repo=None)\n</code></pre> <p>Create a new ato project.</p> Source code in <code>src/atopile/cli/create.py</code> <pre><code>@create_app.command()\ndef project(\n    name: Annotated[str | None, typer.Argument()] = None,\n    repo: Annotated[str | None, typer.Option(\"--repo\", \"-r\")] = None,\n):  # pylint: disable=redefined-builtin\n    \"\"\"\n    Create a new ato project.\n    \"\"\"\n\n    # Get a project name\n    kebab_name = None\n    for _ in stuck_user_helper_generator:\n        if not name:\n            rich.print(\":rocket: What's your project [cyan]name?[/]\")\n            name = questionary.text(\"\").unsafe_ask()\n\n        if name is None:\n            continue\n\n        kebab_name = caseconverter.kebabcase(name)\n        if name != kebab_name:\n            help(\n                f\"\"\"\n                We recommend using kebab-case ([cyan]{kebab_name}[/])\n                for your project name. It makes it easier to use your project\n                with other tools (like git) and it embeds nicely into URLs.\n                \"\"\"\n            )\n\n            rich.print(f\"Do you want to use [cyan]{kebab_name}[/] instead?\")\n            if questionary.confirm(\"\").unsafe_ask():\n                name = kebab_name\n\n        if check_name(name):\n            break\n        else:\n            help(\n                \"[red]Project names must start with a letter and\"\n                \" contain only letters, numbers, dashes and underscores.[/]\"\n            )\n            name = None\n\n    assert name is not None\n\n    if (\n        not repo\n        and not questionary.confirm(\n            \"Would you like to create a new repo for this project?\"\n        ).unsafe_ask()\n    ):\n        repo = PROJECT_TEMPLATE\n\n    # Get a repo\n    repo_obj: git.Repo | None = None\n    for _ in stuck_user_helper_generator:\n        if not repo:\n            make_repo_url = f\"https://github.com/new?name={name}&amp;template_owner=atopile&amp;template_name=project-template\"\n\n            help(\n                f\"\"\"\n                We recommend you create a Github repo for your project.\n\n                If you already have a repo, you can respond [yellow]n[/]\n                to the next question and provide the URL to your repo.\n\n                If you don't have one, you can respond yes to the next question\n                or (Cmd/Ctrl +) click the link below to create one.\n\n                Just select the template you want to use.\n\n                {make_repo_url}\n                \"\"\"\n            )\n\n            rich.print(\":rocket: Open browser to create Github repo?\")\n            if questionary.confirm(\"\").unsafe_ask():\n                webbrowser.open(make_repo_url)\n\n            rich.print(\":rocket: What's the [cyan]repo's URL?[/]\")\n            repo = questionary.text(\"\").unsafe_ask()\n\n        assert repo is not None\n\n        # Try download the repo from the user-provided URL\n        if Path(name).exists():\n            raise click.ClickException(\n                f\"Directory {name} already exists. Please put the repo elsewhere or\"\n                \" choose a different name.\"\n            )\n\n        try:\n            repo_obj = git.Repo.clone_from(repo, name, depth=1)\n            break\n        except git.GitCommandError as ex:\n            help(\n                f\"\"\"\n                [red]Failed to clone repo from {repo}[/]\n\n                {ex.stdout}\n                {ex.stderr}\n                \"\"\"\n            )\n            repo = None\n\n    assert repo_obj is not None\n    assert repo_obj.working_tree_dir is not None\n\n    # Configure the project\n    do_configure(name, str(repo_obj.working_tree_dir), debug=False)\n\n    # Commit the configured project\n    # force the add, because we're potentially\n    # modifying things in gitignored locations\n    if repo_obj.is_dirty():\n        repo_obj.git.add(A=True, f=True)\n        repo_obj.git.commit(m=\"Configure project\")\n    else:\n        rich.print(\n            \"[yellow]No changes to commit! Seems like the\"\n            \" template you used mightn't be configurable?[/]\"\n        )\n\n    # If this repo's remote it PROJECT_TEMPLATE, cleanup the git history\n    if repo_obj.remotes.origin.url == PROJECT_TEMPLATE:\n        try:\n            robustly_rm_dir(Path(repo_obj.git_dir))\n        except (PermissionError, OSError) as ex:\n            with downgrade():\n                raise errors.UserException(\n                    f\"Failed to remove .git directory: {repr(ex)}\"\n                ) from ex\n\n        if not _in_git_repo(Path(repo_obj.working_dir).parent):\n            # If we've created this project OUTSIDE an existing git repo\n            # then re-init the repo so it has a clean history\n            clean_repo = git.Repo.init(repo_obj.working_tree_dir)\n            clean_repo.git.add(A=True)\n            clean_repo.git.commit(m=\"Initial commit\")\n\n    # Install dependencies listed in the ato.yaml, typically just generics\n    do_install(\n        to_install=None,\n        jlcpcb=False,\n        link=True,\n        upgrade=True,\n        path=repo_obj.working_tree_dir,\n    )\n\n    # Wew! New repo created!\n    rich.print(f':sparkles: [green]Created new project \"{name}\"![/] :sparkles:')\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.build","title":"build","text":"<pre><code>build(name=None)\n</code></pre> <p>Create a new build configuration. - adds entry to ato.yaml - creates a new directory in layout</p> Source code in <code>src/atopile/cli/create.py</code> <pre><code>@create_app.command()\ndef build(\n    name: Annotated[str | None, typer.Argument()] = None,\n):\n    \"\"\"\n    Create a new build configuration.\n    - adds entry to ato.yaml\n    - creates a new directory in layout\n    \"\"\"\n    if not name:\n        name = caseconverter.kebabcase(\n            questionary.text(\"Enter the build name\").unsafe_ask()\n        )\n\n    try:\n        project_config = config.get_project_config_from_path(Path(\".\"))\n        project_context = config.ProjectContext.from_config(project_config)\n        top_level_path = project_context.project_path\n        layout_path = project_context.layout_path\n        src_path = project_context.src_path\n    except FileNotFoundError:\n        raise errors.UserException(\n            \"Could not find the project directory, are you within an ato project?\"\n        )\n\n    # Get user input for the entry file and module name\n    rich.print(\"We will create a new ato file and add the entry to the ato.yaml\")\n    entry = questionary.text(\n        \"What would you like to call the entry file? (e.g., psuDebug)\"\n    ).unsafe_ask()\n\n    target_layout_path = layout_path / name\n    with tempfile.TemporaryDirectory() as tmpdirname:\n        try:\n            git.Repo.clone_from(PROJECT_TEMPLATE, tmpdirname)\n        except git.GitCommandError as ex:\n            raise errors.UserException(\n                f\"Failed to clone layout template from {PROJECT_TEMPLATE}: {repr(ex)}\"\n            )\n        source_layout_path = Path(tmpdirname) / \"elec\" / \"layout\" / \"default\"\n        if not source_layout_path.exists():\n            raise errors.UserException(\n                f\"The specified layout path {source_layout_path} does not exist.\"\n            )\n        else:\n            target_layout_path.mkdir(parents=True, exist_ok=True)\n            shutil.copytree(source_layout_path, target_layout_path, dirs_exist_ok=True)\n            # Configure the files in the directory using the do_configure function\n            do_configure(name, str(target_layout_path), debug=False)\n\n        # Add the build to the ato.yaml file\n        ato_yaml_path = top_level_path / config.CONFIG_FILENAME\n        # Check if ato.yaml exists\n        if not ato_yaml_path.exists():\n            print(\n                f\"ato.yaml not found in {top_level_path}. Please ensure the file\"\n                \" exists before proceeding.\"\n            )\n        else:\n            # Load the existing YAML configuration\n            yaml = ruamel.yaml.YAML()\n            with ato_yaml_path.open(\"r\") as file:\n                ato_config = yaml.load(file)\n\n            entry_file = Path(caseconverter.kebabcase(entry)).with_suffix(\".ato\")\n            entry_module = caseconverter.pascalcase(entry)\n\n            # Update the ato_config with the new build information\n            if \"builds\" not in ato_config:\n                ato_config[\"builds\"] = {}\n            ato_config[\"builds\"][name] = {\n                \"entry\": f\"elec/src/{entry_file}:{entry_module}\"\n            }\n\n            # Write the updated configuration back to ato.yaml\n            with ato_yaml_path.open(\"w\") as file:\n                yaml.dump(ato_config, file)\n\n        # create a new ato file with the entry file and module\n        ato_file = src_path / entry_file\n        ato_file.write_text(f\"module {entry_module}:\\n \\tsignal gnd\\n\")\n\n        rich.print(\n            f\":sparkles: Successfully created a new build configuration for {name}!\"\n            \" :sparkles:\"\n        )\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.configure","title":"configure","text":"<pre><code>configure(name, repo_path)\n</code></pre> <p>Command useful in developing templates.</p> Source code in <code>src/atopile/cli/create.py</code> <pre><code>@create_app.command(hidden=True)\ndef configure(name: str, repo_path: str):\n    \"\"\"Command useful in developing templates.\"\"\"\n    do_configure(name, repo_path, debug=True)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.do_configure","title":"do_configure","text":"<pre><code>do_configure(name, _repo_path, debug)\n</code></pre> <p>Configure the project.</p> Source code in <code>src/atopile/cli/create.py</code> <pre><code>def do_configure(name: str, _repo_path: str, debug: bool):\n    \"\"\"Configure the project.\"\"\"\n    repo_path = Path(_repo_path)\n    try:\n        author = git.Repo(repo_path).git.config(\"user.name\")\n    except (git.GitCommandError, git.InvalidGitRepositoryError):\n        author = \"Original Author\"\n\n    template_globals = {\n        \"name\": name,\n        \"caseconverter\": caseconverter,\n        \"repo_root\": repo_path,\n        \"python_path\": sys.executable,\n        \"author\": author,\n    }\n\n    # Load templates\n    env = jinja2.Environment(loader=jinja2.FileSystemLoader(str(repo_path)))\n\n    for template_path in repo_path.glob(\"**/*.j2\"):\n        # Figure out the target path and variables and what not\n        target_path = template_path.parent / template_path.name.replace(\n            \".j2\", \"\"\n        ).replace(\"__name__\", caseconverter.kebabcase(name))\n\n        template_globals[\"rel_path\"] = target_path\n\n        template = env.get_template(\n            str(template_path.relative_to(repo_path).as_posix()),\n            globals=template_globals,\n        )\n\n        # Make the noise!\n        with target_path.open(\"w\") as f:\n            for chunk in template.generate():\n                f.write(chunk)\n\n        # Remove the template\n        if not debug:\n            template_path.unlink()\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.component","title":"component","text":"<pre><code>component(\n    search_term=None, name=None, filename=None, type_=None\n)\n</code></pre> <p>Create a new component.</p> Source code in <code>src/atopile/cli/create.py</code> <pre><code>@create_app.command()\ndef component(\n    search_term: Annotated[str | None, typer.Option(\"--search\", \"-s\")] = None,\n    name: Annotated[str | None, typer.Option(\"--name\", \"-n\")] = None,\n    filename: Annotated[str | None, typer.Option(\"--filename\", \"-f\")] = None,\n    type_: Annotated[ComponentType | None, typer.Option(\"--type\", \"-t\")] = None,\n):\n    \"\"\"Create a new component.\"\"\"\n    import faebryk.libs.picker.lcsc as lcsc_\n    from faebryk.libs.picker.api.models import Component\n    from faebryk.libs.picker.api.picker_lib import _extract_numeric_id, client\n    from faebryk.libs.pycodegen import format_and_write, sanitize_name\n    from faebryk.tools.libadd import Template\n\n    try:\n        project_config, project_ctx = configure_project_context(None)\n    except errors.UserBadParameterError:\n        project_config, project_ctx = configure_project_context(\n            str(Path.cwd()), standalone=True\n        )\n\n    # FIXME: dedup path bullshit\n    lcsc_.LIB_FOLDER = (project_config.location / \"build\" / \"kicad\" / \"libs\",)\n    lcsc_.LIB_FOLDER = lcsc_.BUILD_FOLDER / \"kicad\" / \"libs\"\n    lcsc_.MODEL_PATH = None\n\n    # Find a component --------------------------------------------------------\n\n    component: Component | None = None\n\n    for _ in stuck_user_helper_generator:\n        if not search_term:\n            search_term = questionary.text(\n                \"Search for a component (Part Number or LCSC ID):\"\n            ).unsafe_ask()\n            assert search_term is not None\n\n        try:\n            lcsc_id = _extract_numeric_id(search_term)\n        except ValueError:\n            lcsc_id = None\n\n        try:\n            if lcsc_id:\n                components = client.fetch_part_by_lcsc(lcsc_id)\n            else:\n                # TODO: remove this once we have a fuzzy search\n                mfr = questionary.text(\"Enter the manufacturer\").unsafe_ask()\n                components = client.fetch_part_by_mfr(mfr, search_term)\n        except ApiHTTPError as e:\n            if e.response.status_code == 404:\n                components = []\n            else:\n                raise\n\n        if len(components) == 0:\n            rich.print(f'No components found for \"{search_term}\"')\n            search_term = None\n            continue\n\n        component_table = Table()\n        component_table.add_column(\"Part Number\")\n        component_table.add_column(\"Manufacturer\")\n        component_table.add_column(\"Description\")\n\n        for component in components:\n            component_table.add_row(\n                component.manufacturer_name,\n                component.part_number,\n                component.description,\n            )\n\n        rich.print(component_table)\n\n        choices = [\n            {\n                \"name\": f\"{component.manufacturer_name} {component.part_number}\",\n                \"value\": component,\n            }\n            for component in components\n        ] + [{\"name\": \"Search again...\", \"value\": None}]\n\n        component = questionary.select(\n            \"Select a component\", choices=choices\n        ).unsafe_ask()\n\n        if component is not None:\n            break\n\n        # Reset the input terms to start over if we didn't find what we're looking for\n        search_term = None\n\n    # We have a component -----------------------------------------------------\n    assert component is not None\n\n    # TODO: templated ato components too\n    if type_ is None:\n        type_ = ComponentType.fab\n    # if type_ is None:\n    #     type_ = questionary.select(\n    #         \"Select the component type\", choices=list(ComponentType)\n    #     ).unsafe_ask()\n    #     assert type_ is not None\n\n    if name is None:\n        name = questionary.text(\n            \"Enter the name of the component\",\n            default=caseconverter.pascalcase(\n                sanitize_name(component.manufacturer_name + \" \" + component.part_number)\n            ),\n        ).unsafe_ask()\n\n    sanitized_name = sanitize_name(name)\n    if sanitized_name != name:\n        rich.print(f\"Sanitized name: {sanitized_name}\")\n\n    if type_ == ComponentType.ato:\n        extension = \".ato\"\n    elif type_ == ComponentType.fab:\n        extension = \".py\"\n    else:\n        raise ValueError(f\"Invalid component type: {type_}\")\n\n    out_path: Path | None = None\n    for _ in stuck_user_helper_generator:\n        if filename is None:\n            filename = questionary.text(\n                \"Enter the filename of the component\",\n                default=caseconverter.snakecase(name) + extension,\n            ).unsafe_ask()\n\n        assert filename is not None\n\n        filepath = Path(filename)\n        if filepath.absolute():\n            out_path = filepath.resolve()\n        else:\n            out_path = (project_ctx.src_path / filename).resolve()\n\n        if out_path.exists():\n            rich.print(f\"File {out_path} already exists\")\n            filename = None\n            continue\n\n        if not out_path.parent.exists():\n            rich.print(\n                f\"Directory {out_path.parent} does not exist. Creating it now...\"\n            )\n            out_path.parent.mkdir(parents=True, exist_ok=True)\n\n        break\n\n    assert out_path is not None\n\n    if type_ == ComponentType.ato:\n        raise errors.UserNotImplementedError(\n            \"Creating ato components are not yet supported\"\n        )\n\n    elif type_ == ComponentType.fab:\n        template = Template(name=sanitized_name, base=\"Module\")\n        template.add_part(component)\n        out = template.dumps()\n        format_and_write(out, out_path)\n        rich.print(f\":sparkles: Created {out_path} !\")\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.main","title":"main","text":"<pre><code>main(ctx)\n</code></pre> Source code in <code>src/atopile/cli/create.py</code> <pre><code>@create_app.callback(invoke_without_command=True)\ndef main(ctx: typer.Context):\n    if ctx.resilient_parsing:\n        return\n\n    if not ctx.invoked_subcommand:\n        commands = cast(dict, ctx.command.commands)  # type: ignore  # commands is an attribute of the context\n        command_name = questionary.select(\n            \"What would you like to create?\",\n            choices=[n for n, c in commands.items() if not c.hidden],\n        ).unsafe_ask()\n\n        assert command_name in commands\n\n        # Run the command\n        ctx.invoke(commands[command_name].callback)\n</code></pre>"},{"location":"api/cli/#atopile.cli.excepthook","title":"excepthook","text":""},{"location":"api/cli/#atopile.cli.excepthook.handle_exception","title":"handle_exception","text":"<pre><code>handle_exception(exc_type, exc_value, exc_traceback)\n</code></pre> Source code in <code>src/atopile/cli/excepthook.py</code> <pre><code>def handle_exception(exc_type, exc_value, exc_traceback):\n    try:\n        _handle_exception(exc_type, exc_value, exc_traceback)\n    except Exception as e:\n        sys.__excepthook__(type(e), e, e.__traceback__)\n    finally:\n        with contextlib.suppress(Exception):\n            telemetry.log_telemetry()\n\n        rich.print(\n            \"\\n\\nUnfortunately errors ^^^ stopped the build. \"\n            \"If you need a hand jump on [#9656ce]Discord[/]! [link=https://discord.gg/mjtxARsr9V]https://discord.gg/mjtxARsr9V[/] :wave:\"  # noqa: E501  # pre-existing\n        )\n        sys.exit(1)\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect","title":"inspect","text":"<p><code>ato inspect</code></p>"},{"location":"api/cli/#atopile.cli.inspect.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.odd_row","title":"odd_row  <code>module-attribute</code>","text":"<pre><code>odd_row = 'on grey11 cornflower_blue'\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.even_row","title":"even_row  <code>module-attribute</code>","text":"<pre><code>even_row = 'on grey15 cornflower_blue'\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.odd_greyed_row","title":"odd_greyed_row  <code>module-attribute</code>","text":"<pre><code>odd_greyed_row = 'on grey11 grey0'\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.even_greyed_row","title":"even_greyed_row  <code>module-attribute</code>","text":"<pre><code>even_greyed_row = 'on grey15 grey0'\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.DisplayEntry","title":"DisplayEntry","text":"<pre><code>DisplayEntry(net)\n</code></pre> <p>This class represents the nets that are below the inspected module, the equivalent net that is below the context module and the individual connections that are made to the inspect net and the context net.</p> Source code in <code>src/atopile/cli/inspect.py</code> <pre><code>def __init__(self, net: list[list[AddrStr]]):\n    self.inspect_net: list[AddrStr] = net\n    self.inspect_consumer: list[AddrStr] = []\n    self.context_net: list[AddrStr] = []\n    self.context_consumer: list[AddrStr] = []\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.DisplayEntry.inspect_net","title":"inspect_net  <code>instance-attribute</code>","text":"<pre><code>inspect_net = net\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.DisplayEntry.inspect_consumer","title":"inspect_consumer  <code>instance-attribute</code>","text":"<pre><code>inspect_consumer = []\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.DisplayEntry.context_net","title":"context_net  <code>instance-attribute</code>","text":"<pre><code>context_net = []\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.DisplayEntry.context_consumer","title":"context_consumer  <code>instance-attribute</code>","text":"<pre><code>context_consumer = []\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.inspect","title":"inspect","text":"<pre><code>inspect(\n    entry=None,\n    build=[],\n    target=[],\n    option=[],\n    inspect=None,\n    context=None,\n    dump_csv=None,\n)\n</code></pre> <p>Utility to inspect what is connected to a component. The context sets the boundary where something is considered connected. For example: <code>--inspect rp2040_micro --context rp2040_micro_ki</code></p> Source code in <code>src/atopile/cli/inspect.py</code> <pre><code>def inspect(\n    entry: Annotated[str | None, typer.Argument()] = None,\n    build: Annotated[list[str], typer.Option(\"--build\", \"-b\", envvar=\"ATO_BUILD\")] = [],\n    target: Annotated[\n        list[str], typer.Option(\"--target\", \"-t\", envvar=\"ATO_TARGET\")\n    ] = [],\n    option: Annotated[\n        list[str], typer.Option(\"--option\", \"-o\", envvar=\"ATO_OPTION\")\n    ] = [],\n    inspect: str | None = None,\n    context: Annotated[\n        str | None,\n        typer.Option(\n            \"--context\", \"-c\", help=\"The context from which to inspect the module\"\n        ),\n    ] = None,\n    dump_csv: Annotated[\n        str | None,\n        typer.Option(\"--dump-csv\", \"-d\", help=\"Output the inspection to a CSV file\"),\n    ] = None,\n):\n    \"\"\"\n    Utility to inspect what is connected to a component.\n    The context sets the boundary where something is considered connected.\n    For example: `--inspect rp2040_micro --context rp2040_micro_ki`\n    \"\"\"\n    raise errors.UserNotImplementedError(\"Inspect is not yet implemented.\")\n</code></pre>"},{"location":"api/cli/#atopile.cli.install","title":"install","text":"<p>This CLI command provides the <code>ato install</code> command to: - install dependencies - download JLCPCB footprints</p>"},{"location":"api/cli/#atopile.cli.install.yaml","title":"yaml  <code>module-attribute</code>","text":"<pre><code>yaml = YAML()\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.install","title":"install","text":"<pre><code>install(\n    to_install=None,\n    jlcpcb=False,\n    link=False,\n    upgrade=False,\n    path=None,\n)\n</code></pre> <p>Install atopile packages or components from jlcpcb.com/parts</p> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def install(\n    to_install: Annotated[str | None, typer.Argument()] = None,\n    jlcpcb: Annotated[\n        bool, typer.Option(\"--jlcpcb\", \"-j\", help=\"JLCPCB component ID\")\n    ] = False,\n    link: Annotated[\n        bool,\n        typer.Option(\"--link\", \"-l\", help=\"Keep this dependency linked to the source\"),\n    ] = False,\n    upgrade: Annotated[\n        bool, typer.Option(\"--upgrade\", \"-u\", help=\"Upgrade dependencies\")\n    ] = False,\n    path: Annotated[Path | None, typer.Argument()] = None,\n):\n    \"\"\"\n    Install atopile packages or components from jlcpcb.com/parts\n    \"\"\"\n    do_install(to_install, jlcpcb, link, upgrade, path)\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.do_install","title":"do_install","text":"<pre><code>do_install(to_install, jlcpcb, link, upgrade, path)\n</code></pre> <p>Actually do the installation of the dependencies. This is split in two so that it can be called from <code>install</code> and <code>create</code></p> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def do_install(\n    to_install: str | None, jlcpcb: bool, link: bool, upgrade: bool, path: Path | None\n):\n    \"\"\"\n    Actually do the installation of the dependencies.\n    This is split in two so that it can be called from `install` and `create`\n    \"\"\"\n\n    current_path = Path.cwd()\n    config = atopile.config.get_project_config_from_path(Path(path or current_path))\n    ctx = atopile.config.ProjectContext.from_config(config)\n    top_level_path = config.location\n\n    log.info(f\"Installing {to_install + ' ' if to_install else ''}in {top_level_path}\")\n\n    if jlcpcb:\n        if to_install is None:\n            raise errors.UserBadParameterError(\"No component ID specified\")\n        # eg. \"ato install --jlcpcb=C123\"\n        install_jlcpcb(to_install, top_level_path)\n    elif to_install:\n        # eg. \"ato install some-atopile-module\"\n        install_single_dependency(to_install, link, upgrade, config, ctx)\n    else:\n        # eg. \"ato install\"\n        install_project_dependencies(config, ctx, upgrade)\n\n    log.info(\"[green]Done![/] :call_me_hand:\", extra={\"markup\": True})\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.get_package_repo_from_registry","title":"get_package_repo_from_registry","text":"<pre><code>get_package_repo_from_registry(module_name)\n</code></pre> <p>Get the git repo for a package from the ato registry.</p> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def get_package_repo_from_registry(module_name: str) -&gt; str:\n    \"\"\"\n    Get the git repo for a package from the ato registry.\n    \"\"\"\n    try:\n        response = requests.post(\n            \"https://get-package-atsuhzfd5a-uc.a.run.app\",\n            json={\"name\": module_name},\n            timeout=10,\n        )\n    except requests.exceptions.ReadTimeout as ex:\n        raise errors.UserInfraError(\n            f\"Request to registry timed out for package '{module_name}'\"\n        ) from ex\n\n    if response.status_code == 500:\n        raise errors.UserException(\n            f\"Could not find package '{module_name}' in registry.\"\n        )\n    response.raise_for_status()\n    return_data = response.json()\n    try:\n        return_url = return_data[\"data\"][\"repo_url\"]\n    except KeyError as ex:\n        raise errors.UserException(\n            f\"No repo_url found for package '{module_name}'\"\n        ) from ex\n    return return_url\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.install_single_dependency","title":"install_single_dependency","text":"<pre><code>install_single_dependency(\n    to_install, link, upgrade, config, ctx\n)\n</code></pre> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def install_single_dependency(\n    to_install: str,\n    link: bool,\n    upgrade: bool,\n    config: atopile.config.ProjectConfig,\n    ctx: atopile.config.ProjectContext,\n):\n    dependency = atopile.config.Dependency.from_str(to_install)\n    name = _name_and_clone_url_helper(dependency.name)[0]\n    if link:\n        dependency.link_broken = False\n        abs_path = ctx.module_path / name\n        dependency.path = abs_path.relative_to(ctx.project_path)\n    else:\n        abs_path = ctx.src_path / name\n        dependency.path = abs_path.relative_to(ctx.project_path)\n        dependency.link_broken = True\n\n    try:\n        installed_version = install_dependency(dependency, upgrade, abs_path)\n    except GitCommandError as ex:\n        if \"already exists and is not an empty directory\" in ex.stderr:\n            # FIXME: shouldn't `--upgrade` do this already?\n            raise errors.UserException(\n                f\"Directory {abs_path} already exists and is not empty. \"\n                \"Please move or remove it before installing this new content.\"\n            ) from ex\n        raise\n    # If the link's broken, remove the .git directory so git treats it as copy-pasted code # noqa: E501  # pre-existing\n    if dependency.link_broken:\n        try:\n            robustly_rm_dir(abs_path / \".git\")\n        except (PermissionError, OSError, FileNotFoundError) as ex:\n            errors.UserException(f\"Failed to remove .git directory: {repr(ex)}\").log(\n                log, logging.WARNING\n            )\n\n    if dependency.version_spec is None and installed_version:\n        # If the user didn't specify a version, we'll\n        # use the one we just installed as a basis\n        dependency.version_spec = f\"@{installed_version}\"\n\n    names = {dep.name: i for i, dep in enumerate(config.dependencies)}\n    if dependency.name in names:\n        config.dependencies[names[dependency.name]] = dependency\n    else:\n        config.dependencies.append(dependency)\n    config.save_changes()\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.install_project_dependencies","title":"install_project_dependencies","text":"<pre><code>install_project_dependencies(config, ctx, upgrade)\n</code></pre> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def install_project_dependencies(\n    config: atopile.config.ProjectConfig,\n    ctx: atopile.config.ProjectContext,\n    upgrade: bool,\n):\n    for _ctx, dependency in faebryk.libs.exceptions.iter_through_errors(\n        config.dependencies\n    ):\n        with _ctx():\n            if not dependency.link_broken:\n                # FIXME: these dependency objects are a little too entangled\n                name = _name_and_clone_url_helper(dependency.name)[0]\n                abs_path = ctx.module_path / name\n                dependency.path = abs_path.relative_to(ctx.project_path)\n\n                try:\n                    install_dependency(dependency, upgrade, abs_path)\n                except GitCommandError as ex:\n                    if \"already exists and is not an empty directory\" in ex.stderr:\n                        # FIXME: shouldn't `--upgrade` do this already?\n                        raise errors.UserException(\n                            f\"Directory {abs_path} already exists and is not empty. \"\n                            \"Please move or remove it before installing this new content.\"  # noqa: E501  # pre-existing\n                        ) from ex\n                    raise\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.install_dependency","title":"install_dependency","text":"<pre><code>install_dependency(dependency, upgrade, abs_path)\n</code></pre> <p>Install a dependency of the name \"module_name\"</p> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def install_dependency(\n    dependency: atopile.config.Dependency, upgrade: bool, abs_path: Path\n) -&gt; Optional[str]:\n    \"\"\"\n    Install a dependency of the name \"module_name\"\n    \"\"\"\n    # Ensure the modules path exists\n    abs_path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Figure out what we're trying to install here\n    module_spec = dependency.version_spec or \"*\"\n    module_name, clone_url = _name_and_clone_url_helper(dependency.name)\n\n    try:\n        # This will raise an exception if the directory does not exist\n        repo = Repo(abs_path)\n    except (InvalidGitRepositoryError, NoSuchPathError):\n        # Directory does not contain a valid repo, clone into it\n        log.info(f\"Installing dependency {module_name}\")\n        repo = Repo.clone_from(clone_url, abs_path)\n        repo.active_branch.tracking_branch().checkout()\n    else:\n        # In this case the directory exists and contains a valid repo\n        if upgrade:\n            log.info(f\"Fetching latest changes for {module_name}\")\n            repo.remotes.origin.fetch()\n        else:\n            log.info(\n                f\"{module_name} already exists. If you wish to upgrade, use --upgrade\"\n            )\n            # here we're done because we don't want to play with peoples' deps under them # noqa: E501  # pre-existing\n            return\n\n    # Figure out what version of this thing we need\n    semver_to_tag = {}\n    installed_semver = None\n    for tag in repo.tags:\n        try:\n            semver_to_tag[version.parse(tag.name)] = tag\n        except errors.UserException:\n            log.debug(f\"Tag {tag.name} is not a valid semver tag. Skipping.\")\n\n    if \"@\" in module_spec:\n        # If there's an @ in the version, we're gonna check that thing out\n        best_checkout = module_spec.strip(\" @\")\n    elif semver_to_tag:\n        # Otherwise we're gonna find the best tag meeting the semver spec\n        valid_versions = [v for v in semver_to_tag if version.match(module_spec, v)]\n        if not valid_versions:\n            raise errors.UserException(\n                f\"No versions of {module_name} match spec {module_spec}.\\n\"\n                f\"Available versions: {', '.join(map(str, semver_to_tag))}\"\n            )\n        installed_semver = max(valid_versions)\n        best_checkout = semver_to_tag[installed_semver]\n    else:\n        log.warning(\n            \"No semver tags found for this module. Using latest default branch :hot_pepper:.\",  # noqa: E501  # pre-existing\n            extra={\"markup\": True},\n        )\n        return None\n\n    # If the repo is dirty, throw an error\n    if repo.is_dirty():\n        raise errors.UserException(\n            f\"Module {module_name} has uncommitted changes. Aborting.\"\n        )\n\n    # Checkout the best thing we've found\n    ref_before_checkout = repo.head.commit\n\n    # If the repo best_checkout is a branch, we need to checkout the origin/branch\n    if best_checkout in repo.heads:\n        best_checkout = f\"origin/{best_checkout}\"\n\n    repo.git.checkout(best_checkout)\n\n    if repo.head.commit == ref_before_checkout:\n        log.info(\n            f\"Already on the best option ([cyan bold]{best_checkout}[/]) for {module_name}\",  # noqa: E501  # pre-existing\n            extra={\"markup\": True},\n        )\n    else:\n        log.info(\n            f\"Using :sparkles: [cyan bold]{best_checkout}[/] :sparkles: of {module_name}\",  # noqa: E501  # pre-existing\n            extra={\"markup\": True},\n        )\n\n    return repo.head.commit.hexsha\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.install_jlcpcb","title":"install_jlcpcb","text":"<pre><code>install_jlcpcb(component_id, top_level_path)\n</code></pre> <p>Install a component from JLCPCB</p> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def install_jlcpcb(component_id: str, top_level_path: Path):\n    \"\"\"Install a component from JLCPCB\"\"\"\n    component_id = component_id.upper()\n    if not component_id.startswith(\"C\") or not component_id[1:].isdigit():\n        raise errors.UserException(f\"Component id {component_id} is invalid. Aborting.\")\n\n    footprints_dir = (\n        top_level_path\n        / atopile.config.get_project_config_from_path(top_level_path).paths.footprints\n    )\n    footprints_dir.mkdir(parents=True, exist_ok=True)\n\n    ato_src_dir = (\n        top_level_path\n        / atopile.config.get_project_config_from_path(top_level_path).paths.src\n    )\n    ato_src_dir.mkdir(parents=True, exist_ok=True)\n\n    log.info(f\"Footprints directory: {footprints_dir}\")\n\n    command = [\n        sys.executable,\n        \"-m\",\n        \"easyeda2kicad\",\n        \"--full\",\n        f\"--lcsc_id={component_id}\",\n        f\"--output={footprints_dir}\",\n        \"--overwrite\",\n        \"--ato\",\n        f\"--ato_file_path={ato_src_dir}\",\n    ]\n    result = subprocess.run(command, capture_output=True, text=True, check=False)\n\n    # The stdout and stderr are captured due to 'capture_output=True'\n    print(\"STDOUT:\", result.stdout)\n    print(\"STDERR:\", result.stderr)\n\n    # Check the return code to see if the command was successful\n    if result.returncode == 0:\n        print(\"Command executed successfully\")\n    else:\n        component_link = f\"https://jlcpcb.com/partdetail/{component_id}\"\n        raise errors.UserException(\n            \"Oh no! Looks like this component doesnt have a model available. \"\n            f\"More information about the component can be found here: {component_link}\"\n        )\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging","title":"logging","text":""},{"location":"api/cli/#atopile.cli.logging.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.handler","title":"handler  <code>module-attribute</code>","text":"<pre><code>handler = LogHandler(\n    console=console,\n    rich_tracebacks=True,\n    show_path=False,\n    tracebacks_suppress=[\"typer\"],\n    tracebacks_suppress_map={\n        UserPythonModuleError: [atopile, faebryk]\n    },\n    tracebacks_unwrap=[UserPythonModuleError],\n    hide_traceback_types=(_BaseBaseUserException),\n    always_show_traceback_types=(UserPythonModuleError),\n    traceback_level=ERROR,\n)\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler","title":"LogHandler","text":"<pre><code>LogHandler(\n    *args,\n    tracebacks_suppress_map=None,\n    tracebacks_unwrap=None,\n    hide_traceback_types=(),\n    always_show_traceback_types=(),\n    traceback_level=ERROR,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RichHandler</code></p> <p>A logging handler that renders output with Rich.</p> <p>Suppresses frames from tracebacks conditionally depending on the exception type.</p> Source code in <code>src/atopile/cli/logging.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    tracebacks_suppress_map: dict[type[BaseException], list[ModuleType]]\n    | None = None,\n    tracebacks_unwrap: list[type[BaseException]] | None = None,\n    hide_traceback_types: tuple[type[BaseException], ...] = (),\n    always_show_traceback_types: tuple[type[BaseException], ...] = (),\n    traceback_level: int = logging.ERROR,\n    **kwargs,\n):\n    super().__init__(*args, **kwargs)\n    self.tracebacks_suppress_map = tracebacks_suppress_map or {}\n    self.tracebacks_unwrap = tracebacks_unwrap or []\n    self.hide_traceback_types = hide_traceback_types\n    self.always_show_traceback_types = always_show_traceback_types\n    self.traceback_level = traceback_level\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.tracebacks_suppress_map","title":"tracebacks_suppress_map  <code>instance-attribute</code>","text":"<pre><code>tracebacks_suppress_map = tracebacks_suppress_map or {}\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.tracebacks_unwrap","title":"tracebacks_unwrap  <code>instance-attribute</code>","text":"<pre><code>tracebacks_unwrap = tracebacks_unwrap or []\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.hide_traceback_types","title":"hide_traceback_types  <code>instance-attribute</code>","text":"<pre><code>hide_traceback_types = hide_traceback_types\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.always_show_traceback_types","title":"always_show_traceback_types  <code>instance-attribute</code>","text":"<pre><code>always_show_traceback_types = always_show_traceback_types\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.traceback_level","title":"traceback_level  <code>instance-attribute</code>","text":"<pre><code>traceback_level = traceback_level\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.render_message","title":"render_message","text":"<pre><code>render_message(record, message)\n</code></pre> Source code in <code>src/atopile/cli/logging.py</code> <pre><code>def render_message(\n    self, record: logging.LogRecord, message: str\n) -&gt; ConsoleRenderable:\n    # special handling for exceptions only\n    if record.exc_info is None:\n        return self._render_message(record, message)\n\n    _, exc, _ = record.exc_info\n\n    if not isinstance(exc, ConsoleRenderable):\n        return self._render_message(record, message)\n\n    return exc\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.emit","title":"emit","text":"<pre><code>emit(record)\n</code></pre> <p>Invoked by logging.</p> Source code in <code>src/atopile/cli/logging.py</code> <pre><code>def emit(self, record: logging.LogRecord) -&gt; None:\n    \"\"\"Invoked by logging.\"\"\"\n    hashable = self._get_hashable(record)\n\n    if hashable and hashable in _logged_exceptions:\n        # we've already logged this\n        return\n\n    traceback = self._get_traceback(record)\n\n    if self.formatter:\n        record.message = record.getMessage()\n        formatter = self.formatter\n        if hasattr(formatter, \"usesTime\") and formatter.usesTime():\n            record.asctime = formatter.formatTime(record, formatter.datefmt)\n        message = formatter.formatMessage(record)\n    else:\n        message = record.getMessage()\n\n    message_renderable = self.render_message(record, message)\n\n    log_renderable = self.render(\n        record=record, traceback=traceback, message_renderable=message_renderable\n    )\n    if isinstance(self.console.file, NullFile):\n        # Handles pythonw, where stdout/stderr are null, and we return NullFile\n        # instance from Console.file. In this case, we still want to make a log record # noqa: E501  # pre-existing\n        # even though we won't be writing anything to a file.\n        self.handleError(record)\n    else:\n        try:\n            self.console.print(log_renderable, highlight=True)\n        except Exception:\n            self.handleError(record)\n\n    if hashable:\n        _logged_exceptions.add(hashable)\n</code></pre>"},{"location":"api/cli/#atopile.cli.view","title":"view","text":"<p><code>ato view</code></p>"},{"location":"api/cli/#atopile.cli.view.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.view.view","title":"view","text":"<pre><code>view(entry=None, build=[], target=[], option=[])\n</code></pre> <p>View a block diagram or schematic of your project.</p> Source code in <code>src/atopile/cli/view.py</code> <pre><code>def view(\n    entry: Annotated[str | None, typer.Argument()] = None,\n    build: Annotated[list[str], typer.Option(\"--build\", \"-b\", envvar=\"ATO_BUILD\")] = [],\n    target: Annotated[\n        list[str], typer.Option(\"--target\", \"-t\", envvar=\"ATO_TARGET\")\n    ] = [],\n    option: Annotated[\n        list[str], typer.Option(\"--option\", \"-o\", envvar=\"ATO_OPTION\")\n    ] = [],\n):\n    \"\"\"\n    View a block diagram or schematic of your project.\n    \"\"\"\n    raise errors.UserNotImplementedError(\"View is not yet implemented.\")\n</code></pre>"},{"location":"api/solver/","title":"Solver","text":""},{"location":"api/solver/#faebryk.core.parameter","title":"faebryk.core.parameter","text":""},{"location":"api/solver/#faebryk.core.parameter.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.p_field","title":"p_field  <code>module-attribute</code>","text":"<pre><code>p_field = f_field(Parameter)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Commutative","title":"Commutative  <code>module-attribute</code>","text":"<pre><code>Commutative = (\n    Add\n    | Multiply\n    | And\n    | Or\n    | Xor\n    | Union\n    | Intersection\n    | SymmetricDifference\n    | Is\n)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.FullyAssociative","title":"FullyAssociative  <code>module-attribute</code>","text":"<pre><code>FullyAssociative = (\n    Add | Multiply | And | Or | Xor | Union | Intersection\n)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LeftAssociative","title":"LeftAssociative  <code>module-attribute</code>","text":"<pre><code>LeftAssociative = Subtract | Divide | Difference\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Associative","title":"Associative  <code>module-attribute</code>","text":"<pre><code>Associative = FullyAssociative | LeftAssociative\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Namespace","title":"Namespace","text":"<p>Marker class for namespace objects.</p>"},{"location":"api/solver/#faebryk.core.parameter.GraphInterface","title":"GraphInterface","text":"<pre><code>GraphInterface()\n</code></pre> Source code in <code>src/faebryk/core/cpp/__init__.py</code> <pre><code>other_flags += [f\"-DCMAKE_OSX_ARCHITECTURES={arch}\"]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GraphInterface.G","title":"G  <code>property</code>","text":"<pre><code>G\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GraphInterface.edges","title":"edges  <code>property</code>","text":"<pre><code>edges\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GraphInterface.node","title":"node  <code>property</code> <code>writable</code>","text":"<pre><code>node\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GraphInterface.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GraphInterface.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre> Source code in <code>src/faebryk/core/cpp/__init__.py</code> <pre><code>if DEBUG_BUILD:\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GraphInterface.get_gif_edges","title":"get_gif_edges","text":"<pre><code>get_gif_edges()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GraphInterface.is_connected_to","title":"is_connected_to","text":"<pre><code>is_connected_to(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>GraphInterface</code> </p> Source code in <code>src/faebryk/core/cpp/__init__.py</code> <pre><code>\"-B\",\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GraphInterface.get_connected_nodes","title":"get_connected_nodes","text":"<pre><code>get_connected_nodes(types)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>Sequence[type]</code> </p> Source code in <code>src/faebryk/core/cpp/__init__.py</code> <pre><code>],\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node","title":"Node","text":"<pre><code>Node()\n</code></pre> <p>               Bases: <code>Node</code></p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    CNode.transfer_ownership(self)\n    assert not hasattr(self, \"_is_setup\")\n    self._is_setup = True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Node.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Node.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Node.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait","title":"Trait","text":"<pre><code>Trait()\n</code></pre> <p>               Bases: <code>Node</code></p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    CNode.transfer_ownership(self)\n    assert not hasattr(self, \"_is_setup\")\n    self._is_setup = True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Trait.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Trait.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.impl","title":"impl  <code>classmethod</code>","text":"<pre><code>impl()\n</code></pre> Source code in <code>src/faebryk/core/trait.py</code> <pre><code>@classmethod\ndef impl[T: \"Trait\"](cls: type[T]):\n    # Implements TraitImpl\n    class _Impl(cls):\n        __trait__: type[Trait] = cls\n\n        @property\n        def obj(self) -&gt; Node:\n            p = self.get_parent()\n            if not p:\n                raise TraitUnbound(self)\n            return cast_assert(Node, p[0])\n\n        def get_obj[TN: Node](self, type: type[TN]) -&gt; TN:\n            return cast_assert(type, self.obj)\n\n        def cmp(self, new_t: \"TraitImpl\") -&gt; tuple[bool, \"TraitImpl\"]:\n            assert TraitImpl.is_traitimpl(new_t)\n\n            # If new same or more specific\n            if new_t.implements(self.__trait__):\n                return True, new_t\n\n            # hack type (ghetto protocol)\n            traitimpl = cast(TraitImpl, self)\n\n            # If we are more specific\n            if self.implements(new_t.__trait__):\n                return True, traitimpl\n\n            return False, traitimpl\n\n        def implements(self, trait: type[Trait]):\n            return trait.is_traitimpl(self)\n\n        # Overwriteable ------------------------------------------------------------\n\n        def _handle_added_to_parent(self):\n            self.on_obj_set()\n\n        def on_obj_set(self): ...\n\n        def handle_duplicate(self, old: \"TraitImpl\", node: Node) -&gt; bool:\n            assert old is not self\n            _, candidate = old.cmp(cast(TraitImpl, self))\n            if candidate is not self:\n                # raise TraitAlreadyExists(node, self)\n                return False\n\n            node.del_trait(old.__trait__)\n            return True\n\n        # override this to implement a dynamic trait\n        def is_implemented(self):\n            return True\n\n    # this should be outside the class def to prevent\n    # __init_subclass__ from overwriting it\n    _Impl.__trait__ = cls\n    _Impl.__name__ = f\"{cls.__name__}Impl\"\n\n    return _Impl\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.decless","title":"decless  <code>classmethod</code>","text":"<pre><code>decless()\n</code></pre> Source code in <code>src/faebryk/core/trait.py</code> <pre><code>@classmethod\ndef decless(cls):\n    class _Trait(cls): ...\n\n    _Trait.__decless_trait__ = True\n\n    return _Trait.impl()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Trait.is_traitimpl","title":"is_traitimpl  <code>classmethod</code>","text":"<pre><code>is_traitimpl(obj)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>Trait</code> </p> Source code in <code>src/faebryk/core/trait.py</code> <pre><code>@classmethod\ndef is_traitimpl(cls, obj: \"Trait\") -&gt; TypeGuard[\"TraitImpl\"]:\n    assert issubclass(cls, Trait)\n    if not TraitImpl.is_traitimpl(obj):\n        return False\n    return issubclass(obj.__trait__, cls)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Solver","title":"Solver","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Solver.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Solver.SolverError","title":"SolverError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Solver.TimeoutError","title":"TimeoutError","text":"<p>               Bases: <code>SolverError</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Solver.DivisionByZeroError","title":"DivisionByZeroError","text":"<p>               Bases: <code>SolverError</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Solver.SolveResult","title":"SolveResult  <code>dataclass</code>","text":"<pre><code>SolveResult(timed_out)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Solver.SolveResult.timed_out","title":"timed_out  <code>instance-attribute</code>","text":"<pre><code>timed_out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Solver.SolveResultAny","title":"SolveResultAny  <code>dataclass</code>","text":"<pre><code>SolveResultAny(\n    timed_out,\n    true_predicates,\n    false_predicates,\n    unknown_predicates,\n)\n</code></pre> <p>               Bases: <code>SolveResult</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Solver.SolveResultAny.timed_out","title":"timed_out  <code>instance-attribute</code>","text":"<pre><code>timed_out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Solver.SolveResultAny.true_predicates","title":"true_predicates  <code>instance-attribute</code>","text":"<pre><code>true_predicates\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Solver.SolveResultAny.false_predicates","title":"false_predicates  <code>instance-attribute</code>","text":"<pre><code>false_predicates\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Solver.SolveResultAny.unknown_predicates","title":"unknown_predicates  <code>instance-attribute</code>","text":"<pre><code>unknown_predicates\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Solver.SolveResultAll","title":"SolveResultAll  <code>dataclass</code>","text":"<pre><code>SolveResultAll(timed_out, has_solution)\n</code></pre> <p>               Bases: <code>SolveResult</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Solver.SolveResultAll.timed_out","title":"timed_out  <code>instance-attribute</code>","text":"<pre><code>timed_out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Solver.SolveResultAll.has_solution","title":"has_solution  <code>instance-attribute</code>","text":"<pre><code>has_solution\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Solver.get_any_single","title":"get_any_single","text":"<pre><code>get_any_single(\n    operatable, lock, suppose_constraint=None, minimize=None\n)\n</code></pre> <p>Solve for a single value for the given expression.</p> PARAMETER DESCRIPTION <code>operatable</code> <p> TYPE: <code>Parameter</code> </p> <code>lock</code> <p> TYPE: <code>bool</code> </p> <code>suppose_constraint</code> <p> TYPE: <code>Predicate | None</code> DEFAULT: <code>None</code> </p> <code>minimize</code> <p> TYPE: <code>Expression | None</code> DEFAULT: <code>None</code> </p> PARAMETER DESCRIPTION <code>operatable</code> <p>The expression or parameter to solve.</p> <p> TYPE: <code>Parameter</code> </p> <code>suppose_constraint</code> <p>An optional constraint that can be added to make solving                 easier. It is only in effect for the duration of the                 solve call.</p> <p> TYPE: <code>Predicate | None</code> DEFAULT: <code>None</code> </p> <code>minimize</code> <p>An optional expression to minimize while solving.</p> <p> TYPE: <code>Expression | None</code> DEFAULT: <code>None</code> </p> <code>lock</code> <p>If True, ensure the result is part of the solution set of               the expression.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>A SolveResultSingle object containing the chosen value.</p> Source code in <code>src/faebryk/core/solver/solver.py</code> <pre><code>def get_any_single(\n    self,\n    operatable: Parameter,\n    lock: bool,\n    suppose_constraint: Predicate | None = None,\n    minimize: Expression | None = None,\n) -&gt; Any:\n    \"\"\"\n    Solve for a single value for the given expression.\n\n    Args:\n        operatable: The expression or parameter to solve.\n        suppose_constraint: An optional constraint that can be added to make solving\n                            easier. It is only in effect for the duration of the\n                            solve call.\n        minimize: An optional expression to minimize while solving.\n        lock: If True, ensure the result is part of the solution set of\n                          the expression.\n\n    Returns:\n        A SolveResultSingle object containing the chosen value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Solver.assert_any_predicate","title":"assert_any_predicate","text":"<pre><code>assert_any_predicate(\n    predicates, lock, suppose_constraint=None, minimize=None\n)\n</code></pre> <p>Make at least one of the passed predicates true, unless that is impossible.</p> PARAMETER DESCRIPTION <code>predicates</code> <p> TYPE: <code>list[PredicateWithInfo[ArgType]]</code> </p> <code>lock</code> <p> TYPE: <code>bool</code> </p> <code>suppose_constraint</code> <p> TYPE: <code>Predicate | None</code> DEFAULT: <code>None</code> </p> <code>minimize</code> <p> TYPE: <code>Expression | None</code> DEFAULT: <code>None</code> </p> PARAMETER DESCRIPTION <code>predicates</code> <p>A list of predicates to solve.</p> <p> TYPE: <code>list[PredicateWithInfo[ArgType]]</code> </p> <code>suppose_constraint</code> <p>An optional constraint that can be added to make solving                 easier. It is only in effect for the duration of the                 solve call.</p> <p> TYPE: <code>Predicate | None</code> DEFAULT: <code>None</code> </p> <code>minimize</code> <p>An optional expression to minimize while solving.</p> <p> TYPE: <code>Expression | None</code> DEFAULT: <code>None</code> </p> <code>lock</code> <p>If True, add the solutions as constraints.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>SolveResultAny[ArgType]</code> <p>A SolveResult object containing the true, false, and unknown predicates.</p> Note <p>There is no specific order in which the predicates are solved.</p> Source code in <code>src/faebryk/core/solver/solver.py</code> <pre><code>def assert_any_predicate[ArgType](\n    self,\n    predicates: list[\"Solver.PredicateWithInfo[ArgType]\"],\n    lock: bool,\n    suppose_constraint: Predicate | None = None,\n    minimize: Expression | None = None,\n) -&gt; SolveResultAny[ArgType]:\n    \"\"\"\n    Make at least one of the passed predicates true, unless that is impossible.\n\n    Args:\n        predicates: A list of predicates to solve.\n        suppose_constraint: An optional constraint that can be added to make solving\n                            easier. It is only in effect for the duration of the\n                            solve call.\n        minimize: An optional expression to minimize while solving.\n        lock: If True, add the solutions as constraints.\n\n    Returns:\n        A SolveResult object containing the true, false, and unknown predicates.\n\n    Note:\n        There is no specific order in which the predicates are solved.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Solver.find_and_lock_solution","title":"find_and_lock_solution","text":"<pre><code>find_and_lock_solution(G)\n</code></pre> PARAMETER DESCRIPTION <code>G</code> <p> TYPE: <code>Graph</code> </p> Source code in <code>src/faebryk/core/solver/solver.py</code> <pre><code>def find_and_lock_solution(self, G: Graph) -&gt; SolveResultAll: ...\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Solver.inspect_get_known_supersets","title":"inspect_get_known_supersets","text":"<pre><code>inspect_get_known_supersets(value, force_update=True)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Parameter</code> </p> <code>force_update</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/solver/solver.py</code> <pre><code>def inspect_get_known_supersets(\n    self, value: Parameter, force_update: bool = True\n) -&gt; P_Set: ...\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperableException","title":"ParameterOperableException","text":"<pre><code>ParameterOperableException(parameter, msg)\n</code></pre> <p>               Bases: <code>Exception</code></p> PARAMETER DESCRIPTION <code>parameter</code> <p> TYPE: <code>ParameterOperatable</code> </p> <code>msg</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, parameter: \"ParameterOperatable\", msg: str):\n    self.parameter = parameter\n    super().__init__(msg)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperableException.parameter","title":"parameter  <code>instance-attribute</code>","text":"<pre><code>parameter = parameter\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperableHasNoLiteral","title":"ParameterOperableHasNoLiteral","text":"<pre><code>ParameterOperableHasNoLiteral(parameter, msg)\n</code></pre> <p>               Bases: <code>ParameterOperableException</code></p> PARAMETER DESCRIPTION <code>parameter</code> <p> TYPE: <code>ParameterOperatable</code> </p> <code>msg</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, parameter: \"ParameterOperatable\", msg: str):\n    self.parameter = parameter\n    super().__init__(msg)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperableHasNoLiteral.parameter","title":"parameter  <code>instance-attribute</code>","text":"<pre><code>parameter = parameter\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable","title":"ParameterOperatable","text":"<pre><code>ParameterOperatable()\n</code></pre> <p>               Bases: <code>Node</code></p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    CNode.transfer_ownership(self)\n    assert not hasattr(self, \"_is_setup\")\n    self._is_setup = True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool: ...\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool: ...\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(self, context: ReprContext | None = None) -&gt; str:\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ParameterOperatable.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression","title":"Expression","text":"<pre><code>Expression(domain, *operands)\n</code></pre> <p>               Bases: <code>ParameterOperatable</code></p> PARAMETER DESCRIPTION <code>domain</code> <p> </p> <code>*operands</code> <p> TYPE: <code>All</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, domain, *operands: ParameterOperatable.All):\n    super().__init__()\n    self._domain = domain\n    self.operands = tuple(operands)\n    self.operatable_operands: set[ParameterOperatable] = {\n        op for op in operands if isinstance(op, ParameterOperatable)\n    }\n    self.non_operands: list[Any] = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Expression.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Expression.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Expression.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Expression.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Expression.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression","title":"ConstrainableExpression","text":"<pre><code>ConstrainableExpression(*operands)\n</code></pre> <p>               Bases: <code>Expression</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> TYPE: <code>All</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands: ParameterOperatable.All):\n    super().__init__(Boolean(), *operands)\n    self.constrained: bool = False\n\n    # TODO this should be done in solver, not here\n    self._solver_evaluates_to_true: bool = False\n    \"\"\"\n    Flag marking to the solver that this predicate has been deduced to True.\n    Differs from alias in the sense that we can guarantee that the predicate is\n    True, while alias only marks that the predicate shall be True.\n    \"\"\"\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ConstrainableExpression.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic","title":"Arithmetic","text":"<pre><code>Arithmetic(*operands)\n</code></pre> <p>               Bases: <code>Expression</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> TYPE: <code>NumberLike</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands: ParameterOperatable.NumberLike):\n    # HasUnit attr\n    self.units: Unit = cast(Unit, None)  # checked in postinit\n\n    super().__init__(Numbers(), *operands)\n    types = (\n        int,\n        float,\n        Quantity,\n        Unit,\n        Parameter,\n        Arithmetic,\n        Quantity_Interval,\n        Quantity_Interval_Disjoint,\n    )\n    if any(not isinstance(op, types) for op in operands):\n        raise ValueError(\n            \"operands must be int, float, Quantity, Unit, Parameter, Arithmetic\"\n            \", Quantity_Interval, or Quantity_Interval_Disjoint\"\n            f\", got {[op for op in operands if not isinstance(op, types)]}\"\n        )\n    if any(\n        not isinstance(param.domain, (Numbers, ESeries))\n        for param in operands\n        if isinstance(param, Parameter)\n    ):\n        raise ValueError(\"parameters must have domain Numbers or ESeries\")\n\n    # FIXME: convert to Quantity\n\n    # TODO enforce\n    self.operands = cast(tuple[ParameterOperatable.NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = cast(Unit, None)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Arithmetic.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive","title":"Additive","text":"<pre><code>Additive(*operands)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands):\n    super().__init__(*operands)\n    self.units = assert_compatible_units(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = assert_compatible_units(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Additive.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Additive.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Additive.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Additive.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Additive.sum","title":"sum  <code>staticmethod</code>","text":"<pre><code>sum(operands)\n</code></pre> PARAMETER DESCRIPTION <code>operands</code> <p> TYPE: <code>Sequence[NumberLike]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sum(operands: Sequence[ParameterOperatable.NumberLike]) -&gt; \"Additive\":\n    # Else assert not correct\n    if not len(operands):\n        raise ValueError(\"at least one operand is required\")\n    return cast_assert(Additive, sum(operands))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add","title":"Add","text":"<pre><code>Add(*operands)\n</code></pre> <p>               Bases: <code>Additive</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands):\n    super().__init__(*operands)\n    self.bla = 5\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = assert_compatible_units(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='+', placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.bla","title":"bla  <code>instance-attribute</code>","text":"<pre><code>bla = 5\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Add.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Add.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Add.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Add.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.sum","title":"sum  <code>staticmethod</code>","text":"<pre><code>sum(operands)\n</code></pre> PARAMETER DESCRIPTION <code>operands</code> <p> TYPE: <code>Sequence[NumberLike]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sum(operands: Sequence[ParameterOperatable.NumberLike]) -&gt; \"Additive\":\n    # Else assert not correct\n    if not len(operands):\n        raise ValueError(\"at least one operand is required\")\n    return cast_assert(Additive, sum(operands))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Add.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract","title":"Subtract","text":"<pre><code>Subtract(minuend, *subtrahend)\n</code></pre> <p>               Bases: <code>Additive</code></p> PARAMETER DESCRIPTION <code>minuend</code> <p> </p> <code>*subtrahend</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, minuend, *subtrahend):\n    super().__init__(minuend, *subtrahend)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = assert_compatible_units(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='-', placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.sum","title":"sum  <code>staticmethod</code>","text":"<pre><code>sum(operands)\n</code></pre> PARAMETER DESCRIPTION <code>operands</code> <p> TYPE: <code>Sequence[NumberLike]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sum(operands: Sequence[ParameterOperatable.NumberLike]) -&gt; \"Additive\":\n    # Else assert not correct\n    if not len(operands):\n        raise ValueError(\"at least one operand is required\")\n    return cast_assert(Additive, sum(operands))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Subtract.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply","title":"Multiply","text":"<pre><code>Multiply(*operands)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands):\n    super().__init__(*operands)\n    units = [HasUnit.get_units_or_dimensionless(op) for op in operands]\n    self.units = units[0]\n    for u in units[1:]:\n        self.units = cast_assert(Unit, self.units * u)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='*', placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = cast_assert(Unit, units * u)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Multiply.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide","title":"Divide","text":"<pre><code>Divide(numerator, *denominator)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>numerator</code> <p> </p> <code>*denominator</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, numerator, *denominator):\n    super().__init__(numerator, *denominator)\n\n    frac_unit = dimensionless\n    for d in denominator:\n        frac_unit = cast_assert(\n            Unit, frac_unit * HasUnit.get_units_or_dimensionless(d)\n        )\n\n    self.units = cast_assert(\n        Unit, HasUnit.get_units_or_dimensionless(numerator) / frac_unit\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='/', placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = cast_assert(\n    Unit, get_units_or_dimensionless(numerator) / frac_unit\n)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Divide.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Divide.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Divide.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Divide.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Divide.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # denominator not zero\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt","title":"Sqrt","text":"<pre><code>Sqrt(operand)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>operand</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, operand):\n    super().__init__(operand)\n    self.units = operand.units**0.5\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u221a', placement=PREFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units ** 0.5\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sqrt.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # non-negative\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power","title":"Power","text":"<pre><code>Power(base, exponent)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>base</code> <p> </p> <code>exponent</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, base, exponent):\n    super().__init__(base, exponent)\n\n    exp_unit = HasUnit.get_units_or_dimensionless(exponent)\n    if not exp_unit.is_compatible_with(dimensionless):\n        raise UnitCompatibilityError(\n            \"exponent must have dimensionless unit\",\n            incompatible_items=[exponent],\n        )\n    base_unit = HasUnit.get_units_or_dimensionless(base)\n    units = dimensionless\n    if not base_unit.is_compatible_with(dimensionless):\n        exp_val = Quantity_Interval_Disjoint.from_value(exponent)\n        if exp_val.min_elem != exp_val.max_elem:\n            raise ValueError(\n                \"exponent must be a single value for non-dimensionless base\"\n            )\n        units = base_unit**exp_val.min_elem.magnitude\n    assert isinstance(units, Unit)\n    self.units = units\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='^', placement=INFIX_FIRST)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Power.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Power.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Power.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Power.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Power.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log","title":"Log","text":"<pre><code>Log(operand)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>operand</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, operand):\n    super().__init__(operand)\n    if not operand.unit.is_compatible_with(dimensionless):\n        raise ValueError(\"operand must have dimensionless unit\")\n    self.units = dimensionless\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='log', placement=PREFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = dimensionless\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Log.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Log.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Log.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Log.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Log.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # non-negative\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin","title":"Sin","text":"<pre><code>Sin(operand)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>operand</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, operand):\n    super().__init__(operand)\n    if not operand.unit.is_compatible_with(dimensionless):\n        raise ValueError(\"operand must have dimensionless unit\")\n    self.units = dimensionless\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='sin', placement=PREFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = dimensionless\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Sin.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Sin.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Sin.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Sin.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Sin.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos","title":"Cos","text":"<pre><code>Cos(operand)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>operand</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, operand):\n    super().__init__(operand)\n    if not operand.unit.is_compatible_with(dimensionless):\n        raise ValueError(\"operand must have dimensionless unit\")\n    self.units = dimensionless\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='cos', placement=PREFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = dimensionless\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Cos.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Cos.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Cos.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Cos.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cos.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs","title":"Abs","text":"<pre><code>Abs(operand)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>operand</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, operand):\n    super().__init__(operand)\n    self.units = operand.units\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='|', placement=EMBRACE)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Abs.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Abs.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Abs.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Abs.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Abs.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round","title":"Round","text":"<pre><code>Round(operand)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>operand</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, operand):\n    super().__init__(operand)\n    self.units = operand.units\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='round', placement=PREFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Round.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Round.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Round.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Round.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Round.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor","title":"Floor","text":"<pre><code>Floor(operand)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>operand</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, operand):\n    super().__init__(operand)\n    self.units = operand.units\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u230a', placement=PREFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Floor.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Floor.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Floor.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Floor.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Floor.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil","title":"Ceil","text":"<pre><code>Ceil(operand)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>operand</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, operand):\n    super().__init__(operand)\n    self.units = operand.units\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u2308', placement=PREFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Ceil.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min","title":"Min","text":"<pre><code>Min(*operands)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands):\n    super().__init__(*operands)\n    self.units = assert_compatible_units(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='min', placement=PREFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = assert_compatible_units(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Min.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Min.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Min.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Min.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Min.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max","title":"Max","text":"<pre><code>Max(*operands)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands):\n    super().__init__(*operands)\n    self.units = assert_compatible_units(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='max', placement=PREFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = assert_compatible_units(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Max.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Max.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Max.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Max.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Max.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate","title":"Integrate","text":"<pre><code>Integrate(function, variable)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>function</code> <p> TYPE: <code>ParameterOperatable</code> </p> <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, function: \"ParameterOperatable\", variable: \"Parameter\"):\n    super().__init__(function, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = cast(Unit, None)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u222b', placement=PREFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Integrate.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate","title":"Differentiate","text":"<pre><code>Differentiate(function, variable)\n</code></pre> <p>               Bases: <code>Arithmetic</code></p> PARAMETER DESCRIPTION <code>function</code> <p> TYPE: <code>ParameterOperatable</code> </p> <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, function: \"ParameterOperatable\", variable: \"Parameter\"):\n    super().__init__(function, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = cast(tuple[NumberLike, ...], operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = cast(Unit, None)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='d', placement=PREFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Differentiate.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic","title":"Logic","text":"<pre><code>Logic(*operands)\n</code></pre> <p>               Bases: <code>ConstrainableExpression</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands):\n    super().__init__(*operands)\n    types = bool, BoolSet, Parameter, Logic, Predicate\n    if any(not isinstance(op, types) for op in operands):\n        raise ValueError(\"operands must be bool, Parameter, Logic, or Predicate\")\n    if any(\n        not isinstance(param.domain, Boolean)\n        or not param.units.is_compatible_with(dimensionless)\n        for param in operands\n        if isinstance(param, Parameter)\n    ):\n        raise ValueError(\"parameters must have domain Boolean without a unit\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Logic.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Logic.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Logic.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Logic.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Logic.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And","title":"And","text":"<pre><code>And(*operands)\n</code></pre> <p>               Bases: <code>Logic</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands):\n    super().__init__(*operands)\n    types = bool, BoolSet, Parameter, Logic, Predicate\n    if any(not isinstance(op, types) for op in operands):\n        raise ValueError(\"operands must be bool, Parameter, Logic, or Predicate\")\n    if any(\n        not isinstance(param.domain, Boolean)\n        or not param.units.is_compatible_with(dimensionless)\n        for param in operands\n        if isinstance(param, Parameter)\n    ):\n        raise ValueError(\"parameters must have domain Boolean without a unit\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u2227', placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.And.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.And.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.And.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.And.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.And.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.And.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.And.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or","title":"Or","text":"<pre><code>Or(*operands)\n</code></pre> <p>               Bases: <code>Logic</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands):\n    super().__init__(*operands)\n    types = bool, BoolSet, Parameter, Logic, Predicate\n    if any(not isinstance(op, types) for op in operands):\n        raise ValueError(\"operands must be bool, Parameter, Logic, or Predicate\")\n    if any(\n        not isinstance(param.domain, Boolean)\n        or not param.units.is_compatible_with(dimensionless)\n        for param in operands\n        if isinstance(param, Parameter)\n    ):\n        raise ValueError(\"parameters must have domain Boolean without a unit\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u2228', placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Or.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Or.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Or.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Or.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Or.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not","title":"Not","text":"<pre><code>Not(operand)\n</code></pre> <p>               Bases: <code>Logic</code></p> PARAMETER DESCRIPTION <code>operand</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, operand):\n    super().__init__(operand)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u00ac', placement=PREFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Not.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Not.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Not.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Not.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Not.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor","title":"Xor","text":"<pre><code>Xor(*operands)\n</code></pre> <p>               Bases: <code>Logic</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands):\n    super().__init__(*operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u2295', placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Xor.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Xor.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Xor.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Xor.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Xor.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies","title":"Implies","text":"<pre><code>Implies(condition, implication)\n</code></pre> <p>               Bases: <code>Logic</code></p> PARAMETER DESCRIPTION <code>condition</code> <p> </p> <code>implication</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, condition, implication):\n    super().__init__(condition, implication)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u21d2', placement=INFIX_FIRST)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Implies.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Implies.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Implies.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Implies.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Implies.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse","title":"IfThenElse","text":"<pre><code>IfThenElse(\n    condition, if_true=None, if_false=None, preference=None\n)\n</code></pre> <p>               Bases: <code>Expression</code></p> PARAMETER DESCRIPTION <code>condition</code> <p> TYPE: <code>ConstrainableExpression</code> </p> <code>if_true</code> <p> TYPE: <code>Callable[[], None] | None</code> DEFAULT: <code>None</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], None] | None</code> DEFAULT: <code>None</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(\n    self,\n    condition: ConstrainableExpression,\n    if_true: Callable[[], None] | None = None,\n    if_false: Callable[[], None] | None = None,\n    preference: bool | None = None,\n):\n    # FIXME domain\n    super().__init__(None, condition)\n\n    # TODO a bit hacky\n    self.non_operands = [\n        if_true or (lambda: None),\n        if_false or (lambda: None),\n        preference,\n    ]\n\n    # TODO actually implement this\n    if preference is not None:\n        if preference:\n            condition.constrain()\n            if if_true:\n                if_true()\n        else:\n            condition.operation_not().constrain()\n            if if_false:\n                if_false()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = [if_true or lambda: None, if_false or lambda: None, preference]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.if_true","title":"if_true  <code>property</code>","text":"<pre><code>if_true\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.if_false","title":"if_false  <code>property</code>","text":"<pre><code>if_false\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.preference","title":"preference  <code>property</code>","text":"<pre><code>preference\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IfThenElse.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic","title":"Setic","text":"<pre><code>Setic(*operands)\n</code></pre> <p>               Bases: <code>Expression</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands):\n    # FIXME domain\n    super().__init__(None, *operands)\n    # types = (Parameter, ParameterOperatable.Sets)\n    # if any(not isinstance(op, types) for op in operands):\n    #    raise ValueError(\"operands must be Parameter or Set\")\n    units = [HasUnit.get_units_or_dimensionless(op) for op in operands]\n    self.units = units[0]\n    for u in units[1:]:\n        if not self.units.is_compatible_with(u):\n            raise ValueError(\"all operands must have compatible units\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Setic.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Setic.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Setic.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Setic.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Setic.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union","title":"Union","text":"<pre><code>Union(*operands)\n</code></pre> <p>               Bases: <code>Setic</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands):\n    # FIXME domain\n    super().__init__(None, *operands)\n    # types = (Parameter, ParameterOperatable.Sets)\n    # if any(not isinstance(op, types) for op in operands):\n    #    raise ValueError(\"operands must be Parameter or Set\")\n    units = [HasUnit.get_units_or_dimensionless(op) for op in operands]\n    self.units = units[0]\n    for u in units[1:]:\n        if not self.units.is_compatible_with(u):\n            raise ValueError(\"all operands must have compatible units\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u222a', placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Union.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Union.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Union.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Union.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Union.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection","title":"Intersection","text":"<pre><code>Intersection(*operands)\n</code></pre> <p>               Bases: <code>Setic</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands):\n    # FIXME domain\n    super().__init__(None, *operands)\n    # types = (Parameter, ParameterOperatable.Sets)\n    # if any(not isinstance(op, types) for op in operands):\n    #    raise ValueError(\"operands must be Parameter or Set\")\n    units = [HasUnit.get_units_or_dimensionless(op) for op in operands]\n    self.units = units[0]\n    for u in units[1:]:\n        if not self.units.is_compatible_with(u):\n            raise ValueError(\"all operands must have compatible units\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u2229', placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Intersection.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference","title":"Difference","text":"<pre><code>Difference(minuend, subtrahend)\n</code></pre> <p>               Bases: <code>Setic</code></p> PARAMETER DESCRIPTION <code>minuend</code> <p> </p> <code>subtrahend</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, minuend, subtrahend):\n    super().__init__(minuend, subtrahend)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u2212', placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Difference.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Difference.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Difference.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Difference.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Difference.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference","title":"SymmetricDifference","text":"<pre><code>SymmetricDifference(*operands)\n</code></pre> <p>               Bases: <code>Setic</code></p> PARAMETER DESCRIPTION <code>*operands</code> <p> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, *operands):\n    # FIXME domain\n    super().__init__(None, *operands)\n    # types = (Parameter, ParameterOperatable.Sets)\n    # if any(not isinstance(op, types) for op in operands):\n    #    raise ValueError(\"operands must be Parameter or Set\")\n    units = [HasUnit.get_units_or_dimensionless(op) for op in operands]\n    self.units = units[0]\n    for u in units[1:]:\n        if not self.units.is_compatible_with(u):\n            raise ValueError(\"all operands must have compatible units\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u25b3', placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SymmetricDifference.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Domain","title":"Domain","text":""},{"location":"api/solver/#faebryk.core.parameter.Domain.get_shared_domain","title":"get_shared_domain  <code>staticmethod</code>","text":"<pre><code>get_shared_domain(*domains)\n</code></pre> PARAMETER DESCRIPTION <code>*domains</code> <p> TYPE: <code>Domain</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_shared_domain(*domains: \"Domain\") -&gt; \"Domain\":\n    if len(domains) == 0:\n        raise ValueError(\"No domains provided\")\n    if len(domains) == 1:\n        return domains[0]\n    one = domains[0]\n    two = domains[1]\n    match one:\n        case Boolean():\n            if not isinstance(two, Boolean):\n                raise ValueError(\n                    \"Boolean domain cannot be mixed with other domains\"\n                )\n            shared = Boolean()\n        case EnumDomain():\n            if not isinstance(two, EnumDomain):\n                raise ValueError(\"Enum domain cannot be mixed with other domains\")\n            if one.enum_t != two.enum_t:\n                raise ValueError(\"Enum domains must be of the same type\")\n            shared = EnumDomain(one.enum_t)\n        case Numbers():\n            if not isinstance(two, Numbers):\n                raise ValueError(\n                    \"Numbers domain cannot be mixed with other domains\"\n                )\n            if (\n                isinstance(one, ESeries)\n                and isinstance(two, ESeries)\n                and one.series == two.series\n            ):\n                shared = ESeries(one.series)\n            else:\n                shared = Numbers(\n                    negative=one.negative and two.negative,\n                    zero_allowed=one.zero_allowed and two.zero_allowed,\n                    integer=one.integer or two.integer,\n                )\n        case _:\n            raise ValueError(\"Unsupported domain\")\n\n    if len(domains) == 2:\n        return shared\n    return Domain.get_shared_domain(shared, *domains[2:])\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Domain.unbounded","title":"unbounded","text":"<pre><code>unbounded(param)\n</code></pre> PARAMETER DESCRIPTION <code>param</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def unbounded(self, param: \"Parameter\") -&gt; P_Set: ...\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Numbers","title":"Numbers","text":"<pre><code>Numbers(*, negative=True, zero_allowed=True, integer=False)\n</code></pre> <p>               Bases: <code>Domain</code></p> PARAMETER DESCRIPTION <code>negative</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>zero_allowed</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>integer</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(\n    self, *, negative: bool = True, zero_allowed: bool = True, integer: bool = False\n) -&gt; None:\n    super().__init__()\n    self.negative = negative\n    self.zero_allowed = zero_allowed\n    self.integer = integer\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Numbers.negative","title":"negative  <code>instance-attribute</code>","text":"<pre><code>negative = negative\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Numbers.zero_allowed","title":"zero_allowed  <code>instance-attribute</code>","text":"<pre><code>zero_allowed = zero_allowed\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Numbers.integer","title":"integer  <code>instance-attribute</code>","text":"<pre><code>integer = integer\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Numbers.get_shared_domain","title":"get_shared_domain  <code>staticmethod</code>","text":"<pre><code>get_shared_domain(*domains)\n</code></pre> PARAMETER DESCRIPTION <code>*domains</code> <p> TYPE: <code>Domain</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_shared_domain(*domains: \"Domain\") -&gt; \"Domain\":\n    if len(domains) == 0:\n        raise ValueError(\"No domains provided\")\n    if len(domains) == 1:\n        return domains[0]\n    one = domains[0]\n    two = domains[1]\n    match one:\n        case Boolean():\n            if not isinstance(two, Boolean):\n                raise ValueError(\n                    \"Boolean domain cannot be mixed with other domains\"\n                )\n            shared = Boolean()\n        case EnumDomain():\n            if not isinstance(two, EnumDomain):\n                raise ValueError(\"Enum domain cannot be mixed with other domains\")\n            if one.enum_t != two.enum_t:\n                raise ValueError(\"Enum domains must be of the same type\")\n            shared = EnumDomain(one.enum_t)\n        case Numbers():\n            if not isinstance(two, Numbers):\n                raise ValueError(\n                    \"Numbers domain cannot be mixed with other domains\"\n                )\n            if (\n                isinstance(one, ESeries)\n                and isinstance(two, ESeries)\n                and one.series == two.series\n            ):\n                shared = ESeries(one.series)\n            else:\n                shared = Numbers(\n                    negative=one.negative and two.negative,\n                    zero_allowed=one.zero_allowed and two.zero_allowed,\n                    integer=one.integer or two.integer,\n                )\n        case _:\n            raise ValueError(\"Unsupported domain\")\n\n    if len(domains) == 2:\n        return shared\n    return Domain.get_shared_domain(shared, *domains[2:])\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Numbers.unbounded","title":"unbounded","text":"<pre><code>unbounded(param)\n</code></pre> PARAMETER DESCRIPTION <code>param</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@override\ndef unbounded(self, param: \"Parameter\") -&gt; Quantity_Interval_Disjoint:\n    if self.integer:\n        raise NotImplementedError(\"Integer unbounded not implemented\")\n    if not self.zero_allowed:\n        raise NotImplementedError(\"Non-zero unbounded not implemented\")\n    if not self.negative:\n        return Quantity_Interval_Disjoint.from_value(\n            Quantity_Interval(\n                min=quantity(0, param.units), max=None, units=param.units\n            )\n        )\n    return Quantity_Interval_Disjoint.unbounded(param.units)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ESeries","title":"ESeries","text":"<pre><code>ESeries(series)\n</code></pre> <p>               Bases: <code>Numbers</code></p> PARAMETER DESCRIPTION <code>series</code> <p> TYPE: <code>SeriesType</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, series: SeriesType):\n    super().__init__(negative=False, zero_allowed=False, integer=False)\n    self.series = series\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ESeries.negative","title":"negative  <code>instance-attribute</code>","text":"<pre><code>negative = negative\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ESeries.zero_allowed","title":"zero_allowed  <code>instance-attribute</code>","text":"<pre><code>zero_allowed = zero_allowed\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ESeries.integer","title":"integer  <code>instance-attribute</code>","text":"<pre><code>integer = integer\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ESeries.series","title":"series  <code>instance-attribute</code>","text":"<pre><code>series = series\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ESeries.SeriesType","title":"SeriesType","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.ESeries.SeriesType.E6","title":"E6  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>E6 = auto()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ESeries.SeriesType.E12","title":"E12  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>E12 = auto()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ESeries.SeriesType.E24","title":"E24  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>E24 = auto()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ESeries.SeriesType.E48","title":"E48  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>E48 = auto()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ESeries.SeriesType.E96","title":"E96  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>E96 = auto()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ESeries.SeriesType.E192","title":"E192  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>E192 = auto()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ESeries.get_shared_domain","title":"get_shared_domain  <code>staticmethod</code>","text":"<pre><code>get_shared_domain(*domains)\n</code></pre> PARAMETER DESCRIPTION <code>*domains</code> <p> TYPE: <code>Domain</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_shared_domain(*domains: \"Domain\") -&gt; \"Domain\":\n    if len(domains) == 0:\n        raise ValueError(\"No domains provided\")\n    if len(domains) == 1:\n        return domains[0]\n    one = domains[0]\n    two = domains[1]\n    match one:\n        case Boolean():\n            if not isinstance(two, Boolean):\n                raise ValueError(\n                    \"Boolean domain cannot be mixed with other domains\"\n                )\n            shared = Boolean()\n        case EnumDomain():\n            if not isinstance(two, EnumDomain):\n                raise ValueError(\"Enum domain cannot be mixed with other domains\")\n            if one.enum_t != two.enum_t:\n                raise ValueError(\"Enum domains must be of the same type\")\n            shared = EnumDomain(one.enum_t)\n        case Numbers():\n            if not isinstance(two, Numbers):\n                raise ValueError(\n                    \"Numbers domain cannot be mixed with other domains\"\n                )\n            if (\n                isinstance(one, ESeries)\n                and isinstance(two, ESeries)\n                and one.series == two.series\n            ):\n                shared = ESeries(one.series)\n            else:\n                shared = Numbers(\n                    negative=one.negative and two.negative,\n                    zero_allowed=one.zero_allowed and two.zero_allowed,\n                    integer=one.integer or two.integer,\n                )\n        case _:\n            raise ValueError(\"Unsupported domain\")\n\n    if len(domains) == 2:\n        return shared\n    return Domain.get_shared_domain(shared, *domains[2:])\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.ESeries.unbounded","title":"unbounded","text":"<pre><code>unbounded(param)\n</code></pre> PARAMETER DESCRIPTION <code>param</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@override\ndef unbounded(self, param: \"Parameter\") -&gt; Quantity_Interval_Disjoint:\n    if self.integer:\n        raise NotImplementedError(\"Integer unbounded not implemented\")\n    if not self.zero_allowed:\n        raise NotImplementedError(\"Non-zero unbounded not implemented\")\n    if not self.negative:\n        return Quantity_Interval_Disjoint.from_value(\n            Quantity_Interval(\n                min=quantity(0, param.units), max=None, units=param.units\n            )\n        )\n    return Quantity_Interval_Disjoint.unbounded(param.units)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Boolean","title":"Boolean","text":"<p>               Bases: <code>Domain</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Boolean.get_shared_domain","title":"get_shared_domain  <code>staticmethod</code>","text":"<pre><code>get_shared_domain(*domains)\n</code></pre> PARAMETER DESCRIPTION <code>*domains</code> <p> TYPE: <code>Domain</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_shared_domain(*domains: \"Domain\") -&gt; \"Domain\":\n    if len(domains) == 0:\n        raise ValueError(\"No domains provided\")\n    if len(domains) == 1:\n        return domains[0]\n    one = domains[0]\n    two = domains[1]\n    match one:\n        case Boolean():\n            if not isinstance(two, Boolean):\n                raise ValueError(\n                    \"Boolean domain cannot be mixed with other domains\"\n                )\n            shared = Boolean()\n        case EnumDomain():\n            if not isinstance(two, EnumDomain):\n                raise ValueError(\"Enum domain cannot be mixed with other domains\")\n            if one.enum_t != two.enum_t:\n                raise ValueError(\"Enum domains must be of the same type\")\n            shared = EnumDomain(one.enum_t)\n        case Numbers():\n            if not isinstance(two, Numbers):\n                raise ValueError(\n                    \"Numbers domain cannot be mixed with other domains\"\n                )\n            if (\n                isinstance(one, ESeries)\n                and isinstance(two, ESeries)\n                and one.series == two.series\n            ):\n                shared = ESeries(one.series)\n            else:\n                shared = Numbers(\n                    negative=one.negative and two.negative,\n                    zero_allowed=one.zero_allowed and two.zero_allowed,\n                    integer=one.integer or two.integer,\n                )\n        case _:\n            raise ValueError(\"Unsupported domain\")\n\n    if len(domains) == 2:\n        return shared\n    return Domain.get_shared_domain(shared, *domains[2:])\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Boolean.unbounded","title":"unbounded","text":"<pre><code>unbounded(param)\n</code></pre> PARAMETER DESCRIPTION <code>param</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@override\ndef unbounded(self, param: \"Parameter\") -&gt; BoolSet:\n    return BoolSet.unbounded()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.EnumDomain","title":"EnumDomain","text":"<pre><code>EnumDomain(enum_t)\n</code></pre> <p>               Bases: <code>Domain</code></p> PARAMETER DESCRIPTION <code>enum_t</code> <p> TYPE: <code>type[Enum]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, enum_t: type[Enum]):\n    super().__init__()\n    self.enum_t = enum_t\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.EnumDomain.enum_t","title":"enum_t  <code>instance-attribute</code>","text":"<pre><code>enum_t = enum_t\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.EnumDomain.get_shared_domain","title":"get_shared_domain  <code>staticmethod</code>","text":"<pre><code>get_shared_domain(*domains)\n</code></pre> PARAMETER DESCRIPTION <code>*domains</code> <p> TYPE: <code>Domain</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_shared_domain(*domains: \"Domain\") -&gt; \"Domain\":\n    if len(domains) == 0:\n        raise ValueError(\"No domains provided\")\n    if len(domains) == 1:\n        return domains[0]\n    one = domains[0]\n    two = domains[1]\n    match one:\n        case Boolean():\n            if not isinstance(two, Boolean):\n                raise ValueError(\n                    \"Boolean domain cannot be mixed with other domains\"\n                )\n            shared = Boolean()\n        case EnumDomain():\n            if not isinstance(two, EnumDomain):\n                raise ValueError(\"Enum domain cannot be mixed with other domains\")\n            if one.enum_t != two.enum_t:\n                raise ValueError(\"Enum domains must be of the same type\")\n            shared = EnumDomain(one.enum_t)\n        case Numbers():\n            if not isinstance(two, Numbers):\n                raise ValueError(\n                    \"Numbers domain cannot be mixed with other domains\"\n                )\n            if (\n                isinstance(one, ESeries)\n                and isinstance(two, ESeries)\n                and one.series == two.series\n            ):\n                shared = ESeries(one.series)\n            else:\n                shared = Numbers(\n                    negative=one.negative and two.negative,\n                    zero_allowed=one.zero_allowed and two.zero_allowed,\n                    integer=one.integer or two.integer,\n                )\n        case _:\n            raise ValueError(\"Unsupported domain\")\n\n    if len(domains) == 2:\n        return shared\n    return Domain.get_shared_domain(shared, *domains[2:])\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.EnumDomain.unbounded","title":"unbounded","text":"<pre><code>unbounded(param)\n</code></pre> PARAMETER DESCRIPTION <code>param</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@override\ndef unbounded(self, param: \"Parameter\") -&gt; EnumSet:\n    return EnumSet.unbounded(self.enum_t)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate","title":"Predicate","text":"<pre><code>Predicate(left, right)\n</code></pre> <p>               Bases: <code>ConstrainableExpression</code></p> PARAMETER DESCRIPTION <code>left</code> <p> </p> <code>right</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, left, right):\n    super().__init__(left, right)\n    assert_compatible_units(self.operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Predicate.get_other_operand","title":"get_other_operand","text":"<pre><code>get_other_operand(operand)\n</code></pre> PARAMETER DESCRIPTION <code>operand</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_other_operand(\n    self, operand: ParameterOperatable.All\n) -&gt; ParameterOperatable.All:\n    if self.operands[0] is operand:\n        return self.operands[1]\n    return self.operands[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate","title":"NumericPredicate","text":"<pre><code>NumericPredicate(left, right)\n</code></pre> <p>               Bases: <code>Predicate</code></p> PARAMETER DESCRIPTION <code>left</code> <p> </p> <code>right</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, left, right):\n    super().__init__(left, right)\n\n    for op in self.operands:\n        if isinstance(op, Parameter) and not isinstance(\n            op.domain, (Numbers, ESeries)\n        ):\n            raise ValueError(\n                \"operand must have domain Numbers or ESeries,\"\n                f\" not {type(op.domain)}\"\n            )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NumericPredicate.get_other_operand","title":"get_other_operand","text":"<pre><code>get_other_operand(operand)\n</code></pre> PARAMETER DESCRIPTION <code>operand</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_other_operand(\n    self, operand: ParameterOperatable.All\n) -&gt; ParameterOperatable.All:\n    if self.operands[0] is operand:\n        return self.operands[1]\n    return self.operands[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan","title":"LessThan","text":"<pre><code>LessThan(left, right)\n</code></pre> <p>               Bases: <code>NumericPredicate</code></p> PARAMETER DESCRIPTION <code>left</code> <p> </p> <code>right</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, left, right):\n    super().__init__(left, right)\n\n    for op in self.operands:\n        if isinstance(op, Parameter) and not isinstance(\n            op.domain, (Numbers, ESeries)\n        ):\n            raise ValueError(\n                \"operand must have domain Numbers or ESeries,\"\n                f\" not {type(op.domain)}\"\n            )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='&lt;', placement=INFIX_FIRST)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessThan.get_other_operand","title":"get_other_operand","text":"<pre><code>get_other_operand(operand)\n</code></pre> PARAMETER DESCRIPTION <code>operand</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_other_operand(\n    self, operand: ParameterOperatable.All\n) -&gt; ParameterOperatable.All:\n    if self.operands[0] is operand:\n        return self.operands[1]\n    return self.operands[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan","title":"GreaterThan","text":"<pre><code>GreaterThan(left, right)\n</code></pre> <p>               Bases: <code>NumericPredicate</code></p> PARAMETER DESCRIPTION <code>left</code> <p> </p> <code>right</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, left, right):\n    super().__init__(left, right)\n\n    for op in self.operands:\n        if isinstance(op, Parameter) and not isinstance(\n            op.domain, (Numbers, ESeries)\n        ):\n            raise ValueError(\n                \"operand must have domain Numbers or ESeries,\"\n                f\" not {type(op.domain)}\"\n            )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='&gt;', placement=INFIX_FIRST)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterThan.get_other_operand","title":"get_other_operand","text":"<pre><code>get_other_operand(operand)\n</code></pre> PARAMETER DESCRIPTION <code>operand</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_other_operand(\n    self, operand: ParameterOperatable.All\n) -&gt; ParameterOperatable.All:\n    if self.operands[0] is operand:\n        return self.operands[1]\n    return self.operands[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual","title":"LessOrEqual","text":"<pre><code>LessOrEqual(left, right)\n</code></pre> <p>               Bases: <code>NumericPredicate</code></p> PARAMETER DESCRIPTION <code>left</code> <p> </p> <code>right</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, left, right):\n    super().__init__(left, right)\n\n    for op in self.operands:\n        if isinstance(op, Parameter) and not isinstance(\n            op.domain, (Numbers, ESeries)\n        ):\n            raise ValueError(\n                \"operand must have domain Numbers or ESeries,\"\n                f\" not {type(op.domain)}\"\n            )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u2264', placement=INFIX_FIRST)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.LessOrEqual.get_other_operand","title":"get_other_operand","text":"<pre><code>get_other_operand(operand)\n</code></pre> PARAMETER DESCRIPTION <code>operand</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_other_operand(\n    self, operand: ParameterOperatable.All\n) -&gt; ParameterOperatable.All:\n    if self.operands[0] is operand:\n        return self.operands[1]\n    return self.operands[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual","title":"GreaterOrEqual","text":"<pre><code>GreaterOrEqual(left, right)\n</code></pre> <p>               Bases: <code>NumericPredicate</code></p> PARAMETER DESCRIPTION <code>left</code> <p> </p> <code>right</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, left, right):\n    super().__init__(left, right)\n\n    for op in self.operands:\n        if isinstance(op, Parameter) and not isinstance(\n            op.domain, (Numbers, ESeries)\n        ):\n            raise ValueError(\n                \"operand must have domain Numbers or ESeries,\"\n                f\" not {type(op.domain)}\"\n            )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u2265', placement=INFIX_FIRST)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.GreaterOrEqual.get_other_operand","title":"get_other_operand","text":"<pre><code>get_other_operand(operand)\n</code></pre> PARAMETER DESCRIPTION <code>operand</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_other_operand(\n    self, operand: ParameterOperatable.All\n) -&gt; ParameterOperatable.All:\n    if self.operands[0] is operand:\n        return self.operands[1]\n    return self.operands[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual","title":"NotEqual","text":"<pre><code>NotEqual(left, right)\n</code></pre> <p>               Bases: <code>NumericPredicate</code></p> PARAMETER DESCRIPTION <code>left</code> <p> </p> <code>right</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, left, right):\n    super().__init__(left, right)\n\n    for op in self.operands:\n        if isinstance(op, Parameter) and not isinstance(\n            op.domain, (Numbers, ESeries)\n        ):\n            raise ValueError(\n                \"operand must have domain Numbers or ESeries,\"\n                f\" not {type(op.domain)}\"\n            )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u2260', placement=INFIX_FIRST)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.NotEqual.get_other_operand","title":"get_other_operand","text":"<pre><code>get_other_operand(operand)\n</code></pre> PARAMETER DESCRIPTION <code>operand</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_other_operand(\n    self, operand: ParameterOperatable.All\n) -&gt; ParameterOperatable.All:\n    if self.operands[0] is operand:\n        return self.operands[1]\n    return self.operands[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate","title":"SeticPredicate","text":"<pre><code>SeticPredicate(left, right)\n</code></pre> <p>               Bases: <code>Predicate</code></p> PARAMETER DESCRIPTION <code>left</code> <p> </p> <code>right</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, left, right):\n    super().__init__(left, right)\n    # types = ParameterOperatable, P_Set\n    # TODO\n    # if any(not isinstance(op, types) for op in self.operands):\n    #    raise ValueError(\"operands must be Parameter or Set\")\n    units = [HasUnit.get_units_or_dimensionless(op) for op in self.operands]\n    for u in units[1:]:\n        if not units[0].is_compatible_with(u):\n            raise ValueError(\"all operands must have compatible units\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.SeticPredicate.get_other_operand","title":"get_other_operand","text":"<pre><code>get_other_operand(operand)\n</code></pre> PARAMETER DESCRIPTION <code>operand</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_other_operand(\n    self, operand: ParameterOperatable.All\n) -&gt; ParameterOperatable.All:\n    if self.operands[0] is operand:\n        return self.operands[1]\n    return self.operands[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset","title":"IsSubset","text":"<pre><code>IsSubset(left, right)\n</code></pre> <p>               Bases: <code>SeticPredicate</code></p> PARAMETER DESCRIPTION <code>left</code> <p> </p> <code>right</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, left, right):\n    super().__init__(left, right)\n    # types = ParameterOperatable, P_Set\n    # TODO\n    # if any(not isinstance(op, types) for op in self.operands):\n    #    raise ValueError(\"operands must be Parameter or Set\")\n    units = [HasUnit.get_units_or_dimensionless(op) for op in self.operands]\n    for u in units[1:]:\n        if not units[0].is_compatible_with(u):\n            raise ValueError(\"all operands must have compatible units\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u2286', placement=INFIX_FIRST)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSubset.get_other_operand","title":"get_other_operand","text":"<pre><code>get_other_operand(operand)\n</code></pre> PARAMETER DESCRIPTION <code>operand</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_other_operand(\n    self, operand: ParameterOperatable.All\n) -&gt; ParameterOperatable.All:\n    if self.operands[0] is operand:\n        return self.operands[1]\n    return self.operands[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset","title":"IsSuperset","text":"<pre><code>IsSuperset(left, right)\n</code></pre> <p>               Bases: <code>SeticPredicate</code></p> PARAMETER DESCRIPTION <code>left</code> <p> </p> <code>right</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, left, right):\n    super().__init__(left, right)\n    # types = ParameterOperatable, P_Set\n    # TODO\n    # if any(not isinstance(op, types) for op in self.operands):\n    #    raise ValueError(\"operands must be Parameter or Set\")\n    units = [HasUnit.get_units_or_dimensionless(op) for op in self.operands]\n    for u in units[1:]:\n        if not units[0].is_compatible_with(u):\n            raise ValueError(\"all operands must have compatible units\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='\u2287', placement=INFIX_FIRST)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.IsSuperset.get_other_operand","title":"get_other_operand","text":"<pre><code>get_other_operand(operand)\n</code></pre> PARAMETER DESCRIPTION <code>operand</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_other_operand(\n    self, operand: ParameterOperatable.All\n) -&gt; ParameterOperatable.All:\n    if self.operands[0] is operand:\n        return self.operands[1]\n    return self.operands[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality","title":"Cardinality","text":"<pre><code>Cardinality(set, cardinality)\n</code></pre> <p>               Bases: <code>SeticPredicate</code></p> PARAMETER DESCRIPTION <code>set</code> <p> TYPE: <code>Sets</code> </p> <code>cardinality</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(\n    self, set: ParameterOperatable.Sets, cardinality: ParameterOperatable.NumberLike\n):\n    super().__init__(set, cardinality)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='||', placement=PREFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Cardinality.get_other_operand","title":"get_other_operand","text":"<pre><code>get_other_operand(operand)\n</code></pre> PARAMETER DESCRIPTION <code>operand</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_other_operand(\n    self, operand: ParameterOperatable.All\n) -&gt; ParameterOperatable.All:\n    if self.operands[0] is operand:\n        return self.operands[1]\n    return self.operands[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is","title":"Is","text":"<pre><code>Is(left, right)\n</code></pre> <p>               Bases: <code>Predicate</code></p> PARAMETER DESCRIPTION <code>left</code> <p> </p> <code>right</code> <p> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(self, left, right):\n    super().__init__(left, right)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operates_on","title":"operates_on  <code>instance-attribute</code>","text":"<pre><code>operates_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operands","title":"operands  <code>instance-attribute</code>","text":"<pre><code>operands = tuple(operands)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operatable_operands","title":"operatable_operands  <code>instance-attribute</code>","text":"<pre><code>operatable_operands = {\n    op\n    for op in operands\n    if isinstance(op, ParameterOperatable)\n}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.non_operands","title":"non_operands  <code>instance-attribute</code>","text":"<pre><code>non_operands = []\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.constrained","title":"constrained  <code>instance-attribute</code>","text":"<pre><code>constrained = False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.REPR_STYLE","title":"REPR_STYLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REPR_STYLE = ReprStyle(symbol='is', placement=INFIX_FIRST)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprStyle","title":"ReprStyle  <code>dataclass</code>","text":"<pre><code>ReprStyle(symbol=None, placement=INFIX)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprStyle.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprStyle.placement","title":"placement  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>placement = INFIX\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprStyle.Placement","title":"Placement","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprStyle.Placement.INFIX","title":"INFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX = auto()\n</code></pre> <p>A + B + C</p>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprStyle.Placement.INFIX_FIRST","title":"INFIX_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFIX_FIRST = auto()\n</code></pre> <p>A &gt; (B, C)</p>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprStyle.Placement.PREFIX","title":"PREFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFIX = auto()\n</code></pre> <p>\u00acA</p>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprStyle.Placement.POSTFIX","title":"POSTFIX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTFIX = auto()\n</code></pre> <p>A!</p>"},{"location":"api/solver/#faebryk.core.parameter.Is.ReprStyle.Placement.EMBRACE","title":"EMBRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMBRACE = auto()\n</code></pre> <p>|A|</p>"},{"location":"api/solver/#faebryk.core.parameter.Is.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Is.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Is.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return True  # opt out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    if self.has_implicit_constraint():\n        return True\n    for op in self.operands:\n        if isinstance(op, Expression) and op.has_implicit_constraints_recursive():\n            return True\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    style = type(self).REPR_STYLE\n    symbol = style.symbol\n    if symbol is None:\n        symbol = type(self).__name__\n\n    symbol_suffix = \"\"\n    if isinstance(self, ConstrainableExpression) and self.constrained:\n        # symbol = f\"\\033[4m{symbol}!\\033[0m\"\n        symbol_suffix += \"!\"\n        if self._solver_evaluates_to_true:\n            symbol_suffix += \"!\"\n    symbol += symbol_suffix\n    symbol += self._get_lit_suffix()\n\n    def format_operand(op):\n        if not isinstance(op, ParameterOperatable):\n            return str(op)\n        op_out = op.compact_repr(context)\n        if isinstance(op, Expression) and len(op.operands) &gt; 1:\n            op_out = f\"({op_out})\"\n        return op_out\n\n    formatted_operands = [format_operand(op) for op in self.operands]\n    out = \"\"\n    if style.placement == Expression.ReprStyle.Placement.PREFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{symbol}{formatted_operands[0]}\"\n        else:\n            out = f\"{symbol}({', '.join(formatted_operands)})\"\n    elif style.placement == Expression.ReprStyle.Placement.EMBRACE:\n        out = f\"{symbol}{', '.join(formatted_operands)}{symbol}\"\n    elif len(formatted_operands) == 0:\n        out = f\"{type(self).__name__}{symbol_suffix}()\"\n    elif style.placement == Expression.ReprStyle.Placement.POSTFIX:\n        if len(formatted_operands) == 1:\n            out = f\"{formatted_operands[0]}{symbol}\"\n        else:\n            out = f\"({', '.join(formatted_operands)}){symbol}\"\n    elif len(formatted_operands) == 1:\n        out = f\"{type(self).__name__}{symbol_suffix}({formatted_operands[0]})\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX:\n        symbol = f\" {symbol} \"\n        out = f\"{symbol.join(formatted_operands)}\"\n    elif style.placement == Expression.ReprStyle.Placement.INFIX_FIRST:\n        if len(formatted_operands) == 2:\n            out = f\"{formatted_operands[0]} {symbol} {formatted_operands[1]}\"\n        else:\n            out = (\n                f\"{formatted_operands[0]}{symbol}(\"\n                f\"{', '.join(formatted_operands[1:])})\"\n            )\n    else:\n        assert False\n    assert out\n\n    # out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_uncorrelatable_literals","title":"get_uncorrelatable_literals","text":"<pre><code>get_uncorrelatable_literals()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_uncorrelatable_literals(self) -&gt; list[ParameterOperatable.Literal]:\n    return [\n        lit\n        for lit in self.operands\n        # TODO we should just use the canonical lits, for now just no support\n        # for non-canonical lits\n        if not isinstance(lit, ParameterOperatable)\n        and (\n            not isinstance(lit, P_Set)\n            or not (lit.is_single_element() or lit.is_empty())\n        )\n    ]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_sorted_operands","title":"get_sorted_operands","text":"<pre><code>get_sorted_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef get_sorted_operands(self) -&gt; list[ParameterOperatable]:\n    return sorted(self.operands, key=hash)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.is_congruent_to","title":"is_congruent_to","text":"<pre><code>is_congruent_to(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Expression</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@once\ndef is_congruent_to(self, other: \"Expression\") -&gt; bool:\n    if self == other:\n        return True\n    if type(self) is not type(other):\n        return False\n    if len(self.operands) != len(other.operands):\n        return False\n\n    if self.get_uncorrelatable_literals() or other.get_uncorrelatable_literals():\n        return False\n\n    if self.operands == other.operands:\n        return True\n    if isinstance(self, Commutative):\n        # fucking genius\n        # lit hash is stable\n        # paramop hash only same with same id\n        left = self.get_sorted_operands()\n        right = other.get_sorted_operands()\n        if left == right:\n            return True\n\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_operatable_operands","title":"get_operatable_operands","text":"<pre><code>get_operatable_operands(types=ParameterOperatable)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T]</code> DEFAULT: <code>ParameterOperatable</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operatable_operands[T: ParameterOperatable](\n    self, types: type[T] = ParameterOperatable\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        self.operates_on.get_connected_nodes(types=[types]),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_literal_operands","title":"get_literal_operands","text":"<pre><code>get_literal_operands()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal_operands(self) -&gt; dict[int, ParameterOperatable.Literal]:\n    if isinstance(self, (Is, IsSubset)):\n        return {\n            i: o\n            for i, o in enumerate(self.operands)\n            if ParameterOperatable.is_literal(o)\n        }\n    # TODO not sure its a good idea to do this that recursive\n    return {\n        i: ParameterOperatable.try_extract_literal(o)\n        for i, o in enumerate(self.operands)\n    }\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.depth","title":"depth","text":"<pre><code>depth()\n</code></pre> <p>Returns depth of longest expression tree from this expression. <pre><code>((A + B) + (C + D)) * 5\n    ^    ^    ^     ^\n    0    1    0     2\n\na = (X + (Y + Z))\n(a + 1) + a\n ^ ^    ^ ^\n 1 2    3 1\n</code></pre></p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def depth(self) -&gt; int:\n    \"\"\"\n    Returns depth of longest expression tree from this expression.\n    ```\n    ((A + B) + (C + D)) * 5\n        ^    ^    ^     ^\n        0    1    0     2\n\n    a = (X + (Y + Z))\n    (a + 1) + a\n     ^ ^    ^ ^\n     1 2    3 1\n    ```\n    \"\"\"\n    # FIXME this does not work (if expressions are added afterwards in the tree)\n    if hasattr(self, \"_depth\"):\n        return self._depth\n    self._depth = 1 + max(\n        [0] + [Expression.get_depth(op) for op in self.operands],\n    )\n    return self._depth\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.constrain","title":"constrain","text":"<pre><code>constrain()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain(self):\n    self.constrained = True\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.if_then_else","title":"if_then_else","text":"<pre><code>if_then_else(if_true, if_false, preference=None)\n</code></pre> PARAMETER DESCRIPTION <code>if_true</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>if_false</code> <p> TYPE: <code>Callable[[], Any]</code> </p> <code>preference</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def if_then_else(\n    self,\n    if_true: Callable[[], Any],\n    if_false: Callable[[], Any],\n    preference: bool | None = None,\n):\n    return IfThenElse(self, if_true, if_false, preference)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Is.get_other_operand","title":"get_other_operand","text":"<pre><code>get_other_operand(operand)\n</code></pre> PARAMETER DESCRIPTION <code>operand</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_other_operand(\n    self, operand: ParameterOperatable.All\n) -&gt; ParameterOperatable.All:\n    if self.operands[0] is operand:\n        return self.operands[1]\n    return self.operands[0]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R","title":"R","text":"<p>               Bases: <code>Namespace</code></p> <p>Namespace holding Expressions, Domains and Predicates for Parameters. R = paRameters</p>"},{"location":"api/solver/#faebryk.core.parameter.R.Predicates","title":"Predicates","text":"<p>               Bases: <code>Namespace</code></p>"},{"location":"api/solver/#faebryk.core.parameter.R.Predicates.Element","title":"Element","text":"<p>               Bases: <code>Namespace</code></p>"},{"location":"api/solver/#faebryk.core.parameter.R.Predicates.Element.LT","title":"LT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LT = LessThan\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Predicates.Element.GT","title":"GT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GT = GreaterThan\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Predicates.Element.LE","title":"LE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LE = LessOrEqual\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Predicates.Element.GE","title":"GE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GE = GreaterOrEqual\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Predicates.Element.NE","title":"NE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NE = NotEqual\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Predicates.Set","title":"Set","text":"<p>               Bases: <code>Namespace</code></p>"},{"location":"api/solver/#faebryk.core.parameter.R.Predicates.Set.IS_SUBSET","title":"IS_SUBSET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IS_SUBSET = IsSubset\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Predicates.Set.IS_SUPERSET","title":"IS_SUPERSET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IS_SUPERSET = IsSuperset\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Domains","title":"Domains","text":"<p>               Bases: <code>Namespace</code></p>"},{"location":"api/solver/#faebryk.core.parameter.R.Domains.BOOL","title":"BOOL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOOL = Boolean\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Domains.ENUM","title":"ENUM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ENUM = EnumDomain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Domains.ESeries","title":"ESeries","text":"<p>               Bases: <code>Namespace</code></p>"},{"location":"api/solver/#faebryk.core.parameter.R.Domains.ESeries.E6","title":"E6  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>E6 = lambda: ESeries(E6)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Domains.ESeries.E12","title":"E12  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>E12 = lambda: ESeries(E12)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Domains.ESeries.E24","title":"E24  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>E24 = lambda: ESeries(E24)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Domains.ESeries.E48","title":"E48  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>E48 = lambda: ESeries(E48)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Domains.ESeries.E96","title":"E96  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>E96 = lambda: ESeries(E96)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Domains.ESeries.E192","title":"E192  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>E192 = lambda: ESeries(E192)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Domains.Numbers","title":"Numbers","text":"<p>               Bases: <code>Namespace</code></p>"},{"location":"api/solver/#faebryk.core.parameter.R.Domains.Numbers.REAL","title":"REAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REAL = Numbers\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Domains.Numbers.NATURAL","title":"NATURAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NATURAL = lambda: Numbers(integer=True, negative=False)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions","title":"Expressions","text":"<p>               Bases: <code>Namespace</code></p>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic","title":"Arithmetic","text":"<p>               Bases: <code>Namespace</code></p>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic.ADD","title":"ADD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ADD = Add\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic.SUBTRACT","title":"SUBTRACT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SUBTRACT = Subtract\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic.MULTIPLY","title":"MULTIPLY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MULTIPLY = Multiply\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic.DIVIDE","title":"DIVIDE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIVIDE = Divide\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic.POWER","title":"POWER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER = Power\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic.SQRT","title":"SQRT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SQRT = Sqrt\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic.LOG","title":"LOG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOG = Log\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic.ABS","title":"ABS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ABS = Abs\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic.FLOOR","title":"FLOOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FLOOR = Floor\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic.CEIL","title":"CEIL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CEIL = Ceil\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic.ROUND","title":"ROUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ROUND = Round\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic.SIN","title":"SIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SIN = Sin\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Arithmetic.COS","title":"COS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COS = Cos\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Logic","title":"Logic","text":"<p>               Bases: <code>Namespace</code></p>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Logic.AND","title":"AND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AND = And\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Logic.OR","title":"OR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OR = Or\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Logic.NOT","title":"NOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT = Not\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Logic.XOR","title":"XOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XOR = Xor\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Logic.IMPLIES","title":"IMPLIES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IMPLIES = Implies\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Set","title":"Set","text":"<p>               Bases: <code>Namespace</code></p>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Set.UNION","title":"UNION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNION = Union\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Set.INTERSECTION","title":"INTERSECTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTERSECTION = Intersection\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Set.DIFFERENCE","title":"DIFFERENCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIFFERENCE = Difference\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.R.Expressions.Set.SYMMETRIC_DIFFERENCE","title":"SYMMETRIC_DIFFERENCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYMMETRIC_DIFFERENCE = SymmetricDifference\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter","title":"Parameter","text":"<pre><code>Parameter(\n    *,\n    units=dimensionless,\n    within=None,\n    domain=Numbers(negative=False),\n    soft_set=None,\n    guess=None,\n    tolerance_guess=None,\n    likely_constrained=False\n)\n</code></pre> <p>               Bases: <code>ParameterOperatable</code></p> PARAMETER DESCRIPTION <code>units</code> <p> TYPE: <code>Unit | Quantity</code> DEFAULT: <code>dimensionless</code> </p> <code>within</code> <p> TYPE: <code>Quantity_Interval_Disjoint | Quantity_Interval | None</code> DEFAULT: <code>None</code> </p> <code>domain</code> <p> TYPE: <code>Domain</code> DEFAULT: <code>Numbers(negative=False)</code> </p> <code>soft_set</code> <p> TYPE: <code>Quantity_Interval_Disjoint | Quantity_Interval | None</code> DEFAULT: <code>None</code> </p> <code>guess</code> <p> TYPE: <code>Quantity | int | float | None</code> DEFAULT: <code>None</code> </p> <code>tolerance_guess</code> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>likely_constrained</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def __init__(\n    self,\n    *,\n    units: Unit | Quantity = dimensionless,\n    # hard constraints\n    within: Quantity_Interval_Disjoint | Quantity_Interval | None = None,\n    domain: Domain = Numbers(negative=False),\n    # soft constraints\n    soft_set: Quantity_Interval_Disjoint | Quantity_Interval | None = None,\n    guess: Quantity\n    | int\n    | float\n    | None = None,  # TODO actually allowed to be anything from domain\n    tolerance_guess: float | None = None,\n    # hints\n    likely_constrained: bool = False,  # TODO rename expect_constraits or similiar\n):\n    super().__init__()\n    if within is not None and not within.units.is_compatible_with(units):\n        raise ValueError(\"incompatible units\")\n\n    if isinstance(within, Quantity_Interval):\n        within = Quantity_Interval_Disjoint(within)\n\n    if isinstance(soft_set, Quantity_Interval):\n        soft_set = Quantity_Interval_Disjoint(soft_set)\n\n    if not isinstance(units, Unit):\n        raise TypeError(\"units must be a Unit\")\n    self.units = units\n    self.within = within\n    self._domain = domain\n    self.soft_set = soft_set\n    self.guess = guess\n    self.tolerance_guess = tolerance_guess\n    self.likely_constrained = likely_constrained\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operated_on","title":"operated_on  <code>instance-attribute</code>","text":"<pre><code>operated_on\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.inspect_solution","title":"inspect_solution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inspect_solution = lambda _: None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.within","title":"within  <code>instance-attribute</code>","text":"<pre><code>within = within\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.soft_set","title":"soft_set  <code>instance-attribute</code>","text":"<pre><code>soft_set = soft_set\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.guess","title":"guess  <code>instance-attribute</code>","text":"<pre><code>guess = guess\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.tolerance_guess","title":"tolerance_guess  <code>instance-attribute</code>","text":"<pre><code>tolerance_guess = tolerance_guess\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.likely_constrained","title":"likely_constrained  <code>instance-attribute</code>","text":"<pre><code>likely_constrained = likely_constrained\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.domain","title":"domain  <code>property</code>","text":"<pre><code>domain\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.ReprContext","title":"ReprContext  <code>dataclass</code>","text":"<pre><code>ReprContext(variable_mapping=VariableMapping())\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.ReprContext.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping = field(default_factory=VariableMapping)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.ReprContext.VariableMapping","title":"VariableMapping  <code>dataclass</code>","text":"<pre><code>VariableMapping(mapping=dict(), next_id=0)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.ReprContext.VariableMapping.mapping","title":"mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapping = field(default_factory=dict)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.ReprContext.VariableMapping.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT","title":"TraitT","text":"<pre><code>TraitT()\n</code></pre> <p>               Bases: <code>Trait</code></p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    CNode.transfer_ownership(self)\n    assert not hasattr(self, \"_is_setup\")\n    self._is_setup = True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.self_gif","title":"self_gif  <code>property</code>","text":"<pre><code>self_gif\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.children","title":"children  <code>property</code>","text":"<pre><code>children\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.parent","title":"parent  <code>property</code>","text":"<pre><code>parent\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.no_include_parents_in_full_name","title":"no_include_parents_in_full_name  <code>property</code> <code>writable</code>","text":"<pre><code>no_include_parents_in_full_name\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.runtime_anon","title":"runtime_anon  <code>instance-attribute</code>","text":"<pre><code>runtime_anon\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.runtime","title":"runtime  <code>instance-attribute</code>","text":"<pre><code>runtime\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.specialized_","title":"specialized_  <code>instance-attribute</code>","text":"<pre><code>specialized_\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.impl","title":"impl  <code>classmethod</code>","text":"<pre><code>impl()\n</code></pre> Source code in <code>src/faebryk/core/trait.py</code> <pre><code>@classmethod\ndef impl[T: \"Trait\"](cls: type[T]):\n    # Implements TraitImpl\n    class _Impl(cls):\n        __trait__: type[Trait] = cls\n\n        @property\n        def obj(self) -&gt; Node:\n            p = self.get_parent()\n            if not p:\n                raise TraitUnbound(self)\n            return cast_assert(Node, p[0])\n\n        def get_obj[TN: Node](self, type: type[TN]) -&gt; TN:\n            return cast_assert(type, self.obj)\n\n        def cmp(self, new_t: \"TraitImpl\") -&gt; tuple[bool, \"TraitImpl\"]:\n            assert TraitImpl.is_traitimpl(new_t)\n\n            # If new same or more specific\n            if new_t.implements(self.__trait__):\n                return True, new_t\n\n            # hack type (ghetto protocol)\n            traitimpl = cast(TraitImpl, self)\n\n            # If we are more specific\n            if self.implements(new_t.__trait__):\n                return True, traitimpl\n\n            return False, traitimpl\n\n        def implements(self, trait: type[Trait]):\n            return trait.is_traitimpl(self)\n\n        # Overwriteable ------------------------------------------------------------\n\n        def _handle_added_to_parent(self):\n            self.on_obj_set()\n\n        def on_obj_set(self): ...\n\n        def handle_duplicate(self, old: \"TraitImpl\", node: Node) -&gt; bool:\n            assert old is not self\n            _, candidate = old.cmp(cast(TraitImpl, self))\n            if candidate is not self:\n                # raise TraitAlreadyExists(node, self)\n                return False\n\n            node.del_trait(old.__trait__)\n            return True\n\n        # override this to implement a dynamic trait\n        def is_implemented(self):\n            return True\n\n    # this should be outside the class def to prevent\n    # __init_subclass__ from overwriting it\n    _Impl.__trait__ = cls\n    _Impl.__name__ = f\"{cls.__name__}Impl\"\n\n    return _Impl\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.decless","title":"decless  <code>classmethod</code>","text":"<pre><code>decless()\n</code></pre> Source code in <code>src/faebryk/core/trait.py</code> <pre><code>@classmethod\ndef decless(cls):\n    class _Trait(cls): ...\n\n    _Trait.__decless_trait__ = True\n\n    return _Trait.impl()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.TraitT.is_traitimpl","title":"is_traitimpl  <code>classmethod</code>","text":"<pre><code>is_traitimpl(obj)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>Trait</code> </p> Source code in <code>src/faebryk/core/trait.py</code> <pre><code>@classmethod\ndef is_traitimpl(cls, obj: \"Trait\") -&gt; TypeGuard[\"TraitImpl\"]:\n    assert issubclass(cls, Trait)\n    if not TraitImpl.is_traitimpl(obj):\n        return False\n    return issubclass(obj.__trait__, cls)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.transfer_ownership","title":"transfer_ownership  <code>staticmethod</code>","text":"<pre><code>transfer_ownership(arg)\n</code></pre> PARAMETER DESCRIPTION <code>arg</code> <p> TYPE: <code>Node</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_graph","title":"get_graph","text":"<pre><code>get_graph()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_children","title":"get_children","text":"<pre><code>get_children(\n    direct_only,\n    types,\n    include_root=False,\n    f_filter=None,\n    sort=True,\n)\n</code></pre> PARAMETER DESCRIPTION <code>direct_only</code> <p> TYPE: <code>bool</code> </p> <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_children[T: Node](\n    self,\n    direct_only: bool,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = False,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; set[T]:\n    return cast(\n        set[T],\n        set(\n            super().get_children(\n                direct_only=direct_only,\n                types=types if isinstance(types, tuple) else (types,),\n                include_root=include_root,\n                f_filter=f_filter,  # type: ignore\n                sort=sort,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_parent","title":"get_parent","text":"<pre><code>get_parent()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_parent_force","title":"get_parent_force","text":"<pre><code>get_parent_force()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_name","title":"get_name","text":"<pre><code>get_name(accept_no_parent=False)\n</code></pre> PARAMETER DESCRIPTION <code>accept_no_parent</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_hierarchy","title":"get_hierarchy","text":"<pre><code>get_hierarchy()\n</code></pre> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_hierarchy(self) -&gt; list[tuple[\"Node\", str]]:\n    return [(cast_assert(Node, n), name) for n, name in super().get_hierarchy()]\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_full_name","title":"get_full_name","text":"<pre><code>get_full_name(types=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.bfs_node","title":"bfs_node","text":"<pre><code>bfs_node(filter)\n</code></pre> PARAMETER DESCRIPTION <code>filter</code> <p> TYPE: <code>Callable[[Path], bool]</code> </p>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.add","title":"add","text":"<pre><code>add(obj, name=None, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>obj</code> <p> TYPE: <code>T</code> </p> <code>name</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>container</code> <p> TYPE: <code>Sequence | dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add[T: Node | GraphInterface](\n    self,\n    obj: T,\n    name: str | None = None,\n    container: Sequence | dict[str, Any] | None = None,\n) -&gt; T:\n    assert obj is not None\n\n    if container is None:\n        if name:\n            container = self.runtime\n        else:\n            container = self.runtime_anon\n\n    try:\n        container_name = find(vars(self).items(), lambda x: x[1] is container)[0]\n    except KeyErrorNotFound:\n        raise FieldContainerError(\"Container not in fields\")\n\n    if name:\n        if not isinstance(container, dict):\n            raise FieldContainerError(f\"Expected dict got {type(container)}\")\n        if name in container:\n            raise FieldExistsError(name)\n        # TODO consider setting name for non runtime container\n        # if container is not self.runtime:\n        #   name = f\"{container_name}[{name}]\"\n        pass\n    else:\n        if not isinstance(container, list):\n            raise FieldContainerError(f\"Expected list got {type(container)}\")\n        name = f\"{container_name}[{len(container)}]\"\n\n    try:\n        if isinstance(obj, GraphInterface):\n            self._handle_add_gif(name, obj)\n        else:\n            self._handle_add_node(name, obj)\n    except Node._Skipped:\n        return obj\n\n    # add to container\n    if isinstance(container, dict):\n        container[name] = obj\n    else:\n        container.append(obj)\n\n    return obj\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.add_to_container","title":"add_to_container","text":"<pre><code>add_to_container(n, factory, container=None)\n</code></pre> PARAMETER DESCRIPTION <code>n</code> <p> TYPE: <code>int</code> </p> <code>factory</code> <p> TYPE: <code>Callable[[], T]</code> </p> <code>container</code> <p> TYPE: <code>Sequence[Node] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def add_to_container[T: Node](\n    self,\n    n: int,\n    factory: Callable[[], T],\n    container: Sequence[\"Node\"] | None = None,\n):\n    if container is None:\n        container = self.runtime_anon\n\n    constr = [factory() for _ in range(n)]\n    for obj in constr:\n        self.add(obj, container=container)\n    return constr\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.builder","title":"builder","text":"<pre><code>builder(op)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>Callable[[Self], Any]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def builder(self, op: Callable[[Self], Any]) -&gt; Self:\n    op(self)\n    return self\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.pretty_params","title":"pretty_params","text":"<pre><code>pretty_params(solver=None)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def pretty_params(self, solver: \"Solver | None\" = None) -&gt; str:\n    from faebryk.core.parameter import Parameter\n\n    params = {\n        not_none(p.get_parent())[1]: p\n        for p in self.get_children(direct_only=True, types=Parameter)\n    }\n    params_str = \"\\n\".join(\n        f\"{k}: {solver.inspect_get_known_supersets(v, force_update=False)\n                if solver else v}\"\n        for k, v in params.items()\n    )\n\n    return params_str\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.relative_address","title":"relative_address","text":"<pre><code>relative_address(root=None)\n</code></pre> <p>Return the address from root to self</p> PARAMETER DESCRIPTION <code>root</code> <p> TYPE: <code>Node | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def relative_address(self, root: \"Node | None\" = None) -&gt; str:\n    \"\"\"Return the address from root to self\"\"\"\n    if root is None:\n        return self.get_full_name()\n\n    root_name = root.get_full_name()\n    self_name = self.get_full_name()\n    if not self_name.startswith(root_name):\n        raise ValueError(f\"Root {root_name} is not an ancestor of {self_name}\")\n\n    return self_name.removeprefix(root_name + \".\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.add_trait","title":"add_trait","text":"<pre><code>add_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>_TImpl</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@deprecated(\"Just use add\")\ndef add_trait[_TImpl: \"TraitImpl\"](self, trait: _TImpl) -&gt; _TImpl:\n    return self.add(trait)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.del_trait","title":"del_trait","text":"<pre><code>del_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def del_trait(self, trait: type[\"Trait\"]):\n    impl = self._find_trait_impl(trait, only_implemented=False)\n    if not impl:\n        return\n    self._remove_child(impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.try_get_trait","title":"try_get_trait","text":"<pre><code>try_get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def try_get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V | None:\n    return self._find_trait_impl(trait, only_implemented=True)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.has_trait","title":"has_trait","text":"<pre><code>has_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[Trait | TraitImpl]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def has_trait(self, trait: type[\"Trait | TraitImpl\"]) -&gt; bool:\n    try:\n        return self.try_get_trait(trait) is not None\n    except KeyErrorAmbiguous:\n        return True\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>Type[V]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_trait[V: \"Trait | TraitImpl\"](self, trait: Type[V]) -&gt; V:\n    from faebryk.core.trait import Trait, TraitNotFound\n\n    impl = self.try_get_trait(trait)\n    if not impl:\n        raise TraitNotFound(self, cast(type[Trait], trait))\n\n    return cast_assert(trait, impl)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_tree","title":"get_tree","text":"<pre><code>get_tree(\n    types, include_root=True, f_filter=None, sort=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | tuple[type[T], ...]</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>f_filter</code> <p> TYPE: <code>Callable[[T], bool] | None</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_tree[T: Node](\n    self,\n    types: type[T] | tuple[type[T], ...],\n    include_root: bool = True,\n    f_filter: Callable[[T], bool] | None = None,\n    sort: bool = True,\n) -&gt; Tree[T]:\n    out = self.get_children(\n        direct_only=True,\n        types=types,\n        f_filter=f_filter,\n        sort=sort,\n    )\n\n    tree = Tree[T](\n        {\n            n: n.get_tree(\n                types=types,\n                include_root=False,\n                f_filter=f_filter,\n                sort=sort,\n            )\n            for n in out\n        }\n    )\n\n    if include_root:\n        if isinstance(self, types):\n            if not f_filter or f_filter(self):\n                tree = Tree[T]({self: tree})\n\n    return tree\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_nodes_from_gifs","title":"get_nodes_from_gifs  <code>staticmethod</code>","text":"<pre><code>get_nodes_from_gifs(gifs)\n</code></pre> PARAMETER DESCRIPTION <code>gifs</code> <p> TYPE: <code>Iterable[GraphInterface]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef get_nodes_from_gifs(gifs: Iterable[GraphInterface]):\n    # TODO move this to gif?\n    return {gif.node for gif in gifs}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_parent_f","title":"get_parent_f","text":"<pre><code>get_parent_f(\n    filter_expr, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>filter_expr</code> <p> TYPE: <code>Callable[[Node], bool]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_f(\n    self,\n    filter_expr: Callable[[\"Node\"], bool],\n    direct_only: bool = False,\n    include_root: bool = True,\n):\n    parents = [p for p, _ in self.get_hierarchy()]\n    if not include_root:\n        parents = parents[:-1]\n    if direct_only:\n        parents = parents[-1:]\n    for p in reversed(parents):\n        if filter_expr(p):\n            return p\n    return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_parent_of_type","title":"get_parent_of_type","text":"<pre><code>get_parent_of_type(\n    parent_type, direct_only=False, include_root=True\n)\n</code></pre> PARAMETER DESCRIPTION <code>parent_type</code> <p> TYPE: <code>type[T]</code> </p> <code>direct_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_root</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_of_type[T: Node](\n    self, parent_type: type[T], direct_only: bool = False, include_root: bool = True\n) -&gt; T | None:\n    return cast(\n        parent_type | None,\n        self.get_parent_f(\n            lambda p: isinstance(p, parent_type),\n            direct_only=direct_only,\n            include_root=include_root,\n        ),\n    )\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_parent_with_trait","title":"get_parent_with_trait","text":"<pre><code>get_parent_with_trait(trait, include_self=True)\n</code></pre> PARAMETER DESCRIPTION <code>trait</code> <p> TYPE: <code>type[TR]</code> </p> <code>include_self</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_parent_with_trait[TR: Trait](\n    self, trait: type[TR], include_self: bool = True\n):\n    hierarchy = self.get_hierarchy()\n    if not include_self:\n        hierarchy = hierarchy[:-1]\n    for parent, _ in reversed(hierarchy):\n        if parent.has_trait(trait):\n            return parent, parent.get_trait(trait)\n    raise KeyErrorNotFound(f\"No parent with trait {trait} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_first_child_of_type","title":"get_first_child_of_type","text":"<pre><code>get_first_child_of_type(child_type)\n</code></pre> PARAMETER DESCRIPTION <code>child_type</code> <p> TYPE: <code>type[U]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def get_first_child_of_type[U: Node](self, child_type: type[U]) -&gt; U:\n    for level in self.get_tree(types=Node).iter_by_depth():\n        for child in level:\n            if isinstance(child, child_type):\n                return child\n    raise KeyErrorNotFound(f\"No child of type {child_type} found\")\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.zip_children_by_name_with","title":"zip_children_by_name_with","text":"<pre><code>zip_children_by_name_with(other, sub_type)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Node</code> </p> <code>sub_type</code> <p> TYPE: <code>type[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def zip_children_by_name_with[N: Node](\n    self, other: \"Node\", sub_type: type[N]\n) -&gt; dict[str, tuple[N, N]]:\n    nodes = self, other\n    children = tuple(\n        Node.with_names(\n            n.get_children(direct_only=True, include_root=False, types=sub_type)\n        )\n        for n in nodes\n    )\n    return zip_dicts_by_key(*children)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.with_names","title":"with_names  <code>staticmethod</code>","text":"<pre><code>with_names(nodes)\n</code></pre> PARAMETER DESCRIPTION <code>nodes</code> <p> TYPE: <code>Iterable[N]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>@staticmethod\ndef with_names[N: Node](nodes: Iterable[N]) -&gt; dict[str, N]:\n    return {n.get_name(): n for n in nodes}\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.nearest_common_ancestor","title":"nearest_common_ancestor","text":"<pre><code>nearest_common_ancestor(*others)\n</code></pre> <p>Finds the nearest common ancestor of the given nodes, or None if no common ancestor exists</p> PARAMETER DESCRIPTION <code>*others</code> <p> TYPE: <code>Node</code> DEFAULT: <code>()</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def nearest_common_ancestor(self, *others: \"Node\") -&gt; tuple[\"Node\", str] | None:\n    \"\"\"\n    Finds the nearest common ancestor of the given nodes, or None if no common\n    ancestor exists\n    \"\"\"\n    nodes = [self, *others]\n    if not nodes:\n        return None\n\n    # Get hierarchies for all nodes\n    hierarchies = [list(n.get_hierarchy()) for n in nodes]\n    min_length = min(len(h) for h in hierarchies)\n\n    # Find the last matching ancestor\n    last_match = None\n    for i in range(min_length):\n        ref_node, ref_name = hierarchies[0][i]\n        if any(h[i][0] is not ref_node for h in hierarchies[1:]):\n            break\n        last_match = (ref_node, ref_name)\n\n    return last_match\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_add","title":"operation_add","text":"<pre><code>operation_add(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_add(self, other: NumberLike):\n    return Add(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_subtract","title":"operation_subtract","text":"<pre><code>operation_subtract(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_subtract(self: NumberLike, other: NumberLike):\n    return Subtract(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_multiply","title":"operation_multiply","text":"<pre><code>operation_multiply(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_multiply(self, other: NumberLike):\n    return Multiply(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_divide","title":"operation_divide","text":"<pre><code>operation_divide(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_divide(self: NumberLike, other: NumberLike):\n    return Divide(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_power","title":"operation_power","text":"<pre><code>operation_power(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_power(self, other: NumberLike):\n    return Power(base=self, exponent=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_log","title":"operation_log","text":"<pre><code>operation_log()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_log(self):\n    return Log(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_sqrt","title":"operation_sqrt","text":"<pre><code>operation_sqrt()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sqrt(self):\n    return Sqrt(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_abs","title":"operation_abs","text":"<pre><code>operation_abs()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_abs(self):\n    return Abs(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_min","title":"operation_min","text":"<pre><code>operation_min()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_min(self):\n    return Min(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_max","title":"operation_max","text":"<pre><code>operation_max()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_max(self):\n    return Max(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_integrate","title":"operation_integrate","text":"<pre><code>operation_integrate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_integrate(self, variable: \"Parameter\"):\n    return Integrate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_differentiate","title":"operation_differentiate","text":"<pre><code>operation_differentiate(variable)\n</code></pre> PARAMETER DESCRIPTION <code>variable</code> <p> TYPE: <code>Parameter</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_differentiate(self, variable: \"Parameter\"):\n    return Differentiate(self, variable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_negate","title":"operation_negate","text":"<pre><code>operation_negate()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_negate(self):\n    return Multiply(self, quantity(-1))\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_invert","title":"operation_invert","text":"<pre><code>operation_invert()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_invert(self):\n    return Power(self, -1)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_floor","title":"operation_floor","text":"<pre><code>operation_floor()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_floor(self):\n    return Floor(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_ceil","title":"operation_ceil","text":"<pre><code>operation_ceil()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_ceil(self):\n    return Ceil(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_round","title":"operation_round","text":"<pre><code>operation_round()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_round(self):\n    return Round(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_sin","title":"operation_sin","text":"<pre><code>operation_sin()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_sin(self):\n    return Sin(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_cos","title":"operation_cos","text":"<pre><code>operation_cos()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_cos(self):\n    return Cos(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_union","title":"operation_union","text":"<pre><code>operation_union(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_union(self, other: Sets):\n    return Union(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_intersection","title":"operation_intersection","text":"<pre><code>operation_intersection(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_intersection(self, other: Sets):\n    return Intersection(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_difference","title":"operation_difference","text":"<pre><code>operation_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_difference(self, other: Sets):\n    return Difference(minuend=self, subtrahend=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_symmetric_difference","title":"operation_symmetric_difference","text":"<pre><code>operation_symmetric_difference(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_symmetric_difference(self, other: Sets):\n    return SymmetricDifference(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_and","title":"operation_and","text":"<pre><code>operation_and(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_and(self, other: BooleanLike):\n    return And(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_or","title":"operation_or","text":"<pre><code>operation_or(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_or(self, other: BooleanLike):\n    return Or(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_not","title":"operation_not","text":"<pre><code>operation_not()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_not(self):\n    return Not(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_xor","title":"operation_xor","text":"<pre><code>operation_xor(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_xor(self, other: BooleanLike):\n    return Xor(self, other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_implies","title":"operation_implies","text":"<pre><code>operation_implies(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>BooleanLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_implies(self, other: BooleanLike):\n    return Implies(condition=self, implication=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_is_le","title":"operation_is_le","text":"<pre><code>operation_is_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_le(self, other: NumberLike):\n    return LessOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_is_ge","title":"operation_is_ge","text":"<pre><code>operation_is_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ge(self, other: NumberLike):\n    return GreaterOrEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_is_lt","title":"operation_is_lt","text":"<pre><code>operation_is_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_lt(self, other: NumberLike):\n    return LessThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_is_gt","title":"operation_is_gt","text":"<pre><code>operation_is_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_gt(self, other: NumberLike):\n    return GreaterThan(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_is_ne","title":"operation_is_ne","text":"<pre><code>operation_is_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_ne(self, other: NumberLike):\n    return NotEqual(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_is_subset","title":"operation_is_subset","text":"<pre><code>operation_is_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_subset(self, other: Sets):\n    return IsSubset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.operation_is_superset","title":"operation_is_superset","text":"<pre><code>operation_is_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def operation_is_superset(self, other: Sets):\n    return IsSuperset(left=self, right=other)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.inspect_add_on_solution","title":"inspect_add_on_solution","text":"<pre><code>inspect_add_on_solution(fun)\n</code></pre> PARAMETER DESCRIPTION <code>fun</code> <p> TYPE: <code>Callable[[Self], None]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def inspect_add_on_solution(self, fun: Callable[[Self], None]) -&gt; None:\n    current = self.inspect_solution\n\n    def new(self2):\n        current(self2)\n        fun(self2)\n\n    self.inspect_solution = new\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.alias_is","title":"alias_is","text":"<pre><code>alias_is(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def alias_is(self, other: All):\n    return Is(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.constrain_le","title":"constrain_le","text":"<pre><code>constrain_le(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_le(self, other: NumberLike):\n    return self.operation_is_le(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.constrain_ge","title":"constrain_ge","text":"<pre><code>constrain_ge(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ge(self, other: NumberLike):\n    return self.operation_is_ge(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.constrain_lt","title":"constrain_lt","text":"<pre><code>constrain_lt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_lt(self, other: NumberLike):\n    # makes implementation easier for now\n    # le should be enough\n    raise NotImplementedError()\n    return self.operation_is_lt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.constrain_gt","title":"constrain_gt","text":"<pre><code>constrain_gt(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_gt(self, other: NumberLike):\n    # makes implementation easier for now\n    # ge should be enough\n    raise NotImplementedError()\n    return self.operation_is_gt(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.constrain_ne","title":"constrain_ne","text":"<pre><code>constrain_ne(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>NumberLike</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_ne(self, other: NumberLike):\n    # want to see when this is useful in practice\n    raise NotImplementedError()\n    return self.operation_is_ne(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.constrain_subset","title":"constrain_subset","text":"<pre><code>constrain_subset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_subset(self, other: Sets):\n    return self.operation_is_subset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.constrain_superset","title":"constrain_superset","text":"<pre><code>constrain_superset(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>Sets</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_superset(self, other: Sets):\n    return self.operation_is_superset(other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.constrain_cardinality","title":"constrain_cardinality","text":"<pre><code>constrain_cardinality(other)\n</code></pre> PARAMETER DESCRIPTION <code>other</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def constrain_cardinality(self, other: int):\n    return Cardinality(self, other).constrain()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_operations","title":"get_operations","text":"<pre><code>get_operations(types=None, constrained_only=False)\n</code></pre> PARAMETER DESCRIPTION <code>types</code> <p> TYPE: <code>type[T] | None</code> DEFAULT: <code>None</code> </p> <code>constrained_only</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_operations[T: \"Expression\"](\n    self, types: type[T] | None = None, constrained_only: bool = False\n) -&gt; set[T]:\n    if types is None:\n        types = Expression  # type: ignore\n    types = cast(type[T], types)\n    assert issubclass(types, Expression)\n\n    out = cast(set[T], self.operated_on.get_connected_nodes(types=[types]))\n    if constrained_only:\n        assert issubclass(types, ConstrainableExpression)\n        out = {i for i in out if cast(ConstrainableExpression, i).constrained}\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_literal","title":"get_literal","text":"<pre><code>get_literal(op=None)\n</code></pre> <pre><code>P(self, X) \u2227 P.constrained -&gt; return X\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_literal(self, op: type[\"ConstrainableExpression\"] | None = None) -&gt; Literal:\n    \"\"\"\n    ```\n    P(self, X) \u2227 P.constrained -&gt; return X\n    ```\n    \"\"\"\n    if op is None:\n        op = Is\n    # we have logic for is and is_subset in this function,\n    # let's find a usecase for other ops before allowing them\n    if not issubclass(op, (Is, IsSubset)):\n        raise ValueError(f\"Unsupported op {op}\")\n    ops = self.get_operations(op, constrained_only=True)\n    try:\n        if op is IsSubset:\n            literals = find(\n                lit\n                for op in ops\n                for (i, lit) in op.get_literal_operands().items()\n                if i &gt; 0\n            )\n        else:\n            literals = find(\n                lit for op in ops for (_, lit) in op.get_literal_operands().items()\n            )\n    except KeyErrorNotFound as e:\n        raise ParameterOperableHasNoLiteral(\n            self, f\"Parameter {self} has no literal for op {op}\"\n        ) from e\n    except KeyErrorAmbiguous as e:\n        duplicates = e.duplicates\n        if issubclass(op, Is):\n            if len(unique(duplicates, key=lambda x: x)) != 1:\n                raise\n            return duplicates[0]\n        elif issubclass(op, IsSubset):\n            return P_Set.intersect_all(*duplicates)\n        else:\n            raise\n    return literals\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.try_get_literal_subset","title":"try_get_literal_subset","text":"<pre><code>try_get_literal_subset()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_subset(self) -&gt; Literal | None:\n    lits = self.try_get_literal_for_multiple_ops([Is, IsSubset])\n    if not lits:\n        return None\n    if len(lits) == 1:\n        return next(iter(lits.values()))\n\n    is_lit, ss_lit = map(P_Set.from_value, (lits[Is], lits[IsSubset]))\n    if not is_lit.is_subset_of(ss_lit):\n        raise KeyErrorAmbiguous(list(lits.values()))\n    return is_lit\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.try_get_literal","title":"try_get_literal","text":"<pre><code>try_get_literal(op=None)\n</code></pre> PARAMETER DESCRIPTION <code>op</code> <p> TYPE: <code>type[ConstrainableExpression] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal(\n    self, op: type[\"ConstrainableExpression\"] | None = None\n) -&gt; Literal | None:\n    try:\n        return self.get_literal(op)\n    except ParameterOperableHasNoLiteral:\n        return None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.try_get_literal_for_multiple_ops","title":"try_get_literal_for_multiple_ops","text":"<pre><code>try_get_literal_for_multiple_ops(ops)\n</code></pre> PARAMETER DESCRIPTION <code>ops</code> <p> TYPE: <code>list[type[ConstrainableExpression]]</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def try_get_literal_for_multiple_ops(\n    self, ops: list[type[\"ConstrainableExpression\"]]\n) -&gt; dict[type[\"ConstrainableExpression\"], Literal] | None:\n    lits = {op: self.try_get_literal(op) for op in ops}\n    lits = {op: lit for op, lit in lits.items() if lit is not None}\n    return lits if lits else None\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.try_extract_literal","title":"try_extract_literal  <code>staticmethod</code>","text":"<pre><code>try_extract_literal(po, allow_subset=False)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> <code>allow_subset</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef try_extract_literal(\n    po: \"ParameterOperatable.All\", allow_subset: bool = False\n) -&gt; Literal | None:\n    if ParameterOperatable.is_literal(po):\n        return po\n    assert isinstance(po, ParameterOperatable)\n    if allow_subset:\n        return po.try_get_literal_subset()\n    return po.try_get_literal()\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.is_number_literal","title":"is_number_literal  <code>staticmethod</code>","text":"<pre><code>is_number_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_number_literal(value: Any) -&gt; TypeGuard[QuantityLike]:\n    return isinstance(value, QuantityLikeR)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.is_literal","title":"is_literal  <code>staticmethod</code>","text":"<pre><code>is_literal(value)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef is_literal(value: Any) -&gt; TypeGuard[Literal]:\n    return not isinstance(value, ParameterOperatable)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.sort_by_depth","title":"sort_by_depth  <code>staticmethod</code>","text":"<pre><code>sort_by_depth(exprs, ascending)\n</code></pre> <p>Ascending: <pre><code>(A + B) + (C + D)\n-&gt; [(A+B), (C+D), (A+B)+(C+D)]\n</code></pre></p> PARAMETER DESCRIPTION <code>exprs</code> <p> TYPE: <code>Iterable[T]</code> </p> <code>ascending</code> <p> TYPE: <code>bool</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef sort_by_depth[T: ParameterOperatable](\n    exprs: Iterable[T], ascending: bool\n) -&gt; list[T]:\n    \"\"\"\n    Ascending:\n    ```\n    (A + B) + (C + D)\n    -&gt; [(A+B), (C+D), (A+B)+(C+D)]\n    ```\n    \"\"\"\n    return sorted(exprs, key=ParameterOperatable.get_depth, reverse=not ascending)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_depth","title":"get_depth  <code>staticmethod</code>","text":"<pre><code>get_depth(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>@staticmethod\ndef get_depth(po: \"ParameterOperatable.All\") -&gt; int:\n    if isinstance(po, Expression):\n        return po.depth()\n    return 0\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.has_implicit_constraint","title":"has_implicit_constraint","text":"<pre><code>has_implicit_constraint()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraint(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.compact_repr","title":"compact_repr","text":"<pre><code>compact_repr(context=None)\n</code></pre> <p>Unit only printed if not dimensionless.</p> <p>Letters: <pre><code>A-Z, a-z, \u03b1-\u03c9\nA\u2081-Z\u2081, a\u2081-z\u2081, \u03b1\u2081-\u03c9\u2081\nA\u2082-Z\u2082, a\u2082-z\u2082, \u03b1\u2082-\u03c9\u2082\n...\n</code></pre></p> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ReprContext | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def compact_repr(\n    self, context: ParameterOperatable.ReprContext | None = None\n) -&gt; str:\n    \"\"\"\n    Unit only printed if not dimensionless.\n\n    Letters:\n    ```\n    A-Z, a-z, \u03b1-\u03c9\n    A\u2081-Z\u2081, a\u2081-z\u2081, \u03b1\u2081-\u03c9\u2081\n    A\u2082-Z\u2082, a\u2082-z\u2082, \u03b1\u2082-\u03c9\u2082\n    ...\n    ```\n    \"\"\"\n\n    def param_id_to_human_str(param_id: int) -&gt; str:\n        assert isinstance(param_id, int)\n        alphabets = [(\"A\", 26), (\"a\", 26), (\"\u03b1\", 25)]\n        alphabet = [\n            chr(ord(start_char) + i)\n            for start_char, char_cnt in alphabets\n            for i in range(char_cnt)\n        ]\n\n        def int_to_subscript(i: int) -&gt; str:\n            if i == 0:\n                return \"\"\n            _str = str(i)\n            return \"\".join(chr(ord(\"\u2080\") + ord(c) - ord(\"0\")) for c in _str)\n\n        return alphabet[param_id % len(alphabet)] + int_to_subscript(\n            param_id // len(alphabet)\n        )\n\n    if context is None:\n        context = ParameterOperatable.ReprContext()\n\n    if self not in context.variable_mapping.mapping:\n        next_id = context.variable_mapping.next_id\n        context.variable_mapping.mapping[self] = next_id\n        context.variable_mapping.next_id += 1\n\n    unitstr = f\" {self.units}\" if self.units != dimensionless else \"\"\n    letter = param_id_to_human_str(context.variable_mapping.mapping[self])\n\n    out = f\"{letter}{unitstr}\"\n    out += self._get_lit_suffix()\n\n    return out\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.domain_set","title":"domain_set","text":"<pre><code>domain_set()\n</code></pre> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def domain_set(self) -&gt; P_Set:\n    return self.domain.unbounded(self)\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.Parameter.get_last_known_deduced_superset","title":"get_last_known_deduced_superset","text":"<pre><code>get_last_known_deduced_superset(solver)\n</code></pre> PARAMETER DESCRIPTION <code>solver</code> <p> TYPE: <code>Solver</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def get_last_known_deduced_superset(self, solver: \"Solver\") -&gt; P_Set | None:\n    as_literal = solver.inspect_get_known_supersets(self, force_update=False)\n    return None if as_literal == self.domain_set() else as_literal\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.f_field","title":"f_field","text":"<pre><code>f_field(con)\n</code></pre> PARAMETER DESCRIPTION <code>con</code> <p> TYPE: <code>Callable[P, T]</code> </p> Source code in <code>src/faebryk/core/node.py</code> <pre><code>def f_field[T, **P](con: Callable[P, T]) -&gt; Callable[P, T]:\n    assert isinstance(con, type)\n\n    def _(*args: P.args, **kwargs: P.kwargs) -&gt; Callable[[], T]:\n        def __() -&gt; T:\n            return con(*args, **kwargs)\n\n        return _d_field(__)  # type: ignore\n\n    return _  # type: ignore\n</code></pre>"},{"location":"api/solver/#faebryk.core.parameter.has_implicit_constraints_recursive","title":"has_implicit_constraints_recursive","text":"<pre><code>has_implicit_constraints_recursive(po)\n</code></pre> PARAMETER DESCRIPTION <code>po</code> <p> TYPE: <code>All</code> </p> Source code in <code>src/faebryk/core/parameter.py</code> <pre><code>def has_implicit_constraints_recursive(po: ParameterOperatable.All) -&gt; bool:\n    if isinstance(po, ParameterOperatable):\n        return po.has_implicit_constraints_recursive()\n    return False\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/02/29/be-assertive-/","title":"Be assertive \ud83d\udcaa","text":""},{"location":"blog/2024/02/29/be-assertive-/#check-yoself-before-you-wreck-yo-design","title":"Check yo'self before you wreck yo'... design","text":"<p>atopile has your back when it comes to ensuring your design is correct. With the new assertion feature, you can apply constraints on attributes of your design.</p> <ul> <li>Make sure voltage inputs on ICs are withing operational ranges</li> <li>Avoid exceeding power limits on FETs</li> <li>Check temperature sensors function over their entire operating range</li> </ul> <p>Think of this as unit tests for your electronics! \ud83e\udd29</p>"},{"location":"blog/2024/02/29/be-assertive-/#think-in-specs-let-the-computer-find-the-components","title":"Think in specs \ud83e\udde0, let the computer find the components","text":"<p>atopile can find suitable component values for you, to configure your design in terms you want to think about.</p> <p>Tell your filters what you want their cut-off to be, and let atopile find the right resistor and capacitor values for you.</p> <p>Use code to spec what voltage you want your regulator to output, and let atopile find the resistors that meet spec for you!</p>"},{"location":"blog/2024/02/02/trivial-mistakes-are-expensive-/","title":"Trivial mistakes are expensive \ud83e\udd11","text":"<p>Continuous integration / continuous deployment (CI/CD) is does things in software like running tests and deploying code automatically.</p> <p>We've unfortunately been a little too responsible for some pretty expensive trivial mistakes in the past, so it's a key thing we wanted to focus on in <code>atopile</code>.</p> <p>Instead of all shaking hands and totally agreeing that this local export named \"pcb-final-final-final\" is what we're going to spend serious money on - we can generate the manufacturing files on a trusted server</p> <p> </p> <p>... and stamp them with the precise version of the source-code used to create them!</p> <p></p> <p>No more export mistakes \ud83d\udc4c. Plus, it makes ordering boards super easy!</p> <p>Matt</p>"},{"location":"blog/2024/01/31/cloud-components/","title":"Cloud Components","text":"<p>I am pretty excited about this one. In our latest release 0.2.5, we are introducing 'Cloud Components' - a way to parametrically define and select components from a server.</p>"},{"location":"blog/2024/01/31/cloud-components/#how-it-works","title":"How it works","text":"<p>First step is defining the requirements of the component, much like you would in a digikey search. Currently our library has support for resistors and capacitors with experimental support for diodes, inductors, and FETs. Here's an example of how you would define a few components: <pre><code>resistor = new Resistor\nresistor.value = 10kohm +/- 20%\nresistor.package = \"0603\"\n\ncap = new Capacitor\ncap.value = 1uF +/- 10%\ncap.package = \"0603\"\n\n\n#### experimental ####\nfet = new NFET\nfet.current_a = 30A to 100A\nfet.drain_source_voltage_v = 30V to 100V\n\ninductor = new Inductor\ninductor.inductance = 1uH to 10uH\ninductor.current = 3A to 5A\n\ndiode = new Diode\ndiode.forward_voltage = 7V to 9V\ndiode.impedance = 1ohm to 10ohm\ndiode.power_dissipation = 5W to 60W\n</code></pre> At build time, we take the requirements and send them to our component server, which filters parts in our library for the specified requirements. The server then sorts the parts by price and availability, and returns the best matches. These components are then downloaded and added to your BOM and netlist.</p> <p></p>"},{"location":"blog/2024/01/31/cloud-components/#footprints","title":"Footprints","text":"<p>This was a bit of a pain. This is pretty simple for things like resistors and caps, but becomes a little more complex for devices like mosfets that might have three pins on some parts and eight on others. Our current solution, which admittedly is a bit of a hack, stores a muated footprint in the server for each part, downloads it and adds it to your library.</p> <p>For example, here is a multi-pin mosfet, you can see that the pin names have been mutated to their corresponding signals:</p> <p></p>"},{"location":"blog/2024/01/31/cloud-components/#why-this-is-a-big-deal","title":"Why this is a big deal","text":"<p>The way circuits are defined today requires us as designers to be explicit as to which part number each component will have, in the process loosing information about why you chose that component. If a design at your company has a component shortage and you are assigned the task to find a replacement, how do you know which part to choose, what are the requirements? If you are luck there might be a design document or confluence page you can scroll through to reverse engineer the design and check new parts against it. If you are unlucky, the guy who designed it left the company and only took paper notes.</p> <p>By capturing the requirements in your source code, the information is preserved and can be used even years later to find a suitable part. I imagine a future where automated systems can track component pricing and inventory, automatically finding cost down opportunities, or alerting you when a part is going end of life and proposing a replacement.</p> <p>More immediately, as a designer making a quick turn board, I don't want to spend time browsing digikey, seeing what is available, checking if we have it in our companies component library, only to hear back from the vendor that the component is now out of stock and they need me to pick a new one. Thats enough to make a grown man cry, some days. Instead, we can have the tool generate a list of alternatives that meet the requirements and allow the vendor to pick from that list.</p>"},{"location":"blog/2024/01/31/cloud-components/#what-is-next","title":"What is next?","text":"<p>I believe that a fundamental transformation of how we capture circuit information is needed to enable the next generation of tools. In order to make our tools truly smart, we need to come up with ways to communicate design intent, not just one explicit implementation. Concretely, we are working on:</p> <ul> <li>Adding more component types to the server</li> <li>Adding support for project level requirements and constraints: AECQ100, Environmental conditions, etc</li> <li>Component traits - how to generically describe complex components (blog post coming soon)</li> </ul> <p>Stay tuned for more updates!</p> <p>Narayan</p>"},{"location":"blog/2024/02/09/why-on-earth-did-you-create-a-new-language-/","title":"Why on earth did you create a new language? \ud83e\udee3","text":"<p>It's a good question! Making people learn something new is a huge barrier to entry, ignores the wealth of community support from existing languages and can be a bit of a pain to maintain.</p> <p>This iteration of the project actually came after first working with and then modifying an awesome project called SKiDL (https://github.com/devbisme/skidl). SKiDL takes the approach of using Python. Since it's procedural, turing complete and has a rich eco-system - people use to that and there aren't standard composable ways of designing things. Instead of describing your board, you (practically) write a script that generates your board. It entangles your targets with your source-code and can make it difficult to understand the ultimate outcome of what you've written.</p> <p>We are trying to make it as readable and friendly as possible, our expectation is our users will likely have some experience with Python and perhaps a little C back in school, so making it clear and approachable is front of mind. Ideally some parts of code should \"look\" like the schematic, eg. <code>power.vcc ~&gt; resistor ~&gt; led ~&gt; power.gnd</code>.</p> <p>Units and tolerances are core to our language, the physical world is 'fuzzy' and having a good way to deal with those is pretty important. There's a few operators and first-class language features we wanted as well, (like units and tolerances eg. <code>3.3V +/- 100mV</code>) that just aren't the same when embedded in a string, or class init method.</p> <p>Additionally, since it's a potentially very long program, it was hard to write good language support around (a language server for VSCode, a schematic visualiser etc...) that were snappy, responsive and lent to examining modules as well as the whole program.</p> <p>Worth noting; we're probably going to try make our language more like Python, than less over the coming little while.</p> <p>Happy coding! \ud83d\ude80</p> <p>-- Matt</p>"},{"location":"blog/2024/02/02/-layout-reuse-keeps-getting-better-/","title":"\u2728 Layout Reuse Keeps Getting Better \ud83d\ude80","text":"<p>Now with traces and vias \ud83d\udc4c</p> <p> </p> <p>Happy designing! \ud83c\udf89</p> <p>Matt</p>"},{"location":"blog/2024/02/02/-layout-reuse-/","title":"\u2728 Layout Reuse \u2728","text":"<p>Huge shout out to @nickkrstevski for this awesome new feature!</p> <p>You can now reuse parts placement across designs. This is a huge time saver for designs - particularly those with a lot of common modules.</p> <p> </p>"},{"location":"blog/2024/02/02/-layout-reuse-/#omg-how","title":"OMG, How?","text":"<p>Usage of the <code>ato</code> CLI will automatically install the hook for the atopile plugin to KiCAD. All you need to do is hit the sync \ud83d\udd04 button to group the components into the modules that have layouts associated, then hit pull \u2b07\ufe0f to use that layout. If you want to save a layout to a module, you can do so with the push \u2b06\ufe0f button.</p> <p>Happy designing! \ud83c\udf89</p> <p>Matt</p>"},{"location":"blog/2024/02/06/make-hardware-flow/","title":"Make hardware flow","text":"<p>My dad taught me the technical details of everything for as long as I can remember. For my 7<sup>th</sup> Christmas, I got a lawn-mower - to tear the engine off and turn into a go-kart. I was absolutely stoked.</p> <p>As Narayan and I grew up, we spent every weekend building things. We were always scheming about the next project, and we were always building something. We built a CNC machine, a liquid-fueled rocket motor, and a drone. We were always trying to make things better, faster, and more efficient. We were always trying to make things work better.</p> <p>More than any of the individual projects, the thing that I always got most stoked about was new tools. We converted a milling machine to CNC an axis at a time by first 3D printing and then machining each of the axes brackets. We had to take a second pass at the first two axes because the 3D printed parts were sloppy enough that the machined brackets they created still had too much play for comfort. Man, that was a great project. And the endeavour landed us more offers for contract work (as ~17 year-olds) than we could handle.</p> <p>One specific part of that project I wanted, and wanted for years, were low-cost tightly integrated servo drives. I wanted to make a PCB with 4 servo controllers on it that meant I would only need to run cables out to the motors and I could control the whole system form a single PCB - similar to 3D printer controllers. We're finally getting close! https://github.com/atopile/spin-servo-drive</p> <p>My subsequent decade through university and industry made me consciously realise why people kept trying to pay us - it's far too hard and slow to make hardware fast enough to stay in a flow state and learn fast enough that failing is acceptable.</p> <p><code>atopile</code> will make high-quality hardware engineering flow the same way great software development does - and make engineers everywhere feel like how our scrappy younger selves did.</p>"},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/","title":"From Weekend Projects to Reinventing Hardware Design","text":""},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/#early-days-can-we-build-a-predator-drone","title":"Early Days: Can we build a predator drone?","text":"<p>Matt and I met at camp when we were thirteen and quickly became mates. We chatted the whole twelve hour bus ride home, scheming about the enormous drone we were going to build, looking back at it, we were a bit ambitious.</p> <p>The next decade of weekend weekends Matt and I spent together stand out. They weren't filled with typical childhood pastimes; instead, we immersed ourselves in building and creating. Our projects were modest \u2013 from simple drones to CNC machines. I'll never forget our attempt at a liquid-fueled rocket motor. Igniting it was a disaster, but everything else from the servo-controlled throttling to the large blast shield worked quite the treat - not bad, for about a week's worth of evenings after work!</p>"},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/#stepping-into-the-professional-world","title":"Stepping into the Professional World","text":"<p>Our first proper tech jobs were at Tesla and Lilium. We were eager to translate our weekend tinkering to the real world. At these companies, we learned a lot about manufacturing and bringing products to market. The technology and talent were inspiring, but we noticed the pace of innovation was slower and more traditional than we expected.</p>"},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/#facing-industry-realities","title":"Facing Industry Realities","text":"<p>Eventually, we both ended up at Tesla together, during which time we met Tim. We quickly found common ground in our experiences. Even though we were part of some exciting projects, the reality of day-to-day work often meant dealing with a lot of repetition and slow-moving processes. The job started to feel less about innovation and more about navigating through routine procedures. It wasn't the dynamic environment we had dreamed of, it was becoming just a job.</p>"},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/#a-shift-in-perspective-the-seed-of-an-idea","title":"A Shift in Perspective: The Seed of an Idea","text":"<p>Continuing the trend of the CNC machines we built growing up - our personal projects often revolved around making things to make things. It was clear there must be a better way to describe hardware. Mulling this led to pivotal realization: What if we could streamline hardware design using language-based descriptions? In my day job, our team was managing 10+ designs each disconnected from the other, meaning it could take us years to roll out improvements across all of them. The idea of simply making a PR for each to update that particular module sounded too good to be true.</p>"},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/#our-vision-a-humble-hope-for-change","title":"Our Vision: A Humble Hope for Change","text":"<p>We\u2019re not claiming to have all the answers or to revolutionize the industry overnight, but we do have a vision: a future where tools keep engineers in their flow state - whether working on teams small or large, no matter how complex the project. We believe this will make the design process significantly faster and less costly, bringing us closer to the agility and joy of those weekend projects from our youth.</p>"},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/#an-invitation-to-join-our-journey","title":"An Invitation to Join Our Journey","text":"<p>This journey is just beginning, and there\u2019s a long road ahead. We\u2019re sharing our story not just to talk about our idea, but to invite collaboration, feedback, and shared learning. Together, we can explore ways to bring a new level of dynamism and creativity to hardware design. We\u2019re excited about the future and we hope you\u2019ll join us in this endeavor.</p> <p>Narayan</p>"},{"location":"blog/2024/01/31/composable-electronics/","title":"Composable Electronics","text":"<p>How do we make designing electronics more like playing with legos? We need to standardize the building blocks, how they can be connected together and publish 'instruction manuals' that describe how to connect them up to make something useful.</p>"},{"location":"blog/2024/01/31/composable-electronics/#the-blocks","title":"The blocks","text":"<p>How do you describe what a component is? Today we rely on a language description in a datasheet and a clever human to interpret it. The information is not easily interpretable by a computer, which makes it hard to automate or augment the design process.</p> <p>We need a way to embed key information into the source files.</p>"},{"location":"blog/2024/01/31/composable-electronics/#what-are-the-functional-blocks-inside-the-chip","title":"What are the functional blocks inside the chip?","text":"<p>Here is a simple example of a buck converter IC.  Lets try simplify this into a few functional blocks. Lets say the 'controller' is a block that takes in a voltage outputs a switching node, with a feedback pin. We can just use a NFET component for the fet. So in ato code we could define this as: <pre><code>component LM2841:\n    controller = new BuckController\n    nfet = new NFET\n</code></pre></p>"},{"location":"blog/2024/01/31/composable-electronics/#connecting-and-configuring-the-blocks","title":"Connecting and configuring the blocks","text":"<p>To more completely describe the internals of the IC, we need to define how the blocks are connected and what their properties are. Below we are connecting the NFET to the controller, connecting the blocks to the outputs and configuring the voltage and current limits. <pre><code># connect blocks to pins\ncontroller.feedback ~ fb\ncontroller.power_in.vcc ~ vin\ncontroller.power_out.gnd ~ gnd\nnfet.drain ~ sw\n</code></pre> We will also need to add in any specifics required by this particular IC, like a bootstrap capacitor and a pull-up on the enable pin that ill leave out of this example.</p>"},{"location":"blog/2024/01/31/composable-electronics/#the-instruction-manual","title":"The Instruction Manual","text":"<p>Following through with our buck converter example, lets build a description of how to connect the blocks together to make a buck converter. </p> <p>To start, lets make a new 'topology' and instantiate the required blocks. <pre><code>topology Buck:\n    # Define external interfaces\n    power_in = new Power\n    power_out = new Power\n\n    # Define blocks\n    inductor = new Inductor\n    output_cap = new Capacitor\n    input_cap = new Capacitor\n    diode = new Diode\n    controller = new BuckController\n    nfet = new NFET\n    feedback_divider = new VDiv\n</code></pre></p> <p>Next, lets connect the blocks together. <pre><code>    # Connect internal components\n    controller.drive ~ nfet.gate\n    # Method to chain dipole components (feedback welcome)\n    power_in.vcc ~ nfet ~ inductor ~ power_out.vcc\n    diode.anode ~ gnd\n    diode.cathode ~ inductor.1\n\n    # Feedback divider (input is a power interface)\n    feedback_divider.input ~ power_out\n    feedback_divider.output ~ controller.feedback\n\n\n    # Connect bypass capacitors\n    power_in ~ input_cap\n    power_out ~ output_cap\n\n    # We might want to define some equations to make the buck more intuitive to use\n    eqn: power_out.voltage = feedback_divider.input.voltage\n    eqn: controller.feedback.voltage = feedback_divider.output.voltage\n</code></pre></p> <p>Finally, we need a way to relate the two. Let now create a specific instance of the topology and define the parameters. <pre><code>buck = new Buck\nic = new LM2841\n\n# Map the IC to the topology using the replacement operator\nbuck.controller -&gt; ic.controller\nbuck.nfet -&gt; ic.nfet\n\n# Configure the buck components\nbuck.inductor.inductance = 10uH +/- 20%\ninput_cap.capacitance = 10uF +/- 20%\noutput_cap.capacitance = 10uF +/- 20%\n\n# Configure output voltage\nbuck.power_out.voltage = 5V +/- 5%\n</code></pre></p> <p>That might all feel like alot of work, until you realize that the topologies and components are reusable and only need to be defined once. You can design a buck converter using just that last block of code and a few imports.</p> <p>If you are interested in checking out the full example, you can find it here</p> <p>We have a few language features in the pipeline that will enable this type of workflow in the near future.</p> <p>Narayan</p>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/release/","title":"Release","text":""},{"location":"blog/category/about-us/","title":"About us","text":""},{"location":"blog/category/future/","title":"Future","text":""}]}