{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p><code>atopile</code> is a language, compiler and toolchain to design electronics with code.</p> <p>Design circuit boards with the same powerful workflows that software developers use - version control, modularity, and automated validation. Instead of point-and-click schematics, use human-readable <code>.ato</code> files that can be version controlled and shared. Capture design intelligence and validation rules in code to ensure your hardware works as intended.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\ude80 Auto-select components like resistors and capacitors, based on their attribute's values</li> <li>\ud83e\udd16 Embed calculations in your code, which are checked on every build</li> <li>\ud83e\uddf1 Build you circuit from reliable configurable modules so you can focus on high level design</li> <li>\ud83d\udca5 Build, release and test your circuit board from the <code>CLI</code></li> <li>\ud83d\udce6 Embedded package manager to install and manage modules from https://packages.atopile.io, or Github</li> <li>\ud83d\udd0d Version control line-by-line diffable code w/ git</li> </ul> <p>Jump right in with the quickstart guide</p>"},{"location":"#whos-atopile-for","title":"Who's atopile for?","text":"<p>Currently atopile is young - which means we can't do everything yet and we're focussed on being incredible at a few things:</p>"},{"location":"#custom-validation-equipment","title":"Custom Validation Equipment","text":"<p>\"Rome wasn't built in a day, but your HiL should be\"</p> <p>If you're serious about automating the validation of your production hardware, you're in the right place.</p> <p>Cell-sim is a 16ch, 16-bit, isolated, 0-5V, 0-500mA battery-cell simulator designed from scratch in atopile, from concept to 2-revisions in under 5 days work. Oh, and that time includes the firmware. It is a relatively complex HiL design, and required many new modules that didn't yet exist on our package manager. Simpler HiL designs are frequently just a day's work.</p> <p></p>"},{"location":"#young-companies-who-need-to-iterate-on-hardware","title":"Young companies who need to iterate on hardware","text":"<p><code>atopile</code> designed hardware is in satellites, humanoid robots and VTOL drones - all from startups within the last year.</p> <p>Not every young company NEEDs to iterate on it's hardware, but many more should than do.</p> <p>We're used to this in the software world, but getting the same engine running at even remotely similar speeds for hardware is a huge challenge. <code>atopile</code> let's multiple people work on different features or concepts on the same project in parallel via branches in <code>git</code>. With calculations checked and tests run automatically on every change, you can iterate as an individual - quickly trying out new ideas before committing to a design as a team and only after validating it in the real-world.</p>"},{"location":"#huge-nerds","title":"Huge nerds \ud83e\udd13","text":"<p>Welcome the club!</p> <p>If you like making dope stuff, like these servo drives you're in the right place. Welcome!</p> <p></p>"},{"location":"#roadmap","title":"Roadmap","text":""},{"location":"#up-next","title":"Up-next","text":"<ul> <li> \ud83d\udce6 Package Manager - Make finding, installing and publishing modules fast and easy</li> <li> First-party packages for HiL systems</li> </ul>"},{"location":"#soon","title":"Soon","text":"<ul> <li> Language Server - A standard LSP server for atopile</li> <li> Plugin system - Make it easy to extend the <code>ato</code> CLI</li> </ul>"},{"location":"#non-goals","title":"Non-goals","text":"<ul> <li>Integration with XXX design tool. Reliably supporting all the features of legacy EDA tools is a huge lift, and, with rapid continued improvement in the open-source EDA space, it's not currently the best use of our time.</li> </ul>"},{"location":"CHANGELOG/","title":"Change Log","text":""},{"location":"CHANGELOG/#v03x","title":"v0.3.x","text":"<p>Firstly, thanks for using atopile! It's been a ride, and we're glad you're here. \ud83d\ude4c</p>"},{"location":"CHANGELOG/#changed-commands","title":"Changed Commands","text":"<p>Add <code>--help</code> after any command to see new options in the CLI. This is always the most accurate source of information.</p> Old New <code>ato install --jlcpcb</code> <code>ato create component</code>"},{"location":"CHANGELOG/#im-seeing-a-bunch-of-deprecationwarning","title":"I'm seeing a bunch of <code>DeprecationWarning</code>","text":"<p>There will be a LOT of new deprecation warnings you'll see.</p> <p>For the most part, it's safe to ignore them for the minute, and we plan to make the breaking changes in 0.4.0</p> <p>Upgrading will give you more access to features as they're added, but there's no need to rush if you're content.</p>"},{"location":"CHANGELOG/#pcbs-are-now-directly-modified","title":"PCBs are now directly modified","text":"<p>This means no more need to open the PCB file, import the netlist and cycle.</p> <p><code>ato build</code> now directly modifies the PCB file as required on each build.</p>"},{"location":"CHANGELOG/#standard-library-previously-generics-is-now-shipped-built-in","title":"Standard Library (previously <code>generics</code>) is now shipped built-in!","text":"<p>This vastly improves our ability to version and iterate on the standard library, use the best practices and latest features.</p> <p>See <code>library</code> for the latest and greatest.</p> <p>It should be better documented. If this is important for you, please vote on the issue: #936</p>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":"<p>First of all we really appreciate your interest and involvement in this project.</p> <p>We define some basic rules for the participants of this community:</p> <ul> <li>Be respectful to others</li> <li>Try to help others</li> <li>Be open minded</li> <li>Have fun</li> </ul>"},{"location":"CODING_GUIDELINES/","title":"Coding guidelines","text":""},{"location":"CODING_GUIDELINES/#formatting-linting","title":"Formatting, Linting, ...","text":"<p>Make sure to install all development requirements by running <pre><code>uv sync --dev\n</code></pre></p> <p>Install pre-commit into your repository: <pre><code>pre-commit install\n</code></pre></p> <p>From now on when commiting, <code>pre-commit</code> will run our formatting &amp; linting tools.</p>"},{"location":"CONTRIBUTING/","title":"Contributing guidelines","text":""},{"location":"CONTRIBUTING/#contribution-process","title":"Contribution process","text":"<p>Please follow these steps to make a contribution:</p> <ol> <li>If there is no issue yet, make an issue and follow the instructions of the issue template.</li> <li>Comment on the issue you are going to work on and say you are working on it.</li> <li>Fork our repository and create a branch.</li> <li>Write your code following our coding guidelines and submit your pull request. Be sure to read and follow our pull request guidelines, otherwise it will not be accepted!</li> <li>Wait for your code to be reviewed and address any issues in a timely manner.</li> </ol> <p>We encourage people to review each others pull requests and issues, but please be kind, constructive and respectful to each other!</p>"},{"location":"CONTRIBUTING/#creating-a-new-issue","title":"Creating a new issue","text":"<p>To make it easy for you to fill in all the necessary information, we make use of Github forms.</p> <p>If you find a bug, or want to add or change a feature, go to issues page and follow the steps described there. Please be as elaborate as possible to have the issue resolved as soon as possible. We will add labels to your issue when it's reviewed.</p> <p>When in doubt, ask a question on our Discord community.</p>"},{"location":"CONTRIBUTING/#creating-a-pull-request","title":"Creating a pull request","text":"<p>Like with new issues, we use a template for creating pull requests. Please fill in the template and be elaborate so we can try to merge your pr as soon as possible.</p> <p>Run the Black code formatting tool before creating the pr!! <code>python -m black {source_file_or_directory}</code></p> <p>Be sure there is an issue linked to your pr.</p>"},{"location":"CONTRIBUTING/#labels","title":"Labels","text":"<p>Our labels are divided into three fields for ease of use. The format is as follows where \u23b5 denotes a single space character:</p> <p>\\\u23b5\\:\u23b5\\ <p>A list of labels can be found here</p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Editable atopile install</li> </ul>"},{"location":"development/#dev-tools","title":"Dev Tools","text":"<p>We recommend VSCode for development. If nothing else, it has heaps of high quality extensions and atopile language support, plus it's what we all use internally - so we know how to configure it for purpose.</p> <p>You should have at minimum: - Cursor or VSCode - VSCode atopile extension (also works for Cursor)</p>"},{"location":"development/#verbosity","title":"Verbosity","text":"<p>You can increase the verbosity of atopile by using the <code>-v</code>, <code>-vv</code> or <code>-vvv</code> flags, eg. <code>ato -vv build</code></p> <p>Flag Location</p> <p>Flags are placed after the <code>ato</code> command and before the command you want to run. For example, <code>ato -vv build</code> will run the build command with the verbose flag set to the highest level, while <code>ato build -vv</code> will not work.</p>"},{"location":"development/#debugging","title":"Debugging","text":"<p>You can start the CLI in debug mode by using the <code>--debug</code> flag, eg. <code>ato --debug build</code></p> <p>This will run a <code>debugpy</code> server on port <code>5678</code> which you can connect to with the VSCode built-in debugger.</p> <p></p> Syntax highlighting isn't working <p>If you're having trouble with syntax highlighting in the debugger, it might be because VSCode sets up a mapping between the remote and local file paths by default - remove it.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#install-ato-with-uv-recommended","title":"Install <code>ato</code> \u2014 with <code>uv</code> (recommended)","text":"<ol> <li> <p>Install <code>uv</code>. See: https://docs.astral.sh/uv/installation/</p> </li> <li> <p>Install atopile with <code>uv</code></p> <pre><code>uv tool install atopile\n</code></pre> <p>Important</p> <p><code>uv</code> if this is the first time you've used <code>uv</code> for a tool install, it might give you another command to run to finish setup. Do it.</p> </li> <li> <p>Check <code>ato</code> is installed</p> <pre><code>ato --version\n</code></pre> </li> </ol> <p>Info</p> <p>While we strongly recommend using <code>uv</code> to install atopile, it's ultimately a python package, so you can install it a few other ways. See the installation guide for more details.</p>"},{"location":"quickstart/#editor-recommendations","title":"Editor recommendations","text":"<p>atopile officially supports VSCode and Cursor.</p> <p>We recommend using Cursor. AI is already getting very good at writing <code>ato</code> code.</p> <p>Download it here: https://www.cursor.com/</p> <p>We also strongly recommend installing the atopile VSCode/Cursor extension. It provides syntax highlighting and some LSP support.</p> <p></p>"},{"location":"quickstart/#installing-kicad","title":"Installing KiCAD","text":"<p>If you are on OSx, and you have <code>brew</code> installed, you can install KiCAD with:</p> <pre><code>brew install kicad\n</code></pre> <p>Otherwise, you can download it from here: https://www.kicad.org/download/</p>"},{"location":"quickstart/#a-typical-workflow","title":"A typical workflow","text":"<ol> <li>Sketch your circuit on paper.</li> <li>Search https://packages.atopile.io and Github for pre-existing modules you need, and use <code>ato install</code> to install them.</li> <li>Design a module and do it's calculations using <code>ato</code> code.</li> <li>Run <code>ato build</code> to compile your project choose components to suit your design and update your layout (PCB) file.</li> <li>Use KiCAD to layout any changes</li> <li>Repeat steps 3-5 until you're happy with your design.</li> <li>When you're done with your design, push your changes to your repo.</li> <li>CI will automatically build and test your project, and generate the manufacturing files you need to order your PCBs.</li> <li>Take these manufacturing files to your PCB manufacturer to get your PCBAs</li> </ol> <pre><code>graph TB\n  A[Sketch] --&gt; AA['ato create project'];\n  AA --&gt; BB[Pick a module];\n  BB --&gt; B{Package exists?};\n  B --&gt;|Yes \ud83e\udd73| C['ato install'];\n  B --&gt;|No| CC['ato create component' and Design it! \ud83d\udc68\u200d\ud83d\udcbb];\n  C --&gt; D[Hook it up];\n  CC --&gt; D;\n  D --&gt; E['ato build'];\n  E --&gt; F[Layout using KiCAD];\n  F --&gt; G{More modules to do?};\n  G --&gt;|Yes| BB;\n  G --&gt;|No \ud83c\udf89| H[Download gerbers from CI \u2705];\n  H --&gt; I[Order PCBs from manufacturer \ud83d\udee0\ufe0f];</code></pre>"},{"location":"quickstart/#creating-a-project","title":"Creating a project","text":"<pre><code>ato create project\n</code></pre> <p>And follow the prompts to create a new project from the template.</p>"},{"location":"quickstart/#project-structure","title":"Project Structure","text":"<p>Your new project will have a file structure like this:</p> <pre><code>.\n\u251c\u2500\u2500 LICENSE                    # 1. Default MIT license. You are free to change this\n\u251c\u2500\u2500 README.md                  # 2. A description of your project\n\u251c\u2500\u2500 ato.yaml                   # 3. atopile's configuration file\n\u251c\u2500\u2500 build                      # 4. Build artifacts and cache (not version controlled)\n\u251c\u2500\u2500 layouts                    # 5. KiCAD layout files\n\u2502   \u2514\u2500\u2500 default                # 6. There's a directory / layout per \"build target\"\n\u2502       \u2514\u2500\u2500 default.kicad_pcb  # 7. The layout file that will be updated every time you run `ato build -b default`\n\u2514\u2500\u2500 demo.ato                   # 8. Your atopile source file\n</code></pre> <p>The most important three files in there are:</p> <ul> <li><code>demo.ato</code> - your atopile source file - this is where you write your atopile code</li> <li><code>default.kicad_pcb</code> - the layout file - this is the \"board\" file that looks like a PCB, and you can order from</li> <li><code>ato.yaml</code> - atopile's configuration file - this file is how atopile knows this is a project and what to do when you run <code>ato build</code></li> </ul>"},{"location":"quickstart/#hello-world","title":"Hello, World!","text":"<p>Here's a simple example of atopile code:</p> <pre><code>import Resistor\n\nmodule App:\n    r1 = new Resistor                # Create a new resistor\n    r1.resistance = 100ohm +/- 10%   # Set the resistor value\n</code></pre> <p>Update <code>demo.ato</code> (of whatever you've named your source file) with this code.</p> <p>To build it, run:</p> <pre><code>ato build --open\n</code></pre> <p>You should see a flurry of activity in the terminal with this message towards the end</p> <pre><code>INFO     Build successful! \ud83d\ude80\n</code></pre> <p>Then KiCAD will open up (that's what the <code>--open</code> flag does). You shiny \u2728 new  component should be waiting for you in the top left corner (possibly off the current screen).</p> <p></p> <p>Oh yeah! We're in business. \ud83d\ude0e</p>"},{"location":"quickstart/#whats-next","title":"What's next?","text":"<p>This isn't even a circuit yet, merely a single component however you now:</p> <ul> <li>Have the <code>ato</code> CLI and compiler setup and working</li> <li>Know how to add components to your design</li> <li>Have KiCAD installed and working</li> </ul> <p>In the tutorial we continue with a real circuit, installing and using packages, maths and version control.</p>"},{"location":"spin/","title":"SPIN","text":"<p>SPIN is a BLDC motor controller using the SimpleFOC library. Designed as a reference project, hopefully serving as a starting point for your own projects with motor control!</p> <p></p>"},{"location":"spin/#specs","title":"Specs","text":"<ul> <li>3-phase BLDC nema 17 motor</li> <li>12-24V power supply</li> <li>2A continuous current, 5A peak current</li> <li>14bit magnetic encoder (0.02\u00b0 resolution)</li> </ul>"},{"location":"spin/#features","title":"Features","text":"<ul> <li>XT30 power connector (x2 for daisy chaining)</li> <li>JST-GH 4-pin CAN bus connector (x2 for daisy chaining)</li> <li>Stemma/Qwiic I2C connector</li> <li>Addressable RGB LEDs for status indication</li> <li>USB-C for programming and debugging</li> </ul>"},{"location":"spin/#roadmap","title":"Roadmap","text":"<p>Second version of the board is currently in manufacturing to add CAN bus and I2C communication.</p> <ul> <li> Power supply bring-up</li> <li> Open loop velocity control</li> <li> Closed loop current control</li> <li> Position control with magnetic encoder</li> <li> CAN bus control (position, velocity, current)</li> <li> CAN bus motion profile</li> <li> I2C communication</li> <li> Enumeration with multiple devices</li> </ul>"},{"location":"spin/#documentation","title":"Documentation","text":"<p>Interested in building your own SPIN or helping out with the project? Check out the repo and discord for more information on how to get started!</p>"},{"location":"swoop/","title":"Swoop","text":"<p>Swoop is an open-source motion based flight controller for drones. It uses an IMU to generate commanded yaw, pitch, and roll angles, and sends these commands to the flight controller over ExpressLRS.</p> <p></p>"},{"location":"swoop/#specs","title":"Specs","text":"<ul> <li>9-axis IMU (mag, gyro, accel)</li> <li>RP2040 (sensor fusion, throttle, status indication)</li> <li>ESP32 S3 (ExpressLRS)</li> <li>SX1280 transceiver (compatible with ExpressLRS)</li> <li>Powered by 1000mah internal LiPo battery (~ 4hrs of flight time)</li> </ul>"},{"location":"swoop/#block-diagram","title":"Block Diagram","text":""},{"location":"swoop/#features","title":"Features","text":"<ul> <li>Status LEDs</li> <li>USB-C for programming and debugging</li> <li>hall-sensor for throttle control</li> </ul>"},{"location":"swoop/#roadmap","title":"Roadmap","text":"<p>Second version of the board is currently in manufacturing to add CAN bus and I2C communication.</p> <ul> <li> Power supply bring-up</li> <li> Battery charging circuit bring-up</li> <li> IMU bringup</li> <li> IMU calibration</li> <li> IMU sensor fusion</li> <li> ExpressLRS integration (FLRC)</li> <li> Binding with ExpressLRS receivers</li> <li> Add display and buttons for ExpressLRS configuration</li> </ul>"},{"location":"swoop/#initial-testing","title":"Initial Testing","text":""},{"location":"swoop/#documentation","title":"Documentation","text":"<p>Interested? We are looking for collaborators! Check out the repo and discord for more information on how to get started!</p>"},{"location":"api/cli/","title":"CLI","text":""},{"location":"api/cli/#atopile.cli","title":"atopile.cli","text":""},{"location":"api/cli/#atopile.cli.build","title":"build","text":"<p>CLI command definition for <code>ato build</code>.</p>"},{"location":"api/cli/#atopile.cli.build.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.build.build","title":"build","text":"<pre><code>build(\n    entry=None,\n    selected_builds=[],\n    target=[],\n    option=[],\n    frozen=None,\n    keep_picked_parts=None,\n    keep_net_names=None,\n    keep_designators=None,\n    standalone=False,\n    open_layout=None,\n)\n</code></pre> <p>Build the specified --target(s) or the targets specified by the build config. Optionally specify a different entrypoint with the argument ENTRY. eg. <code>ato build --target my_target path/to/source.ato:module.path</code></p> Source code in <code>src/atopile/cli/build.py</code> <pre><code>def build(\n    entry: Annotated[str | None, typer.Argument()] = None,\n    selected_builds: Annotated[\n        list[str], typer.Option(\"--build\", \"-b\", envvar=\"ATO_BUILD\")\n    ] = [],\n    target: Annotated[\n        list[str], typer.Option(\"--target\", \"-t\", envvar=\"ATO_TARGET\")\n    ] = [],\n    option: Annotated[\n        list[str], typer.Option(\"--option\", \"-o\", envvar=\"ATO_OPTION\")\n    ] = [],\n    frozen: Annotated[\n        bool | None,\n        typer.Option(\n            help=\"PCB must be rebuilt without changes. Useful in CI\",\n            envvar=\"ATO_FROZEN\",\n        ),\n    ] = None,\n    keep_picked_parts: bool | None = None,\n    keep_net_names: bool | None = None,\n    keep_designators: bool | None = None,\n    standalone: bool = False,\n    open_layout: Annotated[\n        bool | None, typer.Option(\"--open\", envvar=\"ATO_OPEN_LAYOUT\")\n    ] = None,\n):\n    \"\"\"\n    Build the specified --target(s) or the targets specified by the build config.\n    Optionally specify a different entrypoint with the argument ENTRY.\n    eg. `ato build --target my_target path/to/source.ato:module.path`\n    \"\"\"\n    from atopile import buildutil\n    from atopile.cli.install import check_missing_deps_or_offer_to_install\n    from atopile.config import BuildType\n    from faebryk.library import _F as F\n    from faebryk.libs.exceptions import accumulate, log_user_errors\n\n    config.apply_options(\n        entry=entry,\n        selected_builds=selected_builds,\n        target=target,\n        option=option,\n        standalone=standalone,\n        frozen=frozen,\n        keep_picked_parts=keep_picked_parts,\n        keep_net_names=keep_net_names,\n        keep_designators=keep_designators,\n    )\n\n    check_missing_deps_or_offer_to_install()\n\n    if open_layout is not None:\n        config.project.open_layout_on_build = open_layout\n\n    with accumulate() as accumulator:\n        for build in config.builds:\n            with accumulator.collect(), log_user_errors(logger), build:\n                logger.info(\"Building '%s'\", config.build.name)\n                with LoggingStage(\n                    name=f\"init-{config.build.name}\",\n                    description=\"Initializing app\",\n                ):\n                    match config.build.build_type:\n                        case BuildType.ATO:\n                            app = _init_ato_app()\n                        case BuildType.PYTHON:\n                            app = _init_python_app()\n                            app.add(F.is_app_root())\n                        case _:\n                            raise ValueError(\n                                f\"Unknown build type: {config.build.build_type}\"\n                            )\n\n                # TODO: add a way to override the following with custom build machinery\n                buildutil.build(app)\n\n    logger.info(\"Build successful! \ud83d\ude80\")\n    logger.info(\"Logs saved to %s\", LOGS_DIR)\n\n    if config.should_open_layout_on_build():\n        selected_build_names = list(config.selected_builds)\n        if len(selected_build_names) == 1:\n            build = config.project.builds[first(selected_build_names)]\n            try:\n                open_pcb(build.paths.layout)\n            except FileNotFoundError:\n                pass\n            except RuntimeError as e:\n                logger.info(\n                    f\"{e.args[0]}\\nReload pcb manually by pressing Ctrl+O; Enter\"\n                )\n\n        elif len(selected_build_names) &gt; 1:\n            logger.warning(\n                \"`--open` option is only supported when building \"\n                \"a single build. It will be ignored.\"\n            )\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli","title":"cli","text":""},{"location":"api/cli/#atopile.cli.cli.app","title":"app  <code>module-attribute</code>","text":"<pre><code>app = Typer(\n    no_args_is_help=True,\n    pretty_exceptions_enable=bool(FLOG_FMT),\n)\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli.python_interpreter_path","title":"python_interpreter_path","text":"<pre><code>python_interpreter_path(ctx, value)\n</code></pre> <p>Print the current python interpreter path.</p> Source code in <code>src/atopile/cli/cli.py</code> <pre><code>def python_interpreter_path(ctx: typer.Context, value: bool):\n    \"\"\"Print the current python interpreter path.\"\"\"\n    if not value or ctx.resilient_parsing:\n        return\n    typer.echo(sys.executable)\n    raise typer.Exit()\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli.atopile_src_path","title":"atopile_src_path","text":"<pre><code>atopile_src_path(ctx, value)\n</code></pre> <p>Print the current python interpreter path.</p> Source code in <code>src/atopile/cli/cli.py</code> <pre><code>def atopile_src_path(ctx: typer.Context, value: bool):\n    \"\"\"Print the current python interpreter path.\"\"\"\n    if not value or ctx.resilient_parsing:\n        return\n    typer.echo(Path(__file__).parent.parent)\n    raise typer.Exit()\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli.version_callback","title":"version_callback","text":"<pre><code>version_callback(ctx, value)\n</code></pre> <p>Output a version string meeting the pypa version spec.</p> Source code in <code>src/atopile/cli/cli.py</code> <pre><code>def version_callback(ctx: typer.Context, value: bool):\n    \"\"\"Output a version string meeting the pypa version spec.\"\"\"\n    if not value or ctx.resilient_parsing:\n        return\n    typer.echo(get_package_version(\"atopile\"))\n    raise typer.Exit()\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli.semver_callback","title":"semver_callback","text":"<pre><code>semver_callback(ctx, value)\n</code></pre> <p>Output a version string meeting the semver.org spec.</p> Source code in <code>src/atopile/cli/cli.py</code> <pre><code>def semver_callback(ctx: typer.Context, value: bool):\n    \"\"\"Output a version string meeting the semver.org spec.\"\"\"\n    if not value or ctx.resilient_parsing:\n        return\n    version_string = get_package_version(\"atopile\")\n    typer.echo(version.parse(version_string))\n    raise typer.Exit()\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli.cli","title":"cli","text":"<pre><code>cli(\n    ctx,\n    non_interactive=None,\n    debug=False,\n    verbose=0,\n    python_path=False,\n    atopile_path=False,\n    version=None,\n    semver=None,\n)\n</code></pre> Source code in <code>src/atopile/cli/cli.py</code> <pre><code>@app.callback()\ndef cli(\n    ctx: typer.Context,\n    non_interactive: Annotated[\n        bool | None,\n        typer.Option(\n            \"--non-interactive\", envvar=[\"ATO_NON_INTERACTIVE\", \"NONINTERACTIVE\"]\n        ),\n    ] = None,\n    debug: Annotated[\n        bool,\n        typer.Option(\"--debug\", help=\"Wait to attach debugger on start\"),\n    ] = False,\n    verbose: Annotated[\n        int,\n        typer.Option(\"--verbose\", \"-v\", count=True, help=\"Increase verbosity\"),\n    ] = 0,\n    python_path: Annotated[\n        bool, typer.Option(hidden=True, callback=python_interpreter_path)\n    ] = False,\n    atopile_path: Annotated[\n        bool, typer.Option(hidden=True, callback=atopile_src_path)\n    ] = False,\n    version: Annotated[\n        bool | None,\n        typer.Option(\"--version\", callback=version_callback, is_eager=True),\n    ] = None,\n    semver: Annotated[\n        bool | None,\n        typer.Option(\"--semver\", callback=semver_callback, is_eager=True),\n    ] = None,\n):\n    if debug:\n        import debugpy  # pylint: disable=import-outside-toplevel\n\n        debug_port = 5678\n        debugpy.listen((\"localhost\", debug_port))\n        logger.info(\"Starting debugpy on port %s\", debug_port)\n        debugpy.wait_for_client()\n\n    # set the log level\n    if verbose == 1:\n        handler.hide_traceback_types = ()\n        handler.tracebacks_show_locals = True\n    elif verbose == 2:\n        handler.tracebacks_suppress_map = {}  # Traceback through atopile infra\n    elif verbose &gt;= 3:\n        logger.root.setLevel(logging.DEBUG)\n        handler.traceback_level = logging.WARNING\n\n    # FIXME: this won't work properly when configs\n    # are reloaded from a pointed-to file (eg in `ato build path/to/file`)\n    # from outside a project directory\n    if non_interactive is not None:\n        config.interactive = not non_interactive\n\n    if ctx.invoked_subcommand:\n        check_for_update()\n\n        # Initialize telemetry\n        telemetry.setup_telemetry_data(ctx.invoked_subcommand)\n\n    if config.interactive and ctx.invoked_subcommand != \"configure\":\n        configure.do_configure_if_needed()\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli.export_config_schema","title":"export_config_schema","text":"<pre><code>export_config_schema(pretty=False)\n</code></pre> Source code in <code>src/atopile/cli/cli.py</code> <pre><code>@app.command(hidden=True)\ndef export_config_schema(pretty: bool = False):\n    from atopile.config import ProjectConfig\n\n    config_schema = ProjectConfig.model_json_schema()\n\n    if pretty:\n        print(json.dumps(config_schema, indent=4))\n    else:\n        print(json.dumps(config_schema))\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli.dump_config","title":"dump_config","text":"<pre><code>dump_config(pretty=False)\n</code></pre> Source code in <code>src/atopile/cli/cli.py</code> <pre><code>@app.command(hidden=True)\ndef dump_config(pretty: bool = False):\n    from rich import print\n\n    if pretty:\n        print(json.dumps(config.project, indent=4))\n    else:\n        print(json.dumps(config.project))\n</code></pre>"},{"location":"api/cli/#atopile.cli.cli.main","title":"main","text":"<pre><code>main()\n</code></pre> Source code in <code>src/atopile/cli/cli.py</code> <pre><code>def main():\n    app()\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure","title":"configure","text":"<p>Configure the user's system for atopile development.</p>"},{"location":"api/cli/#atopile.cli.configure.yaml","title":"yaml  <code>module-attribute</code>","text":"<pre><code>yaml = YAML()\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.CONFIGURED_FOR_PATH","title":"CONFIGURED_FOR_PATH  <code>module-attribute</code>","text":"<pre><code>CONFIGURED_FOR_PATH = absolute()\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.config","title":"config  <code>module-attribute</code>","text":"<pre><code>config = Config()\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.Config","title":"Config","text":""},{"location":"api/cli/#atopile.cli.configure.Config.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version = None\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.Config.install_kicad_plugin","title":"install_kicad_plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>install_kicad_plugin = None\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.get_configured_for_version","title":"get_configured_for_version","text":"<pre><code>get_configured_for_version()\n</code></pre> <p>Return the version of atopile that the user's system is configured for.</p> Source code in <code>src/atopile/cli/configure.py</code> <pre><code>def get_configured_for_version() -&gt; atopile.version.Version:\n    \"\"\"Return the version of atopile that the user's system is configured for.\"\"\"\n    return atopile.version.clean_version(atopile.version.Version.parse(config.version))\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.configure","title":"configure","text":"<pre><code>configure()\n</code></pre> <p>Configure the user's system for atopile development.</p> Source code in <code>src/atopile/cli/configure.py</code> <pre><code>def configure() -&gt; None:\n    \"\"\"\n    Configure the user's system for atopile development.\n    \"\"\"\n    logger.setLevel(logging.INFO)\n    _load_config()\n    do_configure()\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.do_configure_if_needed","title":"do_configure_if_needed","text":"<pre><code>do_configure_if_needed()\n</code></pre> <p>Configure the user's system for atopile development if it's not already configured.</p> Source code in <code>src/atopile/cli/configure.py</code> <pre><code>def do_configure_if_needed() -&gt; None:\n    \"\"\"Configure the user's system for atopile development if it's not already configured.\"\"\"  # noqa: E501  # pre-existing\n    if not CONFIGURED_FOR_PATH.exists():\n        rich.print(\n            dedent(\n                \"\"\"\n            Welcome! :partying_face:\n\n            Looks like you're new to atopile, there's some initial setup we need to do.\n            \"\"\"\n            )\n        )\n\n    _load_config()\n\n    try:\n        if config.version == atopile.version.get_installed_atopile_version():\n            return\n    except TypeError:\n        # Semver appears to do a __req__ by converting the lhs to a type, which\n        # doesn't work for None\n        pass\n\n    # Otherwise we're configured, but we might need to update\n    logger.setLevel(logging.WARNING)  # Quieten output for typical runs\n    do_configure()\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.do_configure","title":"do_configure","text":"<pre><code>do_configure()\n</code></pre> <p>Perform system configuration required for atopile.</p> Source code in <code>src/atopile/cli/configure.py</code> <pre><code>def do_configure() -&gt; None:\n    \"\"\"Perform system configuration required for atopile.\"\"\"\n    if config.install_kicad_plugin is None:\n        config.install_kicad_plugin = questionary.confirm(\n            \":wrench: Install KiCAD plugin?\", default=True\n        ).ask()\n\n    if config.install_kicad_plugin:\n        # FIXME: no idea what's up with this - but seem to help on Windows\n        install_kicad_plugin()\n\n    # final steps\n    config.version = str(\n        atopile.version.clean_version(atopile.version.get_installed_atopile_version())\n    )\n    _save_config()\n</code></pre>"},{"location":"api/cli/#atopile.cli.configure.install_kicad_plugin","title":"install_kicad_plugin","text":"<pre><code>install_kicad_plugin()\n</code></pre> <p>Install the kicad plugin.</p> Source code in <code>src/atopile/cli/configure.py</code> <pre><code>def install_kicad_plugin() -&gt; None:\n    \"\"\"Install the kicad plugin.\"\"\"\n    # Find the path to kicad's plugin directory\n    plugin_loader = f\"\"\"\n        plugin_path = r\"{Path(__file__).parent.parent}\"\n        import sys\n        import importlib\n\n        if plugin_path not in sys.path:\n            sys.path.append(plugin_path)\n\n        # if kicad_plugin is already in sys.modules, reload it\n        for module in sys.modules:\n            if \"kicad_plugin\" in module:\n                importlib.reload(sys.modules[module])\n\n        import kicad_plugin\n        \"\"\"\n\n    def _write_plugin(path: Path):\n        # Create the directory if it doesn't exist\n        path.mkdir(parents=True, exist_ok=True)\n\n        # Write the plugin loader\n        plugin_loader_content = dedent(plugin_loader)\n        plugin_loader_path = path / \"atopile.py\"\n\n        logger.info(\"Writing plugin loader to %s\", plugin_loader_path)\n        with plugin_loader_path.open(\"w\", encoding=\"utf-8\") as f:\n            f.write(plugin_loader_content)\n\n    kicad_config_search_path = [\"~/Documents/KiCad/\", \"~/.local/share/kicad/\"]\n    no_plugin_found = True\n    for sp in kicad_config_search_path:\n        config_path = Path(sp).expanduser().resolve()\n        if config_path.exists():\n            for p in config_path.glob(\"*/scripting/plugins\"):\n                try:\n                    _write_plugin(p)\n                except FileNotFoundError:\n                    _write_plugin(p)\n                no_plugin_found = False\n\n    if no_plugin_found:\n        logger.warning(\"KiCAD config path not found. Couldn't install plugin!\")\n</code></pre>"},{"location":"api/cli/#atopile.cli.console","title":"console","text":""},{"location":"api/cli/#atopile.cli.console.console","title":"console  <code>module-attribute</code>","text":"<pre><code>console = get_console()\n</code></pre>"},{"location":"api/cli/#atopile.cli.console.error_console","title":"error_console  <code>module-attribute</code>","text":"<pre><code>error_console = Console(theme=theme, stderr=True)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create","title":"create","text":""},{"location":"api/cli/#atopile.cli.create.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.PROJECT_TEMPLATE","title":"PROJECT_TEMPLATE  <code>module-attribute</code>","text":"<pre><code>PROJECT_TEMPLATE = (\n    \"https://github.com/atopile/project-template\"\n)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.create_app","title":"create_app  <code>module-attribute</code>","text":"<pre><code>create_app = Typer()\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.stuck_user_helper_generator","title":"stuck_user_helper_generator  <code>module-attribute</code>","text":"<pre><code>stuck_user_helper_generator = _stuck_user_helper()\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.PROJECT_NAME_REQUIREMENTS","title":"PROJECT_NAME_REQUIREMENTS  <code>module-attribute</code>","text":"<pre><code>PROJECT_NAME_REQUIREMENTS = \"Project name must start with a letter and contain only letters, numbers, dashes and underscores. It will be used for the project directory and name on Github\"\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.ComponentType","title":"ComponentType","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"api/cli/#atopile.cli.create.ComponentType.ato","title":"ato  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ato = auto()\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.ComponentType.fab","title":"fab  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fab = auto()\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.CTX","title":"CTX  <code>dataclass</code>","text":"<pre><code>CTX(path, pypath, overwrite)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.CTX.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.CTX.pypath","title":"pypath  <code>instance-attribute</code>","text":"<pre><code>pypath\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.CTX.overwrite","title":"overwrite  <code>instance-attribute</code>","text":"<pre><code>overwrite\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.Template","title":"Template  <code>dataclass</code>","text":"<pre><code>Template(\n    name,\n    base,\n    imports=list(),\n    nodes=list(),\n    docstring=\"TODO: Docstring describing your module\",\n)\n</code></pre> <p>               Bases: <code>ABC</code></p>"},{"location":"api/cli/#atopile.cli.create.Template.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.Template.base","title":"base  <code>instance-attribute</code>","text":"<pre><code>base\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.Template.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports = field(default_factory=list)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.Template.nodes","title":"nodes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nodes = field(default_factory=list)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.Template.docstring","title":"docstring  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>docstring = 'TODO: Docstring describing your module'\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.Template.add_part","title":"add_part  <code>abstractmethod</code>","text":"<pre><code>add_part(part)\n</code></pre> Source code in <code>src/atopile/cli/create.py</code> <pre><code>@abstractmethod\ndef add_part(self, part: Component): ...\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.AtoTemplate","title":"AtoTemplate  <code>dataclass</code>","text":"<pre><code>AtoTemplate(\n    name,\n    base,\n    imports=list(),\n    nodes=list(),\n    docstring=\"TODO: Docstring describing your module\",\n    attributes=list(),\n    pins=list(),\n    defined_signals=set(),\n)\n</code></pre> <p>               Bases: <code>Template</code></p>"},{"location":"api/cli/#atopile.cli.create.AtoTemplate.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.AtoTemplate.base","title":"base  <code>instance-attribute</code>","text":"<pre><code>base\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.AtoTemplate.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports = field(default_factory=list)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.AtoTemplate.nodes","title":"nodes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nodes = field(default_factory=list)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.AtoTemplate.docstring","title":"docstring  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>docstring = 'TODO: Docstring describing your module'\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.AtoTemplate.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes = field(default_factory=list)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.AtoTemplate.pins","title":"pins  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pins = field(default_factory=list)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.AtoTemplate.defined_signals","title":"defined_signals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defined_signals = field(default_factory=set)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.AtoTemplate.add_part","title":"add_part","text":"<pre><code>add_part(part)\n</code></pre> Source code in <code>src/atopile/cli/create.py</code> <pre><code>def add_part(self, part: Component):\n    # Get common processed data\n    self.name, easyeda_symbol = self._process_part(part)\n\n    # Set docstring with description\n    self.docstring = part.description\n\n    # Add component metadata\n    self.attributes.extend(\n        [\n            f'lcsc_id = \"{part.lcsc_display}\"',\n            f'manufacturer = \"{part.manufacturer_name}\"',\n            f'mpn = \"{part.part_number}\"',\n        ]\n    )\n\n    # Add datasheet if available\n    if part.datasheet_url:\n        self.attributes.append(f'datasheet_url = \"{part.datasheet_url}\"')\n\n    # Add designator prefix from EasyEDA symbol\n    designator_prefix = easyeda_symbol.info.prefix.replace(\"?\", \"\")\n    self.attributes.append(f'designator_prefix = \"{designator_prefix}\"')\n\n    # Collect and sort pins first\n    sorted_pins = []\n    if hasattr(easyeda_symbol, \"units\") and easyeda_symbol.units:\n        for unit in easyeda_symbol.units:\n            if hasattr(unit, \"pins\"):\n                for pin in unit.pins:\n                    pin_num = pin.settings.spice_pin_number\n                    pin_name = pin.name.text\n                    if (\n                        pin_name\n                        and pin_name not in [\"NC\", \"nc\"]\n                        and not re.match(r\"^[0-9]+$\", pin_name)\n                    ):\n                        sorted_pins.append((sanitize_name(pin_name), pin_num))\n\n    # Sort pins by name using natsort\n    sorted_pins = natsorted(sorted_pins, key=lambda x: x[0])\n\n    # Process sorted pins\n    for pin_name, pin_num in sorted_pins:\n        if pin_name not in self.defined_signals:\n            self.pins.append(f\"signal {pin_name} ~ pin {pin_num}\")\n            self.defined_signals.add(pin_name)\n        else:\n            self.pins.append(f\"{pin_name} ~ pin {pin_num}\")\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.AtoTemplate.dumps","title":"dumps","text":"<pre><code>dumps()\n</code></pre> Source code in <code>src/atopile/cli/create.py</code> <pre><code>def dumps(self) -&gt; str:\n    output = f\"component {self.name}:\\n\"\n    output += f'    \"\"\"{self.name} component\"\"\"\\n'\n\n    # Add attributes\n    for attr in self.attributes:\n        output += f\"    {attr}\\n\"\n\n    # Add blank line after attributes\n    output += \"\\n\"\n\n    if self.pins:\n        output += \"    # pins\\n\"\n        for pin in self.pins:\n            output += f\"    {pin}\\n\"\n\n    return output\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.FabllTemplate","title":"FabllTemplate  <code>dataclass</code>","text":"<pre><code>FabllTemplate(\n    name,\n    base,\n    imports=list(),\n    nodes=list(),\n    docstring=\"TODO: Docstring describing your module\",\n    traits=list(),\n)\n</code></pre> <p>               Bases: <code>Template</code></p>"},{"location":"api/cli/#atopile.cli.create.FabllTemplate.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.FabllTemplate.base","title":"base  <code>instance-attribute</code>","text":"<pre><code>base\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.FabllTemplate.imports","title":"imports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imports = field(default_factory=list)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.FabllTemplate.nodes","title":"nodes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nodes = field(default_factory=list)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.FabllTemplate.docstring","title":"docstring  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>docstring = 'TODO: Docstring describing your module'\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.FabllTemplate.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = field(default_factory=list)\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.FabllTemplate.add_part","title":"add_part","text":"<pre><code>add_part(part)\n</code></pre> Source code in <code>src/atopile/cli/create.py</code> <pre><code>def add_part(self, part: Component):\n    # Get common processed data\n    self.name, easyeda_symbol = self._process_part(part)\n\n    designator_prefix_str = easyeda_symbol.info.prefix.replace(\"?\", \"\")\n    try:\n        prefix = has_designator_prefix.Prefix(designator_prefix_str)\n        designator_prefix = f\"F.has_designator_prefix.Prefix.{prefix.name}\"\n    except ValueError:\n        logger.warning(\n            f\"Using non-standard designator prefix: {designator_prefix_str}\"\n        )\n        designator_prefix = f\"'{designator_prefix_str}'\"\n\n    self.traits.append(\n        f\"designator_prefix = L.f_field(F.has_designator_prefix)\"\n        f\"({designator_prefix})\"\n    )\n\n    self.traits.append(\n        \"lcsc_id = L.f_field(F.has_descriptive_properties_defined)\"\n        f\"({{'LCSC': '{part.lcsc_display}'}})\"\n    )\n\n    self.imports.append(\n        \"from faebryk.libs.picker.picker import DescriptiveProperties\"\n    )\n    self.traits.append(\n        f\"descriptive_properties = L.f_field(F.has_descriptive_properties_defined)\"\n        f\"({{DescriptiveProperties.manufacturer: '{part.manufacturer_name}', \"\n        f\"DescriptiveProperties.partno: '{part.part_number}'}})\"\n    )\n\n    if url := part.datasheet_url:\n        self.traits.append(\n            f\"datasheet = L.f_field(F.has_datasheet_defined)('{url}')\"\n        )\n\n    partdoc = part.description.replace(\"  \", \"\\n\")\n    self.docstring = f\"{self.docstring}\\n\\n{partdoc}\"\n\n    # pins --------------------------------\n    no_name: list[str] = []\n    no_connection: list[str] = []\n    interface_names_by_pin_num: dict[str, str] = {}\n\n    for unit in easyeda_symbol.units:\n        for pin in unit.pins:\n            pin_num = pin.settings.spice_pin_number\n            pin_name = pin.name.text\n            if re.match(r\"^[0-9]+$\", pin_name):\n                no_name.append(pin_num)\n            elif pin_name in [\"NC\", \"nc\"]:\n                no_connection.append(pin_num)\n            else:\n                pyname = sanitize_name(pin_name)\n                interface_names_by_pin_num[pin_num] = pyname\n\n    self.nodes.append(\n        \"#TODO: Change auto-generated interface types to actual high level types\"\n    )\n\n    _interface_lines_by_min_pin_num = {}\n    for interface_name, _items in groupby(\n        interface_names_by_pin_num.items(), lambda x: x[1]\n    ).items():\n        pin_nums = [x[0] for x in _items]\n        line = f\"{interface_name}: F.Electrical  # {\"pin\" if len(pin_nums) == 1 else \"pins\"}: {\", \".join(pin_nums)}\"  # noqa: E501  # pre-existing\n        _interface_lines_by_min_pin_num[min(pin_nums)] = line\n    self.nodes.extend(\n        line\n        for _, line in natsorted(\n            _interface_lines_by_min_pin_num.items(), key=lambda x: x[0]\n        )\n    )\n\n    if no_name:\n        self.nodes.append(f\"unnamed = L.list_field({len(no_name)}, F.Electrical)\")\n\n    pin_lines = (\n        [\n            f'\"{pin_num}\": self.{interface_name},'\n            for pin_num, interface_name in interface_names_by_pin_num.items()\n        ]\n        + [f'\"{pin_num}\": None,' for pin_num in no_connection]\n        + [f'\"{pin_num}\": self.unnamed[{i}],' for i, pin_num in enumerate(no_name)]\n    )\n    self.traits.append(\n        fix_indent(f\"\"\"\n        @L.rt_field\n        def attach_via_pinmap(self):\n            return F.can_attach_to_footprint_via_pinmap(\n                {{\n                    {gen_repeated_block(natsorted(pin_lines))}\n                }}\n            )\n    \"\"\")\n    )\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.FabllTemplate.dumps","title":"dumps","text":"<pre><code>dumps()\n</code></pre> Source code in <code>src/atopile/cli/create.py</code> <pre><code>def dumps(self) -&gt; str:\n    always_import = [\n        \"import faebryk.library._F as F  # noqa: F401\",\n        f\"from faebryk.core.{self.base.lower()} import {self.base}\",\n        \"from faebryk.libs.library import L  # noqa: F401\",\n        \"from faebryk.libs.units import P  # noqa: F401\",\n    ]\n\n    self.imports = always_import + self.imports\n\n    out = fix_indent(f\"\"\"\n        # This file is part of the faebryk project\n        # SPDX-License-Identifier: MIT\n\n        import logging\n\n        {gen_repeated_block(self.imports)}\n\n        logger = logging.getLogger(__name__)\n\n        class {self.name}({self.base}):\n            \\\"\\\"\\\"\n            {gen_block(self.docstring)}\n            \\\"\\\"\\\"\n\n            # ----------------------------------------\n            #                modules\n            # ----------------------------------------\n\n            # ----------------------------------------\n            #              interfaces\n            # ----------------------------------------\n            {gen_repeated_block(self.nodes)}\n\n            # ----------------------------------------\n            #              parameters\n            # ----------------------------------------\n\n            # ----------------------------------------\n            #                traits\n            # ----------------------------------------\n            {gen_repeated_block(self.traits)}\n\n            def __preinit__(self):\n                # ------------------------------------\n                #           connections\n                # ------------------------------------\n\n                # ------------------------------------\n                #          parametrization\n                # ------------------------------------\n                pass\n    \"\"\")\n\n    return out\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.help","title":"help","text":"<pre><code>help(text)\n</code></pre> <p>Print help text.</p> Source code in <code>src/atopile/cli/create.py</code> <pre><code>def help(text: str) -&gt; None:  # pylint: disable=redefined-builtin\n    \"\"\"Print help text.\"\"\"\n    rich.print(\"\\n\" + textwrap.dedent(text).strip() + \"\\n\")\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.query_helper","title":"query_helper","text":"<pre><code>query_helper(\n    prompt,\n    type_,\n    clarifier=lambda x: x,\n    upgrader=lambda x: x,\n    upgrader_msg=None,\n    validator=None,\n    validation_failure_msg=\"Value [cyan]{value}[/] is invalid\",\n    default=None,\n    pre_entered=None,\n    validate_default=True,\n)\n</code></pre> <p>Query a user for input.</p> Source code in <code>src/atopile/cli/create.py</code> <pre><code>def query_helper[T: str | Path | bool](\n    prompt: str,\n    type_: type[T],\n    clarifier: Callable[[Any], T] = lambda x: x,\n    upgrader: Callable[[T], T] = lambda x: x,\n    upgrader_msg: str | None = None,\n    validator: str | Callable[[T], bool] | None = None,\n    validation_failure_msg: str | None = \"Value [cyan]{value}[/] is invalid\",\n    default: T | None = None,\n    pre_entered: T | None = None,\n    validate_default: bool = True,\n) -&gt; T:\n    \"\"\"Query a user for input.\"\"\"\n    rich.print(prompt)\n\n    # Check the default value\n    if default is not None:\n        if not isinstance(default, type_):\n            raise ValueError(f\"Default value {default} is not of type {type_}\")\n\n    # Make a queryier\n    if type_ is str:\n\n        def queryier() -&gt; str:\n            return questionary.text(\n                \"\",\n                default=str(default or \"\"),\n            ).unsafe_ask()\n\n    elif type_ is Path:\n\n        def queryier() -&gt; Path:\n            return Path(\n                questionary.path(\n                    \"\",\n                    default=str(default or \"\"),\n                ).unsafe_ask()\n            )\n\n    elif type_ is bool:\n        assert default is None or isinstance(default, bool)\n\n        def queryier() -&gt; bool:\n            return questionary.confirm(\n                \"\",\n                default=default or True,\n            ).unsafe_ask()\n\n    else:\n        raise ValueError(f\"Unsupported query type: `{type_}`\")\n\n    # Ensure a validator\n    # Default the validator to a regex match if it's a str\n    if validator is None:\n\n        def validator_func(value: T) -&gt; bool:\n            return True\n\n    elif isinstance(validator, str):\n\n        def validator_func(value: T) -&gt; bool:\n            return bool(re.match(validator, value))  # type: ignore\n\n        if not validation_failure_msg:\n            validation_failure_msg = f'Value must match regex: `r\"{validator}\"`'\n\n    else:\n        validator_func = validator  # type: ignore\n\n    # Ensure the default provided is valid\n    if default is not None and validate_default:\n        if not validator_func(clarifier(default)):\n            raise ValueError(f\"Default value {default} is invalid\")\n\n        if clarifier(default) != upgrader(clarifier(default)):\n            raise ValueError(f\"Default value {default} doesn't meet best-practice\")\n\n    # When running non-interactively, we expect the value to be provided\n    # at the command level, so we don't need to query the user for it\n    # Validate and return the pre-entered value\n    if not config.interactive:\n        if pre_entered is None:\n            raise ValueError(\"Value is required. Check at command level.\")\n\n        if not validator_func(pre_entered):\n            if validation_failure_msg:\n                msg = validation_failure_msg.format(value=pre_entered)\n            else:\n                msg = f\"Value {pre_entered} is invalid\"\n            raise errors.UserException(msg)\n\n        return pre_entered\n\n    # Pre-entered values are expected to skip the query for a value in the first place\n    # but progress through the validator and upgrader if we're running interactively\n    value: T | None = pre_entered\n\n    for _ in stuck_user_helper_generator:\n        if value is None:\n            value = clarifier(queryier())  # type: ignore\n        assert isinstance(value, type_)\n\n        if (proposed_value := upgrader(value)) != value:\n            if upgrader_msg:\n                rich.print(upgrader_msg.format(proposed_value=proposed_value))\n\n            rich.print(f\"Use [cyan]{proposed_value}[/] instead?\")\n            if questionary.confirm(\"\").unsafe_ask():\n                value = proposed_value\n\n        if not validator_func(value):\n            if validation_failure_msg:\n                rich.print(validation_failure_msg.format(value=value))\n            value = None\n            continue\n\n        return value\n\n    raise RuntimeError(\"Unclear how we got here\")\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.project","title":"project","text":"<pre><code>project(\n    template=\"https://github.com/atopile/project-template @ compiler-v0.3\",\n    create_github_repo=None,\n)\n</code></pre> <p>Create a new ato project.</p> Source code in <code>src/atopile/cli/create.py</code> <pre><code>@create_app.command()\ndef project(\n    template: str = \"https://github.com/atopile/project-template @ compiler-v0.3\",\n    create_github_repo: bool | None = None,\n):\n    \"\"\"\n    Create a new ato project.\n    \"\"\"\n    # TODO: add template options\n\n    template_ref, *template_branch = template.split(\"@\")\n    template_ref = template_ref.strip()\n    if template_branch:\n        template_branch = template_branch[0].strip()\n    else:\n        template_branch = None\n\n    # Default to creating a Github repo if running interactively\n    if create_github_repo is None:\n        create_github_repo = config.interactive\n\n    if create_github_repo is True and not config.interactive:\n        raise errors.UserException(\n            \"Cannot create a Github repo when running non-interactively.\"\n        )\n\n    extra_context = {\n        \"__ato_version\": version.get_installed_atopile_version(),\n        \"__python_path\": sys.executable,\n    }\n\n    logging.info(\"Running cookie-cutter on the template\")\n    project_path = Path(\n        cookiecutter(\n            template_ref,\n            checkout=template_branch,\n            no_input=not config.interactive,\n            extra_context=dict(\n                filter(lambda x: x[1] is not None, extra_context.items())\n            ),\n        )\n    )\n\n    # Get a repo\n    if create_github_repo:\n        logging.info(\"Initializing git repo\")\n        repo = git.Repo.init(project_path)\n        repo.git.add(A=True, f=True)\n        repo.git.commit(m=\"Initial commit\")\n\n        github_username = query_helper(\n            \"What's your Github username?\",\n            str,\n            validator=r\"^[a-zA-Z0-9_-]+$\",\n        )\n\n        make_repo_url = (\n            f\"https://github.com/new?name={project_path.name}&amp;owner={github_username}\"\n        )\n\n        help(\n            f\"\"\"\n            We recommend you create a Github repo for your project.\n\n            If you already have a repo, you can respond [yellow]n[/]\n            to the next question and provide the URL to your repo.\n\n            If you don't have one, you can respond yes to the next question\n            or (Cmd/Ctrl +) click the link below to create one.\n\n            Just select the template you want to use.\n\n            {make_repo_url}\n            \"\"\"\n        )\n\n        webbrowser.open(make_repo_url)\n\n        def _repo_validator(url: str) -&gt; bool:\n            try:\n                urllib3.request(\"GET\", url)\n                return True\n            except Exception:\n                return False\n\n        if url := query_helper(\n            \":rocket: What's the [cyan]repo's URL?[/]\",\n            str,\n            default=f\"https://github.com/{github_username}/{project_path.name}\",\n            validator=_repo_validator,\n            validate_default=False,\n        ):\n            repo.create_remote(\"origin\", url).push()\n\n    # Wew! New repo created!\n    rich.print(\n        f':sparkles: [green]Created new project \"{project_path.name}\"![/] :sparkles:'\n    )\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.build_target","title":"build_target","text":"<pre><code>build_target(\n    build_target=None,\n    file=None,\n    module=None,\n    backup_name=None,\n)\n</code></pre> <p>Create a new build configuration. - adds entry to ato.yaml - creates a new directory in layout</p> Source code in <code>src/atopile/cli/create.py</code> <pre><code>@create_app.command(\"build-target\")\ndef build_target(\n    build_target: Annotated[str | None, typer.Option()] = None,\n    file: Annotated[Path | None, typer.Option()] = None,\n    module: Annotated[str | None, typer.Option()] = None,\n    backup_name: Annotated[str | None, typer.Argument()] = None,\n):\n    \"\"\"\n    Create a new build configuration.\n    - adds entry to ato.yaml\n    - creates a new directory in layout\n    \"\"\"\n    config.apply_options(None)\n\n    try:\n        src_path = config.project.paths.src\n        config.project_dir  # touch property to ensure config's loaded from a project\n    except ValueError:\n        raise errors.UserException(\n            \"Could not find the project directory, are you within an ato project?\"\n        )\n\n    if backup_name is None:\n        if build_target:\n            backup_name = build_target\n        elif file:\n            backup_name = file.name.split(\".\", 1)[0]\n        elif module:\n            backup_name = module\n\n    # If we're running non-interactively, all details must be provided\n    if not config.interactive and not all([build_target, file, module]):\n        raise errors.UserException(\n            \"--build-target, --file, and --module must all be\"\n            \" provided when running non-interactively.\"\n        )\n\n    def _check_build_target_name(value: str) -&gt; bool:\n        if not re.match(r\"^[a-zA-Z][a-zA-Z0-9_-]*$\", value):\n            rich.print(\n                \"[red]Build-target names must start with a letter and\"\n                \" contain only letters, numbers, dashes and underscores.[/]\"\n            )\n            return False\n\n        if value in config.project.builds:\n            rich.print(f\"[red]Build-target `{value}` already exists[/]\")\n            return False\n\n        return True\n\n    build_target = query_helper(\n        \":rocket: What's the [cyan]build-target[/] name?\",\n        type_=str,\n        upgrader=caseconverter.kebabcase,\n        upgrader_msg=\"We recommend using kebab-case for build-target names.\",\n        validator=_check_build_target_name,\n        validation_failure_msg=\"\",\n        pre_entered=build_target,\n        default=caseconverter.kebabcase(backup_name) if backup_name else None,\n    )\n\n    def _file_clarifier(value: Path) -&gt; Path:\n        if not value.is_absolute():\n            # If it's a relative path wrt ./ (cwd) then respect that\n            # else assume it's relative to the src directory\n            if str(value).startswith(\"./\") or str(value).startswith(\".\\\\\"):\n                value = Path(value).resolve()\n            else:\n                value = src_path / value\n\n        return value\n\n    def _file_updator(value: Path) -&gt; Path:\n        value = value.with_stem(caseconverter.snakecase(value.stem))\n        if value.suffix != \".ato\":\n            # Allow dots in filenames\n            value = value.with_suffix(value.suffix + \".ato\")\n        return value\n\n    def _file_validator(f: Path) -&gt; bool:\n        if f.is_dir():\n            rich.print(f\"{f} is a directory\")\n            return False\n\n        if f.suffix != \".ato\":\n            rich.print(f\"{f} must end in .ato\")\n            return False\n\n        try:\n            f.relative_to(src_path)\n        except ValueError:\n            rich.print(f\"{f} is outside the project's src dir\")\n            return False\n\n        return True\n\n    file = query_helper(\n        \":rocket: What [cyan]file[/] should we add the module to?\",\n        type_=Path,\n        clarifier=_file_clarifier,\n        upgrader=_file_updator,\n        upgrader_msg=(\n            \"We recommend using snake_case for file names, and it must end in .ato\"\n        ),\n        validator=_file_validator,\n        validation_failure_msg=\"\",\n        pre_entered=file,\n        default=Path(caseconverter.snakecase(backup_name or build_target) + \".ato\"),\n    )\n\n    module = query_helper(\n        \":rocket: What [cyan]module[/] should we add to the file?\",\n        type_=str,\n        validator=str.isidentifier,\n        validation_failure_msg=\"\",\n        upgrader=caseconverter.pascalcase,\n        upgrader_msg=\"We recommend using pascal-case for module names.\",\n        pre_entered=module,\n        default=caseconverter.pascalcase(backup_name or build_target),\n    )\n\n    logger.debug(f\"Creating build-target with {build_target=}, {file=}, {module=}\")\n\n    # Update project config\n    logger.info(\n        f\"Adding build-target to {config.project.paths.root / PROJECT_CONFIG_FILENAME}\"\n    )\n\n    def add_build_target(config_data: dict, new_data: dict):\n        config_data[\"builds\"][build_target] = new_data\n        return config_data\n\n    config.update_project_config(\n        add_build_target, {\"entry\": str(AddrStr.from_parts(file, module))}\n    )\n\n    # Create or add to file\n    module_text = f\"module {module}:\\n    pass\\n\"\n\n    if file.is_file():  # exists and is a file\n        with file.open(\"a\") as f:\n            f.write(\"\\n\")\n            f.write(module_text)\n\n    else:\n        file.parent.mkdir(parents=True, exist_ok=True)\n        file.write_text(module_text)\n\n    rich.print(\n        \":sparkles: Successfully created a new build configuration \"\n        f\"[cyan]{build_target}[/] at [cyan]{file}[/]! :sparkles:\"\n    )\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.component","title":"component","text":"<pre><code>component(\n    search_term=None, name=None, filename=None, type_=None\n)\n</code></pre> <p>Create a new component.</p> Source code in <code>src/atopile/cli/create.py</code> <pre><code>@create_app.command()\ndef component(\n    search_term: Annotated[str | None, typer.Option(\"--search\", \"-s\")] = None,\n    name: Annotated[str | None, typer.Option(\"--name\", \"-n\")] = None,\n    filename: Annotated[str | None, typer.Option(\"--filename\", \"-f\")] = None,\n    type_: Annotated[ComponentType | None, typer.Option(\"--type\", \"-t\")] = None,\n):\n    \"\"\"Create a new component.\"\"\"\n    from faebryk.libs.picker.api.models import Component\n    from faebryk.libs.picker.api.picker_lib import client\n    from faebryk.libs.pycodegen import sanitize_name\n\n    try:\n        config.apply_options(None)\n    except errors.UserBadParameterError:\n        config.apply_options(None, standalone=True)\n\n    # Find a component --------------------------------------------------------\n\n    component: Component | None = None\n\n    for _ in stuck_user_helper_generator:\n        if not search_term:\n            search_term = questionary.text(\n                \"Search for a component (Part Number or LCSC ID):\"\n            ).unsafe_ask()\n            assert search_term is not None\n\n        try:\n            lcsc_id = _extract_numeric_id(search_term)\n        except ValueError:\n            lcsc_id = None\n\n        try:\n            if lcsc_id:\n                components = client.fetch_part_by_lcsc(lcsc_id)\n            else:\n                # TODO: remove this once we have a fuzzy search\n                mfr = questionary.text(\"Enter the manufacturer\").unsafe_ask()\n                components = client.fetch_part_by_mfr(mfr, search_term)\n        except ApiHTTPError as e:\n            if e.response.status_code == 404:\n                components = []\n            else:\n                raise\n\n        if len(components) == 0:\n            rich.print(f'No components found for \"{search_term}\"')\n            search_term = None\n            continue\n\n        component_table = Table()\n        component_table.add_column(\"Part Number\")\n        component_table.add_column(\"Manufacturer\")\n        component_table.add_column(\"Description\")\n\n        for component in components:\n            component_table.add_row(\n                component.manufacturer_name,\n                component.part_number,\n                component.description,\n            )\n\n        rich.print(component_table)\n\n        choices = [\n            {\n                \"name\": f\"{component.manufacturer_name} {component.part_number}\",\n                \"value\": component,\n            }\n            for component in components\n        ] + [{\"name\": \"Search again...\", \"value\": None}]\n\n        component = questionary.select(\n            \"Select a component\", choices=choices\n        ).unsafe_ask()\n\n        if component is not None:\n            break\n\n        # Reset the input terms to start over if we didn't find what we're looking for\n        search_term = None\n\n    # We have a component -----------------------------------------------------\n    assert component is not None\n\n    # TODO: templated ato components too\n    # if type_ is None:\n    #     type_ = ComponentType.fab\n    if type_ is None:\n        type_ = questionary.select(\n            \"Select the component type\", choices=list(ComponentType)\n        ).unsafe_ask()\n        assert type_ is not None\n\n    if name is None:\n        name = questionary.text(\n            \"Enter the name of the component\",\n            default=caseconverter.pascalcase(\n                sanitize_name(component.manufacturer_name + \" \" + component.part_number)\n            ),\n        ).unsafe_ask()\n\n    sanitized_name = sanitize_name(name)\n    if sanitized_name != name:\n        rich.print(f\"Sanitized name: {sanitized_name}\")\n\n    if type_ == ComponentType.ato:\n        extension = \".ato\"\n    elif type_ == ComponentType.fab:\n        extension = \".py\"\n    else:\n        raise ValueError(f\"Invalid component type: {type_}\")\n\n    out_path: Path | None = None\n    for _ in stuck_user_helper_generator:\n        if filename is None:\n            filename = questionary.text(\n                \"Enter the filename of the component\",\n                default=caseconverter.snakecase(name) + extension,\n            ).unsafe_ask()\n\n        assert filename is not None\n\n        filepath = Path(filename)\n        if filepath.absolute():\n            out_path = filepath.resolve()\n        else:\n            out_path = (config.project.paths.src / filename).resolve()\n\n        if out_path.exists():\n            rich.print(f\"File {out_path} already exists\")\n            filename = None\n            continue\n\n        if not out_path.parent.exists():\n            rich.print(\n                f\"Directory {out_path.parent} does not exist. Creating it now...\"\n            )\n            out_path.parent.mkdir(parents=True, exist_ok=True)\n\n        break\n\n    assert out_path is not None\n\n    if type_ == ComponentType.ato:\n        template = AtoTemplate(name=sanitized_name, base=\"Module\")\n        template.add_part(component)\n        out = template.dumps()\n        out_path.write_text(out)\n        rich.print(f\":sparkles: Created {out_path} !\")\n\n    elif type_ == ComponentType.fab:\n        template = FabllTemplate(name=sanitized_name, base=\"Module\")\n        template.add_part(component)\n        out = template.dumps()\n        format_and_write(out, out_path)\n        rich.print(f\":sparkles: Created {out_path} !\")\n</code></pre>"},{"location":"api/cli/#atopile.cli.create.main","title":"main","text":"<pre><code>main(ctx)\n</code></pre> Source code in <code>src/atopile/cli/create.py</code> <pre><code>@create_app.callback(invoke_without_command=True)\ndef main(ctx: typer.Context):\n    if ctx.resilient_parsing:\n        return\n\n    if not ctx.invoked_subcommand:\n        commands = cast(dict, ctx.command.commands)  # type: ignore  # commands is an attribute of the context\n        command_name = questionary.select(\n            \"What would you like to create?\",\n            choices=[n for n, c in commands.items() if not c.hidden],\n        ).unsafe_ask()\n\n        assert command_name in commands\n\n        # Run the command\n        ctx.invoke(commands[command_name].callback)\n</code></pre>"},{"location":"api/cli/#atopile.cli.excepthook","title":"excepthook","text":""},{"location":"api/cli/#atopile.cli.excepthook.handle_exception","title":"handle_exception","text":"<pre><code>handle_exception(exc_type, exc_value, exc_traceback)\n</code></pre> Source code in <code>src/atopile/cli/excepthook.py</code> <pre><code>def handle_exception(exc_type, exc_value, exc_traceback):\n    try:\n        _handle_exception(exc_type, exc_value, exc_traceback)\n    except Exception as e:\n        sys.__excepthook__(type(e), e, e.__traceback__)\n    finally:\n        with contextlib.suppress(Exception):\n            telemetry.log_telemetry()\n\n        rich.print(\n            \"\\n\\nUnfortunately errors ^^^ stopped the build. \"\n            \"If you need a hand jump on [#9656ce]Discord[/]! [link=https://discord.gg/mjtxARsr9V]https://discord.gg/mjtxARsr9V[/] :wave:\"  # noqa: E501  # pre-existing\n        )\n        sys.exit(1)\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect","title":"inspect","text":"<p><code>ato inspect</code></p>"},{"location":"api/cli/#atopile.cli.inspect.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.odd_row","title":"odd_row  <code>module-attribute</code>","text":"<pre><code>odd_row = 'on grey11 cornflower_blue'\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.even_row","title":"even_row  <code>module-attribute</code>","text":"<pre><code>even_row = 'on grey15 cornflower_blue'\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.odd_greyed_row","title":"odd_greyed_row  <code>module-attribute</code>","text":"<pre><code>odd_greyed_row = 'on grey11 grey0'\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.even_greyed_row","title":"even_greyed_row  <code>module-attribute</code>","text":"<pre><code>even_greyed_row = 'on grey15 grey0'\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.DisplayEntry","title":"DisplayEntry","text":"<pre><code>DisplayEntry(net)\n</code></pre> <p>This class represents the nets that are below the inspected module, the equivalent net that is below the context module and the individual connections that are made to the inspect net and the context net.</p> Source code in <code>src/atopile/cli/inspect.py</code> <pre><code>def __init__(self, net: list[list[AddrStr]]):\n    self.inspect_net: list[AddrStr] = net\n    self.inspect_consumer: list[AddrStr] = []\n    self.context_net: list[AddrStr] = []\n    self.context_consumer: list[AddrStr] = []\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.DisplayEntry.inspect_net","title":"inspect_net  <code>instance-attribute</code>","text":"<pre><code>inspect_net = net\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.DisplayEntry.inspect_consumer","title":"inspect_consumer  <code>instance-attribute</code>","text":"<pre><code>inspect_consumer = []\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.DisplayEntry.context_net","title":"context_net  <code>instance-attribute</code>","text":"<pre><code>context_net = []\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.DisplayEntry.context_consumer","title":"context_consumer  <code>instance-attribute</code>","text":"<pre><code>context_consumer = []\n</code></pre>"},{"location":"api/cli/#atopile.cli.inspect.inspect","title":"inspect","text":"<pre><code>inspect(\n    entry=None,\n    build=[],\n    target=[],\n    option=[],\n    inspect=None,\n    context=None,\n    dump_csv=None,\n)\n</code></pre> <p>Utility to inspect what is connected to a component. The context sets the boundary where something is considered connected. For example: <code>--inspect rp2040_micro --context rp2040_micro_ki</code></p> Source code in <code>src/atopile/cli/inspect.py</code> <pre><code>def inspect(\n    entry: Annotated[str | None, typer.Argument()] = None,\n    build: Annotated[list[str], typer.Option(\"--build\", \"-b\", envvar=\"ATO_BUILD\")] = [],\n    target: Annotated[\n        list[str], typer.Option(\"--target\", \"-t\", envvar=\"ATO_TARGET\")\n    ] = [],\n    option: Annotated[\n        list[str], typer.Option(\"--option\", \"-o\", envvar=\"ATO_OPTION\")\n    ] = [],\n    inspect: str | None = None,\n    context: Annotated[\n        str | None,\n        typer.Option(\n            \"--context\", \"-c\", help=\"The context from which to inspect the module\"\n        ),\n    ] = None,\n    dump_csv: Annotated[\n        str | None,\n        typer.Option(\"--dump-csv\", \"-d\", help=\"Output the inspection to a CSV file\"),\n    ] = None,\n):\n    \"\"\"\n    Utility to inspect what is connected to a component.\n    The context sets the boundary where something is considered connected.\n    For example: `--inspect rp2040_micro --context rp2040_micro_ki`\n    \"\"\"\n    raise errors.UserNotImplementedError(\"Inspect is not yet implemented.\")\n</code></pre>"},{"location":"api/cli/#atopile.cli.install","title":"install","text":"<p>This CLI command provides the <code>ato install</code> command to: - install dependencies - download JLCPCB footprints</p>"},{"location":"api/cli/#atopile.cli.install.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.yaml","title":"yaml  <code>module-attribute</code>","text":"<pre><code>yaml = YAML()\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.install","title":"install","text":"<pre><code>install(\n    to_install=None,\n    jlcpcb=False,\n    vendor=False,\n    local=None,\n    upgrade=False,\n    path=None,\n)\n</code></pre> <p>Install atopile packages or components from jlcpcb.com/parts</p> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def install(\n    to_install: Annotated[str | None, typer.Argument()] = None,\n    jlcpcb: Annotated[\n        bool, typer.Option(\"--jlcpcb\", \"-j\", help=\"JLCPCB component ID\", hidden=True)\n    ] = False,\n    vendor: Annotated[\n        bool,\n        typer.Option(\n            \"--vendor\",\n            help=\"Copy the contents of this dependency into the repo\",\n        ),\n    ] = False,\n    local: Annotated[\n        Path | None, typer.Option(\"--local\", \"-l\", help=\"Install from local path\")\n    ] = None,\n    upgrade: Annotated[\n        bool, typer.Option(\"--upgrade\", \"-u\", help=\"Upgrade dependencies\")\n    ] = False,\n    path: Annotated[Path | None, typer.Argument()] = None,\n):\n    \"\"\"\n    Install atopile packages or components from jlcpcb.com/parts\n    \"\"\"\n    if jlcpcb:\n        raise errors.UserBadParameterError(\n            \"--jlcpcb flag has been replaced by `ato create component`\"\n        )\n\n    config.apply_options(None)\n\n    do_install(to_install, vendor, upgrade, path, local)\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.do_install","title":"do_install","text":"<pre><code>do_install(to_install, vendor, upgrade, path, local)\n</code></pre> <p>Actually do the installation of the dependencies. This is split in two so that it can be called from <code>install</code> and <code>create</code></p> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def do_install(\n    to_install: str | None,\n    vendor: bool,\n    upgrade: bool,\n    path: Path | None,\n    local: Path | None,\n):\n    \"\"\"\n    Actually do the installation of the dependencies.\n    This is split in two so that it can be called from `install` and `create`\n    \"\"\"\n\n    if path is not None:\n        config.project_dir = path\n\n    if to_install is None:\n        logger.info(f\"Installing all dependencies in {config.project.paths.root}\")\n    else:\n        logger.info(f\"Installing {to_install} in {config.project.paths.root}\")\n\n    if local:\n        # eg. \"ato install --local /path/to/local/module local_module\"\n        install_single_local(local, name=to_install)\n    elif to_install:\n        # eg. \"ato install some-atopile-module\"\n        install_single_dependency(to_install, vendor, upgrade)\n    else:\n        # eg. \"ato install\"\n        install_project_dependencies(upgrade)\n\n    logger.info(\"[green]Done![/] :call_me_hand:\", extra={\"markup\": True})\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.get_package_repo_from_registry","title":"get_package_repo_from_registry","text":"<pre><code>get_package_repo_from_registry(module_name)\n</code></pre> <p>Get the git repo for a package from the ato registry.</p> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def get_package_repo_from_registry(module_name: str) -&gt; str:\n    \"\"\"\n    Get the git repo for a package from the ato registry.\n    \"\"\"\n    try:\n        encoded_name = quote(module_name)\n        response = requests.get(\n            f\"{config.project.services.packages.url}/v0/package/{encoded_name}\",\n            timeout=10,\n        )\n    except requests.exceptions.ReadTimeout as ex:\n        raise errors.UserInfraError(\n            f\"Request to registry timed out for package '{module_name}'\"\n        ) from ex\n\n    try:\n        response.raise_for_status()\n    except requests.exceptions.HTTPError as ex:\n        try:\n            _ = response.json()[\"detail\"]\n            if response.status_code == 404:\n                raise errors.UserException(\n                    f\"Could not find package '{module_name}' in registry.\",\n                    markdown=False,\n                ) from None\n        except (KeyError, requests.exceptions.JSONDecodeError):\n            pass\n\n        raise errors.UserException(\n            f\"Error getting data for package '{module_name}': \\n{ex}\",\n            markdown=False,\n        )\n\n    return_data = response.json()\n\n    try:\n        return_url = return_data[\"data\"][\"repo_url\"]\n    except KeyError as ex:\n        raise errors.UserException(\n            f\"No repo_url found for package '{module_name}'\"\n        ) from ex\n    return return_url\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.add_dependency","title":"add_dependency","text":"<pre><code>add_dependency(config_data, new_data)\n</code></pre> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def add_dependency(config_data, new_data):\n    config_data[\"dependencies\"] = [\n        dep.model_dump()\n        # add_dependencies is the field validator that loads the dependencies\n        # from the config file. It ensures the format of the ato.yaml\n        for dep in ProjectConfig.add_dependencies(\n            config_data.get(\"dependencies\"),\n        )  # type: ignore  add_dependencies is a classmethod\n    ]\n\n    for i, dep in enumerate(config_data[\"dependencies\"]):\n        if dep[\"name\"] == new_data[\"name\"]:\n            config_data[\"dependencies\"][i] = new_data\n            break\n    else:\n        config_data[\"dependencies\"] = config_data[\"dependencies\"] + [new_data]\n\n    return config_data\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.install_single_local","title":"install_single_local","text":"<pre><code>install_single_local(path, name=None)\n</code></pre> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def install_single_local(path: Path, name: str | None = None):\n    name = name or path.name\n    dependency = Dependency(\n        name=name,\n        source=Source(local=path),\n        path=(config.project.paths.modules / name).relative_to(\n            config.project.paths.root\n        ),\n        project_config=ProjectConfig.from_path(path),\n    )\n    install_local_dependency(dependency)\n    config.update_project_config(add_dependency, dependency.model_dump())\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.install_single_dependency","title":"install_single_dependency","text":"<pre><code>install_single_dependency(to_install, vendor, upgrade)\n</code></pre> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def install_single_dependency(to_install: str, vendor: bool, upgrade: bool):\n    dependency = Dependency.from_str(to_install)\n    name = _name_and_clone_url_helper(dependency.name)[0]\n    if vendor:\n        dependency.link_broken = True\n        abs_path = config.project.paths.src / name\n        dependency.path = abs_path.relative_to(config.project.paths.root)\n    else:\n        dependency.link_broken = False\n        abs_path = config.project.paths.modules / name\n        dependency.path = abs_path.relative_to(config.project.paths.root)\n\n    try:\n        installed_version = install_dependency(dependency, upgrade, abs_path)\n    except GitCommandError as ex:\n        if \"already exists and is not an empty directory\" in ex.stderr:\n            # FIXME: shouldn't `--upgrade` do this already?\n            raise errors.UserException(\n                f\"Directory {abs_path} already exists and is not empty. \"\n                \"Please move or remove it before installing this new content.\"\n            ) from ex\n        raise\n    # If the link's broken, remove the .git directory so git treats it as copy-pasted code # noqa: E501  # pre-existing\n    if dependency.link_broken:\n        try:\n            robustly_rm_dir(abs_path / \".git\")\n        except (PermissionError, OSError, FileNotFoundError) as ex:\n            with faebryk.libs.exceptions.downgrade(errors.UserException):\n                raise errors.UserException(\n                    f\"Failed to remove .git directory: {repr(ex)}\"\n                ) from ex\n\n    if dependency.version_spec is None and installed_version:\n        # If the user didn't specify a version, we'll\n        # use the one we just installed as a basis\n        dependency.version_spec = f\"@{installed_version}\"\n\n    config.update_project_config(add_dependency, dependency.model_dump())\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.install_project_dependencies","title":"install_project_dependencies","text":"<pre><code>install_project_dependencies(upgrade)\n</code></pre> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def install_project_dependencies(upgrade: bool):\n    for _ctx, dependency in faebryk.libs.exceptions.iter_through_errors(\n        config.project.dependencies or []\n    ):\n        with _ctx():\n            if dependency.source and dependency.source.local:\n                install_local_dependency(dependency)\n                continue\n\n            if not dependency.link_broken:\n                # FIXME: these dependency objects are a little too entangled\n                name = _name_and_clone_url_helper(dependency.name)[0]\n                abs_path = config.project.paths.modules / name\n                dependency.path = abs_path.relative_to(config.project.paths.root)\n\n                try:\n                    install_dependency(dependency, upgrade, abs_path)\n                except GitCommandError as ex:\n                    if \"already exists and is not an empty directory\" in ex.stderr:\n                        # FIXME: shouldn't `--upgrade` do this already?\n                        raise errors.UserException(\n                            f\"Directory {abs_path} already exists and is not empty. \"\n                            \"Please move or remove it before installing this new content.\"  # noqa: E501  # pre-existing\n                        ) from ex\n                    raise\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.install_local_dependency","title":"install_local_dependency","text":"<pre><code>install_local_dependency(dependency)\n</code></pre> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def install_local_dependency(dependency: Dependency):\n    if not dependency.source or not dependency.source.local:\n        raise errors.UserFileNotFoundError(\n            \"Local dependency must have a source with local path\"\n        )\n    src = dependency.source.local\n    dst = dependency.path or config.project.paths.modules / dependency.name\n    if not src.exists():\n        raise errors.UserException(f\"Local dependency path {src} does not exist\")\n    shutil.copytree(src, dst, dirs_exist_ok=True)\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.install_dependency","title":"install_dependency","text":"<pre><code>install_dependency(dependency, upgrade, abs_path)\n</code></pre> <p>Install a dependency of the name \"module_name\"</p> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def install_dependency(\n    dependency: Dependency, upgrade: bool, abs_path: Path\n) -&gt; Optional[str]:\n    \"\"\"\n    Install a dependency of the name \"module_name\"\n    \"\"\"\n    # Ensure the modules path exists\n    abs_path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Figure out what we're trying to install here\n    module_spec = dependency.version_spec or \"*\"\n    module_name, clone_url = _name_and_clone_url_helper(dependency.name)\n\n    try:\n        # This will raise an exception if the directory does not exist\n        repo = Repo(abs_path)\n    except (InvalidGitRepositoryError, NoSuchPathError):\n        # Directory does not contain a valid repo, clone into it\n        logger.info(f\"Installing dependency `{module_name}`\")\n        repo = Repo.clone_from(clone_url, abs_path)\n        tracking = repo.active_branch.tracking_branch()\n        if tracking:\n            tracking.checkout()\n        else:\n            logger.warning(\n                f\"No tracking branch found for {module_name}, using current branch\"\n            )\n    else:\n        # In this case the directory exists and contains a valid repo\n        if upgrade:\n            logger.info(f\"Fetching latest changes for {module_name}\")\n            repo.remotes.origin.fetch()\n        else:\n            logger.info(\n                f\"{module_name} already exists. If you wish to upgrade, use --upgrade\"\n            )\n            # here we're done because we don't want to play with peoples' deps under them # noqa: E501  # pre-existing\n            return\n\n    # Figure out what version of this thing we need\n    semver_to_tag = {}\n    installed_semver = None\n    for tag in repo.tags:\n        try:\n            semver_to_tag[version.parse(tag.name)] = tag\n        except errors.UserException:\n            logger.debug(f\"Tag {tag.name} is not a valid semver tag. Skipping.\")\n\n    if \"@\" in module_spec:\n        # If there's an @ in the version, we're gonna check that thing out\n        best_checkout = module_spec.strip(\" @\")\n    elif semver_to_tag:\n        # Otherwise we're gonna find the best tag meeting the semver spec\n        valid_versions = [v for v in semver_to_tag if version.match(module_spec, v)]\n        if not valid_versions:\n            raise errors.UserException(\n                f\"No versions of {module_name} match spec {module_spec}.\\n\"\n                f\"Available versions: {', '.join(map(str, semver_to_tag))}\"\n            )\n        installed_semver = max(valid_versions)\n        best_checkout = semver_to_tag[installed_semver]\n    else:\n        logger.warning(\n            \"No semver tags found for this module. Using latest default branch :hot_pepper:.\",  # noqa: E501  # pre-existing\n            extra={\"markup\": True},\n        )\n        return None\n\n    # If the repo is dirty, throw an error\n    if repo.is_dirty():\n        raise errors.UserException(\n            f\"Module {module_name} has uncommitted changes. Aborting.\"\n        )\n\n    # Checkout the best thing we've found\n    ref_before_checkout = repo.head.commit\n\n    # If the repo best_checkout is a branch, we need to checkout the origin/branch\n    if best_checkout in repo.heads:\n        best_checkout = f\"origin/{best_checkout}\"\n\n    repo.git.checkout(best_checkout)\n\n    if repo.head.commit == ref_before_checkout:\n        logger.info(\n            f\"Already on the best option ([cyan bold]{best_checkout}[/]) for {module_name}\",  # noqa: E501  # pre-existing\n            extra={\"markup\": True},\n        )\n    else:\n        logger.info(\n            f\"Using :sparkles: [cyan bold]{best_checkout}[/] :sparkles: of {module_name}\",  # noqa: E501  # pre-existing\n            extra={\"markup\": True},\n        )\n\n    return repo.head.commit.hexsha\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.check_missing_deps","title":"check_missing_deps","text":"<pre><code>check_missing_deps()\n</code></pre> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def check_missing_deps() -&gt; bool:\n    for dependency in config.project.dependencies or []:\n        if dependency.path:\n            dep_path = config.project.paths.root / dependency.path\n        else:\n            # FIXME: this should exist based on defaults in the config\n            dep_path = config.project.paths.modules / dependency.name\n\n        if not dep_path.exists():\n            return True\n\n    return False\n</code></pre>"},{"location":"api/cli/#atopile.cli.install.check_missing_deps_or_offer_to_install","title":"check_missing_deps_or_offer_to_install","text":"<pre><code>check_missing_deps_or_offer_to_install()\n</code></pre> Source code in <code>src/atopile/cli/install.py</code> <pre><code>def check_missing_deps_or_offer_to_install():\n    if check_missing_deps():\n        logger.warning(\n            \"It appears some dependencies are missing.\"\n            \" Run `ato install` to install them.\",\n            extra={\"markdown\": True},\n        )\n\n        if (\n            config.interactive\n            and questionary.confirm(\"Install missing dependencies now?\").unsafe_ask()\n        ):\n            # Install project dependencies, without upgrading\n            install_project_dependencies(False)\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging","title":"logging","text":""},{"location":"api/cli/#atopile.cli.logging.LOGS_DIR","title":"LOGS_DIR  <code>module-attribute</code>","text":"<pre><code>LOGS_DIR = absolute()\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.handler","title":"handler  <code>module-attribute</code>","text":"<pre><code>handler = LogHandler(console=error_console)\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler","title":"LogHandler","text":"<pre><code>LogHandler(\n    *args,\n    console,\n    rich_tracebacks=True,\n    show_path=False,\n    tracebacks_suppress=[\"typer\"],\n    tracebacks_suppress_map={\n        UserPythonModuleError: [atopile, faebryk]\n    },\n    tracebacks_unwrap=[UserPythonModuleError],\n    hide_traceback_types=(_BaseBaseUserException,),\n    always_show_traceback_types=(UserPythonModuleError,),\n    traceback_level=ERROR,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>RichHandler</code></p> <p>A logging handler that renders output with Rich.</p> <p>Suppresses frames from tracebacks conditionally depending on the exception type.</p> Source code in <code>src/atopile/cli/logging.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    console: Console,\n    rich_tracebacks: bool = True,\n    show_path: bool = False,\n    tracebacks_suppress: Iterable[str] | None = [\"typer\"],\n    tracebacks_suppress_map: dict[type[BaseException], Iterable[ModuleType]]\n    | None = {UserPythonModuleError: [atopile, faebryk]},\n    tracebacks_unwrap: list[type[BaseException]] | None = [UserPythonModuleError],\n    hide_traceback_types: tuple[type[BaseException], ...] = (\n        _BaseBaseUserException,\n    ),\n    always_show_traceback_types: tuple[type[BaseException], ...] = (\n        UserPythonModuleError,\n    ),\n    traceback_level: int = logging.ERROR,\n    **kwargs,\n):\n    super().__init__(\n        *args,\n        console=console,\n        rich_tracebacks=rich_tracebacks,\n        show_path=show_path,\n        **kwargs,\n    )\n    self.tracebacks_suppress = tracebacks_suppress or []\n    self.tracebacks_suppress_map = tracebacks_suppress_map or {}\n    self.tracebacks_unwrap = tracebacks_unwrap or []\n    self.hide_traceback_types = hide_traceback_types\n    self.always_show_traceback_types = always_show_traceback_types\n    self.traceback_level = traceback_level\n    self._logged_exceptions = set()\n\n    self.addFilter(\n        lambda record: record.name.startswith(\"atopile\")\n        or record.name.startswith(\"faebryk\")\n    )\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.tracebacks_suppress","title":"tracebacks_suppress  <code>instance-attribute</code>","text":"<pre><code>tracebacks_suppress = tracebacks_suppress or []\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.tracebacks_suppress_map","title":"tracebacks_suppress_map  <code>instance-attribute</code>","text":"<pre><code>tracebacks_suppress_map = tracebacks_suppress_map or {}\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.tracebacks_unwrap","title":"tracebacks_unwrap  <code>instance-attribute</code>","text":"<pre><code>tracebacks_unwrap = tracebacks_unwrap or []\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.hide_traceback_types","title":"hide_traceback_types  <code>instance-attribute</code>","text":"<pre><code>hide_traceback_types = hide_traceback_types\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.always_show_traceback_types","title":"always_show_traceback_types  <code>instance-attribute</code>","text":"<pre><code>always_show_traceback_types = always_show_traceback_types\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.traceback_level","title":"traceback_level  <code>instance-attribute</code>","text":"<pre><code>traceback_level = traceback_level\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.render_message","title":"render_message","text":"<pre><code>render_message(record, message)\n</code></pre> Source code in <code>src/atopile/cli/logging.py</code> <pre><code>def render_message(\n    self, record: logging.LogRecord, message: str\n) -&gt; ConsoleRenderable:\n    if record.exc_info is not None and isinstance(\n        (exc := record.exc_info[1]), ConsoleRenderable\n    ):\n        # UserExceptions are already renderables\n        return exc\n\n    return self._render_message(record, message)\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LogHandler.emit","title":"emit","text":"<pre><code>emit(record)\n</code></pre> <p>Invoked by logging.</p> Source code in <code>src/atopile/cli/logging.py</code> <pre><code>def emit(self, record: logging.LogRecord) -&gt; None:\n    \"\"\"Invoked by logging.\"\"\"\n    hashable = self._get_hashable(record)\n    if hashable and hashable in self._logged_exceptions:\n        return None\n\n    log_renderable = self._prepare_emit(record)\n\n    if isinstance(self.console.file, NullFile):\n        # Handles pythonw, where stdout/stderr are null, and we return NullFile\n        # instance from Console.file. In this case, we still want to make a log\n        # record even though we won't be writing anything to a file.\n        self.handleError(record)\n    else:\n        try:\n            self.console.print(log_renderable, highlight=True)\n        except Exception:\n            self.handleError(record)\n        finally:\n            if hashable:\n                self._logged_exceptions.add(hashable)\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LiveLogHandler","title":"LiveLogHandler","text":"<pre><code>LiveLogHandler(status, *args, **kwargs)\n</code></pre> <p>               Bases: <code>LogHandler</code></p> Source code in <code>src/atopile/cli/logging.py</code> <pre><code>def __init__(self, status: \"LoggingStage\", *args, **kwargs):\n    super().__init__(*args, console=status._console, **kwargs)\n    self.status = status\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LiveLogHandler.tracebacks_suppress","title":"tracebacks_suppress  <code>instance-attribute</code>","text":"<pre><code>tracebacks_suppress = tracebacks_suppress or []\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LiveLogHandler.tracebacks_suppress_map","title":"tracebacks_suppress_map  <code>instance-attribute</code>","text":"<pre><code>tracebacks_suppress_map = tracebacks_suppress_map or {}\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LiveLogHandler.tracebacks_unwrap","title":"tracebacks_unwrap  <code>instance-attribute</code>","text":"<pre><code>tracebacks_unwrap = tracebacks_unwrap or []\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LiveLogHandler.hide_traceback_types","title":"hide_traceback_types  <code>instance-attribute</code>","text":"<pre><code>hide_traceback_types = hide_traceback_types\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LiveLogHandler.always_show_traceback_types","title":"always_show_traceback_types  <code>instance-attribute</code>","text":"<pre><code>always_show_traceback_types = always_show_traceback_types\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LiveLogHandler.traceback_level","title":"traceback_level  <code>instance-attribute</code>","text":"<pre><code>traceback_level = traceback_level\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LiveLogHandler.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status = status\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LiveLogHandler.render_message","title":"render_message","text":"<pre><code>render_message(record, message)\n</code></pre> Source code in <code>src/atopile/cli/logging.py</code> <pre><code>def render_message(\n    self, record: logging.LogRecord, message: str\n) -&gt; ConsoleRenderable:\n    if record.exc_info is not None and isinstance(\n        (exc := record.exc_info[1]), ConsoleRenderable\n    ):\n        # UserExceptions are already renderables\n        return exc\n\n    return self._render_message(record, message)\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LiveLogHandler.emit","title":"emit","text":"<pre><code>emit(record)\n</code></pre> Source code in <code>src/atopile/cli/logging.py</code> <pre><code>def emit(self, record: logging.LogRecord) -&gt; None:\n    hashable = self._get_hashable(record)\n    if hashable and hashable in self._logged_exceptions:\n        return\n\n    try:\n        if record.levelno &gt;= logging.ERROR:\n            self.status._error_count += 1\n        elif record.levelno &gt;= logging.WARNING:\n            self.status._warning_count += 1\n\n        self.status._live.update(self.status._render_status(), refresh=True)\n    except Exception:\n        self.handleError(record)\n    finally:\n        if hashable:\n            self._logged_exceptions.add(hashable)\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LoggingStage","title":"LoggingStage","text":"<pre><code>LoggingStage(name, description, indent=20)\n</code></pre> Source code in <code>src/atopile/cli/logging.py</code> <pre><code>def __init__(self, name: str, description: str, indent: int = 20):\n    self.name = name\n    self.description = description\n    self.indent = indent\n    self._console = console.error_console\n    self._spinner = Spinner(\"dots\")\n    self._warning_count = 0\n    self._error_count = 0\n    self._info_log_path = None\n    self._log_handler = None\n    self._file_handlers = []\n    self._original_handlers = {}\n    self._live = Live(\n        self._render_status(),\n        console=self._console,\n        transient=True,\n        auto_refresh=True,\n        refresh_per_second=10,\n    )\n    self._sanitized_name = pathvalidate.sanitize_filename(self.name)\n    self._result = None\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LoggingStage.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LoggingStage.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre>"},{"location":"api/cli/#atopile.cli.logging.LoggingStage.indent","title":"indent  <code>instance-attribute</code>","text":"<pre><code>indent = indent\n</code></pre>"},{"location":"api/cli/#atopile.cli.view","title":"view","text":"<p><code>ato view</code></p>"},{"location":"api/cli/#atopile.cli.view.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger(__name__)\n</code></pre>"},{"location":"api/cli/#atopile.cli.view.view","title":"view","text":"<pre><code>view(entry=None, build=[], target=[], option=[])\n</code></pre> <p>View a block diagram or schematic of your project.</p> Source code in <code>src/atopile/cli/view.py</code> <pre><code>def view(\n    entry: Annotated[str | None, typer.Argument()] = None,\n    build: Annotated[list[str], typer.Option(\"--build\", \"-b\", envvar=\"ATO_BUILD\")] = [],\n    target: Annotated[\n        list[str], typer.Option(\"--target\", \"-t\", envvar=\"ATO_TARGET\")\n    ] = [],\n    option: Annotated[\n        list[str], typer.Option(\"--option\", \"-o\", envvar=\"ATO_OPTION\")\n    ] = [],\n):\n    \"\"\"\n    View a block diagram or schematic of your project.\n    \"\"\"\n    raise errors.UserNotImplementedError(\"View is not yet implemented.\")\n</code></pre>"},{"location":"guides/faebryk/","title":"<code>faebryk</code> &amp; <code>fabll</code> \ud83d\udc0d","text":"<p><code>faebryk</code> is atopile's core. It's how we model the world.</p> <p><code>faebryk</code> is a Python module that uses a powerful and efficient core graph (nodes + edges) to represent every relationship in your design or circuit.</p> <p><code>fabll</code> is a Python framework to model circuits, much like <code>ato</code>. It unlocks a the whole Turing-complete power of Python to do design in + low-level procedural code and logic. Think of it like writing C for a Python module. It's focus is power - not ease of use like <code>ato</code>, so it's not recommended for most designs to start with.</p> <p>Warning</p> <p><code>fabll</code> is currently in a very early stage of development. It's not publicly supported yet.</p>"},{"location":"guides/faebryk/#building-fabll-code","title":"Building <code>fabll</code> code","text":"<p>To build a <code>fabll</code> module with atopile, you just need to point to the module within your <code>ato.yaml</code> configuration file.</p> <p>When you run <code>ato build</code>, atopile will automatically build the <code>fabll</code> module and link it to your project.</p>"},{"location":"guides/faebryk/#importing-fabll-code","title":"Importing <code>fabll</code> code","text":"<p>You can just import <code>fabll</code> modules in <code>ato</code> like any other import:</p> <pre><code>from path/to/some/fabll.py import SomeModule\n</code></pre>"},{"location":"guides/git/","title":"Using <code>git</code> for Hardware","text":"<p><code>git</code> is a powerful way to version control your design and one of the key reason we started atopile. If you don't know about <code>git</code>, we strongly recommend learning it. There is a high chance you will end up loving it.</p>"},{"location":"guides/git/#workflow-overview","title":"Workflow Overview","text":"<p><code>git</code> is the de-facto standard for version control in software development. For people who haven't used it before, it's worth explaining a few terms and the workflow</p> Term Definition Repo or Repository A collection of files and directories that is version controlled together. Branch A \"branch\" is an isolated space for your changes. Commit A \"commit\" is a snapshot of some changes in that place in time. Push A \"push\" is sending your changes to the remote repo. Pull Request A \"pull request\" is a request to merge your changes into the main branch. This is the time to review and test your changes with others on your team. <pre><code>flowchart TD\n    AA[Find a project you want to work on on Github] --&gt; A[**Clone** a copy of the repo to your computer]\n    AB[Create a new project on Github] --&gt; A\n    A --&gt; B[\"Create an isolated space (or **branch**) for your changes\"]\n    B --&gt; C[Do some work \u26cf\ufe0f]\n    C --&gt; D[Check the **status** of your changes]\n    D --&gt; E[**Stage** the changes for one topic]\n    E --&gt; F[**Commit** the changes with a message explaining what you did]\n    F --&gt;|More work to do on this topic| D\n    F --&gt;|Ready for review| H[**Push** your branch to the **remote** repo on Github]\n    H --&gt; I[Create **Pull Request** on GitHub]\n    I --&gt; II[\"Continuous Integration (**CI**) runs tests and ensures your project still builds after your updates\"]\n    II --&gt;|Tests pass| J[**Review** all the changes]\n    II --&gt;|Tests fail| D\n    J --&gt;|Changes requested in review| D\n    J --&gt;|Approved| K[**Merge** to main]\n    K --&gt; L[Your changes are now combined with the work of everyone else on the project]</code></pre>"},{"location":"guides/git/#basic-usage","title":"Basic Usage","text":"<pre><code>git clone &lt;repo-url&gt;\ngit checkout -b &lt;new-branch-name&gt;\ngit add &lt;file-to-commit&gt;\ngit commit -m \"This commits adds an LED indicator...\"\ngit push -u origin HEAD\n</code></pre>"},{"location":"guides/git/#more-resources","title":"More resources","text":"<ul> <li>https://github.com/git-guides</li> <li>https://git-scm.com/docs/gittutorial</li> </ul>"},{"location":"guides/installation/","title":"Alternative Installation","text":"<p>Warning</p> <p>Check out the quickstart guide for a step-by-step guide for the recommended way to install atopile. This page provides alternative installation methods.</p> <p>Ultimately <code>atopile</code> is a python package, so you can install it where and however you want - but some python package managers are better than others. Here's how we recommend you install atopile.</p>"},{"location":"guides/installation/#editable-installation-best-for-development","title":"Editable installation (Best for development)","text":"<ol> <li> <p>Install <code>uv</code>     See: https://docs.astral.sh/uv/getting-started/installation/</p> </li> <li> <p>Clone the repo</p> <pre><code>git clone https://github.com/atopile/atopile\n</code></pre> </li> <li> <p><code>cd</code> into the repo</p> <pre><code>cd atopile\n</code></pre> </li> <li> <p>Install</p> <pre><code>uv sync --dev\n</code></pre> </li> </ol>"},{"location":"guides/installation/#via-brew","title":"Via <code>brew</code>","text":"<p>We would recommend this, however it's not yet quite ready</p> <pre><code>brew install atopile/tap/atopile\n</code></pre>"},{"location":"reference/attributes/","title":"Attributes in <code>ato</code>","text":"<p>This page lists all the attributes available in <code>ato</code> which effect the compiler.</p>"},{"location":"reference/attributes/#global-attributes","title":"Global Attributes","text":""},{"location":"reference/attributes/#atopile.attributes.GlobalAttributes","title":"atopile.attributes.GlobalAttributes","text":"<p>               Bases: <code>Module</code></p> <p>These attributes are available to all modules and interfaces in a design.</p>"},{"location":"reference/attributes/#atopile.attributes.GlobalAttributes.lcsc_id","title":"lcsc_id  <code>property</code> <code>writable</code>","text":"<pre><code>lcsc_id\n</code></pre> <p>Assign the LCSC ID of the module.</p> <p>If set, this will tell the picker to select that part from LCSC for this block.</p>"},{"location":"reference/attributes/#atopile.attributes.GlobalAttributes.manufacturer","title":"manufacturer  <code>property</code> <code>writable</code>","text":"<pre><code>manufacturer\n</code></pre> <p>This module's manufacturer name, as a string.</p> <p>Only exact matches on the manufacturer's name will be found by the picker. It's recommended to fill this information based on what <code>ato create component</code> provides.</p>"},{"location":"reference/attributes/#atopile.attributes.GlobalAttributes.mpn","title":"mpn  <code>property</code> <code>writable</code>","text":"<pre><code>mpn\n</code></pre> <p>This module's manufacturer part number, as a string.</p> <p>For the picker to select the correct part from the manufacturer, this must be set.</p>"},{"location":"reference/attributes/#atopile.attributes.GlobalAttributes.designator_prefix","title":"designator_prefix  <code>property</code> <code>writable</code>","text":"<pre><code>designator_prefix\n</code></pre> <p>The prefix used for automatically-generated designators on this module.</p>"},{"location":"reference/attributes/#atopile.attributes.GlobalAttributes.package","title":"package  <code>property</code> <code>writable</code>","text":"<pre><code>package\n</code></pre> <p>The package of the module.</p> <p>This drives which components can be selected, and what footprint is used.</p> <p>Must exactly match a known package name.</p>"},{"location":"reference/attributes/#atopile.attributes.GlobalAttributes.footprint","title":"footprint  <code>property</code> <code>writable</code>","text":"<pre><code>footprint\n</code></pre> <p>Explicitly set the footprint to be used for this module.</p> <p>Setting this will cause this component to be selected and placed on the PCB.</p> <p>The footprint should be a string, naming the KiCAD ID of the footprint.</p>"},{"location":"reference/attributes/#atopile.attributes.GlobalAttributes.exclude_from_bom","title":"exclude_from_bom  <code>property</code> <code>writable</code>","text":"<pre><code>exclude_from_bom\n</code></pre>"},{"location":"reference/attributes/#atopile.attributes.GlobalAttributes.override_net_name","title":"override_net_name  <code>property</code> <code>writable</code>","text":"<pre><code>override_net_name\n</code></pre> <p>When set on an interface, this will override the net name of the interface.</p> <p>This is useful for renaming nets which are automatically generated.</p>"},{"location":"reference/attributes/#atopile.attributes.GlobalAttributes.suggest_net_name","title":"suggest_net_name  <code>property</code> <code>writable</code>","text":"<pre><code>suggest_net_name\n</code></pre> <p>Suggested net name which will have a higher priority than generated net names.</p>"},{"location":"reference/attributes/#components","title":"Components","text":""},{"location":"reference/attributes/#atopile.attributes.Resistor","title":"atopile.attributes.Resistor","text":"<p>               Bases: <code>Resistor</code></p> <p>This resistor is replaces <code>generics/resistors.ato:Resistor</code> every times it's referenced.</p>"},{"location":"reference/attributes/#atopile.attributes.Resistor.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value\n</code></pre> <p>Represents the resistance of the resistor.</p>"},{"location":"reference/attributes/#atopile.attributes.Resistor.footprint","title":"footprint  <code>property</code> <code>writable</code>","text":"<pre><code>footprint\n</code></pre> <p>See <code>GlobalAttributes.footprint</code></p>"},{"location":"reference/attributes/#atopile.attributes.Resistor.package","title":"package  <code>property</code> <code>writable</code>","text":"<pre><code>package\n</code></pre> <p>See <code>GlobalAttributes.package</code></p>"},{"location":"reference/attributes/#atopile.attributes.Resistor.has_ato_cmp_attrs_","title":"has_ato_cmp_attrs_","text":"<pre><code>has_ato_cmp_attrs_()\n</code></pre> <p>Ignore this field.</p> Source code in <code>src/atopile/attributes.py</code> <pre><code>@L.rt_field\ndef has_ato_cmp_attrs_(self) -&gt; _has_ato_cmp_attrs:\n    \"\"\"Ignore this field.\"\"\"\n    trait = _has_ato_cmp_attrs()\n    trait.pinmap[\"1\"] = self.p1\n    trait.pinmap[\"2\"] = self.p2\n    return trait\n</code></pre>"},{"location":"reference/attributes/#atopile.attributes.CommonCapacitor","title":"atopile.attributes.CommonCapacitor","text":"<p>               Bases: <code>Capacitor</code></p> <p>These attributes are common to both electrolytic and non-electrolytic capacitors.</p>"},{"location":"reference/attributes/#atopile.attributes.CommonCapacitor.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value\n</code></pre> <p>Represents the capacitance of the capacitor.</p>"},{"location":"reference/attributes/#atopile.attributes.CommonCapacitor.package","title":"package  <code>property</code> <code>writable</code>","text":"<pre><code>package\n</code></pre> <p>See <code>GlobalAttributes.package</code></p>"},{"location":"reference/attributes/#atopile.attributes.CommonCapacitor.footprint","title":"footprint  <code>property</code> <code>writable</code>","text":"<pre><code>footprint\n</code></pre> <p>See <code>GlobalAttributes.footprint</code></p>"},{"location":"reference/attributes/#atopile.attributes.Capacitor","title":"atopile.attributes.Capacitor","text":"<p>               Bases: <code>CommonCapacitor</code></p> <p>This capacitor is replaces <code>generics/capacitors.ato:Capacitor</code> every times it's referenced.</p>"},{"location":"reference/attributes/#atopile.attributes.Capacitor.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value\n</code></pre> <p>Represents the capacitance of the capacitor.</p>"},{"location":"reference/attributes/#atopile.attributes.Capacitor.package","title":"package  <code>property</code> <code>writable</code>","text":"<pre><code>package\n</code></pre> <p>See <code>GlobalAttributes.package</code></p>"},{"location":"reference/attributes/#atopile.attributes.Capacitor.footprint","title":"footprint  <code>property</code> <code>writable</code>","text":"<pre><code>footprint\n</code></pre> <p>See <code>GlobalAttributes.footprint</code></p>"},{"location":"reference/attributes/#atopile.attributes.Capacitor.has_ato_cmp_attrs_","title":"has_ato_cmp_attrs_","text":"<pre><code>has_ato_cmp_attrs_()\n</code></pre> <p>Ignore this field.</p> Source code in <code>src/atopile/attributes.py</code> <pre><code>@L.rt_field\ndef has_ato_cmp_attrs_(self) -&gt; _has_ato_cmp_attrs:\n    \"\"\"Ignore this field.\"\"\"\n    trait = _has_ato_cmp_attrs()\n    trait.pinmap[\"1\"] = self.p1\n    trait.pinmap[\"2\"] = self.p2\n    return trait\n</code></pre>"},{"location":"reference/attributes/#atopile.attributes.Inductor","title":"atopile.attributes.Inductor","text":"<p>               Bases: <code>Inductor</code></p> <p>This inductor is replaces <code>generics/inductors.ato:Inductor</code> every times it's referenced.</p>"},{"location":"reference/attributes/#atopile.attributes.Inductor.package","title":"package  <code>property</code> <code>writable</code>","text":"<pre><code>package\n</code></pre> <p>See <code>GlobalAttributes.package</code></p>"},{"location":"reference/attributes/#atopile.attributes.Inductor.has_ato_cmp_attrs_","title":"has_ato_cmp_attrs_","text":"<pre><code>has_ato_cmp_attrs_()\n</code></pre> <p>Ignore this field.</p> Source code in <code>src/atopile/attributes.py</code> <pre><code>@L.rt_field\ndef has_ato_cmp_attrs_(self) -&gt; _has_ato_cmp_attrs:\n    \"\"\"Ignore this field.\"\"\"\n    trait = _has_ato_cmp_attrs()\n    trait.pinmap[\"1\"] = self.p1\n    trait.pinmap[\"2\"] = self.p2\n    return trait\n</code></pre>"},{"location":"reference/attributes/#atopile.attributes.LED","title":"atopile.attributes.LED","text":"<p>               Bases: <code>LED</code></p> <p>Temporary shim to translate LEDs.</p>"},{"location":"reference/attributes/#atopile.attributes.LED.v_f","title":"v_f  <code>property</code>","text":"<pre><code>v_f\n</code></pre>"},{"location":"reference/attributes/#atopile.attributes.LED.i_max","title":"i_max  <code>property</code>","text":"<pre><code>i_max\n</code></pre>"},{"location":"reference/attributes/#interfaces","title":"Interfaces","text":""},{"location":"reference/attributes/#atopile.attributes.Power","title":"atopile.attributes.Power","text":"<p>               Bases: <code>ElectricPower</code></p> <p>Temporary shim to translate <code>value</code> to <code>power</code>.</p>"},{"location":"reference/attributes/#atopile.attributes.Power.current","title":"current  <code>property</code>","text":"<pre><code>current\n</code></pre> <p>Maximum current the power interface can provide.</p> <p>Negative is current draw.</p>"},{"location":"reference/config/","title":"<code>ato.yaml</code> Config Reference","text":""},{"location":"reference/config/#ato-version","title":"<code>ato-version</code>","text":"<p>The compiler version with which the project was developed.</p> <p>This is used by the compiler to ensure the code in this project is compatible with the compiler version.</p> <p>Default value: current compiler version</p> <p>Type: <code>str</code></p> <p>Example usage:</p> ato.yaml<pre><code>ato-version: 0.3.0\n</code></pre>"},{"location":"reference/config/#paths.src","title":"<code>paths.src</code>","text":"<p>Project source code directory</p> <p>Default value: <code>elec/src</code></p> <p>Type: <code>str</code></p> <p>Example usage:</p> ato.yaml<pre><code>paths:\n  src: \"./\"\n</code></pre>"},{"location":"reference/config/#paths.layout","title":"<code>paths.layout</code>","text":"<p>Project layout directory where KiCAD projects are stored and searched for</p> <p>Default value: <code>elec/layout</code></p> <p>Type: <code>str</code></p> <p>Example usage:</p> ato.yaml<pre><code>paths:\n  layout: \"./\"\n</code></pre>"},{"location":"reference/config/#dependencies","title":"<code>dependencies</code>","text":"<p>Default value: <code>[]</code> or no dependencies</p> <p>Type:</p> Field Type Description Default <code>name</code> <code>str</code> The name of the dependency No default and required <code>version_spec</code> <code>str</code> The version specifier for the dependency Latest tagged version or commit on <code>main</code> <code>link_broken</code> <code>bool</code> Whether the link to the upstream version is maintained / broken <code>false</code> <code>path</code> <code>str</code> The path to the dependency within this project <code>.ato/modules/&lt;name&gt;</code> <p>Example usage:</p> ato.yaml<pre><code>dependencies:\n  - name: rp2040\n    version_spec: \"&gt;=3.0.0,&lt;4.0.0\"\n</code></pre>"},{"location":"reference/config/#builds","title":"<code>builds</code>","text":"<p>Default value: <code>{}</code> or no build targets</p> <p>Type: <code>dict</code> (see \"builds.name\" etc... below for details)</p>"},{"location":"reference/config/#builds.entry","title":"<code>builds.entry</code>","text":"<p>Entry point or root node for the build-target. Everything that exists within this module will be built as part of this build-target</p> <p>Default value: Required, no default</p> <p>Type: <code>str</code></p> <p>Example usage:</p> ato.yaml<pre><code>builds:\n    default:\n        entry: some_file.ato:App\n</code></pre>"},{"location":"reference/config/#builds.targets","title":"<code>builds.targets</code>","text":"<p>A list of targets' names to build after updating the layout</p> <p>Default value: <code>[\"__default__\"]</code>, which is a special value.</p> <p>Type: <code>list[str]</code></p> <p>Example usage:</p> ato.yaml<pre><code>builds:\n    default:\n        targets:\n          - bom\n          - mfg-data\n</code></pre>"},{"location":"reference/config/#builds.exclude_targets","title":"<code>builds.exclude_targets</code>","text":"<p>A list of targets' names to exclude.</p> <p>Applied after <code>targets</code> are specified. This makes it useful to exclude targets that aren't relevant to a specific build - especially in CI, which typically builds all targets.</p> <p>Excluding the <code>mfg-data</code> target is useful, for example, for CI build targets that represent a  module, but not a board you'd manufacture.</p> <p>Default value: <code>[]</code>, don't actively exclude any targets</p> <p>Type: <code>list[str]</code></p> <p>Example usage:</p> ato.yaml<pre><code>builds:\n    default:\n        exclude_targets:\n          - bom\n          - mfg-data\n</code></pre>"},{"location":"tutorial/1-the-ato-language/","title":"1. Basics of the <code>ato</code> language","text":"<p><code>ato</code> is a domain specific language (DSL) for describing electronic circuit boards.</p> <p>It's heavily inspired by, and attempts to largely follow the syntax of Python \ud83d\udc0d for consistency and familiarity.</p>"},{"location":"tutorial/1-the-ato-language/#basic-types","title":"Basic types","text":"<p>The most basic types in <code>ato</code> are a <code>module</code> and an <code>interface</code>.</p> <p>A <code>signal</code> is a special built-in type of <code>interface</code> that represents a single electrical interface.</p> <p>A <code>component</code> is a subclass of a <code>module</code> that expects to represent a single physical component.</p> <p>You can also define you own types, in a similar way to define a <code>class</code> in Python. Like classes in most modern languages, we can subclass and inherit from blocks.</p> <pre><code>module SomeModule:\n    signal some_signal\n    signal gnd\n    some_variable = \"some value\"\n\nmodule SubclassedModule from SomeModule:\n    # inherits all the signals and variables from SomeModule\n    # we don't need to declare the signals again,\n    # but we will replace the value of some_variable\n    some_variable = \"some other value\"\n\nmodule Test:\n    signal gnd\n    # creates an instance of the SubclassedModule\n    subclased_module = new SubclassedModule\n    # connects the some_signal of the SubclassedModule to the gnd of Test\n    subclased_module.gnd ~ gnd\n</code></pre> <p>Info</p> <p>You can subclass a <code>module</code> as a <code>component</code>, but not the other way around. A component is expected to represent a specific component.</p>"},{"location":"tutorial/1-the-ato-language/#configuring-blocks","title":"Configuring blocks","text":"<p>Configuration of a <code>module</code> or <code>interface</code> is done by assigning to it's attributes.</p> <pre><code>some_instance.value = 100ohm +/- 10%\n</code></pre> <p>Unlike Python, you don't need to state <code>self.</code> and instead any assignments you make within the scope of a block, are automatically assigned to the block.</p> <p>There are a number of built-in attributes that influence the behaviour of the compiler with respect to the block.</p> <p>Setting the <code>package</code> attribute, for example, will make the compiler select only components with the specified package to be used in that component's slot.</p>"},{"location":"tutorial/1-the-ato-language/#connecting-it-up","title":"Connecting it up","text":"<p>Any <code>interface</code> can be connected to any other interface of the same type using the <code>~</code> operator.</p> <pre><code>some_signal ~ another\n</code></pre>"},{"location":"tutorial/1-the-ato-language/#units-and-tolerances-assertions-and-maths","title":"Units and tolerances, assertions and maths","text":"<p>Remember how NASA slung a rocket straight into Mars because of a metric/imperial boo boo?</p> <p>How about we don't do that again.</p>"},{"location":"tutorial/1-the-ato-language/#units","title":"Units","text":"<p>Resistors's resistances must be a resistance; whether <code>1.23\u03a9</code> (option+Z on OSx), <code>1.23ohm</code>, <code>4.56Kohm</code>, <code>7.89Mohm</code> or similar.</p> <p>Any attribute of any block may have a unit attached written (without a space) after any number.</p> <p>Unsurprisingly, caps capacitances need to be a capacitance; eg. <code>23.4uF</code>, various limits in volts, amperes, degrees and so on.</p> <p>Add units.</p>"},{"location":"tutorial/1-the-ato-language/#tolerances","title":"Tolerances","text":"<p>Another unfamiliar first-class language feature when dealing with the physical world is the ability (and generally requirement) to spec tolerances for attributes.</p> <p>You could try find a <code>10k\u03a9</code> resistor, but my money says you won't - it'll likely be at least <code>10k\u03a9 +/- 0.1%</code> (which you can write!)</p> <p>Tolerances can be written in the forms of: - <code>1V to 2V</code> - <code>3uF +/- 1uF</code> - <code>4Kohm +/- 1%</code></p> <p>These are hopefully sufficiently intuitive as to not warrant further explanation \ud83e\udd1e</p>"},{"location":"tutorial/1-the-ato-language/#units-and-tolerances","title":"Units and Tolerances","text":"<p>With Units and Tolerances together, we can define physical attributes.</p> <p>There's quite a few legal ways to combine them!</p> <ul> <li><code>3V to 3.6V</code> perhaps for a supply rail</li> <li><code>3V +/- 10mV</code> maybe for a reference</li> <li><code>4.7uF +/- 20%</code> for a generic cap</li> <li>even <code>25lb +/- 200g</code> \ud83e\udd23</li> </ul>"},{"location":"tutorial/1-the-ato-language/#sweet-so-now-ive-got-all-these-values-around-the-place-what-can-i-do-with-them","title":"Sweet, so now I've got all these values around the place... what can I do with them?","text":"<p> Maths </p> <p>There are two things that atopile can do for you with these values: 1. Check that assertions about their relationships to one another are true 2. Solve systems of constraints based on these relationships for find component values</p> <p>This maths is all done including the units and tolerances, so you can be sure absolutely sure everything always works.</p> <p>Use the <code>assert</code> keyword to apply constraints on the values of attributes to one another.</p> <p>Supported operators are currently <code>&lt;</code>, <code>&gt;</code> and <code>within</code> (all are inclusive of the bounds).</p> <pre><code>a = 1 \u00b1 0.1\nb = 2 \u00b1 0.2\nc: resistance  # variable declaration without assignment\n\nassert a &lt; b  # always true before 0.9 and 1.1 (the bounds of a) are both lower than the bounds of b (1.8 and 2.2)\nassert a &gt; b  # always false --&gt; Will yield a failure at compile time\nassert c within 1Kohm to 10Kohm  # first solved for, then the solution is independently checked at the end of the build\n</code></pre> <p>I'm not sure about you, but I (Matt) am pretty dumb and don't love working too hard. Perhaps you've got a better method, but generally when I'm trying to find resistor values for something even as simple as a voltage divider, I guess one that seems approximately right, then calculate the other - giving me something that doesn't exist, before finally checking through a few other options close-by until finding a pair that works.</p> <p>This is fine and dandy as long as you only care about the ratio of a voltage divider, but as soon as you need to check what that does for your regulators output voltage? Ergh, fine! What about the extremes of the tolerances on those resistors? Fine I'll do it once - but I swear if someone goes to tweak those values for whatever reason, I am unlikely to be pleased.</p> <p>So, let's get atopile to do it for us!</p> <p>atopile will automatically solve systems of constraints for you with free variables, and check that the values of attributes are within their tolerances.</p>"},{"location":"tutorial/1-the-ato-language/#specialization","title":"Specialization","text":"<p>The <code>-&gt;</code> operator will specialize a module from it's existing instance, to an instance of the type on the right hand side.</p> <pre><code>some_instance -&gt; AnotherModuleType\n</code></pre> <p>This is useful for configuring a previously specified topology.</p>"},{"location":"tutorial/1-the-ato-language/#imports","title":"Imports","text":"<p>You can import assets by specifying what you want to import and where you want to import it from using the following syntax within your <code>.ato</code> files:</p> <p><code>from \"where.ato\" import What, Why, Wow</code></p> <p>Notes on that statement: - add quotes on the \"where.ato\" - it's a string - <code>What</code>, <code>Why</code> and <code>Wow</code> are capitalised because they are in the source file. It has to match precisely - it's a type and types should be capitalised, though this isn't enforced and you can import things other than types from other files</p> <p>The import statements are with respect to the current project (the root of which is where your <code>ato.yaml</code> is placed), or within the standard library (<code>.ato/modules/</code>)</p> <p>Warning</p> <p>You'll likely see import statements in the form of <code>import XYZ from \"abc.ato\"</code>. This is a legacy syntax and will be removed in the future. Please use the new syntax.</p> <p>It also doesn't support importing multiple things on the same line.</p>"},{"location":"tutorial/2-the-ato-compiler/","title":"2. The <code>ato</code> compiler","text":"<p>The <code>ato</code> command line interface is the main way to interact with atopile.</p> <p>The CLI has tools to:</p> <ul> <li>Build your code to update your PCB</li> <li>Test your design</li> <li>Generate files to order your PCBs from manufacturers</li> <li>Install and manage dependencies</li> <li>Create new projects, components or build-targets</li> </ul> <p>There's a semi-defacto-standard format to running applications from the terminal, including <code>ato</code>.</p> <pre><code>application command [options] arguments\n</code></pre> <ol> <li><code>application</code> is the name of the application you're running.</li> <li><code>command</code> is the command, think of it as a \"menu option\" the application provides.</li> <li><code>options</code> are the options for the command, typically zero-to-many of <code>--some-option option-value</code></li> <li><code>arguments</code> are just like options, but they only take a value. Their position tells the application which argument they are.</li> </ol> <p>Add <code>--help</code> to the application/command/subcommand to get more information at any point.</p> <p>Tip</p> <p>Some things might have multiple commands/subcommands. Think of it like a menu where, from left to right you're choosing deeper and deeper into the menu.</p> <p>If an upper command/application accepts options, those options should go right after the application/command, rather than at the end after subcommands.</p> <p>For example, <code>-v</code> is a special type of option, called a \"flag\", which doesn't take a value. It's presence or absence is what matters. It increases the amount of information the compiler will print -&gt; increase it's verbosity.</p> <p>The <code>-v</code> flag is an application option, so to use it, place it right after the application name.</p> <pre><code>ato -v build\n</code></pre>"},{"location":"tutorial/2-the-ato-compiler/#build-process","title":"Build Process","text":"<p>As a rough overview, here's what happens when you run <code>ato build</code>:</p> <pre><code>graph TD\n    A[Run &lt;tt&gt;ato build&lt;/tt&gt;] --&gt; B[Compiler looks for your &lt;tt&gt;ato.yaml&lt;/tt&gt;]\n    B --&gt; C[\"Compile the code, starting from the 'entry point'\"]\n    code1[&lt;tt&gt;src/&lt;/tt&gt;] --&gt;|some_code.ato| C\n    code3[Dependencies] --&gt;|dependency_code.ato| C\n    C --&gt;|App - the model of your design| D[Solve equations]\n    D --&gt; E[Pick components]\n    cloud[atopile server recommends components] --&gt; E\n    E --&gt; D\n    E --&gt;|Picked all components| F[Run tests]\n    F --&gt; G[Update PCB File]\n    G --&gt; H[Generate Manufacturing Data]\n    G --&gt; I[Generate Reports]\n    G --&gt; J[Generate ... Target]</code></pre>"},{"location":"tutorial/2-the-ato-compiler/#explaining-the-hello-world-project","title":"Explaining the hello-world project","text":"<p>Important</p> <p>This tutorial continues from the quickstart guide.</p> <p>If you haven't already, complete it, and then come back here.</p> <p>With the additional explanation of <code>ato</code> code and the build process, it should be a little more clear what's happening now in the quickstart project.</p> <pre><code>import Resistor\n\nmodule App:\n    r1 = new Resistor                # Create a new resistor\n    r1.resistance = 100ohm +/- 10%   # Set the resistor value\n</code></pre> <p>Let's break it down:</p>"},{"location":"tutorial/2-the-ato-compiler/#1-import-a-resistor","title":"1. Import a <code>Resistor</code>","text":"<pre><code>import Resistor\n</code></pre>"},{"location":"tutorial/2-the-ato-compiler/#2-define-a-new-module-named-app","title":"2. Define a new <code>module</code>, named <code>App</code>","text":"<p>This is the entry point of the build (see your <code>ato.yaml</code>).</p> <pre><code>module App:\n</code></pre>"},{"location":"tutorial/2-the-ato-compiler/#3-create-an-instance-of-the-resistor","title":"3. Create an instance of the <code>Resistor</code>","text":"<pre><code>    r1 = new Resistor                # Create a new resistor\n</code></pre>"},{"location":"tutorial/2-the-ato-compiler/#4-set-the-resistors-value-attribute","title":"4. Set the resistor's <code>value</code> attribute","text":"<p>This constrains what components can be picked for this resistor.</p> <p>For picking, the rated resistance must be wholely within the <code>value</code> attribute. The precise way to say this in more CS terms / what atopile says internally is that the picked resistor's resistance must be a subset of the quantity interval defined by the value attribute.</p> <pre><code>    r1.resistance = 100ohm +/- 10%   # Set the resistor value\n</code></pre>"},{"location":"tutorial/2-the-ato-compiler/#extending-it","title":"Extending it","text":"<p>Let's say our circuit needs a simple voltage divider - and the standard library doesn't exist containing one pre-made and tested for you.</p> <p>We can easily create our own!</p> <pre><code>import Resistor\n\n\nmodule VoltageDivider:\n    r_top = new Resistor\n    r_bottom = new Resistor\n\n    r_top.p2 ~ r_bottom.p1\n\n\nmodule App:\n    my_vdiv = new VoltageDivider\n    my_vdiv.r_top.resistance = 10kohm +/- 10%\n    my_vdiv.r_bottom.resistance = 4.7kohm +/- 10%\n</code></pre> <p>Now, this is, technically, a voltage divider. And the compiler will happily build it grabbing the right components etc...</p> <p>But, it's not a good voltage divider.</p> <ul> <li>There's no clear interface showing how it should be connected to</li> <li>The point of a voltage divider is to scale voltage, but we're left in the dark about what it's scaling actually is</li> <li>There is no documentation on what's going on</li> </ul> <p>Let's fix that.</p> <pre><code>import ElectricPower, Resistor\n\n\nmodule VoltageDivider:\n    \"\"\"\n    A simple voltage divider\n\n    Connect to the in and out interfaces\n    Configure via:\n    - r_top.voltage\n    - r_bottom.voltage\n    - max_i_q\n    \"\"\"\n\n    in = new ElectricPower\n    out = new ElectricPower\n    max_i_q: current\n\n    r_top = new Resistor\n    r_bottom = new Resistor\n\n    in.vcc ~ r_top.p1; r_top.p2 ~ out.vcc; out.vcc ~ r_bottom.p1; r_bottom.p2 ~ in.gnd\n    in.gnd ~ out.gnd\n\n    assert out.voltage within in.voltage * r_bottom.resistance / (r_top.resistance + r_bottom.resistance)\n    assert in.voltage &gt;= out.voltage\n    assert in.max_current * r_bottom.resistance / (r_top.resistance + r_bottom.resistance) within max_i_q\n\n\nmodule App:\n    my_vdiv = new VoltageDivider\n    my_vdiv.in.voltage = 10V +/- 10%\n    my_vdiv.out.voltage = 3.3V +/- 10%\n    my_vdiv.max_i_q = 10uA to 100uA\n</code></pre> <p>Ooooo yeah! Now we're talking.</p> <p>Let's break it down.</p>"},{"location":"tutorial/2-the-ato-compiler/#more-imports","title":"More imports","text":"<p>When possible, import from the standard library.</p> <pre><code>import ElectricPower, Resistor\n</code></pre>"},{"location":"tutorial/2-the-ato-compiler/#define-a-new-module-named-voltagedivider","title":"Define a new <code>module</code>, named <code>VoltageDivider</code>","text":"<p>This means we trivially have as many <code>VoltageDivider</code>'s as we want, all configured properly with all the same interfaces.</p> <pre><code>module VoltageDivider:\n</code></pre>"},{"location":"tutorial/2-the-ato-compiler/#document-with","title":"Document with <code>\"\"\"</code>","text":"<pre><code>    \"\"\"\n    A simple voltage divider\n\n    Connect to the in and out interfaces\n    Configure via:\n    - r_top.voltage\n    - r_bottom.voltage\n    - max_i_q\n    \"\"\"\n</code></pre>"},{"location":"tutorial/2-the-ato-compiler/#place-external-interfaces-somewhere-obvious","title":"Place external interfaces somewhere obvious","text":"<p>... and use sensible types, like <code>Power</code> to expose them.</p> <pre><code>    in = new ElectricPower\n    out = new ElectricPower\n    max_i_q: current\n</code></pre>"},{"location":"tutorial/2-the-ato-compiler/#embed-the-relationships-between-parameters-with-assert","title":"Embed the relationships between parameters with <code>assert</code>","text":"<p>Read these statements as \"make sure the following is true\".</p> <pre><code>    assert out.voltage within in.voltage * r_bottom.resistance / (r_top.resistance + r_bottom.resistance)\n    assert in.voltage &gt;= out.voltage\n    assert in.max_current * r_bottom.resistance / (r_top.resistance + r_bottom.resistance) within max_i_q\n</code></pre> <ol> <li>The output voltage will be within the range of the voltage divider ratio equation</li> <li>The input voltage must be greater than the output voltage</li> <li>The current through the bottom resistor must be within the allowed range of the maximum quiescent current</li> </ol>"},{"location":"tutorial/3-ato-create-component/","title":"3. <code>ato create component</code>","text":"<p>This embedded tool will help template <code>ato</code> code based on a component. Today, it supports JLCPCB components.</p> <p>It can run as both an interactive tool, or with command line arguments. Go ahead and run it interactively.</p> <pre><code>ato create component\n</code></pre> <p>You'll be prompted for a search term of a component. This may be:</p> <ul> <li>A JLCPCB part number (e.g. <code>C7426</code>)</li> <li>An exact manufacturer part number (e.g. <code>NE5532DR</code>)</li> </ul> <p>Enter <code>C7426</code> and press enter.</p> <p></p> <p>Go ahead and tap <code>Enter</code> through the default options.</p>"},{"location":"tutorial/3-ato-create-component/#our-new-component","title":"Our new <code>component</code>","text":"<pre><code>component Texas_Instruments_NE5532DR:\n    \"\"\"Texas_Instruments_NE5532DR component\"\"\"\n    lcsc_id = \"C7426\"\n    manufacturer = \"Texas Instruments\"\n    mpn = \"NE5532DR\"\n    datasheet_url = \"https://www.lcsc.com/datasheet/lcsc_datasheet_1809301912_Texas-Instruments-NE5532DR_C7426.pdf\"\n    designator_prefix = \"U\"\n\n    # pins\n    signal IN1_ ~ pin 2\n    signal IN1plus ~ pin 3\n    signal IN2_ ~ pin 6\n    signal IN2plus ~ pin 5\n    signal OUT1 ~ pin 1\n    signal OUT2 ~ pin 7\n    signal VCC__GND ~ pin 4\n    signal VCCplus ~ pin 8\n</code></pre> <p>Let's break it down.</p> <p>The <code>component</code> keyword tells the compiler that we're specifying a new component class, which is a subclass of <code>module</code>.</p> <p>The <code>lcsc_id</code> attribute tells the compiler it can pick that JLCPCB part to fill this spot. The <code>manufacturer</code> and <code>mpn</code> attributes together tell fully specify which component this is as well. If you're making a component class of a specific component, it's typically a good idea to include at least either the <code>lcsc_id</code> or the <code>mpn</code> + <code>manufacturer</code>.</p> <p>The <code>datasheet_url</code> and <code>designator_prefix</code> attributes are optional, but it's a good idea to include them. They're self-explanatory.</p>"},{"location":"tutorial/3-ato-create-component/#pin","title":"<code>pin</code>","text":"<p>The <code>pin</code> keyword is used to define electrical interfaces, which the compiler will map to pads on the footprint.</p> <p>That is, <code>pin 2</code> says:</p> <ul> <li>Create a signal named <code>2</code> (pins are treated as a special-case where they're may have an integer name)</li> <li>Connect the signal to pad \"2\" on the footprint</li> </ul>"},{"location":"tutorial/3-ato-create-component/#good-practice","title":"Good practice","text":"<p>Here are a few tweaks we recommend making to your component class:</p>"},{"location":"tutorial/3-ato-create-component/#abstract-classes","title":"Abstract classes","text":"<p>When you're creating a class representing a specific component, for which there's a generic abstract class (eg. An <code>LDO</code>), import and subclass that abstract class to get it's generic methods and attributes.</p> <p>For example, you should update the component class like this:</p> <pre><code>component Texas_Instruments_NE5532DR from LDO:\n</code></pre> <p>Then, connect its pins to the LDO's signals, set known attributes etc...</p>"},{"location":"tutorial/3-ato-create-component/#take-the-mpn-and-manufacturer-from-ato-create-component","title":"Take the <code>mpn</code> and <code>manufacturer</code> from <code>ato create component</code>","text":"<p><code>mpn</code> and <code>manufacturer</code> are only interpreted properly if they exactly match a component in our database.</p>"},{"location":"tutorial/4-packages/","title":"4. Packages","text":"<p>One of the huge benefits to designing circuit boards with code is that it unlocks modularity. As in software, this modularity means you can package up and reuse modules other's have developed and tested.</p>"},{"location":"tutorial/4-packages/#finding-packages","title":"Finding packages","text":"<p>Check first-party packages for a list of designed and used internally at atopile. Discussion planning to open this up publicaly: see #495 These have all been built, are known to work and come with a functioning layout too.</p> <p>Alternatively, Google is your friend! Packages are often publicly available on github or other repositories.</p>"},{"location":"tutorial/4-packages/#installing-packages","title":"Installing packages","text":"<p>Use <code>ato install</code> to install packages.</p> <p>For example, this command will install the package named <code>esp32-s3</code> from atopile's internal package repository.</p> <pre><code>ato install esp32-s3\n</code></pre> <p>You can also directly specify a git repo URL to install from:</p> <pre><code>ato install https://github.com/atopile/rp2040\n</code></pre> <p>This will install the <code>rp2040</code> package from the given repo.</p>"},{"location":"tutorial/4-packages/#versioning","title":"Versioning","text":"<p><code>ato</code> uses version numbers in the format <code>x.y.z</code>, and we recommend using semantic versioning.</p> <p>Properly-specified dependency versions mean that you will get upgrades automatically. That said, if you're too loose with your version requirements, you may end up with a lot of upgrades that break things.</p> <p>By default, <code>ato install</code> is very tight with version requirements, and, without other directives, will add a specific githash as your dependency's version requirement. This means you will always get that exact version of the package when installed on new computers or in CI, but that's often too tight.</p> <p><code>ato</code> also supports the following version operators:</p> Operator Description <code>*</code> Any version <code>^</code> Any version with the same major version <code>~</code> Any version with the same major and minor version <code>!</code> Not this version <code>==</code> Exactly this version <code>&gt;=</code> Any version greater than or equal to <code>&lt;</code> Any version less than <p>Version requirements are \"AND\"ed together when separated by a comma, and can be \"OR\"ed together when separated by a <code>||</code>.</p> <p>Versions may, but don't need to have a <code>v</code> prefix.</p> <p>That means, if you want version <code>1.2.3</code> or anything within <code>1.3</code>, you can specify <code>1.2.3 || ~1.3.0</code>.</p> <p>The most common operator is <code>^</code>, which means \"any version with the same major version\", which when coupled with semantic versioning means \"any version that does at least as much as the version you're specifying without breaking things\".</p> <p>That means you might often use a command like <code>ato install \"some_package^1.2.3\"</code> to add that package to your project.</p> <p>Versions are pulled from <code>git</code> tags.</p> <p>You can use version requirements to specify which version of a package should be installed.</p> <p>Additionally, <code>git</code> refs are supported when prefixed with an <code>@</code>. For example <code>ato install some-package@main</code> will always get the <code>main</code> branch of the <code>some-package</code> package. Very unstable!</p>"},{"location":"tutorial/4-packages/#linked-vs-vendored","title":"Linked vs. Vendored","text":"<p>By default, packages are installed in the directory <code>.ato/modules</code>, which isn't version controlled. Other people installing your project will need to run <code>ato install</code> to install the same packages on their computer. This is how packages typically work in software, and usually works well (as long as you're using good versioning), however, if you plan on making changes to a package that don't make sense to commit back to the upstream repo, you may want to vendor the package instead.</p> <pre><code>ato install --vendor esp32-s3\n</code></pre> <p>This will copy the package into your project's <code>src</code> directory instead, and break the link to the upstream repo.</p>"},{"location":"tutorial/4-packages/#importing-things","title":"<code>import</code>ing things","text":"<p>There are two forms of an <code>import</code> statement in <code>ato</code>:</p> <p>For standard library imports, you can use the <code>import</code> statement:</p> <pre><code>import Something\n</code></pre> <p>For imports from other files, you can use the <code>from ... import ...</code> statement:</p> <pre><code>from \"path/to/file.ato\" import Something, SomethingElse\nfrom \"path/to/another/file.py\" import SomethingMore  # for fabll modules\n</code></pre> <p>The search path for <code>from ... import ...</code> is (in order):</p> <ol> <li>The current file's directory</li> <li>The project's <code>src</code> directory, as defined by the <code>ato.yaml</code> config file</li> <li>The <code>.ato/modules</code> directory within the project's root</li> </ol>"},{"location":"tutorial/4-packages/#sharing-packages-youve-built","title":"Sharing packages you've built","text":"<p>To the package manager: coming soon!  #495</p> <p>For now, publish a public repo with a README.md that describes the package and how to use it. We'd love you to share on discord too!</p>"},{"location":"tutorial/5-layout/","title":"5. Layout","text":"<p><code>ato</code> code defines the function of the circuit via how everything is connected up. Unlike a software compiler, these components all need to end up placed somewhere and copper traces need to be routed between the elements for the circuit to function.</p> <p>This process is typically called \"layout\".</p> <p>atopile uses KiCAD, the premier open-source electronics design package for layout.</p>"},{"location":"tutorial/5-layout/#opening-kicad","title":"Opening KiCAD","text":"<p>When you run <code>ato build</code>, <code>ato</code> will generate a KiCAD project file for you.</p> <p>The easiest way to open this is to add the <code>--open</code> flag to the <code>build</code> command:</p> <pre><code>ato build --open\n</code></pre> <p>This will open the KiCAD project file in a new window.</p>"},{"location":"tutorial/5-layout/#kicad-plugin","title":"KiCAD plugin","text":"<p>The <code>ato</code> compiler automatically installs a KiCAD plugin to help you with layout. This saves insane amounts of time, so we definitely recommend using it!</p> <p>The plugin is installed automatically when you run the <code>ato</code> CLI, but in case something went wrong, you can re-trigger the installation by running <code>ato configure</code>.</p>"},{"location":"tutorial/5-layout/#start-with-existing-modules","title":"Start with existing modules","text":"<p>If you import the rp2040 module we installed in the previous chapter, you can reuse its layout.</p> <pre><code>from \"rp2040/RP2040Kit.ato\" import RP2040Kit\n\nmodule App:\n    uc = new RP2040Kit\n    # Note: I've emptied this module out for brevity.\n    # You can decide whether you want to keep the demo voltage divider or not.\n</code></pre> <p>To reuse a layout from a module:</p> <ul> <li>run an <code>ato build</code>, to make sure the layout is synced with the code</li> <li>hit the \"Sync Group\" button in the KiCAD plugin</li> <li>select the group you want to sync, and hit the \"Pull\" (Down arrow) button to pull the layout from the module's KiCAD layout file</li> </ul> <p>Under the hood </p> <p>The <code>ato</code> compiler will map layouts with a class or super-class that has a build.</p> <p>The <code>RP2040Kit</code> in the example is the class, and the <code>ato.yaml</code> config file in the <code>rp2040</code> package means that there's a layout associated with it.</p> <p>If you want to create a reusable layout for a class of your own, the easiest way is to add a new build config with <code>ato create build</code>, and then point the newly created entry at the module you've made.</p>"},{"location":"tutorial/5-layout/#layout-the-remainder-of-your-design","title":"Layout the remainder of your design","text":"<p>Use KiCAD to place-and-route the remainder of your design, just like if you got it from the schematic editor.</p> <p>If you can't find the quality of KiCAD docs you need to get started, drop a comment or upvote on this Github Issue #882</p>"},{"location":"tutorial/5-layout/#auto-layout-881","title":"Auto-layout  #881","text":"<p>atopile can do small bits of auto-layout for you, however it's not completely exposed to <code>ato</code> yet.</p> <p>If this is a feature that'd super-charge your workflow, please come vote and discuss it in the Github Discussion #881</p>"},{"location":"tutorial/6-saving-your-work/","title":"6. Saving Your Work","text":"<p>atopile strongly recommends using <code>git</code> for version control.</p> <p>If you're not yet familiar with <code>git</code>, check out our short <code>git</code> guide for a general overview on the workflow.</p>"},{"location":"tutorial/6-saving-your-work/#committing","title":"Committing","text":"<ol> <li>Survey what you've done: <code>git status</code></li> <li> <p>Add the files you want to associate with this commit <code>git add &lt;file&gt;</code></p> <p>Adding files</p> <p>You can add multiple files at once by running <code>git add &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;</code></p> <p>You can also add all files in a directory by running <code>git add &lt;directory&gt;</code></p> <p>This includes the current directory, if you use <code>git add .</code> - but careful! This is often a trap and you end up adding a lot of unrelated files. At the start of a project it often makes sense though.</p> </li> <li> <p>Sanity check: <code>git status</code>. It'll tell you all the files you've got staged (ready to commit)</p> </li> <li> <p>Commit your changes: <code>git commit -m \"Add the RP2040 module\"</code>. Commit messages should describe the changes you've made and why.</p> </li> <li> <p>Push your changes up to Github: <code>git push</code></p> <p>Pull Request</p> <p>If you're on a branch other than <code>main</code>, the response from Github gives you a link to the pull request.</p> <p>Cmd+Click on Mac, Ctrl+Click on Windows to open the link in your browser.</p> </li> </ol>"},{"location":"tutorial/6-saving-your-work/#up-on-github","title":"Up on Github","text":"<p>There are a few paths to contribute back to a repository.</p> <p>If you have permissions to push directly to the repo, by far the easiest way to update it is to contribute directly.</p> <p>As your project progresses and stabalises, you typically want to create a new branch and pull-request (PR) for each change you're making, even if you're working alone.</p>"},{"location":"tutorial/6-saving-your-work/#directly-to-main","title":"Directly to <code>main</code>","text":"<p>If you're right at the start of your project, you might want to push straight to <code>main</code>. This is fast and dirty. All you need to do is:</p> <ol> <li>Commit your changes: <code>git commit -m \"Add the RP2040 module\"</code></li> <li>Push your changes up to Github: <code>git push</code></li> </ol> <p>They'll be up on <code>main</code></p>"},{"location":"tutorial/6-saving-your-work/#create-a-branch-and-pull-request","title":"Create a Branch and Pull Request","text":"<p>For a more controlled development process, especially as your project grows, it's best practice to work on feature branches and create pull requests. Here are some recommendations:</p> <ul> <li>Use descriptive branch names, like <code>feature/add-bluetooth-support</code> or <code>bugfix/fix-routing-error</code>.</li> <li>Keep your commits focused and well-documented. Write clear commit messages that explain the \"why\" behind a change, not just the \"what\".</li> <li>When you open a pull request, include a detailed description of the change, the rationale behind it, and steps for testing.</li> <li>If your repository is configured with <code>Continuous Integration</code>, ensure that all tests pass before merging your PR.</li> <li>Request code reviews from your team. Peer reviews help catch potential issues early and improve code quality.</li> </ul>"},{"location":"tutorial/6-saving-your-work/#continuous-integration-ci","title":"Continuous Integration (CI)","text":"<p>atopile's project template include basic CI workflows to validate your design, build manufacturing data you can order with and run testing.</p> <p>It builds in CI as a <code>frozen</code> project, meaning it'll try its hardest to rebuild your design exactly as it stands, with the exact same parts and layout. When it can't - whether because your source code has changes and the components no longer satisfy the design, or because the layout is out of date - it'll fail the build.</p> <p>Additionally, CI is run to build all targets, which means it will also produce the gerber files to order your PCBs.</p> <p>Git and CI Best Practice</p> <p>Consistent use of pull requests and CI pipelines not only improves code quality but also fosters better team collaboration. Keep your <code>main</code> branch in a deployable state by merging only after successful CI runs.</p>"}]}