// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"2TPoR":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "79a37d00f147e69c";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ‚ú® Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          üö® ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>üìù <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"9Ve7W":[function(require,module,exports) {
// TODO: the root cell ID has a colon in it, which there shouldn't be
//import { settings_dict } from "./vis_settings";
var _jointjs = require("jointjs");
// Visual settings for the viewer
let settings_dict = {
    common: {
        backgroundColor: "rgba(224, 233, 227, 0.3)",
        gridSize: 5,
        parentPadding: 50,
        fontFamily: "monospace",
        fontHeightToPxRatio: 1.6,
        fontLengthToPxRatio: 0.7
    },
    component: {
        strokeWidth: 2,
        fontSize: 8,
        fontWeight: "bold",
        defaultWidth: 60,
        portPitch: 20,
        defaultHeight: 50,
        labelHorizontalMargin: 30,
        labelVerticalMargin: 4,
        titleMargin: 10,
        pin: {
            fontSize: 8,
            fontWeight: "normal"
        }
    },
    block: {
        strokeWidth: 2,
        boxRadius: 5,
        strokeDasharray: "4,4",
        label: {
            fontSize: 10,
            fontWeight: "bold"
        }
    },
    link: {
        strokeWidth: 1,
        color: "blue"
    },
    stubs: {
        fontSize: 8
    }
};
function customAnchor(view, magnet, ref, opt, endType, linkView) {
    const elBBox = view.model.getBBox();
    const magnetCenter = view.getNodeBBox(magnet).center();
    const side = elBBox.sideNearestToPoint(magnetCenter);
    let dx = 0;
    let dy = 0;
    const length = "length" in opt ? opt.length : 30;
    switch(side){
        case "left":
            dx = -length;
            break;
        case "right":
            dx = length;
            break;
        case "top":
            dy = -length;
            break;
        case "bottom":
            dy = length;
            break;
    }
    return (0, _jointjs.anchors).center.call(this, view, magnet, ref, {
        ...opt,
        dx,
        dy
    }, endType, linkView);
}
// Base class for the visual elements
class AtoElement extends (0, _jointjs.dia).Element {
    defaults() {
        return {
            ...super.defaults,
            instance_name: null,
            config_origin_filename: null,
            config_origin_module: []
        };
    }
    // TODO: need to change to add port and add pins in port
    addPortWithPins(port_group_name, port_location, pin_list) {
        let port_label_position = getPortLabelPosition(port_location);
        let port_anchor = getPortLabelAnchor(port_location);
        let port_angle = getPortLabelAngle(port_location);
        let port_position = getPortPosition(port_location);
        let port_group = {};
        port_group[port_group_name] = {
            position: port_position,
            attrs: {
                portBody: {
                    magnet: true,
                    r: 2,
                    fill: "#FFFFFF",
                    stroke: "#023047"
                }
            },
            label: {
                position: {
                    args: {
                        x: port_label_position[0],
                        y: port_label_position[1],
                        angle: port_angle
                    }
                },
                markup: [
                    {
                        tagName: "text",
                        selector: "label",
                        className: "label-text"
                    }
                ]
            },
            markup: [
                {
                    tagName: "circle",
                    selector: "portBody"
                }
            ]
        };
        // Add the ports list to the element
        this.prop({
            "ports": {
                "groups": port_group
            }
        });
        // While we are creating the port, add the pins in the element
        for (let pin of pin_list)this.addPort(createPort(pin["path"], pin["name"], port_group_name, port_anchor, true));
    }
    resizeBasedOnContent() {
        let ports = this.getPorts();
        if (ports) {
            let port_buckets = {
                "top": this.getGroupPorts("top"),
                "bottom": this.getGroupPorts("bottom"),
                "left": this.getGroupPorts("left"),
                "right": this.getGroupPorts("right")
            };
            let ports_text_length = {
                "top": "",
                "bottom": "",
                "left": "",
                "right": ""
            };
            let dim_from_text = {
                "height": 0,
                "width": 0
            };
            let dim_from_ports = {
                "height": 0,
                "width": 0
            };
            // Extract the longest port label from each bucket
            for(let port_bucket in port_buckets)if (port_buckets[port_bucket].length) {
                for (let port of port_buckets[port_bucket])if (port["attrs"]["label"]["text"].length > ports_text_length[port_bucket].length) ports_text_length[port_bucket] = port["attrs"]["label"]["text"];
            }
            dim_from_text["height"] = 2 * Math.max(measureText(ports_text_length["top"], settings_dict["component"]["fontSize"], "length"), measureText(ports_text_length["bottom"], settings_dict["component"]["fontSize"], "length"));
            dim_from_text["height"] += measureText(this["attributes"]["attrs"]["label"]["text"], settings_dict["component"]["fontSize"], "height");
            dim_from_text["height"] += settings_dict["component"]["labelVerticalMargin"] * 2;
            dim_from_text["width"] = 2 * Math.max(measureText(ports_text_length["right"], settings_dict["component"]["fontSize"], "length"), measureText(ports_text_length["left"], settings_dict["component"]["fontSize"], "length"));
            dim_from_text["width"] += measureText(this["attributes"]["attrs"]["label"]["text"], settings_dict["component"]["fontSize"], "length");
            dim_from_ports["height"] = (Math.max(port_buckets["right"].length, port_buckets["left"].length) + 1) * settings_dict["component"]["portPitch"];
            dim_from_ports["width"] = (Math.max(port_buckets["top"].length, port_buckets["bottom"].length) - 1) * settings_dict["component"]["portPitch"];
            dim_from_ports["width"] += 2 * settings_dict["component"]["labelHorizontalMargin"];
            // Feature does not work without moveable ports
            // if (port_buckets['right'].length != 0 || port_buckets['left'].length != 0) {
            //     if (port_buckets['top'].length != 0 || port_buckets['bottom'].length != 0) {
            //         dim_from_ports['width'] += 2 * settings_dict['component']['labelHorizontalMargin'];
            //     }
            // }
            this.resize(Math.max(dim_from_text["width"], dim_from_ports["width"]), Math.max(dim_from_text["height"], dim_from_ports["height"]));
        }
    }
    fitAncestorElements() {
        var padding = settings_dict["common"]["parentPadding"];
        this.fitParent({
            deep: true,
            padding: {
                top: padding,
                left: padding,
                right: padding,
                bottom: padding
            }
        });
    }
    applyParentAttrs(attrs) {
        if ("position" in attrs) // Deep setting ensures that the element is placed relative to all parents
        this.position(attrs["position"]["x"], attrs["position"]["y"], {
            deep: true
        });
    }
}
// Class for a component
class AtoComponent extends AtoElement {
    defaults() {
        return {
            ...super.defaults(),
            type: "AtoComponent",
            attrs: {
                body: {
                    fill: "white",
                    z: 10,
                    stroke: "black",
                    strokeWidth: settings_dict["component"]["strokeWidth"],
                    width: "calc(w)",
                    height: "calc(h)",
                    rx: 5,
                    ry: 5
                },
                label: {
                    text: "Component",
                    fill: "black",
                    fontSize: settings_dict["component"]["fontSize"],
                    fontWeight: settings_dict["component"]["fontWeight"],
                    textVerticalAnchor: "middle",
                    textAnchor: "middle",
                    fontFamily: settings_dict["common"]["fontFamily"],
                    x: "calc(w/2)",
                    y: "calc(h/2)"
                }
            }
        };
    }
    preinitialize() {
        this.markup = (0, _jointjs.util).svg`
            <rect @selector="body" />
            <text @selector="label" />
        `;
    }
}
// Class for a block
// For the moment, blocks and components are separate.
// We might want to combine them in the future.
class AtoBlock extends AtoElement {
    defaults() {
        return {
            ...super.defaults(),
            type: "AtoComponent",
            collapsed: false,
            attrs: {
                body: {
                    fill: "transparent",
                    stroke: "#333",
                    strokeWidth: settings_dict["block"]["strokeWidth"],
                    strokeDasharray: settings_dict["block"]["strokeDasharray"],
                    width: "calc(w)",
                    height: "calc(h)",
                    rx: settings_dict["block"]["boxRadius"],
                    ry: settings_dict["block"]["boxRadius"]
                },
                label: {
                    text: "Block",
                    fill: "black",
                    textVerticalAnchor: "top",
                    fontSize: settings_dict["block"]["label"]["fontSize"],
                    fontWeight: settings_dict["block"]["label"]["fontWeight"],
                    textAnchor: "start",
                    fontFamily: settings_dict["common"]["fontFamily"],
                    x: 8,
                    y: 8
                }
            }
        };
    }
    preinitialize() {
        this.markup = (0, _jointjs.util).svg`
            <rect @selector="body" />
            <text @selector="label" />
        `;
    }
    updateChildrenVisibility() {
        const collapsed = this.isCollapsed();
        this.getEmbeddedCells().forEach((child)=>child.set("hidden", collapsed));
    }
}
const cellNamespace = {
    ...(0, _jointjs.shapes),
    AtoElement,
    AtoComponent,
    AtoBlock
};
function createPort(uuid, port_name, port_group_name, port_anchor) {
    return {
        id: uuid,
        group: port_group_name,
        attrs: {
            label: {
                text: port_name,
                fontFamily: settings_dict["common"]["fontFamily"],
                fontSize: settings_dict["component"]["pin"]["fontSize"],
                fontWeight: settings_dict["component"]["pin"]["fontWeight"],
                textAnchor: port_anchor
            }
        }
    };
}
function getPortLabelPosition(location) {
    switch(location){
        case "top":
            return [
                0,
                5
            ];
        case "bottom":
            return [
                0,
                -5
            ];
        case "left":
            return [
                5,
                0
            ];
        case "right":
            return [
                -5,
                0
            ];
        default:
            return [
                0,
                0
            ];
    }
}
function getPortLabelAnchor(location) {
    switch(location){
        case "top":
            return "end";
        case "bottom":
            return "start";
        case "left":
            return "start";
        case "right":
            return "end";
        default:
            return "middle";
    }
}
function getPortLabelAngle(location) {
    switch(location){
        case "top":
            return -90;
        case "bottom":
            return -90;
        case "left":
            return 0;
        case "right":
            return 0;
        default:
            return 0;
    }
}
function getPortPosition(location) {
    switch(location){
        case "top":
            return {
                name: "line",
                args: {
                    start: {
                        x: settings_dict["component"]["labelHorizontalMargin"],
                        y: 0
                    },
                    end: {
                        x: "calc(w - " + settings_dict["component"]["labelHorizontalMargin"] + ")",
                        y: 0
                    }
                }
            };
        case "bottom":
            return {
                name: "line",
                args: {
                    start: {
                        x: settings_dict["component"]["labelHorizontalMargin"],
                        y: "calc(h)"
                    },
                    end: {
                        x: "calc(w - " + settings_dict["component"]["labelHorizontalMargin"] + ")",
                        y: "calc(h)"
                    }
                }
            };
        case "left":
            return {
                name: "line",
                args: {
                    start: {
                        x: 0,
                        y: settings_dict["component"]["labelVerticalMargin"]
                    },
                    end: {
                        x: 0,
                        y: "calc(h - " + settings_dict["component"]["labelVerticalMargin"] + ")"
                    }
                }
            };
        case "right":
            return {
                name: "line",
                args: {
                    start: {
                        x: "calc(w)",
                        y: settings_dict["component"]["labelVerticalMargin"]
                    },
                    end: {
                        x: "calc(w)",
                        y: "calc(h - " + settings_dict["component"]["labelVerticalMargin"] + ")"
                    }
                }
            };
        default:
            return 0;
    }
}
// Definitely need to update this garbage at some point
function measureText(text, text_size, direction) {
    var string = text + "";
    var lines = string.split("\n");
    var width = 0;
    for (let line of lines){
        var length = line.length;
        if (length > width) width = length;
    }
    if (direction == "length") // divide by 3 to go from font size to pxl, will have to fix
    return width * text_size * settings_dict["common"]["fontLengthToPxRatio"];
    else if (direction == "height") return lines.length * text_size * settings_dict["common"]["fontHeightToPxRatio"];
    else return 0;
}
function addStub(block_id, port_id, label) {
    let added_stub = new (0, _jointjs.shapes).standard.Link({
        source: {
            id: block_id,
            port: port_id,
            anchor: {
                name: "center"
            }
        },
        target: {
            id: block_id,
            port: port_id,
            anchor: {
                name: "customAnchor"
            },
            connectionPoint: {
                name: "anchor"
            }
        }
    });
    added_stub.attr({
        line: {
            "stroke": settings_dict["link"]["color"],
            "stroke-width": settings_dict["link"]["strokeWidth"],
            targetMarker: {
                "type": "none"
            }
        },
        z: 0
    });
    added_stub.appendLabel({
        attrs: {
            text: {
                text: label,
                fontFamily: settings_dict["common"]["fontFamily"],
                fontSize: settings_dict["stubs"]["fontSize"],
                //textVerticalAnchor: "middle",
                textAnchor: "middle"
            }
        },
        position: {
            distance: .9,
            offset: -5,
            angle: 0,
            args: {
                keepGradient: true,
                ensureLegibility: true
            }
        }
    });
    graph.addCell(added_stub);
}
function addLink(source_block_id, source_port_id, target_block_id, target_port_id) {
    var added_link = new (0, _jointjs.shapes).standard.Link({
        source: {
            id: source_block_id,
            port: source_port_id
        },
        target: {
            id: target_block_id,
            port: target_port_id
        }
    });
    added_link.attr({
        line: {
            "stroke": settings_dict["link"]["color"],
            "stroke-width": settings_dict["link"]["strokeWidth"],
            targetMarker: {
                "type": "none"
            }
        },
        z: 0
    });
    added_link.router("manhattan", {
        perpendicular: true,
        step: settings_dict["common"]["gridSize"]
    });
    added_link.addTo(graph);
}
// Return the cell id and port id from port name and current path
// If the link spans deeper than one module, a port is added to the module
// TODO: what happens if the port is multiple layers deep?
// TODO: Currently only adding the top link
function getLinkAddress(port, current_path, embedded_cells) {
    let port_path = concatenatePathAndName(current_path, port);
    let port_name_depth = computeNameDepth(port);
    let cell_id;
    let first_element;
    switch(port_name_depth){
        case 1:
            cell_id = current_path;
            break;
        case 2:
            first_element = popFirstNameElementFromName(port);
            cell_id = concatenatePathAndName(current_path, first_element["pop"]);
            break;
        default:
            console.log("default");
            first_element = popFirstNameElementFromName(port);
            cell_id = concatenatePathAndName(current_path, first_element["pop"]);
            for (let cell of embedded_cells)if (cell["id"] == cell_id) cell.addPortWithPins("top", "top", [
                {
                    "path": port_path,
                    "name": first_element["remaining"]
                }
            ]);
            break;
    }
    console.log({
        "cell_id": cell_id,
        "port_id": port_path
    });
    return {
        "cell_id": cell_id,
        "port_id": port_path
    };
}
function addLinks(element, current_path, embedded_cells) {
    for (let link of element["links"]){
        let source_address = getLinkAddress(link["source"], current_path, embedded_cells);
        let target_address = getLinkAddress(link["target"], current_path, embedded_cells);
        let is_stub = false;
        for (let link_config of (element.config || {}).signals || [])if (link_config["name"] == link["name"] && link_config["is_stub"]) {
            is_stub = true;
            // if not a module (don't want stubs at module level)
            if (current_path.length != source_address["cell_id"].length) addStub(source_address["cell_id"], source_address["port_id"], link["name"]);
            // if not a module (don;t want stubs at module level)
            if (current_path.length != target_address["cell_id"].length) addStub(target_address["cell_id"], target_address["port_id"], link["name"]);
        }
        if (!is_stub) addLink(source_address["cell_id"], source_address["port_id"], target_address["cell_id"], target_address["port_id"]);
    }
}
function getElementTitle(element) {
    if (element["instance_of"] != null) return `${element["name"]} \n(${popLastPathElementFromPath(element["instance_of"]).name})`;
    else return element["name"];
}
function addPins(jointJSObject, element, path) {
    // Create the default port location
    let ports_to_add = {};
    // Create the ports that are defined in the config
    for (let port of (element.config || {}).ports || [])ports_to_add[port.name || "top"] = {
        "location": port.location || "top",
        "pins": []
    };
    let config_found;
    for (let pin_to_add of element["pins"]){
        pin_to_add["path"] = concatenatePathAndName(path, pin_to_add["name"]);
        config_found = false;
        for (let config_pin of (element.config || {}).pins || [])// If a port is defined, add it to it designated port
        if (pin_to_add["name"] == config_pin["name"]) {
            ports_to_add[config_pin["port"]]["pins"].push(pin_to_add);
            config_found = true;
        }
        // If no port is defined, add it to the default port
        if (!config_found) {
            if (!ports_to_add["top"]) ports_to_add["top"] = {
                "location": "top",
                "pins": []
            };
            ports_to_add["top"]["pins"].push(pin_to_add);
        }
    }
    for(let port in ports_to_add)if (ports_to_add[port]["pins"].length > 0) jointJSObject.addPortWithPins(port, ports_to_add[port]["location"], ports_to_add[port]["pins"]);
}
function createComponent(element, parent, path) {
    let title = getElementTitle(element);
    let comp_width = measureText(title, settings_dict["component"]["pin"]["fontSize"], "length") + 2 * settings_dict["component"]["titleMargin"];
    let comp_height = measureText(title, settings_dict["component"]["pin"]["fontSize"], "height") + 2 * settings_dict["component"]["titleMargin"];
    var component = new AtoComponent({
        id: path,
        instance_name: element["name"],
        size: {
            width: comp_width,
            height: comp_height
        },
        attrs: {
            label: {
                text: title
            }
        },
        config_origin_filename: element.config_origin_filename,
        config_origin_module: element.config_origin_module
    });
    addPins(component, element, path);
    component.resizeBasedOnContent();
    component.addTo(graph);
    if (parent) addElementToElement(component, parent);
    return component;
}
function createBlock(element, parent, path) {
    let title = getElementTitle(element);
    let block = new AtoBlock({
        id: path,
        instance_name: element["name"],
        size: {
            width: 200,
            height: 100
        },
        attrs: {
            label: {
                text: title
            }
        },
        config_origin_filename: element.config_origin_filename,
        config_origin_module: element.config_origin_module
    });
    addPins(block, element, path);
    block.addTo(graph);
    if (parent) addElementToElement(block, parent);
    return block;
}
function addElementToElement(block_to_add, to_block) {
    to_block.embed(block_to_add);
}
function returnConfigFileName(string) {
    if (string) {
        const [file, module] = string.split(":");
        return {
            "file": file,
            "module": module
        };
    } else return null;
}
function concatenatePathAndName(path, name) {
    if (path == null) return name + ":";
    else if (path.slice(-1) == ":") return path + name;
    else return path + "." + name;
}
// This function does not support complete paths
// Only names that are separated by a .
function computeNameDepth(path) {
    let name_list = path.split(".");
    return name_list.length;
}
function popFirstNameElementFromName(name) {
    // Split the blocks
    const blocks = name.split(".");
    const remaining_blocks = blocks.slice(1, blocks.length);
    const remaining_name = remaining_blocks.join(".");
    const pop = blocks[0];
    return {
        "pop": pop,
        "remaining": remaining_name
    };
}
function popLastPathElementFromPath(path) {
    // Split the file name and the blocks
    const file_block = path.split(":");
    const file = file_block[0];
    // Split the blocks
    const blocks = file_block[1].split(".");
    const path_blocks = blocks.slice(0, blocks.length - 1);
    const remaining_path = file + ":" + path_blocks.join(".");
    const name = blocks[blocks.length - 1];
    return {
        "file": file,
        "path": remaining_path,
        "name": name
    };
}
function applyParentConfig(element, child_attrs) {
    if (child_attrs !== null && Object.keys(child_attrs).length > 0) {
        for(let attrs in child_attrs)if (attrs == element["name"]) element["jointObject"].applyParentAttrs(child_attrs[attrs]);
    }
}
async function generateJointjsGraph(circuit, max_depth, current_depth = 0, path = null, parent = null, child_attrs = null) {
    let downstream_path;
    let new_depth = current_depth + 1;
    if (current_depth <= max_depth) {
        for (let element of circuit){
            var joint_object = null;
            if (element["type"] == "component") {
                downstream_path = concatenatePathAndName(path, element["name"]);
                joint_object = createComponent(element, parent, downstream_path);
                element["jointObject"] = joint_object;
                if (parent) addElementToElement(joint_object, parent);
                applyParentConfig(element, child_attrs);
            } else if (element["type"] == "module") {
                downstream_path = concatenatePathAndName(path, element["name"]);
                // Create the module
                joint_object = createBlock(element, parent, downstream_path);
                element["jointObject"] = joint_object;
                if (parent) addElementToElement(joint_object, parent);
                // Call the function recursively on children
                if (await generateJointjsGraph(element["blocks"], max_depth, new_depth, downstream_path, joint_object, element["config"]["child_attrs"])) {
                    addLinks(element, downstream_path, joint_object.getEmbeddedCells());
                    applyParentConfig(element, child_attrs);
                }
                // FIXME:
                // Position the root element in the middle of the screen
                if (current_depth == 0) {
                    let paperSize = paper.getComputedSize();
                    let rootSize = joint_object.size();
                    // Calculate the position for the center of the paper.
                    let posX = paperSize.width / 2 - rootSize.width / 2;
                    let posY = paperSize.height / 2 - rootSize.height / 2;
                    // Position the rectangle in the center of the paper.
                    joint_object.position(posX, posY);
                // TODO: bring the other content with it
                }
            } else if (element["type"] == "file") {
                downstream_path = concatenatePathAndName(path, element["name"]);
                await generateJointjsGraph(element["blocks"], max_depth, new_depth, downstream_path);
            } else // raise an error because we don't know what to do with this element
            // TODO: raise an error
            console.log("Unknown element type: " + element["type"]);
        }
        return true;
    } else return false;
}
async function populateConfigFromBackend(circuit_dict, file_name = null) {
    let populated_circuit = [];
    let config_location_name;
    for (let element of circuit_dict){
        if (element.type == "component") {
            if (element.instance_of !== null) {
                config_location_name = returnConfigFileName(element.instance_of);
                element.config_origin_filename = getConfigFilenameFromAto(config_location_name.file);
                element.config_origin_module = config_location_name.module;
                const config = await loadFileConfig(config_location_name.file);
                element["config"] = config[config_location_name.module] || {};
            }
        } else if (element.type == "module") {
            let config = null;
            element.config = {};
            if (element.instance_of !== null) {
                config_location_name = returnConfigFileName(element.instance_of);
                element.config_origin_filename = getConfigFilenameFromAto(config_location_name.file);
                element.config_origin_module = config_location_name.module;
                config = await loadFileConfig(config_location_name.file);
            }
            if (config) {
                if (Object.keys(config).length !== 0) {
                    if (config.hasOwnProperty(config_location_name["module"])) element["config"] = config[config_location_name["module"]];
                }
            }
            element["blocks"] = await populateConfigFromBackend(element["blocks"]);
        } else if (element["type"] == "file") // If file, the following block will not be an instance, so it needs to know it's parent file
        // to fetch the config
        element["blocks"] = await populateConfigFromBackend(element["blocks"], element["name"]);
        else console.log("unknown block type");
        populated_circuit.push(element);
    }
    return populated_circuit;
}
const graph = new (0, _jointjs.dia).Graph({}, {
    cellNamespace
});
const paper = new (0, _jointjs.dia).Paper({
    el: document.getElementById("atopilePaper"),
    model: graph,
    width: "100%",
    height: "100%",
    gridSize: settings_dict["common"]["gridSize"],
    drawGrid: true,
    background: {
        color: settings_dict["common"]["backgroundColor"]
    },
    interactive: true,
    snapLinks: true,
    linkPinning: false,
    magnetThreshold: "onleave",
    cellViewNamespace: cellNamespace,
    anchorNamespace: {
        ...(0, _jointjs.anchors),
        customAnchor
    }
});
function fill_paper() {
    paper.setDimensions(window.innerWidth, window.innerHeight);
}
window.onload = fill_paper;
window.onresize = fill_paper;
let pin_to_element_association = {};
paper.on("link:mouseenter", function(linkView) {
    linkView.showTools();
    linkView.highlight();
});
paper.on("link:mouseleave", function(linkView) {
    linkView.hideTools();
    linkView.unhighlight();
});
graph.on("change:position", function(cell) {
    // `fitParent()` method is defined at `joint.shapes.container.Base` in `./joint.shapes.container.js`
    cell.fitAncestorElements();
});
function getConfigFilenameFromAto(ato_file_name) {
    // Strip .ato from the name
    let striped_file_name = ato_file_name.replace(".ato", "");
    return striped_file_name + ".vis.json";
}
// Fetch a file visual config from the server
async function loadFileConfig(file_name) {
    let address = "/api/config/" + getConfigFilenameFromAto(file_name);
    //address = "/api/circuit/bike_light.ato:BikeLight";
    let response;
    try {
        response = await fetch(address);
    } catch (error) {
        console.log("Could not fetch config ", error);
    }
    if (response.ok) return await response.json();
    else {
        console.log(`HTTP Response Code: ${response?.status}`);
        return null;
    }
}
// Fetch a circuit dict from the server
async function loadCircuit() {
    const urlParams = new URLSearchParams(window.location.search);
    const response = await fetch("/api/circuit/" + urlParams.get("circuit"));
    const circuit_data = await response.json();
    console.log("data received from backend");
    console.log(circuit_data);
    let config_populated_circuit = await populateConfigFromBackend([
        circuit_data
    ]);
    console.log(config_populated_circuit);
    generateJointjsGraph(config_populated_circuit, 1);
}
// flag to help rate limit calls to savePositions
var stuff_has_moved = false;
paper.on("cell:pointerup", function(cell, evt, x, y) {
    if (cell.model instanceof AtoComponent || cell.model instanceof AtoBlock) stuff_has_moved = true;
});
function savePositions() {
    let requests_to_make = {};
    graph.getCells().forEach(function(cell) {
        if (cell instanceof AtoComponent || cell instanceof AtoBlock) {
            console.log(cell.id);
            let parent = cell.getParentCell();
            if (!parent) return; // skip the root element
            let origin_file = parent.attributes.config_origin_filename;
            let origin_module = parent.attributes.config_origin_module;
            let instance_name = cell.attributes.instance_name;
            if (!requests_to_make[origin_file]) requests_to_make[origin_file] = {};
            if (!requests_to_make[origin_file][origin_module]) requests_to_make[origin_file][origin_module] = {
                "child_attrs": {}
            };
            requests_to_make[origin_file][origin_module]["child_attrs"][instance_name] = {
                "position": {
                    x: cell.attributes.position.x - parent.attributes.position.x,
                    y: cell.attributes.position.y - parent.attributes.position.y
                }
            };
        }
    });
    for(let origin_file in requests_to_make){
        let requestOptions = {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(requests_to_make[origin_file])
        };
        fetch("/api/config/" + origin_file, requestOptions);
    }
    // reset the flag
    stuff_has_moved = false;
}
// rate limit the calls to savePositions
setInterval(function() {
    if (stuff_has_moved) {
        console.log("saving positions");
        savePositions();
    }
}, 1000);
loadCircuit();

},{"jointjs":"ik3ZM"}],"ik3ZM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// joint core
parcelHelpers.export(exports, "setTheme", ()=>(0, _coreMjs.setTheme));
parcelHelpers.export(exports, "config", ()=>(0, _coreMjs.config));
parcelHelpers.export(exports, "env", ()=>(0, _coreMjs.env));
parcelHelpers.export(exports, "anchors", ()=>(0, _coreMjs.anchors));
parcelHelpers.export(exports, "linkAnchors", ()=>(0, _coreMjs.linkAnchors));
parcelHelpers.export(exports, "connectionPoints", ()=>(0, _coreMjs.connectionPoints));
parcelHelpers.export(exports, "connectionStrategies", ()=>(0, _coreMjs.connectionStrategies));
parcelHelpers.export(exports, "connectors", ()=>(0, _coreMjs.connectors));
parcelHelpers.export(exports, "dia", ()=>(0, _coreMjs.dia));
parcelHelpers.export(exports, "highlighters", ()=>(0, _coreMjs.highlighters));
parcelHelpers.export(exports, "mvc", ()=>(0, _coreMjs.mvc));
parcelHelpers.export(exports, "routers", ()=>(0, _coreMjs.routers));
parcelHelpers.export(exports, "util", ()=>(0, _coreMjs.util));
parcelHelpers.export(exports, "linkTools", ()=>(0, _coreMjs.linkTools));
parcelHelpers.export(exports, "elementTools", ()=>(0, _coreMjs.elementTools));
parcelHelpers.export(exports, "Vectorizer", ()=>(0, _coreMjs.Vectorizer));
parcelHelpers.export(exports, "V", ()=>(0, _coreMjs.V));
parcelHelpers.export(exports, "version", ()=>(0, _coreMjs.version));
parcelHelpers.export(exports, "g", ()=>(0, _coreMjs.g));
parcelHelpers.export(exports, "layout", ()=>_indexMjs);
parcelHelpers.export(exports, "shapes", ()=>_indexMjs1);
var _indexMjs = require("./src/layout/index.mjs");
var _indexMjs1 = require("./src/shapes/index.mjs");
var _coreMjs = require("./src/core.mjs");

},{"./src/layout/index.mjs":false,"./src/shapes/index.mjs":"1oqut","./src/core.mjs":"hOAcI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1oqut":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "basic", ()=>_basicMjs);
parcelHelpers.export(exports, "standard", ()=>_standardMjs);
parcelHelpers.export(exports, "devs", ()=>_devsMjs);
parcelHelpers.export(exports, "logic", ()=>_logicMjs);
parcelHelpers.export(exports, "chess", ()=>_chessMjs);
parcelHelpers.export(exports, "erd", ()=>_erdMjs);
parcelHelpers.export(exports, "fsa", ()=>_fsaMjs);
parcelHelpers.export(exports, "org", ()=>_orgMjs);
parcelHelpers.export(exports, "pn", ()=>_pnMjs);
parcelHelpers.export(exports, "uml", ()=>_umlMjs);
var _basicMjs = require("./basic.mjs");
var _standardMjs = require("./standard.mjs");
var _devsMjs = require("./devs.mjs");
var _logicMjs = require("./logic.mjs");
var _chessMjs = require("./chess.mjs");
var _erdMjs = require("./erd.mjs");
var _fsaMjs = require("./fsa.mjs");
var _orgMjs = require("./org.mjs");
var _pnMjs = require("./pn.mjs");
var _umlMjs = require("./uml.mjs");

},{"./basic.mjs":"frFBw","./standard.mjs":"bIoDe","./devs.mjs":"VCKG3","./logic.mjs":"S4KOp","./chess.mjs":"dcpUb","./erd.mjs":"hUvpP","./fsa.mjs":"66MG9","./org.mjs":"6mYmX","./pn.mjs":"coP6k","./uml.mjs":"5EuxX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"frFBw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Generic", ()=>Generic);
parcelHelpers.export(exports, "Rect", ()=>Rect);
parcelHelpers.export(exports, "TextView", ()=>TextView);
parcelHelpers.export(exports, "Text", ()=>Text);
parcelHelpers.export(exports, "Circle", ()=>Circle);
parcelHelpers.export(exports, "Ellipse", ()=>Ellipse);
parcelHelpers.export(exports, "Polygon", ()=>Polygon);
parcelHelpers.export(exports, "Polyline", ()=>Polyline);
parcelHelpers.export(exports, "Image", ()=>Image);
parcelHelpers.export(exports, "Path", ()=>Path);
parcelHelpers.export(exports, "Rhombus", ()=>Rhombus);
parcelHelpers.export(exports, "TextBlock", ()=>TextBlock);
parcelHelpers.export(exports, "TextBlockView", ()=>TextBlockView);
var _elementMjs = require("../dia/Element.mjs");
var _elementViewMjs = require("../dia/ElementView.mjs");
var _indexMjs = require("../util/index.mjs");
var _indexMjs1 = require("../env/index.mjs");
const Generic = (0, _elementMjs.Element).define("basic.Generic", {
    attrs: {
        ".": {
            fill: "#ffffff",
            stroke: "none"
        }
    }
});
const Rect = Generic.define("basic.Rect", {
    attrs: {
        "rect": {
            fill: "#ffffff",
            stroke: "#000000",
            width: 100,
            height: 60
        },
        "text": {
            fill: "#000000",
            text: "",
            "font-size": 14,
            "ref-x": .5,
            "ref-y": .5,
            "text-anchor": "middle",
            "y-alignment": "middle",
            "font-family": "Arial, helvetica, sans-serif"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><rect/></g><text/></g>'
});
const TextView = (0, _elementViewMjs.ElementView).extend({
    presentationAttributes: (0, _elementViewMjs.ElementView).addPresentationAttributes({
        // The element view is not automatically re-scaled to fit the model size
        // when the attribute 'attrs' is changed.
        attrs: [
            "SCALE"
        ]
    }),
    confirmUpdate: function() {
        var flags = (0, _elementViewMjs.ElementView).prototype.confirmUpdate.apply(this, arguments);
        if (this.hasFlag(flags, "SCALE")) {
            this.resize();
            flags = this.removeFlag(flags, "SCALE");
        }
        return flags;
    }
});
const Text = Generic.define("basic.Text", {
    attrs: {
        "text": {
            "font-size": 18,
            fill: "#000000"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><text/></g></g>'
});
const Circle = Generic.define("basic.Circle", {
    size: {
        width: 60,
        height: 60
    },
    attrs: {
        "circle": {
            fill: "#ffffff",
            stroke: "#000000",
            r: 30,
            cx: 30,
            cy: 30
        },
        "text": {
            "font-size": 14,
            text: "",
            "text-anchor": "middle",
            "ref-x": .5,
            "ref-y": .5,
            "y-alignment": "middle",
            fill: "#000000",
            "font-family": "Arial, helvetica, sans-serif"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><circle/></g><text/></g>'
});
const Ellipse = Generic.define("basic.Ellipse", {
    size: {
        width: 60,
        height: 40
    },
    attrs: {
        "ellipse": {
            fill: "#ffffff",
            stroke: "#000000",
            rx: 30,
            ry: 20,
            cx: 30,
            cy: 20
        },
        "text": {
            "font-size": 14,
            text: "",
            "text-anchor": "middle",
            "ref-x": .5,
            "ref-y": .5,
            "y-alignment": "middle",
            fill: "#000000",
            "font-family": "Arial, helvetica, sans-serif"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><ellipse/></g><text/></g>'
});
const Polygon = Generic.define("basic.Polygon", {
    size: {
        width: 60,
        height: 40
    },
    attrs: {
        "polygon": {
            fill: "#ffffff",
            stroke: "#000000"
        },
        "text": {
            "font-size": 14,
            text: "",
            "text-anchor": "middle",
            "ref-x": .5,
            "ref-dy": 20,
            "y-alignment": "middle",
            fill: "#000000",
            "font-family": "Arial, helvetica, sans-serif"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><polygon/></g><text/></g>'
});
const Polyline = Generic.define("basic.Polyline", {
    size: {
        width: 60,
        height: 40
    },
    attrs: {
        "polyline": {
            fill: "#ffffff",
            stroke: "#000000"
        },
        "text": {
            "font-size": 14,
            text: "",
            "text-anchor": "middle",
            "ref-x": .5,
            "ref-dy": 20,
            "y-alignment": "middle",
            fill: "#000000",
            "font-family": "Arial, helvetica, sans-serif"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><polyline/></g><text/></g>'
});
const Image = Generic.define("basic.Image", {
    attrs: {
        "text": {
            "font-size": 14,
            text: "",
            "text-anchor": "middle",
            "ref-x": .5,
            "ref-dy": 20,
            "y-alignment": "middle",
            fill: "#000000",
            "font-family": "Arial, helvetica, sans-serif"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><image/></g><text/></g>'
});
const Path = Generic.define("basic.Path", {
    size: {
        width: 60,
        height: 60
    },
    attrs: {
        "path": {
            fill: "#ffffff",
            stroke: "#000000"
        },
        "text": {
            "font-size": 14,
            text: "",
            "text-anchor": "middle",
            "ref": "path",
            "ref-x": .5,
            "ref-dy": 10,
            fill: "#000000",
            "font-family": "Arial, helvetica, sans-serif"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><path/></g><text/></g>'
});
const Rhombus = Path.define("basic.Rhombus", {
    attrs: {
        "path": {
            d: "M 30 0 L 60 30 30 60 0 30 z"
        },
        "text": {
            "ref-y": .5,
            "ref-dy": null,
            "y-alignment": "middle"
        }
    }
});
const svgForeignObjectSupported = (0, _indexMjs1.env).test("svgforeignobject");
const TextBlock = Generic.define("basic.TextBlock", {
    // see joint.css for more element styles
    attrs: {
        rect: {
            fill: "#ffffff",
            stroke: "#000000",
            width: 80,
            height: 100
        },
        text: {
            fill: "#000000",
            "font-size": 14,
            "font-family": "Arial, helvetica, sans-serif"
        },
        ".content": {
            text: "",
            "ref-x": .5,
            "ref-y": .5,
            "y-alignment": "middle",
            "x-alignment": "middle"
        }
    },
    content: ""
}, {
    markup: [
        '<g class="rotatable">',
        '<g class="scalable"><rect/></g>',
        svgForeignObjectSupported ? '<foreignObject class="fobj"><body xmlns="http://www.w3.org/1999/xhtml"><div class="content"/></body></foreignObject>' : '<text class="content"/>',
        "</g>"
    ].join(""),
    initialize: function() {
        this.listenTo(this, "change:size", this.updateSize);
        this.listenTo(this, "change:content", this.updateContent);
        this.updateSize(this, this.get("size"));
        this.updateContent(this, this.get("content"));
        Generic.prototype.initialize.apply(this, arguments);
    },
    updateSize: function(cell, size) {
        // Selector `foreignObject' doesn't work across all browsers, we're using class selector instead.
        // We have to clone size as we don't want attributes.div.style to be same object as attributes.size.
        this.attr({
            ".fobj": (0, _indexMjs.assign)({}, size),
            div: {
                style: (0, _indexMjs.assign)({}, size)
            }
        });
    },
    updateContent: function(cell, content) {
        if (svgForeignObjectSupported) // Content element is a <div> element.
        this.attr({
            ".content": {
                html: (0, _indexMjs.sanitizeHTML)(content)
            }
        });
        else // Content element is a <text> element.
        // SVG elements don't have innerHTML attribute.
        this.attr({
            ".content": {
                text: content
            }
        });
    },
    // Here for backwards compatibility:
    setForeignObjectSize: function() {
        this.updateSize.apply(this, arguments);
    },
    // Here for backwards compatibility:
    setDivContent: function() {
        this.updateContent.apply(this, arguments);
    }
});
const TextBlockView = (0, _elementViewMjs.ElementView).extend({
    presentationAttributes: svgForeignObjectSupported ? (0, _elementViewMjs.ElementView).prototype.presentationAttributes : (0, _elementViewMjs.ElementView).addPresentationAttributes({
        content: [
            "CONTENT"
        ],
        size: [
            "CONTENT"
        ]
    }),
    initFlag: [
        "RENDER",
        "CONTENT"
    ],
    confirmUpdate: function() {
        var flags = (0, _elementViewMjs.ElementView).prototype.confirmUpdate.apply(this, arguments);
        if (this.hasFlag(flags, "CONTENT")) {
            this.updateContent(this.model);
            flags = this.removeFlag(flags, "CONTENT");
        }
        return flags;
    },
    update: function(_, renderingOnlyAttrs) {
        var model = this.model;
        if (!svgForeignObjectSupported) {
            // Update everything but the content first.
            var noTextAttrs = (0, _indexMjs.omit)(renderingOnlyAttrs || model.get("attrs"), ".content");
            (0, _elementViewMjs.ElementView).prototype.update.call(this, model, noTextAttrs);
            if (!renderingOnlyAttrs || (0, _indexMjs.has)(renderingOnlyAttrs, ".content")) // Update the content itself.
            this.updateContent(model, renderingOnlyAttrs);
        } else (0, _elementViewMjs.ElementView).prototype.update.call(this, model, renderingOnlyAttrs);
    },
    updateContent: function(cell, renderingOnlyAttrs) {
        // Create copy of the text attributes
        var textAttrs = (0, _indexMjs.merge)({}, (renderingOnlyAttrs || cell.get("attrs"))[".content"]);
        textAttrs = (0, _indexMjs.omit)(textAttrs, "text");
        // Break the content to fit the element size taking into account the attributes
        // set on the model.
        var text = (0, _indexMjs.breakText)(cell.get("content"), cell.get("size"), textAttrs, {
            // measuring sandbox svg document
            svgDocument: this.paper.svg
        });
        // Create a new attrs with same structure as the model attrs { text: { *textAttributes* }}
        var attrs = (0, _indexMjs.setByPath)({}, ".content", textAttrs, "/");
        // Replace text attribute with the one we just processed.
        attrs[".content"].text = text;
        // Update the view using renderingOnlyAttributes parameter.
        (0, _elementViewMjs.ElementView).prototype.update.call(this, cell, attrs);
    }
});

},{"../dia/Element.mjs":"hcQWn","../dia/ElementView.mjs":"dHPd6","../util/index.mjs":"eL7pI","../env/index.mjs":"1Ex7a","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hcQWn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Element", ()=>Element);
var _cellMjs = require("./Cell.mjs");
var _indexMjs = require("../g/index.mjs");
var _indexMjs1 = require("../util/index.mjs");
var _portsMjs = require("./ports.mjs");
const Element = (0, _cellMjs.Cell).extend({
    defaults: {
        position: {
            x: 0,
            y: 0
        },
        size: {
            width: 1,
            height: 1
        },
        angle: 0
    },
    initialize: function() {
        this._initializePorts();
        (0, _cellMjs.Cell).prototype.initialize.apply(this, arguments);
    },
    /**
     * @abstract
     */ _initializePorts: function() {
    // implemented in ports.js
    },
    _refreshPorts: function() {
    // implemented in ports.js
    },
    isElement: function() {
        return true;
    },
    position: function(x, y, opt) {
        const isSetter = (0, _indexMjs1.isNumber)(y);
        opt = (isSetter ? opt : x) || {};
        const { parentRelative, deep, restrictedArea } = opt;
        // option `parentRelative` for setting the position relative to the element's parent.
        let parentPosition;
        if (parentRelative) {
            // Getting the parent's position requires the collection.
            // Cell.parent() holds cell id only.
            if (!this.graph) throw new Error("Element must be part of a graph.");
            const parent = this.getParentCell();
            if (parent && !parent.isLink()) parentPosition = parent.get("position");
        }
        if (isSetter) {
            if (parentPosition) {
                x += parentPosition.x;
                y += parentPosition.y;
            }
            if (deep || restrictedArea) {
                const { x: x0, y: y0 } = this.get("position");
                this.translate(x - x0, y - y0, opt);
            } else this.set("position", {
                x,
                y
            }, opt);
            return this;
        } else {
            const elementPosition = (0, _indexMjs.Point)(this.get("position"));
            return parentRelative ? elementPosition.difference(parentPosition) : elementPosition;
        }
    },
    translate: function(tx, ty, opt) {
        tx = tx || 0;
        ty = ty || 0;
        if (tx === 0 && ty === 0) // Like nothing has happened.
        return this;
        opt = opt || {};
        // Pass the initiator of the translation.
        opt.translateBy = opt.translateBy || this.id;
        var position = this.get("position") || {
            x: 0,
            y: 0
        };
        var ra = opt.restrictedArea;
        if (ra && opt.translateBy === this.id) {
            if (typeof ra === "function") {
                var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);
                tx = newPosition.x - position.x;
                ty = newPosition.y - position.y;
            } else {
                // We are restricting the translation for the element itself only. We get
                // the bounding box of the element including all its embeds.
                // All embeds have to be translated the exact same way as the element.
                var bbox = this.getBBox({
                    deep: true
                });
                //- - - - - - - - - - - - -> ra.x + ra.width
                // - - - -> position.x      |
                // -> bbox.x
                //                ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì   |
                //         ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì
                //         ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë        |
                //   ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
                //   ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì               |
                //   <-dx->                     | restricted area right border
                //         <-width->        |   ‚ñë translated element
                //   <- - bbox.width - ->       ‚ñì embedded element
                var dx = position.x - bbox.x;
                var dy = position.y - bbox.y;
                // Find the maximal/minimal coordinates that the element can be translated
                // while complies the restrictions.
                var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));
                var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));
                // recalculate the translation taking the restrictions into account.
                tx = x - position.x;
                ty = y - position.y;
            }
        }
        var translatedPosition = {
            x: position.x + tx,
            y: position.y + ty
        };
        // To find out by how much an element was translated in event 'change:position' handlers.
        opt.tx = tx;
        opt.ty = ty;
        if (opt.transition) {
            if (!(0, _indexMjs1.isObject)(opt.transition)) opt.transition = {};
            this.transition("position", translatedPosition, (0, _indexMjs1.assign)({}, opt.transition, {
                valueFunction: (0, _indexMjs1.interpolate).object
            }));
            // Recursively call `translate()` on all the embeds cells.
            (0, _indexMjs1.invoke)(this.getEmbeddedCells(), "translate", tx, ty, opt);
        } else {
            this.startBatch("translate", opt);
            this.set("position", translatedPosition, opt);
            (0, _indexMjs1.invoke)(this.getEmbeddedCells(), "translate", tx, ty, opt);
            this.stopBatch("translate", opt);
        }
        return this;
    },
    size: function(width, height, opt) {
        var currentSize = this.get("size");
        // Getter
        // () signature
        if (width === undefined) return {
            width: currentSize.width,
            height: currentSize.height
        };
        // Setter
        // (size, opt) signature
        if ((0, _indexMjs1.isObject)(width)) {
            opt = height;
            height = (0, _indexMjs1.isNumber)(width.height) ? width.height : currentSize.height;
            width = (0, _indexMjs1.isNumber)(width.width) ? width.width : currentSize.width;
        }
        return this.resize(width, height, opt);
    },
    resize: function(width, height, opt) {
        opt = opt || {};
        this.startBatch("resize", opt);
        if (opt.direction) {
            var currentSize = this.get("size");
            switch(opt.direction){
                case "left":
                case "right":
                    // Don't change height when resizing horizontally.
                    height = currentSize.height;
                    break;
                case "top":
                case "bottom":
                    // Don't change width when resizing vertically.
                    width = currentSize.width;
                    break;
            }
            // Get the angle and clamp its value between 0 and 360 degrees.
            var angle = (0, _indexMjs.normalizeAngle)(this.get("angle") || 0);
            // This is a rectangle in size of the un-rotated element.
            var bbox = this.getBBox();
            var origin;
            if (angle) {
                var quadrant = {
                    "top-right": 0,
                    "right": 0,
                    "top-left": 1,
                    "top": 1,
                    "bottom-left": 2,
                    "left": 2,
                    "bottom-right": 3,
                    "bottom": 3
                }[opt.direction];
                if (opt.absolute) {
                    // We are taking the element's rotation into account
                    quadrant += Math.floor((angle + 45) / 90);
                    quadrant %= 4;
                }
                // Pick the corner point on the element, which meant to stay on its place before and
                // after the rotation.
                var fixedPoint = bbox[[
                    "bottomLeft",
                    "corner",
                    "topRight",
                    "origin"
                ][quadrant]]();
                // Find  an image of the previous indent point. This is the position, where is the
                // point actually located on the screen.
                var imageFixedPoint = (0, _indexMjs.Point)(fixedPoint).rotate(bbox.center(), -angle);
                // Every point on the element rotates around a circle with the centre of rotation
                // in the middle of the element while the whole element is being rotated. That means
                // that the distance from a point in the corner of the element (supposed its always rect) to
                // the center of the element doesn't change during the rotation and therefore it equals
                // to a distance on un-rotated element.
                // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.
                var radius = Math.sqrt(width * width + height * height) / 2;
                // Now we are looking for an angle between x-axis and the line starting at image of fixed point
                // and ending at the center of the element. We call this angle `alpha`.
                // The image of a fixed point is located in n-th quadrant. For each quadrant passed
                // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.
                //
                // 3 | 2
                // --c-- Quadrant positions around the element's center `c`
                // 0 | 1
                //
                var alpha = quadrant * Math.PI / 2;
                // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis
                // going through the center of the element) and line crossing the indent of the fixed point and the center
                // of the element. This is the angle we need but on the un-rotated element.
                alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);
                // Lastly we have to deduct the original angle the element was rotated by and that's it.
                alpha -= (0, _indexMjs.toRad)(angle);
                // With this angle and distance we can easily calculate the centre of the un-rotated element.
                // Note that fromPolar constructor accepts an angle in radians.
                var center = (0, _indexMjs.Point).fromPolar(radius, alpha, imageFixedPoint);
                // The top left corner on the un-rotated element has to be half a width on the left
                // and half a height to the top from the center. This will be the origin of rectangle
                // we were looking for.
                origin = (0, _indexMjs.Point)(center).offset(width / -2, height / -2);
            } else {
                // calculation for the origin Point when there is no rotation of the element
                origin = bbox.topLeft();
                switch(opt.direction){
                    case "top":
                    case "top-right":
                        origin.offset(0, bbox.height - height);
                        break;
                    case "left":
                    case "bottom-left":
                        origin.offset(bbox.width - width, 0);
                        break;
                    case "top-left":
                        origin.offset(bbox.width - width, bbox.height - height);
                        break;
                }
            }
            // Resize the element (before re-positioning it).
            this.set("size", {
                width: width,
                height: height
            }, opt);
            // Finally, re-position the element.
            this.position(origin.x, origin.y, opt);
        } else // Resize the element.
        this.set("size", {
            width: width,
            height: height
        }, opt);
        this.stopBatch("resize", opt);
        return this;
    },
    scale: function(sx, sy, origin, opt) {
        var scaledBBox = this.getBBox().scale(sx, sy, origin);
        this.startBatch("scale", opt);
        this.position(scaledBBox.x, scaledBBox.y, opt);
        this.resize(scaledBBox.width, scaledBBox.height, opt);
        this.stopBatch("scale");
        return this;
    },
    fitEmbeds: function(opt) {
        return this.fitToChildren(opt);
    },
    fitToChildren: function(opt = {}) {
        // Getting the children's size and position requires the collection.
        // Cell.get('embeds') holds an array of cell ids only.
        const { graph } = this;
        if (!graph) throw new Error("Element must be part of a graph.");
        const childElements = this.getEmbeddedCells().filter((cell)=>cell.isElement());
        if (childElements.length === 0) return this;
        this.startBatch("fit-embeds", opt);
        if (opt.deep) // `opt.deep = true` means "fit to all descendants".
        // As the first action of the fitting algorithm, recursively apply `fitToChildren()` on all descendants.
        // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant, then go up (= this element).
        (0, _indexMjs1.invoke)(childElements, "fitToChildren", opt);
        // Set new size and position of this element, based on:
        // - union of bboxes of all children
        // - inflated by given `opt.padding`
        this._fitToElements(Object.assign({
            elements: childElements
        }, opt));
        this.stopBatch("fit-embeds");
        return this;
    },
    fitParent: function(opt = {}) {
        const { graph } = this;
        if (!graph) throw new Error("Element must be part of a graph.");
        // When `opt.deep = true`, we want `opt.terminator` to be the last ancestor processed.
        // If the current element is `opt.terminator`, it means that this element has already been processed as parent so we can exit now.
        if (opt.deep && opt.terminator && (opt.terminator === this || opt.terminator === this.id)) return this;
        const parentElement = this.getParentCell();
        if (!parentElement || !parentElement.isElement()) return this;
        // Get all children of parent element (i.e. this element + any sibling elements).
        const siblingElements = parentElement.getEmbeddedCells().filter((cell)=>cell.isElement());
        if (siblingElements.length === 0) return this;
        this.startBatch("fit-parent", opt);
        // Set new size and position of parent element, based on:
        // - union of bboxes of all children of parent element (i.e. this element + any sibling elements)
        // - inflated by given `opt.padding`
        parentElement._fitToElements(Object.assign({
            elements: siblingElements
        }, opt));
        if (opt.deep) // `opt.deep = true` means "fit all ancestors to their respective children".
        // As the last action of the fitting algorithm, recursively apply `fitParent()` on all ancestors.
        // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant (= this element), then go up.
        parentElement.fitParent(opt);
        this.stopBatch("fit-parent");
        return this;
    },
    // Assumption: This element is part of a graph.
    _fitToElements: function(opt = {}) {
        const elementsBBox = this.graph.getCellsBBox(opt.elements);
        // If no `opt.elements` were provided, do nothing.
        if (!elementsBBox) return;
        const { expandOnly, shrinkOnly } = opt;
        // This combination is meaningless, do nothing.
        if (expandOnly && shrinkOnly) return;
        // Calculate new size and position of this element based on:
        // - union of bboxes of `opt.elements`
        // - inflated by `opt.padding` (if not provided, all four properties = 0)
        let { x, y, width, height } = elementsBBox;
        const { left, right, top, bottom } = (0, _indexMjs1.normalizeSides)(opt.padding);
        x -= left;
        y -= top;
        width += left + right;
        height += bottom + top;
        let resultBBox = new (0, _indexMjs.Rect)(x, y, width, height);
        if (expandOnly) // Non-shrinking is enforced by taking union of this element's current bbox with bbox calculated from `opt.elements`.
        resultBBox = this.getBBox().union(resultBBox);
        else if (shrinkOnly) {
            // Non-expansion is enforced by taking intersection of this element's current bbox with bbox calculated from `opt.elements`.
            const intersectionBBox = this.getBBox().intersect(resultBBox);
            // If all children are outside this element's current bbox, then `intersectionBBox` is `null` - does not make sense, do nothing.
            if (!intersectionBBox) return;
            resultBBox = intersectionBBox;
        }
        // Set the new size and position of this element.
        this.set({
            position: {
                x: resultBBox.x,
                y: resultBBox.y
            },
            size: {
                width: resultBBox.width,
                height: resultBBox.height
            }
        }, opt);
    },
    // Rotate element by `angle` degrees, optionally around `origin` point.
    // If `origin` is not provided, it is considered to be the center of the element.
    // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not
    // the difference from the previous angle.
    rotate: function(angle, absolute, origin, opt) {
        if (origin) {
            var center = this.getBBox().center();
            var size = this.get("size");
            var position = this.get("position");
            center.rotate(origin, this.get("angle") - angle);
            var dx = center.x - size.width / 2 - position.x;
            var dy = center.y - size.height / 2 - position.y;
            this.startBatch("rotate", {
                angle: angle,
                absolute: absolute,
                origin: origin
            });
            this.position(position.x + dx, position.y + dy, opt);
            this.rotate(angle, absolute, null, opt);
            this.stopBatch("rotate");
        } else this.set("angle", absolute ? angle : (this.get("angle") + angle) % 360, opt);
        return this;
    },
    angle: function() {
        return (0, _indexMjs.normalizeAngle)(this.get("angle") || 0);
    },
    getBBox: function(opt = {}) {
        const { graph, attributes } = this;
        const { deep, rotate } = opt;
        if (deep && graph) {
            // Get all the embedded elements using breadth first algorithm.
            const elements = this.getEmbeddedCells({
                deep: true,
                breadthFirst: true
            });
            // Add the model itself.
            elements.push(this);
            // Note: the default of getCellsBBox() is rotate=true and can't be
            // changed without a breaking change
            return graph.getCellsBBox(elements, opt);
        }
        const { angle = 0, position: { x, y }, size: { width, height } } = attributes;
        const bbox = new (0, _indexMjs.Rect)(x, y, width, height);
        if (rotate) bbox.rotateAroundCenter(angle);
        return bbox;
    },
    getPointFromConnectedLink: function(link, endType) {
        // Center of the model
        var bbox = this.getBBox();
        var center = bbox.center();
        // Center of a port
        var endDef = link.get(endType);
        if (!endDef) return center;
        var portId = endDef.port;
        if (!portId || !this.hasPort(portId)) return center;
        var portGroup = this.portProp(portId, [
            "group"
        ]);
        var portsPositions = this.getPortsPositions(portGroup);
        var portCenter = new (0, _indexMjs.Point)(portsPositions[portId]).offset(bbox.origin());
        var angle = this.angle();
        if (angle) portCenter.rotate(center, -angle);
        return portCenter;
    }
});
(0, _indexMjs1.assign)(Element.prototype, (0, _portsMjs.elementPortPrototype));

},{"./Cell.mjs":"vHapP","../g/index.mjs":"i91Db","../util/index.mjs":"eL7pI","./ports.mjs":"8Us97","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"vHapP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Cell", ()=>Cell);
var _backbone = require("backbone");
var _backboneDefault = parcelHelpers.interopDefault(_backbone);
var _utilMjs = require("../util/util.mjs");
var _cloneCellsMjs = require("../util/cloneCells.mjs");
var _indexMjs = require("./attributes/index.mjs");
var _indexMjs1 = require("../g/index.mjs");
const Cell = (0, _backboneDefault.default).Model.extend({
    // This is the same as Backbone.Model with the only difference that is uses util.merge
    // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.
    constructor: function(attributes, options) {
        var defaults;
        var attrs = attributes || {};
        if (typeof this.preinitialize === "function") // Check to support an older version of Backbone (prior v1.4)
        this.preinitialize.apply(this, arguments);
        this.cid = (0, _utilMjs.uniqueId)("c");
        this.attributes = {};
        if (options && options.collection) this.collection = options.collection;
        if (options && options.parse) attrs = this.parse(attrs, options) || {};
        if (defaults = (0, _utilMjs.result)(this, "defaults")) //<custom code>
        // Replaced the call to _.defaults with util.merge.
        attrs = (0, _utilMjs.merge)({}, defaults, attrs);
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
    },
    translate: function(dx, dy, opt) {
        throw new Error("Must define a translate() method.");
    },
    toJSON: function() {
        const defaults = (0, _utilMjs.result)(this.constructor.prototype, "defaults");
        const defaultAttrs = defaults.attrs || {};
        const attrs = this.attributes.attrs;
        const finalAttrs = {};
        // Loop through all the attributes and
        // omit the default attributes as they are implicitly reconstructible by the cell 'type'.
        (0, _utilMjs.forIn)(attrs, function(attr, selector) {
            const defaultAttr = defaultAttrs[selector];
            (0, _utilMjs.forIn)(attr, function(value, name) {
                // attr is mainly flat though it might have one more level (consider the `style` attribute).
                // Check if the `value` is object and if yes, go one level deep.
                if ((0, _utilMjs.isObject)(value) && !Array.isArray(value)) (0, _utilMjs.forIn)(value, function(value2, name2) {
                    if (!defaultAttr || !defaultAttr[name] || !(0, _utilMjs.isEqual)(defaultAttr[name][name2], value2)) {
                        finalAttrs[selector] = finalAttrs[selector] || {};
                        (finalAttrs[selector][name] || (finalAttrs[selector][name] = {}))[name2] = value2;
                    }
                });
                else if (!defaultAttr || !(0, _utilMjs.isEqual)(defaultAttr[name], value)) {
                    // `value` is not an object, default attribute for such a selector does not exist
                    // or it is different than the attribute value set on the model.
                    finalAttrs[selector] = finalAttrs[selector] || {};
                    finalAttrs[selector][name] = value;
                }
            });
        });
        const attributes = (0, _utilMjs.cloneDeep)((0, _utilMjs.omit)(this.attributes, "attrs"));
        attributes.attrs = finalAttrs;
        return attributes;
    },
    initialize: function(options) {
        const idAttribute = this.getIdAttribute();
        if (!options || options[idAttribute] === undefined) this.set(idAttribute, this.generateId(), {
            silent: true
        });
        this._transitionIds = {};
        this._scheduledTransitionIds = {};
        // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.
        this.processPorts();
        this.on("change:attrs", this.processPorts, this);
    },
    getIdAttribute: function() {
        return this.idAttribute || "id";
    },
    generateId: function() {
        return (0, _utilMjs.uuid)();
    },
    /**
     * @deprecated
     */ processPorts: function() {
        // Whenever `attrs` changes, we extract ports from the `attrs` object and store it
        // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`
        // set to that port, we remove those links as well (to follow the same behaviour as
        // with a removed element).
        var previousPorts = this.ports;
        // Collect ports from the `attrs` object.
        var ports = {};
        (0, _utilMjs.forIn)(this.get("attrs"), function(attrs, selector) {
            if (attrs && attrs.port) {
                // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).
                if (attrs.port.id !== undefined) ports[attrs.port.id] = attrs.port;
                else ports[attrs.port] = {
                    id: attrs.port
                };
            }
        });
        // Collect ports that have been removed (compared to the previous ports) - if any.
        // Use hash table for quick lookup.
        var removedPorts = {};
        (0, _utilMjs.forIn)(previousPorts, function(port, id) {
            if (!ports[id]) removedPorts[id] = true;
        });
        // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.
        if (this.graph && !(0, _utilMjs.isEmpty)(removedPorts)) {
            var inboundLinks = this.graph.getConnectedLinks(this, {
                inbound: true
            });
            inboundLinks.forEach(function(link) {
                if (removedPorts[link.get("target").port]) link.remove();
            });
            var outboundLinks = this.graph.getConnectedLinks(this, {
                outbound: true
            });
            outboundLinks.forEach(function(link) {
                if (removedPorts[link.get("source").port]) link.remove();
            });
        }
        // Update the `ports` object.
        this.ports = ports;
    },
    remove: function(opt = {}) {
        // Store the graph in a variable because `this.graph` won't be accessible
        // after `this.trigger('remove', ...)` down below.
        const { graph, collection } = this;
        if (!graph) {
            // The collection is a common Backbone collection (not the graph collection).
            if (collection) collection.remove(this, opt);
            return this;
        }
        graph.startBatch("remove");
        // First, unembed this cell from its parent cell if there is one.
        const parentCell = this.getParentCell();
        if (parentCell) parentCell.unembed(this, opt);
        // Remove also all the cells, which were embedded into this cell
        const embeddedCells = this.getEmbeddedCells();
        for(let i = 0, n = embeddedCells.length; i < n; i++){
            const embed = embeddedCells[i];
            if (embed) embed.remove(opt);
        }
        this.trigger("remove", this, graph.attributes.cells, opt);
        graph.stopBatch("remove");
        return this;
    },
    toFront: function(opt) {
        var graph = this.graph;
        if (graph) {
            opt = (0, _utilMjs.defaults)(opt || {}, {
                foregroundEmbeds: true
            });
            let cells;
            if (opt.deep) {
                cells = this.getEmbeddedCells({
                    deep: true,
                    breadthFirst: opt.breadthFirst !== false,
                    sortSiblings: opt.foregroundEmbeds
                });
                cells.unshift(this);
            } else cells = [
                this
            ];
            const sortedCells = opt.foregroundEmbeds ? cells : (0, _utilMjs.sortBy)(cells, (cell)=>cell.z());
            const maxZ = graph.maxZIndex();
            let z = maxZ - cells.length + 1;
            const collection = graph.get("cells");
            let shouldUpdate = collection.indexOf(sortedCells[0]) !== collection.length - cells.length;
            if (!shouldUpdate) shouldUpdate = sortedCells.some(function(cell, index) {
                return cell.z() !== z + index;
            });
            if (shouldUpdate) {
                this.startBatch("to-front");
                z = z + cells.length;
                sortedCells.forEach(function(cell, index) {
                    cell.set("z", z + index, opt);
                });
                this.stopBatch("to-front");
            }
        }
        return this;
    },
    toBack: function(opt) {
        var graph = this.graph;
        if (graph) {
            opt = (0, _utilMjs.defaults)(opt || {}, {
                foregroundEmbeds: true
            });
            let cells;
            if (opt.deep) {
                cells = this.getEmbeddedCells({
                    deep: true,
                    breadthFirst: opt.breadthFirst !== false,
                    sortSiblings: opt.foregroundEmbeds
                });
                cells.unshift(this);
            } else cells = [
                this
            ];
            const sortedCells = opt.foregroundEmbeds ? cells : (0, _utilMjs.sortBy)(cells, (cell)=>cell.z());
            let z = graph.minZIndex();
            var collection = graph.get("cells");
            let shouldUpdate = collection.indexOf(sortedCells[0]) !== 0;
            if (!shouldUpdate) shouldUpdate = sortedCells.some(function(cell, index) {
                return cell.z() !== z + index;
            });
            if (shouldUpdate) {
                this.startBatch("to-back");
                z -= cells.length;
                sortedCells.forEach(function(cell, index) {
                    cell.set("z", z + index, opt);
                });
                this.stopBatch("to-back");
            }
        }
        return this;
    },
    parent: function(parent, opt) {
        // getter
        if (parent === undefined) return this.get("parent");
        // setter
        return this.set("parent", parent, opt);
    },
    embed: function(cell, opt) {
        const cells = Array.isArray(cell) ? cell : [
            cell
        ];
        if (!this.canEmbed(cells)) throw new Error("Recursive embedding not allowed.");
        if (cells.some((c)=>c.isEmbedded() && this.id !== c.parent())) throw new Error("Embedding of already embedded cells is not allowed.");
        this._embedCells(cells, opt);
        return this;
    },
    unembed: function(cell, opt) {
        const cells = Array.isArray(cell) ? cell : [
            cell
        ];
        this._unembedCells(cells, opt);
        return this;
    },
    canEmbed: function(cell) {
        const cells = Array.isArray(cell) ? cell : [
            cell
        ];
        return cells.every((c)=>this !== c && !this.isEmbeddedIn(c));
    },
    _embedCells: function(cells, opt) {
        const batchName = "embed";
        this.startBatch(batchName);
        const embeds = (0, _utilMjs.assign)([], this.get("embeds"));
        cells.forEach((cell)=>{
            // We keep all element ids after link ids.
            embeds[cell.isLink() ? "unshift" : "push"](cell.id);
            cell.parent(this.id, opt);
        });
        this.set("embeds", (0, _utilMjs.uniq)(embeds), opt);
        this.stopBatch(batchName);
    },
    _unembedCells: function(cells, opt) {
        const batchName = "unembed";
        this.startBatch(batchName);
        cells.forEach((cell)=>cell.unset("parent", opt));
        this.set("embeds", (0, _utilMjs.without)(this.get("embeds"), ...cells.map((cell)=>cell.id)), opt);
        this.stopBatch(batchName);
    },
    getParentCell: function() {
        // unlike link.source/target, cell.parent stores id directly as a string
        var parentId = this.parent();
        var graph = this.graph;
        return parentId && graph && graph.getCell(parentId) || null;
    },
    // Return an array of ancestor cells.
    // The array is ordered from the parent of the cell
    // to the most distant ancestor.
    getAncestors: function() {
        var ancestors = [];
        if (!this.graph) return ancestors;
        var parentCell = this.getParentCell();
        while(parentCell){
            ancestors.push(parentCell);
            parentCell = parentCell.getParentCell();
        }
        return ancestors;
    },
    getEmbeddedCells: function(opt) {
        opt = opt || {};
        // Cell models can only be retrieved when this element is part of a collection.
        // There is no way this element knows about other cells otherwise.
        // This also means that calling e.g. `translate()` on an element with embeds before
        // adding it to a graph does not translate its embeds.
        if (!this.graph) return [];
        if (opt.deep) {
            if (opt.breadthFirst) return this._getEmbeddedCellsBfs(opt.sortSiblings);
            else return this._getEmbeddedCellsDfs(opt.sortSiblings);
        }
        const embeddedIds = this.get("embeds");
        if ((0, _utilMjs.isEmpty)(embeddedIds)) return [];
        let cells = embeddedIds.map(this.graph.getCell, this.graph);
        if (opt.sortSiblings) cells = (0, _utilMjs.sortBy)(cells, (cell)=>cell.z());
        return cells;
    },
    _getEmbeddedCellsBfs: function(sortSiblings) {
        const cells = [];
        const queue = [];
        queue.push(this);
        while(queue.length > 0){
            const current = queue.shift();
            cells.push(current);
            const embeddedCells = current.getEmbeddedCells({
                sortSiblings: sortSiblings
            });
            queue.push(...embeddedCells);
        }
        cells.shift();
        return cells;
    },
    _getEmbeddedCellsDfs: function(sortSiblings) {
        const cells = [];
        const stack = [];
        stack.push(this);
        while(stack.length > 0){
            const current = stack.pop();
            cells.push(current);
            const embeddedCells = current.getEmbeddedCells({
                sortSiblings: sortSiblings
            });
            // When using the stack, cells that are embedded last are processed first.
            // To maintain the original order, we need to push the cells in reverse order
            for(let i = embeddedCells.length - 1; i >= 0; --i)stack.push(embeddedCells[i]);
        }
        cells.shift();
        return cells;
    },
    isEmbeddedIn: function(cell, opt) {
        var cellId = (0, _utilMjs.isString)(cell) ? cell : cell.id;
        var parentId = this.parent();
        opt = (0, _utilMjs.assign)({
            deep: true
        }, opt);
        // See getEmbeddedCells().
        if (this.graph && opt.deep) {
            while(parentId){
                if (parentId === cellId) return true;
                parentId = this.graph.getCell(parentId).parent();
            }
            return false;
        } else // When this cell is not part of a collection check
        // at least whether it's a direct child of given cell.
        return parentId === cellId;
    },
    // Whether or not the cell is embedded in any other cell.
    isEmbedded: function() {
        return !!this.parent();
    },
    // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).
    // Shallow cloning simply clones the cell and returns a new cell with different ID.
    // Deep cloning clones the cell and all its embedded cells recursively.
    clone: function(opt) {
        opt = opt || {};
        if (!opt.deep) {
            // Shallow cloning.
            var clone = (0, _backboneDefault.default).Model.prototype.clone.apply(this, arguments);
            // We don't want the clone to have the same ID as the original.
            clone.set(this.getIdAttribute(), this.generateId());
            // A shallow cloned element does not carry over the original embeds.
            clone.unset("embeds");
            // And can not be embedded in any cell
            // as the clone is not part of the graph.
            clone.unset("parent");
            return clone;
        } else // Deep cloning.
        // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.
        return (0, _utilMjs.toArray)((0, _cloneCellsMjs.cloneCells)([
            this
        ].concat(this.getEmbeddedCells({
            deep: true
        }))));
    },
    // A convenient way to set nested properties.
    // This method merges the properties you'd like to set with the ones
    // stored in the cell and makes sure change events are properly triggered.
    // You can either set a nested property with one object
    // or use a property path.
    // The most simple use case is:
    // `cell.prop('name/first', 'John')` or
    // `cell.prop({ name: { first: 'John' } })`.
    // Nested arrays are supported too:
    // `cell.prop('series/0/data/0/degree', 50)` or
    // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.
    prop: function(props, value, opt) {
        var delim = "/";
        var _isString = (0, _utilMjs.isString)(props);
        if (_isString || Array.isArray(props)) {
            // Get/set an attribute by a special path syntax that delimits
            // nested objects by the colon character.
            if (arguments.length > 1) {
                var path;
                var pathArray;
                if (_isString) {
                    path = props;
                    pathArray = path.split("/");
                } else {
                    path = props.join(delim);
                    pathArray = props.slice();
                }
                var property = pathArray[0];
                var pathArrayLength = pathArray.length;
                const options = opt || {};
                options.propertyPath = path;
                options.propertyValue = value;
                options.propertyPathArray = pathArray;
                if (!("rewrite" in options)) options.rewrite = false;
                var update = {};
                // Initialize the nested object. Sub-objects are either arrays or objects.
                // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.
                // Note that this imposes a limitation on object keys one can use with Inspector.
                // Pure integer keys will cause issues and are therefore not allowed.
                var initializer = update;
                var prevProperty = property;
                for(var i = 1; i < pathArrayLength; i++){
                    var pathItem = pathArray[i];
                    var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);
                    initializer = initializer[prevProperty] = isArrayIndex ? [] : {};
                    prevProperty = pathItem;
                }
                // Fill update with the `value` on `path`.
                update = (0, _utilMjs.setByPath)(update, pathArray, value, "/");
                var baseAttributes = (0, _utilMjs.merge)({}, this.attributes);
                // if rewrite mode enabled, we replace value referenced by path with
                // the new one (we don't merge).
                options.rewrite && (0, _utilMjs.unsetByPath)(baseAttributes, path, "/");
                // Merge update with the model attributes.
                var attributes = (0, _utilMjs.merge)(baseAttributes, update);
                // Finally, set the property to the updated attributes.
                return this.set(property, attributes[property], options);
            } else return (0, _utilMjs.getByPath)(this.attributes, props, delim);
        }
        const options = value || {};
        // Note: '' is not the path to the root. It's a path with an empty string i.e. { '': {}}.
        options.propertyPath = null;
        options.propertyValue = props;
        options.propertyPathArray = [];
        if (!("rewrite" in options)) options.rewrite = false;
        return this.set((0, _utilMjs.merge)({}, this.attributes, props), options);
    },
    // A convenient way to unset nested properties
    removeProp: function(path, opt) {
        opt = opt || {};
        var pathArray = Array.isArray(path) ? path : path.split("/");
        // Once a property is removed from the `attrs` attribute
        // the cellView will recognize a `dirty` flag and re-render itself
        // in order to remove the attribute from SVG element.
        var property = pathArray[0];
        if (property === "attrs") opt.dirty = true;
        if (pathArray.length === 1) // A top level property
        return this.unset(path, opt);
        // A nested property
        var nestedPath = pathArray.slice(1);
        var propertyValue = this.get(property);
        if (propertyValue === undefined || propertyValue === null) return this;
        propertyValue = (0, _utilMjs.cloneDeep)(propertyValue);
        (0, _utilMjs.unsetByPath)(propertyValue, nestedPath, "/");
        return this.set(property, propertyValue, opt);
    },
    // A convenient way to set nested attributes.
    attr: function(attrs, value, opt) {
        var args = Array.from(arguments);
        if (args.length === 0) return this.get("attrs");
        if (Array.isArray(attrs)) args[0] = [
            "attrs"
        ].concat(attrs);
        else if ((0, _utilMjs.isString)(attrs)) // Get/set an attribute by a special path syntax that delimits
        // nested objects by the colon character.
        args[0] = "attrs/" + attrs;
        else args[0] = {
            "attrs": attrs
        };
        return this.prop.apply(this, args);
    },
    // A convenient way to unset nested attributes
    removeAttr: function(path, opt) {
        if (Array.isArray(path)) return this.removeProp([
            "attrs"
        ].concat(path));
        return this.removeProp("attrs/" + path, opt);
    },
    transition: function(path, value, opt, delim) {
        delim = delim || "/";
        var defaults = {
            duration: 100,
            delay: 10,
            timingFunction: (0, _utilMjs.timing).linear,
            valueFunction: (0, _utilMjs.interpolate).number
        };
        opt = (0, _utilMjs.assign)(defaults, opt);
        var firstFrameTime = 0;
        var interpolatingFunction;
        var setter = (function(runtime) {
            var id, progress, propertyValue;
            firstFrameTime = firstFrameTime || runtime;
            runtime -= firstFrameTime;
            progress = runtime / opt.duration;
            if (progress < 1) this._transitionIds[path] = id = (0, _utilMjs.nextFrame)(setter);
            else {
                progress = 1;
                delete this._transitionIds[path];
            }
            propertyValue = interpolatingFunction(opt.timingFunction(progress));
            opt.transitionId = id;
            this.prop(path, propertyValue, opt);
            if (!id) this.trigger("transition:end", this, path);
        }).bind(this);
        const { _scheduledTransitionIds } = this;
        let initialId;
        var initiator = (callback)=>{
            if (_scheduledTransitionIds[path]) {
                _scheduledTransitionIds[path] = (0, _utilMjs.without)(_scheduledTransitionIds[path], initialId);
                if (_scheduledTransitionIds[path].length === 0) delete _scheduledTransitionIds[path];
            }
            this.stopPendingTransitions(path, delim);
            interpolatingFunction = opt.valueFunction((0, _utilMjs.getByPath)(this.attributes, path, delim), value);
            this._transitionIds[path] = (0, _utilMjs.nextFrame)(callback);
            this.trigger("transition:start", this, path);
        };
        initialId = setTimeout(initiator, opt.delay, setter);
        _scheduledTransitionIds[path] || (_scheduledTransitionIds[path] = []);
        _scheduledTransitionIds[path].push(initialId);
        return initialId;
    },
    getTransitions: function() {
        return (0, _utilMjs.union)(Object.keys(this._transitionIds), Object.keys(this._scheduledTransitionIds));
    },
    stopScheduledTransitions: function(path, delim = "/") {
        const { _scheduledTransitionIds = {} } = this;
        let transitions = Object.keys(_scheduledTransitionIds);
        if (path) {
            const pathArray = path.split(delim);
            transitions = transitions.filter((key)=>{
                return (0, _utilMjs.isEqual)(pathArray, key.split(delim).slice(0, pathArray.length));
            });
        }
        transitions.forEach((key)=>{
            const transitionIds = _scheduledTransitionIds[key];
            // stop the initiator
            transitionIds.forEach((transitionId)=>clearTimeout(transitionId));
            delete _scheduledTransitionIds[key];
        // Note: we could trigger transition:cancel` event here
        });
        return this;
    },
    stopPendingTransitions (path, delim = "/") {
        const { _transitionIds = {} } = this;
        let transitions = Object.keys(_transitionIds);
        if (path) {
            const pathArray = path.split(delim);
            transitions = transitions.filter((key)=>{
                return (0, _utilMjs.isEqual)(pathArray, key.split(delim).slice(0, pathArray.length));
            });
        }
        transitions.forEach((key)=>{
            const transitionId = _transitionIds[key];
            // stop the setter
            (0, _utilMjs.cancelFrame)(transitionId);
            delete _transitionIds[key];
            this.trigger("transition:end", this, key);
        });
    },
    stopTransitions: function(path, delim = "/") {
        this.stopScheduledTransitions(path, delim);
        this.stopPendingTransitions(path, delim);
        return this;
    },
    // A shorcut making it easy to create constructs like the following:
    // `var el = (new joint.shapes.basic.Rect).addTo(graph)`.
    addTo: function(graph, opt) {
        graph.addCell(this, opt);
        return this;
    },
    // A shortcut for an equivalent call: `paper.findViewByModel(cell)`
    // making it easy to create constructs like the following:
    // `cell.findView(paper).highlight()`
    findView: function(paper) {
        return paper.findViewByModel(this);
    },
    isElement: function() {
        return false;
    },
    isLink: function() {
        return false;
    },
    startBatch: function(name, opt) {
        if (this.graph) this.graph.startBatch(name, (0, _utilMjs.assign)({}, opt, {
            cell: this
        }));
        return this;
    },
    stopBatch: function(name, opt) {
        if (this.graph) this.graph.stopBatch(name, (0, _utilMjs.assign)({}, opt, {
            cell: this
        }));
        return this;
    },
    getChangeFlag: function(attributes) {
        var flag = 0;
        if (!attributes) return flag;
        for(var key in attributes){
            if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;
            flag |= attributes[key];
        }
        return flag;
    },
    angle: function() {
        // To be overridden.
        return 0;
    },
    position: function() {
        // To be overridden.
        return new _indexMjs1.Point(0, 0);
    },
    z: function() {
        return this.get("z") || 0;
    },
    getPointFromConnectedLink: function() {
        // To be overridden
        return new _indexMjs1.Point();
    },
    getBBox: function() {
        // To be overridden
        return new _indexMjs1.Rect(0, 0, 0, 0);
    },
    getPointRotatedAroundCenter (angle, x, y) {
        const point = new _indexMjs1.Point(x, y);
        if (angle) point.rotate(this.getBBox().center(), angle);
        return point;
    },
    getAbsolutePointFromRelative (x, y) {
        // Rotate the position to take the model angle into account
        return this.getPointRotatedAroundCenter(-this.angle(), // Transform the relative position to absolute
        this.position().offset(x, y));
    },
    getRelativePointFromAbsolute (x, y) {
        return this// Rotate the coordinates to mitigate the element's rotation.
        .getPointRotatedAroundCenter(this.angle(), x, y)// Transform the absolute position into relative
        .difference(this.position());
    }
}, {
    getAttributeDefinition: function(attrName) {
        var defNS = this.attributes;
        var globalDefNS = (0, _indexMjs.attributes);
        return defNS && defNS[attrName] || globalDefNS[attrName];
    },
    define: function(type, defaults, protoProps, staticProps) {
        protoProps = (0, _utilMjs.assign)({
            defaults: (0, _utilMjs.defaultsDeep)({
                type: type
            }, defaults, this.prototype.defaults)
        }, protoProps);
        var Cell = this.extend(protoProps, staticProps);
        // es5 backward compatibility
        /* eslint-disable no-undef */ if (typeof joint !== "undefined" && (0, _utilMjs.has)(joint, "shapes")) (0, _utilMjs.setByPath)(joint.shapes, type, Cell, ".");
        /* eslint-enable no-undef */ return Cell;
    }
});

},{"backbone":"gM9rO","../util/util.mjs":"5j2Qt","../util/cloneCells.mjs":"5qBbR","./attributes/index.mjs":"9p63m","../g/index.mjs":"i91Db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gM9rO":[function(require,module,exports) {
var global = arguments[3];
//     Backbone.js 1.4.1
//     (c) 2010-2022 Jeremy Ashkenas and DocumentCloud
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org
(function(factory) {
    // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
    // We use `self` instead of `window` for `WebWorker` support.
    var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global;
    // Set up Backbone appropriately for the environment. Start with AMD.
    if (typeof define === "function" && define.amd) define([
        "underscore",
        "jquery",
        "exports"
    ], function(_, $, exports1) {
        // Export global even in AMD case in case this script is loaded with
        // others that may still expect a global Backbone.
        root.Backbone = factory(root, exports1, _, $);
    });
    else {
        var _ = require("17462749b095c120"), $;
        try {
            $ = require("ddeacdd3a3586f70");
        } catch (e) {}
        factory(root, exports, _, $);
    }
})(function(root, Backbone, _, $) {
    // Initial Setup
    // -------------
    // Save the previous value of the `Backbone` variable, so that it can be
    // restored later on, if `noConflict` is used.
    var previousBackbone = root.Backbone;
    // Create a local reference to a common array method we'll want to use later.
    var slice = Array.prototype.slice;
    // Current version of the library. Keep in sync with `package.json`.
    Backbone.VERSION = "1.4.1";
    // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
    // the `$` variable.
    Backbone.$ = $;
    // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
    // to its previous owner. Returns a reference to this Backbone object.
    Backbone.noConflict = function() {
        root.Backbone = previousBackbone;
        return this;
    };
    // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
    // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
    // set a `X-Http-Method-Override` header.
    Backbone.emulateHTTP = false;
    // Turn on `emulateJSON` to support legacy servers that can't deal with direct
    // `application/json` requests ... this will encode the body as
    // `application/x-www-form-urlencoded` instead and will send the model in a
    // form param named `model`.
    Backbone.emulateJSON = false;
    // Backbone.Events
    // ---------------
    // A module that can be mixed in to *any object* in order to provide it with
    // a custom event channel. You may bind a callback to an event with `on` or
    // remove with `off`; `trigger`-ing an event fires all callbacks in
    // succession.
    //
    //     var object = {};
    //     _.extend(object, Backbone.Events);
    //     object.on('expand', function(){ alert('expanded'); });
    //     object.trigger('expand');
    //
    var Events = Backbone.Events = {};
    // Regular expression used to split event strings.
    var eventSplitter = /\s+/;
    // A private global variable to share between listeners and listenees.
    var _listening;
    // Iterates over the standard `event, callback` (as well as the fancy multiple
    // space-separated events `"change blur", callback` and jQuery-style event
    // maps `{event: callback}`).
    var eventsApi = function(iteratee, events, name, callback, opts) {
        var i = 0, names;
        if (name && typeof name === "object") {
            // Handle event maps.
            if (callback !== void 0 && "context" in opts && opts.context === void 0) opts.context = callback;
            for(names = _.keys(name); i < names.length; i++)events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
        } else if (name && eventSplitter.test(name)) // Handle space-separated event names by delegating them individually.
        for(names = name.split(eventSplitter); i < names.length; i++)events = iteratee(events, names[i], callback, opts);
        else // Finally, standard events.
        events = iteratee(events, name, callback, opts);
        return events;
    };
    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    Events.on = function(name, callback, context) {
        this._events = eventsApi(onApi, this._events || {}, name, callback, {
            context: context,
            ctx: this,
            listening: _listening
        });
        if (_listening) {
            var listeners = this._listeners || (this._listeners = {});
            listeners[_listening.id] = _listening;
            // Allow the listening to use a counter, instead of tracking
            // callbacks for library interop
            _listening.interop = false;
        }
        return this;
    };
    // Inversion-of-control versions of `on`. Tell *this* object to listen to
    // an event in another object... keeping track of what it's listening to
    // for easier unbinding later.
    Events.listenTo = function(obj, name, callback) {
        if (!obj) return this;
        var id = obj._listenId || (obj._listenId = _.uniqueId("l"));
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var listening = _listening = listeningTo[id];
        // This object is not listening to any other events on `obj` yet.
        // Setup the necessary references to track the listening callbacks.
        if (!listening) {
            this._listenId || (this._listenId = _.uniqueId("l"));
            listening = _listening = listeningTo[id] = new Listening(this, obj);
        }
        // Bind callbacks on obj.
        var error = tryCatchOn(obj, name, callback, this);
        _listening = void 0;
        if (error) throw error;
        // If the target obj is not Backbone.Events, track events manually.
        if (listening.interop) listening.on(name, callback);
        return this;
    };
    // The reducing API that adds a callback to the `events` object.
    var onApi = function(events, name, callback, options) {
        if (callback) {
            var handlers = events[name] || (events[name] = []);
            var context = options.context, ctx = options.ctx, listening = options.listening;
            if (listening) listening.count++;
            handlers.push({
                callback: callback,
                context: context,
                ctx: context || ctx,
                listening: listening
            });
        }
        return events;
    };
    // An try-catch guarded #on function, to prevent poisoning the global
    // `_listening` variable.
    var tryCatchOn = function(obj, name, callback, context) {
        try {
            obj.on(name, callback, context);
        } catch (e) {
            return e;
        }
    };
    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    Events.off = function(name, callback, context) {
        if (!this._events) return this;
        this._events = eventsApi(offApi, this._events, name, callback, {
            context: context,
            listeners: this._listeners
        });
        return this;
    };
    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    Events.stopListening = function(obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo) return this;
        var ids = obj ? [
            obj._listenId
        ] : _.keys(listeningTo);
        for(var i = 0; i < ids.length; i++){
            var listening = listeningTo[ids[i]];
            // If listening doesn't exist, this object is not currently
            // listening to obj. Break out early.
            if (!listening) break;
            listening.obj.off(name, callback, this);
            if (listening.interop) listening.off(name, callback);
        }
        if (_.isEmpty(listeningTo)) this._listeningTo = void 0;
        return this;
    };
    // The reducing API that removes a callback from the `events` object.
    var offApi = function(events, name, callback, options) {
        if (!events) return;
        var context = options.context, listeners = options.listeners;
        var i = 0, names;
        // Delete all event listeners and "drop" events.
        if (!name && !context && !callback) {
            for(names = _.keys(listeners); i < names.length; i++)listeners[names[i]].cleanup();
            return;
        }
        names = name ? [
            name
        ] : _.keys(events);
        for(; i < names.length; i++){
            name = names[i];
            var handlers = events[name];
            // Bail out if there are no events stored.
            if (!handlers) break;
            // Find any remaining events.
            var remaining = [];
            for(var j = 0; j < handlers.length; j++){
                var handler = handlers[j];
                if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) remaining.push(handler);
                else {
                    var listening = handler.listening;
                    if (listening) listening.off(name, callback);
                }
            }
            // Replace events if there are any remaining.  Otherwise, clean up.
            if (remaining.length) events[name] = remaining;
            else delete events[name];
        }
        return events;
    };
    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, its listener will be removed. If multiple events
    // are passed in using the space-separated syntax, the handler will fire
    // once for each event, not once for a combination of all events.
    Events.once = function(name, callback, context) {
        // Map the event into a `{event: once}` object.
        var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));
        if (typeof name === "string" && context == null) callback = void 0;
        return this.on(events, callback, context);
    };
    // Inversion-of-control versions of `once`.
    Events.listenToOnce = function(obj, name, callback) {
        // Map the event into a `{event: once}` object.
        var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));
        return this.listenTo(obj, events);
    };
    // Reduces the event callbacks into a map of `{event: onceWrapper}`.
    // `offer` unbinds the `onceWrapper` after it has been called.
    var onceMap = function(map, name, callback, offer) {
        if (callback) {
            var once = map[name] = _.once(function() {
                offer(name, once);
                callback.apply(this, arguments);
            });
            once._callback = callback;
        }
        return map;
    };
    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    Events.trigger = function(name) {
        if (!this._events) return this;
        var length = Math.max(0, arguments.length - 1);
        var args = Array(length);
        for(var i = 0; i < length; i++)args[i] = arguments[i + 1];
        eventsApi(triggerApi, this._events, name, void 0, args);
        return this;
    };
    // Handles triggering the appropriate event callbacks.
    var triggerApi = function(objEvents, name, callback, args) {
        if (objEvents) {
            var events = objEvents[name];
            var allEvents = objEvents.all;
            if (events && allEvents) allEvents = allEvents.slice();
            if (events) triggerEvents(events, args);
            if (allEvents) triggerEvents(allEvents, [
                name
            ].concat(args));
        }
        return objEvents;
    };
    // A difficult-to-believe, but optimized internal dispatch function for
    // triggering events. Tries to keep the usual cases speedy (most internal
    // Backbone events have 3 arguments).
    var triggerEvents = function(events, args) {
        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
        switch(args.length){
            case 0:
                while(++i < l)(ev = events[i]).callback.call(ev.ctx);
                return;
            case 1:
                while(++i < l)(ev = events[i]).callback.call(ev.ctx, a1);
                return;
            case 2:
                while(++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2);
                return;
            case 3:
                while(++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
                return;
            default:
                while(++i < l)(ev = events[i]).callback.apply(ev.ctx, args);
                return;
        }
    };
    // A listening class that tracks and cleans up memory bindings
    // when all callbacks have been offed.
    var Listening = function(listener, obj) {
        this.id = listener._listenId;
        this.listener = listener;
        this.obj = obj;
        this.interop = true;
        this.count = 0;
        this._events = void 0;
    };
    Listening.prototype.on = Events.on;
    // Offs a callback (or several).
    // Uses an optimized counter if the listenee uses Backbone.Events.
    // Otherwise, falls back to manual tracking to support events
    // library interop.
    Listening.prototype.off = function(name, callback) {
        var cleanup;
        if (this.interop) {
            this._events = eventsApi(offApi, this._events, name, callback, {
                context: void 0,
                listeners: void 0
            });
            cleanup = !this._events;
        } else {
            this.count--;
            cleanup = this.count === 0;
        }
        if (cleanup) this.cleanup();
    };
    // Cleans up memory bindings between the listener and the listenee.
    Listening.prototype.cleanup = function() {
        delete this.listener._listeningTo[this.obj._listenId];
        if (!this.interop) delete this.obj._listeners[this.id];
    };
    // Aliases for backwards compatibility.
    Events.bind = Events.on;
    Events.unbind = Events.off;
    // Allow the `Backbone` object to serve as a global event bus, for folks who
    // want global "pubsub" in a convenient place.
    _.extend(Backbone, Events);
    // Backbone.Model
    // --------------
    // Backbone **Models** are the basic data object in the framework --
    // frequently representing a row in a table in a database on your server.
    // A discrete chunk of data and a bunch of useful, related methods for
    // performing computations and transformations on that data.
    // Create a new model with the specified attributes. A client id (`cid`)
    // is automatically generated and assigned for you.
    var Model = Backbone.Model = function(attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.preinitialize.apply(this, arguments);
        this.cid = _.uniqueId(this.cidPrefix);
        this.attributes = {};
        if (options.collection) this.collection = options.collection;
        if (options.parse) attrs = this.parse(attrs, options) || {};
        var defaults = _.result(this, "defaults");
        attrs = _.defaults(_.extend({}, defaults, attrs), defaults);
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
    };
    // Attach all inheritable methods to the Model prototype.
    _.extend(Model.prototype, Events, {
        // A hash of attributes whose current and previous value differ.
        changed: null,
        // The value returned during the last failed validation.
        validationError: null,
        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: "id",
        // The prefix is used to create the client id which is used to identify models locally.
        // You may want to override this if you're experiencing name clashes with model ids.
        cidPrefix: "c",
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Model.
        preinitialize: function() {},
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},
        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
            return _.clone(this.attributes);
        },
        // Proxy `Backbone.sync` by default -- but override this if you need
        // custom syncing semantics for *this* particular model.
        sync: function() {
            return Backbone.sync.apply(this, arguments);
        },
        // Get the value of an attribute.
        get: function(attr) {
            return this.attributes[attr];
        },
        // Get the HTML-escaped value of an attribute.
        escape: function(attr) {
            return _.escape(this.get(attr));
        },
        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr) {
            return this.get(attr) != null;
        },
        // Special-cased proxy to underscore's `_.matches` method.
        matches: function(attrs) {
            return !!_.iteratee(attrs, this)(this.attributes);
        },
        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function(key, val, options) {
            if (key == null) return this;
            // Handle both `"key", value` and `{key: value}` -style arguments.
            var attrs;
            if (typeof key === "object") {
                attrs = key;
                options = val;
            } else (attrs = {})[key] = val;
            options || (options = {});
            // Run validation.
            if (!this._validate(attrs, options)) return false;
            // Extract attributes and options.
            var unset = options.unset;
            var silent = options.silent;
            var changes = [];
            var changing = this._changing;
            this._changing = true;
            if (!changing) {
                this._previousAttributes = _.clone(this.attributes);
                this.changed = {};
            }
            var current = this.attributes;
            var changed = this.changed;
            var prev = this._previousAttributes;
            // For each `set` attribute, update or delete the current value.
            for(var attr in attrs){
                val = attrs[attr];
                if (!_.isEqual(current[attr], val)) changes.push(attr);
                if (!_.isEqual(prev[attr], val)) changed[attr] = val;
                else delete changed[attr];
                unset ? delete current[attr] : current[attr] = val;
            }
            // Update the `id`.
            if (this.idAttribute in attrs) {
                var prevId = this.id;
                this.id = this.get(this.idAttribute);
                this.trigger("changeId", this, prevId, options);
            }
            // Trigger all relevant attribute changes.
            if (!silent) {
                if (changes.length) this._pending = options;
                for(var i = 0; i < changes.length; i++)this.trigger("change:" + changes[i], this, current[changes[i]], options);
            }
            // You might be wondering why there's a `while` loop here. Changes can
            // be recursively nested within `"change"` events.
            if (changing) return this;
            if (!silent) while(this._pending){
                options = this._pending;
                this._pending = false;
                this.trigger("change", this, options);
            }
            this._pending = false;
            this._changing = false;
            return this;
        },
        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function(attr, options) {
            return this.set(attr, void 0, _.extend({}, options, {
                unset: true
            }));
        },
        // Clear all attributes on the model, firing `"change"`.
        clear: function(options) {
            var attrs = {};
            for(var key in this.attributes)attrs[key] = void 0;
            return this.set(attrs, _.extend({}, options, {
                unset: true
            }));
        },
        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
            if (attr == null) return !_.isEmpty(this.changed);
            return _.has(this.changed, attr);
        },
        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
            if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
            var old = this._changing ? this._previousAttributes : this.attributes;
            var changed = {};
            var hasChanged;
            for(var attr in diff){
                var val = diff[attr];
                if (_.isEqual(old[attr], val)) continue;
                changed[attr] = val;
                hasChanged = true;
            }
            return hasChanged ? changed : false;
        },
        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
            if (attr == null || !this._previousAttributes) return null;
            return this._previousAttributes[attr];
        },
        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
            return _.clone(this._previousAttributes);
        },
        // Fetch the model from the server, merging the response with the model's
        // local attributes. Any changed attributes will trigger a "change" event.
        fetch: function(options) {
            options = _.extend({
                parse: true
            }, options);
            var model = this;
            var success = options.success;
            options.success = function(resp) {
                var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                if (!model.set(serverAttrs, options)) return false;
                if (success) success.call(options.context, model, resp, options);
                model.trigger("sync", model, resp, options);
            };
            wrapError(this, options);
            return this.sync("read", this, options);
        },
        // Set a hash of model attributes, and sync the model to the server.
        // If the server returns an attributes hash that differs, the model's
        // state will be `set` again.
        save: function(key, val, options) {
            // Handle both `"key", value` and `{key: value}` -style arguments.
            var attrs;
            if (key == null || typeof key === "object") {
                attrs = key;
                options = val;
            } else (attrs = {})[key] = val;
            options = _.extend({
                validate: true,
                parse: true
            }, options);
            var wait = options.wait;
            // If we're not waiting and attributes exist, save acts as
            // `set(attr).save(null, opts)` with validation. Otherwise, check if
            // the model will be valid when the attributes, if any, are set.
            if (attrs && !wait) {
                if (!this.set(attrs, options)) return false;
            } else if (!this._validate(attrs, options)) return false;
            // After a successful server-side save, the client is (optionally)
            // updated with the server-side state.
            var model = this;
            var success = options.success;
            var attributes = this.attributes;
            options.success = function(resp) {
                // Ensure attributes are restored during synchronous saves.
                model.attributes = attributes;
                var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
                if (serverAttrs && !model.set(serverAttrs, options)) return false;
                if (success) success.call(options.context, model, resp, options);
                model.trigger("sync", model, resp, options);
            };
            wrapError(this, options);
            // Set temporary attributes if `{wait: true}` to properly find new ids.
            if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);
            var method = this.isNew() ? "create" : options.patch ? "patch" : "update";
            if (method === "patch" && !options.attrs) options.attrs = attrs;
            var xhr = this.sync(method, this, options);
            // Restore attributes.
            this.attributes = attributes;
            return xhr;
        },
        // Destroy this model on the server if it was already persisted.
        // Optimistically removes the model from its collection, if it has one.
        // If `wait: true` is passed, waits for the server to respond before removal.
        destroy: function(options) {
            options = options ? _.clone(options) : {};
            var model = this;
            var success = options.success;
            var wait = options.wait;
            var destroy = function() {
                model.stopListening();
                model.trigger("destroy", model, model.collection, options);
            };
            options.success = function(resp) {
                if (wait) destroy();
                if (success) success.call(options.context, model, resp, options);
                if (!model.isNew()) model.trigger("sync", model, resp, options);
            };
            var xhr = false;
            if (this.isNew()) _.defer(options.success);
            else {
                wrapError(this, options);
                xhr = this.sync("delete", this, options);
            }
            if (!wait) destroy();
            return xhr;
        },
        // Default URL for the model's representation on the server -- if you're
        // using Backbone's restful methods, override this to change the endpoint
        // that will be called.
        url: function() {
            var base = _.result(this, "urlRoot") || _.result(this.collection, "url") || urlError();
            if (this.isNew()) return base;
            var id = this.get(this.idAttribute);
            return base.replace(/[^\/]$/, "$&/") + encodeURIComponent(id);
        },
        // **parse** converts a response into the hash of attributes to be `set` on
        // the model. The default implementation is just to pass the response along.
        parse: function(resp, options) {
            return resp;
        },
        // Create a new model with identical attributes to this one.
        clone: function() {
            return new this.constructor(this.attributes);
        },
        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function() {
            return !this.has(this.idAttribute);
        },
        // Check if the model is currently in a valid state.
        isValid: function(options) {
            return this._validate({}, _.extend({}, options, {
                validate: true
            }));
        },
        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function(attrs, options) {
            if (!options.validate || !this.validate) return true;
            attrs = _.extend({}, this.attributes, attrs);
            var error = this.validationError = this.validate(attrs, options) || null;
            if (!error) return true;
            this.trigger("invalid", this, error, _.extend(options, {
                validationError: error
            }));
            return false;
        }
    });
    // Backbone.Collection
    // -------------------
    // If models tend to represent a single row of data, a Backbone Collection is
    // more analogous to a table full of data ... or a small slice or page of that
    // table, or a collection of rows that belong together for a particular reason
    // -- all of the messages in this particular folder, all of the documents
    // belonging to this particular author, and so on. Collections maintain
    // indexes of their models, both in order, and for lookup by `id`.
    // Create a new **Collection**, perhaps to contain a specific type of `model`.
    // If a `comparator` is specified, the Collection will maintain
    // its models in sort order, as they're added and removed.
    var Collection = Backbone.Collection = function(models, options) {
        options || (options = {});
        this.preinitialize.apply(this, arguments);
        if (options.model) this.model = options.model;
        if (options.comparator !== void 0) this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models) this.reset(models, _.extend({
            silent: true
        }, options));
    };
    // Default options for `Collection#set`.
    var setOptions = {
        add: true,
        remove: true,
        merge: true
    };
    var addOptions = {
        add: true,
        remove: false
    };
    // Splices `insert` into `array` at index `at`.
    var splice = function(array, insert, at) {
        at = Math.min(Math.max(at, 0), array.length);
        var tail = Array(array.length - at);
        var length = insert.length;
        var i;
        for(i = 0; i < tail.length; i++)tail[i] = array[i + at];
        for(i = 0; i < length; i++)array[i + at] = insert[i];
        for(i = 0; i < tail.length; i++)array[i + length + at] = tail[i];
    };
    // Define the Collection's inheritable methods.
    _.extend(Collection.prototype, Events, {
        // The default model for a collection is just a **Backbone.Model**.
        // This should be overridden in most cases.
        model: Model,
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Collection.
        preinitialize: function() {},
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},
        // The JSON representation of a Collection is an array of the
        // models' attributes.
        toJSON: function(options) {
            return this.map(function(model) {
                return model.toJSON(options);
            });
        },
        // Proxy `Backbone.sync` by default.
        sync: function() {
            return Backbone.sync.apply(this, arguments);
        },
        // Add a model, or list of models to the set. `models` may be Backbone
        // Models or raw JavaScript objects to be converted to Models, or any
        // combination of the two.
        add: function(models, options) {
            return this.set(models, _.extend({
                merge: false
            }, options, addOptions));
        },
        // Remove a model, or a list of models from the set.
        remove: function(models, options) {
            options = _.extend({}, options);
            var singular = !_.isArray(models);
            models = singular ? [
                models
            ] : models.slice();
            var removed = this._removeModels(models, options);
            if (!options.silent && removed.length) {
                options.changes = {
                    added: [],
                    merged: [],
                    removed: removed
                };
                this.trigger("update", this, options);
            }
            return singular ? removed[0] : removed;
        },
        // Update a collection by `set`-ing a new list of models, adding new ones,
        // removing models that are no longer present, and merging models that
        // already exist in the collection, as necessary. Similar to **Model#set**,
        // the core operation for updating the data contained by the collection.
        set: function(models, options) {
            if (models == null) return;
            options = _.extend({}, setOptions, options);
            if (options.parse && !this._isModel(models)) models = this.parse(models, options) || [];
            var singular = !_.isArray(models);
            models = singular ? [
                models
            ] : models.slice();
            var at = options.at;
            if (at != null) at = +at;
            if (at > this.length) at = this.length;
            if (at < 0) at += this.length + 1;
            var set = [];
            var toAdd = [];
            var toMerge = [];
            var toRemove = [];
            var modelMap = {};
            var add = options.add;
            var merge = options.merge;
            var remove = options.remove;
            var sort = false;
            var sortable = this.comparator && at == null && options.sort !== false;
            var sortAttr = _.isString(this.comparator) ? this.comparator : null;
            // Turn bare objects into model references, and prevent invalid models
            // from being added.
            var model, i;
            for(i = 0; i < models.length; i++){
                model = models[i];
                // If a duplicate is found, prevent it from being added and
                // optionally merge it into the existing model.
                var existing = this.get(model);
                if (existing) {
                    if (merge && model !== existing) {
                        var attrs = this._isModel(model) ? model.attributes : model;
                        if (options.parse) attrs = existing.parse(attrs, options);
                        existing.set(attrs, options);
                        toMerge.push(existing);
                        if (sortable && !sort) sort = existing.hasChanged(sortAttr);
                    }
                    if (!modelMap[existing.cid]) {
                        modelMap[existing.cid] = true;
                        set.push(existing);
                    }
                    models[i] = existing;
                // If this is a new, valid model, push it to the `toAdd` list.
                } else if (add) {
                    model = models[i] = this._prepareModel(model, options);
                    if (model) {
                        toAdd.push(model);
                        this._addReference(model, options);
                        modelMap[model.cid] = true;
                        set.push(model);
                    }
                }
            }
            // Remove stale models.
            if (remove) {
                for(i = 0; i < this.length; i++){
                    model = this.models[i];
                    if (!modelMap[model.cid]) toRemove.push(model);
                }
                if (toRemove.length) this._removeModels(toRemove, options);
            }
            // See if sorting is needed, update `length` and splice in new models.
            var orderChanged = false;
            var replace = !sortable && add && remove;
            if (set.length && replace) {
                orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {
                    return m !== set[index];
                });
                this.models.length = 0;
                splice(this.models, set, 0);
                this.length = this.models.length;
            } else if (toAdd.length) {
                if (sortable) sort = true;
                splice(this.models, toAdd, at == null ? this.length : at);
                this.length = this.models.length;
            }
            // Silently sort the collection if appropriate.
            if (sort) this.sort({
                silent: true
            });
            // Unless silenced, it's time to fire all appropriate add/sort/update events.
            if (!options.silent) {
                for(i = 0; i < toAdd.length; i++){
                    if (at != null) options.index = at + i;
                    model = toAdd[i];
                    model.trigger("add", model, this, options);
                }
                if (sort || orderChanged) this.trigger("sort", this, options);
                if (toAdd.length || toRemove.length || toMerge.length) {
                    options.changes = {
                        added: toAdd,
                        removed: toRemove,
                        merged: toMerge
                    };
                    this.trigger("update", this, options);
                }
            }
            // Return the added (or merged) model (or models).
            return singular ? models[0] : models;
        },
        // When you have more items than you want to add or remove individually,
        // you can reset the entire set with a new list of models, without firing
        // any granular `add` or `remove` events. Fires `reset` when finished.
        // Useful for bulk operations and optimizations.
        reset: function(models, options) {
            options = options ? _.clone(options) : {};
            for(var i = 0; i < this.models.length; i++)this._removeReference(this.models[i], options);
            options.previousModels = this.models;
            this._reset();
            models = this.add(models, _.extend({
                silent: true
            }, options));
            if (!options.silent) this.trigger("reset", this, options);
            return models;
        },
        // Add a model to the end of the collection.
        push: function(model, options) {
            return this.add(model, _.extend({
                at: this.length
            }, options));
        },
        // Remove a model from the end of the collection.
        pop: function(options) {
            var model = this.at(this.length - 1);
            return this.remove(model, options);
        },
        // Add a model to the beginning of the collection.
        unshift: function(model, options) {
            return this.add(model, _.extend({
                at: 0
            }, options));
        },
        // Remove a model from the beginning of the collection.
        shift: function(options) {
            var model = this.at(0);
            return this.remove(model, options);
        },
        // Slice out a sub-array of models from the collection.
        slice: function() {
            return slice.apply(this.models, arguments);
        },
        // Get a model from the set by id, cid, model object with id or cid
        // properties, or an attributes object that is transformed through modelId.
        get: function(obj) {
            if (obj == null) return void 0;
            return this._byId[obj] || this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj, obj.idAttribute)] || obj.cid && this._byId[obj.cid];
        },
        // Returns `true` if the model is in the collection.
        has: function(obj) {
            return this.get(obj) != null;
        },
        // Get the model at the given index.
        at: function(index) {
            if (index < 0) index += this.length;
            return this.models[index];
        },
        // Return models with matching attributes. Useful for simple cases of
        // `filter`.
        where: function(attrs, first) {
            return this[first ? "find" : "filter"](attrs);
        },
        // Return the first model with matching attributes. Useful for simple cases
        // of `find`.
        findWhere: function(attrs) {
            return this.where(attrs, true);
        },
        // Force the collection to re-sort itself. You don't need to call this under
        // normal circumstances, as the set will maintain sort order as each item
        // is added.
        sort: function(options) {
            var comparator = this.comparator;
            if (!comparator) throw new Error("Cannot sort a set without a comparator");
            options || (options = {});
            var length = comparator.length;
            if (_.isFunction(comparator)) comparator = comparator.bind(this);
            // Run sort based on type of `comparator`.
            if (length === 1 || _.isString(comparator)) this.models = this.sortBy(comparator);
            else this.models.sort(comparator);
            if (!options.silent) this.trigger("sort", this, options);
            return this;
        },
        // Pluck an attribute from each model in the collection.
        pluck: function(attr) {
            return this.map(attr + "");
        },
        // Fetch the default set of models for this collection, resetting the
        // collection when they arrive. If `reset: true` is passed, the response
        // data will be passed through the `reset` method instead of `set`.
        fetch: function(options) {
            options = _.extend({
                parse: true
            }, options);
            var success = options.success;
            var collection = this;
            options.success = function(resp) {
                var method = options.reset ? "reset" : "set";
                collection[method](resp, options);
                if (success) success.call(options.context, collection, resp, options);
                collection.trigger("sync", collection, resp, options);
            };
            wrapError(this, options);
            return this.sync("read", this, options);
        },
        // Create a new instance of a model in this collection. Add the model to the
        // collection immediately, unless `wait: true` is passed, in which case we
        // wait for the server to agree.
        create: function(model, options) {
            options = options ? _.clone(options) : {};
            var wait = options.wait;
            model = this._prepareModel(model, options);
            if (!model) return false;
            if (!wait) this.add(model, options);
            var collection = this;
            var success = options.success;
            options.success = function(m, resp, callbackOpts) {
                if (wait) collection.add(m, callbackOpts);
                if (success) success.call(callbackOpts.context, m, resp, callbackOpts);
            };
            model.save(null, options);
            return model;
        },
        // **parse** converts a response into a list of models to be added to the
        // collection. The default implementation is just to pass it through.
        parse: function(resp, options) {
            return resp;
        },
        // Create a new collection with an identical list of models as this one.
        clone: function() {
            return new this.constructor(this.models, {
                model: this.model,
                comparator: this.comparator
            });
        },
        // Define how to uniquely identify models in the collection.
        modelId: function(attrs, idAttribute) {
            return attrs[idAttribute || this.model.prototype.idAttribute || "id"];
        },
        // Get an iterator of all models in this collection.
        values: function() {
            return new CollectionIterator(this, ITERATOR_VALUES);
        },
        // Get an iterator of all model IDs in this collection.
        keys: function() {
            return new CollectionIterator(this, ITERATOR_KEYS);
        },
        // Get an iterator of all [ID, model] tuples in this collection.
        entries: function() {
            return new CollectionIterator(this, ITERATOR_KEYSVALUES);
        },
        // Private method to reset all internal state. Called when the collection
        // is first initialized or reset.
        _reset: function() {
            this.length = 0;
            this.models = [];
            this._byId = {};
        },
        // Prepare a hash of attributes (or other model) to be added to this
        // collection.
        _prepareModel: function(attrs, options) {
            if (this._isModel(attrs)) {
                if (!attrs.collection) attrs.collection = this;
                return attrs;
            }
            options = options ? _.clone(options) : {};
            options.collection = this;
            var model;
            if (this.model.prototype) model = new this.model(attrs, options);
            else // ES class methods didn't have prototype
            model = this.model(attrs, options);
            if (!model.validationError) return model;
            this.trigger("invalid", this, model.validationError, options);
            return false;
        },
        // Internal method called by both remove and set.
        _removeModels: function(models, options) {
            var removed = [];
            for(var i = 0; i < models.length; i++){
                var model = this.get(models[i]);
                if (!model) continue;
                var index = this.indexOf(model);
                this.models.splice(index, 1);
                this.length--;
                // Remove references before triggering 'remove' event to prevent an
                // infinite loop. #3693
                delete this._byId[model.cid];
                var id = this.modelId(model.attributes, model.idAttribute);
                if (id != null) delete this._byId[id];
                if (!options.silent) {
                    options.index = index;
                    model.trigger("remove", model, this, options);
                }
                removed.push(model);
                this._removeReference(model, options);
            }
            return removed;
        },
        // Method for checking whether an object should be considered a model for
        // the purposes of adding to the collection.
        _isModel: function(model) {
            return model instanceof Model;
        },
        // Internal method to create a model's ties to a collection.
        _addReference: function(model, options) {
            this._byId[model.cid] = model;
            var id = this.modelId(model.attributes, model.idAttribute);
            if (id != null) this._byId[id] = model;
            model.on("all", this._onModelEvent, this);
        },
        // Internal method to sever a model's ties to a collection.
        _removeReference: function(model, options) {
            delete this._byId[model.cid];
            var id = this.modelId(model.attributes, model.idAttribute);
            if (id != null) delete this._byId[id];
            if (this === model.collection) delete model.collection;
            model.off("all", this._onModelEvent, this);
        },
        // Internal method called every time a model in the set fires an event.
        // Sets need to update their indexes when models change ids. All other
        // events simply proxy through. "add" and "remove" events that originate
        // in other collections are ignored.
        _onModelEvent: function(event, model, collection, options) {
            if (model) {
                if ((event === "add" || event === "remove") && collection !== this) return;
                if (event === "destroy") this.remove(model, options);
                if (event === "changeId") {
                    var prevId = this.modelId(model.previousAttributes(), model.idAttribute);
                    var id = this.modelId(model.attributes, model.idAttribute);
                    if (prevId != null) delete this._byId[prevId];
                    if (id != null) this._byId[id] = model;
                }
            }
            this.trigger.apply(this, arguments);
        }
    });
    // Defining an @@iterator method implements JavaScript's Iterable protocol.
    // In modern ES2015 browsers, this value is found at Symbol.iterator.
    /* global Symbol */ var $$iterator = typeof Symbol === "function" && Symbol.iterator;
    if ($$iterator) Collection.prototype[$$iterator] = Collection.prototype.values;
    // CollectionIterator
    // ------------------
    // A CollectionIterator implements JavaScript's Iterator protocol, allowing the
    // use of `for of` loops in modern browsers and interoperation between
    // Backbone.Collection and other JavaScript functions and third-party libraries
    // which can operate on Iterables.
    var CollectionIterator = function(collection, kind) {
        this._collection = collection;
        this._kind = kind;
        this._index = 0;
    };
    // This "enum" defines the three possible kinds of values which can be emitted
    // by a CollectionIterator that correspond to the values(), keys() and entries()
    // methods on Collection, respectively.
    var ITERATOR_VALUES = 1;
    var ITERATOR_KEYS = 2;
    var ITERATOR_KEYSVALUES = 3;
    // All Iterators should themselves be Iterable.
    if ($$iterator) CollectionIterator.prototype[$$iterator] = function() {
        return this;
    };
    CollectionIterator.prototype.next = function() {
        if (this._collection) {
            // Only continue iterating if the iterated collection is long enough.
            if (this._index < this._collection.length) {
                var model = this._collection.at(this._index);
                this._index++;
                // Construct a value depending on what kind of values should be iterated.
                var value;
                if (this._kind === ITERATOR_VALUES) value = model;
                else {
                    var id = this._collection.modelId(model.attributes, model.idAttribute);
                    if (this._kind === ITERATOR_KEYS) value = id;
                    else value = [
                        id,
                        model
                    ];
                }
                return {
                    value: value,
                    done: false
                };
            }
            // Once exhausted, remove the reference to the collection so future
            // calls to the next method always return done.
            this._collection = void 0;
        }
        return {
            value: void 0,
            done: true
        };
    };
    // Backbone.View
    // -------------
    // Backbone Views are almost more convention than they are actual code. A View
    // is simply a JavaScript object that represents a logical chunk of UI in the
    // DOM. This might be a single item, an entire list, a sidebar or panel, or
    // even the surrounding frame which wraps your whole app. Defining a chunk of
    // UI as a **View** allows you to define your DOM events declaratively, without
    // having to worry about render order ... and makes it easy for the view to
    // react to specific changes in the state of your models.
    // Creating a Backbone.View creates its initial element outside of the DOM,
    // if an existing element is not provided...
    var View = Backbone.View = function(options) {
        this.cid = _.uniqueId("view");
        this.preinitialize.apply(this, arguments);
        _.extend(this, _.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
    };
    // Cached regex to split keys for `delegate`.
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;
    // List of view options to be set as properties.
    var viewOptions = [
        "model",
        "collection",
        "el",
        "id",
        "attributes",
        "className",
        "tagName",
        "events"
    ];
    // Set up all inheritable **Backbone.View** properties and methods.
    _.extend(View.prototype, Events, {
        // The default `tagName` of a View's element is `"div"`.
        tagName: "div",
        // jQuery delegate for element lookup, scoped to DOM elements within the
        // current view. This should be preferred to global lookups where possible.
        $: function(selector) {
            return this.$el.find(selector);
        },
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the View
        preinitialize: function() {},
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},
        // **render** is the core function that your view should override, in order
        // to populate its element (`this.el`), with the appropriate HTML. The
        // convention is for **render** to always return `this`.
        render: function() {
            return this;
        },
        // Remove this view by taking the element out of the DOM, and removing any
        // applicable Backbone.Events listeners.
        remove: function() {
            this._removeElement();
            this.stopListening();
            return this;
        },
        // Remove this view's element from the document and all event listeners
        // attached to it. Exposed for subclasses using an alternative DOM
        // manipulation API.
        _removeElement: function() {
            this.$el.remove();
        },
        // Change the view's element (`this.el` property) and re-delegate the
        // view's events on the new element.
        setElement: function(element) {
            this.undelegateEvents();
            this._setElement(element);
            this.delegateEvents();
            return this;
        },
        // Creates the `this.el` and `this.$el` references for this view using the
        // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
        // context or an element. Subclasses can override this to utilize an
        // alternative DOM manipulation API and are only required to set the
        // `this.el` property.
        _setElement: function(el) {
            this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
            this.el = this.$el[0];
        },
        // Set callbacks, where `this.events` is a hash of
        //
        // *{"event selector": "callback"}*
        //
        //     {
        //       'mousedown .title':  'edit',
        //       'click .button':     'save',
        //       'click .open':       function(e) { ... }
        //     }
        //
        // pairs. Callbacks will be bound to the view, with `this` set properly.
        // Uses event delegation for efficiency.
        // Omitting the selector binds the event to `this.el`.
        delegateEvents: function(events) {
            events || (events = _.result(this, "events"));
            if (!events) return this;
            this.undelegateEvents();
            for(var key in events){
                var method = events[key];
                if (!_.isFunction(method)) method = this[method];
                if (!method) continue;
                var match = key.match(delegateEventSplitter);
                this.delegate(match[1], match[2], method.bind(this));
            }
            return this;
        },
        // Add a single event listener to the view's element (or a child element
        // using `selector`). This only works for delegate-able events: not `focus`,
        // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
        delegate: function(eventName, selector, listener) {
            this.$el.on(eventName + ".delegateEvents" + this.cid, selector, listener);
            return this;
        },
        // Clears all callbacks previously bound to the view by `delegateEvents`.
        // You usually don't need to use this, but may wish to if you have multiple
        // Backbone views attached to the same DOM element.
        undelegateEvents: function() {
            if (this.$el) this.$el.off(".delegateEvents" + this.cid);
            return this;
        },
        // A finer-grained `undelegateEvents` for removing a single delegated event.
        // `selector` and `listener` are both optional.
        undelegate: function(eventName, selector, listener) {
            this.$el.off(eventName + ".delegateEvents" + this.cid, selector, listener);
            return this;
        },
        // Produces a DOM element to be assigned to your view. Exposed for
        // subclasses using an alternative DOM manipulation API.
        _createElement: function(tagName) {
            return document.createElement(tagName);
        },
        // Ensure that the View has a DOM element to render into.
        // If `this.el` is a string, pass it through `$()`, take the first
        // matching element, and re-assign it to `el`. Otherwise, create
        // an element from the `id`, `className` and `tagName` properties.
        _ensureElement: function() {
            if (!this.el) {
                var attrs = _.extend({}, _.result(this, "attributes"));
                if (this.id) attrs.id = _.result(this, "id");
                if (this.className) attrs["class"] = _.result(this, "className");
                this.setElement(this._createElement(_.result(this, "tagName")));
                this._setAttributes(attrs);
            } else this.setElement(_.result(this, "el"));
        },
        // Set attributes from a hash on this view's element.  Exposed for
        // subclasses using an alternative DOM manipulation API.
        _setAttributes: function(attributes) {
            this.$el.attr(attributes);
        }
    });
    // Proxy Backbone class methods to Underscore functions, wrapping the model's
    // `attributes` object or collection's `models` array behind the scenes.
    //
    // collection.filter(function(model) { return model.get('age') > 10 });
    // collection.each(this.addView);
    //
    // `Function#apply` can be slow so we use the method's arg count, if we know it.
    var addMethod = function(base, length, method, attribute) {
        switch(length){
            case 1:
                return function() {
                    return base[method](this[attribute]);
                };
            case 2:
                return function(value) {
                    return base[method](this[attribute], value);
                };
            case 3:
                return function(iteratee, context) {
                    return base[method](this[attribute], cb(iteratee, this), context);
                };
            case 4:
                return function(iteratee, defaultVal, context) {
                    return base[method](this[attribute], cb(iteratee, this), defaultVal, context);
                };
            default:
                return function() {
                    var args = slice.call(arguments);
                    args.unshift(this[attribute]);
                    return base[method].apply(base, args);
                };
        }
    };
    var addUnderscoreMethods = function(Class, base, methods, attribute) {
        _.each(methods, function(length, method) {
            if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute);
        });
    };
    // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
    var cb = function(iteratee, instance) {
        if (_.isFunction(iteratee)) return iteratee;
        if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
        if (_.isString(iteratee)) return function(model) {
            return model.get(iteratee);
        };
        return iteratee;
    };
    var modelMatcher = function(attrs) {
        var matcher = _.matches(attrs);
        return function(model) {
            return matcher(model.attributes);
        };
    };
    // Underscore methods that we want to implement on the Collection.
    // 90% of the core usefulness of Backbone Collections is actually implemented
    // right here:
    var collectionMethods = {
        forEach: 3,
        each: 3,
        map: 3,
        collect: 3,
        reduce: 0,
        foldl: 0,
        inject: 0,
        reduceRight: 0,
        foldr: 0,
        find: 3,
        detect: 3,
        filter: 3,
        select: 3,
        reject: 3,
        every: 3,
        all: 3,
        some: 3,
        any: 3,
        include: 3,
        includes: 3,
        contains: 3,
        invoke: 0,
        max: 3,
        min: 3,
        toArray: 1,
        size: 1,
        first: 3,
        head: 3,
        take: 3,
        initial: 3,
        rest: 3,
        tail: 3,
        drop: 3,
        last: 3,
        without: 0,
        difference: 0,
        indexOf: 3,
        shuffle: 1,
        lastIndexOf: 3,
        isEmpty: 1,
        chain: 1,
        sample: 3,
        partition: 3,
        groupBy: 3,
        countBy: 3,
        sortBy: 3,
        indexBy: 3,
        findIndex: 3,
        findLastIndex: 3
    };
    // Underscore methods that we want to implement on the Model, mapped to the
    // number of arguments they take.
    var modelMethods = {
        keys: 1,
        values: 1,
        pairs: 1,
        invert: 1,
        pick: 0,
        omit: 0,
        chain: 1,
        isEmpty: 1
    };
    // Mix in each Underscore method as a proxy to `Collection#models`.
    _.each([
        [
            Collection,
            collectionMethods,
            "models"
        ],
        [
            Model,
            modelMethods,
            "attributes"
        ]
    ], function(config) {
        var Base = config[0], methods = config[1], attribute = config[2];
        Base.mixin = function(obj) {
            var mappings = _.reduce(_.functions(obj), function(memo, name) {
                memo[name] = 0;
                return memo;
            }, {});
            addUnderscoreMethods(Base, obj, mappings, attribute);
        };
        addUnderscoreMethods(Base, _, methods, attribute);
    });
    // Backbone.sync
    // -------------
    // Override this function to change the manner in which Backbone persists
    // models to the server. You will be passed the type of request, and the
    // model in question. By default, makes a RESTful Ajax request
    // to the model's `url()`. Some possible customizations could be:
    //
    // * Use `setTimeout` to batch rapid-fire updates into a single request.
    // * Send up the models as XML instead of JSON.
    // * Persist models via WebSockets instead of Ajax.
    //
    // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
    // as `POST`, with a `_method` parameter containing the true HTTP method,
    // as well as all requests with the body as `application/x-www-form-urlencoded`
    // instead of `application/json` with the model in a param named `model`.
    // Useful when interfacing with server-side languages like **PHP** that make
    // it difficult to read the body of `PUT` requests.
    Backbone.sync = function(method, model, options) {
        var type = methodMap[method];
        // Default options, unless specified.
        _.defaults(options || (options = {}), {
            emulateHTTP: Backbone.emulateHTTP,
            emulateJSON: Backbone.emulateJSON
        });
        // Default JSON-request options.
        var params = {
            type: type,
            dataType: "json"
        };
        // Ensure that we have a URL.
        if (!options.url) params.url = _.result(model, "url") || urlError();
        // Ensure that we have the appropriate request data.
        if (options.data == null && model && (method === "create" || method === "update" || method === "patch")) {
            params.contentType = "application/json";
            params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }
        // For older servers, emulate JSON by encoding the request into an HTML-form.
        if (options.emulateJSON) {
            params.contentType = "application/x-www-form-urlencoded";
            params.data = params.data ? {
                model: params.data
            } : {};
        }
        // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
        // And an `X-HTTP-Method-Override` header.
        if (options.emulateHTTP && (type === "PUT" || type === "DELETE" || type === "PATCH")) {
            params.type = "POST";
            if (options.emulateJSON) params.data._method = type;
            var beforeSend = options.beforeSend;
            options.beforeSend = function(xhr) {
                xhr.setRequestHeader("X-HTTP-Method-Override", type);
                if (beforeSend) return beforeSend.apply(this, arguments);
            };
        }
        // Don't process data on a non-GET request.
        if (params.type !== "GET" && !options.emulateJSON) params.processData = false;
        // Pass along `textStatus` and `errorThrown` from jQuery.
        var error = options.error;
        options.error = function(xhr, textStatus, errorThrown) {
            options.textStatus = textStatus;
            options.errorThrown = errorThrown;
            if (error) error.call(options.context, xhr, textStatus, errorThrown);
        };
        // Make the request, allowing the user to override any Ajax options.
        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
        model.trigger("request", model, xhr, options);
        return xhr;
    };
    // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
    var methodMap = {
        "create": "POST",
        "update": "PUT",
        "patch": "PATCH",
        "delete": "DELETE",
        "read": "GET"
    };
    // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
    // Override this if you'd like to use a different library.
    Backbone.ajax = function() {
        return Backbone.$.ajax.apply(Backbone.$, arguments);
    };
    // Backbone.Router
    // ---------------
    // Routers map faux-URLs to actions, and fire events when routes are
    // matched. Creating a new one sets its `routes` hash, if not set statically.
    var Router = Backbone.Router = function(options) {
        options || (options = {});
        this.preinitialize.apply(this, arguments);
        if (options.routes) this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
    };
    // Cached regular expressions for matching named param parts and splatted
    // parts of route strings.
    var optionalParam = /\((.*?)\)/g;
    var namedParam = /(\(\?)?:\w+/g;
    var splatParam = /\*\w+/g;
    var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
    // Set up all inheritable **Backbone.Router** properties and methods.
    _.extend(Router.prototype, Events, {
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Router.
        preinitialize: function() {},
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},
        // Manually bind a single named route to a callback. For example:
        //
        //     this.route('search/:query/p:num', 'search', function(query, num) {
        //       ...
        //     });
        //
        route: function(route, name, callback) {
            if (!_.isRegExp(route)) route = this._routeToRegExp(route);
            if (_.isFunction(name)) {
                callback = name;
                name = "";
            }
            if (!callback) callback = this[name];
            var router = this;
            Backbone.history.route(route, function(fragment) {
                var args = router._extractParameters(route, fragment);
                if (router.execute(callback, args, name) !== false) {
                    router.trigger.apply(router, [
                        "route:" + name
                    ].concat(args));
                    router.trigger("route", name, args);
                    Backbone.history.trigger("route", router, name, args);
                }
            });
            return this;
        },
        // Execute a route handler with the provided parameters.  This is an
        // excellent place to do pre-route setup or post-route cleanup.
        execute: function(callback, args, name) {
            if (callback) callback.apply(this, args);
        },
        // Simple proxy to `Backbone.history` to save a fragment into the history.
        navigate: function(fragment, options) {
            Backbone.history.navigate(fragment, options);
            return this;
        },
        // Bind all defined routes to `Backbone.history`. We have to reverse the
        // order of the routes here to support behavior where the most general
        // routes can be defined at the bottom of the route map.
        _bindRoutes: function() {
            if (!this.routes) return;
            this.routes = _.result(this, "routes");
            var route, routes = _.keys(this.routes);
            while((route = routes.pop()) != null)this.route(route, this.routes[route]);
        },
        // Convert a route string into a regular expression, suitable for matching
        // against the current location hash.
        _routeToRegExp: function(route) {
            route = route.replace(escapeRegExp, "\\$&").replace(optionalParam, "(?:$1)?").replace(namedParam, function(match, optional) {
                return optional ? match : "([^/?]+)";
            }).replace(splatParam, "([^?]*?)");
            return new RegExp("^" + route + "(?:\\?([\\s\\S]*))?$");
        },
        // Given a route, and a URL fragment that it matches, return the array of
        // extracted decoded parameters. Empty or unmatched parameters will be
        // treated as `null` to normalize cross-browser behavior.
        _extractParameters: function(route, fragment) {
            var params = route.exec(fragment).slice(1);
            return _.map(params, function(param, i) {
                // Don't decode the search params.
                if (i === params.length - 1) return param || null;
                return param ? decodeURIComponent(param) : null;
            });
        }
    });
    // Backbone.History
    // ----------------
    // Handles cross-browser history management, based on either
    // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
    // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
    // and URL fragments. If the browser supports neither (old IE, natch),
    // falls back to polling.
    var History = Backbone.History = function() {
        this.handlers = [];
        this.checkUrl = this.checkUrl.bind(this);
        // Ensure that `History` can be used outside of the browser.
        if (typeof window !== "undefined") {
            this.location = window.location;
            this.history = window.history;
        }
    };
    // Cached regex for stripping a leading hash/slash and trailing space.
    var routeStripper = /^[#\/]|\s+$/g;
    // Cached regex for stripping leading and trailing slashes.
    var rootStripper = /^\/+|\/+$/g;
    // Cached regex for stripping urls of hash.
    var pathStripper = /#.*$/;
    // Has the history handling already been started?
    History.started = false;
    // Set up all inheritable **Backbone.History** properties and methods.
    _.extend(History.prototype, Events, {
        // The default interval to poll for hash changes, if necessary, is
        // twenty times a second.
        interval: 50,
        // Are we at the app root?
        atRoot: function() {
            var path = this.location.pathname.replace(/[^\/]$/, "$&/");
            return path === this.root && !this.getSearch();
        },
        // Does the pathname match the root?
        matchRoot: function() {
            var path = this.decodeFragment(this.location.pathname);
            var rootPath = path.slice(0, this.root.length - 1) + "/";
            return rootPath === this.root;
        },
        // Unicode characters in `location.pathname` are percent encoded so they're
        // decoded for comparison. `%25` should not be decoded since it may be part
        // of an encoded parameter.
        decodeFragment: function(fragment) {
            return decodeURI(fragment.replace(/%25/g, "%2525"));
        },
        // In IE6, the hash fragment and search params are incorrect if the
        // fragment contains `?`.
        getSearch: function() {
            var match = this.location.href.replace(/#.*/, "").match(/\?.+/);
            return match ? match[0] : "";
        },
        // Gets the true hash value. Cannot use location.hash directly due to bug
        // in Firefox where location.hash will always be decoded.
        getHash: function(window1) {
            var match = (window1 || this).location.href.match(/#(.*)$/);
            return match ? match[1] : "";
        },
        // Get the pathname and search params, without the root.
        getPath: function() {
            var path = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);
            return path.charAt(0) === "/" ? path.slice(1) : path;
        },
        // Get the cross-browser normalized URL fragment from the path or hash.
        getFragment: function(fragment) {
            if (fragment == null) {
                if (this._usePushState || !this._wantsHashChange) fragment = this.getPath();
                else fragment = this.getHash();
            }
            return fragment.replace(routeStripper, "");
        },
        // Start the hash change handling, returning `true` if the current URL matches
        // an existing route, and `false` otherwise.
        start: function(options) {
            if (History.started) throw new Error("Backbone.history has already been started");
            History.started = true;
            // Figure out the initial configuration. Do we need an iframe?
            // Is pushState desired ... is it available?
            this.options = _.extend({
                root: "/"
            }, this.options, options);
            this.root = this.options.root;
            this._wantsHashChange = this.options.hashChange !== false;
            this._hasHashChange = "onhashchange" in window && (document.documentMode === void 0 || document.documentMode > 7);
            this._useHashChange = this._wantsHashChange && this._hasHashChange;
            this._wantsPushState = !!this.options.pushState;
            this._hasPushState = !!(this.history && this.history.pushState);
            this._usePushState = this._wantsPushState && this._hasPushState;
            this.fragment = this.getFragment();
            // Normalize root to always include a leading and trailing slash.
            this.root = ("/" + this.root + "/").replace(rootStripper, "/");
            // Transition from hashChange to pushState or vice versa if both are
            // requested.
            if (this._wantsHashChange && this._wantsPushState) {
                // If we've started off with a route from a `pushState`-enabled
                // browser, but we're currently in a browser that doesn't support it...
                if (!this._hasPushState && !this.atRoot()) {
                    var rootPath = this.root.slice(0, -1) || "/";
                    this.location.replace(rootPath + "#" + this.getPath());
                    // Return immediately as browser will do redirect to new url
                    return true;
                // Or if we've started out with a hash-based route, but we're currently
                // in a browser where it could be `pushState`-based instead...
                } else if (this._hasPushState && this.atRoot()) this.navigate(this.getHash(), {
                    replace: true
                });
            }
            // Proxy an iframe to handle location events if the browser doesn't
            // support the `hashchange` event, HTML5 history, or the user wants
            // `hashChange` but not `pushState`.
            if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
                this.iframe = document.createElement("iframe");
                this.iframe.src = "javascript:0";
                this.iframe.style.display = "none";
                this.iframe.tabIndex = -1;
                var body = document.body;
                // Using `appendChild` will throw on IE < 9 if the document is not ready.
                var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
                iWindow.document.open();
                iWindow.document.close();
                iWindow.location.hash = "#" + this.fragment;
            }
            // Add a cross-platform `addEventListener` shim for older browsers.
            var addEventListener = window.addEventListener || function(eventName, listener) {
                return attachEvent("on" + eventName, listener);
            };
            // Depending on whether we're using pushState or hashes, and whether
            // 'onhashchange' is supported, determine how we check the URL state.
            if (this._usePushState) addEventListener("popstate", this.checkUrl, false);
            else if (this._useHashChange && !this.iframe) addEventListener("hashchange", this.checkUrl, false);
            else if (this._wantsHashChange) this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
            if (!this.options.silent) return this.loadUrl();
        },
        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
        // but possibly useful for unit testing Routers.
        stop: function() {
            // Add a cross-platform `removeEventListener` shim for older browsers.
            var removeEventListener = window.removeEventListener || function(eventName, listener) {
                return detachEvent("on" + eventName, listener);
            };
            // Remove window listeners.
            if (this._usePushState) removeEventListener("popstate", this.checkUrl, false);
            else if (this._useHashChange && !this.iframe) removeEventListener("hashchange", this.checkUrl, false);
            // Clean up the iframe if necessary.
            if (this.iframe) {
                document.body.removeChild(this.iframe);
                this.iframe = null;
            }
            // Some environments will throw when clearing an undefined interval.
            if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
            History.started = false;
        },
        // Add a route to be tested when the fragment changes. Routes added later
        // may override previous routes.
        route: function(route, callback) {
            this.handlers.unshift({
                route: route,
                callback: callback
            });
        },
        // Checks the current URL to see if it has changed, and if it has,
        // calls `loadUrl`, normalizing across the hidden iframe.
        checkUrl: function(e) {
            var current = this.getFragment();
            // If the user pressed the back button, the iframe's hash will have
            // changed and we should use that for comparison.
            if (current === this.fragment && this.iframe) current = this.getHash(this.iframe.contentWindow);
            if (current === this.fragment) return false;
            if (this.iframe) this.navigate(current);
            this.loadUrl();
        },
        // Attempt to load the current URL fragment. If a route succeeds with a
        // match, returns `true`. If no defined routes matches the fragment,
        // returns `false`.
        loadUrl: function(fragment) {
            // If the root doesn't match, no routes can match either.
            if (!this.matchRoot()) return false;
            fragment = this.fragment = this.getFragment(fragment);
            return _.some(this.handlers, function(handler) {
                if (handler.route.test(fragment)) {
                    handler.callback(fragment);
                    return true;
                }
            });
        },
        // Save a fragment into the hash history, or replace the URL state if the
        // 'replace' option is passed. You are responsible for properly URL-encoding
        // the fragment in advance.
        //
        // The options object can contain `trigger: true` if you wish to have the
        // route callback be fired (not usually desirable), or `replace: true`, if
        // you wish to modify the current URL without adding an entry to the history.
        navigate: function(fragment, options) {
            if (!History.started) return false;
            if (!options || options === true) options = {
                trigger: !!options
            };
            // Normalize the fragment.
            fragment = this.getFragment(fragment || "");
            // Don't include a trailing slash on the root.
            var rootPath = this.root;
            if (fragment === "" || fragment.charAt(0) === "?") rootPath = rootPath.slice(0, -1) || "/";
            var url = rootPath + fragment;
            // Strip the fragment of the query and hash for matching.
            fragment = fragment.replace(pathStripper, "");
            // Decode for matching.
            var decodedFragment = this.decodeFragment(fragment);
            if (this.fragment === decodedFragment) return;
            this.fragment = decodedFragment;
            // If pushState is available, we use it to set the fragment as a real URL.
            if (this._usePushState) this.history[options.replace ? "replaceState" : "pushState"]({}, document.title, url);
            else if (this._wantsHashChange) {
                this._updateHash(this.location, fragment, options.replace);
                if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
                    var iWindow = this.iframe.contentWindow;
                    // Opening and closing the iframe tricks IE7 and earlier to push a
                    // history entry on hash-tag change.  When replace is true, we don't
                    // want this.
                    if (!options.replace) {
                        iWindow.document.open();
                        iWindow.document.close();
                    }
                    this._updateHash(iWindow.location, fragment, options.replace);
                }
            // If you've told us that you explicitly don't want fallback hashchange-
            // based history, then `navigate` becomes a page refresh.
            } else return this.location.assign(url);
            if (options.trigger) return this.loadUrl(fragment);
        },
        // Update the hash location, either replacing the current entry, or adding
        // a new one to the browser history.
        _updateHash: function(location, fragment, replace) {
            if (replace) {
                var href = location.href.replace(/(javascript:|#).*$/, "");
                location.replace(href + "#" + fragment);
            } else // Some browsers require that `hash` contains a leading #.
            location.hash = "#" + fragment;
        }
    });
    // Create the default Backbone.history.
    Backbone.history = new History;
    // Helpers
    // -------
    // Helper function to correctly set up the prototype chain for subclasses.
    // Similar to `goog.inherits`, but uses a hash of prototype properties and
    // class properties to be extended.
    var extend = function(protoProps, staticProps) {
        var parent = this;
        var child;
        // The constructor function for the new subclass is either defined by you
        // (the "constructor" property in your `extend` definition), or defaulted
        // by us to simply call the parent constructor.
        if (protoProps && _.has(protoProps, "constructor")) child = protoProps.constructor;
        else child = function() {
            return parent.apply(this, arguments);
        };
        // Add static properties to the constructor function, if supplied.
        _.extend(child, parent, staticProps);
        // Set the prototype chain to inherit from `parent`, without calling
        // `parent`'s constructor function and add the prototype properties.
        child.prototype = _.create(parent.prototype, protoProps);
        child.prototype.constructor = child;
        // Set a convenience property in case the parent's prototype is needed
        // later.
        child.__super__ = parent.prototype;
        return child;
    };
    // Set up inheritance for the model, collection, router, view and history.
    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
    // Throw an error when a URL is needed, and none is supplied.
    var urlError = function() {
        throw new Error('A "url" property or function must be specified');
    };
    // Wrap an optional error callback with a fallback error event.
    var wrapError = function(model, options) {
        var error = options.error;
        options.error = function(resp) {
            if (error) error.call(options.context, model, resp, options);
            model.trigger("error", model, resp, options);
        };
    };
    return Backbone;
});

},{"17462749b095c120":"8o1Pk","ddeacdd3a3586f70":"7jr44"}],"8o1Pk":[function(require,module,exports) {
// ESM Exports
// ===========
// This module is the package entry point for ES module users. In other words,
// it is the module they are interfacing with when they import from the whole
// package instead of from a submodule, like this:
//
// ```js
// import { map } from 'underscore';
// ```
//
// The difference with `./index-default`, which is the package entry point for
// CommonJS, AMD and UMD users, is purely technical. In ES modules, named and
// default exports are considered to be siblings, so when you have a default
// export, its properties are not automatically available as named exports. For
// this reason, we re-export the named exports in addition to providing the same
// default export as in `./index-default`.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _indexDefaultJsDefault.default));
var _indexDefaultJs = require("./index-default.js");
var _indexDefaultJsDefault = parcelHelpers.interopDefault(_indexDefaultJs);
var _indexJs = require("./index.js");
parcelHelpers.exportAll(_indexJs, exports);

},{"./index-default.js":"gyi03","./index.js":"l9sOw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gyi03":[function(require,module,exports) {
// Default Export
// ==============
// In this module, we mix our bundled exports into the `_` object and export
// the result. This is analogous to setting `module.exports = _` in CommonJS.
// Hence, this module is also the entry point of our UMD bundle and the package
// entry point for CommonJS and AMD users. In other words, this is (the source
// of) the module you are interfacing with when you do any of the following:
//
// ```js
// // CommonJS
// var _ = require('underscore');
//
// // AMD
// define(['underscore'], function(_) {...});
//
// // UMD in the browser
// // _ is available as a global variable
// ```
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./index.js");
// Add all of the Underscore functions to the wrapper object.
var _ = (0, _indexJs.mixin)(_indexJs);
// Legacy Node.js API.
_._ = _;
// Export the Underscore API.
exports.default = _;

},{"./index.js":"l9sOw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l9sOw":[function(require,module,exports) {
// Named Exports
// =============
//     Underscore.js 1.13.6
//     https://underscorejs.org
//     (c) 2009-2022 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
// Baseline setup.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>(0, _setupJs.VERSION));
parcelHelpers.export(exports, "restArguments", ()=>(0, _restArgumentsJsDefault.default));
// Object Functions
// ----------------
// Our most fundamental functions operate on any JavaScript object.
// Most functions in Underscore depend on at least one function in this section.
// A group of functions that check the types of core JavaScript values.
// These are often informally referred to as the "isType" functions.
parcelHelpers.export(exports, "isObject", ()=>(0, _isObjectJsDefault.default));
parcelHelpers.export(exports, "isNull", ()=>(0, _isNullJsDefault.default));
parcelHelpers.export(exports, "isUndefined", ()=>(0, _isUndefinedJsDefault.default));
parcelHelpers.export(exports, "isBoolean", ()=>(0, _isBooleanJsDefault.default));
parcelHelpers.export(exports, "isElement", ()=>(0, _isElementJsDefault.default));
parcelHelpers.export(exports, "isString", ()=>(0, _isStringJsDefault.default));
parcelHelpers.export(exports, "isNumber", ()=>(0, _isNumberJsDefault.default));
parcelHelpers.export(exports, "isDate", ()=>(0, _isDateJsDefault.default));
parcelHelpers.export(exports, "isRegExp", ()=>(0, _isRegExpJsDefault.default));
parcelHelpers.export(exports, "isError", ()=>(0, _isErrorJsDefault.default));
parcelHelpers.export(exports, "isSymbol", ()=>(0, _isSymbolJsDefault.default));
parcelHelpers.export(exports, "isArrayBuffer", ()=>(0, _isArrayBufferJsDefault.default));
parcelHelpers.export(exports, "isDataView", ()=>(0, _isDataViewJsDefault.default));
parcelHelpers.export(exports, "isArray", ()=>(0, _isArrayJsDefault.default));
parcelHelpers.export(exports, "isFunction", ()=>(0, _isFunctionJsDefault.default));
parcelHelpers.export(exports, "isArguments", ()=>(0, _isArgumentsJsDefault.default));
parcelHelpers.export(exports, "isFinite", ()=>(0, _isFiniteJsDefault.default));
parcelHelpers.export(exports, "isNaN", ()=>(0, _isNaNJsDefault.default));
parcelHelpers.export(exports, "isTypedArray", ()=>(0, _isTypedArrayJsDefault.default));
parcelHelpers.export(exports, "isEmpty", ()=>(0, _isEmptyJsDefault.default));
parcelHelpers.export(exports, "isMatch", ()=>(0, _isMatchJsDefault.default));
parcelHelpers.export(exports, "isEqual", ()=>(0, _isEqualJsDefault.default));
parcelHelpers.export(exports, "isMap", ()=>(0, _isMapJsDefault.default));
parcelHelpers.export(exports, "isWeakMap", ()=>(0, _isWeakMapJsDefault.default));
parcelHelpers.export(exports, "isSet", ()=>(0, _isSetJsDefault.default));
parcelHelpers.export(exports, "isWeakSet", ()=>(0, _isWeakSetJsDefault.default));
// Functions that treat an object as a dictionary of key-value pairs.
parcelHelpers.export(exports, "keys", ()=>(0, _keysJsDefault.default));
parcelHelpers.export(exports, "allKeys", ()=>(0, _allKeysJsDefault.default));
parcelHelpers.export(exports, "values", ()=>(0, _valuesJsDefault.default));
parcelHelpers.export(exports, "pairs", ()=>(0, _pairsJsDefault.default));
parcelHelpers.export(exports, "invert", ()=>(0, _invertJsDefault.default));
parcelHelpers.export(exports, "functions", ()=>(0, _functionsJsDefault.default));
parcelHelpers.export(exports, "methods", ()=>(0, _functionsJsDefault.default));
parcelHelpers.export(exports, "extend", ()=>(0, _extendJsDefault.default));
parcelHelpers.export(exports, "extendOwn", ()=>(0, _extendOwnJsDefault.default));
parcelHelpers.export(exports, "assign", ()=>(0, _extendOwnJsDefault.default));
parcelHelpers.export(exports, "defaults", ()=>(0, _defaultsJsDefault.default));
parcelHelpers.export(exports, "create", ()=>(0, _createJsDefault.default));
parcelHelpers.export(exports, "clone", ()=>(0, _cloneJsDefault.default));
parcelHelpers.export(exports, "tap", ()=>(0, _tapJsDefault.default));
parcelHelpers.export(exports, "get", ()=>(0, _getJsDefault.default));
parcelHelpers.export(exports, "has", ()=>(0, _hasJsDefault.default));
parcelHelpers.export(exports, "mapObject", ()=>(0, _mapObjectJsDefault.default));
// Utility Functions
// -----------------
// A bit of a grab bag: Predicate-generating functions for use with filters and
// loops, string escaping and templating, create random numbers and unique ids,
// and functions that facilitate Underscore's chaining and iteration conventions.
parcelHelpers.export(exports, "identity", ()=>(0, _identityJsDefault.default));
parcelHelpers.export(exports, "constant", ()=>(0, _constantJsDefault.default));
parcelHelpers.export(exports, "noop", ()=>(0, _noopJsDefault.default));
parcelHelpers.export(exports, "toPath", ()=>(0, _toPathJsDefault.default));
parcelHelpers.export(exports, "property", ()=>(0, _propertyJsDefault.default));
parcelHelpers.export(exports, "propertyOf", ()=>(0, _propertyOfJsDefault.default));
parcelHelpers.export(exports, "matcher", ()=>(0, _matcherJsDefault.default));
parcelHelpers.export(exports, "matches", ()=>(0, _matcherJsDefault.default));
parcelHelpers.export(exports, "times", ()=>(0, _timesJsDefault.default));
parcelHelpers.export(exports, "random", ()=>(0, _randomJsDefault.default));
parcelHelpers.export(exports, "now", ()=>(0, _nowJsDefault.default));
parcelHelpers.export(exports, "escape", ()=>(0, _escapeJsDefault.default));
parcelHelpers.export(exports, "unescape", ()=>(0, _unescapeJsDefault.default));
parcelHelpers.export(exports, "templateSettings", ()=>(0, _templateSettingsJsDefault.default));
parcelHelpers.export(exports, "template", ()=>(0, _templateJsDefault.default));
parcelHelpers.export(exports, "result", ()=>(0, _resultJsDefault.default));
parcelHelpers.export(exports, "uniqueId", ()=>(0, _uniqueIdJsDefault.default));
parcelHelpers.export(exports, "chain", ()=>(0, _chainJsDefault.default));
parcelHelpers.export(exports, "iteratee", ()=>(0, _iterateeJsDefault.default));
// Function (ahem) Functions
// -------------------------
// These functions take a function as an argument and return a new function
// as the result. Also known as higher-order functions.
parcelHelpers.export(exports, "partial", ()=>(0, _partialJsDefault.default));
parcelHelpers.export(exports, "bind", ()=>(0, _bindJsDefault.default));
parcelHelpers.export(exports, "bindAll", ()=>(0, _bindAllJsDefault.default));
parcelHelpers.export(exports, "memoize", ()=>(0, _memoizeJsDefault.default));
parcelHelpers.export(exports, "delay", ()=>(0, _delayJsDefault.default));
parcelHelpers.export(exports, "defer", ()=>(0, _deferJsDefault.default));
parcelHelpers.export(exports, "throttle", ()=>(0, _throttleJsDefault.default));
parcelHelpers.export(exports, "debounce", ()=>(0, _debounceJsDefault.default));
parcelHelpers.export(exports, "wrap", ()=>(0, _wrapJsDefault.default));
parcelHelpers.export(exports, "negate", ()=>(0, _negateJsDefault.default));
parcelHelpers.export(exports, "compose", ()=>(0, _composeJsDefault.default));
parcelHelpers.export(exports, "after", ()=>(0, _afterJsDefault.default));
parcelHelpers.export(exports, "before", ()=>(0, _beforeJsDefault.default));
parcelHelpers.export(exports, "once", ()=>(0, _onceJsDefault.default));
// Finders
// -------
// Functions that extract (the position of) a single element from an object
// or array based on some criterion.
parcelHelpers.export(exports, "findKey", ()=>(0, _findKeyJsDefault.default));
parcelHelpers.export(exports, "findIndex", ()=>(0, _findIndexJsDefault.default));
parcelHelpers.export(exports, "findLastIndex", ()=>(0, _findLastIndexJsDefault.default));
parcelHelpers.export(exports, "sortedIndex", ()=>(0, _sortedIndexJsDefault.default));
parcelHelpers.export(exports, "indexOf", ()=>(0, _indexOfJsDefault.default));
parcelHelpers.export(exports, "lastIndexOf", ()=>(0, _lastIndexOfJsDefault.default));
parcelHelpers.export(exports, "find", ()=>(0, _findJsDefault.default));
parcelHelpers.export(exports, "detect", ()=>(0, _findJsDefault.default));
parcelHelpers.export(exports, "findWhere", ()=>(0, _findWhereJsDefault.default));
// Collection Functions
// --------------------
// Functions that work on any collection of elements: either an array, or
// an object of key-value pairs.
parcelHelpers.export(exports, "each", ()=>(0, _eachJsDefault.default));
parcelHelpers.export(exports, "forEach", ()=>(0, _eachJsDefault.default));
parcelHelpers.export(exports, "map", ()=>(0, _mapJsDefault.default));
parcelHelpers.export(exports, "collect", ()=>(0, _mapJsDefault.default));
parcelHelpers.export(exports, "reduce", ()=>(0, _reduceJsDefault.default));
parcelHelpers.export(exports, "foldl", ()=>(0, _reduceJsDefault.default));
parcelHelpers.export(exports, "inject", ()=>(0, _reduceJsDefault.default));
parcelHelpers.export(exports, "reduceRight", ()=>(0, _reduceRightJsDefault.default));
parcelHelpers.export(exports, "foldr", ()=>(0, _reduceRightJsDefault.default));
parcelHelpers.export(exports, "filter", ()=>(0, _filterJsDefault.default));
parcelHelpers.export(exports, "select", ()=>(0, _filterJsDefault.default));
parcelHelpers.export(exports, "reject", ()=>(0, _rejectJsDefault.default));
parcelHelpers.export(exports, "every", ()=>(0, _everyJsDefault.default));
parcelHelpers.export(exports, "all", ()=>(0, _everyJsDefault.default));
parcelHelpers.export(exports, "some", ()=>(0, _someJsDefault.default));
parcelHelpers.export(exports, "any", ()=>(0, _someJsDefault.default));
parcelHelpers.export(exports, "contains", ()=>(0, _containsJsDefault.default));
parcelHelpers.export(exports, "includes", ()=>(0, _containsJsDefault.default));
parcelHelpers.export(exports, "include", ()=>(0, _containsJsDefault.default));
parcelHelpers.export(exports, "invoke", ()=>(0, _invokeJsDefault.default));
parcelHelpers.export(exports, "pluck", ()=>(0, _pluckJsDefault.default));
parcelHelpers.export(exports, "where", ()=>(0, _whereJsDefault.default));
parcelHelpers.export(exports, "max", ()=>(0, _maxJsDefault.default));
parcelHelpers.export(exports, "min", ()=>(0, _minJsDefault.default));
parcelHelpers.export(exports, "shuffle", ()=>(0, _shuffleJsDefault.default));
parcelHelpers.export(exports, "sample", ()=>(0, _sampleJsDefault.default));
parcelHelpers.export(exports, "sortBy", ()=>(0, _sortByJsDefault.default));
parcelHelpers.export(exports, "groupBy", ()=>(0, _groupByJsDefault.default));
parcelHelpers.export(exports, "indexBy", ()=>(0, _indexByJsDefault.default));
parcelHelpers.export(exports, "countBy", ()=>(0, _countByJsDefault.default));
parcelHelpers.export(exports, "partition", ()=>(0, _partitionJsDefault.default));
parcelHelpers.export(exports, "toArray", ()=>(0, _toArrayJsDefault.default));
parcelHelpers.export(exports, "size", ()=>(0, _sizeJsDefault.default));
// `_.pick` and `_.omit` are actually object functions, but we put
// them here in order to create a more natural reading order in the
// monolithic build as they depend on `_.contains`.
parcelHelpers.export(exports, "pick", ()=>(0, _pickJsDefault.default));
parcelHelpers.export(exports, "omit", ()=>(0, _omitJsDefault.default));
// Array Functions
// ---------------
// Functions that operate on arrays (and array-likes) only, because they‚Äôre
// expressed in terms of operations on an ordered list of values.
parcelHelpers.export(exports, "first", ()=>(0, _firstJsDefault.default));
parcelHelpers.export(exports, "head", ()=>(0, _firstJsDefault.default));
parcelHelpers.export(exports, "take", ()=>(0, _firstJsDefault.default));
parcelHelpers.export(exports, "initial", ()=>(0, _initialJsDefault.default));
parcelHelpers.export(exports, "last", ()=>(0, _lastJsDefault.default));
parcelHelpers.export(exports, "rest", ()=>(0, _restJsDefault.default));
parcelHelpers.export(exports, "tail", ()=>(0, _restJsDefault.default));
parcelHelpers.export(exports, "drop", ()=>(0, _restJsDefault.default));
parcelHelpers.export(exports, "compact", ()=>(0, _compactJsDefault.default));
parcelHelpers.export(exports, "flatten", ()=>(0, _flattenJsDefault.default));
parcelHelpers.export(exports, "without", ()=>(0, _withoutJsDefault.default));
parcelHelpers.export(exports, "uniq", ()=>(0, _uniqJsDefault.default));
parcelHelpers.export(exports, "unique", ()=>(0, _uniqJsDefault.default));
parcelHelpers.export(exports, "union", ()=>(0, _unionJsDefault.default));
parcelHelpers.export(exports, "intersection", ()=>(0, _intersectionJsDefault.default));
parcelHelpers.export(exports, "difference", ()=>(0, _differenceJsDefault.default));
parcelHelpers.export(exports, "unzip", ()=>(0, _unzipJsDefault.default));
parcelHelpers.export(exports, "transpose", ()=>(0, _unzipJsDefault.default));
parcelHelpers.export(exports, "zip", ()=>(0, _zipJsDefault.default));
parcelHelpers.export(exports, "object", ()=>(0, _objectJsDefault.default));
parcelHelpers.export(exports, "range", ()=>(0, _rangeJsDefault.default));
parcelHelpers.export(exports, "chunk", ()=>(0, _chunkJsDefault.default));
// OOP
// ---
// These modules support the "object-oriented" calling style. See also
// `underscore.js` and `index-default.js`.
parcelHelpers.export(exports, "mixin", ()=>(0, _mixinJsDefault.default));
parcelHelpers.export(exports, "default", ()=>(0, _underscoreArrayMethodsJsDefault.default));
var _setupJs = require("./_setup.js");
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _isNullJs = require("./isNull.js");
var _isNullJsDefault = parcelHelpers.interopDefault(_isNullJs);
var _isUndefinedJs = require("./isUndefined.js");
var _isUndefinedJsDefault = parcelHelpers.interopDefault(_isUndefinedJs);
var _isBooleanJs = require("./isBoolean.js");
var _isBooleanJsDefault = parcelHelpers.interopDefault(_isBooleanJs);
var _isElementJs = require("./isElement.js");
var _isElementJsDefault = parcelHelpers.interopDefault(_isElementJs);
var _isStringJs = require("./isString.js");
var _isStringJsDefault = parcelHelpers.interopDefault(_isStringJs);
var _isNumberJs = require("./isNumber.js");
var _isNumberJsDefault = parcelHelpers.interopDefault(_isNumberJs);
var _isDateJs = require("./isDate.js");
var _isDateJsDefault = parcelHelpers.interopDefault(_isDateJs);
var _isRegExpJs = require("./isRegExp.js");
var _isRegExpJsDefault = parcelHelpers.interopDefault(_isRegExpJs);
var _isErrorJs = require("./isError.js");
var _isErrorJsDefault = parcelHelpers.interopDefault(_isErrorJs);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
var _isArrayBufferJs = require("./isArrayBuffer.js");
var _isArrayBufferJsDefault = parcelHelpers.interopDefault(_isArrayBufferJs);
var _isDataViewJs = require("./isDataView.js");
var _isDataViewJsDefault = parcelHelpers.interopDefault(_isDataViewJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _isFiniteJs = require("./isFinite.js");
var _isFiniteJsDefault = parcelHelpers.interopDefault(_isFiniteJs);
var _isNaNJs = require("./isNaN.js");
var _isNaNJsDefault = parcelHelpers.interopDefault(_isNaNJs);
var _isTypedArrayJs = require("./isTypedArray.js");
var _isTypedArrayJsDefault = parcelHelpers.interopDefault(_isTypedArrayJs);
var _isEmptyJs = require("./isEmpty.js");
var _isEmptyJsDefault = parcelHelpers.interopDefault(_isEmptyJs);
var _isMatchJs = require("./isMatch.js");
var _isMatchJsDefault = parcelHelpers.interopDefault(_isMatchJs);
var _isEqualJs = require("./isEqual.js");
var _isEqualJsDefault = parcelHelpers.interopDefault(_isEqualJs);
var _isMapJs = require("./isMap.js");
var _isMapJsDefault = parcelHelpers.interopDefault(_isMapJs);
var _isWeakMapJs = require("./isWeakMap.js");
var _isWeakMapJsDefault = parcelHelpers.interopDefault(_isWeakMapJs);
var _isSetJs = require("./isSet.js");
var _isSetJsDefault = parcelHelpers.interopDefault(_isSetJs);
var _isWeakSetJs = require("./isWeakSet.js");
var _isWeakSetJsDefault = parcelHelpers.interopDefault(_isWeakSetJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _pairsJs = require("./pairs.js");
var _pairsJsDefault = parcelHelpers.interopDefault(_pairsJs);
var _invertJs = require("./invert.js");
var _invertJsDefault = parcelHelpers.interopDefault(_invertJs);
var _functionsJs = require("./functions.js");
var _functionsJsDefault = parcelHelpers.interopDefault(_functionsJs);
var _extendJs = require("./extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _extendOwnJs = require("./extendOwn.js");
var _extendOwnJsDefault = parcelHelpers.interopDefault(_extendOwnJs);
var _defaultsJs = require("./defaults.js");
var _defaultsJsDefault = parcelHelpers.interopDefault(_defaultsJs);
var _createJs = require("./create.js");
var _createJsDefault = parcelHelpers.interopDefault(_createJs);
var _cloneJs = require("./clone.js");
var _cloneJsDefault = parcelHelpers.interopDefault(_cloneJs);
var _tapJs = require("./tap.js");
var _tapJsDefault = parcelHelpers.interopDefault(_tapJs);
var _getJs = require("./get.js");
var _getJsDefault = parcelHelpers.interopDefault(_getJs);
var _hasJs = require("./has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _mapObjectJs = require("./mapObject.js");
var _mapObjectJsDefault = parcelHelpers.interopDefault(_mapObjectJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _toPathJs = require("./toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
var _propertyJs = require("./property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _propertyOfJs = require("./propertyOf.js");
var _propertyOfJsDefault = parcelHelpers.interopDefault(_propertyOfJs);
var _matcherJs = require("./matcher.js");
var _matcherJsDefault = parcelHelpers.interopDefault(_matcherJs);
var _timesJs = require("./times.js");
var _timesJsDefault = parcelHelpers.interopDefault(_timesJs);
var _randomJs = require("./random.js");
var _randomJsDefault = parcelHelpers.interopDefault(_randomJs);
var _nowJs = require("./now.js");
var _nowJsDefault = parcelHelpers.interopDefault(_nowJs);
var _escapeJs = require("./escape.js");
var _escapeJsDefault = parcelHelpers.interopDefault(_escapeJs);
var _unescapeJs = require("./unescape.js");
var _unescapeJsDefault = parcelHelpers.interopDefault(_unescapeJs);
var _templateSettingsJs = require("./templateSettings.js");
var _templateSettingsJsDefault = parcelHelpers.interopDefault(_templateSettingsJs);
var _templateJs = require("./template.js");
var _templateJsDefault = parcelHelpers.interopDefault(_templateJs);
var _resultJs = require("./result.js");
var _resultJsDefault = parcelHelpers.interopDefault(_resultJs);
var _uniqueIdJs = require("./uniqueId.js");
var _uniqueIdJsDefault = parcelHelpers.interopDefault(_uniqueIdJs);
var _chainJs = require("./chain.js");
var _chainJsDefault = parcelHelpers.interopDefault(_chainJs);
var _iterateeJs = require("./iteratee.js");
var _iterateeJsDefault = parcelHelpers.interopDefault(_iterateeJs);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
var _bindJs = require("./bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var _bindAllJs = require("./bindAll.js");
var _bindAllJsDefault = parcelHelpers.interopDefault(_bindAllJs);
var _memoizeJs = require("./memoize.js");
var _memoizeJsDefault = parcelHelpers.interopDefault(_memoizeJs);
var _delayJs = require("./delay.js");
var _delayJsDefault = parcelHelpers.interopDefault(_delayJs);
var _deferJs = require("./defer.js");
var _deferJsDefault = parcelHelpers.interopDefault(_deferJs);
var _throttleJs = require("./throttle.js");
var _throttleJsDefault = parcelHelpers.interopDefault(_throttleJs);
var _debounceJs = require("./debounce.js");
var _debounceJsDefault = parcelHelpers.interopDefault(_debounceJs);
var _wrapJs = require("./wrap.js");
var _wrapJsDefault = parcelHelpers.interopDefault(_wrapJs);
var _negateJs = require("./negate.js");
var _negateJsDefault = parcelHelpers.interopDefault(_negateJs);
var _composeJs = require("./compose.js");
var _composeJsDefault = parcelHelpers.interopDefault(_composeJs);
var _afterJs = require("./after.js");
var _afterJsDefault = parcelHelpers.interopDefault(_afterJs);
var _beforeJs = require("./before.js");
var _beforeJsDefault = parcelHelpers.interopDefault(_beforeJs);
var _onceJs = require("./once.js");
var _onceJsDefault = parcelHelpers.interopDefault(_onceJs);
var _findKeyJs = require("./findKey.js");
var _findKeyJsDefault = parcelHelpers.interopDefault(_findKeyJs);
var _findIndexJs = require("./findIndex.js");
var _findIndexJsDefault = parcelHelpers.interopDefault(_findIndexJs);
var _findLastIndexJs = require("./findLastIndex.js");
var _findLastIndexJsDefault = parcelHelpers.interopDefault(_findLastIndexJs);
var _sortedIndexJs = require("./sortedIndex.js");
var _sortedIndexJsDefault = parcelHelpers.interopDefault(_sortedIndexJs);
var _indexOfJs = require("./indexOf.js");
var _indexOfJsDefault = parcelHelpers.interopDefault(_indexOfJs);
var _lastIndexOfJs = require("./lastIndexOf.js");
var _lastIndexOfJsDefault = parcelHelpers.interopDefault(_lastIndexOfJs);
var _findJs = require("./find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _findWhereJs = require("./findWhere.js");
var _findWhereJsDefault = parcelHelpers.interopDefault(_findWhereJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _reduceJs = require("./reduce.js");
var _reduceJsDefault = parcelHelpers.interopDefault(_reduceJs);
var _reduceRightJs = require("./reduceRight.js");
var _reduceRightJsDefault = parcelHelpers.interopDefault(_reduceRightJs);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _rejectJs = require("./reject.js");
var _rejectJsDefault = parcelHelpers.interopDefault(_rejectJs);
var _everyJs = require("./every.js");
var _everyJsDefault = parcelHelpers.interopDefault(_everyJs);
var _someJs = require("./some.js");
var _someJsDefault = parcelHelpers.interopDefault(_someJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _invokeJs = require("./invoke.js");
var _invokeJsDefault = parcelHelpers.interopDefault(_invokeJs);
var _pluckJs = require("./pluck.js");
var _pluckJsDefault = parcelHelpers.interopDefault(_pluckJs);
var _whereJs = require("./where.js");
var _whereJsDefault = parcelHelpers.interopDefault(_whereJs);
var _maxJs = require("./max.js");
var _maxJsDefault = parcelHelpers.interopDefault(_maxJs);
var _minJs = require("./min.js");
var _minJsDefault = parcelHelpers.interopDefault(_minJs);
var _shuffleJs = require("./shuffle.js");
var _shuffleJsDefault = parcelHelpers.interopDefault(_shuffleJs);
var _sampleJs = require("./sample.js");
var _sampleJsDefault = parcelHelpers.interopDefault(_sampleJs);
var _sortByJs = require("./sortBy.js");
var _sortByJsDefault = parcelHelpers.interopDefault(_sortByJs);
var _groupByJs = require("./groupBy.js");
var _groupByJsDefault = parcelHelpers.interopDefault(_groupByJs);
var _indexByJs = require("./indexBy.js");
var _indexByJsDefault = parcelHelpers.interopDefault(_indexByJs);
var _countByJs = require("./countBy.js");
var _countByJsDefault = parcelHelpers.interopDefault(_countByJs);
var _partitionJs = require("./partition.js");
var _partitionJsDefault = parcelHelpers.interopDefault(_partitionJs);
var _toArrayJs = require("./toArray.js");
var _toArrayJsDefault = parcelHelpers.interopDefault(_toArrayJs);
var _sizeJs = require("./size.js");
var _sizeJsDefault = parcelHelpers.interopDefault(_sizeJs);
var _pickJs = require("./pick.js");
var _pickJsDefault = parcelHelpers.interopDefault(_pickJs);
var _omitJs = require("./omit.js");
var _omitJsDefault = parcelHelpers.interopDefault(_omitJs);
var _firstJs = require("./first.js");
var _firstJsDefault = parcelHelpers.interopDefault(_firstJs);
var _initialJs = require("./initial.js");
var _initialJsDefault = parcelHelpers.interopDefault(_initialJs);
var _lastJs = require("./last.js");
var _lastJsDefault = parcelHelpers.interopDefault(_lastJs);
var _restJs = require("./rest.js");
var _restJsDefault = parcelHelpers.interopDefault(_restJs);
var _compactJs = require("./compact.js");
var _compactJsDefault = parcelHelpers.interopDefault(_compactJs);
var _flattenJs = require("./flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _withoutJs = require("./without.js");
var _withoutJsDefault = parcelHelpers.interopDefault(_withoutJs);
var _uniqJs = require("./uniq.js");
var _uniqJsDefault = parcelHelpers.interopDefault(_uniqJs);
var _unionJs = require("./union.js");
var _unionJsDefault = parcelHelpers.interopDefault(_unionJs);
var _intersectionJs = require("./intersection.js");
var _intersectionJsDefault = parcelHelpers.interopDefault(_intersectionJs);
var _differenceJs = require("./difference.js");
var _differenceJsDefault = parcelHelpers.interopDefault(_differenceJs);
var _unzipJs = require("./unzip.js");
var _unzipJsDefault = parcelHelpers.interopDefault(_unzipJs);
var _zipJs = require("./zip.js");
var _zipJsDefault = parcelHelpers.interopDefault(_zipJs);
var _objectJs = require("./object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _rangeJs = require("./range.js");
var _rangeJsDefault = parcelHelpers.interopDefault(_rangeJs);
var _chunkJs = require("./chunk.js");
var _chunkJsDefault = parcelHelpers.interopDefault(_chunkJs);
var _mixinJs = require("./mixin.js");
var _mixinJsDefault = parcelHelpers.interopDefault(_mixinJs);
var _underscoreArrayMethodsJs = require("./underscore-array-methods.js");
var _underscoreArrayMethodsJsDefault = parcelHelpers.interopDefault(_underscoreArrayMethodsJs);

},{"./_setup.js":"j1Opz","./restArguments.js":"iHiW5","./isObject.js":"jS3Se","./isNull.js":"3EF4i","./isUndefined.js":"76Kia","./isBoolean.js":"e6GFe","./isElement.js":"dhZbv","./isString.js":"h9vOY","./isNumber.js":"r54Wg","./isDate.js":"iDfv3","./isRegExp.js":"azfrs","./isError.js":"dkIl1","./isSymbol.js":"75NV6","./isArrayBuffer.js":"asmRo","./isDataView.js":"1t0pk","./isArray.js":"cth5N","./isFunction.js":"9XYGL","./isArguments.js":"dVyjs","./isFinite.js":"gKoss","./isNaN.js":"3QjxN","./isTypedArray.js":"6Wsfb","./isEmpty.js":"dK0Pq","./isMatch.js":"aIz4w","./isEqual.js":"cHWdl","./isMap.js":"k6Fdu","./isWeakMap.js":"ebF8O","./isSet.js":"Fl86y","./isWeakSet.js":"isH5L","./keys.js":"epVJ3","./allKeys.js":"iL9rU","./values.js":"1I2Yc","./pairs.js":"bdrSk","./invert.js":"1xVUE","./functions.js":"6kKwG","./extend.js":"3CC22","./extendOwn.js":"7Fpdj","./defaults.js":"2QZRH","./create.js":"27kIz","./clone.js":"9aJbO","./tap.js":"5KIUX","./get.js":"d7ATL","./has.js":"3CTQc","./mapObject.js":"eLKLX","./identity.js":"iCRMn","./constant.js":"6dl0q","./noop.js":"3qYXh","./toPath.js":"2926x","./property.js":"96pvf","./propertyOf.js":"iwYrg","./matcher.js":"3wGZ7","./times.js":"pyCYh","./random.js":"imiVs","./now.js":"aOx7w","./escape.js":"7w3y8","./unescape.js":"gmHHm","./templateSettings.js":"h5qH1","./template.js":"czkRN","./result.js":"4l1X6","./uniqueId.js":"arUrP","./chain.js":"jSwHe","./iteratee.js":"b93XD","./partial.js":"fLBUm","./bind.js":"kSGgn","./bindAll.js":"2htre","./memoize.js":"f9ZJj","./delay.js":"aIkq2","./defer.js":"8wSef","./throttle.js":"5FGQl","./debounce.js":"aVPiV","./wrap.js":"34WFJ","./negate.js":"juYC5","./compose.js":"f2NYc","./after.js":"7w1Ut","./before.js":"ezKMS","./once.js":"1RAuX","./findKey.js":"eLj2O","./findIndex.js":"cs9dN","./findLastIndex.js":"8rc9q","./sortedIndex.js":"ixTcB","./indexOf.js":"3FyCZ","./lastIndexOf.js":"7jQpU","./find.js":"lLtqo","./findWhere.js":"jhudI","./each.js":"fHmAz","./map.js":"1MqH5","./reduce.js":"bIw1c","./reduceRight.js":"2prZg","./filter.js":"5cyip","./reject.js":"2AJcx","./every.js":"7IzXu","./some.js":"dxzPe","./contains.js":"7u1gl","./invoke.js":"aHKqv","./pluck.js":"OekpZ","./where.js":"1GXcS","./max.js":"6g3ZY","./min.js":"9EXwL","./shuffle.js":"kl8WA","./sample.js":"8fNnf","./sortBy.js":"eCcLt","./groupBy.js":"k2aiT","./indexBy.js":"9VQiT","./countBy.js":"kNxCr","./partition.js":"bH0TP","./toArray.js":"7e7T1","./size.js":"88Tqj","./pick.js":"8ScJB","./omit.js":"6aykp","./first.js":"bNqM1","./initial.js":"cD91j","./last.js":"38Fqg","./rest.js":"aLSkH","./compact.js":"3coBb","./flatten.js":"gpF6L","./without.js":"ouhVw","./uniq.js":"kiHGM","./union.js":"k8pGG","./intersection.js":"iHUB6","./difference.js":"e9ASn","./unzip.js":"hyGGg","./zip.js":"lJw0p","./object.js":"bvlJI","./range.js":"43G11","./chunk.js":"57Gcn","./mixin.js":"enXfg","./underscore-array-methods.js":"k1JcM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j1Opz":[function(require,module,exports) {
// Current version.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
parcelHelpers.export(exports, "root", ()=>root);
parcelHelpers.export(exports, "ArrayProto", ()=>ArrayProto);
parcelHelpers.export(exports, "ObjProto", ()=>ObjProto);
parcelHelpers.export(exports, "SymbolProto", ()=>SymbolProto);
parcelHelpers.export(exports, "push", ()=>push);
parcelHelpers.export(exports, "slice", ()=>slice);
parcelHelpers.export(exports, "toString", ()=>toString);
parcelHelpers.export(exports, "hasOwnProperty", ()=>hasOwnProperty);
parcelHelpers.export(exports, "supportsArrayBuffer", ()=>supportsArrayBuffer);
parcelHelpers.export(exports, "supportsDataView", ()=>supportsDataView);
parcelHelpers.export(exports, "nativeIsArray", ()=>nativeIsArray);
parcelHelpers.export(exports, "nativeKeys", ()=>nativeKeys);
parcelHelpers.export(exports, "nativeCreate", ()=>nativeCreate);
parcelHelpers.export(exports, "nativeIsView", ()=>nativeIsView);
parcelHelpers.export(exports, "_isNaN", ()=>_isNaN);
parcelHelpers.export(exports, "_isFinite", ()=>_isFinite);
parcelHelpers.export(exports, "hasEnumBug", ()=>hasEnumBug);
parcelHelpers.export(exports, "nonEnumerableProps", ()=>nonEnumerableProps);
parcelHelpers.export(exports, "MAX_ARRAY_INDEX", ()=>MAX_ARRAY_INDEX);
var global = arguments[3];
var VERSION = "1.13.6";
var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
var ArrayProto = Array.prototype, ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
var supportsArrayBuffer = typeof ArrayBuffer !== "undefined", supportsDataView = typeof DataView !== "undefined";
var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create, nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
var _isNaN = isNaN, _isFinite = isFinite;
var hasEnumBug = !({
    toString: null
}).propertyIsEnumerable("toString");
var nonEnumerableProps = [
    "valueOf",
    "isPrototypeOf",
    "toString",
    "propertyIsEnumerable",
    "hasOwnProperty",
    "toLocaleString"
];
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"iHiW5":[function(require,module,exports) {
// Some functions take a variable number of arguments, or a few expected
// arguments at the beginning and then a variable number of values to operate
// on. This helper accumulates all remaining arguments past the function‚Äôs
// argument length (or an explicit `startIndex`), into an array that becomes
// the last argument. Similar to ES6‚Äôs "rest parameter".
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>restArguments);
function restArguments(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
        var length = Math.max(arguments.length - startIndex, 0), rest = Array(length), index = 0;
        for(; index < length; index++)rest[index] = arguments[index + startIndex];
        switch(startIndex){
            case 0:
                return func.call(this, rest);
            case 1:
                return func.call(this, arguments[0], rest);
            case 2:
                return func.call(this, arguments[0], arguments[1], rest);
        }
        var args = Array(startIndex + 1);
        for(index = 0; index < startIndex; index++)args[index] = arguments[index];
        args[startIndex] = rest;
        return func.apply(this, args);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jS3Se":[function(require,module,exports) {
// Is a given variable an object?
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isObject);
function isObject(obj) {
    var type = typeof obj;
    return type === "function" || type === "object" && !!obj;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3EF4i":[function(require,module,exports) {
// Is a given value equal to null?
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isNull);
function isNull(obj) {
    return obj === null;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"76Kia":[function(require,module,exports) {
// Is a given variable undefined?
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isUndefined);
function isUndefined(obj) {
    return obj === void 0;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e6GFe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isBoolean);
var _setupJs = require("./_setup.js");
function isBoolean(obj) {
    return obj === true || obj === false || (0, _setupJs.toString).call(obj) === "[object Boolean]";
}

},{"./_setup.js":"j1Opz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dhZbv":[function(require,module,exports) {
// Is a given value a DOM element?
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isElement);
function isElement(obj) {
    return !!(obj && obj.nodeType === 1);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h9vOY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = (0, _tagTesterJsDefault.default)("String");

},{"./_tagTester.js":"8zfWu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8zfWu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>tagTester);
var _setupJs = require("./_setup.js");
function tagTester(name) {
    var tag = "[object " + name + "]";
    return function(obj) {
        return (0, _setupJs.toString).call(obj) === tag;
    };
}

},{"./_setup.js":"j1Opz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"r54Wg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = (0, _tagTesterJsDefault.default)("Number");

},{"./_tagTester.js":"8zfWu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iDfv3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = (0, _tagTesterJsDefault.default)("Date");

},{"./_tagTester.js":"8zfWu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"azfrs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = (0, _tagTesterJsDefault.default)("RegExp");

},{"./_tagTester.js":"8zfWu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dkIl1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = (0, _tagTesterJsDefault.default)("Error");

},{"./_tagTester.js":"8zfWu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"75NV6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = (0, _tagTesterJsDefault.default)("Symbol");

},{"./_tagTester.js":"8zfWu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"asmRo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = (0, _tagTesterJsDefault.default)("ArrayBuffer");

},{"./_tagTester.js":"8zfWu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1t0pk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isArrayBufferJs = require("./isArrayBuffer.js");
var _isArrayBufferJsDefault = parcelHelpers.interopDefault(_isArrayBufferJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var isDataView = (0, _tagTesterJsDefault.default)("DataView");
// In IE 10 - Edge 13, we need a different heuristic
// to determine whether an object is a `DataView`.
function ie10IsDataView(obj) {
    return obj != null && (0, _isFunctionJsDefault.default)(obj.getInt8) && (0, _isArrayBufferJsDefault.default)(obj.buffer);
}
exports.default = (0, _stringTagBugJs.hasStringTagBug) ? ie10IsDataView : isDataView;

},{"./_tagTester.js":"8zfWu","./isFunction.js":"9XYGL","./isArrayBuffer.js":"asmRo","./_stringTagBug.js":"2UGte","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9XYGL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _setupJs = require("./_setup.js");
var isFunction = (0, _tagTesterJsDefault.default)("Function");
// Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
// v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
var nodelist = (0, _setupJs.root).document && (0, _setupJs.root).document.childNodes;
if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") isFunction = function(obj) {
    return typeof obj == "function" || false;
};
exports.default = isFunction;

},{"./_tagTester.js":"8zfWu","./_setup.js":"j1Opz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2UGte":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasStringTagBug", ()=>hasStringTagBug);
parcelHelpers.export(exports, "isIE11", ()=>isIE11);
var _setupJs = require("./_setup.js");
var _hasObjectTagJs = require("./_hasObjectTag.js");
var _hasObjectTagJsDefault = parcelHelpers.interopDefault(_hasObjectTagJs);
var hasStringTagBug = (0, _setupJs.supportsDataView) && (0, _hasObjectTagJsDefault.default)(new DataView(new ArrayBuffer(8))), isIE11 = typeof Map !== "undefined" && (0, _hasObjectTagJsDefault.default)(new Map);

},{"./_setup.js":"j1Opz","./_hasObjectTag.js":"EvdI9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"EvdI9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = (0, _tagTesterJsDefault.default)("Object");

},{"./_tagTester.js":"8zfWu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cth5N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
// Is a given value an array?
// Delegates to ECMA5's native `Array.isArray`.
exports.default = (0, _setupJs.nativeIsArray) || (0, _tagTesterJsDefault.default)("Array");

},{"./_setup.js":"j1Opz","./_tagTester.js":"8zfWu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dVyjs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var isArguments = (0, _tagTesterJsDefault.default)("Arguments");
// Define a fallback version of the method in browsers (ahem, IE < 9), where
// there isn't any inspectable "Arguments" type.
(function() {
    if (!isArguments(arguments)) isArguments = function(obj) {
        return (0, _hasJsDefault.default)(obj, "callee");
    };
})();
exports.default = isArguments;

},{"./_tagTester.js":"8zfWu","./_has.js":"500LZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"500LZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>has);
var _setupJs = require("./_setup.js");
function has(obj, key) {
    return obj != null && (0, _setupJs.hasOwnProperty).call(obj, key);
}

},{"./_setup.js":"j1Opz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gKoss":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isFinite);
var _setupJs = require("./_setup.js");
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
function isFinite(obj) {
    return !(0, _isSymbolJsDefault.default)(obj) && (0, _setupJs._isFinite)(obj) && !isNaN(parseFloat(obj));
}

},{"./_setup.js":"j1Opz","./isSymbol.js":"75NV6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3QjxN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isNaN);
var _setupJs = require("./_setup.js");
var _isNumberJs = require("./isNumber.js");
var _isNumberJsDefault = parcelHelpers.interopDefault(_isNumberJs);
function isNaN(obj) {
    return (0, _isNumberJsDefault.default)(obj) && (0, _setupJs._isNaN)(obj);
}

},{"./_setup.js":"j1Opz","./isNumber.js":"r54Wg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Wsfb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setupJs = require("./_setup.js");
var _isDataViewJs = require("./isDataView.js");
var _isDataViewJsDefault = parcelHelpers.interopDefault(_isDataViewJs);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _isBufferLikeJs = require("./_isBufferLike.js");
var _isBufferLikeJsDefault = parcelHelpers.interopDefault(_isBufferLikeJs);
// Is a given value a typed array?
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
    // `ArrayBuffer.isView` is the most future-proof, so use it when available.
    // Otherwise, fall back on the above regular expression.
    return (0, _setupJs.nativeIsView) ? (0, _setupJs.nativeIsView)(obj) && !(0, _isDataViewJsDefault.default)(obj) : (0, _isBufferLikeJsDefault.default)(obj) && typedArrayPattern.test((0, _setupJs.toString).call(obj));
}
exports.default = (0, _setupJs.supportsArrayBuffer) ? isTypedArray : (0, _constantJsDefault.default)(false);

},{"./_setup.js":"j1Opz","./isDataView.js":"1t0pk","./constant.js":"6dl0q","./_isBufferLike.js":"2tre8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6dl0q":[function(require,module,exports) {
// Predicate-generating function. Often useful outside of Underscore.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>constant);
function constant(value) {
    return function() {
        return value;
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2tre8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createSizePropertyCheckJs = require("./_createSizePropertyCheck.js");
var _createSizePropertyCheckJsDefault = parcelHelpers.interopDefault(_createSizePropertyCheckJs);
var _getByteLengthJs = require("./_getByteLength.js");
var _getByteLengthJsDefault = parcelHelpers.interopDefault(_getByteLengthJs);
// Internal helper to determine whether we should spend extensive checks against
// `ArrayBuffer` et al.
exports.default = (0, _createSizePropertyCheckJsDefault.default)((0, _getByteLengthJsDefault.default));

},{"./_createSizePropertyCheck.js":"3UmeP","./_getByteLength.js":"7bY8I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3UmeP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createSizePropertyCheck);
var _setupJs = require("./_setup.js");
function createSizePropertyCheck(getSizeProperty) {
    return function(collection) {
        var sizeProperty = getSizeProperty(collection);
        return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= (0, _setupJs.MAX_ARRAY_INDEX);
    };
}

},{"./_setup.js":"j1Opz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7bY8I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _shallowPropertyJs = require("./_shallowProperty.js");
var _shallowPropertyJsDefault = parcelHelpers.interopDefault(_shallowPropertyJs);
// Internal helper to obtain the `byteLength` property of an object.
exports.default = (0, _shallowPropertyJsDefault.default)("byteLength");

},{"./_shallowProperty.js":"8aNvb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8aNvb":[function(require,module,exports) {
// Internal helper to generate a function to obtain property `key` from `obj`.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>shallowProperty);
function shallowProperty(key) {
    return function(obj) {
        return obj == null ? void 0 : obj[key];
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dK0Pq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isEmpty);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isStringJs = require("./isString.js");
var _isStringJsDefault = parcelHelpers.interopDefault(_isStringJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function isEmpty(obj) {
    if (obj == null) return true;
    // Skip the more expensive `toString`-based type checks if `obj` has no
    // `.length`.
    var length = (0, _getLengthJsDefault.default)(obj);
    if (typeof length == "number" && ((0, _isArrayJsDefault.default)(obj) || (0, _isStringJsDefault.default)(obj) || (0, _isArgumentsJsDefault.default)(obj))) return length === 0;
    return (0, _getLengthJsDefault.default)((0, _keysJsDefault.default)(obj)) === 0;
}

},{"./_getLength.js":"cb0Fe","./isArray.js":"cth5N","./isString.js":"h9vOY","./isArguments.js":"dVyjs","./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cb0Fe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _shallowPropertyJs = require("./_shallowProperty.js");
var _shallowPropertyJsDefault = parcelHelpers.interopDefault(_shallowPropertyJs);
// Internal helper to obtain the `length` property of an object.
exports.default = (0, _shallowPropertyJsDefault.default)("length");

},{"./_shallowProperty.js":"8aNvb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"epVJ3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>keys);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _setupJs = require("./_setup.js");
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _collectNonEnumPropsJs = require("./_collectNonEnumProps.js");
var _collectNonEnumPropsJsDefault = parcelHelpers.interopDefault(_collectNonEnumPropsJs);
function keys(obj) {
    if (!(0, _isObjectJsDefault.default)(obj)) return [];
    if (0, _setupJs.nativeKeys) return (0, _setupJs.nativeKeys)(obj);
    var keys = [];
    for(var key in obj)if ((0, _hasJsDefault.default)(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (0, _setupJs.hasEnumBug) (0, _collectNonEnumPropsJsDefault.default)(obj, keys);
    return keys;
}

},{"./isObject.js":"jS3Se","./_setup.js":"j1Opz","./_has.js":"500LZ","./_collectNonEnumProps.js":"50jyM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"50jyM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>collectNonEnumProps);
var _setupJs = require("./_setup.js");
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
// Internal helper to create a simple lookup structure.
// `collectNonEnumProps` used to depend on `_.contains`, but this led to
// circular imports. `emulatedSet` is a one-off solution that only works for
// arrays of strings.
function emulatedSet(keys) {
    var hash = {};
    for(var l = keys.length, i = 0; i < l; ++i)hash[keys[i]] = true;
    return {
        contains: function(key) {
            return hash[key] === true;
        },
        push: function(key) {
            hash[key] = true;
            return keys.push(key);
        }
    };
}
function collectNonEnumProps(obj, keys) {
    keys = emulatedSet(keys);
    var nonEnumIdx = (0, _setupJs.nonEnumerableProps).length;
    var constructor = obj.constructor;
    var proto = (0, _isFunctionJsDefault.default)(constructor) && constructor.prototype || (0, _setupJs.ObjProto);
    // Constructor is a special case.
    var prop = "constructor";
    if ((0, _hasJsDefault.default)(obj, prop) && !keys.contains(prop)) keys.push(prop);
    while(nonEnumIdx--){
        prop = (0, _setupJs.nonEnumerableProps)[nonEnumIdx];
        if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) keys.push(prop);
    }
}

},{"./_setup.js":"j1Opz","./isFunction.js":"9XYGL","./_has.js":"500LZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aIz4w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isMatch);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function isMatch(object, attrs) {
    var _keys = (0, _keysJsDefault.default)(attrs), length = _keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for(var i = 0; i < length; i++){
        var key = _keys[i];
        if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
}

},{"./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cHWdl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isEqual);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _setupJs = require("./_setup.js");
var _getByteLengthJs = require("./_getByteLength.js");
var _getByteLengthJsDefault = parcelHelpers.interopDefault(_getByteLengthJs);
var _isTypedArrayJs = require("./isTypedArray.js");
var _isTypedArrayJsDefault = parcelHelpers.interopDefault(_isTypedArrayJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var _isDataViewJs = require("./isDataView.js");
var _isDataViewJsDefault = parcelHelpers.interopDefault(_isDataViewJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _toBufferViewJs = require("./_toBufferView.js");
var _toBufferViewJsDefault = parcelHelpers.interopDefault(_toBufferViewJs);
// We use this string twice, so give it a name for minification.
var tagDataView = "[object DataView]";
// Internal recursive comparison function for `_.isEqual`.
function eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== "function" && type !== "object" && typeof b != "object") return false;
    return deepEq(a, b, aStack, bStack);
}
// Internal recursive comparison function for `_.isEqual`.
function deepEq(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof (0, _underscoreJsDefault.default)) a = a._wrapped;
    if (b instanceof (0, _underscoreJsDefault.default)) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = (0, _setupJs.toString).call(a);
    if (className !== (0, _setupJs.toString).call(b)) return false;
    // Work around a bug in IE 10 - Edge 13.
    if ((0, _stringTagBugJs.hasStringTagBug) && className == "[object Object]" && (0, _isDataViewJsDefault.default)(a)) {
        if (!(0, _isDataViewJsDefault.default)(b)) return false;
        className = tagDataView;
    }
    switch(className){
        // These types are compared by value.
        case "[object RegExp]":
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case "[object String]":
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return "" + a === "" + b;
        case "[object Number]":
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN.
            if (+a !== +a) return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case "[object Date]":
        case "[object Boolean]":
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
        case "[object Symbol]":
            return (0, _setupJs.SymbolProto).valueOf.call(a) === (0, _setupJs.SymbolProto).valueOf.call(b);
        case "[object ArrayBuffer]":
        case tagDataView:
            // Coerce to typed array so we can fall through.
            return deepEq((0, _toBufferViewJsDefault.default)(a), (0, _toBufferViewJsDefault.default)(b), aStack, bStack);
    }
    var areArrays = className === "[object Array]";
    if (!areArrays && (0, _isTypedArrayJsDefault.default)(a)) {
        var byteLength = (0, _getByteLengthJsDefault.default)(a);
        if (byteLength !== (0, _getByteLengthJsDefault.default)(b)) return false;
        if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
        areArrays = true;
    }
    if (!areArrays) {
        if (typeof a != "object" || typeof b != "object") return false;
        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !((0, _isFunctionJsDefault.default)(aCtor) && aCtor instanceof aCtor && (0, _isFunctionJsDefault.default)(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) return false;
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while(length--){
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a) return bStack[length] === b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length) return false;
        // Deep compare the contents, ignoring non-numeric properties.
        while(length--){
            if (!eq(a[length], b[length], aStack, bStack)) return false;
        }
    } else {
        // Deep compare objects.
        var _keys = (0, _keysJsDefault.default)(a), key;
        length = _keys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if ((0, _keysJsDefault.default)(b).length !== length) return false;
        while(length--){
            // Deep compare each member
            key = _keys[length];
            if (!((0, _hasJsDefault.default)(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
}
function isEqual(a, b) {
    return eq(a, b);
}

},{"./underscore.js":"cZn3h","./_setup.js":"j1Opz","./_getByteLength.js":"7bY8I","./isTypedArray.js":"6Wsfb","./isFunction.js":"9XYGL","./_stringTagBug.js":"2UGte","./isDataView.js":"1t0pk","./keys.js":"epVJ3","./_has.js":"500LZ","./_toBufferView.js":"kwSPW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cZn3h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_);
var _setupJs = require("./_setup.js");
function _(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
}
_.VERSION = (0, _setupJs.VERSION);
// Extracts the result from a wrapped and chained object.
_.prototype.value = function() {
    return this._wrapped;
};
// Provide unwrapping proxies for some methods used in engine operations
// such as arithmetic and JSON stringification.
_.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
_.prototype.toString = function() {
    return String(this._wrapped);
};

},{"./_setup.js":"j1Opz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kwSPW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>toBufferView);
var _getByteLengthJs = require("./_getByteLength.js");
var _getByteLengthJsDefault = parcelHelpers.interopDefault(_getByteLengthJs);
function toBufferView(bufferSource) {
    return new Uint8Array(bufferSource.buffer || bufferSource, bufferSource.byteOffset || 0, (0, _getByteLengthJsDefault.default)(bufferSource));
}

},{"./_getByteLength.js":"7bY8I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k6Fdu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var _methodFingerprintJs = require("./_methodFingerprint.js");
exports.default = (0, _stringTagBugJs.isIE11) ? (0, _methodFingerprintJs.ie11fingerprint)((0, _methodFingerprintJs.mapMethods)) : (0, _tagTesterJsDefault.default)("Map");

},{"./_tagTester.js":"8zfWu","./_stringTagBug.js":"2UGte","./_methodFingerprint.js":"c9ykx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c9ykx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Since the regular `Object.prototype.toString` type tests don't work for
// some types in IE 11, we use a fingerprinting heuristic instead, based
// on the methods. It's not great, but it's the best we got.
// The fingerprint method lists are defined below.
parcelHelpers.export(exports, "ie11fingerprint", ()=>ie11fingerprint);
parcelHelpers.export(exports, "mapMethods", ()=>mapMethods);
parcelHelpers.export(exports, "weakMapMethods", ()=>weakMapMethods);
parcelHelpers.export(exports, "setMethods", ()=>setMethods);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
function ie11fingerprint(methods) {
    var length = (0, _getLengthJsDefault.default)(methods);
    return function(obj) {
        if (obj == null) return false;
        // `Map`, `WeakMap` and `Set` have no enumerable keys.
        var keys = (0, _allKeysJsDefault.default)(obj);
        if ((0, _getLengthJsDefault.default)(keys)) return false;
        for(var i = 0; i < length; i++){
            if (!(0, _isFunctionJsDefault.default)(obj[methods[i]])) return false;
        }
        // If we are testing against `WeakMap`, we need to ensure that
        // `obj` doesn't have a `forEach` method in order to distinguish
        // it from a regular `Map`.
        return methods !== weakMapMethods || !(0, _isFunctionJsDefault.default)(obj[forEachName]);
    };
}
// In the interest of compact minification, we write
// each string in the fingerprints only once.
var forEachName = "forEach", hasName = "has", commonInit = [
    "clear",
    "delete"
], mapTail = [
    "get",
    hasName,
    "set"
];
var mapMethods = commonInit.concat(forEachName, mapTail), weakMapMethods = commonInit.concat(mapTail), setMethods = [
    "add"
].concat(commonInit, forEachName, hasName);

},{"./_getLength.js":"cb0Fe","./isFunction.js":"9XYGL","./allKeys.js":"iL9rU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iL9rU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>allKeys);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _setupJs = require("./_setup.js");
var _collectNonEnumPropsJs = require("./_collectNonEnumProps.js");
var _collectNonEnumPropsJsDefault = parcelHelpers.interopDefault(_collectNonEnumPropsJs);
function allKeys(obj) {
    if (!(0, _isObjectJsDefault.default)(obj)) return [];
    var keys = [];
    for(var key in obj)keys.push(key);
    // Ahem, IE < 9.
    if (0, _setupJs.hasEnumBug) (0, _collectNonEnumPropsJsDefault.default)(obj, keys);
    return keys;
}

},{"./isObject.js":"jS3Se","./_setup.js":"j1Opz","./_collectNonEnumProps.js":"50jyM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ebF8O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var _methodFingerprintJs = require("./_methodFingerprint.js");
exports.default = (0, _stringTagBugJs.isIE11) ? (0, _methodFingerprintJs.ie11fingerprint)((0, _methodFingerprintJs.weakMapMethods)) : (0, _tagTesterJsDefault.default)("WeakMap");

},{"./_tagTester.js":"8zfWu","./_stringTagBug.js":"2UGte","./_methodFingerprint.js":"c9ykx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Fl86y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
var _stringTagBugJs = require("./_stringTagBug.js");
var _methodFingerprintJs = require("./_methodFingerprint.js");
exports.default = (0, _stringTagBugJs.isIE11) ? (0, _methodFingerprintJs.ie11fingerprint)((0, _methodFingerprintJs.setMethods)) : (0, _tagTesterJsDefault.default)("Set");

},{"./_tagTester.js":"8zfWu","./_stringTagBug.js":"2UGte","./_methodFingerprint.js":"c9ykx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"isH5L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagTesterJs = require("./_tagTester.js");
var _tagTesterJsDefault = parcelHelpers.interopDefault(_tagTesterJs);
exports.default = (0, _tagTesterJsDefault.default)("WeakSet");

},{"./_tagTester.js":"8zfWu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1I2Yc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>values);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function values(obj) {
    var _keys = (0, _keysJsDefault.default)(obj);
    var length = _keys.length;
    var values = Array(length);
    for(var i = 0; i < length; i++)values[i] = obj[_keys[i]];
    return values;
}

},{"./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bdrSk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>pairs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function pairs(obj) {
    var _keys = (0, _keysJsDefault.default)(obj);
    var length = _keys.length;
    var pairs = Array(length);
    for(var i = 0; i < length; i++)pairs[i] = [
        _keys[i],
        obj[_keys[i]]
    ];
    return pairs;
}

},{"./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1xVUE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>invert);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function invert(obj) {
    var result = {};
    var _keys = (0, _keysJsDefault.default)(obj);
    for(var i = 0, length = _keys.length; i < length; i++)result[obj[_keys[i]]] = _keys[i];
    return result;
}

},{"./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6kKwG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>functions);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
function functions(obj) {
    var names = [];
    for(var key in obj)if ((0, _isFunctionJsDefault.default)(obj[key])) names.push(key);
    return names.sort();
}

},{"./isFunction.js":"9XYGL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3CC22":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createAssignerJs = require("./_createAssigner.js");
var _createAssignerJsDefault = parcelHelpers.interopDefault(_createAssignerJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
// Extend a given object with all the properties in passed-in object(s).
exports.default = (0, _createAssignerJsDefault.default)((0, _allKeysJsDefault.default));

},{"./_createAssigner.js":"eDRTj","./allKeys.js":"iL9rU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eDRTj":[function(require,module,exports) {
// An internal function for creating assigner functions.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createAssigner);
function createAssigner(keysFunc, defaults) {
    return function(obj) {
        var length = arguments.length;
        if (defaults) obj = Object(obj);
        if (length < 2 || obj == null) return obj;
        for(var index = 1; index < length; index++){
            var source = arguments[index], keys = keysFunc(source), l = keys.length;
            for(var i = 0; i < l; i++){
                var key = keys[i];
                if (!defaults || obj[key] === void 0) obj[key] = source[key];
            }
        }
        return obj;
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Fpdj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createAssignerJs = require("./_createAssigner.js");
var _createAssignerJsDefault = parcelHelpers.interopDefault(_createAssignerJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
// Assigns a given object with all the own properties in the passed-in
// object(s).
// (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
exports.default = (0, _createAssignerJsDefault.default)((0, _keysJsDefault.default));

},{"./_createAssigner.js":"eDRTj","./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2QZRH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createAssignerJs = require("./_createAssigner.js");
var _createAssignerJsDefault = parcelHelpers.interopDefault(_createAssignerJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
// Fill in a given object with default properties.
exports.default = (0, _createAssignerJsDefault.default)((0, _allKeysJsDefault.default), true);

},{"./_createAssigner.js":"eDRTj","./allKeys.js":"iL9rU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"27kIz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>create);
var _baseCreateJs = require("./_baseCreate.js");
var _baseCreateJsDefault = parcelHelpers.interopDefault(_baseCreateJs);
var _extendOwnJs = require("./extendOwn.js");
var _extendOwnJsDefault = parcelHelpers.interopDefault(_extendOwnJs);
function create(prototype, props) {
    var result = (0, _baseCreateJsDefault.default)(prototype);
    if (props) (0, _extendOwnJsDefault.default)(result, props);
    return result;
}

},{"./_baseCreate.js":"4BZA8","./extendOwn.js":"7Fpdj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4BZA8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>baseCreate);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _setupJs = require("./_setup.js");
// Create a naked function reference for surrogate-prototype-swapping.
function ctor() {
    return function() {};
}
function baseCreate(prototype) {
    if (!(0, _isObjectJsDefault.default)(prototype)) return {};
    if (0, _setupJs.nativeCreate) return (0, _setupJs.nativeCreate)(prototype);
    var Ctor = ctor();
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
}

},{"./isObject.js":"jS3Se","./_setup.js":"j1Opz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9aJbO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>clone);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _extendJs = require("./extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
function clone(obj) {
    if (!(0, _isObjectJsDefault.default)(obj)) return obj;
    return (0, _isArrayJsDefault.default)(obj) ? obj.slice() : (0, _extendJsDefault.default)({}, obj);
}

},{"./isObject.js":"jS3Se","./isArray.js":"cth5N","./extend.js":"3CC22","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5KIUX":[function(require,module,exports) {
// Invokes `interceptor` with the `obj` and then returns `obj`.
// The primary purpose of this method is to "tap into" a method chain, in
// order to perform operations on intermediate results within the chain.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>tap);
function tap(obj, interceptor) {
    interceptor(obj);
    return obj;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d7ATL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>get);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
var _deepGetJs = require("./_deepGet.js");
var _deepGetJsDefault = parcelHelpers.interopDefault(_deepGetJs);
var _isUndefinedJs = require("./isUndefined.js");
var _isUndefinedJsDefault = parcelHelpers.interopDefault(_isUndefinedJs);
function get(object, path, defaultValue) {
    var value = (0, _deepGetJsDefault.default)(object, (0, _toPathJsDefault.default)(path));
    return (0, _isUndefinedJsDefault.default)(value) ? defaultValue : value;
}

},{"./_toPath.js":"fQeyr","./_deepGet.js":"4yNnp","./isUndefined.js":"76Kia","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fQeyr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>toPath);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _toPathJs = require("./toPath.js");
function toPath(path) {
    return (0, _underscoreJsDefault.default).toPath(path);
}

},{"./underscore.js":"cZn3h","./toPath.js":"2926x","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2926x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>toPath);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
function toPath(path) {
    return (0, _isArrayJsDefault.default)(path) ? path : [
        path
    ];
}
(0, _underscoreJsDefault.default).toPath = toPath;

},{"./underscore.js":"cZn3h","./isArray.js":"cth5N","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4yNnp":[function(require,module,exports) {
// Internal function to obtain a nested property in `obj` along `path`.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>deepGet);
function deepGet(obj, path) {
    var length = path.length;
    for(var i = 0; i < length; i++){
        if (obj == null) return void 0;
        obj = obj[path[i]];
    }
    return length ? obj : void 0;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3CTQc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>has);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
function has(obj, path) {
    path = (0, _toPathJsDefault.default)(path);
    var length = path.length;
    for(var i = 0; i < length; i++){
        var key = path[i];
        if (!(0, _hasJsDefault.default)(obj, key)) return false;
        obj = obj[key];
    }
    return !!length;
}

},{"./_has.js":"500LZ","./_toPath.js":"fQeyr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eLKLX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>mapObject);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function mapObject(obj, iteratee, context) {
    iteratee = (0, _cbJsDefault.default)(iteratee, context);
    var _keys = (0, _keysJsDefault.default)(obj), length = _keys.length, results = {};
    for(var index = 0; index < length; index++){
        var currentKey = _keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
}

},{"./_cb.js":"hwRTD","./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hwRTD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>cb);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _baseIterateeJs = require("./_baseIteratee.js");
var _baseIterateeJsDefault = parcelHelpers.interopDefault(_baseIterateeJs);
var _iterateeJs = require("./iteratee.js");
var _iterateeJsDefault = parcelHelpers.interopDefault(_iterateeJs);
function cb(value, context, argCount) {
    if ((0, _underscoreJsDefault.default).iteratee !== (0, _iterateeJsDefault.default)) return (0, _underscoreJsDefault.default).iteratee(value, context);
    return (0, _baseIterateeJsDefault.default)(value, context, argCount);
}

},{"./underscore.js":"cZn3h","./_baseIteratee.js":"8cF3R","./iteratee.js":"b93XD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8cF3R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>baseIteratee);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _matcherJs = require("./matcher.js");
var _matcherJsDefault = parcelHelpers.interopDefault(_matcherJs);
var _propertyJs = require("./property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
function baseIteratee(value, context, argCount) {
    if (value == null) return 0, _identityJsDefault.default;
    if ((0, _isFunctionJsDefault.default)(value)) return (0, _optimizeCbJsDefault.default)(value, context, argCount);
    if ((0, _isObjectJsDefault.default)(value) && !(0, _isArrayJsDefault.default)(value)) return (0, _matcherJsDefault.default)(value);
    return (0, _propertyJsDefault.default)(value);
}

},{"./identity.js":"iCRMn","./isFunction.js":"9XYGL","./isObject.js":"jS3Se","./isArray.js":"cth5N","./matcher.js":"3wGZ7","./property.js":"96pvf","./_optimizeCb.js":"ib91j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iCRMn":[function(require,module,exports) {
// Keep the identity function around for default iteratees.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>identity);
function identity(value) {
    return value;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3wGZ7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>matcher);
var _extendOwnJs = require("./extendOwn.js");
var _extendOwnJsDefault = parcelHelpers.interopDefault(_extendOwnJs);
var _isMatchJs = require("./isMatch.js");
var _isMatchJsDefault = parcelHelpers.interopDefault(_isMatchJs);
function matcher(attrs) {
    attrs = (0, _extendOwnJsDefault.default)({}, attrs);
    return function(obj) {
        return (0, _isMatchJsDefault.default)(obj, attrs);
    };
}

},{"./extendOwn.js":"7Fpdj","./isMatch.js":"aIz4w","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"96pvf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>property);
var _deepGetJs = require("./_deepGet.js");
var _deepGetJsDefault = parcelHelpers.interopDefault(_deepGetJs);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
function property(path) {
    path = (0, _toPathJsDefault.default)(path);
    return function(obj) {
        return (0, _deepGetJsDefault.default)(obj, path);
    };
}

},{"./_deepGet.js":"4yNnp","./_toPath.js":"fQeyr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ib91j":[function(require,module,exports) {
// Internal function that returns an efficient (for current engines) version
// of the passed-in callback, to be repeatedly applied in other Underscore
// functions.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>optimizeCb);
function optimizeCb(func, context, argCount) {
    if (context === void 0) return func;
    switch(argCount == null ? 3 : argCount){
        case 1:
            return function(value) {
                return func.call(context, value);
            };
        // The 2-argument case is omitted because we‚Äôre not using it.
        case 3:
            return function(value, index, collection) {
                return func.call(context, value, index, collection);
            };
        case 4:
            return function(accumulator, value, index, collection) {
                return func.call(context, accumulator, value, index, collection);
            };
    }
    return function() {
        return func.apply(context, arguments);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b93XD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>iteratee);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _baseIterateeJs = require("./_baseIteratee.js");
var _baseIterateeJsDefault = parcelHelpers.interopDefault(_baseIterateeJs);
function iteratee(value, context) {
    return (0, _baseIterateeJsDefault.default)(value, context, Infinity);
}
(0, _underscoreJsDefault.default).iteratee = iteratee;

},{"./underscore.js":"cZn3h","./_baseIteratee.js":"8cF3R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3qYXh":[function(require,module,exports) {
// Predicate-generating function. Often useful outside of Underscore.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>noop);
function noop() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iwYrg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>propertyOf);
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _getJs = require("./get.js");
var _getJsDefault = parcelHelpers.interopDefault(_getJs);
function propertyOf(obj) {
    if (obj == null) return 0, _noopJsDefault.default;
    return function(path) {
        return (0, _getJsDefault.default)(obj, path);
    };
}

},{"./noop.js":"3qYXh","./get.js":"d7ATL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"pyCYh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>times);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
function times(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = (0, _optimizeCbJsDefault.default)(iteratee, context, 1);
    for(var i = 0; i < n; i++)accum[i] = iteratee(i);
    return accum;
}

},{"./_optimizeCb.js":"ib91j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"imiVs":[function(require,module,exports) {
// Return a random integer between `min` and `max` (inclusive).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>random);
function random(min, max) {
    if (max == null) {
        max = min;
        min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aOx7w":[function(require,module,exports) {
// A (possibly faster) way to get the current timestamp as an integer.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = Date.now || function() {
    return new Date().getTime();
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7w3y8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createEscaperJs = require("./_createEscaper.js");
var _createEscaperJsDefault = parcelHelpers.interopDefault(_createEscaperJs);
var _escapeMapJs = require("./_escapeMap.js");
var _escapeMapJsDefault = parcelHelpers.interopDefault(_escapeMapJs);
// Function for escaping strings to HTML interpolation.
exports.default = (0, _createEscaperJsDefault.default)((0, _escapeMapJsDefault.default));

},{"./_createEscaper.js":"5bjMZ","./_escapeMap.js":"71n9D","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5bjMZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createEscaper);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function createEscaper(map) {
    var escaper = function(match) {
        return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = "(?:" + (0, _keysJsDefault.default)(map).join("|") + ")";
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, "g");
    return function(string) {
        string = string == null ? "" : "" + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
}

},{"./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"71n9D":[function(require,module,exports) {
// Internal list of HTML entities for escaping.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gmHHm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createEscaperJs = require("./_createEscaper.js");
var _createEscaperJsDefault = parcelHelpers.interopDefault(_createEscaperJs);
var _unescapeMapJs = require("./_unescapeMap.js");
var _unescapeMapJsDefault = parcelHelpers.interopDefault(_unescapeMapJs);
// Function for unescaping strings from HTML interpolation.
exports.default = (0, _createEscaperJsDefault.default)((0, _unescapeMapJsDefault.default));

},{"./_createEscaper.js":"5bjMZ","./_unescapeMap.js":"21Nyc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"21Nyc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _invertJs = require("./invert.js");
var _invertJsDefault = parcelHelpers.interopDefault(_invertJs);
var _escapeMapJs = require("./_escapeMap.js");
var _escapeMapJsDefault = parcelHelpers.interopDefault(_escapeMapJs);
// Internal list of HTML entities for unescaping.
exports.default = (0, _invertJsDefault.default)((0, _escapeMapJsDefault.default));

},{"./invert.js":"1xVUE","./_escapeMap.js":"71n9D","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h5qH1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
// By default, Underscore uses ERB-style template delimiters. Change the
// following template settings to use alternative delimiters.
exports.default = (0, _underscoreJsDefault.default).templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
};

},{"./underscore.js":"cZn3h","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"czkRN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>template);
var _defaultsJs = require("./defaults.js");
var _defaultsJsDefault = parcelHelpers.interopDefault(_defaultsJs);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _templateSettingsJs = require("./templateSettings.js");
// When customizing `_.templateSettings`, if you don't want to define an
// interpolation, evaluation or escaping regex, we need one that is
// guaranteed not to match.
var noMatch = /(.)^/;
// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes = {
    "'": "'",
    "\\": "\\",
    "\r": "r",
    "\n": "n",
    "\u2028": "u2028",
    "\u2029": "u2029"
};
var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
function escapeChar(match) {
    return "\\" + escapes[match];
}
// In order to prevent third-party code injection through
// `_.templateSettings.variable`, we test it against the following regular
// expression. It is intentionally a bit more liberal than just matching valid
// identifiers, but still prevents possible loopholes through defaults or
// destructuring assignment.
var bareIdentifier = /^\s*(\w|\$)+\s*$/;
function template(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = (0, _defaultsJsDefault.default)({}, settings, (0, _underscoreJsDefault.default).templateSettings);
    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
    ].join("|") + "|$", "g");
    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
        index = offset + match.length;
        if (escape) source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        else if (interpolate) source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        else if (evaluate) source += "';\n" + evaluate + "\n__p+='";
        // Adobe VMs need the match returned to produce the correct offset.
        return match;
    });
    source += "';\n";
    var argument = settings.variable;
    if (argument) {
        // Insure against third-party code injection. (CVE-2021-23358)
        if (!bareIdentifier.test(argument)) throw new Error("variable is not a bare identifier: " + argument);
    } else {
        // If a variable is not specified, place data values in local scope.
        source = "with(obj||{}){\n" + source + "}\n";
        argument = "obj";
    }
    source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
    var render;
    try {
        render = new Function(argument, "_", source);
    } catch (e) {
        e.source = source;
        throw e;
    }
    var template = function(data) {
        return render.call(this, data, (0, _underscoreJsDefault.default));
    };
    // Provide the compiled source as a convenience for precompilation.
    template.source = "function(" + argument + "){\n" + source + "}";
    return template;
}

},{"./defaults.js":"2QZRH","./underscore.js":"cZn3h","./templateSettings.js":"h5qH1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4l1X6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>result);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
function result(obj, path, fallback) {
    path = (0, _toPathJsDefault.default)(path);
    var length = path.length;
    if (!length) return (0, _isFunctionJsDefault.default)(fallback) ? fallback.call(obj) : fallback;
    for(var i = 0; i < length; i++){
        var prop = obj == null ? void 0 : obj[path[i]];
        if (prop === void 0) {
            prop = fallback;
            i = length; // Ensure we don't continue iterating.
        }
        obj = (0, _isFunctionJsDefault.default)(prop) ? prop.call(obj) : prop;
    }
    return obj;
}

},{"./isFunction.js":"9XYGL","./_toPath.js":"fQeyr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"arUrP":[function(require,module,exports) {
// Generate a unique integer id (unique within the entire client session).
// Useful for temporary DOM ids.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>uniqueId);
var idCounter = 0;
function uniqueId(prefix) {
    var id = ++idCounter + "";
    return prefix ? prefix + id : id;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jSwHe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>chain);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
function chain(obj) {
    var instance = (0, _underscoreJsDefault.default)(obj);
    instance._chain = true;
    return instance;
}

},{"./underscore.js":"cZn3h","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fLBUm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _executeBoundJs = require("./_executeBound.js");
var _executeBoundJsDefault = parcelHelpers.interopDefault(_executeBoundJs);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
// Partially apply a function by creating a version that has had some of its
// arguments pre-filled, without changing its dynamic `this` context. `_` acts
// as a placeholder by default, allowing any combination of arguments to be
// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
var partial = (0, _restArgumentsJsDefault.default)(function(func, boundArgs) {
    var placeholder = partial.placeholder;
    var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for(var i = 0; i < length; i++)args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
        while(position < arguments.length)args.push(arguments[position++]);
        return (0, _executeBoundJsDefault.default)(func, bound, this, this, args);
    };
    return bound;
});
partial.placeholder = (0, _underscoreJsDefault.default);
exports.default = partial;

},{"./restArguments.js":"iHiW5","./_executeBound.js":"9uJKk","./underscore.js":"cZn3h","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9uJKk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>executeBound);
var _baseCreateJs = require("./_baseCreate.js");
var _baseCreateJsDefault = parcelHelpers.interopDefault(_baseCreateJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = (0, _baseCreateJsDefault.default)(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if ((0, _isObjectJsDefault.default)(result)) return result;
    return self;
}

},{"./_baseCreate.js":"4BZA8","./isObject.js":"jS3Se","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kSGgn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _executeBoundJs = require("./_executeBound.js");
var _executeBoundJsDefault = parcelHelpers.interopDefault(_executeBoundJs);
// Create a function bound to a given object (assigning `this`, and arguments,
// optionally).
exports.default = (0, _restArgumentsJsDefault.default)(function(func, context, args) {
    if (!(0, _isFunctionJsDefault.default)(func)) throw new TypeError("Bind must be called on a function");
    var bound = (0, _restArgumentsJsDefault.default)(function(callArgs) {
        return (0, _executeBoundJsDefault.default)(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
});

},{"./restArguments.js":"iHiW5","./isFunction.js":"9XYGL","./_executeBound.js":"9uJKk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2htre":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _bindJs = require("./bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
// Bind a number of an object's methods to that object. Remaining arguments
// are the method names to be bound. Useful for ensuring that all callbacks
// defined on an object belong to it.
exports.default = (0, _restArgumentsJsDefault.default)(function(obj, keys) {
    keys = (0, _flattenJsDefault.default)(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error("bindAll must be passed function names");
    while(index--){
        var key = keys[index];
        obj[key] = (0, _bindJsDefault.default)(obj[key], obj);
    }
    return obj;
});

},{"./restArguments.js":"iHiW5","./_flatten.js":"kRaRq","./bind.js":"kSGgn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kRaRq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>flatten);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
function flatten(input, depth, strict, output) {
    output = output || [];
    if (!depth && depth !== 0) depth = Infinity;
    else if (depth <= 0) return output.concat(input);
    var idx = output.length;
    for(var i = 0, length = (0, _getLengthJsDefault.default)(input); i < length; i++){
        var value = input[i];
        if ((0, _isArrayLikeJsDefault.default)(value) && ((0, _isArrayJsDefault.default)(value) || (0, _isArgumentsJsDefault.default)(value))) {
            // Flatten current level of array or arguments object.
            if (depth > 1) {
                flatten(value, depth - 1, strict, output);
                idx = output.length;
            } else {
                var j = 0, len = value.length;
                while(j < len)output[idx++] = value[j++];
            }
        } else if (!strict) output[idx++] = value;
    }
    return output;
}

},{"./_getLength.js":"cb0Fe","./_isArrayLike.js":"7w1Hu","./isArray.js":"cth5N","./isArguments.js":"dVyjs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7w1Hu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createSizePropertyCheckJs = require("./_createSizePropertyCheck.js");
var _createSizePropertyCheckJsDefault = parcelHelpers.interopDefault(_createSizePropertyCheckJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
// Internal helper for collection methods to determine whether a collection
// should be iterated as an array or as an object.
// Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
// Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
exports.default = (0, _createSizePropertyCheckJsDefault.default)((0, _getLengthJsDefault.default));

},{"./_createSizePropertyCheck.js":"3UmeP","./_getLength.js":"cb0Fe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f9ZJj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>memoize);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
function memoize(func, hasher) {
    var memoize = function(key) {
        var cache = memoize.cache;
        var address = "" + (hasher ? hasher.apply(this, arguments) : key);
        if (!(0, _hasJsDefault.default)(cache, address)) cache[address] = func.apply(this, arguments);
        return cache[address];
    };
    memoize.cache = {};
    return memoize;
}

},{"./_has.js":"500LZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aIkq2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
// Delays a function for the given number of milliseconds, and then calls
// it with the arguments supplied.
exports.default = (0, _restArgumentsJsDefault.default)(function(func, wait, args) {
    return setTimeout(function() {
        return func.apply(null, args);
    }, wait);
});

},{"./restArguments.js":"iHiW5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8wSef":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
var _delayJs = require("./delay.js");
var _delayJsDefault = parcelHelpers.interopDefault(_delayJs);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
// Defers a function, scheduling it to run after the current call stack has
// cleared.
exports.default = (0, _partialJsDefault.default)((0, _delayJsDefault.default), (0, _underscoreJsDefault.default), 1);

},{"./partial.js":"fLBUm","./delay.js":"aIkq2","./underscore.js":"cZn3h","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5FGQl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>throttle);
var _nowJs = require("./now.js");
var _nowJsDefault = parcelHelpers.interopDefault(_nowJs);
function throttle(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
        previous = options.leading === false ? 0 : (0, _nowJsDefault.default)();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
    };
    var throttled = function() {
        var _now = (0, _nowJsDefault.default)();
        if (!previous && options.leading === false) previous = _now;
        var remaining = wait - (_now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = _now;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) timeout = setTimeout(later, remaining);
        return result;
    };
    throttled.cancel = function() {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
    };
    return throttled;
}

},{"./now.js":"aOx7w","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aVPiV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>debounce);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _nowJs = require("./now.js");
var _nowJsDefault = parcelHelpers.interopDefault(_nowJs);
function debounce(func, wait, immediate) {
    var timeout, previous, args, result, context;
    var later = function() {
        var passed = (0, _nowJsDefault.default)() - previous;
        if (wait > passed) timeout = setTimeout(later, wait - passed);
        else {
            timeout = null;
            if (!immediate) result = func.apply(context, args);
            // This check is needed because `func` can recursively invoke `debounced`.
            if (!timeout) args = context = null;
        }
    };
    var debounced = (0, _restArgumentsJsDefault.default)(function(_args) {
        context = this;
        args = _args;
        previous = (0, _nowJsDefault.default)();
        if (!timeout) {
            timeout = setTimeout(later, wait);
            if (immediate) result = func.apply(context, args);
        }
        return result;
    });
    debounced.cancel = function() {
        clearTimeout(timeout);
        timeout = args = context = null;
    };
    return debounced;
}

},{"./restArguments.js":"iHiW5","./now.js":"aOx7w","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"34WFJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>wrap);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
function wrap(func, wrapper) {
    return (0, _partialJsDefault.default)(wrapper, func);
}

},{"./partial.js":"fLBUm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"juYC5":[function(require,module,exports) {
// Returns a negated version of the passed-in predicate.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>negate);
function negate(predicate) {
    return function() {
        return !predicate.apply(this, arguments);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f2NYc":[function(require,module,exports) {
// Returns a function that is the composition of a list of functions, each
// consuming the return value of the function that follows.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>compose);
function compose() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
        var i = start;
        var result = args[start].apply(this, arguments);
        while(i--)result = args[i].call(this, result);
        return result;
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7w1Ut":[function(require,module,exports) {
// Returns a function that will only be executed on and after the Nth call.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>after);
function after(times, func) {
    return function() {
        if (--times < 1) return func.apply(this, arguments);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ezKMS":[function(require,module,exports) {
// Returns a function that will only be executed up to (but not including) the
// Nth call.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>before);
function before(times, func) {
    var memo;
    return function() {
        if (--times > 0) memo = func.apply(this, arguments);
        if (times <= 1) func = null;
        return memo;
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1RAuX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
var _beforeJs = require("./before.js");
var _beforeJsDefault = parcelHelpers.interopDefault(_beforeJs);
// Returns a function that will be executed at most one time, no matter how
// often you call it. Useful for lazy initialization.
exports.default = (0, _partialJsDefault.default)((0, _beforeJsDefault.default), 2);

},{"./partial.js":"fLBUm","./before.js":"ezKMS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eLj2O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>findKey);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function findKey(obj, predicate, context) {
    predicate = (0, _cbJsDefault.default)(predicate, context);
    var _keys = (0, _keysJsDefault.default)(obj), key;
    for(var i = 0, length = _keys.length; i < length; i++){
        key = _keys[i];
        if (predicate(obj[key], key, obj)) return key;
    }
}

},{"./_cb.js":"hwRTD","./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cs9dN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createPredicateIndexFinderJs = require("./_createPredicateIndexFinder.js");
var _createPredicateIndexFinderJsDefault = parcelHelpers.interopDefault(_createPredicateIndexFinderJs);
// Returns the first index on an array-like that passes a truth test.
exports.default = (0, _createPredicateIndexFinderJsDefault.default)(1);

},{"./_createPredicateIndexFinder.js":"MoeMM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"MoeMM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createPredicateIndexFinder);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
        predicate = (0, _cbJsDefault.default)(predicate, context);
        var length = (0, _getLengthJsDefault.default)(array);
        var index = dir > 0 ? 0 : length - 1;
        for(; index >= 0 && index < length; index += dir){
            if (predicate(array[index], index, array)) return index;
        }
        return -1;
    };
}

},{"./_cb.js":"hwRTD","./_getLength.js":"cb0Fe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8rc9q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createPredicateIndexFinderJs = require("./_createPredicateIndexFinder.js");
var _createPredicateIndexFinderJsDefault = parcelHelpers.interopDefault(_createPredicateIndexFinderJs);
// Returns the last index on an array-like that passes a truth test.
exports.default = (0, _createPredicateIndexFinderJsDefault.default)(-1);

},{"./_createPredicateIndexFinder.js":"MoeMM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ixTcB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>sortedIndex);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
function sortedIndex(array, obj, iteratee, context) {
    iteratee = (0, _cbJsDefault.default)(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = (0, _getLengthJsDefault.default)(array);
    while(low < high){
        var mid = Math.floor((low + high) / 2);
        if (iteratee(array[mid]) < value) low = mid + 1;
        else high = mid;
    }
    return low;
}

},{"./_cb.js":"hwRTD","./_getLength.js":"cb0Fe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3FyCZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _sortedIndexJs = require("./sortedIndex.js");
var _sortedIndexJsDefault = parcelHelpers.interopDefault(_sortedIndexJs);
var _findIndexJs = require("./findIndex.js");
var _findIndexJsDefault = parcelHelpers.interopDefault(_findIndexJs);
var _createIndexFinderJs = require("./_createIndexFinder.js");
var _createIndexFinderJsDefault = parcelHelpers.interopDefault(_createIndexFinderJs);
// Return the position of the first occurrence of an item in an array,
// or -1 if the item is not included in the array.
// If the array is large and already in sort order, pass `true`
// for **isSorted** to use binary search.
exports.default = (0, _createIndexFinderJsDefault.default)(1, (0, _findIndexJsDefault.default), (0, _sortedIndexJsDefault.default));

},{"./sortedIndex.js":"ixTcB","./findIndex.js":"cs9dN","./_createIndexFinder.js":"7sDEF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7sDEF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createIndexFinder);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _setupJs = require("./_setup.js");
var _isNaNJs = require("./isNaN.js");
var _isNaNJsDefault = parcelHelpers.interopDefault(_isNaNJs);
function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
        var i = 0, length = (0, _getLengthJsDefault.default)(array);
        if (typeof idx == "number") {
            if (dir > 0) i = idx >= 0 ? idx : Math.max(idx + length, i);
            else length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        } else if (sortedIndex && idx && length) {
            idx = sortedIndex(array, item);
            return array[idx] === item ? idx : -1;
        }
        if (item !== item) {
            idx = predicateFind((0, _setupJs.slice).call(array, i, length), (0, _isNaNJsDefault.default));
            return idx >= 0 ? idx + i : -1;
        }
        for(idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir){
            if (array[idx] === item) return idx;
        }
        return -1;
    };
}

},{"./_getLength.js":"cb0Fe","./_setup.js":"j1Opz","./isNaN.js":"3QjxN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7jQpU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _findLastIndexJs = require("./findLastIndex.js");
var _findLastIndexJsDefault = parcelHelpers.interopDefault(_findLastIndexJs);
var _createIndexFinderJs = require("./_createIndexFinder.js");
var _createIndexFinderJsDefault = parcelHelpers.interopDefault(_createIndexFinderJs);
// Return the position of the last occurrence of an item in an array,
// or -1 if the item is not included in the array.
exports.default = (0, _createIndexFinderJsDefault.default)(-1, (0, _findLastIndexJsDefault.default));

},{"./findLastIndex.js":"8rc9q","./_createIndexFinder.js":"7sDEF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lLtqo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>find);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _findIndexJs = require("./findIndex.js");
var _findIndexJsDefault = parcelHelpers.interopDefault(_findIndexJs);
var _findKeyJs = require("./findKey.js");
var _findKeyJsDefault = parcelHelpers.interopDefault(_findKeyJs);
function find(obj, predicate, context) {
    var keyFinder = (0, _isArrayLikeJsDefault.default)(obj) ? (0, _findIndexJsDefault.default) : (0, _findKeyJsDefault.default);
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
}

},{"./_isArrayLike.js":"7w1Hu","./findIndex.js":"cs9dN","./findKey.js":"eLj2O","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jhudI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>findWhere);
var _findJs = require("./find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _matcherJs = require("./matcher.js");
var _matcherJsDefault = parcelHelpers.interopDefault(_matcherJs);
function findWhere(obj, attrs) {
    return (0, _findJsDefault.default)(obj, (0, _matcherJsDefault.default)(attrs));
}

},{"./find.js":"lLtqo","./matcher.js":"3wGZ7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fHmAz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>each);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function each(obj, iteratee, context) {
    iteratee = (0, _optimizeCbJsDefault.default)(iteratee, context);
    var i, length;
    if ((0, _isArrayLikeJsDefault.default)(obj)) for(i = 0, length = obj.length; i < length; i++)iteratee(obj[i], i, obj);
    else {
        var _keys = (0, _keysJsDefault.default)(obj);
        for(i = 0, length = _keys.length; i < length; i++)iteratee(obj[_keys[i]], _keys[i], obj);
    }
    return obj;
}

},{"./_optimizeCb.js":"ib91j","./_isArrayLike.js":"7w1Hu","./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1MqH5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>map);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function map(obj, iteratee, context) {
    iteratee = (0, _cbJsDefault.default)(iteratee, context);
    var _keys = !(0, _isArrayLikeJsDefault.default)(obj) && (0, _keysJsDefault.default)(obj), length = (_keys || obj).length, results = Array(length);
    for(var index = 0; index < length; index++){
        var currentKey = _keys ? _keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
}

},{"./_cb.js":"hwRTD","./_isArrayLike.js":"7w1Hu","./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bIw1c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createReduceJs = require("./_createReduce.js");
var _createReduceJsDefault = parcelHelpers.interopDefault(_createReduceJs);
// **Reduce** builds up a single result from a list of values, aka `inject`,
// or `foldl`.
exports.default = (0, _createReduceJsDefault.default)(1);

},{"./_createReduce.js":"8GuPA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8GuPA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createReduce);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
function createReduce(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
        var _keys = !(0, _isArrayLikeJsDefault.default)(obj) && (0, _keysJsDefault.default)(obj), length = (_keys || obj).length, index = dir > 0 ? 0 : length - 1;
        if (!initial) {
            memo = obj[_keys ? _keys[index] : index];
            index += dir;
        }
        for(; index >= 0 && index < length; index += dir){
            var currentKey = _keys ? _keys[index] : index;
            memo = iteratee(memo, obj[currentKey], currentKey, obj);
        }
        return memo;
    };
    return function(obj, iteratee, memo, context) {
        var initial = arguments.length >= 3;
        return reducer(obj, (0, _optimizeCbJsDefault.default)(iteratee, context, 4), memo, initial);
    };
}

},{"./_isArrayLike.js":"7w1Hu","./keys.js":"epVJ3","./_optimizeCb.js":"ib91j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2prZg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createReduceJs = require("./_createReduce.js");
var _createReduceJsDefault = parcelHelpers.interopDefault(_createReduceJs);
// The right-associative version of reduce, also known as `foldr`.
exports.default = (0, _createReduceJsDefault.default)(-1);

},{"./_createReduce.js":"8GuPA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5cyip":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>filter);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
function filter(obj, predicate, context) {
    var results = [];
    predicate = (0, _cbJsDefault.default)(predicate, context);
    (0, _eachJsDefault.default)(obj, function(value, index, list) {
        if (predicate(value, index, list)) results.push(value);
    });
    return results;
}

},{"./_cb.js":"hwRTD","./each.js":"fHmAz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2AJcx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>reject);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _negateJs = require("./negate.js");
var _negateJsDefault = parcelHelpers.interopDefault(_negateJs);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
function reject(obj, predicate, context) {
    return (0, _filterJsDefault.default)(obj, (0, _negateJsDefault.default)((0, _cbJsDefault.default)(predicate)), context);
}

},{"./filter.js":"5cyip","./negate.js":"juYC5","./_cb.js":"hwRTD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7IzXu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>every);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function every(obj, predicate, context) {
    predicate = (0, _cbJsDefault.default)(predicate, context);
    var _keys = !(0, _isArrayLikeJsDefault.default)(obj) && (0, _keysJsDefault.default)(obj), length = (_keys || obj).length;
    for(var index = 0; index < length; index++){
        var currentKey = _keys ? _keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
}

},{"./_cb.js":"hwRTD","./_isArrayLike.js":"7w1Hu","./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dxzPe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>some);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function some(obj, predicate, context) {
    predicate = (0, _cbJsDefault.default)(predicate, context);
    var _keys = !(0, _isArrayLikeJsDefault.default)(obj) && (0, _keysJsDefault.default)(obj), length = (_keys || obj).length;
    for(var index = 0; index < length; index++){
        var currentKey = _keys ? _keys[index] : index;
        if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
}

},{"./_cb.js":"hwRTD","./_isArrayLike.js":"7w1Hu","./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7u1gl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>contains);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _indexOfJs = require("./indexOf.js");
var _indexOfJsDefault = parcelHelpers.interopDefault(_indexOfJs);
function contains(obj, item, fromIndex, guard) {
    if (!(0, _isArrayLikeJsDefault.default)(obj)) obj = (0, _valuesJsDefault.default)(obj);
    if (typeof fromIndex != "number" || guard) fromIndex = 0;
    return (0, _indexOfJsDefault.default)(obj, item, fromIndex) >= 0;
}

},{"./_isArrayLike.js":"7w1Hu","./values.js":"1I2Yc","./indexOf.js":"3FyCZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aHKqv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _deepGetJs = require("./_deepGet.js");
var _deepGetJsDefault = parcelHelpers.interopDefault(_deepGetJs);
var _toPathJs = require("./_toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
// Invoke a method (with arguments) on every item in a collection.
exports.default = (0, _restArgumentsJsDefault.default)(function(obj, path, args) {
    var contextPath, func;
    if ((0, _isFunctionJsDefault.default)(path)) func = path;
    else {
        path = (0, _toPathJsDefault.default)(path);
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
    }
    return (0, _mapJsDefault.default)(obj, function(context) {
        var method = func;
        if (!method) {
            if (contextPath && contextPath.length) context = (0, _deepGetJsDefault.default)(context, contextPath);
            if (context == null) return void 0;
            method = context[path];
        }
        return method == null ? method : method.apply(context, args);
    });
});

},{"./restArguments.js":"iHiW5","./isFunction.js":"9XYGL","./map.js":"1MqH5","./_deepGet.js":"4yNnp","./_toPath.js":"fQeyr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"OekpZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>pluck);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _propertyJs = require("./property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
function pluck(obj, key) {
    return (0, _mapJsDefault.default)(obj, (0, _propertyJsDefault.default)(key));
}

},{"./map.js":"1MqH5","./property.js":"96pvf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1GXcS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>where);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _matcherJs = require("./matcher.js");
var _matcherJsDefault = parcelHelpers.interopDefault(_matcherJs);
function where(obj, attrs) {
    return (0, _filterJsDefault.default)(obj, (0, _matcherJsDefault.default)(attrs));
}

},{"./filter.js":"5cyip","./matcher.js":"3wGZ7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6g3ZY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>max);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
function max(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity, value, computed;
    if (iteratee == null || typeof iteratee == "number" && typeof obj[0] != "object" && obj != null) {
        obj = (0, _isArrayLikeJsDefault.default)(obj) ? obj : (0, _valuesJsDefault.default)(obj);
        for(var i = 0, length = obj.length; i < length; i++){
            value = obj[i];
            if (value != null && value > result) result = value;
        }
    } else {
        iteratee = (0, _cbJsDefault.default)(iteratee, context);
        (0, _eachJsDefault.default)(obj, function(v, index, list) {
            computed = iteratee(v, index, list);
            if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
                result = v;
                lastComputed = computed;
            }
        });
    }
    return result;
}

},{"./_isArrayLike.js":"7w1Hu","./values.js":"1I2Yc","./_cb.js":"hwRTD","./each.js":"fHmAz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9EXwL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>min);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
function min(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity, value, computed;
    if (iteratee == null || typeof iteratee == "number" && typeof obj[0] != "object" && obj != null) {
        obj = (0, _isArrayLikeJsDefault.default)(obj) ? obj : (0, _valuesJsDefault.default)(obj);
        for(var i = 0, length = obj.length; i < length; i++){
            value = obj[i];
            if (value != null && value < result) result = value;
        }
    } else {
        iteratee = (0, _cbJsDefault.default)(iteratee, context);
        (0, _eachJsDefault.default)(obj, function(v, index, list) {
            computed = iteratee(v, index, list);
            if (computed < lastComputed || computed === Infinity && result === Infinity) {
                result = v;
                lastComputed = computed;
            }
        });
    }
    return result;
}

},{"./_isArrayLike.js":"7w1Hu","./values.js":"1I2Yc","./_cb.js":"hwRTD","./each.js":"fHmAz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kl8WA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>shuffle);
var _sampleJs = require("./sample.js");
var _sampleJsDefault = parcelHelpers.interopDefault(_sampleJs);
function shuffle(obj) {
    return (0, _sampleJsDefault.default)(obj, Infinity);
}

},{"./sample.js":"8fNnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8fNnf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>sample);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _randomJs = require("./random.js");
var _randomJsDefault = parcelHelpers.interopDefault(_randomJs);
var _toArrayJs = require("./toArray.js");
var _toArrayJsDefault = parcelHelpers.interopDefault(_toArrayJs);
function sample(obj, n, guard) {
    if (n == null || guard) {
        if (!(0, _isArrayLikeJsDefault.default)(obj)) obj = (0, _valuesJsDefault.default)(obj);
        return obj[(0, _randomJsDefault.default)(obj.length - 1)];
    }
    var sample = (0, _toArrayJsDefault.default)(obj);
    var length = (0, _getLengthJsDefault.default)(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for(var index = 0; index < n; index++){
        var rand = (0, _randomJsDefault.default)(index, last);
        var temp = sample[index];
        sample[index] = sample[rand];
        sample[rand] = temp;
    }
    return sample.slice(0, n);
}

},{"./_isArrayLike.js":"7w1Hu","./values.js":"1I2Yc","./_getLength.js":"cb0Fe","./random.js":"imiVs","./toArray.js":"7e7T1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7e7T1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>toArray);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _setupJs = require("./_setup.js");
var _isStringJs = require("./isString.js");
var _isStringJsDefault = parcelHelpers.interopDefault(_isStringJs);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
// Safely create a real, live array from anything iterable.
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
    if (!obj) return [];
    if ((0, _isArrayJsDefault.default)(obj)) return (0, _setupJs.slice).call(obj);
    if ((0, _isStringJsDefault.default)(obj)) // Keep surrogate pair characters together.
    return obj.match(reStrSymbol);
    if ((0, _isArrayLikeJsDefault.default)(obj)) return (0, _mapJsDefault.default)(obj, (0, _identityJsDefault.default));
    return (0, _valuesJsDefault.default)(obj);
}

},{"./isArray.js":"cth5N","./_setup.js":"j1Opz","./isString.js":"h9vOY","./_isArrayLike.js":"7w1Hu","./map.js":"1MqH5","./identity.js":"iCRMn","./values.js":"1I2Yc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eCcLt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>sortBy);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _pluckJs = require("./pluck.js");
var _pluckJsDefault = parcelHelpers.interopDefault(_pluckJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
function sortBy(obj, iteratee, context) {
    var index = 0;
    iteratee = (0, _cbJsDefault.default)(iteratee, context);
    return (0, _pluckJsDefault.default)((0, _mapJsDefault.default)(obj, function(value, key, list) {
        return {
            value: value,
            index: index++,
            criteria: iteratee(value, key, list)
        };
    }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
            if (a > b || a === void 0) return 1;
            if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
    }), "value");
}

},{"./_cb.js":"hwRTD","./pluck.js":"OekpZ","./map.js":"1MqH5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k2aiT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _groupJs = require("./_group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
// Groups the object's values by a criterion. Pass either a string attribute
// to group by, or a function that returns the criterion.
exports.default = (0, _groupJsDefault.default)(function(result, value, key) {
    if ((0, _hasJsDefault.default)(result, key)) result[key].push(value);
    else result[key] = [
        value
    ];
});

},{"./_group.js":"ltdJN","./_has.js":"500LZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ltdJN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>group);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
function group(behavior, partition) {
    return function(obj, iteratee, context) {
        var result = partition ? [
            [],
            []
        ] : {};
        iteratee = (0, _cbJsDefault.default)(iteratee, context);
        (0, _eachJsDefault.default)(obj, function(value, index) {
            var key = iteratee(value, index, obj);
            behavior(result, value, key);
        });
        return result;
    };
}

},{"./_cb.js":"hwRTD","./each.js":"fHmAz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9VQiT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _groupJs = require("./_group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
// Indexes the object's values by a criterion, similar to `_.groupBy`, but for
// when you know that your index values will be unique.
exports.default = (0, _groupJsDefault.default)(function(result, value, key) {
    result[key] = value;
});

},{"./_group.js":"ltdJN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kNxCr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _groupJs = require("./_group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
var _hasJs = require("./_has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
// Counts instances of an object that group by a certain criterion. Pass
// either a string attribute to count by, or a function that returns the
// criterion.
exports.default = (0, _groupJsDefault.default)(function(result, value, key) {
    if ((0, _hasJsDefault.default)(result, key)) result[key]++;
    else result[key] = 1;
});

},{"./_group.js":"ltdJN","./_has.js":"500LZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bH0TP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _groupJs = require("./_group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
// Split a collection into two arrays: one whose elements all pass the given
// truth test, and one whose elements all do not pass the truth test.
exports.default = (0, _groupJsDefault.default)(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
}, true);

},{"./_group.js":"ltdJN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"88Tqj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>size);
var _isArrayLikeJs = require("./_isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
function size(obj) {
    if (obj == null) return 0;
    return (0, _isArrayLikeJsDefault.default)(obj) ? obj.length : (0, _keysJsDefault.default)(obj).length;
}

},{"./_isArrayLike.js":"7w1Hu","./keys.js":"epVJ3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8ScJB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _optimizeCbJs = require("./_optimizeCb.js");
var _optimizeCbJsDefault = parcelHelpers.interopDefault(_optimizeCbJs);
var _allKeysJs = require("./allKeys.js");
var _allKeysJsDefault = parcelHelpers.interopDefault(_allKeysJs);
var _keyInObjJs = require("./_keyInObj.js");
var _keyInObjJsDefault = parcelHelpers.interopDefault(_keyInObjJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
// Return a copy of the object only containing the allowed properties.
exports.default = (0, _restArgumentsJsDefault.default)(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if ((0, _isFunctionJsDefault.default)(iteratee)) {
        if (keys.length > 1) iteratee = (0, _optimizeCbJsDefault.default)(iteratee, keys[1]);
        keys = (0, _allKeysJsDefault.default)(obj);
    } else {
        iteratee = (0, _keyInObjJsDefault.default);
        keys = (0, _flattenJsDefault.default)(keys, false, false);
        obj = Object(obj);
    }
    for(var i = 0, length = keys.length; i < length; i++){
        var key = keys[i];
        var value = obj[key];
        if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
});

},{"./restArguments.js":"iHiW5","./isFunction.js":"9XYGL","./_optimizeCb.js":"ib91j","./allKeys.js":"iL9rU","./_keyInObj.js":"cvpDy","./_flatten.js":"kRaRq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cvpDy":[function(require,module,exports) {
// Internal `_.pick` helper function to determine whether `key` is an enumerable
// property name of `obj`.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>keyInObj);
function keyInObj(value, key, obj) {
    return key in obj;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6aykp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _negateJs = require("./negate.js");
var _negateJsDefault = parcelHelpers.interopDefault(_negateJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _pickJs = require("./pick.js");
var _pickJsDefault = parcelHelpers.interopDefault(_pickJs);
// Return a copy of the object without the disallowed properties.
exports.default = (0, _restArgumentsJsDefault.default)(function(obj, keys) {
    var iteratee = keys[0], context;
    if ((0, _isFunctionJsDefault.default)(iteratee)) {
        iteratee = (0, _negateJsDefault.default)(iteratee);
        if (keys.length > 1) context = keys[1];
    } else {
        keys = (0, _mapJsDefault.default)((0, _flattenJsDefault.default)(keys, false, false), String);
        iteratee = function(value, key) {
            return !(0, _containsJsDefault.default)(keys, key);
        };
    }
    return (0, _pickJsDefault.default)(obj, iteratee, context);
});

},{"./restArguments.js":"iHiW5","./isFunction.js":"9XYGL","./negate.js":"juYC5","./map.js":"1MqH5","./_flatten.js":"kRaRq","./contains.js":"7u1gl","./pick.js":"8ScJB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bNqM1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>first);
var _initialJs = require("./initial.js");
var _initialJsDefault = parcelHelpers.interopDefault(_initialJs);
function first(array, n, guard) {
    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    if (n == null || guard) return array[0];
    return (0, _initialJsDefault.default)(array, array.length - n);
}

},{"./initial.js":"cD91j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cD91j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>initial);
var _setupJs = require("./_setup.js");
function initial(array, n, guard) {
    return (0, _setupJs.slice).call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}

},{"./_setup.js":"j1Opz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"38Fqg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>last);
var _restJs = require("./rest.js");
var _restJsDefault = parcelHelpers.interopDefault(_restJs);
function last(array, n, guard) {
    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return (0, _restJsDefault.default)(array, Math.max(0, array.length - n));
}

},{"./rest.js":"aLSkH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aLSkH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>rest);
var _setupJs = require("./_setup.js");
function rest(array, n, guard) {
    return (0, _setupJs.slice).call(array, n == null || guard ? 1 : n);
}

},{"./_setup.js":"j1Opz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3coBb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>compact);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
function compact(array) {
    return (0, _filterJsDefault.default)(array, Boolean);
}

},{"./filter.js":"5cyip","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gpF6L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>flatten);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
function flatten(array, depth) {
    return (0, _flattenJsDefault.default)(array, depth, false);
}

},{"./_flatten.js":"kRaRq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ouhVw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _differenceJs = require("./difference.js");
var _differenceJsDefault = parcelHelpers.interopDefault(_differenceJs);
// Return a version of the array that does not contain the specified value(s).
exports.default = (0, _restArgumentsJsDefault.default)(function(array, otherArrays) {
    return (0, _differenceJsDefault.default)(array, otherArrays);
});

},{"./restArguments.js":"iHiW5","./difference.js":"e9ASn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e9ASn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
// Take the difference between one array and a number of other arrays.
// Only the elements present in just the first array will remain.
exports.default = (0, _restArgumentsJsDefault.default)(function(array, rest) {
    rest = (0, _flattenJsDefault.default)(rest, true, true);
    return (0, _filterJsDefault.default)(array, function(value) {
        return !(0, _containsJsDefault.default)(rest, value);
    });
});

},{"./restArguments.js":"iHiW5","./_flatten.js":"kRaRq","./filter.js":"5cyip","./contains.js":"7u1gl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kiHGM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>uniq);
var _isBooleanJs = require("./isBoolean.js");
var _isBooleanJsDefault = parcelHelpers.interopDefault(_isBooleanJs);
var _cbJs = require("./_cb.js");
var _cbJsDefault = parcelHelpers.interopDefault(_cbJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
function uniq(array, isSorted, iteratee, context) {
    if (!(0, _isBooleanJsDefault.default)(isSorted)) {
        context = iteratee;
        iteratee = isSorted;
        isSorted = false;
    }
    if (iteratee != null) iteratee = (0, _cbJsDefault.default)(iteratee, context);
    var result = [];
    var seen = [];
    for(var i = 0, length = (0, _getLengthJsDefault.default)(array); i < length; i++){
        var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
        if (isSorted && !iteratee) {
            if (!i || seen !== computed) result.push(value);
            seen = computed;
        } else if (iteratee) {
            if (!(0, _containsJsDefault.default)(seen, computed)) {
                seen.push(computed);
                result.push(value);
            }
        } else if (!(0, _containsJsDefault.default)(result, value)) result.push(value);
    }
    return result;
}

},{"./isBoolean.js":"e6GFe","./_cb.js":"hwRTD","./_getLength.js":"cb0Fe","./contains.js":"7u1gl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k8pGG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _uniqJs = require("./uniq.js");
var _uniqJsDefault = parcelHelpers.interopDefault(_uniqJs);
var _flattenJs = require("./_flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
// Produce an array that contains the union: each distinct element from all of
// the passed-in arrays.
exports.default = (0, _restArgumentsJsDefault.default)(function(arrays) {
    return (0, _uniqJsDefault.default)((0, _flattenJsDefault.default)(arrays, true, true));
});

},{"./restArguments.js":"iHiW5","./uniq.js":"kiHGM","./_flatten.js":"kRaRq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iHUB6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>intersection);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
function intersection(array) {
    var result = [];
    var argsLength = arguments.length;
    for(var i = 0, length = (0, _getLengthJsDefault.default)(array); i < length; i++){
        var item = array[i];
        if ((0, _containsJsDefault.default)(result, item)) continue;
        var j;
        for(j = 1; j < argsLength; j++){
            if (!(0, _containsJsDefault.default)(arguments[j], item)) break;
        }
        if (j === argsLength) result.push(item);
    }
    return result;
}

},{"./_getLength.js":"cb0Fe","./contains.js":"7u1gl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hyGGg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>unzip);
var _maxJs = require("./max.js");
var _maxJsDefault = parcelHelpers.interopDefault(_maxJs);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
var _pluckJs = require("./pluck.js");
var _pluckJsDefault = parcelHelpers.interopDefault(_pluckJs);
function unzip(array) {
    var length = array && (0, _maxJsDefault.default)(array, (0, _getLengthJsDefault.default)).length || 0;
    var result = Array(length);
    for(var index = 0; index < length; index++)result[index] = (0, _pluckJsDefault.default)(array, index);
    return result;
}

},{"./max.js":"6g3ZY","./_getLength.js":"cb0Fe","./pluck.js":"OekpZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lJw0p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _restArgumentsJs = require("./restArguments.js");
var _restArgumentsJsDefault = parcelHelpers.interopDefault(_restArgumentsJs);
var _unzipJs = require("./unzip.js");
var _unzipJsDefault = parcelHelpers.interopDefault(_unzipJs);
// Zip together multiple lists into a single array -- elements that share
// an index go together.
exports.default = (0, _restArgumentsJsDefault.default)((0, _unzipJsDefault.default));

},{"./restArguments.js":"iHiW5","./unzip.js":"hyGGg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bvlJI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>object);
var _getLengthJs = require("./_getLength.js");
var _getLengthJsDefault = parcelHelpers.interopDefault(_getLengthJs);
function object(list, values) {
    var result = {};
    for(var i = 0, length = (0, _getLengthJsDefault.default)(list); i < length; i++)if (values) result[list[i]] = values[i];
    else result[list[i][0]] = list[i][1];
    return result;
}

},{"./_getLength.js":"cb0Fe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"43G11":[function(require,module,exports) {
// Generate an integer Array containing an arithmetic progression. A port of
// the native Python `range()` function. See
// [the Python documentation](https://docs.python.org/library/functions.html#range).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>range);
function range(start, stop, step) {
    if (stop == null) {
        stop = start || 0;
        start = 0;
    }
    if (!step) step = stop < start ? -1 : 1;
    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);
    for(var idx = 0; idx < length; idx++, start += step)range[idx] = start;
    return range;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"57Gcn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>chunk);
var _setupJs = require("./_setup.js");
function chunk(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while(i < length)result.push((0, _setupJs.slice).call(array, i, i += count));
    return result;
}

},{"./_setup.js":"j1Opz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"enXfg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>mixin);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
var _functionsJs = require("./functions.js");
var _functionsJsDefault = parcelHelpers.interopDefault(_functionsJs);
var _setupJs = require("./_setup.js");
var _chainResultJs = require("./_chainResult.js");
var _chainResultJsDefault = parcelHelpers.interopDefault(_chainResultJs);
function mixin(obj) {
    (0, _eachJsDefault.default)((0, _functionsJsDefault.default)(obj), function(name) {
        var func = (0, _underscoreJsDefault.default)[name] = obj[name];
        (0, _underscoreJsDefault.default).prototype[name] = function() {
            var args = [
                this._wrapped
            ];
            (0, _setupJs.push).apply(args, arguments);
            return (0, _chainResultJsDefault.default)(this, func.apply((0, _underscoreJsDefault.default), args));
        };
    });
    return 0, _underscoreJsDefault.default;
}

},{"./underscore.js":"cZn3h","./each.js":"fHmAz","./functions.js":"6kKwG","./_setup.js":"j1Opz","./_chainResult.js":"2gkrX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2gkrX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>chainResult);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
function chainResult(instance, obj) {
    return instance._chain ? (0, _underscoreJsDefault.default)(obj).chain() : obj;
}

},{"./underscore.js":"cZn3h","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k1JcM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _underscoreJs = require("./underscore.js");
var _underscoreJsDefault = parcelHelpers.interopDefault(_underscoreJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
var _setupJs = require("./_setup.js");
var _chainResultJs = require("./_chainResult.js");
var _chainResultJsDefault = parcelHelpers.interopDefault(_chainResultJs);
// Add all mutator `Array` functions to the wrapper.
(0, _eachJsDefault.default)([
    "pop",
    "push",
    "reverse",
    "shift",
    "sort",
    "splice",
    "unshift"
], function(name) {
    var method = (0, _setupJs.ArrayProto)[name];
    (0, _underscoreJsDefault.default).prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) {
            method.apply(obj, arguments);
            if ((name === "shift" || name === "splice") && obj.length === 0) delete obj[0];
        }
        return (0, _chainResultJsDefault.default)(this, obj);
    };
});
// Add all accessor `Array` functions to the wrapper.
(0, _eachJsDefault.default)([
    "concat",
    "join",
    "slice"
], function(name) {
    var method = (0, _setupJs.ArrayProto)[name];
    (0, _underscoreJsDefault.default).prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) obj = method.apply(obj, arguments);
        return (0, _chainResultJsDefault.default)(this, obj);
    };
});
exports.default = (0, _underscoreJsDefault.default);

},{"./underscore.js":"cZn3h","./each.js":"fHmAz","./_setup.js":"j1Opz","./_chainResult.js":"2gkrX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7jr44":[function(require,module,exports) {
/*!
 * jQuery JavaScript Library v3.6.4
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-03-08T15:28Z
 */ (function(global, factory) {
    "use strict";
    if (typeof module.exports === "object") // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket trac-14549 for more info.
    module.exports = global.document ? factory(global, true) : function(w) {
        if (!w.document) throw new Error("jQuery requires a window with a document");
        return factory(w);
    };
    else factory(global);
// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function(window1, noGlobal) {
    // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
    // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
    // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
    // enough that all such attempts are guarded in a try block.
    "use strict";
    var arr = [];
    var getProto = Object.getPrototypeOf;
    var slice = arr.slice;
    var flat = arr.flat ? function(array) {
        return arr.flat.call(array);
    } : function(array) {
        return arr.concat.apply([], array);
    };
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    var isFunction = function isFunction(obj) {
        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
        // Plus for old WebKit, typeof returns "function" for HTML collections
        // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
        return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
    };
    var isWindow = function isWindow(obj) {
        return obj != null && obj === obj.window;
    };
    var document = window1.document;
    var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
    };
    function DOMEval(code, node, doc) {
        doc = doc || document;
        var i, val, script = doc.createElement("script");
        script.text = code;
        if (node) for(i in preservedScriptAttributes){
            // Support: Firefox 64+, Edge 18+
            // Some browsers don't support the "nonce" property on scripts.
            // On the other hand, just using `getAttribute` is not enough as
            // the `nonce` attribute is reset to an empty string whenever it
            // becomes browsing-context connected.
            // See https://github.com/whatwg/html/issues/2369
            // See https://html.spec.whatwg.org/#nonce-attributes
            // The `node.getAttribute` check was added for the sake of
            // `jQuery.globalEval` so that it can fake a nonce-containing node
            // via an object.
            val = node[i] || node.getAttribute && node.getAttribute(i);
            if (val) script.setAttribute(i, val);
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
    }
    function toType(obj) {
        if (obj == null) return obj + "";
        // Support: Android <=2.3 only (functionish RegExp)
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    }
    /* global Symbol */ // Defining this global in .eslintrc.json would create a danger of using the global
    // unguarded in another place, it seems safer to define global only for this module
    var version = "3.6.4", // Define a local copy of jQuery
    jQuery = function(selector, context) {
        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init(selector, context);
    };
    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,
        constructor: jQuery,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
            // Return all the elements in a clean array
            if (num == null) return slice.call(this);
            // Return just the one element from the set
            return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);
            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            // Return the newly-formed element set
            return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function(callback) {
            return jQuery.each(this, callback);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        even: function() {
            return this.pushStack(jQuery.grep(this, function(_elem, i) {
                return (i + 1) % 2;
            }));
        },
        odd: function() {
            return this.pushStack(jQuery.grep(this, function(_elem, i) {
                return i % 2;
            }));
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [
                this[j]
            ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;
            // Skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }
        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !isFunction(target)) target = {};
        // Extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }
        for(; i < length; i++){
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) // Extend the base object
            for(name in options){
                copy = options[name];
                // Prevent Object.prototype pollution
                // Prevent never-ending loop
                if (name === "__proto__" || target === copy) continue;
                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                    src = target[name];
                    // Ensure proper type for the source value
                    if (copyIsArray && !Array.isArray(src)) clone = [];
                    else if (!copyIsArray && !jQuery.isPlainObject(src)) clone = {};
                    else clone = src;
                    copyIsArray = false;
                    // Never move original objects, clone them
                    target[name] = jQuery.extend(deep, clone, copy);
                // Don't bring in undefined values
                } else if (copy !== undefined) target[name] = copy;
            }
        }
        // Return the modified object
        return target;
    };
    jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isPlainObject: function(obj) {
            var proto, Ctor;
            // Detect obvious negatives
            // Use toString instead of jQuery.type to catch host objects
            if (!obj || toString.call(obj) !== "[object Object]") return false;
            proto = getProto(obj);
            // Objects with no prototype (e.g., `Object.create( null )`) are plain
            if (!proto) return true;
            // Objects with prototype are plain iff they were constructed by a global Object function
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
            var name;
            for(name in obj)return false;
            return true;
        },
        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function(code, options, doc) {
            DOMEval(code, {
                nonce: options && options.nonce
            }, doc);
        },
        each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for(; i < length; i++){
                    if (callback.call(obj[i], i, obj[i]) === false) break;
                }
            } else for(i in obj){
                if (callback.call(obj[i], i, obj[i]) === false) break;
            }
            return obj;
        },
        // results is for internal usage only
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) jQuery.merge(ret, typeof arr === "string" ? [
                    arr
                ] : arr);
                else push.call(ret, arr);
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for(; j < len; j++)first[i++] = second[j];
            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            // Go through the array, only saving the items
            // that pass the validator function
            for(; i < length; i++){
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) matches.push(elems[i]);
            }
            return matches;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            // Go through the array, translating each of the items to their new values
            if (isArrayLike(elems)) {
                length = elems.length;
                for(; i < length; i++){
                    value = callback(elems[i], i, arg);
                    if (value != null) ret.push(value);
                }
            // Go through every key on the object,
            } else for(i in elems){
                value = callback(elems[i], i, arg);
                if (value != null) ret.push(value);
            }
            // Flatten any nested arrays
            return flat(ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });
    if (typeof Symbol === "function") jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(_i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArrayLike(obj) {
        // Support: real iOS 8.2 only (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length, type = toType(obj);
        if (isFunction(obj) || isWindow(obj)) return false;
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = /*!
 * Sizzle CSS Selector Engine v2.3.10
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2023-02-14
 */ function(window1) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, // Local document vars
        setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, // Instance-specific data
        expando = "sizzle" + 1 * new Date(), preferredDoc = window1.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
            if (a === b) hasDuplicate = true;
            return 0;
        }, // Instance methods
        hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, pushNative = arr.push, push = arr.push, slice = arr.slice, // Use a stripped-down indexOf as it's faster than native
        // https://jsperf.com/thor-indexof-vs-for/5
        indexOf = function(list, elem) {
            var i = 0, len = list.length;
            for(; i < len; i++){
                if (list[i] === elem) return i;
            }
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", // Regular expressions
        // http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]", // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
        identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\x00-\\x7f])+", // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
        // or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
        ".*" + ")\\)|)", // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            "ID": new RegExp("^#(" + identifier + ")"),
            "CLASS": new RegExp("^\\.(" + identifier + ")"),
            "TAG": new RegExp("^(" + identifier + "|[*])"),
            "ATTR": new RegExp("^" + attributes),
            "PSEUDO": new RegExp("^" + pseudos),
            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rhtml = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, // CSS escapes
        // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
            var high = "0x" + escape.slice(1) - 0x10000;
            return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
            nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
            // Support: IE <=11+
            // For values outside the Basic Multilingual Plane (BMP), manually construct a
            // surrogate pair
            high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        }, // CSS string/identifier serialization
        // https://drafts.csswg.org/cssom/#common-serializing-idioms
        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
            if (asCodePoint) {
                // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                if (ch === "\x00") return "ÔøΩ";
                // Control characters and (dependent upon position) numbers get escaped as code points
                return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
            }
            // Other potentially-special ASCII characters get backslash-escaped
            return "\\" + ch;
        }, // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function() {
            setDocument();
        }, inDisabledFieldset = addCombinator(function(elem) {
            return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
        }, {
            dir: "parentNode",
            next: "legend"
        });
        // Optimize for push.apply( _, NodeList )
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            // Support: Android<4.0
            // Detect silently failing push.apply
            // eslint-disable-next-line no-unused-expressions
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? // Leverage slice if possible
                function(target, els) {
                    pushNative.apply(target, slice.call(els));
                } : // Support: IE<9
                // Otherwise append directly
                function(target, els) {
                    var j = target.length, i = 0;
                    // Can't trust NodeList.length
                    while(target[j++] = els[i++]);
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, // nodeType defaults to 9, since context defaults to document
            nodeType = context ? context.nodeType : 9;
            results = results || [];
            // Return early from calls with invalid selector or context
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) return results;
            // Try to shortcut find operations (as opposed to filters) in HTML documents
            if (!seed) {
                setDocument(context);
                context = context || document;
                if (documentIsHTML) {
                    // If the selector is sufficiently simple, try using a "get*By*" DOM method
                    // (excepting DocumentFragment context, where the methods don't exist)
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                        // ID selector
                        if (m = match[1]) {
                            // Document context
                            if (nodeType === 9) {
                                if (elem = context.getElementById(m)) // Support: IE, Opera, Webkit
                                // TODO: identify versions
                                // getElementById can match elements by name instead of ID
                                {
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else return results;
                            // Element context
                            } else // Support: IE, Opera, Webkit
                            // TODO: identify versions
                            // getElementById can match elements by name instead of ID
                            if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        // Type selector
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;
                        // Class selector
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }
                    // Take advantage of querySelectorAll
                    if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && // Support: IE 8 only
                    // Exclude object elements
                    (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
                        newSelector = selector;
                        newContext = context;
                        // qSA considers elements outside a scoping root when evaluating child or
                        // descendant combinators, which is not what we want.
                        // In such cases, we work around the behavior by prefixing every selector in the
                        // list with an ID selector referencing the scope context.
                        // The technique has to be used as well when a leading combinator is used
                        // as such selectors are not recognized by querySelectorAll.
                        // Thanks to Andrew Dupont for this technique.
                        if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                            // Expand context for sibling selectors
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                            // We can use :scope instead of the ID hack if the browser
                            // supports it & if we're not changing the context.
                            if (newContext !== context || !support.scope) {
                                // Capture the context ID, setting it first if necessary
                                if (nid = context.getAttribute("id")) nid = nid.replace(rcssescape, fcssescape);
                                else context.setAttribute("id", nid = expando);
                            }
                            // Prefix every selector in the list
                            groups = tokenize(selector);
                            i = groups.length;
                            while(i--)groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
                            newSelector = groups.join(",");
                        }
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {
                            nonnativeSelectorCache(selector, true);
                        } finally{
                            if (nid === expando) context.removeAttribute("id");
                        }
                    }
                }
            }
            // All others
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        /**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */ function createCache() {
            var keys = [];
            function cache(key, value) {
                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                if (keys.push(key + " ") > Expr.cacheLength) // Only keep the most recent entries
                delete cache[keys.shift()];
                return cache[key + " "] = value;
            }
            return cache;
        }
        /**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */ function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        /**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */ function assert(fn) {
            var el = document.createElement("fieldset");
            try {
                return !!fn(el);
            } catch (e) {
                return false;
            } finally{
                // Remove from its parent by default
                if (el.parentNode) el.parentNode.removeChild(el);
                // release memory in IE
                el = null;
            }
        }
        /**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */ function addHandle(attrs, handler) {
            var arr = attrs.split("|"), i = arr.length;
            while(i--)Expr.attrHandle[arr[i]] = handler;
        }
        /**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */ function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
            // Use IE sourceIndex if available on both nodes
            if (diff) return diff;
            // Check if b follows a
            if (cur) while(cur = cur.nextSibling){
                if (cur === b) return -1;
            }
            return a ? 1 : -1;
        }
        /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */ function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */ function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */ function createDisabledPseudo(disabled) {
            // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
            return function(elem) {
                // Only certain elements can match :enabled or :disabled
                // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                if ("form" in elem) {
                    // Check for inherited disabledness on relevant non-disabled elements:
                    // * listed form-associated elements in a disabled fieldset
                    //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                    // * option elements in a disabled optgroup
                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                    // All such elements have a "form" property.
                    if (elem.parentNode && elem.disabled === false) {
                        // Option elements defer to a parent optgroup if present
                        if ("label" in elem) {
                            if ("label" in elem.parentNode) return elem.parentNode.disabled === disabled;
                            else return elem.disabled === disabled;
                        }
                        // Support: IE 6 - 11
                        // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                        return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                        /* jshint -W018 */ elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                    }
                    return elem.disabled === disabled;
                // Try to winnow out elements that can't be disabled before trusting the disabled property.
                // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                // even exist on them, let alone have a boolean value.
                } else if ("label" in elem) return elem.disabled === disabled;
                // Remaining elements are neither :enabled nor :disabled
                return false;
            };
        }
        /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */ function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    // Match elements found at the specified indexes
                    while(i--)if (seed[j = matchIndexes[i]]) seed[j] = !(matches[j] = seed[j]);
                });
            });
        }
        /**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */ function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        // Expose support vars for convenience
        support = Sizzle.support = {};
        /**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */ isXML = Sizzle.isXML = function(elem) {
            var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
            // Support: IE <=8
            // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
            // https://bugs.jquery.com/ticket/4833
            return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
        };
        /**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */ setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            // Return early if doc is invalid or already selected
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if (doc == document || doc.nodeType !== 9 || !doc.documentElement) return document;
            // Update global variables
            document = doc;
            docElem = document.documentElement;
            documentIsHTML = !isXML(document);
            // Support: IE 9 - 11+, Edge 12 - 18+
            // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
                // Support: IE 11, Edge
                if (subWindow.addEventListener) subWindow.addEventListener("unload", unloadHandler, false);
                else if (subWindow.attachEvent) subWindow.attachEvent("onunload", unloadHandler);
            }
            // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
            // Safari 4 - 5 only, Opera <=11.6 - 12.x only
            // IE/Edge & older browsers don't support the :scope pseudo-class.
            // Support: Safari 6.0 only
            // Safari 6.0 supports :scope but it's an alias of :root there.
            support.scope = assert(function(el) {
                docElem.appendChild(el).appendChild(document.createElement("div"));
                return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
            });
            // Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
            // Make sure the the `:has()` argument is parsed unforgivingly.
            // We include `*` in the test to detect buggy implementations that are
            // _selectively_ forgiving (specifically when the list includes at least
            // one valid selector).
            // Note that we treat complete lack of support for `:has()` as if it were
            // spec-compliant support, which is fine because use of `:has()` in such
            // environments will fail in the qSA path and fall back to jQuery traversal
            // anyway.
            support.cssHas = assert(function() {
                try {
                    document.querySelector(":has(*,:jqfake)");
                    return false;
                } catch (e) {
                    return true;
                }
            });
            /* Attributes
	---------------------------------------------------------------------- */ // Support: IE<8
            // Verify that getAttribute really returns attributes and not properties
            // (excepting IE8 booleans)
            support.attributes = assert(function(el) {
                el.className = "i";
                return !el.getAttribute("className");
            });
            /* getElement(s)By*
	---------------------------------------------------------------------- */ // Check if getElementsByTagName("*") returns only elements
            support.getElementsByTagName = assert(function(el) {
                el.appendChild(document.createComment(""));
                return !el.getElementsByTagName("*").length;
            });
            // Support: IE<9
            support.getElementsByClassName = rnative.test(document.getElementsByClassName);
            // Support: IE<10
            // Check if getElementById returns elements by name
            // The broken getElementById methods don't pick up programmatically-set names,
            // so use a roundabout getElementsByName test
            support.getById = assert(function(el) {
                docElem.appendChild(el).id = expando;
                return !document.getElementsByName || !document.getElementsByName(expando).length;
            });
            // ID filter and find
            if (support.getById) {
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var elem = context.getElementById(id);
                        return elem ? [
                            elem
                        ] : [];
                    }
                };
            } else {
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };
                // Support: IE 6 - 7 only
                // getElementById is not reliable as a find shortcut
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var node, i, elems, elem = context.getElementById(id);
                        if (elem) {
                            // Verify the id attribute
                            node = elem.getAttributeNode("id");
                            if (node && node.value === id) return [
                                elem
                            ];
                            // Fall back on getElementsByName
                            elems = context.getElementsByName(id);
                            i = 0;
                            while(elem = elems[i++]){
                                node = elem.getAttributeNode("id");
                                if (node && node.value === id) return [
                                    elem
                                ];
                            }
                        }
                        return [];
                    }
                };
            }
            // Tag
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") return context.getElementsByTagName(tag);
                else if (support.qsa) return context.querySelectorAll(tag);
            } : function(tag, context) {
                var elem, tmp = [], i = 0, // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                results = context.getElementsByTagName(tag);
                // Filter out possible comments
                if (tag === "*") {
                    while(elem = results[i++])if (elem.nodeType === 1) tmp.push(elem);
                    return tmp;
                }
                return results;
            };
            // Class
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) return context.getElementsByClassName(className);
            };
            /* QSA/matchesSelector
	---------------------------------------------------------------------- */ // QSA and matchesSelector support
            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
            rbuggyMatches = [];
            // qSa(:focus) reports false when true (Chrome 21)
            // We allow this because of a bug in IE8/9 that throws an error
            // whenever `document.activeElement` is accessed on an iframe
            // So, we allow :focus to pass through QSA all the time to avoid the IE error
            // See https://bugs.jquery.com/ticket/13378
            rbuggyQSA = [];
            if (support.qsa = rnative.test(document.querySelectorAll)) {
                // Build QSA regex
                // Regex strategy adopted from Diego Perini
                assert(function(el) {
                    var input;
                    // Select is set to empty string on purpose
                    // This is to test IE's treatment of not explicitly
                    // setting a boolean content attribute,
                    // since its presence should be enough
                    // https://bugs.jquery.com/ticket/12359
                    docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
                    // Support: IE8, Opera 11-12.16
                    // Nothing should be selected when empty strings follow ^= or $= or *=
                    // The test attribute must be unknown in Opera but "safe" for WinRT
                    // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                    if (el.querySelectorAll("[msallowcapture^='']").length) rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    // Support: IE8
                    // Boolean attributes and "value" are not treated correctly
                    if (!el.querySelectorAll("[selected]").length) rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                    if (!el.querySelectorAll("[id~=" + expando + "-]").length) rbuggyQSA.push("~=");
                    // Support: IE 11+, Edge 15 - 18+
                    // IE 11/Edge don't find elements on a `[name='']` query in some cases.
                    // Adding a temporary attribute to the document before the selection works
                    // around the issue.
                    // Interestingly, IE 10 & older don't seem to have the issue.
                    input = document.createElement("input");
                    input.setAttribute("name", "");
                    el.appendChild(input);
                    if (!el.querySelectorAll("[name='']").length) rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
                    // Webkit/Opera - :checked should return selected option elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    // IE8 throws error here and will not see later tests
                    if (!el.querySelectorAll(":checked").length) rbuggyQSA.push(":checked");
                    // Support: Safari 8+, iOS 8+
                    // https://bugs.webkit.org/show_bug.cgi?id=136851
                    // In-page `selector#id sibling-combinator selector` fails
                    if (!el.querySelectorAll("a#" + expando + "+*").length) rbuggyQSA.push(".#.+[+~]");
                    // Support: Firefox <=3.6 - 5 only
                    // Old Firefox doesn't throw on a badly-escaped identifier.
                    el.querySelectorAll("\\\f");
                    rbuggyQSA.push("[\\r\\n\\f]");
                });
                assert(function(el) {
                    el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                    // Support: Windows 8 Native Apps
                    // The type and name attributes are restricted during .innerHTML assignment
                    var input = document.createElement("input");
                    input.setAttribute("type", "hidden");
                    el.appendChild(input).setAttribute("name", "D");
                    // Support: IE8
                    // Enforce case-sensitivity of name attribute
                    if (el.querySelectorAll("[name=d]").length) rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                    // IE8 throws error here and will not see later tests
                    if (el.querySelectorAll(":enabled").length !== 2) rbuggyQSA.push(":enabled", ":disabled");
                    // Support: IE9-11+
                    // IE's :disabled selector does not pick up the children of disabled fieldsets
                    docElem.appendChild(el).disabled = true;
                    if (el.querySelectorAll(":disabled").length !== 2) rbuggyQSA.push(":enabled", ":disabled");
                    // Support: Opera 10 - 11 only
                    // Opera 10-11 does not throw on post-comma invalid pseudos
                    el.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) assert(function(el) {
                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9)
                support.disconnectedMatch = matches.call(el, "*");
                // This should fail with an exception
                // Gecko does not error, returns false instead
                matches.call(el, "[s!='']:x");
                rbuggyMatches.push("!=", pseudos);
            });
            if (!support.cssHas) // Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
            // Our regular `try-catch` mechanism fails to detect natively-unsupported
            // pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
            // in browsers that parse the `:has()` argument as a forgiving selector list.
            // https://drafts.csswg.org/selectors/#relational now requires the argument
            // to be parsed unforgivingly, but browsers have not yet fully adjusted.
            rbuggyQSA.push(":has");
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            /* Contains
	---------------------------------------------------------------------- */ hasCompare = rnative.test(docElem.compareDocumentPosition);
            // Element contains another
            // Purposefully self-exclusive
            // As in, an element does not contain itself
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                // Support: IE <9 only
                // IE doesn't have `contains` on `document` so we need to check for
                // `documentElement` presence.
                // We need to fall back to `a` when `documentElement` is missing
                // as `ownerDocument` of elements within `<template/>` may have
                // a null one - a default behavior of all modern browsers.
                var adown = a.nodeType === 9 && a.documentElement || a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
                if (b) while(b = b.parentNode){
                    if (b === a) return true;
                }
                return false;
            };
            /* Sorting
	---------------------------------------------------------------------- */ // Document order sorting
            sortOrder = hasCompare ? function(a, b) {
                // Flag for duplicate removal
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                // Sort on method existence if only one input has compareDocumentPosition
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) return compare;
                // Calculate position if both inputs belong to the same document
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
                1;
                // Disconnected nodes
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    // Choose the first element that is related to our preferred document
                    // Support: IE 11+, Edge 17 - 18+
                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                    // two documents; shallow comparisons work.
                    // eslint-disable-next-line eqeqeq
                    if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) return -1;
                    // Support: IE 11+, Edge 17 - 18+
                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                    // two documents; shallow comparisons work.
                    // eslint-disable-next-line eqeqeq
                    if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) return 1;
                    // Maintain original order
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function(a, b) {
                // Exit early if the nodes are identical
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [
                    a
                ], bp = [
                    b
                ];
                // Parentless nodes are either documents or disconnected
                if (!aup || !bup) // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                /* eslint-disable eqeqeq */ return a == document ? -1 : b == document ? 1 : /* eslint-enable eqeqeq */ aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                else if (aup === bup) return siblingCheck(a, b);
                // Otherwise we need full lists of their ancestors for comparison
                cur = a;
                while(cur = cur.parentNode)ap.unshift(cur);
                cur = b;
                while(cur = cur.parentNode)bp.unshift(cur);
                // Walk down the tree looking for a discrepancy
                while(ap[i] === bp[i])i++;
                return i ? // Do a sibling check if the nodes have a common ancestor
                siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                /* eslint-disable eqeqeq */ ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 : /* eslint-enable eqeqeq */ 0;
            };
            return document;
        };
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
            setDocument(elem);
            if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
                var ret = matches.call(elem, expr);
                // IE 9's matchesSelector returns false on disconnected nodes
                if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                // fragment in IE 9
                elem.document && elem.document.nodeType !== 11) return ret;
            } catch (e) {
                nonnativeSelectorCache(expr, true);
            }
            return Sizzle(expr, document, null, [
                elem
            ]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
            // Set document vars if needed
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if ((context.ownerDocument || context) != document) setDocument(context);
            return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
            // Set document vars if needed
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if ((elem.ownerDocument || elem) != document) setDocument(elem);
            var fn = Expr.attrHandle[name.toLowerCase()], // Don't get fooled by Object.prototype properties (jQuery #13807)
            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.escape = function(sel) {
            return (sel + "").replace(rcssescape, fcssescape);
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        /**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */ Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            // Unless we *know* we can detect duplicates, assume their presence
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while(elem = results[i++])if (elem === results[i]) j = duplicates.push(i);
                while(j--)results.splice(duplicates[j], 1);
            }
            // Clear input after sorting to release objects
            // See https://github.com/jquery/sizzle/pull/225
            sortInput = null;
            return results;
        };
        /**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */ getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) // If no nodeType, this is expected to be an array
            while(node = elem[i++])// Do not traverse comment nodes
            ret += getText(node);
            else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                // Use textContent for elements
                // innerText usage removed for consistency of new lines (jQuery #11153)
                if (typeof elem.textContent === "string") return elem.textContent;
                else // Traverse its children
                for(elem = elem.firstChild; elem; elem = elem.nextSibling)ret += getText(elem);
            } else if (nodeType === 3 || nodeType === 4) return elem.nodeValue;
            // Do not include comment or processing instruction nodes
            return ret;
        };
        Expr = Sizzle.selectors = {
            // Can be adjusted by the user
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                "ATTR": function(match) {
                    match[1] = match[1].replace(runescape, funescape);
                    // Move the given value to match[3] whether quoted or unquoted
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                    if (match[2] === "~=") match[3] = " " + match[3] + " ";
                    return match.slice(0, 4);
                },
                "CHILD": function(match) {
                    /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/ match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === "nth") {
                        // nth-* requires argument
                        if (!match[3]) Sizzle.error(match[0]);
                        // numeric x and y parameters for Expr.filter.CHILD
                        // remember that false/true cast respectively to 0/1
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");
                    // other types prohibit arguments
                    } else if (match[3]) Sizzle.error(match[0]);
                    return match;
                },
                "PSEUDO": function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr["CHILD"].test(match[0])) return null;
                    // Accept quoted arguments as-is
                    if (match[3]) match[2] = match[4] || match[5] || "";
                    else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                    (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
                    (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        // excess is a negative index
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    // Return only captures needed by the pseudo filter method (type and argument)
                    return match.slice(0, 3);
                }
            },
            filter: {
                "TAG": function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                "CLASS": function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)"), classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                    }));
                },
                "ATTR": function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) return operator === "!=";
                        if (!operator) return true;
                        result += "";
                        /* eslint-disable max-len */ return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    /* eslint-enable max-len */ };
                },
                "CHILD": function(type, what, _argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                    return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
                    function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, _context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                        if (parent) {
                            // :(first|last|only)-(child|of-type)
                            if (simple) {
                                while(dir){
                                    node = elem;
                                    while(node = node[dir]){
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) return false;
                                    }
                                    // Reverse direction for :only-* (if we haven't yet done so)
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
                            start = [
                                forward ? parent.firstChild : parent.lastChild
                            ];
                            // non-xml :nth-child(...) stores cache data on `parent`
                            if (forward && useCache) {
                                // Seek `elem` from a previously-cached index
                                // ...in a gzip-friendly way
                                node = parent;
                                outerCache = node[expando] || (node[expando] = {});
                                // Support: IE <9 only
                                // Defend against cloned attroperties (jQuery gh-1709)
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while(node = ++nodeIndex && node && node[dir] || // Fallback to seeking `elem` from the start
                                (diff = nodeIndex = 0) || start.pop())// When found, cache indexes on `parent` and break
                                if (node.nodeType === 1 && ++diff && node === elem) {
                                    uniqueCache[type] = [
                                        dirruns,
                                        nodeIndex,
                                        diff
                                    ];
                                    break;
                                }
                            } else {
                                // Use previously-cached element index if available
                                if (useCache) {
                                    // ...in a gzip-friendly way
                                    node = elem;
                                    outerCache = node[expando] || (node[expando] = {});
                                    // Support: IE <9 only
                                    // Defend against cloned attroperties (jQuery gh-1709)
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }
                                // xml :nth-child(...)
                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                if (diff === false) {
                                    // Use the same loop as above to seek `elem` from the start
                                    while(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        // Cache the index of each encountered element
                                        if (useCache) {
                                            outerCache = node[expando] || (node[expando] = {});
                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                            uniqueCache[type] = [
                                                dirruns,
                                                diff
                                            ];
                                        }
                                        if (node === elem) break;
                                    }
                                }
                            }
                            // Incorporate the offset, then check against cycle size
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                "PSEUDO": function(pseudo, argument) {
                    // pseudo-class names are case-insensitive
                    // http://www.w3.org/TR/selectors/#pseudo-classes
                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                    // Remember that setFilters inherits from pseudos
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    // The user may use createPseudo to indicate that
                    // arguments are needed to create the filter function
                    // just as Sizzle does
                    if (fn[expando]) return fn(argument);
                    // But maintain support for old signatures
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            "",
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while(i--){
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                // Potentially complex pseudos
                "not": markFunction(function(selector) {
                    // Trim the selector passed to compile
                    // to avoid treating leading and trailing
                    // spaces as combinators
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, _context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        // Match elements unmatched by `matcher`
                        while(i--)if (elem = unmatched[i]) seed[i] = !(matches[i] = elem);
                    }) : function(elem, _context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        // Don't keep the element (issue #299)
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                "has": markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                "contains": markFunction(function(text) {
                    text = text.replace(runescape, funescape);
                    return function(elem) {
                        return (elem.textContent || getText(elem)).indexOf(text) > -1;
                    };
                }),
                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // http://www.w3.org/TR/selectors/#lang-pseudo
                "lang": markFunction(function(lang) {
                    // lang value must be a valid identifier
                    if (!ridentifier.test(lang || "")) Sizzle.error("unsupported lang: " + lang);
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                            elemLang = elemLang.toLowerCase();
                            return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                        }
                        while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                // Miscellaneous
                "target": function(elem) {
                    var hash = window1.location && window1.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                "root": function(elem) {
                    return elem === docElem;
                },
                "focus": function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                // Boolean properties
                "enabled": createDisabledPseudo(false),
                "disabled": createDisabledPseudo(true),
                "checked": function(elem) {
                    // In CSS3, :checked should return both checked and selected elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },
                "selected": function(elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) // eslint-disable-next-line no-unused-expressions
                    elem.parentNode.selectedIndex;
                    return elem.selected === true;
                },
                // Contents
                "empty": function(elem) {
                    // http://www.w3.org/TR/selectors/#empty-pseudo
                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                    // nodeType < 6 works because attributes (2) do not appear as children
                    for(elem = elem.firstChild; elem; elem = elem.nextSibling){
                        if (elem.nodeType < 6) return false;
                    }
                    return true;
                },
                "parent": function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },
                // Element/input types
                "header": function(elem) {
                    return rheader.test(elem.nodeName);
                },
                "input": function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                "button": function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },
                "text": function(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && // Support: IE <10 only
                    // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                    ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                // Position-in-collection
                "first": createPositionalPseudo(function() {
                    return [
                        0
                    ];
                }),
                "last": createPositionalPseudo(function(_matchIndexes, length) {
                    return [
                        length - 1
                    ];
                }),
                "eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
                    return [
                        argument < 0 ? argument + length : argument
                    ];
                }),
                "even": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for(; i < length; i += 2)matchIndexes.push(i);
                    return matchIndexes;
                }),
                "odd": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for(; i < length; i += 2)matchIndexes.push(i);
                    return matchIndexes;
                }),
                "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument > length ? length : argument;
                    for(; --i >= 0;)matchIndexes.push(i);
                    return matchIndexes;
                }),
                "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for(; ++i < length;)matchIndexes.push(i);
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        // Add button/input type pseudos
        for(i in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        })Expr.pseudos[i] = createInputPseudo(i);
        for(i in {
            submit: true,
            reset: true
        })Expr.pseudos[i] = createButtonPseudo(i);
        // Easy API for creating new setFilters
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) return parseOnly ? 0 : cached.slice(0);
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while(soFar){
                // Comma and first run
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) // Don't consume trailing commas as valid
                    soFar = soFar.slice(match[0].length) || soFar;
                    groups.push(tokens = []);
                }
                matched = false;
                // Combinators
                if (match = rleadingCombinator.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        // Cast descendant combinators to space
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }
                // Filters
                for(type in Expr.filter)if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                    });
                    soFar = soFar.slice(matched.length);
                }
                if (!matched) break;
            }
            // Return the length of the invalid excess
            // if we're just parsing
            // Otherwise, throw an error or return tokens
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
            tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = "";
            for(; i < len; i++)selector += tokens[i].value;
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === "parentNode", doneName = done++;
            return combinator.first ? // Check against closest ancestor/preceding element
            function(elem, context, xml) {
                while(elem = elem[dir]){
                    if (elem.nodeType === 1 || checkNonElements) return matcher(elem, context, xml);
                }
                return false;
            } : // Check against all ancestor/preceding elements
            function(elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [
                    dirruns,
                    doneName
                ];
                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                if (xml) {
                    while(elem = elem[dir])if (elem.nodeType === 1 || checkNonElements) {
                        if (matcher(elem, context, xml)) return true;
                    }
                } else {
                    while(elem = elem[dir])if (elem.nodeType === 1 || checkNonElements) {
                        outerCache = elem[expando] || (elem[expando] = {});
                        // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)
                        uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                        if (skip && skip === elem.nodeName.toLowerCase()) elem = elem[dir] || elem;
                        else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) // Assign to newCache so results back-propagate to previous elements
                        return newCache[2] = oldCache[2];
                        else {
                            // Reuse newcache so results back-propagate to previous elements
                            uniqueCache[key] = newCache;
                            // A match means we're done; a fail means we have to keep checking
                            if (newCache[2] = matcher(elem, context, xml)) return true;
                        }
                    }
                }
                return false;
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while(i--){
                    if (!matchers[i](elem, context, xml)) return false;
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for(; i < len; i++)Sizzle(selector, contexts[i], results);
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for(; i < len; i++){
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) map.push(i);
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) postFilter = setMatcher(postFilter);
            if (postFinder && !postFinder[expando]) postFinder = setMatcher(postFinder, postSelector);
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, // Get initial elements from seed or context
                elems = seed || multipleContexts(selector || "*", context.nodeType ? [
                    context
                ] : context, []), // Prefilter to get matcher input, preserving a map for seed-results synchronization
                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
                [] : // ...otherwise use results directly
                results : matcherIn;
                // Find primary matches
                if (matcher) matcher(matcherIn, matcherOut, context, xml);
                // Apply postFilter
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    // Un-match failing elements by moving them back to matcherIn
                    i = temp.length;
                    while(i--)if (elem = temp[i]) matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                            temp = [];
                            i = matcherOut.length;
                            while(i--)if (elem = matcherOut[i]) // Restore matcherIn since elem is not yet a final match
                            temp.push(matcherIn[i] = elem);
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        // Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length;
                        while(i--)if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) seed[temp] = !(results[temp] = elem);
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) postFinder(null, results, matcherOut, xml);
                    else push.apply(results, matcherOut);
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, // The foundational matcher ensures that elements are reachable from top-level context(s)
            matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [
                function(elem, context, xml) {
                    var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                    // Avoid hanging onto element (issue #299)
                    checkContext = null;
                    return ret;
                }
            ];
            for(; i < len; i++)if (matcher = Expr.relative[tokens[i].type]) matchers = [
                addCombinator(elementMatcher(matchers), matcher)
            ];
            else {
                matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                // Return special upon seeing a positional matcher
                if (matcher[expando]) {
                    // Find the next relative operator (if any) for proper handling
                    j = ++i;
                    for(; j < len; j++){
                        if (Expr.relative[tokens[j].type]) break;
                    }
                    return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(// If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i - 1).concat({
                        value: tokens[i - 2].type === " " ? "*" : ""
                    })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                }
                matchers.push(matcher);
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, // We must always have either seed elements or outermost context
                elems = seed || byElement && Expr.find["TAG"]("*", outermost), // Use integer dirruns iff this is the outermost matcher
                dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                if (outermost) // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                outermostContext = context == document || context || outermost;
                // Add elements passing elementMatchers directly to results
                // Support: IE<9, Safari
                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                for(; i !== len && (elem = elems[i]) != null; i++){
                    if (byElement && elem) {
                        j = 0;
                        // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        // eslint-disable-next-line eqeqeq
                        if (!context && elem.ownerDocument != document) {
                            setDocument(elem);
                            xml = !documentIsHTML;
                        }
                        while(matcher = elementMatchers[j++])if (matcher(elem, context || document, xml)) {
                            results.push(elem);
                            break;
                        }
                        if (outermost) dirruns = dirrunsUnique;
                    }
                    // Track unmatched elements for set filters
                    if (bySet) {
                        // They will have gone through all possible matchers
                        if (elem = !matcher && elem) matchedCount--;
                        // Lengthen the array for every element, matched or not
                        if (seed) unmatched.push(elem);
                    }
                }
                // `i` is now the count of elements visited above, and adding it to `matchedCount`
                // makes the latter nonnegative.
                matchedCount += i;
                // Apply set filters to unmatched elements
                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                // no element matchers and no seed.
                // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                // numerically zero.
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while(matcher = setMatchers[j++])matcher(unmatched, setMatched, context, xml);
                    if (seed) {
                        // Reintegrate element matches to eliminate the need for sorting
                        if (matchedCount > 0) {
                            while(i--)if (!(unmatched[i] || setMatched[i])) setMatched[i] = pop.call(results);
                        }
                        // Discard index placeholder values to get only actual matches
                        setMatched = condense(setMatched);
                    }
                    // Add matches to results
                    push.apply(results, setMatched);
                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) Sizzle.uniqueSort(results);
                }
                // Override manipulation of globals by nested matchers
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
                return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match /* Internal Use Only */ ) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                // Generate a function of recursive functions that can be used to check each element
                if (!match) match = tokenize(selector);
                i = match.length;
                while(i--){
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) setMatchers.push(cached);
                    else elementMatchers.push(cached);
                }
                // Cache the compiled function
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                // Save selector and tokenization
                cached.selector = selector;
            }
            return cached;
        };
        /**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */ select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            // Try to minimize operations if there is only one selector in the list and no seed
            // (the latter of which guarantees us context)
            if (match.length === 1) {
                // Reduce context if the leading compound selector is an ID
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) return results;
                    else if (compiled) context = context.parentNode;
                    selector = selector.slice(tokens.shift().value.length);
                }
                // Fetch a seed set for right-to-left matching
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while(i--){
                    token = tokens[i];
                    // Abort if we hit a combinator
                    if (Expr.relative[type = token.type]) break;
                    if (find = Expr.find[type]) // Search, expanding context for leading sibling combinators
                    {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            // If seed is empty or no tokens remain, we can return early
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            // Compile and execute a filtering function if one is not provided
            // Provide `match` to avoid retokenization if we modified the selector above
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        // One-time assignments
        // Sort stability
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        // Support: Chrome 14-35+
        // Always assume duplicates if they aren't passed to the comparison function
        support.detectDuplicates = !!hasDuplicate;
        // Initialize against the default document
        setDocument();
        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
        // Detached nodes confoundingly follow *each other*
        support.sortDetached = assert(function(el) {
            // Should return 1, but returns 4 (following)
            return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
        });
        // Support: IE<8
        // Prevent attribute/property "interpolation"
        // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
        if (!assert(function(el) {
            el.innerHTML = "<a href='#'></a>";
            return el.firstChild.getAttribute("href") === "#";
        })) addHandle("type|href|height|width", function(elem, name, isXML) {
            if (!isXML) return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        });
        // Support: IE<9
        // Use defaultValue in place of getAttribute("value")
        if (!support.attributes || !assert(function(el) {
            el.innerHTML = "<input/>";
            el.firstChild.setAttribute("value", "");
            return el.firstChild.getAttribute("value") === "";
        })) addHandle("value", function(elem, _name, isXML) {
            if (!isXML && elem.nodeName.toLowerCase() === "input") return elem.defaultValue;
        });
        // Support: IE<9
        // Use getAttributeNode to fetch booleans when getAttribute lies
        if (!assert(function(el) {
            return el.getAttribute("disabled") == null;
        })) addHandle(booleans, function(elem, name, isXML) {
            var val;
            if (!isXML) return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        });
        return Sizzle;
    }(window1);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    // Deprecated
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;
    var dir = function(elem, dir, until) {
        var matched = [], truncate = until !== undefined;
        while((elem = elem[dir]) && elem.nodeType !== 9)if (elem.nodeType === 1) {
            if (truncate && jQuery(elem).is(until)) break;
            matched.push(elem);
        }
        return matched;
    };
    var siblings = function(n, elem) {
        var matched = [];
        for(; n; n = n.nextSibling)if (n.nodeType === 1 && n !== elem) matched.push(n);
        return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (isFunction(qualifier)) return jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
        });
        // Single element
        if (qualifier.nodeType) return jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
        });
        // Arraylike of elements (jQuery, arguments, Array)
        if (typeof qualifier !== "string") return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
        });
        // Filtered directly for both simple and complex selectors
        return jQuery.filter(qualifier, elements, not);
    }
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) expr = ":not(" + expr + ")";
        if (elems.length === 1 && elem.nodeType === 1) return jQuery.find.matchesSelector(elem, expr) ? [
            elem
        ] : [];
        return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, ret, len = this.length, self = this;
            if (typeof selector !== "string") return this.pushStack(jQuery(selector).filter(function() {
                for(i = 0; i < len; i++){
                    if (jQuery.contains(self[i], this)) return true;
                }
            }));
            ret = this.pushStack([]);
            for(i = 0; i < len; i++)jQuery.find(selector, self[i], ret);
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    // Initialize a jQuery object
    // A central reference to the root jQuery(document)
    var rootjQuery, // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
    // Strict HTML recognition (trac-11290: must start with <)
    // Shortcut simple #id case for speed
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {
        var match, elem;
        // HANDLE: $(""), $(null), $(undefined), $(false)
        if (!selector) return this;
        // Method init() accepts an alternate rootjQuery
        // so migrate can support jQuery.sub (gh-2101)
        root = root || rootjQuery;
        // Handle HTML strings
        if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) // Assume that strings that start and end with <> are HTML and skip the regex check
            match = [
                null,
                selector,
                null
            ];
            else match = rquickExpr.exec(selector);
            // Match html or make sure no context is specified for #id
            if (match && (match[1] || !context)) {
                // HANDLE: $(html) -> $(array)
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;
                    // Option to run scripts is true for back-compat
                    // Intentionally let the error be thrown if parseHTML is not present
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                    // HANDLE: $(html, props)
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for(match in context)// Properties of context are called as methods if possible
                        if (isFunction(this[match])) this[match](context[match]);
                        else this.attr(match, context[match]);
                    }
                    return this;
                // HANDLE: $(#id)
                } else {
                    elem = document.getElementById(match[2]);
                    if (elem) {
                        // Inject the element directly into the jQuery object
                        this[0] = elem;
                        this.length = 1;
                    }
                    return this;
                }
            } else if (!context || context.jquery) return (context || root).find(selector);
            else return this.constructor(context).find(selector);
        // HANDLE: $(DOMElement)
        } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
        // HANDLE: $(function)
        // Shortcut for document ready
        } else if (isFunction(selector)) return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
        selector(jQuery);
        return jQuery.makeArray(selector, this);
    };
    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;
    // Initialize central reference
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                var i = 0;
                for(; i < l; i++){
                    if (jQuery.contains(this, targets[i])) return true;
                }
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
            // Positional selectors never match, since there's no _selection_ context
            if (!rneedsContext.test(selectors)) for(; i < l; i++){
                for(cur = this[i]; cur && cur !== context; cur = cur.parentNode)// Always skip document fragments
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
                cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                    matched.push(cur);
                    break;
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function(elem) {
            // No argument, return index in parent
            if (!elem) return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            // Index in selector
            if (typeof elem === "string") return indexOf.call(jQuery(elem), this[0]);
            // Locate the position of the desired element
            return indexOf.call(this, // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while((cur = cur[dir]) && cur.nodeType !== 1);
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, _i, until) {
            return dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, _i, until) {
            return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, _i, until) {
            return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return siblings(elem.firstChild);
        },
        contents: function(elem) {
            if (elem.contentDocument != null && // Support: IE 11+
            // <object> elements with no `data` attribute has an object
            // `contentDocument` with a `null` prototype.
            getProto(elem.contentDocument)) return elem.contentDocument;
            // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
            // Treat the template element as a regular one in browsers that
            // don't support it.
            if (nodeName(elem, "template")) elem = elem.content || elem;
            return jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") selector = until;
            if (selector && typeof selector === "string") matched = jQuery.filter(selector, matched);
            if (this.length > 1) {
                // Remove duplicates
                if (!guaranteedUnique[name]) jQuery.uniqueSort(matched);
                // Reverse order for parents* and prev-derivatives
                if (rparentsprev.test(name)) matched.reverse();
            }
            return this.pushStack(matched);
        };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    // Convert String-formatted options into Object-formatted ones
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */ jQuery.Callbacks = function(options) {
        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
        var firing, // Last fire value for non-forgettable lists
        memory, // Flag to know if list was already fired
        fired, // Flag to prevent firing
        locked, // Actual callback list
        list = [], // Queue of execution data for repeatable lists
        queue = [], // Index of currently firing callback (modified by add/remove as needed)
        firingIndex = -1, // Fire callbacks
        fire = function() {
            // Enforce single-firing
            locked = locked || options.once;
            // Execute callbacks for all pending executions,
            // respecting firingIndex overrides and runtime changes
            fired = firing = true;
            for(; queue.length; firingIndex = -1){
                memory = queue.shift();
                while(++firingIndex < list.length)// Run callback and check for early termination
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                    // Jump to end and forget the data so .add doesn't re-fire
                    firingIndex = list.length;
                    memory = false;
                }
            }
            // Forget the data if we're done with it
            if (!options.memory) memory = false;
            firing = false;
            // Clean up if we're done firing for good
            if (locked) {
                // Keep an empty list if we have data for future add calls
                if (memory) list = [];
                else list = "";
            }
        }, // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if (list) {
                    // If we have memory from a past run, we should fire after adding
                    if (memory && !firing) {
                        firingIndex = list.length - 1;
                        queue.push(memory);
                    }
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            if (isFunction(arg)) {
                                if (!options.unique || !self.has(arg)) list.push(arg);
                            } else if (arg && arg.length && toType(arg) !== "string") // Inspect recursively
                            add(arg);
                        });
                    })(arguments);
                    if (memory && !firing) fire();
                }
                return this;
            },
            // Remove a callback from the list
            remove: function() {
                jQuery.each(arguments, function(_, arg) {
                    var index;
                    while((index = jQuery.inArray(arg, list, index)) > -1){
                        list.splice(index, 1);
                        // Handle firing indexes
                        if (index <= firingIndex) firingIndex--;
                    }
                });
                return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
            },
            // Remove all callbacks from the list
            empty: function() {
                if (list) list = [];
                return this;
            },
            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
                locked = queue = [];
                list = memory = "";
                return this;
            },
            disabled: function() {
                return !list;
            },
            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
                locked = queue = [];
                if (!memory && !firing) list = memory = "";
                return this;
            },
            locked: function() {
                return !!locked;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
                if (!locked) {
                    args = args || [];
                    args = [
                        context,
                        args.slice ? args.slice() : args
                    ];
                    queue.push(args);
                    if (!firing) fire();
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
                return !!fired;
            }
        };
        return self;
    };
    function Identity(v) {
        return v;
    }
    function Thrower(ex) {
        throw ex;
    }
    function adoptValue(value, resolve, reject, noValue) {
        var method;
        try {
            // Check for promise aspect first to privilege synchronous behavior
            if (value && isFunction(method = value.promise)) method.call(value).done(resolve).fail(reject);
            else if (value && isFunction(method = value.then)) method.call(value, resolve, reject);
            else // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
            // * false: [ value ].slice( 0 ) => resolve( value )
            // * true: [ value ].slice( 1 ) => resolve()
            resolve.apply(undefined, [
                value
            ].slice(noValue));
        // For Promises/A+, convert exceptions into rejections
        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
        // Deferred#then to conditionally suppress rejection.
        } catch (value) {
            // Support: Android 4.0 only
            // Strict mode functions invoked without .call/.apply get global-object context
            reject.apply(undefined, [
                value
            ]);
        }
    }
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [
                // action, add listener, callbacks,
                // ... .then handlers, argument index, [final state]
                [
                    "notify",
                    "progress",
                    jQuery.Callbacks("memory"),
                    jQuery.Callbacks("memory"),
                    2
                ],
                [
                    "resolve",
                    "done",
                    jQuery.Callbacks("once memory"),
                    jQuery.Callbacks("once memory"),
                    0,
                    "resolved"
                ],
                [
                    "reject",
                    "fail",
                    jQuery.Callbacks("once memory"),
                    jQuery.Callbacks("once memory"),
                    1,
                    "rejected"
                ]
            ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done(arguments).fail(arguments);
                    return this;
                },
                "catch": function(fn) {
                    return promise.then(null, fn);
                },
                // Keep pipe for back-compat
                pipe: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(_i, tuple) {
                            // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                            var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                            // deferred.progress(function() { bind to newDefer or newDefer.notify })
                            // deferred.done(function() { bind to newDefer or newDefer.resolve })
                            // deferred.fail(function() { bind to newDefer or newDefer.reject })
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && isFunction(returned.promise)) returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                else newDefer[tuple[0] + "With"](this, fn ? [
                                    returned
                                ] : arguments);
                            });
                        });
                        fns = null;
                    }).promise();
                },
                then: function(onFulfilled, onRejected, onProgress) {
                    var maxDepth = 0;
                    function resolve(depth, deferred, handler, special) {
                        return function() {
                            var that = this, args = arguments, mightThrow = function() {
                                var returned, then;
                                // Support: Promises/A+ section 2.3.3.3.3
                                // https://promisesaplus.com/#point-59
                                // Ignore double-resolution attempts
                                if (depth < maxDepth) return;
                                returned = handler.apply(that, args);
                                // Support: Promises/A+ section 2.3.1
                                // https://promisesaplus.com/#point-48
                                if (returned === deferred.promise()) throw new TypeError("Thenable self-resolution");
                                // Support: Promises/A+ sections 2.3.3.1, 3.5
                                // https://promisesaplus.com/#point-54
                                // https://promisesaplus.com/#point-75
                                // Retrieve `then` only once
                                then = returned && // Support: Promises/A+ section 2.3.4
                                // https://promisesaplus.com/#point-64
                                // Only check objects and functions for thenability
                                (typeof returned === "object" || typeof returned === "function") && returned.then;
                                // Handle a returned thenable
                                if (isFunction(then)) {
                                    // Special processors (notify) just wait for resolution
                                    if (special) then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                                    else {
                                        // ...and disregard older resolution values
                                        maxDepth++;
                                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                                    }
                                } else {
                                    // Only substitute handlers pass on context
                                    // and multiple values (non-spec behavior)
                                    if (handler !== Identity) {
                                        that = undefined;
                                        args = [
                                            returned
                                        ];
                                    }
                                    // Process the value(s)
                                    // Default process is resolve
                                    (special || deferred.resolveWith)(that, args);
                                }
                            }, // Only normal processors (resolve) catch and reject exceptions
                            process = special ? mightThrow : function() {
                                try {
                                    mightThrow();
                                } catch (e) {
                                    if (jQuery.Deferred.exceptionHook) jQuery.Deferred.exceptionHook(e, process.stackTrace);
                                    // Support: Promises/A+ section 2.3.3.3.4.1
                                    // https://promisesaplus.com/#point-61
                                    // Ignore post-resolution exceptions
                                    if (depth + 1 >= maxDepth) {
                                        // Only substitute handlers pass on context
                                        // and multiple values (non-spec behavior)
                                        if (handler !== Thrower) {
                                            that = undefined;
                                            args = [
                                                e
                                            ];
                                        }
                                        deferred.rejectWith(that, args);
                                    }
                                }
                            };
                            // Support: Promises/A+ section 2.3.3.3.1
                            // https://promisesaplus.com/#point-57
                            // Re-resolve promises immediately to dodge false rejection from
                            // subsequent errors
                            if (depth) process();
                            else {
                                // Call an optional hook to record the stack, in case of exception
                                // since it's otherwise lost when execution goes async
                                if (jQuery.Deferred.getStackHook) process.stackTrace = jQuery.Deferred.getStackHook();
                                window1.setTimeout(process);
                            }
                        };
                    }
                    return jQuery.Deferred(function(newDefer) {
                        // progress_handlers.add( ... )
                        tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                        // fulfilled_handlers.add( ... )
                        tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
                        // rejected_handlers.add( ... )
                        tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            // Add list-specific methods
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[5];
                // promise.progress = list.add
                // promise.done = list.add
                // promise.fail = list.add
                promise[tuple[1]] = list.add;
                // Handle state
                if (stateString) list.add(function() {
                    // state = "resolved" (i.e., fulfilled)
                    // state = "rejected"
                    state = stateString;
                }, // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[3 - i][2].disable, // rejected_handlers.disable
                // fulfilled_handlers.disable
                tuples[3 - i][3].disable, // progress_callbacks.lock
                tuples[0][2].lock, // progress_handlers.lock
                tuples[0][3].lock);
                // progress_handlers.fire
                // fulfilled_handlers.fire
                // rejected_handlers.fire
                list.add(tuple[3].fire);
                // deferred.notify = function() { deferred.notifyWith(...) }
                // deferred.resolve = function() { deferred.resolveWith(...) }
                // deferred.reject = function() { deferred.rejectWith(...) }
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
                    return this;
                };
                // deferred.notifyWith = list.fireWith
                // deferred.resolveWith = list.fireWith
                // deferred.rejectWith = list.fireWith
                deferred[tuple[0] + "With"] = list.fireWith;
            });
            // Make the deferred a promise
            promise.promise(deferred);
            // Call given func if any
            if (func) func.call(deferred, deferred);
            // All done!
            return deferred;
        },
        // Deferred helper
        when: function(singleValue) {
            var // count of uncompleted subordinates
            remaining = arguments.length, // count of unprocessed arguments
            i = remaining, // subordinate fulfillment data
            resolveContexts = Array(i), resolveValues = slice.call(arguments), // the primary Deferred
            primary = jQuery.Deferred(), // subordinate callback factory
            updateFunc = function(i) {
                return function(value) {
                    resolveContexts[i] = this;
                    resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
                    if (!--remaining) primary.resolveWith(resolveContexts, resolveValues);
                };
            };
            // Single- and empty arguments are adopted like Promise.resolve
            if (remaining <= 1) {
                adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining);
                // Use .then() to unwrap secondary thenables (cf. gh-3000)
                if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) return primary.then();
            }
            // Multiple arguments are aggregated like Promise.all array elements
            while(i--)adoptValue(resolveValues[i], updateFunc(i), primary.reject);
            return primary.promise();
        }
    });
    // These usually indicate a programmer mistake during development,
    // warn about them ASAP rather than swallowing them by default.
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function(error, stack) {
        // Support: IE 8 - 9 only
        // Console exists when dev tools are open, which can happen at any time
        if (window1.console && window1.console.warn && error && rerrorNames.test(error.name)) window1.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    };
    jQuery.readyException = function(error) {
        window1.setTimeout(function() {
            throw error;
        });
    };
    // The deferred used on DOM ready
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function(fn) {
        readyList.then(fn)// Wrap jQuery.readyException in a function so that the lookup
        // happens at the time of error handling instead of callback
        // registration.
        .catch(function(error) {
            jQuery.readyException(error);
        });
        return this;
    };
    jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See trac-6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function(wait) {
            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) return;
            // Remember that the DOM is ready
            jQuery.isReady = true;
            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) return;
            // If there are functions bound, to execute
            readyList.resolveWith(document, [
                jQuery
            ]);
        }
    });
    jQuery.ready.then = readyList.then;
    // The ready event handler and self cleanup method
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed);
        window1.removeEventListener("load", completed);
        jQuery.ready();
    }
    // Catch cases where $(document).ready() is called
    // after the browser event has already occurred.
    // Support: IE <=9 - 10 only
    // Older IE sometimes signals "interactive" too soon
    if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) // Handle it asynchronously to allow scripts the opportunity to delay ready
    window1.setTimeout(jQuery.ready);
    else {
        // Use the handy event callback
        document.addEventListener("DOMContentLoaded", completed);
        // A fallback to window.onload, that will always work
        window1.addEventListener("load", completed);
    }
    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        // Sets many values
        if (toType(key) === "object") {
            chainable = true;
            for(i in key)access(elems, fn, i, key[i], true, emptyGet, raw);
        // Sets one value
        } else if (value !== undefined) {
            chainable = true;
            if (!isFunction(value)) raw = true;
            if (bulk) {
                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function(elem, _key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) for(; i < len; i++)fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
        if (chainable) return elems;
        // Gets
        if (bulk) return fn.call(elems);
        return len ? fn(elems[0], key) : emptyGet;
    };
    // Matches dashed string for camelizing
    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
    // Used by camelCase as callback to replace()
    function fcamelCase(_all, letter) {
        return letter.toUpperCase();
    }
    // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 15
    // Microsoft forgot to hump their vendor prefix (trac-9572)
    function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function(owner) {
        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
        cache: function(owner) {
            // Check if the owner object already has a cache
            var value = owner[this.expando];
            // If not, create one
            if (!value) {
                value = {};
                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see trac-8335.
                // Always return an empty object.
                if (acceptData(owner)) {
                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if (owner.nodeType) owner[this.expando] = value;
                    else Object.defineProperty(owner, this.expando, {
                        value: value,
                        configurable: true
                    });
                }
            }
            return value;
        },
        set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            // Handle: [ owner, key, value ] args
            // Always use camelCase key (gh-2257)
            if (typeof data === "string") cache[camelCase(data)] = value;
            else // Copy the properties one-by-one to the cache object
            for(prop in data)cache[camelCase(prop)] = data[prop];
            return cache;
        },
        get: function(owner, key) {
            return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
            owner[this.expando] && owner[this.expando][camelCase(key)];
        },
        access: function(owner, key, value) {
            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if (key === undefined || key && typeof key === "string" && value === undefined) return this.get(owner, key);
            // When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set(owner, key, value);
            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, cache = owner[this.expando];
            if (cache === undefined) return;
            if (key !== undefined) {
                // Support array or space separated string of keys
                if (Array.isArray(key)) // If key is an array of keys...
                // We always set camelCase keys, so remove that.
                key = key.map(camelCase);
                else {
                    key = camelCase(key);
                    // If a key with the spaces exists, use it.
                    // Otherwise, create an array by matching non-whitespace
                    key = key in cache ? [
                        key
                    ] : key.match(rnothtmlwhite) || [];
                }
                i = key.length;
                while(i--)delete cache[key[i]];
            }
            // Remove the expando if there's no more data
            if (key === undefined || jQuery.isEmptyObject(cache)) {
                // Support: Chrome <=35 - 45
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                if (owner.nodeType) owner[this.expando] = undefined;
                else delete owner[this.expando];
            }
        },
        hasData: function(owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data) {
        if (data === "true") return true;
        if (data === "false") return false;
        if (data === "null") return null;
        // Only convert to a number if it doesn't change the string
        if (data === +data + "") return +data;
        if (rbrace.test(data)) return JSON.parse(data);
        return data;
    }
    function dataAttr(elem, key, data) {
        var name;
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = getData(data);
                } catch (e) {}
                // Make sure we set the data so it isn't changed later
                dataUser.set(elem, key, data);
            } else data = undefined;
        }
        return data;
    }
    jQuery.extend({
        hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
            dataUser.remove(elem, name);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);
                    if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while(i--)// Support: IE 11 only
                        // The attrs elements can be null (trac-14894)
                        if (attrs[i]) {
                            name = attrs[i].name;
                            if (name.indexOf("data-") === 0) {
                                name = camelCase(name.slice(5));
                                dataAttr(elem, name, data[name]);
                            }
                        }
                        dataPriv.set(elem, "hasDataAttrs", true);
                    }
                }
                return data;
            }
            // Sets multiple values
            if (typeof key === "object") return this.each(function() {
                dataUser.set(this, key);
            });
            return access(this, function(value) {
                var data;
                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if (elem && value === undefined) {
                    // Attempt to get data from the cache
                    // The key will always be camelCased in Data
                    data = dataUser.get(elem, key);
                    if (data !== undefined) return data;
                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, key);
                    if (data !== undefined) return data;
                    // We tried really hard, but the data doesn't exist.
                    return;
                }
                // Set the data...
                this.each(function() {
                    // We always store the camelCased key
                    dataUser.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
            return this.each(function() {
                dataUser.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = dataPriv.get(elem, type);
                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || Array.isArray(data)) queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    else queue.push(data);
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") queue.unshift("inprogress");
                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) hooks.empty.fire();
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    dataPriv.remove(elem, [
                        type + "queue",
                        key
                    ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) return jQuery.queue(this[0], type);
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                // Ensure a hooks for this queue
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") jQuery.dequeue(this, type);
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) defer.resolveWith(elements, [
                    elements
                ]);
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while(i--){
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = [
        "Top",
        "Right",
        "Bottom",
        "Left"
    ];
    var documentElement = document.documentElement;
    var isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem);
    }, composed = {
        composed: true
    };
    // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
    // Check attachment across shadow DOM boundaries when possible (gh-3504)
    // Support: iOS 10.0-10.2 only
    // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
    // leading to errors. We need to check for `getRootNode`.
    if (documentElement.getRootNode) isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
    };
    var isHiddenWithinTree = function(elem, el) {
        // isHiddenWithinTree might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        // Inline style trumps all
        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) && jQuery.css(elem, "display") === "none";
    };
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
        } : function() {
            return jQuery.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), // Starting value computation is required for potential unit mismatches
        initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            // Support: Firefox <=54
            // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
            initial = initial / 2;
            // Trust units reported by jQuery.css
            unit = unit || initialInUnit[3];
            // Iteratively approximate from a nonzero starting point
            initialInUnit = +initial || 1;
            while(maxIterations--){
                // Evaluate and update our best guess (doubling guesses that zero out).
                // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
                jQuery.style(elem, prop, initialInUnit + unit);
                if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) maxIterations = 0;
                initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery.style(elem, prop, initialInUnit + unit);
            // Make sure we update the tween properties later on
            valueParts = valueParts || [];
        }
        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            // Apply relative offset (+=/-=) if specified
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
        if (display) return display;
        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, "display");
        temp.parentNode.removeChild(temp);
        if (display === "none") display = "block";
        defaultDisplayMap[nodeName] = display;
        return display;
    }
    function showHide(elements, show) {
        var display, elem, values = [], index = 0, length = elements.length;
        // Determine new display value for elements that need to change
        for(; index < length; index++){
            elem = elements[index];
            if (!elem.style) continue;
            display = elem.style.display;
            if (show) {
                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                // check is required in this first loop unless we have a nonempty display value (either
                // inline or about-to-be-restored)
                if (display === "none") {
                    values[index] = dataPriv.get(elem, "display") || null;
                    if (!values[index]) elem.style.display = "";
                }
                if (elem.style.display === "" && isHiddenWithinTree(elem)) values[index] = getDefaultDisplay(elem);
            } else if (display !== "none") {
                values[index] = "none";
                // Remember what we're overwriting
                dataPriv.set(elem, "display", display);
            }
        }
        // Set the display of the elements in a second loop to avoid constant reflow
        for(index = 0; index < length; index++)if (values[index] != null) elements[index].style.display = values[index];
        return elements;
    }
    jQuery.fn.extend({
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") return state ? this.show() : this.hide();
            return this.each(function() {
                if (isHiddenWithinTree(this)) jQuery(this).show();
                else jQuery(this).hide();
            });
        }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
    (function() {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        // Support: Android 4.0 - 4.3 only
        // Check state lost if the name is set (trac-11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (trac-14901)
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        // Support: Android <=4.1 only
        // Older WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        // Support: IE <=11 only
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        // Support: IE <=9 only
        // IE <=9 replaces <option> tags with their contents when inserted outside of
        // the select element.
        div.innerHTML = "<option></option>";
        support.option = !!div.lastChild;
    })();
    // We have to close these tags to support XHTML (trac-13200)
    var wrapMap = {
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [
            1,
            "<table>",
            "</table>"
        ],
        col: [
            2,
            "<table><colgroup>",
            "</colgroup></table>"
        ],
        tr: [
            2,
            "<table><tbody>",
            "</tbody></table>"
        ],
        td: [
            3,
            "<table><tbody><tr>",
            "</tr></tbody></table>"
        ],
        _default: [
            0,
            "",
            ""
        ]
    };
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    // Support: IE <=9 only
    if (!support.option) wrapMap.optgroup = wrapMap.option = [
        1,
        "<select multiple='multiple'>",
        "</select>"
    ];
    function getAll(context, tag) {
        // Support: IE <=9 - 11 only
        // Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
        var ret;
        if (typeof context.getElementsByTagName !== "undefined") ret = context.getElementsByTagName(tag || "*");
        else if (typeof context.querySelectorAll !== "undefined") ret = context.querySelectorAll(tag || "*");
        else ret = [];
        if (tag === undefined || tag && nodeName(context, tag)) return jQuery.merge([
            context
        ], ret);
        return ret;
    }
    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for(; i < l; i++)dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
        for(; i < l; i++){
            elem = elems[i];
            if (elem || elem === 0) {
                // Add nodes directly
                if (toType(elem) === "object") // Support: Android <=4.0 only, PhantomJS 1 only
                // push.apply(_, arraylike) throws on ancient WebKit
                jQuery.merge(nodes, elem.nodeType ? [
                    elem
                ] : elem);
                else if (!rhtml.test(elem)) nodes.push(context.createTextNode(elem));
                else {
                    tmp = tmp || fragment.appendChild(context.createElement("div"));
                    // Deserialize a standard representation
                    tag = (rtagName.exec(elem) || [
                        "",
                        ""
                    ])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while(j--)tmp = tmp.lastChild;
                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, tmp.childNodes);
                    // Remember the top-level container
                    tmp = fragment.firstChild;
                    // Ensure the created nodes are orphaned (trac-12392)
                    tmp.textContent = "";
                }
            }
        }
        // Remove wrapper from fragment
        fragment.textContent = "";
        i = 0;
        while(elem = nodes[i++]){
            // Skip elements already in the context collection (trac-4087)
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) ignored.push(elem);
                continue;
            }
            attached = isAttached(elem);
            // Append to fragment
            tmp = getAll(fragment.appendChild(elem), "script");
            // Preserve script evaluation history
            if (attached) setGlobalEval(tmp);
            // Capture executables
            if (scripts) {
                j = 0;
                while(elem = tmp[j++])if (rscriptType.test(elem.type || "")) scripts.push(elem);
            }
        }
        return fragment;
    }
    var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    // Support: IE <=9 - 11+
    // focus() and blur() are asynchronous, except when they are no-op.
    // So expect focus to be synchronous when the element is already active,
    // and blur to be synchronous when the element is not already active.
    // (focus and blur are always synchronous in other supported browsers,
    // this just defines when we can count on it).
    function expectSync(elem, type) {
        return elem === safeActiveElement() === (type === "focus");
    }
    // Support: IE <=9 only
    // Accessing document.activeElement can throw unexpectedly
    // https://bugs.jquery.com/ticket/13393
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        // Types can be a map of types/handlers
        if (typeof types === "object") {
            // ( types-Object, selector, data )
            if (typeof selector !== "string") {
                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for(type in types)on(elem, type, selector, data, types[type], one);
            return elem;
        }
        if (data == null && fn == null) {
            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === "string") {
                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {
                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) fn = returnFalse;
        else if (!fn) return elem;
        if (one === 1) {
            origFn = fn;
            fn = function(event) {
                // Can use an empty set, since event contains the info
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };
            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */ jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            // Only attach events to objects that accept data
            if (!acceptData(elem)) return;
            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            // Ensure that invalid selectors throw exceptions at attach time
            // Evaluate against documentElement in case elem is a non-element node (e.g., document)
            if (selector) jQuery.find.matchesSelector(documentElement, selector);
            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) handler.guid = jQuery.guid++;
            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) events = elemData.events = Object.create(null);
            if (!(eventHandle = elemData.handle)) eventHandle = elemData.handle = function(e) {
                // Discard the second event of a jQuery.event.trigger() and
                // when an event is called after a page has unloaded
                return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
            };
            // Handle multiple events separated by a space
            types = (types || "").match(rnothtmlwhite) || [
                ""
            ];
            t = types.length;
            while(t--){
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                // There *must* be a type, no attaching namespace-only handlers
                if (!type) continue;
                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};
                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;
                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};
                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    // Only use addEventListener if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) elem.addEventListener(type, eventHandle);
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) handleObj.handler.guid = handler.guid;
                }
                // Add to the element's handler list, delegates in front
                if (selector) handlers.splice(handlers.delegateCount++, 0, handleObj);
                else handlers.push(handleObj);
                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) return;
            // Once for each type.namespace in types; type may be omitted
            types = (types || "").match(rnothtmlwhite) || [
                ""
            ];
            t = types.length;
            while(t--){
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for(type in events)jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                // Remove matching events
                origCount = j = handlers.length;
                while(j--){
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) handlers.delegateCount--;
                        if (special.remove) special.remove.call(elem, handleObj);
                    }
                }
                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) jQuery.removeEvent(elem, type, elemData.handle);
                    delete events[type];
                }
            }
            // Remove data and the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) dataPriv.remove(elem, "handle events");
        },
        dispatch: function(nativeEvent) {
            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            for(i = 1; i < arguments.length; i++)args[i] = arguments[i];
            event.delegateTarget = this;
            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) return;
            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while((matched = handlerQueue[i++]) && !event.isPropagationStopped()){
                event.currentTarget = matched.elem;
                j = 0;
                while((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped())// If the event is namespaced, then each handler is only invoked if it is
                // specially universal or its namespaces are a superset of the event's.
                if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                    event.handleObj = handleObj;
                    event.data = handleObj.data;
                    ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                    if (ret !== undefined) {
                        if ((event.result = ret) === false) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }
                }
            }
            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) special.postDispatch.call(this, event);
            return event.result;
        },
        handlers: function(event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            // Find delegate handlers
            if (delegateCount && // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType && // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === "click" && event.button >= 1)) {
                for(; cur !== this; cur = cur.parentNode || this)// Don't check non-elements (trac-13208)
                // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                    matchedHandlers = [];
                    matchedSelectors = {};
                    for(i = 0; i < delegateCount; i++){
                        handleObj = handlers[i];
                        // Don't conflict with Object.prototype properties (trac-13203)
                        sel = handleObj.selector + " ";
                        if (matchedSelectors[sel] === undefined) matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [
                            cur
                        ]).length;
                        if (matchedSelectors[sel]) matchedHandlers.push(handleObj);
                    }
                    if (matchedHandlers.length) handlerQueue.push({
                        elem: cur,
                        handlers: matchedHandlers
                    });
                }
            }
            // Add the remaining (directly-bound) handlers
            cur = this;
            if (delegateCount < handlers.length) handlerQueue.push({
                elem: cur,
                handlers: handlers.slice(delegateCount)
            });
            return handlerQueue;
        },
        addProp: function(name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,
                get: isFunction(hook) ? function() {
                    if (this.originalEvent) return hook(this.originalEvent);
                } : function() {
                    if (this.originalEvent) return this.originalEvent[name];
                },
                set: function(value) {
                    Object.defineProperty(this, name, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    });
                }
            });
        },
        fix: function(originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            click: {
                // Utilize native event to ensure correct state for checkable inputs
                setup: function(data) {
                    // For mutual compressibility with _default, replace `this` access with a local var.
                    // `|| data` is dead code meant only to preserve the variable through minification.
                    var el = this || data;
                    // Claim the first handler
                    if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) // dataPriv.set( el, "click", ... )
                    leverageNative(el, "click", returnTrue);
                    // Return false to allow normal processing in the caller
                    return false;
                },
                trigger: function(data) {
                    // For mutual compressibility with _default, replace `this` access with a local var.
                    // `|| data` is dead code meant only to preserve the variable through minification.
                    var el = this || data;
                    // Force setup before triggering a click
                    if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) leverageNative(el, "click");
                    // Return non-false to allow normal event-path propagation
                    return true;
                },
                // For cross-browser consistency, suppress native .click() on links
                // Also prevent it if we're currently inside a leveraged native-event stack
                _default: function(event) {
                    var target = event.target;
                    return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) event.originalEvent.returnValue = event.result;
                }
            }
        }
    };
    // Ensure the presence of an event listener that handles manually-triggered
    // synthetic events by interrupting progress until reinvoked in response to
    // *native* events that it fires directly, ensuring that state changes have
    // already occurred before other listeners are invoked.
    function leverageNative(el, type, expectSync) {
        // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
        if (!expectSync) {
            if (dataPriv.get(el, type) === undefined) jQuery.event.add(el, type, returnTrue);
            return;
        }
        // Register the controller as a special universal handler for all event namespaces
        dataPriv.set(el, type, false);
        jQuery.event.add(el, type, {
            namespace: false,
            handler: function(event) {
                var notAsync, result, saved = dataPriv.get(this, type);
                if (event.isTrigger & 1 && this[type]) {
                    // Interrupt processing of the outer synthetic .trigger()ed event
                    // Saved data should be false in such cases, but might be a leftover capture object
                    // from an async native handler (gh-4350)
                    if (!saved.length) {
                        // Store arguments for use when handling the inner native event
                        // There will always be at least one argument (an event object), so this array
                        // will not be confused with a leftover capture object.
                        saved = slice.call(arguments);
                        dataPriv.set(this, type, saved);
                        // Trigger the native event and capture its result
                        // Support: IE <=9 - 11+
                        // focus() and blur() are asynchronous
                        notAsync = expectSync(this, type);
                        this[type]();
                        result = dataPriv.get(this, type);
                        if (saved !== result || notAsync) dataPriv.set(this, type, false);
                        else result = {};
                        if (saved !== result) {
                            // Cancel the outer synthetic event
                            event.stopImmediatePropagation();
                            event.preventDefault();
                            // Support: Chrome 86+
                            // In Chrome, if an element having a focusout handler is blurred by
                            // clicking outside of it, it invokes the handler synchronously. If
                            // that handler calls `.remove()` on the element, the data is cleared,
                            // leaving `result` undefined. We need to guard against this.
                            return result && result.value;
                        }
                    // If this is an inner synthetic event for an event with a bubbling surrogate
                    // (focus or blur), assume that the surrogate already propagated from triggering the
                    // native event and prevent that from happening again here.
                    // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
                    // bubbling surrogate propagates *after* the non-bubbling base), but that seems
                    // less bad than duplication.
                    } else if ((jQuery.event.special[type] || {}).delegateType) event.stopPropagation();
                // If this is a native event triggered above, everything is now in order
                // Fire an inner synthetic event with the original arguments
                } else if (saved.length) {
                    // ...and capture the result
                    dataPriv.set(this, type, {
                        value: jQuery.event.trigger(// Support: IE <=9 - 11+
                        // Extend with the prototype to reset the above stopImmediatePropagation()
                        jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
                    });
                    // Abort handling of the native event
                    event.stopImmediatePropagation();
                }
            }
        });
    }
    jQuery.removeEvent = function(elem, type, handle) {
        // This "if" is needed for plain objects
        if (elem.removeEventListener) elem.removeEventListener(type, handle);
    };
    jQuery.Event = function(src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) return new jQuery.Event(src, props);
        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
            src.returnValue === false ? returnTrue : returnFalse;
            // Create target properties
            // Support: Safari <=6 - 7 only
            // Target should not be a text node (trac-504, trac-13143)
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
        // Event type
        } else this.type = src;
        // Put explicitly provided properties onto the event object
        if (props) jQuery.extend(this, props);
        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || Date.now();
        // Mark it as fixed
        this[jQuery.expando] = true;
    };
    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) e.preventDefault();
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) e.stopPropagation();
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) e.stopImmediatePropagation();
            this.stopPropagation();
        }
    };
    // Includes all common event props including KeyEvent and MouseEvent specific props
    jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true
    }, jQuery.event.addProp);
    jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(type, delegateType) {
        jQuery.event.special[type] = {
            // Utilize native event if possible so blur/focus sequence is correct
            setup: function() {
                // Claim the first handler
                // dataPriv.set( this, "focus", ... )
                // dataPriv.set( this, "blur", ... )
                leverageNative(this, type, expectSync);
                // Return false to allow normal processing in the caller
                return false;
            },
            trigger: function() {
                // Force setup before trigger
                leverageNative(this, type);
                // Return non-false to allow normal event-path propagation
                return true;
            },
            // Suppress native focus or blur if we're currently inside
            // a leveraged native-event stack
            _default: function(event) {
                return dataPriv.get(event.target, type);
            },
            delegateType: delegateType
        };
    });
    // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                // For mouseenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    jQuery.fn.extend({
        on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                // ( types-object [, selector] )
                for(type in types)this.off(type, selector, types[type]);
                return this;
            }
            if (selector === false || typeof selector === "function") {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) fn = returnFalse;
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var // Support: IE <=10 - 11, Edge 12 - 13 only
    // In IE/Edge using regex groups here causes severe slowdowns.
    // See https://connect.microsoft.com/IE/feedback/details/1736512/
    rnoInnerhtml = /<script|<style|<link/i, // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
    // Prefer a tbody over its parent table for containing new rows
    function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) return jQuery(elem).children("tbody")[0] || elem;
        return elem;
    }
    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") elem.type = elem.type.slice(5);
        else elem.removeAttribute("type");
        return elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, udataOld, udataCur, events;
        if (dest.nodeType !== 1) return;
        // 1. Copy private data: events, handlers, etc.
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
                dataPriv.remove(dest, "handle events");
                for(type in events)for(i = 0, l = events[type].length; i < l; i++)jQuery.event.add(dest, type, events[type][i]);
            }
        }
        // 2. Copy user data
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
        }
    }
    // Fix IE bugs, see support tests
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        // Fails to persist the checked state of a cloned checkbox or radio button.
        if (nodeName === "input" && rcheckableType.test(src.type)) dest.checked = src.checked;
        else if (nodeName === "input" || nodeName === "textarea") dest.defaultValue = src.defaultValue;
    }
    function domManip(collection, args, callback, ignored) {
        // Flatten any nested arrays
        args = flat(args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
        // We can't cloneNode fragments that contain checked, in WebKit
        if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) return collection.each(function(index) {
            var self = collection.eq(index);
            if (valueIsFunction) args[0] = value.call(this, index, self.html());
            domManip(self, args, callback, ignored);
        });
        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) fragment = first;
            // Require either new content or an interest in ignored elements to invoke the callback
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;
                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (trac-8070).
                for(; i < l; i++){
                    node = fragment;
                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);
                        // Keep references to cloned scripts for later restoration
                        if (hasScripts) // Support: Android <=4.0 only, PhantomJS 1 only
                        // push.apply(_, arraylike) throws on ancient WebKit
                        jQuery.merge(scripts, getAll(node, "script"));
                    }
                    callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;
                    // Reenable scripts
                    jQuery.map(scripts, restoreScript);
                    // Evaluate executable scripts on first document insertion
                    for(i = 0; i < hasScripts; i++){
                        node = scripts[i];
                        if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                            if (node.src && (node.type || "").toLowerCase() !== "module") // Optional AJAX dependency, but won't run scripts if not present
                            {
                                if (jQuery._evalUrl && !node.noModule) jQuery._evalUrl(node.src, {
                                    nonce: node.nonce || node.getAttribute("nonce")
                                }, doc);
                            } else // Unwrap a CDATA section containing script contents. This shouldn't be
                            // needed as in XML documents they're already not visible when
                            // inspecting element contents and in HTML documents they have no
                            // meaning but we're preserving that logic for backwards compatibility.
                            // This will be removed completely in 4.0. See gh-4904.
                            DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                        }
                    }
                }
            }
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
        for(; (node = nodes[i]) != null; i++){
            if (!keepData && node.nodeType === 1) jQuery.cleanData(getAll(node));
            if (node.parentNode) {
                if (keepData && isAttached(node)) setGlobalEval(getAll(node, "script"));
                node.parentNode.removeChild(node);
            }
        }
        return elem;
    }
    jQuery.extend({
        htmlPrefilter: function(html) {
            return html;
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
            // Fix IE cloning issues
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for(i = 0, l = srcElements.length; i < l; i++)fixInput(srcElements[i], destElements[i]);
            }
            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for(i = 0, l = srcElements.length; i < l; i++)cloneCopyEvent(srcElements[i], destElements[i]);
                } else cloneCopyEvent(elem, clone);
            }
            // Preserve script evaluation history
            destElements = getAll(clone, "script");
            if (destElements.length > 0) setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            // Return the cloned set
            return clone;
        },
        cleanData: function(elems) {
            var data, elem, type, special = jQuery.event.special, i = 0;
            for(; (elem = elems[i]) !== undefined; i++)if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                    if (data.events) {
                        for(type in data.events)if (special[type]) jQuery.event.remove(elem, type);
                        else jQuery.removeEvent(elem, type, data.handle);
                    }
                    // Support: Chrome <=35 - 45+
                    // Assign undefined instead of using delete, see Data#remove
                    elem[dataPriv.expando] = undefined;
                }
                if (elem[dataUser.expando]) // Support: Chrome <=35 - 45+
                // Assign undefined instead of using delete, see Data#remove
                elem[dataUser.expando] = undefined;
            }
        }
    });
    jQuery.fn.extend({
        detach: function(selector) {
            return remove(this, selector, true);
        },
        remove: function(selector) {
            return remove(this, selector);
        },
        text: function(value) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) this.textContent = value;
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) this.parentNode.insertBefore(elem, this);
            });
        },
        after: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) this.parentNode.insertBefore(elem, this.nextSibling);
            });
        },
        empty: function() {
            var elem, i = 0;
            for(; (elem = this[i]) != null; i++)if (elem.nodeType === 1) {
                // Prevent memory leaks
                jQuery.cleanData(getAll(elem, false));
                // Remove any remaining nodes
                elem.textContent = "";
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) return elem.innerHTML;
                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                    "",
                    ""
                ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for(; i < l; i++){
                            elem = this[i] || {};
                            // Remove element nodes and prevent memory leaks
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    // If using innerHTML throws an exception, use the fallback method
                    } catch (e) {}
                }
                if (elem) this.empty().append(value);
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var ignored = [];
            // Make the changes, replacing each non-ignored context element with the new content
            return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;
                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) parent.replaceChild(elem, this);
                }
            // Force callback invocation
            }, ignored);
        }
    });
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for(; i <= last; i++){
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                // Support: Android <=4.0 only, PhantomJS 1 only
                // .get() because push.apply(_, arraylike) throws on ancient WebKit
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var rcustomProp = /^--/;
    var getStyles = function(elem) {
        // Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) view = window1;
        return view.getComputedStyle(elem);
    };
    var swap = function(elem, options, callback) {
        var ret, name, old = {};
        // Remember the old values, and insert the new ones
        for(name in options){
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.call(elem);
        // Revert the old values
        for(name in options)elem.style[name] = old[name];
        return ret;
    };
    var rboxStyle = new RegExp(cssExpand.join("|"), "i");
    var whitespace = "[\\x20\\t\\r\\n\\f]";
    var rtrimCSS = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g");
    (function() {
        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {
            // This is a singleton, we need to execute it only once
            if (!div) return;
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);
            var divStyle = window1.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
            // Some styles come back with percentage values, even though they shouldn't
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            // Support: IE 9 - 11 only
            // Detect misreporting of content dimensions for box-sizing:border-box elements
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            // Support: IE 9 only
            // Detect overflow:scroll screwiness (gh-3699)
            // Support: Chrome <=64
            // Don't get tricked when zoom affects offsetWidth (gh-4029)
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            // Nullify the div so it wouldn't be stored in the memory and
            // it will also be a sign that checks already performed
            div = null;
        }
        function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document.createElement("div"), div = document.createElement("div");
        // Finish early in limited (non-browser) environments
        if (!div.style) return;
        // Support: IE <=9 - 11 only
        // Style of cloned element affects source element cloned (trac-8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        jQuery.extend(support, {
            boxSizingReliable: function() {
                computeStyleTests();
                return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
                computeStyleTests();
                return pixelBoxStylesVal;
            },
            pixelPosition: function() {
                computeStyleTests();
                return pixelPositionVal;
            },
            reliableMarginLeft: function() {
                computeStyleTests();
                return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
                computeStyleTests();
                return scrollboxSizeVal;
            },
            // Support: IE 9 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Behavior in IE 9 is more subtle than in newer versions & it passes
            // some versions of this test; make sure not to make it pass there!
            //
            // Support: Firefox 70+
            // Only Firefox includes border widths
            // in computed dimensions. (gh-4529)
            reliableTrDimensions: function() {
                var table, tr, trChild, trStyle;
                if (reliableTrDimensionsVal == null) {
                    table = document.createElement("table");
                    tr = document.createElement("tr");
                    trChild = document.createElement("div");
                    table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                    tr.style.cssText = "border:1px solid";
                    // Support: Chrome 86+
                    // Height set through cssText does not get applied.
                    // Computed height then comes back as 0.
                    tr.style.height = "1px";
                    trChild.style.height = "9px";
                    // Support: Android 8 Chrome 86+
                    // In our bodyBackground.html iframe,
                    // display for all div elements is set to "inline",
                    // which causes a problem only in Android 8 Chrome 86.
                    // Ensuring the div is display: block
                    // gets around this issue.
                    trChild.style.display = "block";
                    documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
                    trStyle = window1.getComputedStyle(tr);
                    reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
                    documentElement.removeChild(table);
                }
                return reliableTrDimensionsVal;
            }
        });
    })();
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), // Support: Firefox 51+
        // Retrieving style before computed somehow
        // fixes an issue with getting wrong values
        // on detached elements
        style = elem.style;
        computed = computed || getStyles(elem);
        // getPropertyValue is needed for:
        //   .css('filter') (IE 9 only, trac-12537)
        //   .css('--customProperty) (gh-3144)
        if (computed) {
            // Support: IE <=9 - 11+
            // IE only supports `"float"` in `getPropertyValue`; in computed styles
            // it's only available as `"cssFloat"`. We no longer modify properties
            // sent to `.css()` apart from camelCasing, so we need to check both.
            // Normally, this would create difference in behavior: if
            // `getPropertyValue` returns an empty string, the value returned
            // by `.css()` would be `undefined`. This is usually the case for
            // disconnected elements. However, in IE even disconnected elements
            // with no styles return `"none"` for `getPropertyValue( "float" )`
            ret = computed.getPropertyValue(name) || computed[name];
            if (isCustomProp && ret) // Support: Firefox 105+, Chrome <=105+
            // Spec requires trimming whitespace for custom properties (gh-4926).
            // Firefox only trims leading whitespace. Chrome just collapses
            // both leading & trailing whitespace to a single space.
            //
            // Fall back to `undefined` if empty string returned.
            // This collapses a missing definition with property defined
            // and set to an empty string but there's no standard API
            // allowing us to differentiate them without a performance penalty
            // and returning `undefined` aligns with older jQuery.
            //
            // rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
            // as whitespace while CSS does not, but this is not a problem
            // because CSS preprocessing replaces them with U+000A LINE FEED
            // (which *is* CSS whitespace)
            // https://www.w3.org/TR/css-syntax-3/#input-preprocessing
            ret = ret.replace(rtrimCSS, "$1") || undefined;
            if (ret === "" && !isAttached(elem)) ret = jQuery.style(elem, name);
            // A tribute to the "awesome hack by Dean Edwards"
            // Android Browser returns percentage for some values,
            // but width seems to be reliably pixels.
            // This is against the CSSOM draft spec:
            // https://drafts.csswg.org/cssom/#resolved-values
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                if (conditionFn()) {
                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }
                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    var cssPrefixes = [
        "Webkit",
        "Moz",
        "ms"
    ], emptyStyle = document.createElement("div").style, vendorProps = {};
    // Return a vendor-prefixed property or undefined
    function vendorPropName(name) {
        // Check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
        while(i--){
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) return name;
        }
    }
    // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
    function finalPropName(name) {
        var final = jQuery.cssProps[name] || vendorProps[name];
        if (final) return final;
        if (name in emptyStyle) return name;
        return vendorProps[name] = vendorPropName(name) || name;
    }
    var // Swappable if display is none or starts with table
    // except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    };
    function setPositiveNumber(_elem, value, subtract) {
        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec(value);
        return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }
    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
        // Adjustment may not be necessary
        if (box === (isBorderBox ? "border" : "content")) return 0;
        for(; i < 4; i += 2){
            // Both box models exclude margin
            if (box === "margin") delta += jQuery.css(elem, box + cssExpand[i], true, styles);
            // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
            if (!isBorderBox) {
                // Add padding
                delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                // For "border" or "margin", add border
                if (box !== "padding") delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                else extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            // If we get here with a border-box (content + padding + border), we're seeking "content" or
            // "padding" or "margin"
            } else {
                // For "content", subtract padding
                if (box === "content") delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                // For "content" or "padding", subtract border
                if (box !== "margin") delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            }
        }
        // Account for positive content-box scroll gutter when requested by providing computedVal
        if (!isBorderBox && computedVal >= 0) // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
        // Assuming integer scroll gutter, subtract the rest and round down
        delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5)) || 0;
        return delta;
    }
    function getWidthOrHeight(elem, dimension, extra) {
        // Start with computed style
        var styles = getStyles(elem), // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
        // Fake content-box until we know it's needed to know the true value.
        boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
        // Support: Firefox <=54
        // Return a confounding non-pixel value or feign ignorance, as appropriate.
        if (rnumnonpx.test(val)) {
            if (!extra) return val;
            val = "auto";
        }
        // Support: IE 9 - 11 only
        // Use offsetWidth/offsetHeight for when box sizing is unreliable.
        // In those cases, the computed value can be trusted to be border-box.
        if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Interestingly, in some cases IE 9 doesn't suffer from this issue.
        !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        val === "auto" || // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
        elem.getClientRects().length) {
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
            // Where available, offsetWidth/offsetHeight approximate border box dimensions.
            // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
            // retrieved value as a content box dimension.
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) val = elem[offsetProp];
        }
        // Normalize "" and auto
        val = parseFloat(val) || 0;
        // Adjust for the element's box model
        return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
        val) + "px";
    }
    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "gridArea": true,
            "gridColumn": true,
            "gridColumnEnd": true,
            "gridColumnStart": true,
            "gridRow": true,
            "gridRowEnd": true,
            "gridRowStart": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},
        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) return;
            // Make sure that we're working with the right name
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            // Make sure that we're working with the right name. We don't
            // want to query the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) name = finalPropName(origName);
            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;
                // Convert "+=" or "-=" to relative numbers (trac-7345)
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);
                    // Fixes bug trac-9237
                    type = "number";
                }
                // Make sure that null and NaN values aren't set (trac-7116)
                if (value == null || value !== value) return;
                // If a number was passed in, add the unit (except for certain CSS properties)
                // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
                // "px" to a few hardcoded values.
                if (type === "number" && !isCustomProp) value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                // background-* props affect original clone's values
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) style[name] = "inherit";
                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    if (isCustomProp) style.setProperty(name, value);
                    else style[name] = value;
                }
            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) return ret;
                // Otherwise just get the value from the style object
                return style[name];
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            // Make sure that we're working with the right name. We don't
            // want to modify the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) name = finalPropName(origName);
            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) val = hooks.get(elem, true, extra);
            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) val = curCSS(elem, name, styles);
            // Convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) val = cssNormalTransform[name];
            // Make numeric if forced or a qualifier was provided and val looks numeric
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        "height",
        "width"
    ], function(_i, dimension) {
        jQuery.cssHooks[dimension] = {
            get: function(elem, computed, extra) {
                if (computed) // Certain elements can have dimension info if we invisibly show them
                // but it must have a current display style that would benefit
                return rdisplayswap.test(jQuery.css(elem, "display")) && // Support: Safari 8+
                // Table columns in Safari have non-zero offsetWidth & zero
                // getBoundingClientRect().width unless display is changed.
                // Support: IE <=11 only
                // Running getBoundingClientRect on a disconnected node
                // in IE throws an error.
                (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                    return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
            },
            set: function(elem, value, extra) {
                var matches, styles = getStyles(elem), // Only read styles.position if the test has a chance to fail
                // to avoid forcing a reflow.
                scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
                boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;
                // Account for unreliable border-box dimensions by comparing offset* to computed and
                // faking a content-box to get border and padding (gh-3699)
                if (isBorderBox && scrollboxSizeBuggy) subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
                // Convert to pixels if value adjustment is needed
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                    elem.style[dimension] = value;
                    value = jQuery.css(elem, dimension);
                }
                return setPositiveNumber(elem, value, subtract);
            }
        };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
        if (computed) return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
            marginLeft: 0
        }, function() {
            return elem.getBoundingClientRect().left;
        })) + "px";
    });
    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0, expanded = {}, // Assumes a single number if not a string
                parts = typeof value === "string" ? value.split(" ") : [
                    value
                ];
                for(; i < 4; i++)expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                return expanded;
            }
        };
        if (prefix !== "margin") jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    });
    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (Array.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for(; i < len; i++)map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            else this.pos = eased = percent;
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) this.options.step.call(this.elem, this.now, this);
            if (hooks && hooks.set) hooks.set(this);
            else Tween.propHooks._default.set(this);
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) return tween.elem[tween.prop];
                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css(tween.elem, tween.prop, "");
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if (jQuery.fx.step[tween.prop]) jQuery.fx.step[tween.prop](tween);
                else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                else tween.elem[tween.prop] = tween.now;
            }
        }
    };
    // Support: IE <=9 only
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) tween.elem[tween.prop] = tween.now;
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    };
    jQuery.fx = Tween.prototype.init;
    // Back compat <1.8 extension point
    jQuery.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
        if (inProgress) {
            if (document.hidden === false && window1.requestAnimationFrame) window1.requestAnimationFrame(schedule);
            else window1.setTimeout(schedule, jQuery.fx.interval);
            jQuery.fx.tick();
        }
    }
    // Animations created synchronously will run synchronously
    function createFxNow() {
        window1.setTimeout(function() {
            fxNow = undefined;
        });
        return fxNow = Date.now();
    }
    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for(; i < 4; i += 2 - includeWidth){
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) attrs.opacity = attrs.width = type;
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
        for(; index < length; index++){
            if (tween = collection[index].call(animation, prop, value)) // We're done with this property
            return tween;
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        // Queue-skipping animations hijack the fx hooks
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) oldfire();
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                // Ensure the complete handler is called before this completes
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) hooks.empty.fire();
                });
            });
        }
        // Detect show/hide animations
        for(prop in props){
            value = props[prop];
            if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    // Pretend to be hidden if this is a "show" and
                    // there is still data from a stopped show/hide
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) hidden = true;
                    else continue;
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }
        // Bail out if this is a no-op like .hide().hide()
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) return;
        // Restrict "overflow" and "display" styles during box animations
        if (isBox && elem.nodeType === 1) {
            // Support: IE <=9 - 11, Edge 12 - 15
            // Record all 3 overflow attributes because IE does not infer the shorthand
            // from identically-valued overflowX and overflowY and Edge just mirrors
            // the overflowX value there.
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            // Identify a display type, preferring old show/hide data over the CSS cascade
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) restoreDisplay = dataPriv.get(elem, "display");
            display = jQuery.css(elem, "display");
            if (display === "none") {
                if (restoreDisplay) display = restoreDisplay;
                else {
                    // Get nonempty value(s) by temporarily forcing visibility
                    showHide([
                        elem
                    ], true);
                    restoreDisplay = elem.style.display || restoreDisplay;
                    display = jQuery.css(elem, "display");
                    showHide([
                        elem
                    ]);
                }
            }
            // Animate inline elements as inline-block
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                if (jQuery.css(elem, "float") === "none") {
                    // Restore the original display value at the end of pure show/hide animations
                    if (!propTween) {
                        anim.done(function() {
                            style.display = restoreDisplay;
                        });
                        if (restoreDisplay == null) {
                            display = style.display;
                            restoreDisplay = display === "none" ? "" : display;
                        }
                    }
                    style.display = "inline-block";
                }
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        // Implement show/hide animations
        propTween = false;
        for(prop in orig){
            // General show/hide setup for this element animation
            if (!propTween) {
                if (dataShow) {
                    if ("hidden" in dataShow) hidden = dataShow.hidden;
                } else dataShow = dataPriv.access(elem, "fxshow", {
                    display: restoreDisplay
                });
                // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                if (toggle) dataShow.hidden = !hidden;
                // Show elements before animating them
                if (hidden) showHide([
                    elem
                ], true);
                /* eslint-disable no-loop-func */ anim.done(function() {
                    /* eslint-enable no-loop-func */ // The final step of a "hide" animation is actually hiding the element
                    if (!hidden) showHide([
                        elem
                    ]);
                    dataPriv.remove(elem, "fxshow");
                    for(prop in orig)jQuery.style(elem, prop, orig[prop]);
                });
            }
            // Per-property setup
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                    propTween.end = propTween.start;
                    propTween.start = 0;
                }
            }
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        // camelCase, specialEasing and expand cssHook pass
        for(index in props){
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for(index in value)if (!(index in props)) {
                    props[index] = value[index];
                    specialEasing[index] = easing;
                }
            } else specialEasing[name] = easing;
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
            // Don't match elem in the :animated selector
            delete tick.elem;
        }), tick = function() {
            if (stopped) return false;
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), // Support: Android 2.3 only
            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
            temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
            for(; index < length; index++)animation.tweens[index].run(percent);
            deferred.notifyWith(elem, [
                animation,
                percent,
                remaining
            ]);
            // If there's more to do, yield
            if (percent < 1 && length) return remaining;
            // If this was an empty animation, synthesize a final progress notification
            if (!length) deferred.notifyWith(elem, [
                animation,
                1,
                0
            ]);
            // Resolve the animation and report its conclusion
            deferred.resolveWith(elem, [
                animation
            ]);
            return false;
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {},
                easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0, // If we are going to the end, we want to run all the tweens
                // otherwise we skip this part
                length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) return this;
                stopped = true;
                for(; index < length; index++)animation.tweens[index].run(1);
                // Resolve when we played the last frame; otherwise, reject
                if (gotoEnd) {
                    deferred.notifyWith(elem, [
                        animation,
                        1,
                        0
                    ]);
                    deferred.resolveWith(elem, [
                        animation,
                        gotoEnd
                    ]);
                } else deferred.rejectWith(elem, [
                    animation,
                    gotoEnd
                ]);
                return this;
            }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for(; index < length; index++){
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (isFunction(result.stop)) jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (isFunction(animation.opts.start)) animation.opts.start.call(elem, animation);
        // Attach callbacks from options
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation;
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            "*": [
                function(prop, value) {
                    var tween = this.createTween(prop, value);
                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                    return tween;
                }
            ]
        },
        tweener: function(props, callback) {
            if (isFunction(props)) {
                callback = props;
                props = [
                    "*"
                ];
            } else props = props.match(rnothtmlwhite);
            var prop, index = 0, length = props.length;
            for(; index < length; index++){
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },
        prefilters: [
            defaultPrefilter
        ],
        prefilter: function(callback, prepend) {
            if (prepend) Animation.prefilters.unshift(callback);
            else Animation.prefilters.push(callback);
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction(easing) && easing
        };
        // Go to the end state if fx are off
        if (jQuery.fx.off) opt.duration = 0;
        else if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery.fx.speeds) opt.duration = jQuery.fx.speeds[opt.duration];
            else opt.duration = jQuery.fx.speeds._default;
        }
        // Normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) opt.queue = "fx";
        // Queueing
        opt.old = opt.complete;
        opt.complete = function() {
            if (isFunction(opt.old)) opt.old.call(this);
            if (opt.queue) jQuery.dequeue(this, opt.queue);
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            // Show any hidden elements after setting opacity to 0
            return this.filter(isHiddenWithinTree).css("opacity", 0).show()// Animate to the value specified
            .end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                // Empty animations, or finishing resolves immediately
                if (empty || dataPriv.get(this, "finish")) anim.stop(true);
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue) this.queue(type || "fx", []);
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) stopQueue(data[index]);
                } else {
                    for(index in data)if (data[index] && data[index].stop && rrun.test(index)) stopQueue(data[index]);
                }
                for(index = timers.length; index--;)if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                    timers[index].anim.stop(gotoEnd);
                    dequeue = false;
                    timers.splice(index, 1);
                }
                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if (dequeue || !gotoEnd) jQuery.dequeue(this, type);
            });
        },
        finish: function(type) {
            if (type !== false) type = type || "fx";
            return this.each(function() {
                var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                // Enable finishing flag on private data
                data.finish = true;
                // Empty the queue first
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) hooks.stop.call(this, true);
                // Look for any active animations, and finish them
                for(index = timers.length; index--;)if (timers[index].elem === this && timers[index].queue === type) {
                    timers[index].anim.stop(true);
                    timers.splice(index, 1);
                }
                // Look for any animations in the old queue and finish them
                for(index = 0; index < length; index++)if (queue[index] && queue[index].finish) queue[index].finish.call(this);
                // Turn off finishing flag
                delete data.finish;
            });
        }
    });
    jQuery.each([
        "toggle",
        "show",
        "hide"
    ], function(_i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = Date.now();
        for(; i < timers.length; i++){
            timer = timers[i];
            // Run the timer and safely remove it when done (allowing for external removal)
            if (!timer() && timers[i] === timer) timers.splice(i--, 1);
        }
        if (!timers.length) jQuery.fx.stop();
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (inProgress) return;
        inProgress = true;
        schedule();
    };
    jQuery.fx.stop = function() {
        inProgress = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
    };
    // Based off of the plugin by Clint Helfers, with permission.
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = window1.setTimeout(next, time);
            hooks.stop = function() {
                window1.clearTimeout(timeout);
            };
        });
    };
    (function() {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox";
        // Support: Android <=4.3 only
        // Default value for a checkbox should be "on"
        support.checkOn = input.value !== "";
        // Support: IE <=11 only
        // Must access selectedIndex to make default options select
        support.optSelected = opt.selected;
        // Support: IE <=11 only
        // An input loses its value after becoming a radio
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            // Don't get/set attributes on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) return;
            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === "undefined") return jQuery.prop(elem, name, value);
            // Attribute hooks are determined by the lowercase version
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) return ret;
                elem.setAttribute(name, value + "");
                return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) return ret;
            ret = jQuery.find.attr(elem, name);
            // Non-existent attributes return null, we normalize to undefined
            return ret == null ? undefined : ret;
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) elem.value = val;
                        return value;
                    }
                }
            }
        },
        removeAttr: function(elem, value) {
            var name, i = 0, // Attribute names can contain non-HTML whitespace characters
            // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
            attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) while(name = attrNames[i++])elem.removeAttribute(name);
        }
    });
    // Hooks for boolean attributes
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) // Remove boolean attributes when set to false
            jQuery.removeAttr(elem, name);
            else elem.setAttribute(name, name);
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle, lowercaseName = name.toLowerCase();
            if (!isXML) {
                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name, isXML) != null ? lowercaseName : null;
                attrHandle[lowercaseName] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            // Don't get/set properties on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) return;
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) return ret;
                return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) return ret;
            return elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    // Support: IE <=9 - 11 only
                    // elem.tabIndex doesn't always return the
                    // correct value when it hasn't been explicitly set
                    // Use proper attribute retrieval (trac-12072)
                    var tabindex = jQuery.find.attr(elem, "tabindex");
                    if (tabindex) return parseInt(tabindex, 10);
                    if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) return 0;
                    return -1;
                }
            }
        },
        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    });
    // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    // eslint rule "no-unused-expressions" is disabled for this code
    // since it considers such accessions noop
    if (!support.optSelected) jQuery.propHooks.selected = {
        get: function(elem) {
            /* eslint no-unused-expressions: "off" */ var parent = elem.parentNode;
            if (parent && parent.parentNode) parent.parentNode.selectedIndex;
            return null;
        },
        set: function(elem) {
            /* eslint no-unused-expressions: "off" */ var parent = elem.parentNode;
            if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) parent.parentNode.selectedIndex;
            }
        }
    };
    jQuery.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    // Strip and collapse whitespace according to HTML spec
    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
    }
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }
    function classesToArray(value) {
        if (Array.isArray(value)) return value;
        if (typeof value === "string") return value.match(rnothtmlwhite) || [];
        return [];
    }
    jQuery.fn.extend({
        addClass: function(value) {
            var classNames, cur, curValue, className, i, finalValue;
            if (isFunction(value)) return this.each(function(j) {
                jQuery(this).addClass(value.call(this, j, getClass(this)));
            });
            classNames = classesToArray(value);
            if (classNames.length) return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                    for(i = 0; i < classNames.length; i++){
                        className = classNames[i];
                        if (cur.indexOf(" " + className + " ") < 0) cur += className + " ";
                    }
                    // Only assign if different to avoid unneeded rendering.
                    finalValue = stripAndCollapse(cur);
                    if (curValue !== finalValue) this.setAttribute("class", finalValue);
                }
            });
            return this;
        },
        removeClass: function(value) {
            var classNames, cur, curValue, className, i, finalValue;
            if (isFunction(value)) return this.each(function(j) {
                jQuery(this).removeClass(value.call(this, j, getClass(this)));
            });
            if (!arguments.length) return this.attr("class", "");
            classNames = classesToArray(value);
            if (classNames.length) return this.each(function() {
                curValue = getClass(this);
                // This expression is here for better compressibility (see addClass)
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                    for(i = 0; i < classNames.length; i++){
                        className = classNames[i];
                        // Remove *all* instances
                        while(cur.indexOf(" " + className + " ") > -1)cur = cur.replace(" " + className + " ", " ");
                    }
                    // Only assign if different to avoid unneeded rendering.
                    finalValue = stripAndCollapse(cur);
                    if (curValue !== finalValue) this.setAttribute("class", finalValue);
                }
            });
            return this;
        },
        toggleClass: function(value, stateVal) {
            var classNames, className, i, self, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (isFunction(value)) return this.each(function(i) {
                jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
            });
            if (typeof stateVal === "boolean" && isValidValue) return stateVal ? this.addClass(value) : this.removeClass(value);
            classNames = classesToArray(value);
            return this.each(function() {
                if (isValidValue) {
                    // Toggle individual class names
                    self = jQuery(this);
                    for(i = 0; i < classNames.length; i++){
                        className = classNames[i];
                        // Check each className given, space separated list
                        if (self.hasClass(className)) self.removeClass(className);
                        else self.addClass(className);
                    }
                // Toggle whole class name
                } else if (value === undefined || type === "boolean") {
                    className = getClass(this);
                    if (className) // Store className if set
                    dataPriv.set(this, "__className__", className);
                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    if (this.setAttribute) this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
                }
            });
        },
        hasClass: function(selector) {
            var className, elem, i = 0;
            className = " " + selector + " ";
            while(elem = this[i++]){
                if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) return true;
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) return ret;
                    ret = elem.value;
                    // Handle most common string cases
                    if (typeof ret === "string") return ret.replace(rreturn, "");
                    // Handle cases where value is null/undef or number
                    return ret == null ? "" : ret;
                }
                return;
            }
            valueIsFunction = isFunction(value);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) return;
                if (valueIsFunction) val = value.call(this, i, jQuery(this).val());
                else val = value;
                // Treat null/undefined as ""; convert numbers to string
                if (val == null) val = "";
                else if (typeof val === "number") val += "";
                else if (Array.isArray(val)) val = jQuery.map(val, function(value) {
                    return value == null ? "" : value + "";
                });
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) this.value = val;
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val : // Support: IE <=10 - 11 only
                    // option.text throws exceptions (trac-14686, trac-14858)
                    // Strip and collapse whitespace
                    // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                    stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
                    if (index < 0) i = max;
                    else i = one ? index : 0;
                    // Loop through all the selected options
                    for(; i < max; i++){
                        option = options[i];
                        // Support: IE <=9 only
                        // IE8-9 doesn't update selected after form reset (trac-2551)
                        if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                        !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                            // Get the specific value for the option
                            value = jQuery(option).val();
                            // We don't need an array for one selects
                            if (one) return value;
                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while(i--){
                        option = options[i];
                        /* eslint-disable no-cond-assign */ if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) optionSet = true;
                    /* eslint-enable no-cond-assign */ }
                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) elem.selectedIndex = -1;
                    return values;
                }
            }
        }
    });
    // Radios and checkboxes getter/setter
    jQuery.each([
        "radio",
        "checkbox"
    ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (Array.isArray(value)) return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
            }
        };
        if (!support.checkOn) jQuery.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
        };
    });
    // Return jQuery for attributes-only inclusion
    support.focusin = "onfocusin" in window1;
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
        e.stopPropagation();
    };
    jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [
                elem || document
            ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document;
            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) return;
            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) return;
            if (type.indexOf(".") > -1) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) event.target = elem;
            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ? [
                event
            ] : jQuery.makeArray(data, [
                event
            ]);
            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) return;
            // Determine event propagation path in advance, per W3C events spec (trac-9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) cur = cur.parentNode;
                for(; cur; cur = cur.parentNode){
                    eventPath.push(cur);
                    tmp = cur;
                }
                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) eventPath.push(tmp.defaultView || tmp.parentWindow || window1);
            }
            // Fire handlers on the event path
            i = 0;
            while((cur = eventPath[i++]) && !event.isPropagationStopped()){
                lastElement = cur;
                event.type = i > 1 ? bubbleType : special.bindType || type;
                // jQuery handler
                handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");
                if (handle) handle.apply(cur, data);
                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) event.preventDefault();
                }
            }
            event.type = type;
            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) // Call a native DOM method on the target with the same name as the event.
                // Don't do default actions on window, that's where global variables be (trac-6170)
                {
                    if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];
                        if (tmp) elem[ontype] = null;
                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        if (event.isPropagationStopped()) lastElement.addEventListener(type, stopPropagationCallback);
                        elem[type]();
                        if (event.isPropagationStopped()) lastElement.removeEventListener(type, stopPropagationCallback);
                        jQuery.event.triggered = undefined;
                        if (tmp) elem[ontype] = tmp;
                    }
                }
            }
            return event.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function(type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });
            jQuery.event.trigger(e, null, elem);
        }
    });
    jQuery.fn.extend({
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) return jQuery.event.trigger(type, data, elem, true);
        }
    });
    // Support: Firefox <=44
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
    if (!support.focusin) jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(orig, fix) {
        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };
        jQuery.event.special[fix] = {
            setup: function() {
                // Handle: regular nodes (via `this.ownerDocument`), window
                // (via `this.document`) & document (via `this`).
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix);
                if (!attaches) doc.addEventListener(orig, handler, true);
                dataPriv.access(doc, fix, (attaches || 0) + 1);
            },
            teardown: function() {
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix) - 1;
                if (!attaches) {
                    doc.removeEventListener(orig, handler, true);
                    dataPriv.remove(doc, fix);
                } else dataPriv.access(doc, fix, attaches);
            }
        };
    });
    var location = window1.location;
    var nonce = {
        guid: Date.now()
    };
    var rquery = /\?/;
    // Cross-browser xml parsing
    jQuery.parseXML = function(data) {
        var xml, parserErrorElem;
        if (!data || typeof data !== "string") return null;
        // Support: IE 9 - 11 only
        // IE throws on parseFromString with invalid input.
        try {
            xml = new window1.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {}
        parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
        if (!xml || parserErrorElem) jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
            return el.textContent;
        }).join("\n") : data));
        return xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (Array.isArray(obj)) // Serialize array item.
        jQuery.each(obj, function(i, v) {
            if (traditional || rbracket.test(prefix)) // Treat each array item as a scalar.
            add(prefix, v);
            else // Item is non-scalar (array or object), encode its numeric index.
            buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        });
        else if (!traditional && toType(obj) === "object") // Serialize object item.
        for(name in obj)buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
        else // Serialize scalar item.
        add(prefix, obj);
    }
    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, valueOrFunction) {
            // If value is a function, invoke it and use its return value
            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
        if (a == null) return "";
        // If an array was passed in, assume that it is an array of form elements.
        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) // Serialize the form elements
        jQuery.each(a, function() {
            add(this.name, this.value);
        });
        else // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for(prefix in a)buildParams(prefix, a[prefix], traditional, add);
        // Return the resulting serialization
        return s.join("&");
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                // Use .is( ":disabled" ) so that fieldset[disabled] works
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i, elem) {
                var val = jQuery(this).val();
                if (val == null) return null;
                if (Array.isArray(val)) return jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                });
                return {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, // trac-7653, trac-8125, trac-8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */ prefilters = {}, /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */ transports = {}, // Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
    allTypes = "*/".concat("*"), // Anchor tag for parsing the document origin
    originAnchor = document.createElement("a");
    originAnchor.href = location.href;
    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {
        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction(func)) {
                // For each dataType in the dataTypeExpression
                while(dataType = dataTypes[i++])// Prepend if requested
                if (dataType[0] === "+") {
                    dataType = dataType.slice(1) || "*";
                    (structure[dataType] = structure[dataType] || []).unshift(func);
                // Otherwise append
                } else (structure[dataType] = structure[dataType] || []).push(func);
            }
        };
    }
    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) return !(selected = dataTypeOrTransport);
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes trac-9887
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for(key in src)if (src[key] !== undefined) (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
        if (deep) jQuery.extend(true, target, deep);
        return target;
    }
    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */ function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        // Remove auto dataType and get content-type in the process
        while(dataTypes[0] === "*"){
            dataTypes.shift();
            if (ct === undefined) ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
        // Check if we're dealing with a known content-type
        if (ct) {
            for(type in contents)if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
            }
        }
        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) finalDataType = dataTypes[0];
        else {
            // Try convertible dataTypes
            for(type in responses){
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) firstDataType = type;
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }
        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) dataTypes.unshift(finalDataType);
            return responses[finalDataType];
        }
    }
    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */ function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();
        // Create converters map with lowercased keys
        if (dataTypes[1]) for(conv in s.converters)converters[conv.toLowerCase()] = s.converters[conv];
        current = dataTypes.shift();
        // Convert to each sequential dataType
        while(current){
            if (s.responseFields[current]) jqXHR[s.responseFields[current]] = response;
            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) response = s.dataFilter(response, s.dataType);
            prev = current;
            current = dataTypes.shift();
            if (current) {
                // There's only work to do if current dataType is non-auto
                if (current === "*") current = prev;
                else if (prev !== "*" && prev !== current) {
                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];
                    // If none found, seek a pair
                    if (!conv) for(conv2 in converters){
                        // If conv2 outputs current
                        tmp = conv2.split(" ");
                        if (tmp[1] === current) {
                            // If prev can be converted to accepted input
                            conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                            if (conv) {
                                // Condense equivalence converters
                                if (conv === true) conv = converters[conv2];
                                else if (converters[conv2] !== true) {
                                    current = tmp[0];
                                    dataTypes.unshift(tmp[1]);
                                }
                                break;
                            }
                        }
                    }
                    // Apply converter (if not an equivalence)
                    if (conv !== true) {
                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s.throws) response = conv(response);
                        else try {
                            response = conv(response);
                        } catch (e) {
                            return {
                                state: "parsererror",
                                error: conv ? e : "No conversion from " + prev + " to " + current
                            };
                        }
                    }
                }
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    jQuery.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/ accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
                // Convert anything to text
                "* text": String,
                // Text to html (true = no transformation)
                "text html": true,
                // Evaluate text as a json expression
                "text json": JSON.parse,
                // Parse text as xml
                "text xml": jQuery.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
            return settings ? // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
            ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url, options) {
            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            // Force options to be an object
            options = options || {};
            var transport, // URL without anti-cache param
            cacheURL, // Response headers
            responseHeadersString, responseHeaders, // timeout handle
            timeoutTimer, // Url cleanup var
            urlAnchor, // Request state (becomes false upon send and true upon completion)
            completed, // To know if global events are to be dispatched
            fireGlobals, // Loop variable
            i, // uncached part of the url
            uncached, // Create the final options object
            s = jQuery.ajaxSetup({}, options), // Callbacks context
            callbackContext = s.context || s, // Context for global events is callbackContext if it is a DOM node or jQuery collection
            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, // Deferreds
            deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), // Status-dependent callbacks
            statusCode = s.statusCode || {}, // Headers (they are sent all at once)
            requestHeaders = {}, requestHeadersNames = {}, // Default abort message
            strAbort = "canceled", // Fake xhr
            jqXHR = {
                readyState: 0,
                // Builds headers hashtable if needed
                getResponseHeader: function(key) {
                    var match;
                    if (completed) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while(match = rheaders.exec(responseHeadersString))responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                        }
                        match = responseHeaders[key.toLowerCase() + " "];
                    }
                    return match == null ? null : match.join(", ");
                },
                // Raw string
                getAllResponseHeaders: function() {
                    return completed ? responseHeadersString : null;
                },
                // Caches the header
                setRequestHeader: function(name, value) {
                    if (completed == null) {
                        name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },
                // Overrides response content-type header
                overrideMimeType: function(type) {
                    if (completed == null) s.mimeType = type;
                    return this;
                },
                // Status-dependent callbacks
                statusCode: function(map) {
                    var code;
                    if (map) {
                        if (completed) // Execute the appropriate callbacks
                        jqXHR.always(map[jqXHR.status]);
                        else // Lazy-add the new callbacks in a way that preserves old ones
                        for(code in map)statusCode[code] = [
                            statusCode[code],
                            map[code]
                        ];
                    }
                    return this;
                },
                // Cancel the request
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) transport.abort(finalText);
                    done(0, finalText);
                    return this;
                }
            };
            // Attach deferreds
            deferred.promise(jqXHR);
            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (trac-10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
            // Alias method option to type as per ticket trac-12004
            s.type = options.method || options.type || s.method || s.type;
            // Extract dataTypes list
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [
                ""
            ];
            // A cross-domain request is in order when the origin doesn't match the current origin.
            if (s.crossDomain == null) {
                urlAnchor = document.createElement("a");
                // Support: IE <=8 - 11, Edge 12 - 15
                // IE throws exception on accessing the href property if url is malformed,
                // e.g. http://example.com:80x/
                try {
                    urlAnchor.href = s.url;
                    // Support: IE <=8 - 11 only
                    // Anchor's host property isn't correctly set when s.url is relative
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {
                    // If there is an error parsing the URL, assume it is crossDomain,
                    // it can be rejected by the transport if it is invalid
                    s.crossDomain = true;
                }
            }
            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") s.data = jQuery.param(s.data, s.traditional);
            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            // If request was aborted inside a prefilter, stop there
            if (completed) return jqXHR;
            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
            fireGlobals = jQuery.event && s.global;
            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) jQuery.event.trigger("ajaxStart");
            // Uppercase the type
            s.type = s.type.toUpperCase();
            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);
            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            // Remove hash to simplify url manipulation
            cacheURL = s.url.replace(rhash, "");
            // More options handling for requests with no content
            if (!s.hasContent) {
                // Remember the hash so we can put it back
                uncached = s.url.slice(cacheURL.length);
                // If data is available and should be processed, append data to url
                if (s.data && (s.processData || typeof s.data === "string")) {
                    cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                    // trac-9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }
                // Add or update anti-cache param if needed
                if (s.cache === false) {
                    cacheURL = cacheURL.replace(rantiCache, "$1");
                    uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
                }
                // Put hash and anti-cache on the URL that will be requested (gh-1732)
                s.url = cacheURL + uncached;
            // Change '%20' to '+' if this is encoded form body content (gh-2658)
            } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) s.data = s.data.replace(r20, "+");
            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                if (jQuery.etag[cacheURL]) jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
            }
            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) jqXHR.setRequestHeader("Content-Type", s.contentType);
            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            // Check for headers option
            for(i in s.headers)jqXHR.setRequestHeader(i, s.headers[i]);
            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) // Abort if not done already and return
            return jqXHR.abort();
            // Aborting is no longer a cancellation
            strAbort = "abort";
            // Install callbacks on deferreds
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            // If no transport, we auto-abort
            if (!transport) done(-1, "No Transport");
            else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) globalEventContext.trigger("ajaxSend", [
                    jqXHR,
                    s
                ]);
                // If request was aborted inside ajaxSend, stop there
                if (completed) return jqXHR;
                // Timeout
                if (s.async && s.timeout > 0) timeoutTimer = window1.setTimeout(function() {
                    jqXHR.abort("timeout");
                }, s.timeout);
                try {
                    completed = false;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Rethrow post-completion exceptions
                    if (completed) throw e;
                    // Propagate others as results
                    done(-1, e);
                }
            }
            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                // Ignore repeat invocations
                if (completed) return;
                completed = true;
                // Clear timeout if it exists
                if (timeoutTimer) window1.clearTimeout(timeoutTimer);
                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;
                // Cache response headers
                responseHeadersString = headers || "";
                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;
                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;
                // Get response data
                if (responses) response = ajaxHandleResponses(s, jqXHR, responses);
                // Use a noop converter for missing script but not if jsonp
                if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) s.converters["text script"] = function() {};
                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                // If successful, handle type chaining
                if (isSuccess) {
                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) jQuery.lastModified[cacheURL] = modified;
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) jQuery.etag[cacheURL] = modified;
                    }
                    // if no content
                    if (status === 204 || s.type === "HEAD") statusText = "nocontent";
                    else if (status === 304) statusText = "notmodified";
                    else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) status = 0;
                    }
                }
                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                // Success/Error
                if (isSuccess) deferred.resolveWith(callbackContext, [
                    success,
                    statusText,
                    jqXHR
                ]);
                else deferred.rejectWith(callbackContext, [
                    jqXHR,
                    statusText,
                    error
                ]);
                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [
                    jqXHR,
                    s,
                    isSuccess ? success : error
                ]);
                // Complete
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [
                        jqXHR,
                        s
                    ]);
                    // Handle the global AJAX counter
                    if (!--jQuery.active) jQuery.event.trigger("ajaxStop");
                }
            }
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });
    jQuery.each([
        "get",
        "post"
    ], function(_i, method) {
        jQuery[method] = function(url, data, callback, type) {
            // Shift arguments if data argument was omitted
            if (isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            // The url can be an options object (which then must have .url)
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });
    jQuery.ajaxPrefilter(function(s) {
        var i;
        for(i in s.headers)if (i.toLowerCase() === "content-type") s.contentType = s.headers[i] || "";
    });
    jQuery._evalUrl = function(url, options, doc) {
        return jQuery.ajax({
            url: url,
            // Make this explicit, since user can override this through ajaxSetup (trac-11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
                "text script": function() {}
            },
            dataFilter: function(response) {
                jQuery.globalEval(response, options, doc);
            }
        });
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            if (this[0]) {
                if (isFunction(html)) html = html.call(this[0]);
                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) wrap.insertBefore(this[0]);
                wrap.map(function() {
                    var elem = this;
                    while(elem.firstElementChild)elem = elem.firstElementChild;
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (isFunction(html)) return this.each(function(i) {
                jQuery(this).wrapInner(html.call(this, i));
            });
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) contents.wrapAll(html);
                else self.append(html);
            });
        },
        wrap: function(html) {
            var htmlIsFunction = isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
                jQuery(this).replaceWith(this.childNodes);
            });
            return this;
        }
    });
    jQuery.expr.pseudos.hidden = function(elem) {
        return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new window1.XMLHttpRequest();
        } catch (e) {}
    };
    var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // trac-1450: sometimes IE returns 1223 when it should be 204
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        // Cross domain only allowed if supported through XMLHttpRequest
        if (support.cors || xhrSupported && !options.crossDomain) return {
            send: function(headers, complete) {
                var i, xhr = options.xhr();
                xhr.open(options.type, options.url, options.async, options.username, options.password);
                // Apply custom fields if provided
                if (options.xhrFields) for(i in options.xhrFields)xhr[i] = options.xhrFields[i];
                // Override mime type if needed
                if (options.mimeType && xhr.overrideMimeType) xhr.overrideMimeType(options.mimeType);
                // X-Requested-With header
                // For cross-domain requests, seeing as conditions for a preflight are
                // akin to a jigsaw puzzle, we simply never set it to be sure.
                // (it can always be set on a per-request basis or even using ajaxSetup)
                // For same-domain requests, won't change header if already provided.
                if (!options.crossDomain && !headers["X-Requested-With"]) headers["X-Requested-With"] = "XMLHttpRequest";
                // Set headers
                for(i in headers)xhr.setRequestHeader(i, headers[i]);
                // Callback
                callback = function(type) {
                    return function() {
                        if (callback) {
                            callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                            if (type === "abort") xhr.abort();
                            else if (type === "error") {
                                // Support: IE <=9 only
                                // On a manual native abort, IE9 throws
                                // errors on any property access that is not readyState
                                if (typeof xhr.status !== "number") complete(0, "error");
                                else complete(// File: protocol always yields status 0; see trac-8605, trac-14207
                                xhr.status, xhr.statusText);
                            } else complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                            // IE9 has no XHR2 but throws on binary (trac-11426)
                            // For XHR2 non-text, let the caller handle it (gh-2498)
                            (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                                binary: xhr.response
                            } : {
                                text: xhr.responseText
                            }, xhr.getAllResponseHeaders());
                        }
                    };
                };
                // Listen to events
                xhr.onload = callback();
                errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                // Support: IE 9 only
                // Use onreadystatechange to replace onabort
                // to handle uncaught aborts
                if (xhr.onabort !== undefined) xhr.onabort = errorCallback;
                else xhr.onreadystatechange = function() {
                    // Check readyState before timeout as it changes
                    if (xhr.readyState === 4) // Allow onerror to be called first,
                    // but that will not handle a native abort
                    // Also, save errorCallback to a variable
                    // as xhr.onerror cannot be accessed
                    window1.setTimeout(function() {
                        if (callback) errorCallback();
                    });
                };
                // Create the abort callback
                callback = callback("abort");
                try {
                    // Do send the request (this may raise an exception)
                    xhr.send(options.hasContent && options.data || null);
                } catch (e) {
                    // trac-14683: Only rethrow if this hasn't been notified as an error yet
                    if (callback) throw e;
                }
            },
            abort: function() {
                if (callback) callback();
            }
        };
    });
    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
    jQuery.ajaxPrefilter(function(s) {
        if (s.crossDomain) s.contents.script = false;
    });
    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) s.cache = false;
        if (s.crossDomain) s.type = "GET";
    });
    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function(s) {
        // This transport only deals with cross domain or forced-by-attrs requests
        if (s.crossDomain || s.scriptAttrs) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) complete(evt.type === "error" ? 404 : 200, evt.type);
                    });
                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    document.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) callback();
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
            this[callback] = true;
            return callback;
        }
    });
    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            // Insert callback into url or form data
            if (jsonProp) s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            else if (s.jsonp !== false) s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if (!responseContainer) jQuery.error(callbackName + " was not called");
                return responseContainer[0];
            };
            // Force json dataType
            s.dataTypes[0] = "json";
            // Install callback
            overwritten = window1[callbackName];
            window1[callbackName] = function() {
                responseContainer = arguments;
            };
            // Clean-up function (fires after converters)
            jqXHR.always(function() {
                // If previous value didn't exist - remove it
                if (overwritten === undefined) jQuery(window1).removeProp(callbackName);
                else window1[callbackName] = overwritten;
                // Save back as free
                if (s[callbackName]) {
                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    // Save the callback name for future use
                    oldCallbacks.push(callbackName);
                }
                // Call if it was a function and we have a response
                if (responseContainer && isFunction(overwritten)) overwritten(responseContainer[0]);
                responseContainer = overwritten = undefined;
            });
            // Delegate to script
            return "script";
        }
    });
    // Support: Safari 8 only
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337
    support.createHTMLDocument = function() {
        var body = document.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
    }();
    // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (typeof data !== "string") return [];
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        var base, parsed, scripts;
        if (!context) {
            // Stop scripts or inline event handlers from being executed immediately
            // by using document.implementation
            if (support.createHTMLDocument) {
                context = document.implementation.createHTMLDocument("");
                // Set the base href for the created document
                // so any parsed elements with URLs
                // are based on the document's URL (gh-2965)
                base = context.createElement("base");
                base.href = document.location.href;
                context.head.appendChild(base);
            } else context = document;
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        // Single tag
        if (parsed) return [
            context.createElement(parsed[1])
        ];
        parsed = buildFragment([
            data
        ], context, scripts);
        if (scripts && scripts.length) jQuery(scripts).remove();
        return jQuery.merge([], parsed.childNodes);
    };
    /**
 * Load a url into a page
 */ jQuery.fn.load = function(url, params, callback) {
        var selector, type, response, self = this, off = url.indexOf(" ");
        if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
        }
        // If it's a function
        if (isFunction(params)) {
            // We assume that it's the callback
            callback = params;
            params = undefined;
        // Otherwise, build a param string
        } else if (params && typeof params === "object") type = "POST";
        // If we have elements to modify, make the request
        if (self.length > 0) jQuery.ajax({
            url: url,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type || "GET",
            dataType: "html",
            data: params
        }).done(function(responseText) {
            // Save response for use in complete callback
            response = arguments;
            self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
            // Exclude scripts to avoid IE 'Permission Denied' errors
            jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
            responseText);
        // If the request succeeds, this function gets "data", "status", "jqXHR"
        // but they are ignored because response was set above.
        // If it fails, this function gets "jqXHR", "status", "error"
        }).always(callback && function(jqXHR, status) {
            self.each(function() {
                callback.apply(this, response || [
                    jqXHR.responseText,
                    status,
                    jqXHR
                ]);
            });
        });
        return this;
    };
    jQuery.expr.pseudos.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            // Set position first, in-case top/left are set even on static elem
            if (position === "static") elem.style.position = "relative";
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction(options)) // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
            options = options.call(elem, i, jQuery.extend({}, curOffset));
            if (options.top != null) props.top = options.top - curOffset.top + curTop;
            if (options.left != null) props.left = options.left - curOffset.left + curLeft;
            if ("using" in options) options.using.call(elem, props);
            else curElem.css(props);
        }
    };
    jQuery.fn.extend({
        // offset() relates an element's border box to the document origin
        offset: function(options) {
            // Preserve chaining for setter
            if (arguments.length) return options === undefined ? this : this.each(function(i) {
                jQuery.offset.setOffset(this, options, i);
            });
            var rect, win, elem = this[0];
            if (!elem) return;
            // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
            // Support: IE <=11 only
            // Running getBoundingClientRect on a
            // disconnected node in IE throws an error
            if (!elem.getClientRects().length) return {
                top: 0,
                left: 0
            };
            // Get document-relative position by adding viewport scroll to viewport-relative gBCR
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
            };
        },
        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function() {
            if (!this[0]) return;
            var offsetParent, offset, doc, elem = this[0], parentOffset = {
                top: 0,
                left: 0
            };
            // position:fixed elements are offset from the viewport, which itself always has zero offset
            if (jQuery.css(elem, "position") === "fixed") // Assume position:fixed implies availability of getBoundingClientRect
            offset = elem.getBoundingClientRect();
            else {
                offset = this.offset();
                // Account for the *real* offset parent, which can be the document or its root element
                // when a statically positioned element is identified
                doc = elem.ownerDocument;
                offsetParent = elem.offsetParent || doc.documentElement;
                while(offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static")offsetParent = offsetParent.parentNode;
                if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                    // Incorporate borders into its offset, since they are outside its content origin
                    parentOffset = jQuery(offsetParent).offset();
                    parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
                    parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
                }
            }
            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent;
                while(offsetParent && jQuery.css(offsetParent, "position") === "static")offsetParent = offsetParent.offsetParent;
                return offsetParent || documentElement;
            });
        }
    });
    // Create scrollLeft and scrollTop methods
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                // Coalesce documents and windows
                var win;
                if (isWindow(elem)) win = elem;
                else if (elem.nodeType === 9) win = elem.defaultView;
                if (val === undefined) return win ? win[prop] : elem[method];
                if (win) win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                else elem[method] = val;
            }, method, val, arguments.length);
        };
    });
    // Support: Safari <=7 - 9.1, Chrome <=37 - 49
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each([
        "top",
        "left"
    ], function(_i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                // If curCSS returns percentage, fallback to offset
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });
    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            // Margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (isWindow(elem)) // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                    return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                    // Get document width or height
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                        // whichever is greatest
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery.css(elem, type, extra) : // Set width or height on the element
                    jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable);
            };
        });
    });
    jQuery.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function(_i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });
    jQuery.fn.extend({
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });
    jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(_i, name) {
        // Handle event binding
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP
    // Require that the "whitespace run" starts from a non-whitespace
    // to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
    var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
    // Bind a function to a context, optionally partially applying any
    // arguments.
    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
    // However, it is not slated for removal any time soon
    jQuery.proxy = function(fn, context) {
        var tmp, args, proxy;
        if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
        }
        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if (!isFunction(fn)) return undefined;
        // Simulated bind
        args = slice.call(arguments, 2);
        proxy = function() {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
        };
        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
        return proxy;
    };
    jQuery.holdReady = function(hold) {
        if (hold) jQuery.readyWait++;
        else jQuery.ready(true);
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;
    jQuery.now = Date.now;
    jQuery.isNumeric = function(obj) {
        // As of jQuery 3.0, isNumeric is limited to
        // strings and numbers (primitives or objects)
        // that can be coerced to finite numbers (gh-2662)
        var type = jQuery.type(obj);
        return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
    };
    jQuery.trim = function(text) {
        return text == null ? "" : (text + "").replace(rtrim, "$1");
    };
    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.
    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
    if (typeof define === "function" && define.amd) define("jquery", [], function() {
        return jQuery;
    });
    var // Map over jQuery in case of overwrite
    _jQuery = window1.jQuery, // Map over the $ in case of overwrite
    _$ = window1.$;
    jQuery.noConflict = function(deep) {
        if (window1.$ === jQuery) window1.$ = _$;
        if (deep && window1.jQuery === jQuery) window1.jQuery = _jQuery;
        return jQuery;
    };
    // Expose jQuery and $ identifiers, even in AMD
    // (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (trac-13566)
    if (typeof noGlobal === "undefined") window1.jQuery = window1.$ = jQuery;
    return jQuery;
});

},{}],"5j2Qt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addClassNamePrefix", ()=>addClassNamePrefix);
parcelHelpers.export(exports, "removeClassNamePrefix", ()=>removeClassNamePrefix);
parcelHelpers.export(exports, "parseDOMJSON", ()=>parseDOMJSON);
parcelHelpers.export(exports, "hashCode", ()=>hashCode);
parcelHelpers.export(exports, "getByPath", ()=>getByPath);
parcelHelpers.export(exports, "setByPath", ()=>setByPath);
parcelHelpers.export(exports, "unsetByPath", ()=>unsetByPath);
parcelHelpers.export(exports, "flattenObject", ()=>flattenObject);
parcelHelpers.export(exports, "uuid", ()=>uuid);
parcelHelpers.export(exports, "guid", ()=>guid);
parcelHelpers.export(exports, "toKebabCase", ()=>toKebabCase);
parcelHelpers.export(exports, "normalizeEvent", ()=>normalizeEvent);
parcelHelpers.export(exports, "normalizeWheel", ()=>normalizeWheel);
parcelHelpers.export(exports, "cap", ()=>cap);
parcelHelpers.export(exports, "nextFrame", ()=>nextFrame);
parcelHelpers.export(exports, "cancelFrame", ()=>cancelFrame);
parcelHelpers.export(exports, "shapePerimeterConnectionPoint", ()=>shapePerimeterConnectionPoint);
parcelHelpers.export(exports, "isPercentage", ()=>isPercentage);
parcelHelpers.export(exports, "parseCssNumeric", ()=>parseCssNumeric);
parcelHelpers.export(exports, "breakText", ()=>breakText);
parcelHelpers.export(exports, "sanitizeHTML", ()=>sanitizeHTML);
parcelHelpers.export(exports, "downloadBlob", ()=>downloadBlob);
parcelHelpers.export(exports, "downloadDataUri", ()=>downloadDataUri);
parcelHelpers.export(exports, "dataUriToBlob", ()=>dataUriToBlob);
parcelHelpers.export(exports, "imageToDataUri", ()=>imageToDataUri);
parcelHelpers.export(exports, "getElementBBox", ()=>getElementBBox);
parcelHelpers.export(exports, "sortElements", ()=>sortElements);
parcelHelpers.export(exports, "setAttributesBySelector", ()=>setAttributesBySelector);
parcelHelpers.export(exports, "normalizeSides", ()=>normalizeSides);
parcelHelpers.export(exports, "timing", ()=>timing);
parcelHelpers.export(exports, "interpolate", ()=>interpolate);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "format", ()=>format);
parcelHelpers.export(exports, "template", ()=>template);
parcelHelpers.export(exports, "toggleFullScreen", ()=>toggleFullScreen);
parcelHelpers.export(exports, "isBoolean", ()=>(0, _utilHelpersMjs.isBoolean));
parcelHelpers.export(exports, "isObject", ()=>(0, _utilHelpersMjs.isObject));
parcelHelpers.export(exports, "isNumber", ()=>(0, _utilHelpersMjs.isNumber));
parcelHelpers.export(exports, "isString", ()=>(0, _utilHelpersMjs.isString));
parcelHelpers.export(exports, "mixin", ()=>(0, _utilHelpersMjs.mixin));
parcelHelpers.export(exports, "deepMixin", ()=>(0, _utilHelpersMjs.deepMixin));
parcelHelpers.export(exports, "supplement", ()=>(0, _utilHelpersMjs.supplement));
parcelHelpers.export(exports, "defaults", ()=>(0, _utilHelpersMjs.defaults));
parcelHelpers.export(exports, "deepSupplement", ()=>(0, _utilHelpersMjs.deepSupplement));
parcelHelpers.export(exports, "defaultsDeep", ()=>(0, _utilHelpersMjs.defaultsDeep));
parcelHelpers.export(exports, "assign", ()=>(0, _utilHelpersMjs.assign));
parcelHelpers.export(exports, "invoke", ()=>(0, _utilHelpersMjs.invoke));
parcelHelpers.export(exports, "invokeProperty", ()=>(0, _utilHelpersMjs.invokeProperty));
parcelHelpers.export(exports, "sortedIndex", ()=>(0, _utilHelpersMjs.sortedIndex));
parcelHelpers.export(exports, "uniq", ()=>(0, _utilHelpersMjs.uniq));
parcelHelpers.export(exports, "clone", ()=>(0, _utilHelpersMjs.clone));
parcelHelpers.export(exports, "cloneDeep", ()=>(0, _utilHelpersMjs.cloneDeep));
parcelHelpers.export(exports, "isEmpty", ()=>(0, _utilHelpersMjs.isEmpty));
parcelHelpers.export(exports, "isEqual", ()=>(0, _utilHelpersMjs.isEqual));
parcelHelpers.export(exports, "isFunction", ()=>(0, _utilHelpersMjs.isFunction));
parcelHelpers.export(exports, "isPlainObject", ()=>(0, _utilHelpersMjs.isPlainObject));
parcelHelpers.export(exports, "toArray", ()=>(0, _utilHelpersMjs.toArray));
parcelHelpers.export(exports, "debounce", ()=>(0, _utilHelpersMjs.debounce));
parcelHelpers.export(exports, "groupBy", ()=>(0, _utilHelpersMjs.groupBy));
parcelHelpers.export(exports, "sortBy", ()=>(0, _utilHelpersMjs.sortBy));
parcelHelpers.export(exports, "flattenDeep", ()=>(0, _utilHelpersMjs.flattenDeep));
parcelHelpers.export(exports, "without", ()=>(0, _utilHelpersMjs.without));
parcelHelpers.export(exports, "difference", ()=>(0, _utilHelpersMjs.difference));
parcelHelpers.export(exports, "intersection", ()=>(0, _utilHelpersMjs.intersection));
parcelHelpers.export(exports, "union", ()=>(0, _utilHelpersMjs.union));
parcelHelpers.export(exports, "has", ()=>(0, _utilHelpersMjs.has));
parcelHelpers.export(exports, "result", ()=>(0, _utilHelpersMjs.result));
parcelHelpers.export(exports, "omit", ()=>(0, _utilHelpersMjs.omit));
parcelHelpers.export(exports, "pick", ()=>(0, _utilHelpersMjs.pick));
parcelHelpers.export(exports, "bindAll", ()=>(0, _utilHelpersMjs.bindAll));
parcelHelpers.export(exports, "forIn", ()=>(0, _utilHelpersMjs.forIn));
parcelHelpers.export(exports, "camelCase", ()=>(0, _utilHelpersMjs.camelCase));
parcelHelpers.export(exports, "uniqueId", ()=>(0, _utilHelpersMjs.uniqueId));
parcelHelpers.export(exports, "merge", ()=>(0, _utilHelpersMjs.merge));
parcelHelpers.export(exports, "noop", ()=>noop);
var _jquery = require("jquery");
var _jqueryDefault = parcelHelpers.interopDefault(_jquery);
var _indexMjs = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _indexMjs1 = require("../config/index.mjs");
var _utilHelpersMjs = require("./utilHelpers.mjs");
const addClassNamePrefix = function(className) {
    if (!className) return className;
    return className.toString().split(" ").map(function(_className) {
        if (_className.substr(0, (0, _indexMjs1.config).classNamePrefix.length) !== (0, _indexMjs1.config).classNamePrefix) _className = (0, _indexMjs1.config).classNamePrefix + _className;
        return _className;
    }).join(" ");
};
const removeClassNamePrefix = function(className) {
    if (!className) return className;
    return className.toString().split(" ").map(function(_className) {
        if (_className.substr(0, (0, _indexMjs1.config).classNamePrefix.length) === (0, _indexMjs1.config).classNamePrefix) _className = _className.substr((0, _indexMjs1.config).classNamePrefix.length);
        return _className;
    }).join(" ");
};
const parseDOMJSON = function(json, namespace) {
    const selectors = {};
    const groupSelectors = {};
    const svgNamespace = (0, _indexMjsDefault.default).namespace.svg;
    const ns = namespace || svgNamespace;
    const fragment = document.createDocumentFragment();
    const parseNode = function(siblingsDef, parentNode, ns) {
        for(let i = 0; i < siblingsDef.length; i++){
            const nodeDef = siblingsDef[i];
            // Text node
            if (typeof nodeDef === "string") {
                const textNode = document.createTextNode(nodeDef);
                parentNode.appendChild(textNode);
                continue;
            }
            // TagName
            if (!nodeDef.hasOwnProperty("tagName")) throw new Error("json-dom-parser: missing tagName");
            const tagName = nodeDef.tagName;
            let node;
            // Namespace URI
            if (nodeDef.hasOwnProperty("namespaceURI")) ns = nodeDef.namespaceURI;
            node = document.createElementNS(ns, tagName);
            const svg = ns === svgNamespace;
            const wrapper = svg ? (0, _indexMjsDefault.default) : (0, _jqueryDefault.default);
            // Attributes
            const attributes = nodeDef.attributes;
            if (attributes) wrapper(node).attr(attributes);
            // Style
            const style = nodeDef.style;
            if (style) (0, _jqueryDefault.default)(node).css(style);
            // ClassName
            if (nodeDef.hasOwnProperty("className")) {
                const className = nodeDef.className;
                if (svg) node.className.baseVal = className;
                else node.className = className;
            }
            // TextContent
            if (nodeDef.hasOwnProperty("textContent")) node.textContent = nodeDef.textContent;
            // Selector
            if (nodeDef.hasOwnProperty("selector")) {
                const nodeSelector = nodeDef.selector;
                if (selectors[nodeSelector]) throw new Error("json-dom-parser: selector must be unique");
                selectors[nodeSelector] = node;
                wrapper(node).attr("joint-selector", nodeSelector);
            }
            // Groups
            if (nodeDef.hasOwnProperty("groupSelector")) {
                let nodeGroups = nodeDef.groupSelector;
                if (!Array.isArray(nodeGroups)) nodeGroups = [
                    nodeGroups
                ];
                for(let j = 0; j < nodeGroups.length; j++){
                    const nodeGroup = nodeGroups[j];
                    let group = groupSelectors[nodeGroup];
                    if (!group) group = groupSelectors[nodeGroup] = [];
                    group.push(node);
                }
            }
            parentNode.appendChild(node);
            // Children
            const childrenDef = nodeDef.children;
            if (Array.isArray(childrenDef)) parseNode(childrenDef, node, ns);
        }
    };
    parseNode(json, fragment, ns);
    return {
        fragment: fragment,
        selectors: selectors,
        groupSelectors: groupSelectors
    };
};
const hashCode = function(str) {
    let hash = 0;
    if (str.length === 0) return hash;
    for(let i = 0; i < str.length; i++){
        const c = str.charCodeAt(i);
        hash = (hash << 5) - hash + c;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
};
const getByPath = function(obj, path, delimiter) {
    var keys = Array.isArray(path) ? path : path.split(delimiter || "/");
    var key;
    var i = 0;
    var length = keys.length;
    while(i < length){
        key = keys[i++];
        if (Object(obj) === obj && key in obj) obj = obj[key];
        else return undefined;
    }
    return obj;
};
const isGetSafe = function(obj, key) {
    // Prevent prototype pollution
    // https://snyk.io/vuln/SNYK-JS-JSON8MERGEPATCH-1038399
    if (typeof key !== "string" && typeof key !== "number") key = String(key);
    if (key === "constructor" && typeof obj[key] === "function") return false;
    if (key === "__proto__") return false;
    return true;
};
const setByPath = function(obj, path, value, delimiter) {
    const keys = Array.isArray(path) ? path : path.split(delimiter || "/");
    const last = keys.length - 1;
    let diver = obj;
    let i = 0;
    for(; i < last; i++){
        const key = keys[i];
        if (!isGetSafe(diver, key)) return obj;
        const value = diver[key];
        // diver creates an empty object if there is no nested object under such a key.
        // This means that one can populate an empty nested object with setByPath().
        diver = value || (diver[key] = {});
    }
    diver[keys[last]] = value;
    return obj;
};
const unsetByPath = function(obj, path, delimiter) {
    const keys = Array.isArray(path) ? path : path.split(delimiter || "/");
    const last = keys.length - 1;
    let diver = obj;
    let i = 0;
    for(; i < last; i++){
        const key = keys[i];
        if (!isGetSafe(diver, key)) return obj;
        const value = diver[key];
        if (!value) return obj;
        diver = value;
    }
    delete diver[keys[last]];
    return obj;
};
const flattenObject = function(obj, delim, stop) {
    delim = delim || "/";
    var ret = {};
    for(var key in obj){
        if (!obj.hasOwnProperty(key)) continue;
        var shouldGoDeeper = typeof obj[key] === "object";
        if (shouldGoDeeper && stop && stop(obj[key])) shouldGoDeeper = false;
        if (shouldGoDeeper) {
            var flatObject = flattenObject(obj[key], delim, stop);
            for(var flatKey in flatObject){
                if (!flatObject.hasOwnProperty(flatKey)) continue;
                ret[key + delim + flatKey] = flatObject[flatKey];
            }
        } else ret[key] = obj[key];
    }
    return ret;
};
const uuid = function() {
    // credit: http://stackoverflow.com/posts/2117523/revisions
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0;
        var v = c === "x" ? r : r & 0x3 | 0x8;
        return v.toString(16);
    });
};
const guid = function(obj) {
    guid.id = guid.id || 1;
    if (obj === undefined) return "j_" + guid.id++;
    obj.id = obj.id === undefined ? "j_" + guid.id++ : obj.id;
    return obj.id;
};
const toKebabCase = function(string) {
    return string.replace(/[A-Z]/g, "-$&").toLowerCase();
};
const normalizeEvent = function(evt) {
    if (evt.normalized) return evt;
    const { originalEvent, target } = evt;
    // If the event is a touch event, normalize it to a mouse event.
    const touch = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];
    if (touch) {
        for(let property in touch)// copy all the properties from the first touch that are not
        // defined on TouchEvent (clientX, clientY, pageX, pageY, screenX, screenY, identifier, ...)
        if (evt[property] === undefined) evt[property] = touch[property];
    }
    // IE: evt.target could be set to SVGElementInstance for SVGUseElement
    if (target) {
        const useElement = target.correspondingUseElement;
        if (useElement) evt.target = useElement;
    }
    evt.normalized = true;
    return evt;
};
const normalizeWheel = function(evt) {
    // Sane values derived empirically
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;
    let sX = 0, sY = 0, pX = 0, pY = 0;
    // Legacy
    if ("detail" in evt) sY = evt.detail;
    if ("wheelDelta" in evt) sY = -evt.wheelDelta / 120;
    if ("wheelDeltaY" in evt) sY = -evt.wheelDeltaY / 120;
    if ("wheelDeltaX" in evt) sX = -evt.wheelDeltaX / 120;
    // side scrolling on FF with DOMMouseScroll
    if ("axis" in evt && evt.axis === evt.HORIZONTAL_AXIS) {
        sX = sY;
        sY = 0;
    }
    pX = "deltaX" in evt ? evt.deltaX : sX * PIXEL_STEP;
    pY = "deltaY" in evt ? evt.deltaY : sY * PIXEL_STEP;
    if ((pX || pY) && evt.deltaMode) {
        if (evt.deltaMode == 1) {
            pX *= LINE_HEIGHT;
            pY *= LINE_HEIGHT;
        } else {
            pX *= PAGE_HEIGHT;
            pY *= PAGE_HEIGHT;
        }
    }
    // macOS switches deltaX and deltaY automatically when scrolling with shift key, so this is needed in other cases
    if (evt.deltaX === 0 && evt.deltaY !== 0 && evt.shiftKey) {
        pX = pY;
        pY = 0;
        sX = sY;
        sY = 0;
    }
    // Fall-back if spin cannot be determined
    if (pX && !sX) sX = pX < 1 ? -1 : 1;
    if (pY && !sY) sY = pY < 1 ? -1 : 1;
    return {
        spinX: sX,
        spinY: sY,
        deltaX: pX,
        deltaY: pY
    };
};
const cap = function(val, max) {
    return val > max ? max : val < -max ? -max : val;
};
const nextFrame = function() {
    var raf;
    if (typeof window !== "undefined") raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
    if (!raf) {
        var lastTime = 0;
        raf = function(callback) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = setTimeout(function() {
                callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }
    return function(callback, context, ...rest) {
        return context !== undefined ? raf(callback.bind(context, ...rest)) : raf(callback);
    };
}();
const cancelFrame = function() {
    var caf;
    var client = typeof window != "undefined";
    if (client) caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame;
    caf = caf || clearTimeout;
    return client ? caf.bind(window) : caf;
}();
const shapePerimeterConnectionPoint = function(linkView, view, magnet, reference) {
    var bbox;
    var spot;
    if (!magnet) {
        // There is no magnet, try to make the best guess what is the
        // wrapping SVG element. This is because we want this "smart"
        // connection points to work out of the box without the
        // programmer to put magnet marks to any of the subelements.
        // For example, we want the function to work on basic.Path elements
        // without any special treatment of such elements.
        // The code below guesses the wrapping element based on
        // one simple assumption. The wrapping elemnet is the
        // first child of the scalable group if such a group exists
        // or the first child of the rotatable group if not.
        // This makese sense because usually the wrapping element
        // is below any other sub element in the shapes.
        var scalable = view.$(".scalable")[0];
        var rotatable = view.$(".rotatable")[0];
        if (scalable && scalable.firstChild) magnet = scalable.firstChild;
        else if (rotatable && rotatable.firstChild) magnet = rotatable.firstChild;
    }
    if (magnet) {
        spot = (0, _indexMjsDefault.default)(magnet).findIntersection(reference, linkView.paper.cells);
        if (!spot) bbox = (0, _indexMjsDefault.default)(magnet).getBBox({
            target: linkView.paper.cells
        });
    } else {
        bbox = view.model.getBBox();
        spot = bbox.intersectionWithLineFromCenterToPoint(reference);
    }
    return spot || bbox.center();
};
const isPercentage = function(val) {
    return (0, _utilHelpersMjs.isString)(val) && val.slice(-1) === "%";
};
const parseCssNumeric = function(val, restrictUnits) {
    function getUnit(validUnitExp) {
        // one or more numbers, followed by
        // any number of (
        //  `.`, followed by
        //  one or more numbers
        // ), followed by
        // `validUnitExp`, followed by
        // end of string
        var matches = new RegExp("(?:\\d+(?:\\.\\d+)*)(" + validUnitExp + ")$").exec(val);
        if (!matches) return null;
        return matches[1];
    }
    var number = parseFloat(val);
    // if `val` cannot be parsed as a number, return `null`
    if (Number.isNaN(number)) return null;
    // else: we know `output.value`
    var output = {};
    output.value = number;
    // determine the unit
    var validUnitExp;
    if (restrictUnits == null) // no restriction
    // accept any unit, as well as no unit
    validUnitExp = "[A-Za-z]*";
    else if (Array.isArray(restrictUnits)) {
        // if this is an empty array, top restriction - return `null`
        if (restrictUnits.length === 0) return null;
        // else: restriction - an array of valid unit strings
        validUnitExp = restrictUnits.join("|");
    } else if ((0, _utilHelpersMjs.isString)(restrictUnits)) // restriction - a single valid unit string
    validUnitExp = restrictUnits;
    var unit = getUnit(validUnitExp);
    // if we found no matches for `restrictUnits`, return `null`
    if (unit === null) return null;
    // else: we know the unit
    output.unit = unit;
    return output;
};
const NO_SPACE = 0;
function splitWordWithEOL(word, eol) {
    const eolWords = word.split(eol);
    let n = 1;
    for(let j = 0, jl = eolWords.length - 1; j < jl; j++){
        const replacement = [];
        if (j > 0 || eolWords[0] !== "") replacement.push(NO_SPACE);
        replacement.push(eol);
        if (j < jl - 1 || eolWords[jl] !== "") replacement.push(NO_SPACE);
        eolWords.splice(n, 0, ...replacement);
        n += replacement.length + 1;
    }
    return eolWords.filter((word)=>word !== "");
}
function getLineHeight(heightValue, textElement) {
    if (heightValue === null) // Default 1em lineHeight
    return textElement.getBBox().height;
    switch(heightValue.unit){
        case "em":
            return textElement.getBBox().height * heightValue.value;
        case "px":
        case "":
            return heightValue.value;
    }
}
const breakText = function(text, size, styles = {}, opt = {}) {
    var width = size.width;
    var height = size.height;
    var svgDocument = opt.svgDocument || (0, _indexMjsDefault.default)("svg").node;
    var textSpan = (0, _indexMjsDefault.default)("tspan").node;
    var textElement = (0, _indexMjsDefault.default)("text").attr(styles).append(textSpan).node;
    var textNode = document.createTextNode("");
    // Prevent flickering
    textElement.style.opacity = 0;
    // Prevent FF from throwing an uncaught exception when `getBBox()`
    // called on element that is not in the render tree (is not measurable).
    // <tspan>.getComputedTextLength() returns always 0 in this case.
    // Note that the `textElement` resp. `textSpan` can become hidden
    // when it's appended to the DOM and a `display: none` CSS stylesheet
    // rule gets applied.
    textElement.style.display = "block";
    textSpan.style.display = "block";
    textSpan.appendChild(textNode);
    svgDocument.appendChild(textElement); // lgtm [js/xss-through-dom]
    if (!opt.svgDocument) document.body.appendChild(svgDocument);
    const preserveSpaces = opt.preserveSpaces;
    const space = " ";
    var separator = opt.separator || space;
    var eol = opt.eol || "\n";
    var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\w\d]/;
    var maxLineCount = opt.maxLineCount;
    if (!(0, _utilHelpersMjs.isNumber)(maxLineCount)) maxLineCount = Infinity;
    var words = text.split(separator);
    var full = [];
    var lines = [];
    var p, h;
    var lineHeight;
    if (preserveSpaces) (0, _indexMjsDefault.default)(textSpan).attr("xml:space", "preserve");
    for(var i = 0, l = 0, len = words.length; i < len; i++){
        var word = words[i];
        if (!word && !preserveSpaces) continue;
        if (typeof word !== "string") continue;
        var isEol = false;
        if (eol && word.indexOf(eol) >= 0) {
            // word contains end-of-line character
            if (word.length > 1) {
                // separate word and continue cycle
                const eolWords = splitWordWithEOL(words[i], eol);
                words.splice(i, 1, ...eolWords);
                i--;
                len = words.length;
                continue;
            } else {
                // creates a new line
                if (preserveSpaces && typeof words[i - 1] === "string") {
                    words.splice(i, NO_SPACE, "", NO_SPACE);
                    len += 2;
                    i--;
                    continue;
                }
                lines[++l] = !preserveSpaces || typeof words[i + 1] === "string" ? "" : undefined;
                isEol = true;
            }
        }
        if (!isEol) {
            let data;
            if (preserveSpaces) data = lines[l] !== undefined ? lines[l] + space + word : word;
            else data = lines[l] ? lines[l] + space + word : word;
            textNode.data = data;
            if (textSpan.getComputedTextLength() <= width) {
                // the current line fits
                lines[l] = data;
                if (p || h) {
                    // We were partitioning. Put rest of the word onto next line
                    full[l++] = true;
                    // cancel partitioning and splitting by hyphens
                    p = 0;
                    h = 0;
                }
            } else {
                if (!lines[l] || p) {
                    var partition = !!p;
                    p = word.length - 1;
                    if (partition || !p) {
                        // word has only one character.
                        if (!p) {
                            if (!lines[l]) {
                                // we won't fit this text within our rect
                                lines = [];
                                break;
                            }
                            // partitioning didn't help on the non-empty line
                            // try again, but this time start with a new line
                            // cancel partitions created
                            words.splice(i, 2, word + words[i + 1]);
                            // adjust word length
                            len--;
                            full[l++] = true;
                            i--;
                            continue;
                        }
                        // move last letter to the beginning of the next word
                        words[i] = word.substring(0, p);
                        const nextWord = words[i + 1];
                        words[i + 1] = word.substring(p) + (nextWord === undefined || nextWord === NO_SPACE ? "" : nextWord);
                    } else {
                        if (h) {
                            // cancel splitting and put the words together again
                            words.splice(i, 2, words[i] + words[i + 1]);
                            h = 0;
                        } else {
                            var hyphenIndex = word.search(hyphen);
                            if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {
                                h = hyphenIndex + 1;
                                p = 0;
                            }
                            // We initiate partitioning or splitting
                            // split the long word into two words
                            words.splice(i, 1, word.substring(0, h || p), word.substring(h || p));
                            // adjust words length
                            len++;
                        }
                        if (l && !full[l - 1]) // if the previous line is not full, try to fit max part of
                        // the current word there
                        l--;
                    }
                    if (!preserveSpaces || lines[l] !== "") i--;
                    continue;
                }
                l++;
                i--;
            }
        }
        var lastL = null;
        if (lines.length > maxLineCount) lastL = maxLineCount - 1;
        else if (height !== undefined) {
            // if size.height is defined we have to check whether the height of the entire
            // text exceeds the rect height
            if (lineHeight === undefined && textNode.data !== "") {
                // use the same defaults as in V.prototype.text
                if (styles.lineHeight === "auto") lineHeight = getLineHeight({
                    value: 1.5,
                    unit: "em"
                }, textElement);
                else {
                    const parsed = parseCssNumeric(styles.lineHeight, [
                        "em",
                        "px",
                        ""
                    ]);
                    lineHeight = getLineHeight(parsed, textElement);
                }
            }
            if (lineHeight * lines.length > height) // remove overflowing lines
            lastL = Math.floor(height / lineHeight) - 1;
        }
        if (lastL !== null) {
            lines.splice(lastL + 1);
            // add ellipsis
            var ellipsis = opt.ellipsis;
            if (!ellipsis || lastL < 0) break;
            if (typeof ellipsis !== "string") ellipsis = "‚Ä¶";
            var lastLine = lines[lastL];
            if (!lastLine && !isEol) break;
            var k = lastLine.length;
            var lastLineWithOmission, lastChar, separatorChar;
            do {
                lastChar = lastLine[k];
                lastLineWithOmission = lastLine.substring(0, k);
                if (!lastChar) {
                    separatorChar = typeof separator === "string" ? separator : " ";
                    lastLineWithOmission += separatorChar;
                } else if (lastChar.match(separator)) lastLineWithOmission += lastChar;
                lastLineWithOmission += ellipsis;
                textNode.data = lastLineWithOmission;
                if (textSpan.getComputedTextLength() <= width) {
                    lines[lastL] = lastLineWithOmission;
                    break;
                }
                k--;
            }while (k >= 0);
            break;
        }
    }
    if (opt.svgDocument) // svg document was provided, remove the text element only
    svgDocument.removeChild(textElement);
    else // clean svg document
    document.body.removeChild(svgDocument);
    return lines.join(eol);
};
const sanitizeHTML = function(html) {
    // Ignores tags that are invalid inside a <div> tag (e.g. <body>, <head>)
    // If documentContext (second parameter) is not specified or given as `null` or `undefined`, a new document is used.
    // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.
    // If keepScripts (last parameter) is `false`, scripts are not executed.
    var output = (0, _jqueryDefault.default)((0, _jqueryDefault.default).parseHTML("<div>" + html + "</div>", null, false));
    output.find("*").each(function() {
        var currentNode = this;
        (0, _jqueryDefault.default).each(currentNode.attributes, function() {
            var currentAttribute = this;
            var attrName = currentAttribute.name;
            var attrValue = currentAttribute.value;
            // Remove attribute names that start with "on" (e.g. onload, onerror...).
            // Remove attribute values that start with "javascript:" pseudo protocol (e.g. `href="javascript:alert(1)"`).
            if (attrName.startsWith("on") || attrValue.startsWith("javascript:") || attrValue.startsWith("data:") || attrValue.startsWith("vbscript:")) (0, _jqueryDefault.default)(currentNode).removeAttr(attrName);
        });
    });
    return output.html();
};
const downloadBlob = function(blob, fileName) {
    if (window.navigator.msSaveBlob) // pulls up a save dialog
    window.navigator.msSaveBlob(blob, fileName);
    else {
        // downloads directly in Chrome and Safari
        // presents a save/open dialog in Firefox
        // Firefox bug: `from` field in save dialog always shows `from:blob:`
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327
        var url = window.URL.createObjectURL(blob);
        var link = document.createElement("a");
        link.href = url;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url); // mark the url for garbage collection
    }
};
const downloadDataUri = function(dataUri, fileName) {
    const blob = dataUriToBlob(dataUri);
    downloadBlob(blob, fileName);
};
const dataUriToBlob = function(dataUri) {
    // first, make sure there are no newlines in the data uri
    dataUri = dataUri.replace(/\s/g, "");
    dataUri = decodeURIComponent(dataUri);
    var firstCommaIndex = dataUri.indexOf(","); // split dataUri as `dataTypeString`,`data`
    var dataTypeString = dataUri.slice(0, firstCommaIndex); // e.g. 'data:image/jpeg;base64'
    var mimeString = dataTypeString.split(":")[1].split(";")[0]; // e.g. 'image/jpeg'
    var data = dataUri.slice(firstCommaIndex + 1);
    var decodedString;
    if (dataTypeString.indexOf("base64") >= 0) decodedString = atob(data); // decode data
    else // convert the decoded string to UTF-8
    decodedString = unescape(encodeURIComponent(data));
    // write the bytes of the string to a typed array
    var ia = new Uint8Array(decodedString.length);
    for(var i = 0; i < decodedString.length; i++)ia[i] = decodedString.charCodeAt(i);
    return new Blob([
        ia
    ], {
        type: mimeString
    }); // return the typed array as Blob
};
const imageToDataUri = function(url, callback) {
    if (!url || url.substr(0, 5) === "data:") // No need to convert to data uri if it is already in data uri.
    // This not only convenient but desired. For example,
    // IE throws a security error if data:image/svg+xml is used to render
    // an image to the canvas and an attempt is made to read out data uri.
    // Now if our image is already in data uri, there is no need to render it to the canvas
    // and so we can bypass this error.
    // Keep the async nature of the function.
    return setTimeout(function() {
        callback(null, url);
    }, 0);
    // chrome, IE10+
    var modernHandler = function(xhr, callback) {
        if (xhr.status === 200) {
            var reader = new FileReader();
            reader.onload = function(evt) {
                var dataUri = evt.target.result;
                callback(null, dataUri);
            };
            reader.onerror = function() {
                callback(new Error("Failed to load image " + url));
            };
            reader.readAsDataURL(xhr.response);
        } else callback(new Error("Failed to load image " + url));
    };
    var legacyHandler = function(xhr, callback) {
        var Uint8ToString = function(u8a) {
            var CHUNK_SZ = 0x8000;
            var c = [];
            for(var i = 0; i < u8a.length; i += CHUNK_SZ)c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));
            return c.join("");
        };
        if (xhr.status === 200) {
            var bytes = new Uint8Array(xhr.response);
            var suffix = url.split(".").pop() || "png";
            var map = {
                "svg": "svg+xml"
            };
            var meta = "data:image/" + (map[suffix] || suffix) + ";base64,";
            var b64encoded = meta + btoa(Uint8ToString(bytes));
            callback(null, b64encoded);
        } else callback(new Error("Failed to load image " + url));
    };
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.addEventListener("error", function() {
        callback(new Error("Failed to load image " + url));
    });
    xhr.responseType = window.FileReader ? "blob" : "arraybuffer";
    xhr.addEventListener("load", function() {
        if (window.FileReader) modernHandler(xhr, callback);
        else legacyHandler(xhr, callback);
    });
    xhr.send();
};
const getElementBBox = function(el) {
    var $el = (0, _jqueryDefault.default)(el);
    if ($el.length === 0) throw new Error("Element not found");
    var element = $el[0];
    var doc = element.ownerDocument;
    var clientBBox = element.getBoundingClientRect();
    var strokeWidthX = 0;
    var strokeWidthY = 0;
    // Firefox correction
    if (element.ownerSVGElement) {
        var vel = (0, _indexMjsDefault.default)(element);
        var bbox = vel.getBBox({
            target: vel.svg()
        });
        // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.
        // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.
        strokeWidthX = clientBBox.width - bbox.width;
        strokeWidthY = clientBBox.height - bbox.height;
    }
    return {
        x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,
        y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,
        width: clientBBox.width - strokeWidthX,
        height: clientBBox.height - strokeWidthY
    };
};
const sortElements = function(elements, comparator) {
    var $elements = (0, _jqueryDefault.default)(elements);
    var placements = $elements.map(function() {
        var sortElement = this;
        var parentNode = sortElement.parentNode;
        // Since the element itself will change position, we have
        // to have some way of storing it's original position in
        // the DOM. The easiest way is to have a 'flag' node:
        var nextSibling = parentNode.insertBefore(document.createTextNode(""), sortElement.nextSibling);
        return function() {
            if (parentNode === this) throw new Error("You can't sort elements if any one is a descendant of another.");
            // Insert before flag:
            parentNode.insertBefore(this, nextSibling);
            // Remove flag:
            parentNode.removeChild(nextSibling);
        };
    });
    return Array.prototype.sort.call($elements, comparator).each(function(i) {
        placements[i].call(this);
    });
};
const setAttributesBySelector = function(element, attrs) {
    var $element = (0, _jqueryDefault.default)(element);
    (0, _utilHelpersMjs.forIn)(attrs, function(attrs, selector) {
        var $elements = $element.find(selector).addBack().filter(selector);
        // Make a special case for setting classes.
        // We do not want to overwrite any existing class.
        if ((0, _utilHelpersMjs.has)(attrs, "class")) {
            $elements.addClass(attrs["class"]);
            attrs = (0, _utilHelpersMjs.omit)(attrs, "class");
        }
        $elements.attr(attrs);
    });
};
const normalizeSides = function(box) {
    if (Object(box) !== box) {
        var val = 0; // `val` left as 0 if `box` cannot be understood as finite number
        if (isFinite(box)) val = +box; // actually also accepts string numbers (e.g. '100')
        return {
            top: val,
            right: val,
            bottom: val,
            left: val
        };
    }
    // `box` is an object
    var top, right, bottom, left;
    top = right = bottom = left = 0;
    if (isFinite(box.vertical)) top = bottom = +box.vertical;
    if (isFinite(box.horizontal)) right = left = +box.horizontal;
    if (isFinite(box.top)) top = +box.top; // overwrite vertical
    if (isFinite(box.right)) right = +box.right; // overwrite horizontal
    if (isFinite(box.bottom)) bottom = +box.bottom; // overwrite vertical
    if (isFinite(box.left)) left = +box.left; // overwrite horizontal
    return {
        top: top,
        right: right,
        bottom: bottom,
        left: left
    };
};
const timing = {
    linear: function(t) {
        return t;
    },
    quad: function(t) {
        return t * t;
    },
    cubic: function(t) {
        return t * t * t;
    },
    inout: function(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        var t2 = t * t;
        var t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
    },
    exponential: function(t) {
        return Math.pow(2, 10 * (t - 1));
    },
    bounce: function(t) {
        for(var a = 0, b = 1;; a += b, b /= 2)if (t >= (7 - 4 * a) / 11) {
            var q = (11 - 6 * a - 11 * t) / 4;
            return -q * q + b * b;
        }
    },
    reverse: function(f) {
        return function(t) {
            return 1 - f(1 - t);
        };
    },
    reflect: function(f) {
        return function(t) {
            return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
    },
    clamp: function(f, n, x) {
        n = n || 0;
        x = x || 1;
        return function(t) {
            var r = f(t);
            return r < n ? n : r > x ? x : r;
        };
    },
    back: function(s) {
        if (!s) s = 1.70158;
        return function(t) {
            return t * t * ((s + 1) * t - s);
        };
    },
    elastic: function(x) {
        if (!x) x = 1.5;
        return function(t) {
            return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);
        };
    }
};
const interpolate = {
    number: function(a, b) {
        var d = b - a;
        return function(t) {
            return a + d * t;
        };
    },
    object: function(a, b) {
        var s = Object.keys(a);
        return function(t) {
            var i, p;
            var r = {};
            for(i = s.length - 1; i != -1; i--){
                p = s[i];
                r[p] = a[p] + (b[p] - a[p]) * t;
            }
            return r;
        };
    },
    hexColor: function(a, b) {
        var ca = parseInt(a.slice(1), 16);
        var cb = parseInt(b.slice(1), 16);
        var ra = ca & 0x0000ff;
        var rd = (cb & 0x0000ff) - ra;
        var ga = ca & 0x00ff00;
        var gd = (cb & 0x00ff00) - ga;
        var ba = ca & 0xff0000;
        var bd = (cb & 0xff0000) - ba;
        return function(t) {
            var r = ra + rd * t & 0x000000ff;
            var g = ga + gd * t & 0x0000ff00;
            var b = ba + bd * t & 0x00ff0000;
            return "#" + (16777216 | r | g | b).toString(16).slice(1);
        };
    },
    unit: function(a, b) {
        var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;
        var ma = r.exec(a);
        var mb = r.exec(b);
        var p = mb[1].indexOf(".");
        var f = p > 0 ? mb[1].length - p - 1 : 0;
        a = +ma[1];
        var d = +mb[1] - a;
        var u = ma[2];
        return function(t) {
            return (a + d * t).toFixed(f) + u;
        };
    }
};
const filter = {
    // `color` ... outline color ('blue')
    // `width`... outline width (1)
    // `opacity` ... outline opacity (1)
    // `margin` ... gap between outline and the element (2)
    outline: function(args) {
        var tpl = '<filter><feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/><feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${outerRadius}" /><feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${innerRadius}" /><feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/><feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/><feMerge><feMergeNode in="outline"/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
        var margin = Number.isFinite(args.margin) ? args.margin : 2;
        var width = Number.isFinite(args.width) ? args.width : 1;
        return template(tpl)({
            color: args.color || "blue",
            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,
            outerRadius: margin + width,
            innerRadius: margin
        });
    },
    // `color` ... color ('red')
    // `width`... width (1)
    // `blur` ... blur (0)
    // `opacity` ... opacity (1)
    highlight: function(args) {
        var tpl = '<filter><feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/><feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${width}"/><feComposite result="composed" in="colored" in2="morphed" operator="in"/><feGaussianBlur result="blured" in="composed" stdDeviation="${blur}"/><feBlend in="SourceGraphic" in2="blured" mode="normal"/></filter>';
        return template(tpl)({
            color: args.color || "red",
            width: Number.isFinite(args.width) ? args.width : 1,
            blur: Number.isFinite(args.blur) ? args.blur : 0,
            opacity: Number.isFinite(args.opacity) ? args.opacity : 1
        });
    },
    // `x` ... horizontal blur (2)
    // `y` ... vertical blur (optional)
    blur: function(args) {
        var x = Number.isFinite(args.x) ? args.x : 2;
        return template('<filter><feGaussianBlur stdDeviation="${stdDeviation}"/></filter>')({
            stdDeviation: Number.isFinite(args.y) ? [
                x,
                args.y
            ] : x
        });
    },
    // `dx` ... horizontal shift (0)
    // `dy` ... vertical shift (0)
    // `blur` ... blur (4)
    // `color` ... color ('black')
    // `opacity` ... opacity (1)
    dropShadow: function(args) {
        var tpl = "SVGFEDropShadowElement" in window ? '<filter><feDropShadow stdDeviation="${blur}" dx="${dx}" dy="${dy}" flood-color="${color}" flood-opacity="${opacity}"/></filter>' : '<filter><feGaussianBlur in="SourceAlpha" stdDeviation="${blur}"/><feOffset dx="${dx}" dy="${dy}" result="offsetblur"/><feFlood flood-color="${color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="${opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
        return template(tpl)({
            dx: args.dx || 0,
            dy: args.dy || 0,
            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,
            color: args.color || "black",
            blur: Number.isFinite(args.blur) ? args.blur : 4
        });
    },
    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.
    grayscale: function(args) {
        var amount = Number.isFinite(args.amount) ? args.amount : 1;
        return template('<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/></filter>')({
            a: 0.2126 + 0.7874 * (1 - amount),
            b: 0.7152 - 0.7152 * (1 - amount),
            c: 0.0722 - 0.0722 * (1 - amount),
            d: 0.2126 - 0.2126 * (1 - amount),
            e: 0.7152 + 0.2848 * (1 - amount),
            f: 0.0722 - 0.0722 * (1 - amount),
            g: 0.2126 - 0.2126 * (1 - amount),
            h: 0.0722 + 0.9278 * (1 - amount)
        });
    },
    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.
    sepia: function(args) {
        var amount = Number.isFinite(args.amount) ? args.amount : 1;
        return template('<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0"/></filter>')({
            a: 0.393 + 0.607 * (1 - amount),
            b: 0.769 - 0.769 * (1 - amount),
            c: 0.189 - 0.189 * (1 - amount),
            d: 0.349 - 0.349 * (1 - amount),
            e: 0.686 + 0.314 * (1 - amount),
            f: 0.168 - 0.168 * (1 - amount),
            g: 0.272 - 0.272 * (1 - amount),
            h: 0.534 - 0.534 * (1 - amount),
            i: 0.131 + 0.869 * (1 - amount)
        });
    },
    // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.
    saturate: function(args) {
        var amount = Number.isFinite(args.amount) ? args.amount : 1;
        return template('<filter><feColorMatrix type="saturate" values="${amount}"/></filter>')({
            amount: 1 - amount
        });
    },
    // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).
    hueRotate: function(args) {
        return template('<filter><feColorMatrix type="hueRotate" values="${angle}"/></filter>')({
            angle: args.angle || 0
        });
    },
    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.
    invert: function(args) {
        var amount = Number.isFinite(args.amount) ? args.amount : 1;
        return template('<filter><feComponentTransfer><feFuncR type="table" tableValues="${amount} ${amount2}"/><feFuncG type="table" tableValues="${amount} ${amount2}"/><feFuncB type="table" tableValues="${amount} ${amount2}"/></feComponentTransfer></filter>')({
            amount: amount,
            amount2: 1 - amount
        });
    },
    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.
    brightness: function(args) {
        return template('<filter><feComponentTransfer><feFuncR type="linear" slope="${amount}"/><feFuncG type="linear" slope="${amount}"/><feFuncB type="linear" slope="${amount}"/></feComponentTransfer></filter>')({
            amount: Number.isFinite(args.amount) ? args.amount : 1
        });
    },
    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.
    contrast: function(args) {
        var amount = Number.isFinite(args.amount) ? args.amount : 1;
        return template('<filter><feComponentTransfer><feFuncR type="linear" slope="${amount}" intercept="${amount2}"/><feFuncG type="linear" slope="${amount}" intercept="${amount2}"/><feFuncB type="linear" slope="${amount}" intercept="${amount2}"/></feComponentTransfer></filter>')({
            amount: amount,
            amount2: .5 - amount / 2
        });
    }
};
const format = {
    // Formatting numbers via the Python Format Specification Mini-language.
    // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.
    // Heavilly inspired by the D3.js library implementation.
    number: function(specifier, value, locale) {
        locale = locale || {
            currency: [
                "$",
                ""
            ],
            decimal: ".",
            thousands: ",",
            grouping: [
                3
            ]
        };
        // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.
        // [[fill]align][sign][symbol][0][width][,][.precision][type]
        var re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
        var match = re.exec(specifier);
        var fill = match[1] || " ";
        var align = match[2] || ">";
        var sign = match[3] || "";
        var symbol = match[4] || "";
        var zfill = match[5];
        var width = +match[6];
        var comma = match[7];
        var precision = match[8];
        var type = match[9];
        var scale = 1;
        var prefix = "";
        var suffix = "";
        var integer = false;
        if (precision) precision = +precision.substring(1);
        if (zfill || fill === "0" && align === "=") {
            zfill = fill = "0";
            align = "=";
            if (comma) width -= Math.floor((width - 1) / 4);
        }
        switch(type){
            case "n":
                comma = true;
                type = "g";
                break;
            case "%":
                scale = 100;
                suffix = "%";
                type = "f";
                break;
            case "p":
                scale = 100;
                suffix = "%";
                type = "r";
                break;
            case "b":
            case "o":
            case "x":
            case "X":
                if (symbol === "#") prefix = "0" + type.toLowerCase();
                break;
            case "c":
            case "d":
                integer = true;
                precision = 0;
                break;
            case "s":
                scale = -1;
                type = "r";
                break;
        }
        if (symbol === "$") {
            prefix = locale.currency[0];
            suffix = locale.currency[1];
        }
        // If no precision is specified for `'r'`, fallback to general notation.
        if (type == "r" && !precision) type = "g";
        // Ensure that the requested precision is in the supported range.
        if (precision != null) {
            if (type == "g") precision = Math.max(1, Math.min(21, precision));
            else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
        }
        var zcomma = zfill && comma;
        // Return the empty string for floats formatted as ints.
        if (integer && value % 1) return "";
        // Convert negative to positive, and record the sign prefix.
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign;
        var fullSuffix = suffix;
        // Apply the scale, computing it from the value's exponent for si format.
        // Preserve the existing suffix, if any, such as the currency symbol.
        if (scale < 0) {
            var unit = this.prefix(value, precision);
            value = unit.scale(value);
            fullSuffix = unit.symbol + suffix;
        } else value *= scale;
        // Convert to the desired precision.
        value = this.convert(type, value, precision);
        // Break the value into the integer part (before) and decimal part (after).
        var i = value.lastIndexOf(".");
        var before = i < 0 ? value : value.substring(0, i);
        var after = i < 0 ? "" : locale.decimal + value.substring(i + 1);
        function formatGroup(value) {
            var i = value.length;
            var t = [];
            var j = 0;
            var g = locale.grouping[0];
            while(i > 0 && g > 0){
                t.push(value.substring(i -= g, i + g));
                g = locale.grouping[j = (j + 1) % locale.grouping.length];
            }
            return t.reverse().join(locale.thousands);
        }
        // If the fill character is not `'0'`, grouping is applied before padding.
        if (!zfill && comma && locale.grouping) before = formatGroup(before);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);
        var padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        // If the fill character is `'0'`, grouping is applied after padding.
        if (zcomma) before = formatGroup(padding + before);
        // Apply prefix.
        negative += prefix;
        // Rejoin integer and decimal parts.
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
    },
    // Formatting string via the Python Format string.
    // See https://docs.python.org/2/library/string.html#format-string-syntax)
    string: function(formatString, value) {
        var fieldDelimiterIndex;
        var fieldDelimiter = "{";
        var endPlaceholder = false;
        var formattedStringArray = [];
        while((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1){
            var pieceFormattedString, formatSpec, fieldName;
            pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);
            if (endPlaceholder) {
                formatSpec = pieceFormattedString.split(":");
                fieldName = formatSpec.shift().split(".");
                pieceFormattedString = value;
                for(var i = 0; i < fieldName.length; i++)pieceFormattedString = pieceFormattedString[fieldName[i]];
                if (formatSpec.length) pieceFormattedString = this.number(formatSpec, pieceFormattedString);
            }
            formattedStringArray.push(pieceFormattedString);
            formatString = formatString.slice(fieldDelimiterIndex + 1);
            endPlaceholder = !endPlaceholder;
            fieldDelimiter = endPlaceholder ? "}" : "{";
        }
        formattedStringArray.push(formatString);
        return formattedStringArray.join("");
    },
    convert: function(type, value, precision) {
        switch(type){
            case "b":
                return value.toString(2);
            case "c":
                return String.fromCharCode(value);
            case "o":
                return value.toString(8);
            case "x":
                return value.toString(16);
            case "X":
                return value.toString(16).toUpperCase();
            case "g":
                return value.toPrecision(precision);
            case "e":
                return value.toExponential(precision);
            case "f":
                return value.toFixed(precision);
            case "r":
                return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));
            default:
                return value + "";
        }
    },
    round: function(value, precision) {
        return precision ? Math.round(value * (precision = Math.pow(10, precision))) / precision : Math.round(value);
    },
    precision: function(value, precision) {
        return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);
    },
    prefix: function(value, precision) {
        var prefixes = [
            "y",
            "z",
            "a",
            "f",
            "p",
            "n",
            "\xb5",
            "m",
            "",
            "k",
            "M",
            "G",
            "T",
            "P",
            "E",
            "Z",
            "Y"
        ].map(function(d, i) {
            var k = Math.pow(10, Math.abs(8 - i) * 3);
            return {
                scale: i > 8 ? function(d) {
                    return d / k;
                } : function(d) {
                    return d * k;
                },
                symbol: d
            };
        });
        var i = 0;
        if (value) {
            if (value < 0) value *= -1;
            if (precision) value = this.round(value, this.precision(value, precision));
            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
            i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
        }
        return prefixes[8 + i / 3];
    }
};
const template = function(html) {
    /*
        Must support the variation in templating syntax found here:
        https://lodash.com/docs#template
    */ var regex = /<%= ([^ ]+) %>|\$\{ ?([^{} ]+) ?\}|\{\{([^{} ]+)\}\}/g;
    return function(data) {
        data = data || {};
        return html.replace(regex, function(match) {
            var args = Array.from(arguments);
            var attr = args.slice(1, 4).find(function(_attr) {
                return !!_attr;
            });
            var attrArray = attr.split(".");
            var value = data[attrArray.shift()];
            while(value !== undefined && attrArray.length)value = value[attrArray.shift()];
            return value !== undefined ? value : "";
        });
    };
};
const toggleFullScreen = function(el) {
    var topDocument = window.top.document;
    el = el || topDocument.body;
    function prefixedResult(el, prop) {
        var prefixes = [
            "webkit",
            "moz",
            "ms",
            "o",
            ""
        ];
        for(var i = 0; i < prefixes.length; i++){
            var prefix = prefixes[i];
            var propName = prefix ? prefix + prop : prop.substr(0, 1).toLowerCase() + prop.substr(1);
            if (el[propName] !== undefined) return (0, _utilHelpersMjs.isFunction)(el[propName]) ? el[propName]() : el[propName];
        }
    }
    if (prefixedResult(topDocument, "FullscreenElement") || prefixedResult(topDocument, "FullScreenElement")) prefixedResult(topDocument, "ExitFullscreen") || // Spec.
    prefixedResult(topDocument, "CancelFullScreen"); // Firefox
    else prefixedResult(el, "RequestFullscreen") || // Spec.
    prefixedResult(el, "RequestFullScreen"); // Firefox
};
const noop = function() {};

},{"jquery":"7jr44","../V/index.mjs":"iw8UN","../config/index.mjs":"7Vsch","./utilHelpers.mjs":"4e0W7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iw8UN":[function(require,module,exports) {
// Vectorizer.
// -----------
// A tiny library for making your life easier when dealing with SVG.
// The only Vectorizer dependency is the Geometry library.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexMjs = require("../g/index.mjs");
const V = function() {
    var hasSvg = typeof window === "object" && !!window.SVGAngle;
    // SVG support is required.
    if (!hasSvg) // Return a function that throws an error when it is used.
    return function() {
        throw new Error("SVG is required to use Vectorizer.");
    };
    // XML namespaces.
    var ns = {
        svg: "http://www.w3.org/2000/svg",
        xmlns: "http://www.w3.org/2000/xmlns/",
        xml: "http://www.w3.org/XML/1998/namespace",
        xlink: "http://www.w3.org/1999/xlink",
        xhtml: "http://www.w3.org/1999/xhtml"
    };
    var SVGVersion = "1.1";
    // Declare shorthands to the most used math functions.
    var math = Math;
    var PI = math.PI;
    var atan2 = math.atan2;
    var sqrt = math.sqrt;
    var min = math.min;
    var max = math.max;
    var cos = math.cos;
    var sin = math.sin;
    var V = function(el, attrs, children) {
        // This allows using V() without the new keyword.
        if (!(this instanceof V)) return V.apply(Object.create(V.prototype), arguments);
        if (!el) return;
        if (V.isV(el)) el = el.node;
        attrs = attrs || {};
        if (V.isString(el)) {
            el = el.trim();
            if (el.toLowerCase() === "svg") // Create a new SVG canvas.
            el = V.createSvgDocument();
            else if (el[0] === "<") {
                // Create element from an SVG string.
                // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.
                var svgDoc = V.createSvgDocument(el);
                // Note that `V()` might also return an array should the SVG string passed as
                // the first argument contain more than one root element.
                if (svgDoc.childNodes.length > 1) {
                    // Map child nodes to `V`s.
                    var arrayOfVels = [];
                    var i, len;
                    for(i = 0, len = svgDoc.childNodes.length; i < len; i++){
                        var childNode = svgDoc.childNodes[i];
                        arrayOfVels.push(new V(document.importNode(childNode, true)));
                    }
                    return arrayOfVels;
                }
                el = document.importNode(svgDoc.firstChild, true);
            } else el = document.createElementNS(ns.svg, el);
            V.ensureId(el);
        }
        this.node = el;
        this.setAttributes(attrs);
        if (children) this.append(children);
        return this;
    };
    var VPrototype = V.prototype;
    Object.defineProperty(VPrototype, "id", {
        enumerable: true,
        get: function() {
            return this.node.id;
        },
        set: function(id) {
            this.node.id = id;
        }
    });
    /**
     * @param {SVGGElement} toElem
     * @returns {SVGMatrix}
     */ VPrototype.getTransformToElement = function(target) {
        var node = this.node;
        if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {
            var targetCTM = V.toNode(target).getScreenCTM();
            var nodeCTM = node.getScreenCTM();
            if (targetCTM && nodeCTM) return targetCTM.inverse().multiply(nodeCTM);
        }
        // Could not get actual transformation matrix
        return V.createSVGMatrix();
    };
    /**
     * @param {SVGMatrix} matrix
     * @param {Object=} opt
     * @returns {Vectorizer|SVGMatrix} Setter / Getter
     */ VPrototype.transform = function(matrix, opt) {
        var node = this.node;
        if (V.isUndefined(matrix)) return V.transformStringToMatrix(this.attr("transform"));
        if (opt && opt.absolute) return this.attr("transform", V.matrixToTransformString(matrix));
        var svgTransform = V.createSVGTransform(matrix);
        node.transform.baseVal.appendItem(svgTransform);
        return this;
    };
    VPrototype.translate = function(tx, ty, opt) {
        opt = opt || {};
        ty = ty || 0;
        var transformAttr = this.attr("transform") || "";
        var transform = V.parseTransformString(transformAttr);
        transformAttr = transform.value;
        // Is it a getter?
        if (V.isUndefined(tx)) return transform.translate;
        transformAttr = transformAttr.replace(/translate\([^)]*\)/g, "").trim();
        var newTx = opt.absolute ? tx : transform.translate.tx + tx;
        var newTy = opt.absolute ? ty : transform.translate.ty + ty;
        var newTranslate = "translate(" + newTx + "," + newTy + ")";
        // Note that `translate()` is always the first transformation. This is
        // usually the desired case.
        this.attr("transform", (newTranslate + " " + transformAttr).trim());
        return this;
    };
    VPrototype.rotate = function(angle, cx, cy, opt) {
        opt = opt || {};
        var transformAttr = this.attr("transform") || "";
        var transform = V.parseTransformString(transformAttr);
        transformAttr = transform.value;
        // Is it a getter?
        if (V.isUndefined(angle)) return transform.rotate;
        transformAttr = transformAttr.replace(/rotate\([^)]*\)/g, "").trim();
        angle %= 360;
        var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;
        var newOrigin = cx !== undefined && cy !== undefined ? "," + cx + "," + cy : "";
        var newRotate = "rotate(" + newAngle + newOrigin + ")";
        this.attr("transform", (transformAttr + " " + newRotate).trim());
        return this;
    };
    // Note that `scale` as the only transformation does not combine with previous values.
    VPrototype.scale = function(sx, sy) {
        sy = V.isUndefined(sy) ? sx : sy;
        var transformAttr = this.attr("transform") || "";
        var transform = V.parseTransformString(transformAttr);
        transformAttr = transform.value;
        // Is it a getter?
        if (V.isUndefined(sx)) return transform.scale;
        transformAttr = transformAttr.replace(/scale\([^)]*\)/g, "").trim();
        var newScale = "scale(" + sx + "," + sy + ")";
        this.attr("transform", (transformAttr + " " + newScale).trim());
        return this;
    };
    // Get SVGRect that contains coordinates and dimension of the real bounding box,
    // i.e. after transformations are applied.
    // If `target` is specified, bounding box will be computed relatively to `target` element.
    VPrototype.bbox = function(withoutTransformations, target) {
        var box;
        var node = this.node;
        var ownerSVGElement = node.ownerSVGElement;
        // If the element is not in the live DOM, it does not have a bounding box defined and
        // so fall back to 'zero' dimension element.
        if (!ownerSVGElement) return new _indexMjs.Rect(0, 0, 0, 0);
        try {
            box = node.getBBox();
        } catch (e) {
            // Fallback for IE.
            box = {
                x: node.clientLeft,
                y: node.clientTop,
                width: node.clientWidth,
                height: node.clientHeight
            };
        }
        if (withoutTransformations) return new _indexMjs.Rect(box);
        var matrix = this.getTransformToElement(target || ownerSVGElement);
        return V.transformRect(box, matrix);
    };
    // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,
    // i.e. after transformations are applied.
    // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.
    // Takes an (Object) `opt` argument (optional) with the following attributes:
    // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this
    // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();
    VPrototype.getBBox = function(opt) {
        var options = {};
        var outputBBox;
        var node = this.node;
        var ownerSVGElement = node.ownerSVGElement;
        // If the element is not in the live DOM, it does not have a bounding box defined and
        // so fall back to 'zero' dimension element.
        // If the element is not an SVGGraphicsElement, we could not measure the bounding box either
        if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) return new _indexMjs.Rect(0, 0, 0, 0);
        if (opt) {
            if (opt.target) options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects
            if (opt.recursive) options.recursive = opt.recursive;
        }
        if (!options.recursive) {
            try {
                outputBBox = node.getBBox();
            } catch (e) {
                // Fallback for IE.
                outputBBox = {
                    x: node.clientLeft,
                    y: node.clientTop,
                    width: node.clientWidth,
                    height: node.clientHeight
                };
            }
            if (!options.target) // transform like this (that is, not at all)
            return new _indexMjs.Rect(outputBBox);
            else {
                // transform like target
                var matrix = this.getTransformToElement(options.target);
                return V.transformRect(outputBBox, matrix);
            }
        } else {
            // browsers report correct bbox around svg elements (one that envelops the path lines tightly)
            // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())
            // this happens even if we wrap a single svg element into a group!
            // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes
            var children = this.children();
            var n = children.length;
            if (n === 0) return this.getBBox({
                target: options.target,
                recursive: false
            });
            // recursion's initial pass-through setting:
            // recursive passes-through just keep the target as whatever was set up here during the initial pass-through
            if (!options.target) // transform children/descendants like this (their parent/ancestor)
            options.target = this;
             // else transform children/descendants like target
            for(var i = 0; i < n; i++){
                var currentChild = children[i];
                var childBBox;
                // if currentChild is not a group element, get its bbox with a nonrecursive call
                if (currentChild.children().length === 0) childBBox = currentChild.getBBox({
                    target: options.target,
                    recursive: false
                });
                else // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call
                childBBox = currentChild.getBBox({
                    target: options.target,
                    recursive: true
                });
                if (!outputBBox) // if this is the first iteration
                outputBBox = childBBox;
                else // make a new bounding box rectangle that contains this child's bounding box and previous bounding box
                outputBBox = outputBBox.union(childBBox);
            }
            return outputBBox;
        }
    };
    // Text() helpers
    function createTextPathNode(attrs, vel) {
        attrs || (attrs = {});
        var textPathElement = V("textPath");
        var d = attrs.d;
        if (d && attrs["xlink:href"] === undefined) {
            // If `opt.attrs` is a plain string, consider it to be directly the
            // SVG path data for the text to go along (this is a shortcut).
            // Otherwise if it is an object and contains the `d` property, then this is our path.
            // Wrap the text in the SVG <textPath> element that points
            // to a path defined by `opt.attrs` inside the `<defs>` element.
            var linkedPath = V("path").attr("d", d).appendTo(vel.defs());
            textPathElement.attr("xlink:href", "#" + linkedPath.id);
        }
        if (V.isObject(attrs)) // Set attributes on the `<textPath>`. The most important one
        // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.
        // Note that we also allow the following construct:
        // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.
        // In other words, one can completely skip the auto-creation of the path
        // and use any other arbitrary path that is in the document.
        textPathElement.attr(attrs);
        return textPathElement.node;
    }
    function annotateTextLine(lineNode, lineAnnotations, opt) {
        opt || (opt = {});
        var includeAnnotationIndices = opt.includeAnnotationIndices;
        var eol = opt.eol;
        var lineHeight = opt.lineHeight;
        var baseSize = opt.baseSize;
        var maxFontSize = 0;
        var fontMetrics = {};
        var lastJ = lineAnnotations.length - 1;
        for(var j = 0; j <= lastJ; j++){
            var annotation = lineAnnotations[j];
            var fontSize = null;
            if (V.isObject(annotation)) {
                var annotationAttrs = annotation.attrs;
                var vTSpan = V("tspan", annotationAttrs);
                var tspanNode = vTSpan.node;
                var t = annotation.t;
                if (eol && j === lastJ) t += eol;
                tspanNode.textContent = t;
                // Per annotation className
                var annotationClass = annotationAttrs["class"];
                if (annotationClass) vTSpan.addClass(annotationClass);
                // If `opt.includeAnnotationIndices` is `true`,
                // set the list of indices of all the applied annotations
                // in the `annotations` attribute. This list is a comma
                // separated list of indices.
                if (includeAnnotationIndices) vTSpan.attr("annotations", annotation.annotations);
                // Check for max font size
                fontSize = parseFloat(annotationAttrs["font-size"]);
                if (!isFinite(fontSize)) fontSize = baseSize;
                if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;
            } else {
                if (eol && j === lastJ) annotation += eol;
                tspanNode = document.createTextNode(annotation || " ");
                if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;
            }
            lineNode.appendChild(tspanNode);
        }
        if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;
        if (lineHeight) fontMetrics.lineHeight = lineHeight;
        else if (maxFontSize) fontMetrics.lineHeight = maxFontSize * 1.2;
        return fontMetrics;
    }
    var emRegex = /em$/;
    function convertEmToPx(em, fontSize) {
        var numerical = parseFloat(em);
        if (emRegex.test(em)) return numerical * fontSize;
        return numerical;
    }
    function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {
        if (!Array.isArray(linesMetrics)) return 0;
        var n = linesMetrics.length;
        if (!n) return 0;
        var lineMetrics = linesMetrics[0];
        var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
        var rLineHeights = 0;
        var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);
        for(var i = 1; i < n; i++){
            lineMetrics = linesMetrics[i];
            var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;
            rLineHeights += iLineHeight;
        }
        var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
        var dy;
        switch(alignment){
            case "middle":
                dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;
                break;
            case "bottom":
                dy = -(0.25 * llMaxFont) - rLineHeights;
                break;
            default:
            case "top":
                dy = 0.8 * flMaxFont;
                break;
        }
        return dy;
    }
    VPrototype.text = function(content, opt) {
        if (content && typeof content !== "string") throw new Error("Vectorizer: text() expects the first argument to be a string.");
        // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).
        // IE would otherwise collapse all spaces into one.
        content = V.sanitizeText(content);
        opt || (opt = {});
        // Should we allow the text to be selected?
        var displayEmpty = opt.displayEmpty;
        // End of Line character
        var eol = opt.eol;
        // Text along path
        var textPath = opt.textPath;
        // Vertical shift
        var verticalAnchor = opt.textVerticalAnchor;
        var namedVerticalAnchor = verticalAnchor === "middle" || verticalAnchor === "bottom" || verticalAnchor === "top";
        // Horizontal shift applied to all the lines but the first.
        var x = opt.x;
        if (x === undefined) x = this.attr("x") || 0;
        // Annotations
        var iai = opt.includeAnnotationIndices;
        var annotations = opt.annotations;
        if (annotations && !V.isArray(annotations)) annotations = [
            annotations
        ];
        // Shift all the <tspan> but first by one line (`1em`)
        var defaultLineHeight = opt.lineHeight;
        var autoLineHeight = defaultLineHeight === "auto";
        var lineHeight = autoLineHeight ? "1.5em" : defaultLineHeight || "1em";
        // Clearing the element
        this.empty();
        this.attr({
            // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.
            "xml:space": "preserve",
            // An empty text gets rendered into the DOM in webkit-based browsers.
            // In order to unify this behaviour across all browsers
            // we rather hide the text element when it's empty.
            "display": content || displayEmpty ? null : "none"
        });
        // Set default font-size if none
        var fontSize = parseFloat(this.attr("font-size"));
        if (!fontSize) {
            fontSize = 16;
            if (namedVerticalAnchor || annotations) this.attr("font-size", fontSize);
        }
        var doc = document;
        var containerNode;
        if (textPath) {
            // Now all the `<tspan>`s will be inside the `<textPath>`.
            if (typeof textPath === "string") textPath = {
                d: textPath
            };
            containerNode = createTextPathNode(textPath, this);
        } else containerNode = doc.createDocumentFragment();
        var offset = 0;
        var lines = content.split("\n");
        var linesMetrics = [];
        var annotatedY;
        for(var i = 0, lastI = lines.length - 1; i <= lastI; i++){
            var dy = lineHeight;
            var lineClassName = "v-line";
            var lineNode = doc.createElementNS(ns.svg, "tspan");
            var line = lines[i];
            var lineMetrics;
            if (line) {
                if (annotations) {
                    // Find the *compacted* annotations for this line.
                    var lineAnnotations = V.annotateString(line, annotations, {
                        offset: -offset,
                        includeAnnotationIndices: iai
                    });
                    lineMetrics = annotateTextLine(lineNode, lineAnnotations, {
                        includeAnnotationIndices: iai,
                        eol: i !== lastI && eol,
                        lineHeight: autoLineHeight ? null : lineHeight,
                        baseSize: fontSize
                    });
                    // Get the line height based on the biggest font size in the annotations for this line.
                    var iLineHeight = lineMetrics.lineHeight;
                    if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;
                    if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;
                } else {
                    if (eol && i !== lastI) line += eol;
                    lineNode.textContent = line;
                }
            } else {
                // Make sure the textContent is never empty. If it is, add a dummy
                // character and make it invisible, making the following lines correctly
                // relatively positioned. `dy=1em` won't work with empty lines otherwise.
                lineNode.textContent = "-";
                lineClassName += " v-empty-line";
                // 'opacity' needs to be specified with fill, stroke. Opacity without specification
                // is not applied in Firefox
                var lineNodeStyle = lineNode.style;
                lineNodeStyle.fillOpacity = 0;
                lineNodeStyle.strokeOpacity = 0;
                if (annotations) {
                    // Empty line with annotations.
                    lineMetrics = {};
                    lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);
                    let lineFontSize = fontSize;
                    // Check if any of the annotations overrides the font size.
                    for(let j = lineAnnotations.length; j > 0; j--){
                        const attrs = lineAnnotations[j - 1].attrs;
                        if (!attrs || !("font-size" in attrs)) continue;
                        const fs = parseFloat(attrs["font-size"]);
                        if (isFinite(fs)) {
                            lineFontSize = fs;
                            break;
                        }
                    }
                    if (autoLineHeight) {
                        if (i > 0) dy = lineFontSize * 1.2;
                        else annotatedY = lineFontSize * 0.8;
                    }
                    // The font size is important for the native selection box height.
                    lineNode.setAttribute("font-size", lineFontSize);
                    lineMetrics.maxFontSize = lineFontSize;
                }
            }
            if (lineMetrics) linesMetrics.push(lineMetrics);
            if (i > 0) lineNode.setAttribute("dy", dy);
            // Firefox requires 'x' to be set on the first line when inside a text path
            if (i > 0 || textPath) lineNode.setAttribute("x", x);
            lineNode.className.baseVal = lineClassName;
            containerNode.appendChild(lineNode);
            offset += line.length + 1; // + 1 = newline character.
        }
        // Y Alignment calculation
        if (namedVerticalAnchor) {
            if (annotations) dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);
            else if (verticalAnchor === "top") // A shortcut for top alignment. It does not depend on font-size nor line-height
            dy = "0.8em";
            else {
                var rh; // remaining height
                if (lastI > 0) {
                    rh = parseFloat(lineHeight) || 1;
                    rh *= lastI;
                    if (!emRegex.test(lineHeight)) rh /= fontSize;
                } else // Single-line text
                rh = 0;
                switch(verticalAnchor){
                    case "middle":
                        dy = 0.3 - rh / 2 + "em";
                        break;
                    case "bottom":
                        dy = -rh - 0.3 + "em";
                        break;
                }
            }
        } else {
            if (verticalAnchor === 0) dy = "0em";
            else if (verticalAnchor) dy = verticalAnchor;
            else {
                // No vertical anchor is defined
                dy = 0;
                // Backwards compatibility - we change the `y` attribute instead of `dy`.
                if (this.attr("y") === null) this.attr("y", annotatedY || "0.8em");
            }
        }
        containerNode.firstChild.setAttribute("dy", dy);
        // Appending lines to the element.
        this.append(containerNode);
        return this;
    };
    /**
     * @public
     * @param {string} name
     * @returns {Vectorizer}
     */ VPrototype.removeAttr = function(name) {
        var qualifiedName = V.qualifyAttr(name);
        var el = this.node;
        if (qualifiedName.ns) {
            if (el.hasAttributeNS(qualifiedName.ns, qualifiedName.local)) el.removeAttributeNS(qualifiedName.ns, qualifiedName.local);
        } else if (el.hasAttribute(name)) el.removeAttribute(name);
        return this;
    };
    VPrototype.attr = function(name, value) {
        if (V.isUndefined(name)) {
            // Return all attributes.
            var attributes = this.node.attributes;
            var attrs = {};
            for(var i = 0; i < attributes.length; i++)attrs[attributes[i].name] = attributes[i].value;
            return attrs;
        }
        if (V.isString(name) && V.isUndefined(value)) return this.node.getAttribute(name);
        if (typeof name === "object") {
            for(var attrName in name)if (name.hasOwnProperty(attrName)) this.setAttribute(attrName, name[attrName]);
        } else this.setAttribute(name, value);
        return this;
    };
    VPrototype.normalizePath = function() {
        var tagName = this.tagName();
        if (tagName === "PATH") this.attr("d", V.normalizePathData(this.attr("d")));
        return this;
    };
    VPrototype.remove = function() {
        if (this.node.parentNode) this.node.parentNode.removeChild(this.node);
        return this;
    };
    VPrototype.empty = function() {
        while(this.node.firstChild)this.node.removeChild(this.node.firstChild);
        return this;
    };
    /**
     * @private
     * @param {object} attrs
     * @returns {Vectorizer}
     */ VPrototype.setAttributes = function(attrs) {
        for(var key in attrs)if (attrs.hasOwnProperty(key)) this.setAttribute(key, attrs[key]);
        return this;
    };
    VPrototype.append = function(els) {
        if (!V.isArray(els)) els = [
            els
        ];
        for(var i = 0, len = els.length; i < len; i++)this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]
        return this;
    };
    VPrototype.prepend = function(els) {
        var child = this.node.firstChild;
        return child ? V(child).before(els) : this.append(els);
    };
    VPrototype.before = function(els) {
        var node = this.node;
        var parent = node.parentNode;
        if (parent) {
            if (!V.isArray(els)) els = [
                els
            ];
            for(var i = 0, len = els.length; i < len; i++)parent.insertBefore(V.toNode(els[i]), node);
        }
        return this;
    };
    VPrototype.appendTo = function(node) {
        V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]
        return this;
    };
    VPrototype.svg = function() {
        return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);
    };
    VPrototype.tagName = function() {
        return this.node.tagName.toUpperCase();
    };
    VPrototype.defs = function() {
        var context = this.svg() || this;
        var defsNode = context.node.getElementsByTagName("defs")[0];
        if (defsNode) return V(defsNode);
        return V("defs").appendTo(context);
    };
    VPrototype.clone = function() {
        var clone = V(this.node.cloneNode(true));
        // Note that clone inherits also ID. Therefore, we need to change it here.
        clone.node.id = V.uniqueId();
        return clone;
    };
    VPrototype.findOne = function(selector) {
        var found = this.node.querySelector(selector);
        return found ? V(found) : undefined;
    };
    VPrototype.find = function(selector) {
        var vels = [];
        var nodes = this.node.querySelectorAll(selector);
        if (nodes) // Map DOM elements to `V`s.
        for(var i = 0; i < nodes.length; i++)vels.push(V(nodes[i]));
        return vels;
    };
    // Returns an array of V elements made from children of this.node.
    VPrototype.children = function() {
        var children = this.node.childNodes;
        var outputArray = [];
        for(var i = 0; i < children.length; i++){
            var currentChild = children[i];
            if (currentChild.nodeType === 1) outputArray.push(V(children[i]));
        }
        return outputArray;
    };
    // Returns the V element from parentNode of this.node.
    VPrototype.parent = function() {
        return V(this.node.parentNode) || null;
    }, // Find an index of an element inside its container.
    VPrototype.index = function() {
        var index = 0;
        var node = this.node.previousSibling;
        while(node){
            // nodeType 1 for ELEMENT_NODE
            if (node.nodeType === 1) index++;
            node = node.previousSibling;
        }
        return index;
    };
    VPrototype.findParentByClass = function(className, terminator) {
        var ownerSVGElement = this.node.ownerSVGElement;
        var node = this.node.parentNode;
        while(node && node !== terminator && node !== ownerSVGElement){
            var vel = V(node);
            if (vel.hasClass(className)) return vel;
            node = node.parentNode;
        }
        return null;
    };
    // https://jsperf.com/get-common-parent
    VPrototype.contains = function(el) {
        var a = this.node;
        var b = V.toNode(el);
        var bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && a.compareDocumentPosition(bup) & 16);
    };
    // Convert global point into the coordinate space of this element.
    VPrototype.toLocalPoint = function(x, y) {
        var svg = this.svg().node;
        var p = svg.createSVGPoint();
        p.x = x;
        p.y = y;
        try {
            var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());
            var globalToLocalMatrix = this.getTransformToElement(svg).inverse();
        } catch (e) {
            // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)
            // We have to make do with the original coordianates.
            return p;
        }
        return globalPoint.matrixTransform(globalToLocalMatrix);
    };
    VPrototype.translateCenterToPoint = function(p) {
        var bbox = this.getBBox({
            target: this.svg()
        });
        var center = bbox.center();
        this.translate(p.x - center.x, p.y - center.y);
        return this;
    };
    // Efficiently auto-orient an element. This basically implements the orient=auto attribute
    // of markers. The easiest way of understanding on what this does is to imagine the element is an
    // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while
    // being auto-oriented (properly rotated) towards the `reference` point.
    // `target` is the element relative to which the transformations are applied. Usually a viewport.
    VPrototype.translateAndAutoOrient = function(position, reference, target) {
        position = new _indexMjs.Point(position);
        reference = new _indexMjs.Point(reference);
        target || (target = this.svg());
        // Clean-up previously set transformations except the scale. If we didn't clean up the
        // previous transformations then they'd add up with the old ones. Scale is an exception as
        // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the
        // element is scaled by the factor 2, not 8.
        var scale = this.scale();
        this.attr("transform", "");
        var bbox = this.getBBox({
            target: target
        }).scale(scale.sx, scale.sy);
        // 1. Translate to origin.
        var translateToOrigin = V.createSVGTransform();
        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);
        // 2. Rotate around origin.
        var rotateAroundOrigin = V.createSVGTransform();
        var angle = position.angleBetween(reference, position.clone().offset(1, 0));
        if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);
        // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.
        var translateFromOrigin = V.createSVGTransform();
        var finalPosition = position.clone().move(reference, bbox.width / 2);
        translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);
        // 4. Get the current transformation matrix of this node
        var ctm = this.getTransformToElement(target);
        // 5. Apply transformations and the scale
        var transform = V.createSVGTransform();
        transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(scale.sx, scale.sy)))));
        this.attr("transform", V.matrixToTransformString(transform.matrix));
        return this;
    };
    VPrototype.animateAlongPath = function(attrs, path) {
        path = V.toNode(path);
        var id = V.ensureId(path);
        var animateMotion = V("animateMotion", attrs);
        var mpath = V("mpath", {
            "xlink:href": "#" + id
        });
        animateMotion.append(mpath);
        this.append(animateMotion);
        try {
            animateMotion.node.beginElement();
        } catch (e) {
            // Fallback for IE 9.
            // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present
            if (document.documentElement.getAttribute("smiling") === "fake") {
                /* global getTargets:true, Animator:true, animators:true id2anim:true */ // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)
                var animation = animateMotion.node;
                animation.animators = [];
                var animationID = animation.getAttribute("id");
                if (animationID) id2anim[animationID] = animation;
                var targets = getTargets(animation);
                for(var i = 0, len = targets.length; i < len; i++){
                    var target = targets[i];
                    var animator = new Animator(animation, target, i);
                    animators.push(animator);
                    animation.animators[i] = animator;
                    animator.register();
                }
            }
        }
        return this;
    };
    // Split a string into an array of tokens.
    // https://infra.spec.whatwg.org/#ascii-whitespace
    const noHTMLWhitespaceRegex = /[^\x20\t\r\n\f]+/g;
    function getTokenList(str) {
        if (!V.isString(str)) return [];
        return str.trim().match(noHTMLWhitespaceRegex) || [];
    }
    VPrototype.hasClass = function(className) {
        if (!V.isString(className)) return false;
        return this.node.classList.contains(className.trim());
    };
    VPrototype.addClass = function(className) {
        this.node.classList.add(...getTokenList(className));
        return this;
    };
    VPrototype.removeClass = function(className) {
        this.node.classList.remove(...getTokenList(className));
        return this;
    };
    VPrototype.toggleClass = function(className, toAdd) {
        const tokens = getTokenList(className);
        for(let i = 0; i < tokens.length; i++)this.node.classList.toggle(tokens[i], toAdd);
        return this;
    };
    // Interpolate path by discrete points. The precision of the sampling
    // is controlled by `interval`. In other words, `sample()` will generate
    // a point on the path starting at the beginning of the path going to the end
    // every `interval` pixels.
    // The sampler can be very useful for e.g. finding intersection between two
    // paths (finding the two closest points from two samples).
    VPrototype.sample = function(interval) {
        interval = interval || 1;
        var node = this.node;
        var length = node.getTotalLength();
        var samples = [];
        var distance = 0;
        var sample;
        while(distance < length){
            sample = node.getPointAtLength(distance);
            samples.push({
                x: sample.x,
                y: sample.y,
                distance: distance
            });
            distance += interval;
        }
        return samples;
    };
    VPrototype.convertToPath = function() {
        var path = V("path");
        path.attr(this.attr());
        var d = this.convertToPathData();
        if (d) path.attr("d", d);
        return path;
    };
    VPrototype.convertToPathData = function() {
        var tagName = this.tagName();
        switch(tagName){
            case "PATH":
                return this.attr("d");
            case "LINE":
                return V.convertLineToPathData(this.node);
            case "POLYGON":
                return V.convertPolygonToPathData(this.node);
            case "POLYLINE":
                return V.convertPolylineToPathData(this.node);
            case "ELLIPSE":
                return V.convertEllipseToPathData(this.node);
            case "CIRCLE":
                return V.convertCircleToPathData(this.node);
            case "RECT":
                return V.convertRectToPathData(this.node);
        }
        throw new Error(tagName + " cannot be converted to PATH.");
    };
    V.prototype.toGeometryShape = function() {
        var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;
        switch(this.tagName()){
            case "RECT":
                x = parseFloat(this.attr("x")) || 0;
                y = parseFloat(this.attr("y")) || 0;
                width = parseFloat(this.attr("width")) || 0;
                height = parseFloat(this.attr("height")) || 0;
                return new _indexMjs.Rect(x, y, width, height);
            case "CIRCLE":
                cx = parseFloat(this.attr("cx")) || 0;
                cy = parseFloat(this.attr("cy")) || 0;
                r = parseFloat(this.attr("r")) || 0;
                return new _indexMjs.Ellipse({
                    x: cx,
                    y: cy
                }, r, r);
            case "ELLIPSE":
                cx = parseFloat(this.attr("cx")) || 0;
                cy = parseFloat(this.attr("cy")) || 0;
                rx = parseFloat(this.attr("rx")) || 0;
                ry = parseFloat(this.attr("ry")) || 0;
                return new _indexMjs.Ellipse({
                    x: cx,
                    y: cy
                }, rx, ry);
            case "POLYLINE":
                points = V.getPointsFromSvgNode(this);
                return new _indexMjs.Polyline(points);
            case "POLYGON":
                points = V.getPointsFromSvgNode(this);
                if (points.length > 1) points.push(points[0]);
                return new _indexMjs.Polyline(points);
            case "PATH":
                d = this.attr("d");
                if (!_indexMjs.Path.isDataSupported(d)) d = V.normalizePathData(d);
                return new _indexMjs.Path(d);
            case "LINE":
                x1 = parseFloat(this.attr("x1")) || 0;
                y1 = parseFloat(this.attr("y1")) || 0;
                x2 = parseFloat(this.attr("x2")) || 0;
                y2 = parseFloat(this.attr("y2")) || 0;
                return new _indexMjs.Line({
                    x: x1,
                    y: y1
                }, {
                    x: x2,
                    y: y2
                });
        }
        // Anything else is a rectangle
        return this.getBBox();
    };
    // Find the intersection of a line starting in the center
    // of the SVG `node` ending in the point `ref`.
    // `target` is an SVG element to which `node`s transformations are relative to.
    // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.
    // Returns a point in the `target` coordinate system (the same system as `ref` is in) if
    // an intersection is found. Returns `undefined` otherwise.
    VPrototype.findIntersection = function(ref, target) {
        var svg = this.svg().node;
        target = target || svg;
        var bbox = this.getBBox({
            target: target
        });
        var center = bbox.center();
        if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;
        var spot;
        var tagName = this.tagName();
        // Little speed up optimization for `<rect>` element. We do not do conversion
        // to path element and sampling but directly calculate the intersection through
        // a transformed geometrical rectangle.
        if (tagName === "RECT") {
            var gRect = new _indexMjs.Rect(parseFloat(this.attr("x") || 0), parseFloat(this.attr("y") || 0), parseFloat(this.attr("width")), parseFloat(this.attr("height")));
            // Get the rect transformation matrix with regards to the SVG document.
            var rectMatrix = this.getTransformToElement(target);
            // Decompose the matrix to find the rotation angle.
            var rectMatrixComponents = V.decomposeMatrix(rectMatrix);
            // Now we want to rotate the rectangle back so that we
            // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.
            var resetRotation = svg.createSVGTransform();
            resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);
            var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));
            spot = new _indexMjs.Rect(rect).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);
        } else if (tagName === "PATH" || tagName === "POLYGON" || tagName === "POLYLINE" || tagName === "CIRCLE" || tagName === "ELLIPSE") {
            var pathNode = tagName === "PATH" ? this : this.convertToPath();
            var samples = pathNode.sample();
            var minDistance = Infinity;
            var closestSamples = [];
            var i, sample, gp, centerDistance, refDistance, distance;
            for(i = 0; i < samples.length; i++){
                sample = samples[i];
                // Convert the sample point in the local coordinate system to the global coordinate system.
                gp = V.createSVGPoint(sample.x, sample.y);
                gp = gp.matrixTransform(this.getTransformToElement(target));
                sample = new _indexMjs.Point(gp);
                centerDistance = sample.distance(center);
                // Penalize a higher distance to the reference point by 10%.
                // This gives better results. This is due to
                // inaccuracies introduced by rounding errors and getPointAtLength() returns.
                refDistance = sample.distance(ref) * 1.1;
                distance = centerDistance + refDistance;
                if (distance < minDistance) {
                    minDistance = distance;
                    closestSamples = [
                        {
                            sample: sample,
                            refDistance: refDistance
                        }
                    ];
                } else if (distance < minDistance + 1) closestSamples.push({
                    sample: sample,
                    refDistance: refDistance
                });
            }
            closestSamples.sort(function(a, b) {
                return a.refDistance - b.refDistance;
            });
            if (closestSamples[0]) spot = closestSamples[0].sample;
        }
        return spot;
    };
    /**
     * @private
     * @param {string} name
     * @param {string} value
     * @returns {Vectorizer}
     */ VPrototype.setAttribute = function(name, value) {
        var el = this.node;
        if (value === null) {
            this.removeAttr(name);
            return this;
        }
        var qualifiedName = V.qualifyAttr(name);
        if (qualifiedName.ns) // Attribute names can be namespaced. E.g. `image` elements
        // have a `xlink:href` attribute to set the source of the image.
        el.setAttributeNS(qualifiedName.ns, name, value);
        else if (name === "id") el.id = value;
        else el.setAttribute(name, value);
        return this;
    };
    // Create an SVG document element.
    // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.
    V.createSvgDocument = function(content) {
        if (content) {
            const XMLString = `<svg xmlns="${ns.svg}" xmlns:xlink="${ns.xlink}" version="${SVGVersion}">${content}</svg>`;
            const { documentElement } = V.parseXML(XMLString, {
                async: false
            });
            return documentElement;
        }
        const svg = document.createElementNS(ns.svg, "svg");
        svg.setAttributeNS(ns.xmlns, "xmlns:xlink", ns.xlink);
        svg.setAttribute("version", SVGVersion);
        return svg;
    };
    V.createSVGStyle = function(stylesheet) {
        const { node } = V("style", {
            type: "text/css"
        }, [
            V.createCDATASection(stylesheet)
        ]);
        return node;
    }, V.createCDATASection = function(data = "") {
        const xml = document.implementation.createDocument(null, "xml", null);
        return xml.createCDATASection(data);
    };
    V.idCounter = 0;
    // A function returning a unique identifier for this client session with every call.
    V.uniqueId = function() {
        return "v-" + ++V.idCounter;
    };
    V.toNode = function(el) {
        return V.isV(el) ? el.node : el.nodeName && el || el[0];
    };
    V.ensureId = function(node) {
        node = V.toNode(node);
        return node.id || (node.id = V.uniqueId());
    };
    // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).
    // IE would otherwise collapse all spaces into one. This is used in the text() method but it is
    // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests
    // when you want to compare the actual DOM text content without having to add the unicode character in
    // the place of all spaces.
    V.sanitizeText = function(text) {
        return (text || "").replace(/ /g, "\xa0");
    };
    V.isUndefined = function(value) {
        return typeof value === "undefined";
    };
    V.isString = function(value) {
        return typeof value === "string";
    };
    V.isObject = function(value) {
        return value && typeof value === "object";
    };
    V.isArray = Array.isArray;
    V.parseXML = function(data, opt) {
        opt = opt || {};
        var xml;
        try {
            var parser = new DOMParser();
            if (!V.isUndefined(opt.async)) parser.async = opt.async;
            xml = parser.parseFromString(data, "text/xml");
        } catch (error) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) throw new Error("Invalid XML: " + data);
        return xml;
    };
    /**
     * @param {string} name
     * @returns {{ns: string|null, local: string}} namespace and attribute name
     */ V.qualifyAttr = function(name) {
        if (name.indexOf(":") !== -1) {
            var combinedKey = name.split(":");
            return {
                ns: ns[combinedKey[0]],
                local: combinedKey[1]
            };
        }
        return {
            ns: null,
            local: name
        };
    };
    // Note: This regex allows multiple commas as separator which is incorrect in SVG
    // This regex is used by `split()`, so it doesn't need to use /g
    V.transformSeparatorRegex = /[ ,]+/;
    // Note: All following regexes are more restrictive than SVG specification
    // ReDoS mitigation: Use an anchor at the beginning of the match
    // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)
    // ReDoS mitigation: Don't match initial `(` inside repeated part
    // The following regex needs to use /g (= cannot use capturing groups)
    V.transformRegex = /\b\w+\([^()]+\)/g;
    // The following regexes need to use capturing groups (= cannot use /g)
    V.transformFunctionRegex = /\b(\w+)\(([^()]+)\)/;
    V.transformTranslateRegex = /\btranslate\(([^()]+)\)/;
    V.transformRotateRegex = /\brotate\(([^()]+)\)/;
    V.transformScaleRegex = /\bscale\(([^()]+)\)/;
    V.transformStringToMatrix = function(transform) {
        // Initialize result matrix as identity matrix
        let transformationMatrix = V.createSVGMatrix();
        // Note: Multiple transform functions are allowed in `transform` string
        // `match()` returns `null` if none found
        const transformMatches = transform && transform.match(V.transformRegex);
        if (!transformMatches) // Return identity matrix
        return transformationMatrix;
        const numMatches = transformMatches.length;
        for(let i = 0; i < numMatches; i++){
            const transformMatch = transformMatches[i];
            // Use same regex as above, but with capturing groups
            // `match()` returns values of capturing groups as `[1]`, `[2]`
            const transformFunctionMatch = transformMatch.match(V.transformFunctionRegex);
            if (transformFunctionMatch) {
                let sx, sy, tx, ty, angle;
                let ctm = V.createSVGMatrix();
                const transformFunction = transformFunctionMatch[1].toLowerCase();
                const args = transformFunctionMatch[2].split(V.transformSeparatorRegex);
                switch(transformFunction){
                    case "scale":
                        sx = parseFloat(args[0]);
                        sy = args[1] === undefined ? sx : parseFloat(args[1]);
                        ctm = ctm.scaleNonUniform(sx, sy);
                        break;
                    case "translate":
                        tx = parseFloat(args[0]);
                        ty = parseFloat(args[1]);
                        ctm = ctm.translate(tx, ty);
                        break;
                    case "rotate":
                        angle = parseFloat(args[0]);
                        tx = parseFloat(args[1]) || 0;
                        ty = parseFloat(args[2]) || 0;
                        if (tx !== 0 || ty !== 0) ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);
                        else ctm = ctm.rotate(angle);
                        break;
                    case "skewx":
                        angle = parseFloat(args[0]);
                        ctm = ctm.skewX(angle);
                        break;
                    case "skewy":
                        angle = parseFloat(args[0]);
                        ctm = ctm.skewY(angle);
                        break;
                    case "matrix":
                        ctm.a = parseFloat(args[0]);
                        ctm.b = parseFloat(args[1]);
                        ctm.c = parseFloat(args[2]);
                        ctm.d = parseFloat(args[3]);
                        ctm.e = parseFloat(args[4]);
                        ctm.f = parseFloat(args[5]);
                        break;
                    default:
                        continue;
                }
                // Multiply current transformation into result matrix
                transformationMatrix = transformationMatrix.multiply(ctm);
            }
        }
        return transformationMatrix;
    };
    V.matrixToTransformString = function(matrix) {
        matrix || (matrix = true);
        return "matrix(" + (matrix.a !== undefined ? matrix.a : 1) + "," + (matrix.b !== undefined ? matrix.b : 0) + "," + (matrix.c !== undefined ? matrix.c : 0) + "," + (matrix.d !== undefined ? matrix.d : 1) + "," + (matrix.e !== undefined ? matrix.e : 0) + "," + (matrix.f !== undefined ? matrix.f : 0) + ")";
    };
    V.parseTransformString = function(transform) {
        var translate, rotate, scale;
        if (transform) {
            var separator = V.transformSeparatorRegex;
            // Special handling for `transform` with one or more matrix functions
            if (transform.trim().indexOf("matrix") >= 0) {
                // Convert EVERYTHING in `transform` string to a matrix
                // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates
                // Note: In non-matrix case, we only take first one of each (if any)
                var matrix = V.transformStringToMatrix(transform);
                var decomposedMatrix = V.decomposeMatrix(matrix);
                // Extract `translate`, `scale`, `rotate` from matrix
                translate = [
                    decomposedMatrix.translateX,
                    decomposedMatrix.translateY
                ];
                scale = [
                    decomposedMatrix.scaleX,
                    decomposedMatrix.scaleY
                ];
                rotate = [
                    decomposedMatrix.rotation
                ];
                // Rewrite `transform` string in `translate scale rotate` format
                var transformations = [];
                if (translate[0] !== 0 || translate[1] !== 0) transformations.push("translate(" + translate + ")");
                if (scale[0] !== 1 || scale[1] !== 1) transformations.push("scale(" + scale + ")");
                if (rotate[0] !== 0) transformations.push("rotate(" + rotate + ")");
                transform = transformations.join(" ");
            } else {
                // Extract `translate`, `rotate`, `scale` functions from `transform` string
                // Note: We only detect the first match of each (if any)
                // `match()` returns value of capturing group as `[1]`
                const translateMatch = transform.match(V.transformTranslateRegex);
                if (translateMatch) translate = translateMatch[1].split(separator);
                const rotateMatch = transform.match(V.transformRotateRegex);
                if (rotateMatch) rotate = rotateMatch[1].split(separator);
                const scaleMatch = transform.match(V.transformScaleRegex);
                if (scaleMatch) scale = scaleMatch[1].split(separator);
            }
        }
        var sx = scale && scale[0] ? parseFloat(scale[0]) : 1;
        return {
            value: transform,
            translate: {
                tx: translate && translate[0] ? parseInt(translate[0], 10) : 0,
                ty: translate && translate[1] ? parseInt(translate[1], 10) : 0
            },
            rotate: {
                angle: rotate && rotate[0] ? parseInt(rotate[0], 10) : 0,
                cx: rotate && rotate[1] ? parseInt(rotate[1], 10) : undefined,
                cy: rotate && rotate[2] ? parseInt(rotate[2], 10) : undefined
            },
            scale: {
                sx: sx,
                sy: scale && scale[1] ? parseFloat(scale[1]) : sx
            }
        };
    };
    V.deltaTransformPoint = function(matrix, point) {
        var dx = point.x * matrix.a + point.y * matrix.c + 0;
        var dy = point.x * matrix.b + point.y * matrix.d + 0;
        return {
            x: dx,
            y: dy
        };
    };
    V.decomposeMatrix = function(matrix) {
        // @see https://gist.github.com/2052247
        // calculate delta transform point
        var px = V.deltaTransformPoint(matrix, {
            x: 0,
            y: 1
        });
        var py = V.deltaTransformPoint(matrix, {
            x: 1,
            y: 0
        });
        // calculate skew
        var skewX = 180 / PI * atan2(px.y, px.x) - 90;
        var skewY = 180 / PI * atan2(py.y, py.x);
        return {
            translateX: matrix.e,
            translateY: matrix.f,
            scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
            scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
            skewX: skewX,
            skewY: skewY,
            rotation: skewX // rotation is the same as skew x
        };
    };
    // Return the `scale` transformation from the following equation:
    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`
    V.matrixToScale = function(matrix) {
        var a, b, c, d;
        if (matrix) {
            a = V.isUndefined(matrix.a) ? 1 : matrix.a;
            d = V.isUndefined(matrix.d) ? 1 : matrix.d;
            b = matrix.b;
            c = matrix.c;
        } else a = d = 1;
        return {
            sx: b ? sqrt(a * a + b * b) : a,
            sy: c ? sqrt(c * c + d * d) : d
        };
    };
    // Return the `rotate` transformation from the following equation:
    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`
    V.matrixToRotate = function(matrix) {
        var p = {
            x: 0,
            y: 1
        };
        if (matrix) p = V.deltaTransformPoint(matrix, p);
        return {
            angle: _indexMjs.normalizeAngle(_indexMjs.toDeg(atan2(p.y, p.x)) - 90)
        };
    };
    // Return the `translate` transformation from the following equation:
    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`
    V.matrixToTranslate = function(matrix) {
        return {
            tx: matrix && matrix.e || 0,
            ty: matrix && matrix.f || 0
        };
    };
    V.isV = function(object) {
        return object instanceof V;
    };
    // For backwards compatibility:
    V.isVElement = V.isV;
    // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`
    // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement
    V.isSVGGraphicsElement = function(node) {
        if (!node) return false;
        node = V.toNode(node);
        // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below
        return node instanceof SVGElement && typeof node.getScreenCTM === "function";
    };
    var svgDocument = V("svg").node;
    V.createSVGMatrix = function(matrix) {
        var svgMatrix = svgDocument.createSVGMatrix();
        for(var component in matrix)svgMatrix[component] = matrix[component];
        return svgMatrix;
    };
    V.createSVGTransform = function(matrix) {
        if (!V.isUndefined(matrix)) {
            if (!(matrix instanceof SVGMatrix)) matrix = V.createSVGMatrix(matrix);
            return svgDocument.createSVGTransformFromMatrix(matrix);
        }
        return svgDocument.createSVGTransform();
    };
    V.createSVGPoint = function(x, y) {
        var p = svgDocument.createSVGPoint();
        p.x = x;
        p.y = y;
        return p;
    };
    V.transformRect = function(r, matrix) {
        var p = svgDocument.createSVGPoint();
        p.x = r.x;
        p.y = r.y;
        var corner1 = p.matrixTransform(matrix);
        p.x = r.x + r.width;
        p.y = r.y;
        var corner2 = p.matrixTransform(matrix);
        p.x = r.x + r.width;
        p.y = r.y + r.height;
        var corner3 = p.matrixTransform(matrix);
        p.x = r.x;
        p.y = r.y + r.height;
        var corner4 = p.matrixTransform(matrix);
        var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);
        var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);
        var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);
        var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);
        return new _indexMjs.Rect(minX, minY, maxX - minX, maxY - minY);
    };
    V.transformPoint = function(p, matrix) {
        return new _indexMjs.Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));
    };
    V.transformLine = function(l, matrix) {
        return new _indexMjs.Line(V.transformPoint(l.start, matrix), V.transformPoint(l.end, matrix));
    };
    V.transformPolyline = function(p, matrix) {
        var inPoints = p instanceof _indexMjs.Polyline ? p.points : p;
        if (!V.isArray(inPoints)) inPoints = [];
        var outPoints = [];
        for(var i = 0, n = inPoints.length; i < n; i++)outPoints[i] = V.transformPoint(inPoints[i], matrix);
        return new _indexMjs.Polyline(outPoints);
    };
    // Convert a style represented as string (e.g. `'fill="blue"; stroke="red"'`) to
    // an object (`{ fill: 'blue', stroke: 'red' }`).
    V.styleToObject = function(styleString) {
        var ret = {};
        var styles = styleString.split(";");
        for(var i = 0; i < styles.length; i++){
            var style = styles[i];
            var pair = style.split("=");
            ret[pair[0].trim()] = pair[1].trim();
        }
        return ret;
    };
    // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js
    V.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {
        var svgArcMax = 2 * PI - 1e-6;
        var r0 = innerRadius;
        var r1 = outerRadius;
        var a0 = startAngle;
        var a1 = endAngle;
        var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);
        var df = da < PI ? "0" : "1";
        var c0 = cos(a0);
        var s0 = sin(a0);
        var c1 = cos(a1);
        var s1 = sin(a1);
        return da >= svgArcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z";
    };
    // Merge attributes from object `b` with attributes in object `a`.
    // Note that this modifies the object `a`.
    // Also important to note that attributes are merged but CSS classes are concatenated.
    V.mergeAttrs = function(a, b) {
        for(var attr in b){
            if (attr === "class") // Concatenate classes.
            a[attr] = a[attr] ? a[attr] + " " + b[attr] : b[attr];
            else if (attr === "style") {
                // `style` attribute can be an object.
                if (V.isObject(a[attr]) && V.isObject(b[attr])) // `style` stored in `a` is an object.
                a[attr] = V.mergeAttrs(a[attr], b[attr]);
                else if (V.isObject(a[attr])) // `style` in `a` is an object but it's a string in `b`.
                // Convert the style represented as a string to an object in `b`.
                a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));
                else if (V.isObject(b[attr])) // `style` in `a` is a string, in `b` it's an object.
                a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);
                else // Both styles are strings.
                a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));
            } else a[attr] = b[attr];
        }
        return a;
    };
    V.annotateString = function(t, annotations, opt) {
        annotations = annotations || [];
        opt = opt || {};
        var offset = opt.offset || 0;
        var compacted = [];
        var batch;
        var ret = [];
        var item;
        var prev;
        for(var i = 0; i < t.length; i++){
            item = ret[i] = t[i];
            for(var j = 0; j < annotations.length; j++){
                var annotation = annotations[j];
                var start = annotation.start + offset;
                var end = annotation.end + offset;
                if (i >= start && i < end) {
                    // Annotation applies.
                    if (V.isObject(item)) // There is more than one annotation to be applied => Merge attributes.
                    item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);
                    else item = ret[i] = {
                        t: t[i],
                        attrs: annotation.attrs
                    };
                    if (opt.includeAnnotationIndices) (item.annotations || (item.annotations = [])).push(j);
                }
            }
            prev = ret[i - 1];
            if (!prev) batch = item;
            else if (V.isObject(item) && V.isObject(prev)) {
                // Both previous item and the current one are annotations. If the attributes
                // didn't change, merge the text.
                if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) batch.t += item.t;
                else {
                    compacted.push(batch);
                    batch = item;
                }
            } else if (V.isObject(item)) {
                // Previous item was a string, current item is an annotation.
                compacted.push(batch);
                batch = item;
            } else if (V.isObject(prev)) {
                // Previous item was an annotation, current item is a string.
                compacted.push(batch);
                batch = item;
            } else // Both previous and current item are strings.
            batch = (batch || "") + item;
        }
        if (batch) compacted.push(batch);
        return compacted;
    };
    V.findAnnotationsAtIndex = function(annotations, index) {
        var found = [];
        if (annotations) annotations.forEach(function(annotation) {
            if (annotation.start < index && index <= annotation.end) found.push(annotation);
        });
        return found;
    };
    V.findAnnotationsBetweenIndexes = function(annotations, start, end) {
        var found = [];
        if (annotations) annotations.forEach(function(annotation) {
            if (start >= annotation.start && start < annotation.end || end > annotation.start && end <= annotation.end || annotation.start >= start && annotation.end < end) found.push(annotation);
        });
        return found;
    };
    // Shift all the text annotations after character `index` by `offset` positions.
    V.shiftAnnotations = function(annotations, index, offset) {
        if (annotations) annotations.forEach(function(annotation) {
            if (annotation.start < index && annotation.end >= index) annotation.end += offset;
            else if (annotation.start >= index) {
                annotation.start += offset;
                annotation.end += offset;
            }
        });
        return annotations;
    };
    V.convertLineToPathData = function(line) {
        line = V(line);
        var d = [
            "M",
            line.attr("x1"),
            line.attr("y1"),
            "L",
            line.attr("x2"),
            line.attr("y2")
        ].join(" ");
        return d;
    };
    V.convertPolygonToPathData = function(polygon) {
        var points = V.getPointsFromSvgNode(polygon);
        if (points.length === 0) return null;
        return V.svgPointsToPath(points) + " Z";
    };
    V.convertPolylineToPathData = function(polyline) {
        var points = V.getPointsFromSvgNode(polyline);
        if (points.length === 0) return null;
        return V.svgPointsToPath(points);
    };
    V.svgPointsToPath = function(points) {
        for(var i = 0, n = points.length; i < n; i++)points[i] = points[i].x + " " + points[i].y;
        return "M " + points.join(" L");
    };
    V.getPointsFromSvgNode = function(node) {
        node = V.toNode(node);
        var points = [];
        var nodePoints = node.points;
        if (nodePoints) for(var i = 0, n = nodePoints.numberOfItems; i < n; i++)points.push(nodePoints.getItem(i));
        return points;
    };
    V.KAPPA = 0.551784;
    V.convertCircleToPathData = function(circle) {
        circle = V(circle);
        var cx = parseFloat(circle.attr("cx")) || 0;
        var cy = parseFloat(circle.attr("cy")) || 0;
        var r = parseFloat(circle.attr("r"));
        var cd = r * V.KAPPA; // Control distance.
        var d = [
            "M",
            cx,
            cy - r,
            "C",
            cx + cd,
            cy - r,
            cx + r,
            cy - cd,
            cx + r,
            cy,
            "C",
            cx + r,
            cy + cd,
            cx + cd,
            cy + r,
            cx,
            cy + r,
            "C",
            cx - cd,
            cy + r,
            cx - r,
            cy + cd,
            cx - r,
            cy,
            "C",
            cx - r,
            cy - cd,
            cx - cd,
            cy - r,
            cx,
            cy - r,
            "Z"
        ].join(" ");
        return d;
    };
    V.convertEllipseToPathData = function(ellipse) {
        ellipse = V(ellipse);
        var cx = parseFloat(ellipse.attr("cx")) || 0;
        var cy = parseFloat(ellipse.attr("cy")) || 0;
        var rx = parseFloat(ellipse.attr("rx"));
        var ry = parseFloat(ellipse.attr("ry")) || rx;
        var cdx = rx * V.KAPPA; // Control distance x.
        var cdy = ry * V.KAPPA; // Control distance y.
        var d = [
            "M",
            cx,
            cy - ry,
            "C",
            cx + cdx,
            cy - ry,
            cx + rx,
            cy - cdy,
            cx + rx,
            cy,
            "C",
            cx + rx,
            cy + cdy,
            cx + cdx,
            cy + ry,
            cx,
            cy + ry,
            "C",
            cx - cdx,
            cy + ry,
            cx - rx,
            cy + cdy,
            cx - rx,
            cy,
            "C",
            cx - rx,
            cy - cdy,
            cx - cdx,
            cy - ry,
            cx,
            cy - ry,
            "Z"
        ].join(" ");
        return d;
    };
    V.convertRectToPathData = function(rect) {
        rect = V(rect);
        return V.rectToPath({
            x: parseFloat(rect.attr("x")) || 0,
            y: parseFloat(rect.attr("y")) || 0,
            width: parseFloat(rect.attr("width")) || 0,
            height: parseFloat(rect.attr("height")) || 0,
            rx: parseFloat(rect.attr("rx")) || 0,
            ry: parseFloat(rect.attr("ry")) || 0
        });
    };
    // Convert a rectangle to SVG path commands. `r` is an object of the form:
    // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,
    // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for
    // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle
    // that has only `rx` and `ry` attributes).
    V.rectToPath = function(r) {
        var d;
        var x = r.x;
        var y = r.y;
        var width = r.width;
        var height = r.height;
        var topRx = min(r.rx || r["top-rx"] || 0, width / 2);
        var bottomRx = min(r.rx || r["bottom-rx"] || 0, width / 2);
        var topRy = min(r.ry || r["top-ry"] || 0, height / 2);
        var bottomRy = min(r.ry || r["bottom-ry"] || 0, height / 2);
        if (topRx || bottomRx || topRy || bottomRy) d = [
            "M",
            x,
            y + topRy,
            "v",
            height - topRy - bottomRy,
            "a",
            bottomRx,
            bottomRy,
            0,
            0,
            0,
            bottomRx,
            bottomRy,
            "h",
            width - 2 * bottomRx,
            "a",
            bottomRx,
            bottomRy,
            0,
            0,
            0,
            bottomRx,
            -bottomRy,
            "v",
            -(height - bottomRy - topRy),
            "a",
            topRx,
            topRy,
            0,
            0,
            0,
            -topRx,
            -topRy,
            "h",
            -(width - 2 * topRx),
            "a",
            topRx,
            topRy,
            0,
            0,
            0,
            -topRx,
            topRy,
            "Z"
        ];
        else d = [
            "M",
            x,
            y,
            "H",
            x + width,
            "V",
            y + height,
            "H",
            x,
            "V",
            y,
            "Z"
        ];
        return d.join(" ");
    };
    // Take a path data string
    // Return a normalized path data string
    // If data cannot be parsed, return 'M 0 0'
    // Adapted from Rappid normalizePath polyfill
    // Highly inspired by Raphael Library (www.raphael.com)
    V.normalizePathData = function() {
        var spaces = "	\n\v\f\r \xa0·öÄ·†é‚ÄÄ‚ÄÅ‚ÄÇ‚ÄÉ‚ÄÑ‚ÄÖ‚ÄÜ‚Äá‚Äà‚Äâ‚Ää‚ÄØ‚Åü„ÄÄ\u2028\u2029";
        var pathCommand = new RegExp("([a-z])[" + spaces + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + spaces + "]*,?[" + spaces + "]*)+)", "ig");
        var pathValues = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + spaces + "]*,?[" + spaces + "]*", "ig");
        var math = Math;
        var PI = math.PI;
        var sin = math.sin;
        var cos = math.cos;
        var tan = math.tan;
        var asin = math.asin;
        var sqrt = math.sqrt;
        var abs = math.abs;
        function q2c(x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3;
            var _23 = 2 / 3;
            return [
                _13 * x1 + _23 * ax,
                _13 * y1 + _23 * ay,
                _13 * x2 + _23 * ax,
                _13 * y2 + _23 * ay,
                x2,
                y2
            ];
        }
        function rotate(x, y, rad) {
            var X = x * cos(rad) - y * sin(rad);
            var Y = x * sin(rad) + y * cos(rad);
            return {
                x: X,
                y: Y
            };
        }
        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180;
            var rad = PI / 180 * (+angle || 0);
            var res = [];
            var xy;
            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                var x = (x1 - x2) / 2;
                var y = (y1 - y2) / 2;
                var h = x * x / (rx * rx) + y * y / (ry * ry);
                if (h > 1) {
                    h = sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                var rx2 = rx * rx;
                var ry2 = ry * ry;
                var k = (large_arc_flag == sweep_flag ? -1 : 1) * sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
                var cx = k * rx * y / ry + (x1 + x2) / 2;
                var cy = k * -ry * x / rx + (y1 + y2) / 2;
                var f1 = asin(((y1 - cy) / ry).toFixed(9));
                var f2 = asin(((y2 - cy) / ry).toFixed(9));
                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                if (f1 < 0) f1 = PI * 2 + f1;
                if (f2 < 0) f2 = PI * 2 + f2;
                if (sweep_flag && f1 > f2) f1 = f1 - PI * 2;
                if (!sweep_flag && f2 > f1) f2 = f2 - PI * 2;
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs(df) > _120) {
                var f2old = f2;
                var x2old = x2;
                var y2old = y2;
                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * cos(f2);
                y2 = cy + ry * sin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
                    f2,
                    f2old,
                    cx,
                    cy
                ]);
            }
            df = f2 - f1;
            var c1 = cos(f1);
            var s1 = sin(f1);
            var c2 = cos(f2);
            var s2 = sin(f2);
            var t = tan(df / 4);
            var hx = 4 / 3 * (rx * t);
            var hy = 4 / 3 * (ry * t);
            var m1 = [
                x1,
                y1
            ];
            var m2 = [
                x1 + hx * s1,
                y1 - hy * c1
            ];
            var m3 = [
                x2 + hx * s2,
                y2 - hy * c2
            ];
            var m4 = [
                x2,
                y2
            ];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) return [
                m2,
                m3,
                m4
            ].concat(res);
            else {
                res = [
                    m2,
                    m3,
                    m4
                ].concat(res).join().split(",");
                var newres = [];
                var ii = res.length;
                for(var i = 0; i < ii; i++)newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                return newres;
            }
        }
        function parsePathString(pathString) {
            if (!pathString) return null;
            var paramCounts = {
                a: 7,
                c: 6,
                h: 1,
                l: 2,
                m: 2,
                q: 4,
                s: 4,
                t: 2,
                v: 1,
                z: 0
            };
            var data = [];
            String(pathString).replace(pathCommand, function(a, b, c) {
                var params = [];
                var name = b.toLowerCase();
                c.replace(pathValues, function(a, b) {
                    if (b) params.push(+b);
                });
                if (name === "m" && params.length > 2) {
                    data.push([
                        b
                    ].concat(params.splice(0, 2)));
                    name = "l";
                    b = b === "m" ? "l" : "L";
                }
                while(params.length >= paramCounts[name]){
                    data.push([
                        b
                    ].concat(params.splice(0, paramCounts[name])));
                    if (!paramCounts[name]) break;
                }
            });
            return data;
        }
        function pathToAbsolute(pathArray) {
            if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) pathArray = parsePathString(pathArray);
            // if invalid string, return 'M 0 0'
            if (!pathArray || !pathArray.length) return [
                [
                    "M",
                    0,
                    0
                ]
            ];
            var res = [];
            var x = 0;
            var y = 0;
            var mx = 0;
            var my = 0;
            var start = 0;
            var pa0;
            var ii = pathArray.length;
            for(var i = start; i < ii; i++){
                var r = [];
                res.push(r);
                var pa = pathArray[i];
                pa0 = pa[0];
                if (pa0 != pa0.toUpperCase()) {
                    r[0] = pa0.toUpperCase();
                    var jj;
                    var j;
                    switch(r[0]){
                        case "A":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +pa[6] + x;
                            r[7] = +pa[7] + y;
                            break;
                        case "V":
                            r[1] = +pa[1] + y;
                            break;
                        case "H":
                            r[1] = +pa[1] + x;
                            break;
                        case "M":
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                            jj = pa.length;
                            for(j = 1; j < jj; j++)r[j] = +pa[j] + (j % 2 ? x : y);
                            break;
                        default:
                            jj = pa.length;
                            for(j = 1; j < jj; j++)r[j] = +pa[j] + (j % 2 ? x : y);
                            break;
                    }
                } else {
                    var kk = pa.length;
                    for(var k = 0; k < kk; k++)r[k] = pa[k];
                }
                switch(r[0]){
                    case "Z":
                        x = +mx;
                        y = +my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                        break;
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                        break;
                }
            }
            return res;
        }
        function normalize(path) {
            var p = pathToAbsolute(path);
            var attrs = {
                x: 0,
                y: 0,
                bx: 0,
                by: 0,
                X: 0,
                Y: 0,
                qx: null,
                qy: null
            };
            function processPath(path, d, pcom) {
                var nx, ny;
                if (!path) return [
                    "C",
                    d.x,
                    d.y,
                    d.x,
                    d.y,
                    d.x,
                    d.y
                ];
                if (!(path[0] in {
                    T: 1,
                    Q: 1
                })) {
                    d.qx = null;
                    d.qy = null;
                }
                switch(path[0]){
                    case "M":
                        d.X = path[1];
                        d.Y = path[2];
                        break;
                    case "A":
                        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters
                        // "If either rx or ry is 0, then this arc is treated as a
                        // straight line segment (a "lineto") joining the endpoints."
                        path = [
                            "L",
                            path[6],
                            path[7]
                        ];
                        else path = [
                            "C"
                        ].concat(a2c.apply(0, [
                            d.x,
                            d.y
                        ].concat(path.slice(1))));
                        break;
                    case "S":
                        if (pcom === "C" || pcom === "S") {
                            nx = d.x * 2 - d.bx; // And reflect the previous
                            ny = d.y * 2 - d.by; // command's control point relative to the current point.
                        } else {
                            nx = d.x;
                            ny = d.y;
                        }
                        path = [
                            "C",
                            nx,
                            ny
                        ].concat(path.slice(1));
                        break;
                    case "T":
                        if (pcom === "Q" || pcom === "T") {
                            d.qx = d.x * 2 - d.qx; // And make a reflection similar
                            d.qy = d.y * 2 - d.qy; // to case 'S'.
                        } else {
                            d.qx = d.x;
                            d.qy = d.y;
                        }
                        path = [
                            "C"
                        ].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                        break;
                    case "Q":
                        d.qx = path[1];
                        d.qy = path[2];
                        path = [
                            "C"
                        ].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                        break;
                    case "H":
                        path = [
                            "L"
                        ].concat(path[1], d.y);
                        break;
                    case "V":
                        path = [
                            "L"
                        ].concat(d.x, path[1]);
                        break;
                    case "L":
                        break;
                    case "Z":
                        break;
                }
                return path;
            }
            function fixArc(pp, i) {
                if (pp[i].length > 7) {
                    pp[i].shift();
                    var pi = pp[i];
                    while(pi.length){
                        pcoms[i] = "A"; // if created multiple 'C's, their original seg is saved
                        pp.splice(i++, 0, [
                            "C"
                        ].concat(pi.splice(0, 6)));
                    }
                    pp.splice(i, 1);
                    ii = p.length;
                }
            }
            var pcoms = []; // path commands of original path p
            var pfirst = ""; // temporary holder for original path command
            var pcom = ""; // holder for previous path command of original path
            var ii = p.length;
            for(var i = 0; i < ii; i++){
                if (p[i]) pfirst = p[i][0]; // save current path command
                if (pfirst !== "C") {
                    pcoms[i] = pfirst; // Save current path command
                    if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom
                }
                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath
                if (pcoms[i] !== "A" && pfirst === "C") pcoms[i] = "C"; // 'A' is the only command
                // which may produce multiple 'C's
                // so we have to make sure that 'C' is also 'C' in original path
                fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms
                var seg = p[i];
                var seglen = seg.length;
                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
            }
            // make sure normalized path data string starts with an M segment
            if (!p[0][0] || p[0][0] !== "M") p.unshift([
                "M",
                0,
                0
            ]);
            return p;
        }
        return function(pathData) {
            return normalize(pathData).join(",").split(",").join(" ");
        };
    }();
    V.namespace = ns;
    V.g = _indexMjs;
    return V;
}();
exports.default = V;

},{"../g/index.mjs":"i91Db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i91Db":[function(require,module,exports) {
// Geometry library.
// -----------------
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "intersection", ()=>intersection);
var _geometryHelpersMjs = require("./geometry.helpers.mjs");
parcelHelpers.exportAll(_geometryHelpersMjs, exports);
var _bezierMjs = require("./bezier.mjs");
parcelHelpers.exportAll(_bezierMjs, exports);
var _curveMjs = require("./curve.mjs");
parcelHelpers.exportAll(_curveMjs, exports);
var _ellipseMjs = require("./ellipse.mjs");
parcelHelpers.exportAll(_ellipseMjs, exports);
var _lineMjs = require("./line.mjs");
parcelHelpers.exportAll(_lineMjs, exports);
var _pathMjs = require("./path.mjs");
parcelHelpers.exportAll(_pathMjs, exports);
var _pointMjs = require("./point.mjs");
parcelHelpers.exportAll(_pointMjs, exports);
var _polylineMjs = require("./polyline.mjs");
parcelHelpers.exportAll(_polylineMjs, exports);
var _polygonMjs = require("./polygon.mjs");
parcelHelpers.exportAll(_polygonMjs, exports);
var _rectMjs = require("./rect.mjs");
parcelHelpers.exportAll(_rectMjs, exports);
var _typesMjs = require("./types.mjs");
parcelHelpers.exportAll(_typesMjs, exports);
var _intersectionMjs = require("./intersection.mjs");
const intersection = _intersectionMjs;

},{"./geometry.helpers.mjs":"cjTph","./bezier.mjs":"5CljX","./curve.mjs":"4kW90","./ellipse.mjs":"fjvxW","./line.mjs":"f7trh","./path.mjs":"1WHnT","./point.mjs":"7vrrP","./polyline.mjs":"8d0If","./polygon.mjs":"6G1L0","./rect.mjs":"6MvV7","./types.mjs":"217db","./intersection.mjs":"1nOFs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cjTph":[function(require,module,exports) {
// Declare shorthands to the most used math functions.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scale", ()=>scale);
parcelHelpers.export(exports, "normalizeAngle", ()=>normalizeAngle);
parcelHelpers.export(exports, "snapToGrid", ()=>snapToGrid);
parcelHelpers.export(exports, "toDeg", ()=>toDeg);
parcelHelpers.export(exports, "toRad", ()=>toRad);
parcelHelpers.export(exports, "random", ()=>random);
const { round, floor, PI } = Math;
const scale = {
    // Return the `value` from the `domain` interval scaled to the `range` interval.
    linear: function(domain, range, value) {
        var domainSpan = domain[1] - domain[0];
        var rangeSpan = range[1] - range[0];
        return (value - domain[0]) / domainSpan * rangeSpan + range[0] || 0;
    }
};
const normalizeAngle = function(angle) {
    return angle % 360 + (angle < 0 ? 360 : 0);
};
const snapToGrid = function(value, gridSize) {
    return gridSize * round(value / gridSize);
};
const toDeg = function(rad) {
    return 180 * rad / PI % 360;
};
const toRad = function(deg, over360) {
    over360 = over360 || false;
    deg = over360 ? deg : deg % 360;
    return deg * PI / 180;
};
const random = function(min, max) {
    if (max === undefined) {
        // use first argument as max, min is 0
        max = min === undefined ? 1 : min;
        min = 0;
    } else if (max < min) {
        // switch max and min
        const temp = min;
        min = max;
        max = temp;
    }
    return floor(Math.random() * (max - min + 1) + min);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5CljX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bezier", ()=>bezier);
var _pathMjs = require("./path.mjs");
var _curveMjs = require("./curve.mjs");
var _pointMjs = require("./point.mjs");
const bezier = {
    // Cubic Bezier curve path through points.
    // @deprecated
    // @param {array} points Array of points through which the smooth line will go.
    // @return {array} SVG Path commands as an array
    curveThroughPoints: function(points) {
        console.warn("deprecated");
        return new (0, _pathMjs.Path)((0, _curveMjs.Curve).throughPoints(points)).serialize();
    },
    // Get open-ended Bezier Spline Control Points.
    // @deprecated
    // @param knots Input Knot Bezier spline points (At least two points!).
    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.
    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.
    getCurveControlPoints: function(knots) {
        console.warn("deprecated");
        var firstControlPoints = [];
        var secondControlPoints = [];
        var n = knots.length - 1;
        var i;
        // Special case: Bezier curve should be a straight line.
        if (n == 1) {
            // 3P1 = 2P0 + P3
            firstControlPoints[0] = new (0, _pointMjs.Point)((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);
            // P2 = 2P1 ‚Äì P0
            secondControlPoints[0] = new (0, _pointMjs.Point)(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
            return [
                firstControlPoints,
                secondControlPoints
            ];
        }
        // Calculate first Bezier control points.
        // Right hand side vector.
        var rhs = [];
        // Set right hand side X values.
        for(i = 1; i < n - 1; i++)rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
        rhs[0] = knots[0].x + 2 * knots[1].x;
        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;
        // Get first control points X-values.
        var x = this.getFirstControlPoints(rhs);
        // Set right hand side Y values.
        for(i = 1; i < n - 1; ++i)rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;
        rhs[0] = knots[0].y + 2 * knots[1].y;
        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;
        // Get first control points Y-values.
        var y = this.getFirstControlPoints(rhs);
        // Fill output arrays.
        for(i = 0; i < n; i++){
            // First control point.
            firstControlPoints.push(new (0, _pointMjs.Point)(x[i], y[i]));
            // Second control point.
            if (i < n - 1) secondControlPoints.push(new (0, _pointMjs.Point)(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));
            else secondControlPoints.push(new (0, _pointMjs.Point)((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
        }
        return [
            firstControlPoints,
            secondControlPoints
        ];
    },
    // Divide a Bezier curve into two at point defined by value 't' <0,1>.
    // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867
    // @deprecated
    // @param control points (start, control start, control end, end)
    // @return a function that accepts t and returns 2 curves.
    getCurveDivider: function(p0, p1, p2, p3) {
        console.warn("deprecated");
        var curve = new (0, _curveMjs.Curve)(p0, p1, p2, p3);
        return function divideCurve(t) {
            var divided = curve.divide(t);
            return [
                {
                    p0: divided[0].start,
                    p1: divided[0].controlPoint1,
                    p2: divided[0].controlPoint2,
                    p3: divided[0].end
                },
                {
                    p0: divided[1].start,
                    p1: divided[1].controlPoint1,
                    p2: divided[1].controlPoint2,
                    p3: divided[1].end
                }
            ];
        };
    },
    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.
    // @deprecated
    // @param rhs Right hand side vector.
    // @return Solution vector.
    getFirstControlPoints: function(rhs) {
        console.warn("deprecated");
        var n = rhs.length;
        // `x` is a solution vector.
        var x = [];
        var tmp = [];
        var b = 2.0;
        x[0] = rhs[0] / b;
        // Decomposition and forward substitution.
        for(var i = 1; i < n; i++){
            tmp[i] = 1 / b;
            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];
            x[i] = (rhs[i] - x[i - 1]) / b;
        }
        for(i = 1; i < n; i++)// Backsubstitution.
        x[n - i - 1] -= tmp[n - i] * x[n - i];
        return x;
    },
    // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on
    // a parametric curve x = x(t)/w(t), y = y(t)/w(t), Ô¨Ånd the parameter value t
    // which corresponds to that point.
    // @deprecated
    // @param control points (start, control start, control end, end)
    // @return a function that accepts a point and returns t.
    getInversionSolver: function(p0, p1, p2, p3) {
        console.warn("deprecated");
        var curve = new (0, _curveMjs.Curve)(p0, p1, p2, p3);
        return function solveInversion(p) {
            return curve.closestPointT(p);
        };
    }
};

},{"./path.mjs":"1WHnT","./curve.mjs":"4kW90","./point.mjs":"7vrrP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1WHnT":[function(require,module,exports) {
// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.
// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Path", ()=>Path);
var _polylineMjs = require("./polyline.mjs");
var _rectMjs = require("./rect.mjs");
var _pointMjs = require("./point.mjs");
var _lineMjs = require("./line.mjs");
var _curveMjs = require("./curve.mjs");
var _typesMjs = require("./types.mjs");
var _extendMjs = require("./extend.mjs");
const Path = function(arg) {
    if (!(this instanceof Path)) return new Path(arg);
    if (typeof arg === "string") return new Path.parse(arg);
    this.segments = [];
    var i;
    var n;
    if (!arg) ;
    else if (Array.isArray(arg) && arg.length !== 0) {
        // flatten one level deep
        // so we can chain arbitrary Path.createSegment results
        arg = arg.reduce(function(acc, val) {
            return acc.concat(val);
        }, []);
        n = arg.length;
        if (arg[0].isSegment) for(i = 0; i < n; i++){
            var segment = arg[i];
            this.appendSegment(segment);
        }
        else {
            var previousObj = null;
            for(i = 0; i < n; i++){
                var obj = arg[i];
                if (!(obj instanceof (0, _lineMjs.Line) || obj instanceof (0, _curveMjs.Curve))) throw new Error("Cannot construct a path segment from the provided object.");
                if (i === 0) this.appendSegment(Path.createSegment("M", obj.start));
                // if objects do not link up, moveto segments are inserted to cover the gaps
                if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path.createSegment("M", obj.start));
                if (obj instanceof (0, _lineMjs.Line)) this.appendSegment(Path.createSegment("L", obj.end));
                else if (obj instanceof (0, _curveMjs.Curve)) this.appendSegment(Path.createSegment("C", obj.controlPoint1, obj.controlPoint2, obj.end));
                previousObj = obj;
            }
        }
    } else if (arg.isSegment) this.appendSegment(arg);
    else if (arg instanceof (0, _lineMjs.Line)) {
        this.appendSegment(Path.createSegment("M", arg.start));
        this.appendSegment(Path.createSegment("L", arg.end));
    } else if (arg instanceof (0, _curveMjs.Curve)) {
        this.appendSegment(Path.createSegment("M", arg.start));
        this.appendSegment(Path.createSegment("C", arg.controlPoint1, arg.controlPoint2, arg.end));
    } else if (arg instanceof (0, _polylineMjs.Polyline)) {
        if (!(arg.points && arg.points.length !== 0)) return; // if Polyline has no points, leave Path empty
        n = arg.points.length;
        for(i = 0; i < n; i++){
            var point = arg.points[i];
            if (i === 0) this.appendSegment(Path.createSegment("M", point));
            else this.appendSegment(Path.createSegment("L", point));
        }
    } else throw new Error("Cannot construct a path from the provided object.");
};
// More permissive than V.normalizePathData and Path.prototype.serialize.
// Allows path data strings that do not start with a Moveto command (unlike SVG specification).
// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').
// Allows for command argument chaining.
// Throws an error if wrong number of arguments is provided with a command.
// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).
Path.parse = function(pathData) {
    if (!pathData) return new Path();
    var path = new Path();
    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g;
    var commands = pathData.match(commandRe);
    var numCommands = commands.length;
    for(var i = 0; i < numCommands; i++){
        var command = commands[i];
        var argRe = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g;
        var args = command.match(argRe);
        var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]
        path.appendSegment(segment);
    }
    return path;
};
// Create a segment or an array of segments.
// Accepts unlimited points/coords arguments after `type`.
Path.createSegment = function(type) {
    if (!type) throw new Error("Type must be provided.");
    var segmentConstructor = Path.segmentTypes[type];
    if (!segmentConstructor) throw new Error(type + " is not a recognized path segment type.");
    var args = [];
    var n = arguments.length;
    for(var i = 1; i < n; i++)args.push(arguments[i]);
    return applyToNew(segmentConstructor, args);
};
Path.prototype = {
    type: (0, _typesMjs.types).Path,
    // Accepts one segment or an array of segments as argument.
    // Throws an error if argument is not a segment or an array of segments.
    appendSegment: function(arg) {
        var segments = this.segments;
        var numSegments = segments.length;
        // works even if path has no segments
        var currentSegment;
        var previousSegment = numSegments !== 0 ? segments[numSegments - 1] : null; // if we are appending to an empty path, previousSegment is null
        var nextSegment = null;
        if (!Array.isArray(arg)) {
            if (!arg || !arg.isSegment) throw new Error("Segment required.");
            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);
            segments.push(currentSegment);
        } else {
            // flatten one level deep
            // so we can chain arbitrary Path.createSegment results
            arg = arg.reduce(function(acc, val) {
                return acc.concat(val);
            }, []);
            if (!arg[0].isSegment) throw new Error("Segments required.");
            var n = arg.length;
            for(var i = 0; i < n; i++){
                var currentArg = arg[i];
                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);
                segments.push(currentSegment);
                previousSegment = currentSegment;
            }
        }
    },
    // Returns the bbox of the path.
    // If path has no segments, returns null.
    // If path has only invisible segments, returns bbox of the end point of last segment.
    bbox: function() {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        var bbox;
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i];
            if (segment.isVisible) {
                var segmentBBox = segment.bbox();
                bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;
            }
        }
        if (bbox) return bbox;
        // if the path has only invisible elements, return end point of last segment
        var lastSegment = segments[numSegments - 1];
        return new (0, _rectMjs.Rect)(lastSegment.end.x, lastSegment.end.y, 0, 0);
    },
    // Returns a new path that is a clone of this path.
    clone: function() {
        var segments = this.segments;
        var numSegments = segments.length;
        // works even if path has no segments
        var path = new Path();
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i].clone();
            path.appendSegment(segment);
        }
        return path;
    },
    closestPoint: function(p, opt) {
        var t = this.closestPointT(p, opt);
        if (!t) return null;
        return this.pointAtT(t);
    },
    closestPointLength: function(p, opt) {
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        var localOpt = {
            precision: precision,
            segmentSubdivisions: segmentSubdivisions
        };
        var t = this.closestPointT(p, localOpt);
        if (!t) return 0;
        return this.lengthAtT(t, localOpt);
    },
    closestPointNormalizedLength: function(p, opt) {
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        var localOpt = {
            precision: precision,
            segmentSubdivisions: segmentSubdivisions
        };
        var cpLength = this.closestPointLength(p, localOpt);
        if (cpLength === 0) return 0; // shortcut
        var length = this.length(localOpt);
        if (length === 0) return 0; // prevents division by zero
        return cpLength / length;
    },
    // Private function.
    closestPointT: function(p, opt) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        // not using localOpt
        var closestPointT;
        var minSquaredDistance = Infinity;
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i];
            var subdivisions = segmentSubdivisions[i];
            if (segment.isVisible) {
                var segmentClosestPointT = segment.closestPointT(p, {
                    precision: precision,
                    subdivisions: subdivisions
                });
                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
                var squaredDistance = new (0, _lineMjs.Line)(segmentClosestPoint, p).squaredLength();
                if (squaredDistance < minSquaredDistance) {
                    closestPointT = {
                        segmentIndex: i,
                        value: segmentClosestPointT
                    };
                    minSquaredDistance = squaredDistance;
                }
            }
        }
        if (closestPointT) return closestPointT;
        // if no visible segment, return end of last segment
        return {
            segmentIndex: numSegments - 1,
            value: 1
        };
    },
    closestPointTangent: function(p, opt) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        // not using localOpt
        var closestPointTangent;
        var minSquaredDistance = Infinity;
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i];
            var subdivisions = segmentSubdivisions[i];
            if (segment.isDifferentiable()) {
                var segmentClosestPointT = segment.closestPointT(p, {
                    precision: precision,
                    subdivisions: subdivisions
                });
                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
                var squaredDistance = new (0, _lineMjs.Line)(segmentClosestPoint, p).squaredLength();
                if (squaredDistance < minSquaredDistance) {
                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);
                    minSquaredDistance = squaredDistance;
                }
            }
        }
        if (closestPointTangent) return closestPointTangent;
        // if no valid segment, return null
        return null;
    },
    // Returns `true` if the area surrounded by the path contains the point `p`.
    // Implements the even-odd algorithm (self-intersections are "outside").
    // Closes open paths (always imagines a final closing segment).
    // Precision may be adjusted by passing an `opt` object.
    containsPoint: function(p, opt) {
        var polylines = this.toPolylines(opt);
        if (!polylines) return false; // shortcut (this path has no polylines)
        var numPolylines = polylines.length;
        // how many component polylines does `p` lie within?
        var numIntersections = 0;
        for(var i = 0; i < numPolylines; i++){
            var polyline = polylines[i];
            if (polyline.containsPoint(p)) // `p` lies within this polyline
            numIntersections++;
        }
        // returns `true` for odd numbers of intersections (even-odd algorithm)
        return numIntersections % 2 === 1;
    },
    // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.
    divideAt: function(ratio, opt) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        if (ratio < 0) ratio = 0;
        if (ratio > 1) ratio = 1;
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        var localOpt = {
            precision: precision,
            segmentSubdivisions: segmentSubdivisions
        };
        var pathLength = this.length(localOpt);
        var length = pathLength * ratio;
        return this.divideAtLength(length, localOpt);
    },
    // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
    divideAtLength: function(length, opt) {
        var numSegments = this.segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        var fromStart = true;
        if (length < 0) {
            fromStart = false; // negative lengths mean start calculation from end point
            length = -length; // absolute value
        }
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        // not using localOpt
        var i;
        var segment;
        // identify the segment to divide:
        var l = 0; // length so far
        var divided;
        var dividedSegmentIndex;
        var lastValidSegment; // visible AND differentiable
        var lastValidSegmentIndex;
        var t;
        for(i = 0; i < numSegments; i++){
            var index = fromStart ? i : numSegments - 1 - i;
            segment = this.getSegment(index);
            var subdivisions = segmentSubdivisions[index];
            var d = segment.length({
                precision: precision,
                subdivisions: subdivisions
            });
            if (segment.isDifferentiable()) {
                lastValidSegment = segment;
                lastValidSegmentIndex = index;
                if (length <= l + d) {
                    dividedSegmentIndex = index;
                    divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - l), {
                        precision: precision,
                        subdivisions: subdivisions
                    });
                    break;
                }
            }
            l += d;
        }
        if (!lastValidSegment) return null;
        // else: the path contains at least one valid segment
        if (!divided) {
            dividedSegmentIndex = lastValidSegmentIndex;
            t = fromStart ? 1 : 0;
            divided = lastValidSegment.divideAtT(t);
        }
        // create a copy of this path and replace the identified segment with its two divided parts:
        var pathCopy = this.clone();
        pathCopy.replaceSegment(dividedSegmentIndex, divided);
        var divisionStartIndex = dividedSegmentIndex;
        var divisionMidIndex = dividedSegmentIndex + 1;
        var divisionEndIndex = dividedSegmentIndex + 2;
        // do not insert the part if it looks like a point
        if (!divided[0].isDifferentiable()) {
            pathCopy.removeSegment(divisionStartIndex);
            divisionMidIndex -= 1;
            divisionEndIndex -= 1;
        }
        // insert a Moveto segment to ensure secondPath will be valid:
        var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;
        pathCopy.insertSegment(divisionMidIndex, Path.createSegment("M", movetoEnd));
        divisionEndIndex += 1;
        // do not insert the part if it looks like a point
        if (!divided[1].isDifferentiable()) {
            pathCopy.removeSegment(divisionEndIndex - 1);
            divisionEndIndex -= 1;
        }
        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:
        var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;
        for(i = divisionEndIndex; i < pathCopy.segments.length; i++){
            var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);
            segment = pathCopy.getSegment(i);
            if (segment.type === "Z" && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {
                // pathCopy segment's subpathStartSegment is different from original segment's one
                // convert this Closepath segment to a Lineto and replace it in pathCopy
                var convertedSegment = Path.createSegment("L", originalSegment.end);
                pathCopy.replaceSegment(i, convertedSegment);
            }
        }
        // distribute pathCopy segments into two paths and return those:
        var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));
        var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));
        return [
            firstPath,
            secondPath
        ];
    },
    // Checks whether two paths are exactly the same.
    // If `p` is undefined or null, returns false.
    equals: function(p) {
        if (!p) return false;
        var segments = this.segments;
        var otherSegments = p.segments;
        var numSegments = segments.length;
        if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i];
            var otherSegment = otherSegments[i];
            // as soon as an inequality is found in segments, return false
            if (segment.type !== otherSegment.type || !segment.equals(otherSegment)) return false;
        }
        // if no inequality found in segments, return true
        return true;
    },
    // Accepts negative indices.
    // Throws an error if path has no segments.
    // Throws an error if index is out of range.
    getSegment: function(index) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) throw new Error("Path has no segments.");
        if (index < 0) index = numSegments + index; // convert negative indices to positive
        if (index >= numSegments || index < 0) throw new Error("Index out of range.");
        return segments[index];
    },
    // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.
    getSegmentSubdivisions: function(opt) {
        var segments = this.segments;
        var numSegments = segments.length;
        // works even if path has no segments
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        // not using opt.segmentSubdivisions
        // not using localOpt
        var segmentSubdivisions = [];
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i];
            var subdivisions = segment.getSubdivisions({
                precision: precision
            });
            segmentSubdivisions.push(subdivisions);
        }
        return segmentSubdivisions;
    },
    // Returns an array of subpaths of this path.
    // Invalid paths are validated first.
    // Returns `[]` if path has no segments.
    getSubpaths: function() {
        const validatedPath = this.clone().validate();
        const segments = validatedPath.segments;
        const numSegments = segments.length;
        const subpaths = [];
        for(let i = 0; i < numSegments; i++){
            const segment = segments[i];
            if (segment.isSubpathStart) // we encountered a subpath start segment
            // create a new path for segment, and push it to list of subpaths
            subpaths.push(new Path(segment));
            else // append current segment to the last subpath
            subpaths[subpaths.length - 1].appendSegment(segment);
        }
        return subpaths;
    },
    // Insert `arg` at given `index`.
    // `index = 0` means insert at the beginning.
    // `index = segments.length` means insert at the end.
    // Accepts negative indices, from `-1` to `-(segments.length + 1)`.
    // Accepts one segment or an array of segments as argument.
    // Throws an error if index is out of range.
    // Throws an error if argument is not a segment or an array of segments.
    insertSegment: function(index, arg) {
        var segments = this.segments;
        var numSegments = segments.length;
        // works even if path has no segments
        // note that these are incremented compared to getSegments()
        // we can insert after last element (note that this changes the meaning of index -1)
        if (index < 0) index = numSegments + index + 1; // convert negative indices to positive
        if (index > numSegments || index < 0) throw new Error("Index out of range.");
        var currentSegment;
        var previousSegment = null;
        var nextSegment = null;
        if (numSegments !== 0) {
            if (index >= 1) {
                previousSegment = segments[index - 1];
                nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null
            } else // previousSegment is null
            nextSegment = segments[0];
        }
        if (!Array.isArray(arg)) {
            if (!arg || !arg.isSegment) throw new Error("Segment required.");
            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);
            segments.splice(index, 0, currentSegment);
        } else {
            // flatten one level deep
            // so we can chain arbitrary Path.createSegment results
            arg = arg.reduce(function(acc, val) {
                return acc.concat(val);
            }, []);
            if (!arg[0].isSegment) throw new Error("Segments required.");
            var n = arg.length;
            for(var i = 0; i < n; i++){
                var currentArg = arg[i];
                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);
                segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments
                previousSegment = currentSegment;
            }
        }
    },
    intersectionWithLine: function(line, opt) {
        var intersection = null;
        var polylines = this.toPolylines(opt);
        if (!polylines) return null;
        for(var i = 0, n = polylines.length; i < n; i++){
            var polyline = polylines[i];
            var polylineIntersection = line.intersect(polyline);
            if (polylineIntersection) {
                intersection || (intersection = []);
                if (Array.isArray(polylineIntersection)) Array.prototype.push.apply(intersection, polylineIntersection);
                else intersection.push(polylineIntersection);
            }
        }
        return intersection;
    },
    isDifferentiable: function() {
        var segments = this.segments;
        var numSegments = segments.length;
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i];
            // as soon as a differentiable segment is found in segments, return true
            if (segment.isDifferentiable()) return true;
        }
        // if no differentiable segment is found in segments, return false
        return false;
    },
    // Checks whether current path segments are valid.
    // Note that d is allowed to be empty - should disable rendering of the path.
    isValid: function() {
        var segments = this.segments;
        var isValid = segments.length === 0 || segments[0].type === "M"; // either empty or first segment is a Moveto
        return isValid;
    },
    // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.
    // If path has no segments, returns 0.
    length: function(opt) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return 0; // if segments is an empty array
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        // not using localOpt
        var length = 0;
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i];
            var subdivisions = segmentSubdivisions[i];
            length += segment.length({
                subdivisions: subdivisions
            });
        }
        return length;
    },
    // Private function.
    lengthAtT: function(t, opt) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return 0; // if segments is an empty array
        var segmentIndex = t.segmentIndex;
        if (segmentIndex < 0) return 0; // regardless of t.value
        var tValue = t.value;
        if (segmentIndex >= numSegments) {
            segmentIndex = numSegments - 1;
            tValue = 1;
        } else if (tValue < 0) tValue = 0;
        else if (tValue > 1) tValue = 1;
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        // not using localOpt
        var subdivisions;
        var length = 0;
        for(var i = 0; i < segmentIndex; i++){
            var segment = segments[i];
            subdivisions = segmentSubdivisions[i];
            length += segment.length({
                precisison: precision,
                subdivisions: subdivisions
            });
        }
        segment = segments[segmentIndex];
        subdivisions = segmentSubdivisions[segmentIndex];
        length += segment.lengthAtT(tValue, {
            precisison: precision,
            subdivisions: subdivisions
        });
        return length;
    },
    // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.
    pointAt: function(ratio, opt) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        if (ratio <= 0) return this.start.clone();
        if (ratio >= 1) return this.end.clone();
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        var localOpt = {
            precision: precision,
            segmentSubdivisions: segmentSubdivisions
        };
        var pathLength = this.length(localOpt);
        var length = pathLength * ratio;
        return this.pointAtLength(length, localOpt);
    },
    // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.
    // Accepts negative length.
    pointAtLength: function(length, opt) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        if (length === 0) return this.start.clone();
        var fromStart = true;
        if (length < 0) {
            fromStart = false; // negative lengths mean start calculation from end point
            length = -length; // absolute value
        }
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        // not using localOpt
        var lastVisibleSegment;
        var l = 0; // length so far
        for(var i = 0; i < numSegments; i++){
            var index = fromStart ? i : numSegments - 1 - i;
            var segment = segments[index];
            var subdivisions = segmentSubdivisions[index];
            var d = segment.length({
                precision: precision,
                subdivisions: subdivisions
            });
            if (segment.isVisible) {
                if (length <= l + d) return segment.pointAtLength((fromStart ? 1 : -1) * (length - l), {
                    precision: precision,
                    subdivisions: subdivisions
                });
                lastVisibleSegment = segment;
            }
            l += d;
        }
        // if length requested is higher than the length of the path, return last visible segment endpoint
        if (lastVisibleSegment) return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;
        // if no visible segment, return last segment end point (no matter if fromStart or no)
        var lastSegment = segments[numSegments - 1];
        return lastSegment.end.clone();
    },
    // Private function.
    pointAtT: function(t) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        var segmentIndex = t.segmentIndex;
        if (segmentIndex < 0) return segments[0].pointAtT(0);
        if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);
        var tValue = t.value;
        if (tValue < 0) tValue = 0;
        else if (tValue > 1) tValue = 1;
        return segments[segmentIndex].pointAtT(tValue);
    },
    // Default precision
    PRECISION: 3,
    // Helper method for adding segments.
    prepareSegment: function(segment, previousSegment, nextSegment) {
        // insert after previous segment and before previous segment's next segment
        segment.previousSegment = previousSegment;
        segment.nextSegment = nextSegment;
        if (previousSegment) previousSegment.nextSegment = segment;
        if (nextSegment) nextSegment.previousSegment = segment;
        var updateSubpathStart = segment;
        if (segment.isSubpathStart) {
            segment.subpathStartSegment = segment; // assign self as subpath start segment
            updateSubpathStart = nextSegment; // start updating from next segment
        }
        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments
        if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);
        return segment;
    },
    // Remove the segment at `index`.
    // Accepts negative indices, from `-1` to `-segments.length`.
    // Throws an error if path has no segments.
    // Throws an error if index is out of range.
    removeSegment: function(index) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) throw new Error("Path has no segments.");
        if (index < 0) index = numSegments + index; // convert negative indices to positive
        if (index >= numSegments || index < 0) throw new Error("Index out of range.");
        var removedSegment = segments.splice(index, 1)[0];
        var previousSegment = removedSegment.previousSegment;
        var nextSegment = removedSegment.nextSegment;
        // link the previous and next segments together (if present)
        if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null
        if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null
        // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached
        if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);
    },
    // Replace the segment at `index` with `arg`.
    // Accepts negative indices, from `-1` to `-segments.length`.
    // Accepts one segment or an array of segments as argument.
    // Throws an error if path has no segments.
    // Throws an error if index is out of range.
    // Throws an error if argument is not a segment or an array of segments.
    replaceSegment: function(index, arg) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) throw new Error("Path has no segments.");
        if (index < 0) index = numSegments + index; // convert negative indices to positive
        if (index >= numSegments || index < 0) throw new Error("Index out of range.");
        var currentSegment;
        var replacedSegment = segments[index];
        var previousSegment = replacedSegment.previousSegment;
        var nextSegment = replacedSegment.nextSegment;
        var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?
        if (!Array.isArray(arg)) {
            if (!arg || !arg.isSegment) throw new Error("Segment required.");
            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);
            segments.splice(index, 1, currentSegment); // directly replace
            if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`
        } else {
            // flatten one level deep
            // so we can chain arbitrary Path.createSegment results
            arg = arg.reduce(function(acc, val) {
                return acc.concat(val);
            }, []);
            if (!arg[0].isSegment) throw new Error("Segments required.");
            segments.splice(index, 1);
            var n = arg.length;
            for(var i = 0; i < n; i++){
                var currentArg = arg[i];
                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);
                segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments
                previousSegment = currentSegment;
                if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`
            }
        }
        // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached
        if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);
    },
    round: function(precision) {
        var segments = this.segments;
        var numSegments = segments.length;
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i];
            segment.round(precision);
        }
        return this;
    },
    scale: function(sx, sy, origin) {
        var segments = this.segments;
        var numSegments = segments.length;
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i];
            segment.scale(sx, sy, origin);
        }
        return this;
    },
    segmentAt: function(ratio, opt) {
        var index = this.segmentIndexAt(ratio, opt);
        if (!index) return null;
        return this.getSegment(index);
    },
    // Accepts negative length.
    segmentAtLength: function(length, opt) {
        var index = this.segmentIndexAtLength(length, opt);
        if (!index) return null;
        return this.getSegment(index);
    },
    segmentIndexAt: function(ratio, opt) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        if (ratio < 0) ratio = 0;
        if (ratio > 1) ratio = 1;
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        var localOpt = {
            precision: precision,
            segmentSubdivisions: segmentSubdivisions
        };
        var pathLength = this.length(localOpt);
        var length = pathLength * ratio;
        return this.segmentIndexAtLength(length, localOpt);
    },
    // Accepts negative length.
    segmentIndexAtLength: function(length, opt) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        var fromStart = true;
        if (length < 0) {
            fromStart = false; // negative lengths mean start calculation from end point
            length = -length; // absolute value
        }
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        // not using localOpt
        var lastVisibleSegmentIndex = null;
        var l = 0; // length so far
        for(var i = 0; i < numSegments; i++){
            var index = fromStart ? i : numSegments - 1 - i;
            var segment = segments[index];
            var subdivisions = segmentSubdivisions[index];
            var d = segment.length({
                precision: precision,
                subdivisions: subdivisions
            });
            if (segment.isVisible) {
                if (length <= l + d) return index;
                lastVisibleSegmentIndex = index;
            }
            l += d;
        }
        // if length requested is higher than the length of the path, return last visible segment index
        // if no visible segment, return null
        return lastVisibleSegmentIndex;
    },
    // Returns a string that can be used to reconstruct the path.
    // Additional error checking compared to toString (must start with M segment).
    serialize: function() {
        if (!this.isValid()) throw new Error("Invalid path segments.");
        return this.toString();
    },
    // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.
    tangentAt: function(ratio, opt) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        if (ratio < 0) ratio = 0;
        if (ratio > 1) ratio = 1;
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        var localOpt = {
            precision: precision,
            segmentSubdivisions: segmentSubdivisions
        };
        var pathLength = this.length(localOpt);
        var length = pathLength * ratio;
        return this.tangentAtLength(length, localOpt);
    },
    // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.
    // Accepts negative length.
    tangentAtLength: function(length, opt) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        var fromStart = true;
        if (length < 0) {
            fromStart = false; // negative lengths mean start calculation from end point
            length = -length; // absolute value
        }
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        // not using localOpt
        var lastValidSegment; // visible AND differentiable (with a tangent)
        var l = 0; // length so far
        for(var i = 0; i < numSegments; i++){
            var index = fromStart ? i : numSegments - 1 - i;
            var segment = segments[index];
            var subdivisions = segmentSubdivisions[index];
            var d = segment.length({
                precision: precision,
                subdivisions: subdivisions
            });
            if (segment.isDifferentiable()) {
                if (length <= l + d) return segment.tangentAtLength((fromStart ? 1 : -1) * (length - l), {
                    precision: precision,
                    subdivisions: subdivisions
                });
                lastValidSegment = segment;
            }
            l += d;
        }
        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment
        if (lastValidSegment) {
            var t = fromStart ? 1 : 0;
            return lastValidSegment.tangentAtT(t);
        }
        // if no valid segment, return null
        return null;
    },
    // Private function.
    tangentAtT: function(t) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        var segmentIndex = t.segmentIndex;
        if (segmentIndex < 0) return segments[0].tangentAtT(0);
        if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);
        var tValue = t.value;
        if (tValue < 0) tValue = 0;
        else if (tValue > 1) tValue = 1;
        return segments[segmentIndex].tangentAtT(tValue);
    },
    toPoints: function(opt) {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null; // if segments is an empty array
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({
            precision: precision
        }) : opt.segmentSubdivisions;
        var points = [];
        var partialPoints = [];
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i];
            if (segment.isVisible) {
                var currentSegmentSubdivisions = segmentSubdivisions[i];
                if (currentSegmentSubdivisions.length > 0) {
                    var subdivisionPoints = currentSegmentSubdivisions.map(function(curve) {
                        return curve.start;
                    });
                    Array.prototype.push.apply(partialPoints, subdivisionPoints);
                } else partialPoints.push(segment.start);
            } else if (partialPoints.length > 0) {
                partialPoints.push(segments[i - 1].end);
                points.push(partialPoints);
                partialPoints = [];
            }
        }
        if (partialPoints.length > 0) {
            partialPoints.push(this.end);
            points.push(partialPoints);
        }
        return points;
    },
    toPolylines: function(opt) {
        var polylines = [];
        var points = this.toPoints(opt);
        if (!points) return null;
        for(var i = 0, n = points.length; i < n; i++)polylines.push(new (0, _polylineMjs.Polyline)(points[i]));
        return polylines;
    },
    toString: function() {
        var segments = this.segments;
        var numSegments = segments.length;
        var pathData = "";
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i];
            pathData += segment.serialize() + " ";
        }
        return pathData.trim();
    },
    translate: function(tx, ty) {
        var segments = this.segments;
        var numSegments = segments.length;
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i];
            segment.translate(tx, ty);
        }
        return this;
    },
    // Helper method for updating subpath start of segments, starting with the one provided.
    updateSubpathStartSegment: function(segment) {
        var previousSegment = segment.previousSegment; // may be null
        while(segment && !segment.isSubpathStart){
            // assign previous segment's subpath start segment to this segment
            if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null
            else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!
            previousSegment = segment;
            segment = segment.nextSegment; // move on to the segment after etc.
        }
    },
    // If the path is not valid, insert M 0 0 at the beginning.
    // Path with no segments is considered valid, so nothing is inserted.
    validate: function() {
        if (!this.isValid()) this.insertSegment(0, Path.createSegment("M", 0, 0));
        return this;
    }
};
Object.defineProperty(Path.prototype, "start", {
    // Getter for the first visible endpoint of the path.
    configurable: true,
    enumerable: true,
    get: function() {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null;
        for(var i = 0; i < numSegments; i++){
            var segment = segments[i];
            if (segment.isVisible) return segment.start;
        }
        // if no visible segment, return last segment end point
        return segments[numSegments - 1].end;
    }
});
Object.defineProperty(Path.prototype, "end", {
    // Getter for the last visible endpoint of the path.
    configurable: true,
    enumerable: true,
    get: function() {
        var segments = this.segments;
        var numSegments = segments.length;
        if (numSegments === 0) return null;
        for(var i = numSegments - 1; i >= 0; i--){
            var segment = segments[i];
            if (segment.isVisible) return segment.end;
        }
        // if no visible segment, return last segment end point
        return segments[numSegments - 1].end;
    }
});
// Local helper function.
// Use an array of arguments to call a constructor (function called with `new`).
// Adapted from https://stackoverflow.com/a/8843181/2263595
// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).
// - If that is the case, use `new constructor(arg1, arg2)`, for example.
// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.
// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.
function applyToNew(constructor, argsArray) {
    // The `new` keyword can only be applied to functions that take a limited number of arguments.
    // - We can fake that with .bind().
    // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.
    // - So `new (constructor.bind(thisArg, arg1, arg2...))`
    // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.
    // We need to pass in a variable number of arguments to the bind() call.
    // - We can use .apply().
    // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`
    // - `thisArg` can still be anything because `new` overwrites it.
    // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.
    // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`
    // The function expects `argsArray[0]` to be `thisArg`.
    // - This means that whatever is sent as the first element will be ignored.
    // - The constructor will only see arguments starting from argsArray[1].
    // - So, a new dummy element is inserted at the start of the array.
    argsArray.unshift(null);
    return new (Function.prototype.bind.apply(constructor, argsArray));
}
// Path segment interface:
var segmentPrototype = {
    // virtual
    bbox: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // virtual
    clone: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // virtual
    closestPoint: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // virtual
    closestPointLength: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // virtual
    closestPointNormalizedLength: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.
    closestPointT: function(p) {
        if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);
        throw new Error("Neither closestPointT() nor closestPointNormalizedLength() function is implemented.");
    },
    // virtual
    closestPointTangent: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // virtual
    divideAt: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // virtual
    divideAtLength: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // Redirect calls to divideAt() function if divideAtT() is not defined for segment.
    divideAtT: function(t) {
        if (this.divideAt) return this.divideAt(t);
        throw new Error("Neither divideAtT() nor divideAt() function is implemented.");
    },
    // virtual
    equals: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // virtual
    getSubdivisions: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // virtual
    isDifferentiable: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    isSegment: true,
    isSubpathStart: false,
    isVisible: true,
    // virtual
    length: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // Return a fraction of result of length() function if lengthAtT() is not defined for segment.
    lengthAtT: function(t) {
        if (t <= 0) return 0;
        var length = this.length();
        if (t >= 1) return length;
        return length * t;
    },
    nextSegment: null,
    // virtual
    pointAt: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // virtual
    pointAtLength: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // Redirect calls to pointAt() function if pointAtT() is not defined for segment.
    pointAtT: function(t) {
        if (this.pointAt) return this.pointAt(t);
        throw new Error("Neither pointAtT() nor pointAt() function is implemented.");
    },
    previousSegment: null,
    // virtual
    round: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    subpathStartSegment: null,
    // virtual
    scale: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // virtual
    serialize: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // virtual
    tangentAt: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // virtual
    tangentAtLength: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.
    tangentAtT: function(t) {
        if (this.tangentAt) return this.tangentAt(t);
        throw new Error("Neither tangentAtT() nor tangentAt() function is implemented.");
    },
    // virtual
    toString: function() {
        throw new Error("Declaration missing for virtual function.");
    },
    // virtual
    translate: function() {
        throw new Error("Declaration missing for virtual function.");
    }
};
// usually directly assigned
// getter for Closepath
Object.defineProperty(segmentPrototype, "end", {
    configurable: true,
    enumerable: true,
    writable: true
});
// always a getter
// always throws error for Moveto
Object.defineProperty(segmentPrototype, "start", {
    // get a reference to the end point of previous segment
    configurable: true,
    enumerable: true,
    get: function() {
        if (!this.previousSegment) throw new Error("Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)");
        return this.previousSegment.end;
    }
});
// virtual
Object.defineProperty(segmentPrototype, "type", {
    configurable: true,
    enumerable: true,
    get: function() {
        throw new Error("Bad segment declaration. No type specified.");
    }
});
// Path segment implementations:
var Lineto = function() {
    var args = [];
    var n = arguments.length;
    for(var i = 0; i < n; i++)args.push(arguments[i]);
    if (!(this instanceof Lineto)) return applyToNew(Lineto, args);
    if (n === 0) throw new Error("Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).");
    var outputArray;
    if (args[0] instanceof (0, _lineMjs.Line)) {
        if (n === 1) {
            this.end = args[0].end.clone();
            return this;
        } else throw new Error("Lineto constructor expects a line, 1 point, or 2 coordinates (" + n + " lines provided).");
    } else if (typeof args[0] === "string" || typeof args[0] === "number") {
        if (n === 2) {
            this.end = new (0, _pointMjs.Point)(+args[0], +args[1]);
            return this;
        } else if (n < 2) throw new Error("Lineto constructor expects a line, 1 point, or 2 coordinates (" + n + " coordinates provided).");
        else {
            var segmentCoords;
            outputArray = [];
            for(i = 0; i < n; i += 2){
                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2
                outputArray.push(applyToNew(Lineto, segmentCoords));
            }
            return outputArray;
        }
    } else if (n === 1) {
        this.end = new (0, _pointMjs.Point)(args[0]);
        return this;
    } else {
        var segmentPoint;
        outputArray = [];
        for(i = 0; i < n; i += 1){
            segmentPoint = args[i];
            outputArray.push(new Lineto(segmentPoint));
        }
        return outputArray;
    }
};
var linetoPrototype = {
    clone: function() {
        return new Lineto(this.end);
    },
    divideAt: function(ratio) {
        var line = new (0, _lineMjs.Line)(this.start, this.end);
        var divided = line.divideAt(ratio);
        return [
            new Lineto(divided[0]),
            new Lineto(divided[1])
        ];
    },
    divideAtLength: function(length) {
        var line = new (0, _lineMjs.Line)(this.start, this.end);
        var divided = line.divideAtLength(length);
        return [
            new Lineto(divided[0]),
            new Lineto(divided[1])
        ];
    },
    getSubdivisions: function() {
        return [];
    },
    isDifferentiable: function() {
        if (!this.previousSegment) return false;
        return !this.start.equals(this.end);
    },
    round: function(precision) {
        this.end.round(precision);
        return this;
    },
    scale: function(sx, sy, origin) {
        this.end.scale(sx, sy, origin);
        return this;
    },
    serialize: function() {
        var end = this.end;
        return this.type + " " + end.x + " " + end.y;
    },
    toString: function() {
        return this.type + " " + this.start + " " + this.end;
    },
    translate: function(tx, ty) {
        this.end.translate(tx, ty);
        return this;
    }
};
Object.defineProperty(linetoPrototype, "type", {
    configurable: true,
    enumerable: true,
    value: "L"
});
Lineto.prototype = (0, _extendMjs.extend)(segmentPrototype, (0, _lineMjs.Line).prototype, linetoPrototype);
var Curveto = function() {
    var args = [];
    var n = arguments.length;
    for(var i = 0; i < n; i++)args.push(arguments[i]);
    if (!(this instanceof Curveto)) return applyToNew(Curveto, args);
    if (n === 0) throw new Error("Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).");
    var outputArray;
    if (args[0] instanceof (0, _curveMjs.Curve)) {
        if (n === 1) {
            this.controlPoint1 = args[0].controlPoint1.clone();
            this.controlPoint2 = args[0].controlPoint2.clone();
            this.end = args[0].end.clone();
            return this;
        } else throw new Error("Curveto constructor expects a curve, 3 points, or 6 coordinates (" + n + " curves provided).");
    } else if (typeof args[0] === "string" || typeof args[0] === "number") {
        if (n === 6) {
            this.controlPoint1 = new (0, _pointMjs.Point)(+args[0], +args[1]);
            this.controlPoint2 = new (0, _pointMjs.Point)(+args[2], +args[3]);
            this.end = new (0, _pointMjs.Point)(+args[4], +args[5]);
            return this;
        } else if (n < 6) throw new Error("Curveto constructor expects a curve, 3 points, or 6 coordinates (" + n + " coordinates provided).");
        else {
            var segmentCoords;
            outputArray = [];
            for(i = 0; i < n; i += 6){
                segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6
                outputArray.push(applyToNew(Curveto, segmentCoords));
            }
            return outputArray;
        }
    } else {
        if (n === 3) {
            this.controlPoint1 = new (0, _pointMjs.Point)(args[0]);
            this.controlPoint2 = new (0, _pointMjs.Point)(args[1]);
            this.end = new (0, _pointMjs.Point)(args[2]);
            return this;
        } else if (n < 3) throw new Error("Curveto constructor expects a curve, 3 points, or 6 coordinates (" + n + " points provided).");
        else {
            var segmentPoints;
            outputArray = [];
            for(i = 0; i < n; i += 3){
                segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3
                outputArray.push(applyToNew(Curveto, segmentPoints));
            }
            return outputArray;
        }
    }
};
var curvetoPrototype = {
    clone: function() {
        return new Curveto(this.controlPoint1, this.controlPoint2, this.end);
    },
    divideAt: function(ratio, opt) {
        var curve = new (0, _curveMjs.Curve)(this.start, this.controlPoint1, this.controlPoint2, this.end);
        var divided = curve.divideAt(ratio, opt);
        return [
            new Curveto(divided[0]),
            new Curveto(divided[1])
        ];
    },
    divideAtLength: function(length, opt) {
        var curve = new (0, _curveMjs.Curve)(this.start, this.controlPoint1, this.controlPoint2, this.end);
        var divided = curve.divideAtLength(length, opt);
        return [
            new Curveto(divided[0]),
            new Curveto(divided[1])
        ];
    },
    divideAtT: function(t) {
        var curve = new (0, _curveMjs.Curve)(this.start, this.controlPoint1, this.controlPoint2, this.end);
        var divided = curve.divideAtT(t);
        return [
            new Curveto(divided[0]),
            new Curveto(divided[1])
        ];
    },
    isDifferentiable: function() {
        if (!this.previousSegment) return false;
        var start = this.start;
        var control1 = this.controlPoint1;
        var control2 = this.controlPoint2;
        var end = this.end;
        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
    },
    round: function(precision) {
        this.controlPoint1.round(precision);
        this.controlPoint2.round(precision);
        this.end.round(precision);
        return this;
    },
    scale: function(sx, sy, origin) {
        this.controlPoint1.scale(sx, sy, origin);
        this.controlPoint2.scale(sx, sy, origin);
        this.end.scale(sx, sy, origin);
        return this;
    },
    serialize: function() {
        var c1 = this.controlPoint1;
        var c2 = this.controlPoint2;
        var end = this.end;
        return this.type + " " + c1.x + " " + c1.y + " " + c2.x + " " + c2.y + " " + end.x + " " + end.y;
    },
    toString: function() {
        return this.type + " " + this.start + " " + this.controlPoint1 + " " + this.controlPoint2 + " " + this.end;
    },
    translate: function(tx, ty) {
        this.controlPoint1.translate(tx, ty);
        this.controlPoint2.translate(tx, ty);
        this.end.translate(tx, ty);
        return this;
    }
};
Object.defineProperty(curvetoPrototype, "type", {
    configurable: true,
    enumerable: true,
    value: "C"
});
Curveto.prototype = (0, _extendMjs.extend)(segmentPrototype, (0, _curveMjs.Curve).prototype, curvetoPrototype);
var Moveto = function() {
    var args = [];
    var n = arguments.length;
    for(var i = 0; i < n; i++)args.push(arguments[i]);
    if (!(this instanceof Moveto)) return applyToNew(Moveto, args);
    if (n === 0) throw new Error("Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).");
    var outputArray;
    if (args[0] instanceof (0, _lineMjs.Line)) {
        if (n === 1) {
            this.end = args[0].end.clone();
            return this;
        } else throw new Error("Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (" + n + " lines provided).");
    } else if (args[0] instanceof (0, _curveMjs.Curve)) {
        if (n === 1) {
            this.end = args[0].end.clone();
            return this;
        } else throw new Error("Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (" + n + " curves provided).");
    } else if (typeof args[0] === "string" || typeof args[0] === "number") {
        if (n === 2) {
            this.end = new (0, _pointMjs.Point)(+args[0], +args[1]);
            return this;
        } else if (n < 2) throw new Error("Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (" + n + " coordinates provided).");
        else {
            var segmentCoords;
            outputArray = [];
            for(i = 0; i < n; i += 2){
                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2
                if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));
                else outputArray.push(applyToNew(Lineto, segmentCoords));
            }
            return outputArray;
        }
    } else if (n === 1) {
        this.end = new (0, _pointMjs.Point)(args[0]);
        return this;
    } else {
        var segmentPoint;
        outputArray = [];
        for(i = 0; i < n; i += 1){
            segmentPoint = args[i];
            if (i === 0) outputArray.push(new Moveto(segmentPoint));
            else outputArray.push(new Lineto(segmentPoint));
        }
        return outputArray;
    }
};
var movetoPrototype = {
    bbox: function() {
        return null;
    },
    clone: function() {
        return new Moveto(this.end);
    },
    closestPoint: function() {
        return this.end.clone();
    },
    closestPointNormalizedLength: function() {
        return 0;
    },
    closestPointLength: function() {
        return 0;
    },
    closestPointT: function() {
        return 1;
    },
    closestPointTangent: function() {
        return null;
    },
    divideAt: function() {
        return [
            this.clone(),
            this.clone()
        ];
    },
    divideAtLength: function() {
        return [
            this.clone(),
            this.clone()
        ];
    },
    equals: function(m) {
        return this.end.equals(m.end);
    },
    getSubdivisions: function() {
        return [];
    },
    isDifferentiable: function() {
        return false;
    },
    isSubpathStart: true,
    isVisible: false,
    length: function() {
        return 0;
    },
    lengthAtT: function() {
        return 0;
    },
    pointAt: function() {
        return this.end.clone();
    },
    pointAtLength: function() {
        return this.end.clone();
    },
    pointAtT: function() {
        return this.end.clone();
    },
    round: function(precision) {
        this.end.round(precision);
        return this;
    },
    scale: function(sx, sy, origin) {
        this.end.scale(sx, sy, origin);
        return this;
    },
    serialize: function() {
        var end = this.end;
        return this.type + " " + end.x + " " + end.y;
    },
    tangentAt: function() {
        return null;
    },
    tangentAtLength: function() {
        return null;
    },
    tangentAtT: function() {
        return null;
    },
    toString: function() {
        return this.type + " " + this.end;
    },
    translate: function(tx, ty) {
        this.end.translate(tx, ty);
        return this;
    }
};
Object.defineProperty(movetoPrototype, "start", {
    configurable: true,
    enumerable: true,
    get: function() {
        throw new Error("Illegal access. Moveto segments should not need a start property.");
    }
});
Object.defineProperty(movetoPrototype, "type", {
    configurable: true,
    enumerable: true,
    value: "M"
});
Moveto.prototype = (0, _extendMjs.extend)(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object
var Closepath = function() {
    var args = [];
    var n = arguments.length;
    for(var i = 0; i < n; i++)args.push(arguments[i]);
    if (!(this instanceof Closepath)) return applyToNew(Closepath, args);
    if (n > 0) throw new Error("Closepath constructor expects no arguments.");
    return this;
};
var closepathPrototype = {
    clone: function() {
        return new Closepath();
    },
    divideAt: function(ratio) {
        var line = new (0, _lineMjs.Line)(this.start, this.end);
        var divided = line.divideAt(ratio);
        return [
            // if we didn't actually cut into the segment, first divided part can stay as Z
            divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(),
            new Lineto(divided[1])
        ];
    },
    divideAtLength: function(length) {
        var line = new (0, _lineMjs.Line)(this.start, this.end);
        var divided = line.divideAtLength(length);
        return [
            // if we didn't actually cut into the segment, first divided part can stay as Z
            divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(),
            new Lineto(divided[1])
        ];
    },
    getSubdivisions: function() {
        return [];
    },
    isDifferentiable: function() {
        if (!this.previousSegment || !this.subpathStartSegment) return false;
        return !this.start.equals(this.end);
    },
    round: function() {
        return this;
    },
    scale: function() {
        return this;
    },
    serialize: function() {
        return this.type;
    },
    toString: function() {
        return this.type + " " + this.start + " " + this.end;
    },
    translate: function() {
        return this;
    }
};
Object.defineProperty(closepathPrototype, "end", {
    // get a reference to the end point of subpath start segment
    configurable: true,
    enumerable: true,
    get: function() {
        if (!this.subpathStartSegment) throw new Error("Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)");
        return this.subpathStartSegment.end;
    }
});
Object.defineProperty(closepathPrototype, "type", {
    configurable: true,
    enumerable: true,
    value: "Z"
});
Closepath.prototype = (0, _extendMjs.extend)(segmentPrototype, (0, _lineMjs.Line).prototype, closepathPrototype);
var segmentTypes = Path.segmentTypes = {
    L: Lineto,
    C: Curveto,
    M: Moveto,
    Z: Closepath,
    z: Closepath
};
Path.regexSupportedData = new RegExp("^[\\s\\d" + Object.keys(segmentTypes).join("") + ",.]*$");
Path.isDataSupported = function(data) {
    if (typeof data !== "string") return false;
    return this.regexSupportedData.test(data);
};

},{"./polyline.mjs":"8d0If","./rect.mjs":"6MvV7","./point.mjs":"7vrrP","./line.mjs":"f7trh","./curve.mjs":"4kW90","./types.mjs":"217db","./extend.mjs":"0gPi8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8d0If":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Polyline", ()=>Polyline);
var _rectMjs = require("./rect.mjs");
var _pointMjs = require("./point.mjs");
var _lineMjs = require("./line.mjs");
var _typesMjs = require("./types.mjs");
var _pointsMjs = require("./points.mjs");
const Polyline = function(points) {
    if (!(this instanceof Polyline)) return new Polyline(points);
    if (typeof points === "string") return new Polyline.parse(points);
    this.points = Array.isArray(points) ? points.map((0, _pointMjs.Point)) : [];
};
Polyline.parse = function(svgString) {
    return new Polyline((0, _pointsMjs.parsePoints)(svgString));
};
Polyline.fromRect = function(rect) {
    return new Polyline([
        rect.topLeft(),
        rect.topRight(),
        rect.bottomRight(),
        rect.bottomLeft(),
        rect.topLeft()
    ]);
};
Polyline.prototype = {
    type: (0, _typesMjs.types).Polyline,
    bbox: function() {
        var x1 = Infinity;
        var x2 = -Infinity;
        var y1 = Infinity;
        var y2 = -Infinity;
        var points = this.points;
        var numPoints = points.length;
        if (numPoints === 0) return null; // if points array is empty
        for(var i = 0; i < numPoints; i++){
            var point = points[i];
            var x = point.x;
            var y = point.y;
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;
        }
        return new (0, _rectMjs.Rect)(x1, y1, x2 - x1, y2 - y1);
    },
    clone: function() {
        return new Polyline((0, _pointsMjs.clonePoints)(this.points));
    },
    closestPoint: function(p) {
        var cpLength = this.closestPointLength(p);
        return this.pointAtLength(cpLength);
    },
    closestPointLength: function(p) {
        var points = this.lengthPoints();
        var numPoints = points.length;
        if (numPoints === 0) return 0; // if points array is empty
        if (numPoints === 1) return 0; // if there is only one point
        var cpLength;
        var minSqrDistance = Infinity;
        var length = 0;
        var n = numPoints - 1;
        for(var i = 0; i < n; i++){
            var line = new (0, _lineMjs.Line)(points[i], points[i + 1]);
            var lineLength = line.length();
            var cpNormalizedLength = line.closestPointNormalizedLength(p);
            var cp = line.pointAt(cpNormalizedLength);
            var sqrDistance = cp.squaredDistance(p);
            if (sqrDistance < minSqrDistance) {
                minSqrDistance = sqrDistance;
                cpLength = length + cpNormalizedLength * lineLength;
            }
            length += lineLength;
        }
        return cpLength;
    },
    closestPointNormalizedLength: function(p) {
        var cpLength = this.closestPointLength(p);
        if (cpLength === 0) return 0; // shortcut
        var length = this.length();
        if (length === 0) return 0; // prevents division by zero
        return cpLength / length;
    },
    closestPointTangent: function(p) {
        var cpLength = this.closestPointLength(p);
        return this.tangentAtLength(cpLength);
    },
    // Returns `true` if the area surrounded by the polyline contains the point `p`.
    // Implements the even-odd SVG algorithm (self-intersections are "outside").
    // (Uses horizontal rays to the right of `p` to look for intersections.)
    // Closes open polylines (always imagines a final closing segment).
    containsPoint: function(p) {
        var points = this.points;
        var numPoints = points.length;
        if (numPoints === 0) return false; // shortcut (this polyline has no points)
        var x = p.x;
        var y = p.y;
        // initialize a final closing segment by creating one from last-first points on polyline
        var startIndex = numPoints - 1; // start of current polyline segment
        var endIndex = 0; // end of current polyline segment
        var numIntersections = 0;
        var segment = new (0, _lineMjs.Line)();
        var ray = new (0, _lineMjs.Line)();
        var rayEnd = new (0, _pointMjs.Point)();
        for(; endIndex < numPoints; endIndex++){
            var start = points[startIndex];
            var end = points[endIndex];
            if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)
            // current polyline segment
            segment.start = start;
            segment.end = end;
            if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)
            // do we have an intersection?
            if (y <= start.y && y > end.y || y > start.y && y <= end.y) {
                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`
                // (when `y === start.y === end.y`)
                // this conditional branch IS entered when `segment` touches `ray` at only one point
                // (e.g. when `y === start.y !== end.y`)
                // since this branch is entered again for the following segment, the two touches cancel out
                var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;
                if (xDifference >= 0) {
                    // segment lies at least partially to the right of `p`
                    rayEnd.x = x + xDifference;
                    rayEnd.y = y; // right
                    ray.start = p;
                    ray.end = rayEnd;
                    if (segment.intersect(ray)) // an intersection was detected to the right of `p`
                    numIntersections++;
                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)
            }
            // move to check the next polyline segment
            startIndex = endIndex;
        }
        // returns `true` for odd numbers of intersections (even-odd algorithm)
        return numIntersections % 2 === 1;
    },
    close: function() {
        const { start, end, points } = this;
        if (start && end && !start.equals(end)) points.push(start.clone());
        return this;
    },
    lengthPoints: function() {
        return this.points;
    },
    convexHull: function() {
        return new Polyline((0, _pointsMjs.convexHull)(this.points));
    },
    // Checks whether two polylines are exactly the same.
    // If `p` is undefined or null, returns false.
    equals: function(p) {
        if (!p) return false;
        var points = this.points;
        var otherPoints = p.points;
        var numPoints = points.length;
        if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal
        for(var i = 0; i < numPoints; i++){
            var point = points[i];
            var otherPoint = p.points[i];
            // as soon as an inequality is found in points, return false
            if (!point.equals(otherPoint)) return false;
        }
        // if no inequality found in points, return true
        return true;
    },
    intersectionWithLine: function(l) {
        var line = new (0, _lineMjs.Line)(l);
        var intersections = [];
        var points = this.lengthPoints();
        var l2 = new (0, _lineMjs.Line)();
        for(var i = 0, n = points.length - 1; i < n; i++){
            l2.start = points[i];
            l2.end = points[i + 1];
            var int = line.intersectionWithLine(l2);
            if (int) intersections.push(int[0]);
        }
        return intersections.length > 0 ? intersections : null;
    },
    isDifferentiable: function() {
        var points = this.points;
        var numPoints = points.length;
        if (numPoints === 0) return false;
        var line = new (0, _lineMjs.Line)();
        var n = numPoints - 1;
        for(var i = 0; i < n; i++){
            line.start = points[i];
            line.end = points[i + 1];
            // as soon as a differentiable line is found between two points, return true
            if (line.isDifferentiable()) return true;
        }
        // if no differentiable line is found between pairs of points, return false
        return false;
    },
    length: function() {
        var points = this.lengthPoints();
        var numPoints = points.length;
        if (numPoints === 0) return 0; // if points array is empty
        var length = 0;
        var n = numPoints - 1;
        for(var i = 0; i < n; i++)length += points[i].distance(points[i + 1]);
        return length;
    },
    pointAt: function(ratio) {
        var points = this.lengthPoints();
        var numPoints = points.length;
        if (numPoints === 0) return null; // if points array is empty
        if (numPoints === 1) return points[0].clone(); // if there is only one point
        if (ratio <= 0) return points[0].clone();
        if (ratio >= 1) return points[numPoints - 1].clone();
        var polylineLength = this.length();
        var length = polylineLength * ratio;
        return this.pointAtLength(length);
    },
    pointAtLength: function(length) {
        var points = this.lengthPoints();
        var numPoints = points.length;
        if (numPoints === 0) return null; // if points array is empty
        if (numPoints === 1) return points[0].clone(); // if there is only one point
        var fromStart = true;
        if (length < 0) {
            fromStart = false; // negative lengths mean start calculation from end point
            length = -length; // absolute value
        }
        var l = 0;
        var n = numPoints - 1;
        for(var i = 0; i < n; i++){
            var index = fromStart ? i : n - 1 - i;
            var a = points[index];
            var b = points[index + 1];
            var line = new (0, _lineMjs.Line)(a, b);
            var d = a.distance(b);
            if (length <= l + d) return line.pointAtLength((fromStart ? 1 : -1) * (length - l));
            l += d;
        }
        // if length requested is higher than the length of the polyline, return last endpoint
        var lastPoint = fromStart ? points[numPoints - 1] : points[0];
        return lastPoint.clone();
    },
    round: function(precision) {
        var points = this.points;
        var numPoints = points.length;
        for(var i = 0; i < numPoints; i++)points[i].round(precision);
        return this;
    },
    scale: function(sx, sy, origin) {
        var points = this.points;
        var numPoints = points.length;
        for(var i = 0; i < numPoints; i++)points[i].scale(sx, sy, origin);
        return this;
    },
    simplify: function(opt = {}) {
        const points = this.points;
        if (points.length < 3) return this; // we need at least 3 points
        // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification
        const threshold = opt.threshold || 0; // = max distance of middle point from chord to be simplified
        // start at the beginning of the polyline and go forward
        let currentIndex = 0;
        // we need at least one intermediate point (3 points) in every iteration
        // as soon as that stops being true, we know we reached the end of the polyline
        while(points[currentIndex + 2]){
            const firstIndex = currentIndex;
            const middleIndex = currentIndex + 1;
            const lastIndex = currentIndex + 2;
            const firstPoint = points[firstIndex];
            const middlePoint = points[middleIndex];
            const lastPoint = points[lastIndex];
            const chord = new (0, _lineMjs.Line)(firstPoint, lastPoint); // = connection between first and last point
            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point
            const closestPointDistance = closestPoint.distance(middlePoint);
            if (closestPointDistance <= threshold) // middle point is close enough to the chord = simplify
            // 1) remove middle point:
            points.splice(middleIndex, 1);
            else // middle point is far from the chord
            // 1) preserve middle point
            // 2) in next iteration, move `currentIndex` by one step:
            currentIndex += 1;
        }
        // `points` array was modified in-place
        return this;
    },
    tangentAt: function(ratio) {
        var points = this.lengthPoints();
        var numPoints = points.length;
        if (numPoints === 0) return null; // if points array is empty
        if (numPoints === 1) return null; // if there is only one point
        if (ratio < 0) ratio = 0;
        if (ratio > 1) ratio = 1;
        var polylineLength = this.length();
        var length = polylineLength * ratio;
        return this.tangentAtLength(length);
    },
    tangentAtLength: function(length) {
        var points = this.lengthPoints();
        var numPoints = points.length;
        if (numPoints === 0) return null; // if points array is empty
        if (numPoints === 1) return null; // if there is only one point
        var fromStart = true;
        if (length < 0) {
            fromStart = false; // negative lengths mean start calculation from end point
            length = -length; // absolute value
        }
        var lastValidLine; // differentiable (with a tangent)
        var l = 0; // length so far
        var n = numPoints - 1;
        for(var i = 0; i < n; i++){
            var index = fromStart ? i : n - 1 - i;
            var a = points[index];
            var b = points[index + 1];
            var line = new (0, _lineMjs.Line)(a, b);
            var d = a.distance(b);
            if (line.isDifferentiable()) {
                if (length <= l + d) return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));
                lastValidLine = line;
            }
            l += d;
        }
        // if length requested is higher than the length of the polyline, return last valid endpoint
        if (lastValidLine) {
            var ratio = fromStart ? 1 : 0;
            return lastValidLine.tangentAt(ratio);
        }
        // if no valid line, return null
        return null;
    },
    toString: function() {
        return this.points + "";
    },
    translate: function(tx, ty) {
        var points = this.points;
        var numPoints = points.length;
        for(var i = 0; i < numPoints; i++)points[i].translate(tx, ty);
        return this;
    },
    // Return svgString that can be used to recreate this line.
    serialize: function() {
        var points = this.points;
        var numPoints = points.length;
        if (numPoints === 0) return ""; // if points array is empty
        var output = "";
        for(var i = 0; i < numPoints; i++){
            var point = points[i];
            output += point.x + "," + point.y + " ";
        }
        return output.trim();
    }
};
Object.defineProperty(Polyline.prototype, "start", {
    // Getter for the first point of the polyline.
    configurable: true,
    enumerable: true,
    get: function() {
        var points = this.points;
        var numPoints = points.length;
        if (numPoints === 0) return null; // if points array is empty
        return this.points[0];
    }
});
Object.defineProperty(Polyline.prototype, "end", {
    // Getter for the last point of the polyline.
    configurable: true,
    enumerable: true,
    get: function() {
        var points = this.points;
        var numPoints = points.length;
        if (numPoints === 0) return null; // if points array is empty
        return this.points[numPoints - 1];
    }
});

},{"./rect.mjs":"6MvV7","./point.mjs":"7vrrP","./line.mjs":"f7trh","./types.mjs":"217db","./points.mjs":"kAIcD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6MvV7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Rect", ()=>Rect);
parcelHelpers.export(exports, "rect", ()=>rect);
var _geometryHelpersMjs = require("./geometry.helpers.mjs");
var _lineMjs = require("./line.mjs");
var _pointMjs = require("./point.mjs");
var _ellipseMjs = require("./ellipse.mjs");
var _typesMjs = require("./types.mjs");
const { abs, cos, sin, min, max, round, pow } = Math;
const Rect = function(x, y, w, h) {
    if (!(this instanceof Rect)) return new Rect(x, y, w, h);
    if (Object(x) === x) {
        y = x.y;
        w = x.width;
        h = x.height;
        x = x.x;
    }
    this.x = x === undefined ? 0 : x;
    this.y = y === undefined ? 0 : y;
    this.width = w === undefined ? 0 : w;
    this.height = h === undefined ? 0 : h;
};
Rect.fromEllipse = function(e) {
    e = new (0, _ellipseMjs.Ellipse)(e);
    return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);
};
Rect.fromPointUnion = function(...points) {
    if (points.length === 0) return null;
    const p = new (0, _pointMjs.Point)();
    let minX, minY, maxX, maxY;
    minX = minY = Infinity;
    maxX = maxY = -Infinity;
    for(let i = 0; i < points.length; i++){
        p.update(points[i]);
        const x = p.x;
        const y = p.y;
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
    }
    return new Rect(minX, minY, maxX - minX, maxY - minY);
};
Rect.fromRectUnion = function(...rects) {
    if (rects.length === 0) return null;
    const r = new Rect();
    let minX, minY, maxX, maxY;
    minX = minY = Infinity;
    maxX = maxY = -Infinity;
    for(let i = 0; i < rects.length; i++){
        r.update(rects[i]);
        const x = r.x;
        const y = r.y;
        const mX = x + r.width;
        const mY = y + r.height;
        if (x < minX) minX = x;
        if (mX > maxX) maxX = mX;
        if (y < minY) minY = y;
        if (mY > maxY) maxY = mY;
    }
    return new Rect(minX, minY, maxX - minX, maxY - minY);
};
Rect.prototype = {
    type: (0, _typesMjs.types).Rect,
    // Find my bounding box when I'm rotated with the center of rotation in the center of me.
    // @return r {rectangle} representing a bounding box
    bbox: function(angle) {
        return this.clone().rotateAroundCenter(angle);
    },
    rotateAroundCenter: function(angle) {
        if (!angle) return this;
        const { width, height } = this;
        const theta = (0, _geometryHelpersMjs.toRad)(angle);
        const st = abs(sin(theta));
        const ct = abs(cos(theta));
        const w = width * ct + height * st;
        const h = width * st + height * ct;
        this.x += (width - w) / 2;
        this.y += (height - h) / 2;
        this.width = w;
        this.height = h;
        return this;
    },
    bottomLeft: function() {
        return new (0, _pointMjs.Point)(this.x, this.y + this.height);
    },
    bottomLine: function() {
        return new (0, _lineMjs.Line)(this.bottomLeft(), this.bottomRight());
    },
    bottomMiddle: function() {
        return new (0, _pointMjs.Point)(this.x + this.width / 2, this.y + this.height);
    },
    center: function() {
        return new (0, _pointMjs.Point)(this.x + this.width / 2, this.y + this.height / 2);
    },
    clone: function() {
        return new Rect(this);
    },
    // @return {bool} true if point p is inside me.
    containsPoint: function(p) {
        p = new (0, _pointMjs.Point)(p);
        return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;
    },
    // @return {bool} true if rectangle `r` is inside me.
    containsRect: function(r) {
        var r0 = new Rect(this).normalize();
        var r1 = new Rect(r).normalize();
        var w0 = r0.width;
        var h0 = r0.height;
        var w1 = r1.width;
        var h1 = r1.height;
        if (!w0 || !h0 || !w1 || !h1) // At least one of the dimensions is 0
        return false;
        var x0 = r0.x;
        var y0 = r0.y;
        var x1 = r1.x;
        var y1 = r1.y;
        w1 += x1;
        w0 += x0;
        h1 += y1;
        h0 += y0;
        return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;
    },
    corner: function() {
        return new (0, _pointMjs.Point)(this.x + this.width, this.y + this.height);
    },
    // @return {boolean} true if rectangles are equal.
    equals: function(r) {
        var mr = new Rect(this).normalize();
        var nr = new Rect(r).normalize();
        return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;
    },
    // inflate by dx and dy, recompute origin [x, y]
    // @param dx {delta_x} representing additional size to x
    // @param dy {delta_y} representing additional size to y -
    // dy param is not required -> in that case y is sized by dx
    inflate: function(dx, dy) {
        if (dx === undefined) dx = 0;
        if (dy === undefined) dy = dx;
        this.x -= dx;
        this.y -= dy;
        this.width += 2 * dx;
        this.height += 2 * dy;
        return this;
    },
    // @return {rect} if rectangles intersect, {null} if not.
    intersect: function(r) {
        var myOrigin = this.origin();
        var myCorner = this.corner();
        var rOrigin = r.origin();
        var rCorner = r.corner();
        // No intersection found
        if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) return null;
        var x = max(myOrigin.x, rOrigin.x);
        var y = max(myOrigin.y, rOrigin.y);
        return new Rect(x, y, min(myCorner.x, rCorner.x) - x, min(myCorner.y, rCorner.y) - y);
    },
    intersectionWithLine: function(line) {
        var r = this;
        var rectLines = [
            r.topLine(),
            r.rightLine(),
            r.bottomLine(),
            r.leftLine()
        ];
        var points = [];
        var dedupeArr = [];
        var pt, i;
        var n = rectLines.length;
        for(i = 0; i < n; i++){
            pt = line.intersect(rectLines[i]);
            if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {
                points.push(pt);
                dedupeArr.push(pt.toString());
            }
        }
        return points.length > 0 ? points : null;
    },
    // Find point on my boundary where line starting
    // from my center ending in point p intersects me.
    // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.
    intersectionWithLineFromCenterToPoint: function(p, angle) {
        p = new (0, _pointMjs.Point)(p);
        var center = new (0, _pointMjs.Point)(this.x + this.width / 2, this.y + this.height / 2);
        var result;
        if (angle) p.rotate(center, angle);
        // (clockwise, starting from the top side)
        var sides = [
            this.topLine(),
            this.rightLine(),
            this.bottomLine(),
            this.leftLine()
        ];
        var connector = new (0, _lineMjs.Line)(center, p);
        for(var i = sides.length - 1; i >= 0; --i){
            var intersection = sides[i].intersection(connector);
            if (intersection !== null) {
                result = intersection;
                break;
            }
        }
        if (result && angle) result.rotate(center, -angle);
        return result;
    },
    leftLine: function() {
        return new (0, _lineMjs.Line)(this.topLeft(), this.bottomLeft());
    },
    leftMiddle: function() {
        return new (0, _pointMjs.Point)(this.x, this.y + this.height / 2);
    },
    maxRectScaleToFit: function(rect, origin) {
        rect = new Rect(rect);
        origin || (origin = rect.center());
        var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;
        var ox = origin.x;
        var oy = origin.y;
        // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,
        // so when the scale is applied the point is still inside the rectangle.
        sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;
        // Top Left
        var p1 = rect.topLeft();
        if (p1.x < ox) sx1 = (this.x - ox) / (p1.x - ox);
        if (p1.y < oy) sy1 = (this.y - oy) / (p1.y - oy);
        // Bottom Right
        var p2 = rect.bottomRight();
        if (p2.x > ox) sx2 = (this.x + this.width - ox) / (p2.x - ox);
        if (p2.y > oy) sy2 = (this.y + this.height - oy) / (p2.y - oy);
        // Top Right
        var p3 = rect.topRight();
        if (p3.x > ox) sx3 = (this.x + this.width - ox) / (p3.x - ox);
        if (p3.y < oy) sy3 = (this.y - oy) / (p3.y - oy);
        // Bottom Left
        var p4 = rect.bottomLeft();
        if (p4.x < ox) sx4 = (this.x - ox) / (p4.x - ox);
        if (p4.y > oy) sy4 = (this.y + this.height - oy) / (p4.y - oy);
        return {
            sx: min(sx1, sx2, sx3, sx4),
            sy: min(sy1, sy2, sy3, sy4)
        };
    },
    maxRectUniformScaleToFit: function(rect, origin) {
        var scale = this.maxRectScaleToFit(rect, origin);
        return min(scale.sx, scale.sy);
    },
    // Move and expand me.
    // @param r {rectangle} representing deltas
    moveAndExpand: function(r) {
        this.x += r.x || 0;
        this.y += r.y || 0;
        this.width += r.width || 0;
        this.height += r.height || 0;
        return this;
    },
    // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.
    // If width < 0 the function swaps the left and right corners,
    // and it swaps the top and bottom corners if height < 0
    // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized
    normalize: function() {
        var newx = this.x;
        var newy = this.y;
        var newwidth = this.width;
        var newheight = this.height;
        if (this.width < 0) {
            newx = this.x + this.width;
            newwidth = -this.width;
        }
        if (this.height < 0) {
            newy = this.y + this.height;
            newheight = -this.height;
        }
        this.x = newx;
        this.y = newy;
        this.width = newwidth;
        this.height = newheight;
        return this;
    },
    // Offset me by the specified amount.
    offset: function(dx, dy) {
        // pretend that this is a point and call offset()
        // rewrites x and y according to dx and dy
        return (0, _pointMjs.Point).prototype.offset.call(this, dx, dy);
    },
    origin: function() {
        return new (0, _pointMjs.Point)(this.x, this.y);
    },
    // @return {point} a point on my boundary nearest to the given point.
    // @see Squeak Smalltalk, Rectangle>>pointNearestTo:
    pointNearestToPoint: function(point) {
        point = new (0, _pointMjs.Point)(point);
        if (this.containsPoint(point)) {
            var side = this.sideNearestToPoint(point);
            switch(side){
                case "right":
                    return new (0, _pointMjs.Point)(this.x + this.width, point.y);
                case "left":
                    return new (0, _pointMjs.Point)(this.x, point.y);
                case "bottom":
                    return new (0, _pointMjs.Point)(point.x, this.y + this.height);
                case "top":
                    return new (0, _pointMjs.Point)(point.x, this.y);
            }
        }
        return point.adhereToRect(this);
    },
    rightLine: function() {
        return new (0, _lineMjs.Line)(this.topRight(), this.bottomRight());
    },
    rightMiddle: function() {
        return new (0, _pointMjs.Point)(this.x + this.width, this.y + this.height / 2);
    },
    round: function(precision) {
        let f = 1; // case 0
        if (precision) switch(precision){
            case 1:
                f = 10;
                break;
            case 2:
                f = 100;
                break;
            case 3:
                f = 1000;
                break;
            default:
                f = pow(10, precision);
                break;
        }
        this.x = round(this.x * f) / f;
        this.y = round(this.y * f) / f;
        this.width = round(this.width * f) / f;
        this.height = round(this.height * f) / f;
        return this;
    },
    // Scale rectangle with origin.
    scale: function(sx, sy, origin) {
        origin = this.origin().scale(sx, sy, origin);
        this.x = origin.x;
        this.y = origin.y;
        this.width *= sx;
        this.height *= sy;
        return this;
    },
    // @return {string} (left|right|top|bottom) side which is nearest to point
    // @see Squeak Smalltalk, Rectangle>>sideNearestTo:
    sideNearestToPoint: function(point) {
        point = new (0, _pointMjs.Point)(point);
        var distToLeft = point.x - this.x;
        var distToRight = this.x + this.width - point.x;
        var distToTop = point.y - this.y;
        var distToBottom = this.y + this.height - point.y;
        var closest = distToLeft;
        var side = "left";
        if (distToRight < closest) {
            closest = distToRight;
            side = "right";
        }
        if (distToTop < closest) {
            closest = distToTop;
            side = "top";
        }
        if (distToBottom < closest) // closest = distToBottom;
        side = "bottom";
        return side;
    },
    snapToGrid: function(gx, gy) {
        var origin = this.origin().snapToGrid(gx, gy);
        var corner = this.corner().snapToGrid(gx, gy);
        this.x = origin.x;
        this.y = origin.y;
        this.width = corner.x - origin.x;
        this.height = corner.y - origin.y;
        return this;
    },
    toJSON: function() {
        return {
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height
        };
    },
    topLine: function() {
        return new (0, _lineMjs.Line)(this.topLeft(), this.topRight());
    },
    topMiddle: function() {
        return new (0, _pointMjs.Point)(this.x + this.width / 2, this.y);
    },
    topRight: function() {
        return new (0, _pointMjs.Point)(this.x + this.width, this.y);
    },
    toString: function() {
        return this.origin().toString() + " " + this.corner().toString();
    },
    // @return {rect} representing the union of both rectangles.
    union: function(rect) {
        return Rect.fromRectUnion(this, rect);
    },
    update: function(x, y, w, h) {
        if (Object(x) === x) {
            y = x.y;
            w = x.width;
            h = x.height;
            x = x.x;
        }
        this.x = x || 0;
        this.y = y || 0;
        this.width = w || 0;
        this.height = h || 0;
        return this;
    }
};
Rect.prototype.bottomRight = Rect.prototype.corner;
Rect.prototype.topLeft = Rect.prototype.origin;
Rect.prototype.translate = Rect.prototype.offset;
const rect = Rect;

},{"./geometry.helpers.mjs":"cjTph","./line.mjs":"f7trh","./point.mjs":"7vrrP","./ellipse.mjs":"fjvxW","./types.mjs":"217db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f7trh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Line", ()=>Line);
parcelHelpers.export(exports, "line", ()=>line);
var _pointMjs = require("./point.mjs");
var _rectMjs = require("./rect.mjs");
var _lineBearingMjs = require("./line.bearing.mjs");
var _lineSquaredLengthMjs = require("./line.squaredLength.mjs");
var _lineLengthMjs = require("./line.length.mjs");
var _typesMjs = require("./types.mjs");
const { max, min } = Math;
const Line = function(p1, p2) {
    if (!(this instanceof Line)) return new Line(p1, p2);
    if (p1 instanceof Line) return new Line(p1.start, p1.end);
    this.start = new (0, _pointMjs.Point)(p1);
    this.end = new (0, _pointMjs.Point)(p2);
};
Line.prototype = {
    type: (0, _typesMjs.types).Line,
    // @returns the angle of incline of the line.
    angle: function() {
        var horizontalPoint = new (0, _pointMjs.Point)(this.start.x + 1, this.start.y);
        return this.start.angleBetween(this.end, horizontalPoint);
    },
    bbox: function() {
        var left = min(this.start.x, this.end.x);
        var top = min(this.start.y, this.end.y);
        var right = max(this.start.x, this.end.x);
        var bottom = max(this.start.y, this.end.y);
        return new (0, _rectMjs.Rect)(left, top, right - left, bottom - top);
    },
    // @return the bearing (cardinal direction) of the line. For example N, W, or SE.
    // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.
    bearing: function() {
        return (0, _lineBearingMjs.bearing)(this.start, this.end);
    },
    clone: function() {
        return new Line(this.start, this.end);
    },
    // @return {point} the closest point on the line to point `p`
    closestPoint: function(p) {
        return this.pointAt(this.closestPointNormalizedLength(p));
    },
    closestPointLength: function(p) {
        return this.closestPointNormalizedLength(p) * this.length();
    },
    // @return {number} the normalized length of the closest point on the line to point `p`
    closestPointNormalizedLength: function(p) {
        var product = this.vector().dot(new Line(this.start, p).vector());
        var cpNormalizedLength = min(1, max(0, product / this.squaredLength()));
        // cpNormalizedLength returns `NaN` if this line has zero length
        // we can work with that - if `NaN`, return 0
        if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`
        // (`NaN` is the only value that is not equal to itself)
        return cpNormalizedLength;
    },
    closestPointTangent: function(p) {
        return this.tangentAt(this.closestPointNormalizedLength(p));
    },
    // Returns `true` if the point lies on the line.
    containsPoint: function(p) {
        var start = this.start;
        var end = this.end;
        if (start.cross(p, end) !== 0) return false;
        // else: cross product of 0 indicates that this line and the vector to `p` are collinear
        var length = this.length();
        if (new Line(start, p).length() > length) return false;
        if (new Line(p, end).length() > length) return false;
        // else: `p` lies between start and end of the line
        return true;
    },
    // Divides the line into two at requested `ratio` between 0 and 1.
    divideAt: function(ratio) {
        var dividerPoint = this.pointAt(ratio);
        // return array with two lines
        return [
            new Line(this.start, dividerPoint),
            new Line(dividerPoint, this.end)
        ];
    },
    // Divides the line into two at requested `length`.
    divideAtLength: function(length) {
        var dividerPoint = this.pointAtLength(length);
        // return array with two new lines
        return [
            new Line(this.start, dividerPoint),
            new Line(dividerPoint, this.end)
        ];
    },
    equals: function(l) {
        return !!l && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;
    },
    // @return {point} Point where I'm intersecting a line.
    // @return [point] Points where I'm intersecting a rectangle.
    // @see Squeak Smalltalk, LineSegment>>intersectionWith:
    intersect: function(shape, opt) {
        if (shape && shape.intersectionWithLine) {
            var intersection = shape.intersectionWithLine(this, opt);
            // Backwards compatibility
            if (intersection && shape instanceof Line) intersection = intersection[0];
            return intersection;
        }
        return null;
    },
    intersectionWithLine: function(line) {
        var pt1Dir = new (0, _pointMjs.Point)(this.end.x - this.start.x, this.end.y - this.start.y);
        var pt2Dir = new (0, _pointMjs.Point)(line.end.x - line.start.x, line.end.y - line.start.y);
        var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;
        var deltaPt = new (0, _pointMjs.Point)(line.start.x - this.start.x, line.start.y - this.start.y);
        var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;
        var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;
        if (det === 0 || alpha * det < 0 || beta * det < 0) // No intersection found.
        return null;
        if (det > 0) {
            if (alpha > det || beta > det) return null;
        } else {
            if (alpha < det || beta < det) return null;
        }
        return [
            new (0, _pointMjs.Point)(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det)
        ];
    },
    isDifferentiable: function() {
        return !this.start.equals(this.end);
    },
    // @return {double} length of the line
    length: function() {
        return (0, _lineLengthMjs.length)(this.start, this.end);
    },
    // @return {point} my midpoint
    midpoint: function() {
        return new (0, _pointMjs.Point)((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
    },
    parallel: function(distance) {
        const l = this.clone();
        if (!this.isDifferentiable()) return l;
        const { start, end } = l;
        const eRef = start.clone().rotate(end, 270);
        const sRef = end.clone().rotate(start, 90);
        start.move(sRef, distance);
        end.move(eRef, distance);
        return l;
    },
    // @return {point} my point at 't' <0,1>
    pointAt: function(t) {
        var start = this.start;
        var end = this.end;
        if (t <= 0) return start.clone();
        if (t >= 1) return end.clone();
        return start.lerp(end, t);
    },
    pointAtLength: function(length) {
        var start = this.start;
        var end = this.end;
        var fromStart = true;
        if (length < 0) {
            fromStart = false; // negative lengths mean start calculation from end point
            length = -length; // absolute value
        }
        var lineLength = this.length();
        if (length >= lineLength) return fromStart ? end.clone() : start.clone();
        return this.pointAt((fromStart ? length : lineLength - length) / lineLength);
    },
    // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.
    pointOffset: function(p) {
        // Find the sign of the determinant of vectors (start,end), where p is the query point.
        p = new (0, _pointMjs.Point)(p);
        var start = this.start;
        var end = this.end;
        var determinant = (end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x);
        return determinant / this.length();
    },
    rotate: function(origin, angle) {
        this.start.rotate(origin, angle);
        this.end.rotate(origin, angle);
        return this;
    },
    round: function(precision) {
        this.start.round(precision);
        this.end.round(precision);
        return this;
    },
    scale: function(sx, sy, origin) {
        this.start.scale(sx, sy, origin);
        this.end.scale(sx, sy, origin);
        return this;
    },
    // @return {number} scale the line so that it has the requested length
    setLength: function(length) {
        var currentLength = this.length();
        if (!currentLength) return this;
        var scaleFactor = length / currentLength;
        return this.scale(scaleFactor, scaleFactor, this.start);
    },
    // @return {integer} length without sqrt
    // @note for applications where the exact length is not necessary (e.g. compare only)
    squaredLength: function() {
        return (0, _lineSquaredLengthMjs.squaredLength)(this.start, this.end);
    },
    tangentAt: function(t) {
        if (!this.isDifferentiable()) return null;
        var start = this.start;
        var end = this.end;
        var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1
        var tangentLine = new Line(start, end);
        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested
        return tangentLine;
    },
    tangentAtLength: function(length) {
        if (!this.isDifferentiable()) return null;
        var start = this.start;
        var end = this.end;
        var tangentStart = this.pointAtLength(length);
        var tangentLine = new Line(start, end);
        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested
        return tangentLine;
    },
    toString: function() {
        return this.start.toString() + " " + this.end.toString();
    },
    serialize: function() {
        return this.start.serialize() + " " + this.end.serialize();
    },
    translate: function(tx, ty) {
        this.start.translate(tx, ty);
        this.end.translate(tx, ty);
        return this;
    },
    // @return vector {point} of the line
    vector: function() {
        return new (0, _pointMjs.Point)(this.end.x - this.start.x, this.end.y - this.start.y);
    }
};
// For backwards compatibility:
Line.prototype.intersection = Line.prototype.intersect;
const line = Line;

},{"./point.mjs":"7vrrP","./rect.mjs":"6MvV7","./line.bearing.mjs":"bANOv","./line.squaredLength.mjs":"kh3Mx","./line.length.mjs":"6KN6K","./types.mjs":"217db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7vrrP":[function(require,module,exports) {
/*
    Point is the most basic object consisting of x/y coordinate.

    Possible instantiations are:
    * `Point(10, 20)`
    * `new Point(10, 20)`
    * `Point('10 20')`
    * `Point(Point(10, 20))`
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Point", ()=>Point);
parcelHelpers.export(exports, "point", ()=>point);
var _geometryHelpersMjs = require("./geometry.helpers.mjs");
var _lineBearingMjs = require("./line.bearing.mjs");
var _lineSquaredLengthMjs = require("./line.squaredLength.mjs");
var _lineLengthMjs = require("./line.length.mjs");
var _typesMjs = require("./types.mjs");
const { abs, cos, sin, sqrt, min, max, atan2, round, pow, PI } = Math;
const Point = function(x, y) {
    if (!(this instanceof Point)) return new Point(x, y);
    if (typeof x === "string") {
        var xy = x.split(x.indexOf("@") === -1 ? " " : "@");
        x = parseFloat(xy[0]);
        y = parseFloat(xy[1]);
    } else if (Object(x) === x) {
        y = x.y;
        x = x.x;
    }
    this.x = x === undefined ? 0 : x;
    this.y = y === undefined ? 0 : y;
};
// Alternative constructor, from polar coordinates.
// @param {number} Distance.
// @param {number} Angle in radians.
// @param {point} [optional] Origin.
Point.fromPolar = function(distance, angle, origin) {
    origin = new Point(origin);
    var x = abs(distance * cos(angle));
    var y = abs(distance * sin(angle));
    var deg = (0, _geometryHelpersMjs.normalizeAngle)((0, _geometryHelpersMjs.toDeg)(angle));
    if (deg < 90) y = -y;
    else if (deg < 180) {
        x = -x;
        y = -y;
    } else if (deg < 270) x = -x;
    return new Point(origin.x + x, origin.y + y);
};
// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.
Point.random = function(x1, x2, y1, y2) {
    return new Point((0, _geometryHelpersMjs.random)(x1, x2), (0, _geometryHelpersMjs.random)(y1, y2));
};
Point.prototype = {
    type: (0, _typesMjs.types).Point,
    chooseClosest: function(points) {
        var n = points.length;
        if (n === 1) return new Point(points[0]);
        var closest = null;
        var minSqrDistance = Infinity;
        for(var i = 0; i < n; i++){
            var p = new Point(points[i]);
            var sqrDistance = this.squaredDistance(p);
            if (sqrDistance < minSqrDistance) {
                closest = p;
                minSqrDistance = sqrDistance;
            }
        }
        return closest;
    },
    // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,
    // otherwise return point itself.
    // (see Squeak Smalltalk, Point>>adhereTo:)
    adhereToRect: function(r) {
        if (r.containsPoint(this)) return this;
        this.x = min(max(this.x, r.x), r.x + r.width);
        this.y = min(max(this.y, r.y), r.y + r.height);
        return this;
    },
    // Compute the angle between vector from me to p1 and the vector from me to p2.
    // ordering of points p1 and p2 is important!
    // theta function's angle convention:
    // returns angles between 0 and 180 when the angle is counterclockwise
    // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones
    // returns NaN if any of the points p1, p2 is coincident with this point
    angleBetween: function(p1, p2) {
        var angleBetween = this.equals(p1) || this.equals(p2) ? NaN : this.theta(p2) - this.theta(p1);
        if (angleBetween < 0) angleBetween += 360; // correction to keep angleBetween between 0 and 360
        return angleBetween;
    },
    // Return the bearing between me and the given point.
    bearing: function(point) {
        return (0, _lineBearingMjs.bearing)(this, point);
    },
    // Returns change in angle from my previous position (-dx, -dy) to my new position
    // relative to ref point.
    changeInAngle: function(dx, dy, ref) {
        // Revert the translation and measure the change in angle around x-axis.
        return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);
    },
    clone: function() {
        return new Point(this);
    },
    // Returns the cross product of this point relative to two other points
    // this point is the common point
    // point p1 lies on the first vector, point p2 lies on the second vector
    // watch out for the ordering of points p1 and p2!
    // positive result indicates a clockwise ("right") turn from first to second vector
    // negative result indicates a counterclockwise ("left") turn from first to second vector
    // zero indicates that the first and second vector are collinear
    // note that the above directions are reversed from the usual answer on the Internet
    // that is because we are in a left-handed coord system (because the y-axis points downward)
    cross: function(p1, p2) {
        return p1 && p2 ? (p2.x - this.x) * (p1.y - this.y) - (p2.y - this.y) * (p1.x - this.x) : NaN;
    },
    difference: function(dx, dy) {
        if (Object(dx) === dx) {
            dy = dx.y;
            dx = dx.x;
        }
        return new Point(this.x - (dx || 0), this.y - (dy || 0));
    },
    // Returns distance between me and point `p`.
    distance: function(p) {
        return (0, _lineLengthMjs.length)(this, p);
    },
    // Returns the dot product of this point with given other point
    dot: function(p) {
        return p ? this.x * p.x + this.y * p.y : NaN;
    },
    equals: function(p) {
        return !!p && this.x === p.x && this.y === p.y;
    },
    // Linear interpolation
    lerp: function(p, t) {
        var x = this.x;
        var y = this.y;
        return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);
    },
    magnitude: function() {
        return sqrt(this.x * this.x + this.y * this.y) || 0.01;
    },
    // Returns a manhattan (taxi-cab) distance between me and point `p`.
    manhattanDistance: function(p) {
        return abs(p.x - this.x) + abs(p.y - this.y);
    },
    // Move point on line starting from ref ending at me by
    // distance distance.
    move: function(ref, distance) {
        var theta = (0, _geometryHelpersMjs.toRad)(new Point(ref).theta(this));
        var offset = this.offset(cos(theta) * distance, -sin(theta) * distance);
        return offset;
    },
    // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.
    normalize: function(length) {
        var scale = (length || 1) / this.magnitude();
        return this.scale(scale, scale);
    },
    // Offset me by the specified amount.
    offset: function(dx, dy) {
        if (Object(dx) === dx) {
            dy = dx.y;
            dx = dx.x;
        }
        this.x += dx || 0;
        this.y += dy || 0;
        return this;
    },
    // Returns a point that is the reflection of me with
    // the center of inversion in ref point.
    reflection: function(ref) {
        return new Point(ref).move(this, this.distance(ref));
    },
    // Rotate point by angle around origin.
    // Angle is flipped because this is a left-handed coord system (y-axis points downward).
    rotate: function(origin, angle) {
        if (angle === 0) return this;
        origin = origin || new Point(0, 0);
        angle = (0, _geometryHelpersMjs.toRad)((0, _geometryHelpersMjs.normalizeAngle)(-angle));
        var cosAngle = cos(angle);
        var sinAngle = sin(angle);
        var x = cosAngle * (this.x - origin.x) - sinAngle * (this.y - origin.y) + origin.x;
        var y = sinAngle * (this.x - origin.x) + cosAngle * (this.y - origin.y) + origin.y;
        this.x = x;
        this.y = y;
        return this;
    },
    round: function(precision) {
        let f = 1; // case 0
        if (precision) switch(precision){
            case 1:
                f = 10;
                break;
            case 2:
                f = 100;
                break;
            case 3:
                f = 1000;
                break;
            default:
                f = pow(10, precision);
                break;
        }
        this.x = round(this.x * f) / f;
        this.y = round(this.y * f) / f;
        return this;
    },
    // Scale point with origin.
    scale: function(sx, sy, origin) {
        origin = origin && new Point(origin) || new Point(0, 0);
        this.x = origin.x + sx * (this.x - origin.x);
        this.y = origin.y + sy * (this.y - origin.y);
        return this;
    },
    snapToGrid: function(gx, gy) {
        this.x = (0, _geometryHelpersMjs.snapToGrid)(this.x, gx);
        this.y = (0, _geometryHelpersMjs.snapToGrid)(this.y, gy || gx);
        return this;
    },
    squaredDistance: function(p) {
        return (0, _lineSquaredLengthMjs.squaredLength)(this, p);
    },
    // Compute the angle between me and `p` and the x axis.
    // (cartesian-to-polar coordinates conversion)
    // Return theta angle in degrees.
    theta: function(p) {
        p = new Point(p);
        // Invert the y-axis.
        var y = -(p.y - this.y);
        var x = p.x - this.x;
        var rad = atan2(y, x); // defined for all 0 corner cases
        // Correction for III. and IV. quadrant.
        if (rad < 0) rad = 2 * PI + rad;
        return 180 * rad / PI;
    },
    toJSON: function() {
        return {
            x: this.x,
            y: this.y
        };
    },
    // Converts rectangular to polar coordinates.
    // An origin can be specified, otherwise it's 0@0.
    toPolar: function(o) {
        o = o && new Point(o) || new Point(0, 0);
        var x = this.x;
        var y = this.y;
        this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r
        this.y = (0, _geometryHelpersMjs.toRad)(o.theta(new Point(x, y)));
        return this;
    },
    toString: function() {
        return this.x + "@" + this.y;
    },
    serialize: function() {
        return this.x + "," + this.y;
    },
    update: function(x, y) {
        if (Object(x) === x) {
            y = x.y;
            x = x.x;
        }
        this.x = x || 0;
        this.y = y || 0;
        return this;
    },
    // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.
    // Returns NaN if p is at 0,0.
    vectorAngle: function(p) {
        var zero = new Point(0, 0);
        return zero.angleBetween(this, p);
    }
};
Point.prototype.translate = Point.prototype.offset;
const point = Point;

},{"./geometry.helpers.mjs":"cjTph","./line.bearing.mjs":"bANOv","./line.squaredLength.mjs":"kh3Mx","./line.length.mjs":"6KN6K","./types.mjs":"217db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bANOv":[function(require,module,exports) {
// @return the bearing (cardinal direction) of the line. For example N, W, or SE.
// @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bearing", ()=>bearing);
var _geometryHelpersMjs = require("./geometry.helpers.mjs");
const { cos, sin, atan2 } = Math;
const bearing = function(p, q) {
    var lat1 = (0, _geometryHelpersMjs.toRad)(p.y);
    var lat2 = (0, _geometryHelpersMjs.toRad)(q.y);
    var lon1 = p.x;
    var lon2 = q.x;
    var dLon = (0, _geometryHelpersMjs.toRad)(lon2 - lon1);
    var y = sin(dLon) * cos(lat2);
    var x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);
    var brng = (0, _geometryHelpersMjs.toDeg)(atan2(y, x));
    var bearings = [
        "NE",
        "E",
        "SE",
        "S",
        "SW",
        "W",
        "NW",
        "N"
    ];
    var index = brng - 22.5;
    if (index < 0) index += 360;
    index = parseInt(index / 45);
    return bearings[index];
};

},{"./geometry.helpers.mjs":"cjTph","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kh3Mx":[function(require,module,exports) {
// @return {integer} length without sqrt
// @note for applications where the exact length is not necessary (e.g. compare only)
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "squaredLength", ()=>squaredLength);
const squaredLength = function(start, end) {
    var x0 = start.x;
    var y0 = start.y;
    var x1 = end.x;
    var y1 = end.y;
    return (x0 -= x1) * x0 + (y0 -= y1) * y0;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6KN6K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "length", ()=>length);
var _lineSquaredLengthMjs = require("./line.squaredLength.mjs");
const length = function(start, end) {
    return Math.sqrt((0, _lineSquaredLengthMjs.squaredLength)(start, end));
};

},{"./line.squaredLength.mjs":"kh3Mx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"217db":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "types", ()=>types);
const types = {
    Point: 1,
    Line: 2,
    Ellipse: 3,
    Rect: 4,
    Polyline: 5,
    Polygon: 6,
    Curve: 7,
    Path: 8
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fjvxW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Ellipse", ()=>Ellipse);
parcelHelpers.export(exports, "ellipse", ()=>ellipse);
var _rectMjs = require("./rect.mjs");
var _pointMjs = require("./point.mjs");
var _typesMjs = require("./types.mjs");
const { sqrt, round, pow } = Math;
const Ellipse = function(c, a, b) {
    if (!(this instanceof Ellipse)) return new Ellipse(c, a, b);
    if (c instanceof Ellipse) return new Ellipse(new (0, _pointMjs.Point)(c.x, c.y), c.a, c.b);
    c = new (0, _pointMjs.Point)(c);
    this.x = c.x;
    this.y = c.y;
    this.a = a;
    this.b = b;
};
Ellipse.fromRect = function(rect) {
    rect = new (0, _rectMjs.Rect)(rect);
    return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);
};
Ellipse.prototype = {
    type: (0, _typesMjs.types).Ellipse,
    bbox: function() {
        return new (0, _rectMjs.Rect)(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);
    },
    /**
     * @returns {g.Point}
     */ center: function() {
        return new (0, _pointMjs.Point)(this.x, this.y);
    },
    clone: function() {
        return new Ellipse(this);
    },
    /**
     * @param {g.Point} p
     * @returns {boolean}
     */ containsPoint: function(p) {
        return this.normalizedDistance(p) <= 1;
    },
    equals: function(ellipse) {
        return !!ellipse && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;
    },
    // inflate by dx and dy
    // @param dx {delta_x} representing additional size to x
    // @param dy {delta_y} representing additional size to y -
    // dy param is not required -> in that case y is sized by dx
    inflate: function(dx, dy) {
        if (dx === undefined) dx = 0;
        if (dy === undefined) dy = dx;
        this.a += 2 * dx;
        this.b += 2 * dy;
        return this;
    },
    intersectionWithLine: function(line) {
        var intersections = [];
        var a1 = line.start;
        var a2 = line.end;
        var rx = this.a;
        var ry = this.b;
        var dir = line.vector();
        var diff = a1.difference(new (0, _pointMjs.Point)(this));
        var mDir = new (0, _pointMjs.Point)(dir.x / (rx * rx), dir.y / (ry * ry));
        var mDiff = new (0, _pointMjs.Point)(diff.x / (rx * rx), diff.y / (ry * ry));
        var a = dir.dot(mDir);
        var b = dir.dot(mDiff);
        var c = diff.dot(mDiff) - 1.0;
        var d = b * b - a * c;
        if (d < 0) return null;
        else if (d > 0) {
            var root = sqrt(d);
            var ta = (-b - root) / a;
            var tb = (-b + root) / a;
            if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside
            return null;
            else {
                if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));
                if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));
            }
        } else {
            var t = -b / a;
            if (0 <= t && t <= 1) intersections.push(a1.lerp(a2, t));
            else // outside
            return null;
        }
        return intersections;
    },
    // Find point on me where line from my center to
    // point p intersects my boundary.
    // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.
    intersectionWithLineFromCenterToPoint: function(p, angle) {
        p = new (0, _pointMjs.Point)(p);
        if (angle) p.rotate(new (0, _pointMjs.Point)(this.x, this.y), angle);
        var dx = p.x - this.x;
        var dy = p.y - this.y;
        var result;
        if (dx === 0) {
            result = this.bbox().pointNearestToPoint(p);
            if (angle) return result.rotate(new (0, _pointMjs.Point)(this.x, this.y), -angle);
            return result;
        }
        var m = dy / dx;
        var mSquared = m * m;
        var aSquared = this.a * this.a;
        var bSquared = this.b * this.b;
        var x = sqrt(1 / (1 / aSquared + mSquared / bSquared));
        x = dx < 0 ? -x : x;
        var y = m * x;
        result = new (0, _pointMjs.Point)(this.x + x, this.y + y);
        if (angle) return result.rotate(new (0, _pointMjs.Point)(this.x, this.y), -angle);
        return result;
    },
    /**
     * @param {g.Point} point
     * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside
     */ normalizedDistance: function(point) {
        var x0 = point.x;
        var y0 = point.y;
        var a = this.a;
        var b = this.b;
        var x = this.x;
        var y = this.y;
        return (x0 - x) * (x0 - x) / (a * a) + (y0 - y) * (y0 - y) / (b * b);
    },
    round: function(precision) {
        let f = 1; // case 0
        if (precision) switch(precision){
            case 1:
                f = 10;
                break;
            case 2:
                f = 100;
                break;
            case 3:
                f = 1000;
                break;
            default:
                f = pow(10, precision);
                break;
        }
        this.x = round(this.x * f) / f;
        this.y = round(this.y * f) / f;
        this.a = round(this.a * f) / f;
        this.b = round(this.b * f) / f;
        return this;
    },
    /** Compute angle between tangent and x axis
     * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.
     * @returns {number} angle between tangent and x axis
     */ tangentTheta: function(p) {
        var refPointDelta = 30;
        var x0 = p.x;
        var y0 = p.y;
        var a = this.a;
        var b = this.b;
        var center = this.bbox().center();
        var m = center.x;
        var n = center.y;
        var q1 = x0 > center.x + a / 2;
        var q3 = x0 < center.x - a / 2;
        var y, x;
        if (q1 || q3) {
            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;
            x = a * a / (x0 - m) - a * a * (y0 - n) * (y - n) / (b * b * (x0 - m)) + m;
        } else {
            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;
            y = b * b / (y0 - n) - b * b * (x0 - m) * (x - m) / (a * a * (y0 - n)) + n;
        }
        return new (0, _pointMjs.Point)(x, y).theta(p);
    },
    toString: function() {
        return new (0, _pointMjs.Point)(this.x, this.y).toString() + " " + this.a + " " + this.b;
    }
};
const ellipse = Ellipse;

},{"./rect.mjs":"6MvV7","./point.mjs":"7vrrP","./types.mjs":"217db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kAIcD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parsePoints", ()=>parsePoints);
parcelHelpers.export(exports, "clonePoints", ()=>clonePoints);
// Returns a convex-hull polyline from this polyline.
// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).
// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.
// Minimal polyline is found (only vertices of the hull are reported, no collinear points).
parcelHelpers.export(exports, "convexHull", ()=>convexHull);
function parsePoints(svgString) {
    // Step 1: Discard surrounding spaces
    const trimmedString = svgString.trim();
    if (trimmedString === "") return [];
    const points = [];
    // Step 2: Split at commas (+ their surrounding spaces) or at multiple spaces
    // ReDoS mitigation: Have an anchor at the beginning of each alternation
    // Note: This doesn't simplify double (or more) commas - causes empty coords
    // This regex is used by `split()`, so it doesn't need to use /g
    const coords = trimmedString.split(/\b\s*,\s*|,\s*|\s+/);
    const numCoords = coords.length;
    for(let i = 0; i < numCoords; i += 2)// Step 3: Convert each coord to number
    // Note: If the coord cannot be converted to a number, it will be `NaN`
    // Note: If the coord is empty ("", e.g. from ",," input), it will be `0`
    // Note: If we end up with an odd number of coords, the last point's second coord will be `NaN`
    points.push({
        x: +coords[i],
        y: +coords[i + 1]
    });
    return points;
}
function clonePoints(points) {
    const numPoints = points.length;
    if (numPoints === 0) return [];
    const newPoints = [];
    for(let i = 0; i < numPoints; i++){
        const point = points[i].clone();
        newPoints.push(point);
    }
    return newPoints;
}
function convexHull(points) {
    const { abs } = Math;
    var i;
    var n;
    var numPoints = points.length;
    if (numPoints === 0) return []; // if points array is empty
    // step 1: find the starting point - point with the lowest y (if equality, highest x)
    var startPoint;
    for(i = 0; i < numPoints; i++){
        if (startPoint === undefined) // if this is the first point we see, set it as start point
        startPoint = points[i];
        else if (points[i].y < startPoint.y) // start point should have lowest y from all points
        startPoint = points[i];
        else if (points[i].y === startPoint.y && points[i].x > startPoint.x) // if two points have the lowest y, choose the one that has highest x
        // there are no points to the right of startPoint - no ambiguity about theta 0
        // if there are several coincident start point candidates, first one is reported
        startPoint = points[i];
    }
    // step 2: sort the list of points
    // sorting by angle between line from startPoint to point and the x-axis (theta)
    // step 2a: create the point records = [point, originalIndex, angle]
    var sortedPointRecords = [];
    for(i = 0; i < numPoints; i++){
        var angle = startPoint.theta(points[i]);
        if (angle === 0) angle = 360; // give highest angle to start point
        var entry = [
            points[i],
            i,
            angle
        ];
        sortedPointRecords.push(entry);
    }
    // step 2b: sort the list in place
    sortedPointRecords.sort(function(record1, record2) {
        // returning a negative number here sorts record1 before record2
        // if first angle is smaller than second, first angle should come before second
        var sortOutput = record1[2] - record2[2]; // negative if first angle smaller
        if (sortOutput === 0) // if the two angles are equal, sort by originalIndex
        sortOutput = record2[1] - record1[1]; // negative if first index larger
        return sortOutput;
    });
    // step 2c: duplicate start record from the top of the stack to the bottom of the stack
    if (sortedPointRecords.length > 2) {
        var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];
        sortedPointRecords.unshift(startPointRecord);
    }
    // step 3a: go through sorted points in order and find those with right turns
    // we want to get our results in clockwise order
    var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull
    var hullPointRecords = []; // stack of records with right turns - hull point candidates
    var currentPointRecord;
    var currentPoint;
    var lastHullPointRecord;
    var lastHullPoint;
    var secondLastHullPointRecord;
    var secondLastHullPoint;
    while(sortedPointRecords.length !== 0){
        currentPointRecord = sortedPointRecords.pop();
        currentPoint = currentPointRecord[0];
        // check if point has already been discarded
        // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'
        if (insidePoints.hasOwnProperty(currentPointRecord[0] + "@@" + currentPointRecord[1])) continue;
        var correctTurnFound = false;
        while(!correctTurnFound)if (hullPointRecords.length < 2) {
            // not enough points for comparison, just add current point
            hullPointRecords.push(currentPointRecord);
            correctTurnFound = true;
        } else {
            lastHullPointRecord = hullPointRecords.pop();
            lastHullPoint = lastHullPointRecord[0];
            secondLastHullPointRecord = hullPointRecords.pop();
            secondLastHullPoint = secondLastHullPointRecord[0];
            var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);
            if (crossProduct < 0) {
                // found a right turn
                hullPointRecords.push(secondLastHullPointRecord);
                hullPointRecords.push(lastHullPointRecord);
                hullPointRecords.push(currentPointRecord);
                correctTurnFound = true;
            } else if (crossProduct === 0) {
                // the three points are collinear
                // three options:
                // there may be a 180 or 0 degree angle at lastHullPoint
                // or two of the three points are coincident
                var THRESHOLD = 1e-10; // we have to take rounding errors into account
                var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);
                if (abs(angleBetween - 180) < THRESHOLD) {
                    // if the cross product is 0 because the angle is 180 degrees
                    // discard last hull point (add to insidePoints)
                    //insidePoints.unshift(lastHullPoint);
                    insidePoints[lastHullPointRecord[0] + "@@" + lastHullPointRecord[1]] = lastHullPoint;
                    // reenter second-to-last hull point (will be last at next iter)
                    hullPointRecords.push(secondLastHullPointRecord);
                // do not do anything with current point
                // correct turn not found
                } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {
                    // if the cross product is 0 because two points are the same
                    // discard last hull point (add to insidePoints)
                    //insidePoints.unshift(lastHullPoint);
                    insidePoints[lastHullPointRecord[0] + "@@" + lastHullPointRecord[1]] = lastHullPoint;
                    // reenter second-to-last hull point (will be last at next iter)
                    hullPointRecords.push(secondLastHullPointRecord);
                // do not do anything with current point
                // correct turn not found
                } else if (abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {
                    // if the cross product is 0 because the angle is 0 degrees
                    // remove last hull point from hull BUT do not discard it
                    // reenter second-to-last hull point (will be last at next iter)
                    hullPointRecords.push(secondLastHullPointRecord);
                    // put last hull point back into the sorted point records list
                    sortedPointRecords.push(lastHullPointRecord);
                // we are switching the order of the 0deg and 180deg points
                // correct turn not found
                }
            } else {
                // found a left turn
                // discard last hull point (add to insidePoints)
                //insidePoints.unshift(lastHullPoint);
                insidePoints[lastHullPointRecord[0] + "@@" + lastHullPointRecord[1]] = lastHullPoint;
                // reenter second-to-last hull point (will be last at next iter of loop)
                hullPointRecords.push(secondLastHullPointRecord);
            // do not do anything with current point
            // correct turn not found
            }
        }
    }
    // at this point, hullPointRecords contains the output points in clockwise order
    // the points start with lowest-y,highest-x startPoint, and end at the same point
    // step 3b: remove duplicated startPointRecord from the end of the array
    if (hullPointRecords.length > 2) hullPointRecords.pop();
    // step 4: find the lowest originalIndex record and put it at the beginning of hull
    var lowestHullIndex; // the lowest originalIndex on the hull
    var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex
    n = hullPointRecords.length;
    for(i = 0; i < n; i++){
        var currentHullIndex = hullPointRecords[i][1];
        if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {
            lowestHullIndex = currentHullIndex;
            indexOfLowestHullIndexRecord = i;
        }
    }
    var hullPointRecordsReordered = [];
    if (indexOfLowestHullIndexRecord > 0) {
        var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);
        var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);
        hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);
    } else hullPointRecordsReordered = hullPointRecords;
    var hullPoints = [];
    n = hullPointRecordsReordered.length;
    for(i = 0; i < n; i++)hullPoints.push(hullPointRecordsReordered[i][0]);
    return hullPoints;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kW90":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Curve", ()=>Curve);
var _pointMjs = require("./point.mjs");
var _rectMjs = require("./rect.mjs");
var _lineMjs = require("./line.mjs");
var _polylineMjs = require("./polyline.mjs");
var _typesMjs = require("./types.mjs");
const { abs, sqrt, min, max, pow } = Math;
const Curve = function(p1, p2, p3, p4) {
    if (!(this instanceof Curve)) return new Curve(p1, p2, p3, p4);
    if (p1 instanceof Curve) return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);
    this.start = new (0, _pointMjs.Point)(p1);
    this.controlPoint1 = new (0, _pointMjs.Point)(p2);
    this.controlPoint2 = new (0, _pointMjs.Point)(p3);
    this.end = new (0, _pointMjs.Point)(p4);
};
// Curve passing through points.
// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).
// @param {array} points Array of points through which the smooth line will go.
// @return {array} curves.
Curve.throughPoints = function() {
    // Get open-ended Bezier Spline Control Points.
    // @param knots Input Knot Bezier spline points (At least two points!).
    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.
    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.
    function getCurveControlPoints(knots) {
        var firstControlPoints = [];
        var secondControlPoints = [];
        var n = knots.length - 1;
        var i;
        // Special case: Bezier curve should be a straight line.
        if (n == 1) {
            // 3P1 = 2P0 + P3
            firstControlPoints[0] = new (0, _pointMjs.Point)((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);
            // P2 = 2P1 ‚Äì P0
            secondControlPoints[0] = new (0, _pointMjs.Point)(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
            return [
                firstControlPoints,
                secondControlPoints
            ];
        }
        // Calculate first Bezier control points.
        // Right hand side vector.
        var rhs = [];
        // Set right hand side X values.
        for(i = 1; i < n - 1; i++)rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
        rhs[0] = knots[0].x + 2 * knots[1].x;
        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;
        // Get first control points X-values.
        var x = getFirstControlPoints(rhs);
        // Set right hand side Y values.
        for(i = 1; i < n - 1; ++i)rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;
        rhs[0] = knots[0].y + 2 * knots[1].y;
        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;
        // Get first control points Y-values.
        var y = getFirstControlPoints(rhs);
        // Fill output arrays.
        for(i = 0; i < n; i++){
            // First control point.
            firstControlPoints.push(new (0, _pointMjs.Point)(x[i], y[i]));
            // Second control point.
            if (i < n - 1) secondControlPoints.push(new (0, _pointMjs.Point)(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));
            else secondControlPoints.push(new (0, _pointMjs.Point)((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
        }
        return [
            firstControlPoints,
            secondControlPoints
        ];
    }
    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.
    // @param rhs Right hand side vector.
    // @return Solution vector.
    function getFirstControlPoints(rhs) {
        var n = rhs.length;
        // `x` is a solution vector.
        var x = [];
        var tmp = [];
        var b = 2.0;
        x[0] = rhs[0] / b;
        // Decomposition and forward substitution.
        for(var i = 1; i < n; i++){
            tmp[i] = 1 / b;
            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];
            x[i] = (rhs[i] - x[i - 1]) / b;
        }
        for(i = 1; i < n; i++)// Backsubstitution.
        x[n - i - 1] -= tmp[n - i] * x[n - i];
        return x;
    }
    return function(points) {
        if (!points || Array.isArray(points) && points.length < 2) throw new Error("At least 2 points are required");
        var controlPoints = getCurveControlPoints(points);
        var curves = [];
        var n = controlPoints[0].length;
        for(var i = 0; i < n; i++){
            var controlPoint1 = new (0, _pointMjs.Point)(controlPoints[0][i].x, controlPoints[0][i].y);
            var controlPoint2 = new (0, _pointMjs.Point)(controlPoints[1][i].x, controlPoints[1][i].y);
            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));
        }
        return curves;
    };
}();
Curve.prototype = {
    type: (0, _typesMjs.types).Curve,
    // Returns a bbox that tightly envelops the curve.
    bbox: function() {
        var start = this.start;
        var controlPoint1 = this.controlPoint1;
        var controlPoint2 = this.controlPoint2;
        var end = this.end;
        var x0 = start.x;
        var y0 = start.y;
        var x1 = controlPoint1.x;
        var y1 = controlPoint1.y;
        var x2 = controlPoint2.x;
        var y2 = controlPoint2.y;
        var x3 = end.x;
        var y3 = end.y;
        var points = new Array(); // local extremes
        var tvalues = new Array(); // t values of local extremes
        var bounds = [
            new Array(),
            new Array()
        ];
        var a, b, c, t;
        var t1, t2;
        var b2ac, sqrtb2ac;
        for(var i = 0; i < 2; ++i){
            if (i === 0) {
                b = 6 * x0 - 12 * x1 + 6 * x2;
                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                c = 3 * x1 - 3 * x0;
            } else {
                b = 6 * y0 - 12 * y1 + 6 * y2;
                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                c = 3 * y1 - 3 * y0;
            }
            if (abs(a) < 1e-12) {
                if (abs(b) < 1e-12) continue;
                t = -c / b;
                if (0 < t && t < 1) tvalues.push(t);
                continue;
            }
            b2ac = b * b - 4 * c * a;
            sqrtb2ac = sqrt(b2ac);
            if (b2ac < 0) continue;
            t1 = (-b + sqrtb2ac) / (2 * a);
            if (0 < t1 && t1 < 1) tvalues.push(t1);
            t2 = (-b - sqrtb2ac) / (2 * a);
            if (0 < t2 && t2 < 1) tvalues.push(t2);
        }
        var j = tvalues.length;
        var jlen = j;
        var mt;
        var x, y;
        while(j--){
            t = tvalues[j];
            mt = 1 - t;
            x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
            bounds[0][j] = x;
            y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
            bounds[1][j] = y;
            points[j] = {
                X: x,
                Y: y
            };
        }
        tvalues[jlen] = 0;
        tvalues[jlen + 1] = 1;
        points[jlen] = {
            X: x0,
            Y: y0
        };
        points[jlen + 1] = {
            X: x3,
            Y: y3
        };
        bounds[0][jlen] = x0;
        bounds[1][jlen] = y0;
        bounds[0][jlen + 1] = x3;
        bounds[1][jlen + 1] = y3;
        tvalues.length = jlen + 2;
        bounds[0].length = jlen + 2;
        bounds[1].length = jlen + 2;
        points.length = jlen + 2;
        var left = min.apply(null, bounds[0]);
        var top = min.apply(null, bounds[1]);
        var right = max.apply(null, bounds[0]);
        var bottom = max.apply(null, bounds[1]);
        return new (0, _rectMjs.Rect)(left, top, right - left, bottom - top);
    },
    clone: function() {
        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
    },
    // Returns the point on the curve closest to point `p`
    closestPoint: function(p, opt) {
        return this.pointAtT(this.closestPointT(p, opt));
    },
    closestPointLength: function(p, opt) {
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
            precision: precision
        }) : opt.subdivisions;
        var localOpt = {
            precision: precision,
            subdivisions: subdivisions
        };
        return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);
    },
    closestPointNormalizedLength: function(p, opt) {
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
            precision: precision
        }) : opt.subdivisions;
        var localOpt = {
            precision: precision,
            subdivisions: subdivisions
        };
        var cpLength = this.closestPointLength(p, localOpt);
        if (!cpLength) return 0;
        var length = this.length(localOpt);
        if (length === 0) return 0;
        return cpLength / length;
    },
    // Returns `t` of the point on the curve closest to point `p`
    closestPointT: function(p, opt) {
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
            precision: precision
        }) : opt.subdivisions;
        // does not use localOpt
        // identify the subdivision that contains the point:
        var investigatedSubdivision;
        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced
        var investigatedSubdivisionEndT;
        var distFromStart; // distance of point from start of baseline
        var distFromEnd; // distance of point from end of baseline
        var chordLength; // distance between start and end of the subdivision
        var minSumDist; // lowest observed sum of the two distances
        var n = subdivisions.length;
        var subdivisionSize = n ? 1 / n : 0;
        for(var i = 0; i < n; i++){
            var currentSubdivision = subdivisions[i];
            var startDist = currentSubdivision.start.distance(p);
            var endDist = currentSubdivision.end.distance(p);
            var sumDist = startDist + endDist;
            // check that the point is closest to current subdivision and not any other
            if (!minSumDist || sumDist < minSumDist) {
                investigatedSubdivision = currentSubdivision;
                investigatedSubdivisionStartT = i * subdivisionSize;
                investigatedSubdivisionEndT = (i + 1) * subdivisionSize;
                distFromStart = startDist;
                distFromEnd = endDist;
                chordLength = currentSubdivision.start.distance(currentSubdivision.end);
                minSumDist = sumDist;
            }
        }
        var precisionRatio = pow(10, -precision);
        // recursively divide investigated subdivision:
        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)
        // then return the closest endpoint of that final subdivision
        while(true){
            // check if we have reached at least one required observed precision
            // - calculated as: the difference in distances from point to start and end divided by the distance
            // - note that this function is not monotonic = it doesn't converge stably but has "teeth"
            // - the function decreases while one of the endpoints is fixed but "jumps" whenever we switch
            // - this criterion works well for points lying far away from the curve
            var startPrecisionRatio = distFromStart ? abs(distFromStart - distFromEnd) / distFromStart : 0;
            var endPrecisionRatio = distFromEnd ? abs(distFromStart - distFromEnd) / distFromEnd : 0;
            var hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio;
            // check if we have reached at least one required minimal distance
            // - calculated as: the subdivision chord length multiplied by precisionRatio
            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions
            // - this is a backup criterion that works well for points lying "almost at" the curve
            var hasMinimalStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;
            var hasMinimalEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;
            var hasMinimalDistance = hasMinimalStartDistance || hasMinimalEndDistance;
            // do we stop now?
            if (hasRequiredPrecision || hasMinimalDistance) return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;
            // otherwise, set up for next iteration
            var divided = investigatedSubdivision.divide(0.5);
            subdivisionSize /= 2;
            var startDist1 = divided[0].start.distance(p);
            var endDist1 = divided[0].end.distance(p);
            var sumDist1 = startDist1 + endDist1;
            var startDist2 = divided[1].start.distance(p);
            var endDist2 = divided[1].end.distance(p);
            var sumDist2 = startDist2 + endDist2;
            if (sumDist1 <= sumDist2) {
                investigatedSubdivision = divided[0];
                investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved
                distFromStart = startDist1;
                distFromEnd = endDist1;
            } else {
                investigatedSubdivision = divided[1];
                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved
                distFromStart = startDist2;
                distFromEnd = endDist2;
            }
        }
    },
    closestPointTangent: function(p, opt) {
        return this.tangentAtT(this.closestPointT(p, opt));
    },
    // Returns `true` if the area surrounded by the curve contains the point `p`.
    // Implements the even-odd algorithm (self-intersections are "outside").
    // Closes open curves (always imagines a closing segment).
    // Precision may be adjusted by passing an `opt` object.
    containsPoint: function(p, opt) {
        var polyline = this.toPolyline(opt);
        return polyline.containsPoint(p);
    },
    // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.
    // For a function that uses `t`, use Curve.divideAtT().
    divideAt: function(ratio, opt) {
        if (ratio <= 0) return this.divideAtT(0);
        if (ratio >= 1) return this.divideAtT(1);
        var t = this.tAt(ratio, opt);
        return this.divideAtT(t);
    },
    // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
    divideAtLength: function(length, opt) {
        var t = this.tAtLength(length, opt);
        return this.divideAtT(t);
    },
    // Divides the curve into two at point defined by `t` between 0 and 1.
    // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).
    // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau
    divideAtT: function(t) {
        var start = this.start;
        var controlPoint1 = this.controlPoint1;
        var controlPoint2 = this.controlPoint2;
        var end = this.end;
        // shortcuts for `t` values that are out of range
        if (t <= 0) return [
            new Curve(start, start, start, start),
            new Curve(start, controlPoint1, controlPoint2, end)
        ];
        if (t >= 1) return [
            new Curve(start, controlPoint1, controlPoint2, end),
            new Curve(end, end, end, end)
        ];
        var dividerPoints = this.getSkeletonPoints(t);
        var startControl1 = dividerPoints.startControlPoint1;
        var startControl2 = dividerPoints.startControlPoint2;
        var divider = dividerPoints.divider;
        var dividerControl1 = dividerPoints.dividerControlPoint1;
        var dividerControl2 = dividerPoints.dividerControlPoint2;
        // return array with two new curves
        return [
            new Curve(start, startControl1, startControl2, divider),
            new Curve(divider, dividerControl1, dividerControl2, end)
        ];
    },
    // Returns the distance between the curve's start and end points.
    endpointDistance: function() {
        return this.start.distance(this.end);
    },
    // Checks whether two curves are exactly the same.
    equals: function(c) {
        return !!c && this.start.x === c.start.x && this.start.y === c.start.y && this.controlPoint1.x === c.controlPoint1.x && this.controlPoint1.y === c.controlPoint1.y && this.controlPoint2.x === c.controlPoint2.x && this.controlPoint2.y === c.controlPoint2.y && this.end.x === c.end.x && this.end.y === c.end.y;
    },
    // Returns five helper points necessary for curve division.
    getSkeletonPoints: function(t) {
        var start = this.start;
        var control1 = this.controlPoint1;
        var control2 = this.controlPoint2;
        var end = this.end;
        // shortcuts for `t` values that are out of range
        if (t <= 0) return {
            startControlPoint1: start.clone(),
            startControlPoint2: start.clone(),
            divider: start.clone(),
            dividerControlPoint1: control1.clone(),
            dividerControlPoint2: control2.clone()
        };
        if (t >= 1) return {
            startControlPoint1: control1.clone(),
            startControlPoint2: control2.clone(),
            divider: end.clone(),
            dividerControlPoint1: end.clone(),
            dividerControlPoint2: end.clone()
        };
        var midpoint1 = new (0, _lineMjs.Line)(start, control1).pointAt(t);
        var midpoint2 = new (0, _lineMjs.Line)(control1, control2).pointAt(t);
        var midpoint3 = new (0, _lineMjs.Line)(control2, end).pointAt(t);
        var subControl1 = new (0, _lineMjs.Line)(midpoint1, midpoint2).pointAt(t);
        var subControl2 = new (0, _lineMjs.Line)(midpoint2, midpoint3).pointAt(t);
        var divider = new (0, _lineMjs.Line)(subControl1, subControl2).pointAt(t);
        var output = {
            startControlPoint1: midpoint1,
            startControlPoint2: subControl1,
            divider: divider,
            dividerControlPoint1: subControl2,
            dividerControlPoint2: midpoint3
        };
        return output;
    },
    // Returns a list of curves whose flattened length is better than `opt.precision`.
    // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%
    // (Observed difference is not real precision, but close enough as long as special cases are covered)
    // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)
    // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)
    // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)
    // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)
    // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)
    // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)
    // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)
    getSubdivisions: function(opt) {
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        // not using opt.subdivisions
        // not using localOpt
        var start = this.start;
        var control1 = this.controlPoint1;
        var control2 = this.controlPoint2;
        var end = this.end;
        var subdivisions = [
            new Curve(start, control1, control2, end)
        ];
        if (precision === 0) return subdivisions;
        // special case #1: point-like curves
        // - no need to calculate subdivisions, they would all be identical
        var isPoint = !this.isDifferentiable();
        if (isPoint) return subdivisions;
        var previousLength = this.endpointDistance();
        var precisionRatio = pow(10, -precision);
        // special case #2: sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1
        // - not a problem for further iterations because cubic curves cannot have more than two local extrema
        // - (i.e. cubic curves cannot intersect the baseline more than once)
        // - therefore starting from iteration = 2 ensures that subsequent iterations do not produce sampling with equal length
        // - (unless it's a straight-line curve, see below)
        var minIterations = 2; // = 2*1
        // special case #3: straight-line curves have the same observed length in all iterations
        // - this causes observed precision ratio to always be 0 (= lower than `precisionRatio`, which is our exit condition)
        // - we enforce the expected number of iterations = 2 * precision
        var isLine = control1.cross(start, end) === 0 && control2.cross(start, end) === 0;
        if (isLine) minIterations = 2 * precision;
        // recursively divide curve at `t = 0.5`
        // until we reach `minIterations`
        // and until the difference between observed length at subsequent iterations is lower than `precision`
        var iteration = 0;
        while(true){
            iteration += 1;
            // divide all subdivisions
            var newSubdivisions = [];
            var numSubdivisions = subdivisions.length;
            for(var i = 0; i < numSubdivisions; i++){
                var currentSubdivision = subdivisions[i];
                var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)
                newSubdivisions.push(divided[0], divided[1]);
            }
            // measure new length
            var length = 0;
            var numNewSubdivisions = newSubdivisions.length;
            for(var j = 0; j < numNewSubdivisions; j++){
                var currentNewSubdivision = newSubdivisions[j];
                length += currentNewSubdivision.endpointDistance();
            }
            // check if we have reached minimum number of iterations
            if (iteration >= minIterations) {
                // check if we have reached required observed precision
                var observedPrecisionRatio = length !== 0 ? (length - previousLength) / length : 0;
                if (observedPrecisionRatio < precisionRatio) return newSubdivisions;
            }
            // otherwise, set up for next iteration
            subdivisions = newSubdivisions;
            previousLength = length;
        }
    },
    isDifferentiable: function() {
        var start = this.start;
        var control1 = this.controlPoint1;
        var control2 = this.controlPoint2;
        var end = this.end;
        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
    },
    // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.
    length: function(opt) {
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call
        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
            precision: precision
        }) : opt.subdivisions;
        // not using localOpt
        var length = 0;
        var n = subdivisions.length;
        for(var i = 0; i < n; i++){
            var currentSubdivision = subdivisions[i];
            length += currentSubdivision.endpointDistance();
        }
        return length;
    },
    // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)
    lengthAtT: function(t, opt) {
        if (t <= 0) return 0;
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        // not using opt.subdivisions
        // not using localOpt
        var subCurve = this.divide(t)[0];
        var subCurveLength = subCurve.length({
            precision: precision
        });
        return subCurveLength;
    },
    // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.
    // Mirrors Line.pointAt() function.
    // For a function that tracks `t`, use Curve.pointAtT().
    pointAt: function(ratio, opt) {
        if (ratio <= 0) return this.start.clone();
        if (ratio >= 1) return this.end.clone();
        var t = this.tAt(ratio, opt);
        return this.pointAtT(t);
    },
    // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
    pointAtLength: function(length, opt) {
        var t = this.tAtLength(length, opt);
        return this.pointAtT(t);
    },
    // Returns the point at provided `t` between 0 and 1.
    // `t` does not track distance along curve as it does in Line objects.
    // Non-linear relationship, speeds up and slows down as curve warps!
    // For linear length-based solution, use Curve.pointAt().
    pointAtT: function(t) {
        if (t <= 0) return this.start.clone();
        if (t >= 1) return this.end.clone();
        return this.getSkeletonPoints(t).divider;
    },
    // Default precision
    PRECISION: 3,
    round: function(precision) {
        this.start.round(precision);
        this.controlPoint1.round(precision);
        this.controlPoint2.round(precision);
        this.end.round(precision);
        return this;
    },
    scale: function(sx, sy, origin) {
        this.start.scale(sx, sy, origin);
        this.controlPoint1.scale(sx, sy, origin);
        this.controlPoint2.scale(sx, sy, origin);
        this.end.scale(sx, sy, origin);
        return this;
    },
    // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.
    tangentAt: function(ratio, opt) {
        if (!this.isDifferentiable()) return null;
        if (ratio < 0) ratio = 0;
        else if (ratio > 1) ratio = 1;
        var t = this.tAt(ratio, opt);
        return this.tangentAtT(t);
    },
    // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.
    tangentAtLength: function(length, opt) {
        if (!this.isDifferentiable()) return null;
        var t = this.tAtLength(length, opt);
        return this.tangentAtT(t);
    },
    // Returns a tangent line at requested `t`.
    tangentAtT: function(t) {
        if (!this.isDifferentiable()) return null;
        if (t < 0) t = 0;
        else if (t > 1) t = 1;
        var skeletonPoints = this.getSkeletonPoints(t);
        var p1 = skeletonPoints.startControlPoint2;
        var p2 = skeletonPoints.dividerControlPoint1;
        var tangentStart = skeletonPoints.divider;
        var tangentLine = new (0, _lineMjs.Line)(p1, p2);
        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested
        return tangentLine;
    },
    // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
    tAt: function(ratio, opt) {
        if (ratio <= 0) return 0;
        if (ratio >= 1) return 1;
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
            precision: precision
        }) : opt.subdivisions;
        var localOpt = {
            precision: precision,
            subdivisions: subdivisions
        };
        var curveLength = this.length(localOpt);
        var length = curveLength * ratio;
        return this.tAtLength(length, localOpt);
    },
    // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
    // Uses `precision` to approximate length within `precision` (always underestimates)
    // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated
    // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper
    // - Precision 0 (chooses one of the two endpoints) - 0 levels
    // - Precision 1 (chooses one of 5 points, <10% error) - 1 level
    // - Precision 2 (<1% error) - 3 levels
    // - Precision 3 (<0.1% error) - 7 levels
    // - Precision 4 (<0.01% error) - 15 levels
    tAtLength: function(length, opt) {
        var fromStart = true;
        if (length < 0) {
            fromStart = false; // negative lengths mean start calculation from end point
            length = -length; // absolute value
        }
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision;
        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
            precision: precision
        }) : opt.subdivisions;
        var localOpt = {
            precision: precision,
            subdivisions: subdivisions
        };
        // identify the subdivision that contains the point at requested `length`:
        var investigatedSubdivision;
        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced
        var investigatedSubdivisionEndT;
        //var baseline; // straightened version of subdivision to investigate
        //var baselinePoint; // point on the baseline that is the requested distance away from start
        var baselinePointDistFromStart; // distance of baselinePoint from start of baseline
        var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline
        var l = 0; // length so far
        var n = subdivisions.length;
        var subdivisionSize = 1 / n;
        for(var i = 0; i < n; i++){
            var index = fromStart ? i : n - 1 - i;
            var currentSubdivision = subdivisions[i];
            var d = currentSubdivision.endpointDistance(); // length of current subdivision
            if (length <= l + d) {
                investigatedSubdivision = currentSubdivision;
                investigatedSubdivisionStartT = index * subdivisionSize;
                investigatedSubdivisionEndT = (index + 1) * subdivisionSize;
                baselinePointDistFromStart = fromStart ? length - l : d + l - length;
                baselinePointDistFromEnd = fromStart ? d + l - length : length - l;
                break;
            }
            l += d;
        }
        if (!investigatedSubdivision) return fromStart ? 1 : 0; // length requested is out of range - return maximum t
        // note that precision affects what length is recorded
        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)
        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1
        var curveLength = this.length(localOpt);
        var precisionRatio = pow(10, -precision);
        // recursively divide investigated subdivision:
        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)
        // then return the closest endpoint of that final subdivision
        while(true){
            // check if we have reached required observed precision
            var observedPrecisionRatio;
            observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromStart / curveLength : 0;
            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;
            observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromEnd / curveLength : 0;
            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;
            // otherwise, set up for next iteration
            var newBaselinePointDistFromStart;
            var newBaselinePointDistFromEnd;
            var divided = investigatedSubdivision.divide(0.5);
            subdivisionSize /= 2;
            var baseline1Length = divided[0].endpointDistance();
            var baseline2Length = divided[1].endpointDistance();
            if (baselinePointDistFromStart <= baseline1Length) {
                investigatedSubdivision = divided[0];
                investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved
                newBaselinePointDistFromStart = baselinePointDistFromStart;
                newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;
            } else {
                investigatedSubdivision = divided[1];
                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved
                newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;
                newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;
            }
            baselinePointDistFromStart = newBaselinePointDistFromStart;
            baselinePointDistFromEnd = newBaselinePointDistFromEnd;
        }
    },
    // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.
    // Flattened length is no more than 10^(-precision) away from real curve length.
    toPoints: function(opt) {
        opt = opt || {};
        var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call
        var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({
            precision: precision
        }) : opt.subdivisions;
        // not using localOpt
        var points = [
            subdivisions[0].start.clone()
        ];
        var n = subdivisions.length;
        for(var i = 0; i < n; i++){
            var currentSubdivision = subdivisions[i];
            points.push(currentSubdivision.end.clone());
        }
        return points;
    },
    // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.
    // Flattened length is no more than 10^(-precision) away from real curve length.
    toPolyline: function(opt) {
        return new (0, _polylineMjs.Polyline)(this.toPoints(opt));
    },
    toString: function() {
        return this.start + " " + this.controlPoint1 + " " + this.controlPoint2 + " " + this.end;
    },
    translate: function(tx, ty) {
        this.start.translate(tx, ty);
        this.controlPoint1.translate(tx, ty);
        this.controlPoint2.translate(tx, ty);
        this.end.translate(tx, ty);
        return this;
    }
};
Curve.prototype.divide = Curve.prototype.divideAtT;

},{"./point.mjs":"7vrrP","./rect.mjs":"6MvV7","./line.mjs":"f7trh","./polyline.mjs":"8d0If","./types.mjs":"217db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"0gPi8":[function(require,module,exports) {
// Local helper function.
// Add properties from arguments on top of properties from `obj`.
// This allows for rudimentary inheritance.
// - The `obj` argument acts as parent.
// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.
// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extend", ()=>extend);
function extend(obj) {
    // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.
    // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)
    // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?
    // - First, realize that both of those quasiclasses would still have their own separate constructor function.
    // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.
    // - This method provides a way to do exactly that.
    // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.
    // - Therefore, to continue with the example above:
    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`
    //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.
    //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.
    //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.
    // - Multiple inheritance is also possible, if multiple arguments are provided.
    // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?
    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`
    //   - The ancestors are applied in order of appearance.
    //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.
    //   - Any number of ancestors may be provided.
    // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.
    // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).
    //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.
    //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.
    // - Therefore, both of the following are valid:
    //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`
    //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`
    var i;
    var n;
    var args = [];
    n = arguments.length;
    for(i = 1; i < n; i++)args.push(arguments[i]);
    if (!obj) throw new Error("Missing a parent object.");
    var child = Object.create(obj);
    n = args.length;
    for(i = 0; i < n; i++){
        var src = args[i];
        var inheritedProperty;
        var key;
        for(key in src)if (src.hasOwnProperty(key)) {
            delete child[key]; // delete property inherited from parent
            inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src
            Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)
        }
    }
    return child;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6G1L0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Polygon", ()=>Polygon);
var _pointMjs = require("./point.mjs");
var _polylineMjs = require("./polyline.mjs");
var _extendMjs = require("./extend.mjs");
var _typesMjs = require("./types.mjs");
var _pointsMjs = require("./points.mjs");
const Polygon = function(points) {
    if (!(this instanceof Polygon)) return new Polygon(points);
    if (typeof points === "string") return new Polygon.parse(points);
    this.points = Array.isArray(points) ? points.map((0, _pointMjs.Point)) : [];
};
Polygon.parse = function(svgString) {
    return new Polygon((0, _pointsMjs.parsePoints)(svgString));
};
Polygon.fromRect = function(rect) {
    return new Polygon([
        rect.topLeft(),
        rect.topRight(),
        rect.bottomRight(),
        rect.bottomLeft()
    ]);
};
Polygon.prototype = (0, _extendMjs.extend)((0, _polylineMjs.Polyline).prototype, {
    type: (0, _typesMjs.types).Polygon,
    clone: function() {
        return new Polygon((0, _pointsMjs.clonePoints)(this.points));
    },
    convexHull: function() {
        return new Polygon((0, _pointsMjs.convexHull)(this.points));
    },
    lengthPoints: function() {
        const { start, end, points } = this;
        if (points.length <= 1 || start.equals(end)) return points;
        return [
            ...points,
            start.clone()
        ];
    }
});

},{"./point.mjs":"7vrrP","./polyline.mjs":"8d0If","./extend.mjs":"0gPi8","./types.mjs":"217db","./points.mjs":"kAIcD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1nOFs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "exists", ()=>exists);
/* Line */ parcelHelpers.export(exports, "lineWithLine", ()=>lineWithLine);
/* Ellipse */ parcelHelpers.export(exports, "ellipseWithLine", ()=>ellipseWithLine);
parcelHelpers.export(exports, "ellipseWithEllipse", ()=>ellipseWithEllipse);
/* Rect */ parcelHelpers.export(exports, "rectWithLine", ()=>rectWithLine);
parcelHelpers.export(exports, "rectWithEllipse", ()=>rectWithEllipse);
parcelHelpers.export(exports, "rectWithRect", ()=>rectWithRect);
/* Polyline */ parcelHelpers.export(exports, "polylineWithLine", ()=>polylineWithLine);
parcelHelpers.export(exports, "polylineWithEllipse", ()=>polylineWithEllipse);
parcelHelpers.export(exports, "polylineWithRect", ()=>polylineWithRect);
parcelHelpers.export(exports, "polylineWithPolyline", ()=>polylineWithPolyline);
/* Polygon */ parcelHelpers.export(exports, "polygonWithLine", ()=>polygonWithLine);
parcelHelpers.export(exports, "polygonWithEllipse", ()=>polygonWithEllipse);
parcelHelpers.export(exports, "polygonWithRect", ()=>polygonWithRect);
parcelHelpers.export(exports, "polygonWithPolyline", ()=>polygonWithPolyline);
parcelHelpers.export(exports, "polygonWithPolygon", ()=>polygonWithPolygon);
/* Path */ parcelHelpers.export(exports, "pathWithLine", ()=>pathWithLine);
parcelHelpers.export(exports, "pathWithEllipse", ()=>pathWithEllipse);
parcelHelpers.export(exports, "pathWithRect", ()=>pathWithRect);
parcelHelpers.export(exports, "pathWithPolyline", ()=>pathWithPolyline);
parcelHelpers.export(exports, "pathWithPolygon", ()=>pathWithPolygon);
parcelHelpers.export(exports, "pathWithPath", ()=>pathWithPath);
var _lineMjs = require("./line.mjs");
var _polygonMjs = require("./polygon.mjs");
var _rectMjs = require("./rect.mjs");
var _typesMjs = require("./types.mjs");
function exists(shape1, shape2, shape1opt, shape2opt) {
    switch(shape1.type){
        case (0, _typesMjs.types).Line:
            switch(shape2.type){
                case (0, _typesMjs.types).Line:
                    return lineWithLine(shape1, shape2);
            }
            break;
        case (0, _typesMjs.types).Ellipse:
            switch(shape2.type){
                case (0, _typesMjs.types).Line:
                    return ellipseWithLine(shape1, shape2);
                case (0, _typesMjs.types).Ellipse:
                    return ellipseWithEllipse(shape1, shape2);
            }
            break;
        case (0, _typesMjs.types).Rect:
            switch(shape2.type){
                case (0, _typesMjs.types).Line:
                    return rectWithLine(shape1, shape2);
                case (0, _typesMjs.types).Ellipse:
                    return rectWithEllipse(shape1, shape2);
                case (0, _typesMjs.types).Rect:
                    return rectWithRect(shape1, shape2);
            }
            break;
        case (0, _typesMjs.types).Polyline:
            switch(shape2.type){
                case (0, _typesMjs.types).Line:
                    return polylineWithLine(shape1, shape2);
                case (0, _typesMjs.types).Ellipse:
                    return polylineWithEllipse(shape1, shape2);
                case (0, _typesMjs.types).Rect:
                    return polylineWithRect(shape1, shape2);
                case (0, _typesMjs.types).Polyline:
                    return polylineWithPolyline(shape1, shape2);
            }
            break;
        case (0, _typesMjs.types).Polygon:
            switch(shape2.type){
                case (0, _typesMjs.types).Line:
                    return polygonWithLine(shape1, shape2);
                case (0, _typesMjs.types).Ellipse:
                    return polygonWithEllipse(shape1, shape2);
                case (0, _typesMjs.types).Rect:
                    return polygonWithRect(shape1, shape2);
                case (0, _typesMjs.types).Polyline:
                    return polygonWithPolyline(shape1, shape2);
                case (0, _typesMjs.types).Polygon:
                    return polygonWithPolygon(shape1, shape2);
            }
            break;
        case (0, _typesMjs.types).Path:
            switch(shape2.type){
                case (0, _typesMjs.types).Line:
                    return pathWithLine(shape1, shape2, shape1opt);
                case (0, _typesMjs.types).Ellipse:
                    return pathWithEllipse(shape1, shape2, shape1opt);
                case (0, _typesMjs.types).Rect:
                    return pathWithRect(shape1, shape2, shape1opt);
                case (0, _typesMjs.types).Polyline:
                    return pathWithPolyline(shape1, shape2, shape1opt);
                case (0, _typesMjs.types).Polygon:
                    return pathWithPolygon(shape1, shape2, shape1opt);
                case (0, _typesMjs.types).Path:
                    return pathWithPath(shape1, shape2, shape1opt, shape2opt);
            }
            break;
    }
    // None of the cases above
    switch(shape2.type){
        case (0, _typesMjs.types).Ellipse:
        case (0, _typesMjs.types).Rect:
        case (0, _typesMjs.types).Polyline:
        case (0, _typesMjs.types).Polygon:
        case (0, _typesMjs.types).Path:
            return exists(shape2, shape1, shape2opt, shape1opt);
        default:
            throw Error(`The intersection for ${shape1} and ${shape2} could not be found.`);
    }
}
function lineWithLine(line1, line2) {
    const x1 = line1.start.x;
    const y1 = line1.start.y;
    const x2 = line1.end.x;
    const y2 = line1.end.y;
    const x3 = line2.start.x;
    const y3 = line2.start.y;
    const x4 = line2.end.x;
    const y4 = line2.end.y;
    const s1x = x2 - x1;
    const s1y = y2 - y1;
    const s2x = x4 - x3;
    const s2y = y4 - y3;
    const s3x = x1 - x3;
    const s3y = y1 - y3;
    const p = s1x * s2y - s2x * s1y;
    const s = (s1x * s3y - s1y * s3x) / p;
    const t = (s2x * s3y - s2y * s3x) / p;
    return s >= 0 && s <= 1 && t >= 0 && t <= 1;
}
function ellipseWithLine(ellipse, line) {
    const rex = ellipse.a;
    const rey = ellipse.b;
    const xe = ellipse.x;
    const ye = ellipse.y;
    const x1 = line.start.x - xe;
    const x2 = line.end.x - xe;
    const y1 = line.start.y - ye;
    const y2 = line.end.y - ye;
    const rex_2 = rex * rex;
    const rey_2 = rey * rey;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const A = dx * dx / rex_2 + dy * dy / rey_2;
    const B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;
    const C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;
    const D = B * B - 4 * A * C;
    if (D === 0) {
        const t = -B / 2 / A;
        return t >= 0 && t <= 1;
    } else if (D > 0) {
        const sqrt = Math.sqrt(D);
        const t1 = (-B + sqrt) / 2 / A;
        const t2 = (-B - sqrt) / 2 / A;
        return t1 >= 0 && t1 <= 1 || t2 >= 0 && t2 <= 1;
    }
    return false;
}
function ellipseWithEllipse(ellipse1, ellipse2) {
    return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);
}
function rectWithLine(rect, line) {
    const { start, end } = line;
    const { x, y, width, height } = rect;
    if (start.x > x + width && end.x > x + width || start.x < x && end.x < x || start.y > y + height && end.y > y + height || start.y < y && end.y < y) return false;
    if (rect.containsPoint(line.start) || rect.containsPoint(line.end)) return true;
    return lineWithLine(rect.topLine(), line) || lineWithLine(rect.rightLine(), line) || lineWithLine(rect.bottomLine(), line) || lineWithLine(rect.leftLine(), line);
}
function rectWithEllipse(rect, ellipse) {
    if (!rectWithRect(rect, (0, _rectMjs.Rect).fromEllipse(ellipse))) return false;
    return polygonWithEllipse((0, _polygonMjs.Polygon).fromRect(rect), ellipse);
}
function rectWithRect(rect1, rect2) {
    return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
}
function polylineWithLine(polyline, line) {
    return _polylineWithLine(polyline, line, {
        interior: false
    });
}
function polylineWithEllipse(polyline, ellipse) {
    return _polylineWithEllipse(polyline, ellipse, {
        interior: false
    });
}
function polylineWithRect(polyline, rect) {
    return _polylineWithRect(polyline, rect, {
        interior: false
    });
}
function polylineWithPolyline(polyline1, polyline2) {
    return _polylineWithPolyline(polyline1, polyline2, {
        interior: false
    });
}
function polygonWithLine(polygon, line) {
    return _polylineWithLine(polygon, line, {
        interior: true
    });
}
function polygonWithEllipse(polygon, ellipse) {
    return _polylineWithEllipse(polygon, ellipse, {
        interior: true
    });
}
function polygonWithRect(polygon, rect) {
    return _polylineWithRect(polygon, rect, {
        interior: true
    });
}
function polygonWithPolyline(polygon, polyline) {
    return _polylineWithPolyline(polygon, polyline, {
        interior: true
    });
}
function polygonWithPolygon(polygon1, polygon2) {
    return _polylineWithPolygon(polygon1, polygon2, {
        interior: true
    });
}
function pathWithLine(path, line, pathOpt) {
    return path.getSubpaths().some((subpath)=>{
        const [polyline] = subpath.toPolylines(pathOpt);
        const { type } = subpath.getSegment(-1);
        if (type === "Z") return polygonWithLine(polyline, line);
        else return polylineWithLine(polyline, line);
    });
}
function pathWithEllipse(path, ellipse, pathOpt) {
    return path.getSubpaths().some((subpath)=>{
        const [polyline] = subpath.toPolylines(pathOpt);
        const { type } = subpath.getSegment(-1);
        if (type === "Z") return polygonWithEllipse(polyline, ellipse);
        else return polylineWithEllipse(polyline, ellipse);
    });
}
function pathWithRect(path, rect, pathOpt) {
    return pathWithPolygon(path, (0, _polygonMjs.Polygon).fromRect(rect), pathOpt);
}
function pathWithPolyline(path, polyline, pathOpt) {
    return _pathWithPolyline(path, polyline, pathOpt, {
        interior: false
    });
}
function pathWithPolygon(path, polygon, pathOpt) {
    return _pathWithPolyline(path, polygon, pathOpt, {
        interior: true
    });
}
function pathWithPath(path1, path2, pathOpt1, pathOpt2) {
    return path1.getSubpaths().some((subpath)=>{
        const [polyline1] = subpath.toPolylines(pathOpt1);
        const { type } = subpath.getSegment(-1);
        if (type === "Z") return pathWithPolygon(path2, polyline1, pathOpt2);
        else return pathWithPolyline(path2, polyline1, pathOpt2);
    });
}
function _polylineWithLine(polyline, line, opt = {}) {
    const { interior = false } = opt;
    let thisPoints;
    if (interior) {
        if (polyline.containsPoint(line.start)) // If any point of the polyline lies inside this polygon (interior = true)
        // there is an intersection (we've chosen the start point)
        return true;
        const { start, end, points } = polyline;
        thisPoints = end.equals(start) ? points : [
            ...points,
            start
        ];
    } else thisPoints = polyline.points;
    const { length } = thisPoints;
    const segment = new (0, _lineMjs.Line)();
    for(let i = 0; i < length - 1; i++){
        segment.start = thisPoints[i];
        segment.end = thisPoints[i + 1];
        if (lineWithLine(line, segment)) return true;
    }
    return false;
}
function _polylineWithEllipse(polyline, ellipse, opt = {}) {
    const { start, end, points } = polyline;
    if (ellipse.containsPoint(start)) return true;
    let thisPoints;
    const { interior = false } = opt;
    if (interior) {
        if (polyline.containsPoint(ellipse.center())) // If any point of the ellipse lies inside this polygon (interior = true)
        // there is an intersection (we've chosen the center point)
        return true;
        thisPoints = end.equals(start) ? points : [
            ...points,
            start
        ];
    } else thisPoints = points;
    const { length } = thisPoints;
    const segment = new (0, _lineMjs.Line)();
    for(let i = 0; i < length - 1; i++){
        segment.start = thisPoints[i];
        segment.end = thisPoints[i + 1];
        if (ellipseWithLine(ellipse, segment)) return true;
    }
    return false;
}
function _polylineWithRect(polyline, rect, opt) {
    const polygon = (0, _polygonMjs.Polygon).fromRect(rect);
    return _polylineWithPolygon(polyline, polygon, opt);
}
function _pathWithPolyline(path, polyline1, pathOpt, opt) {
    return path.getSubpaths().some((subpath)=>{
        const [polyline2] = subpath.toPolylines(pathOpt);
        const { type } = subpath.getSegment(-1);
        if (type === "Z") return _polylineWithPolygon(polyline1, polyline2, opt);
        else return _polylineWithPolyline(polyline1, polyline2, opt);
    });
}
function _polylineWithPolyline(polyline1, polyline2, opt = {}) {
    const { interior = false } = opt;
    let thisPolyline;
    if (interior) {
        const { start } = polyline2;
        if (polyline1.containsPoint(start)) // If any point of the polyline lies inside this polygon (interior = true)
        // there is an intersection (we've chosen the start point)
        return true;
        thisPolyline = polyline1.clone().close();
    } else thisPolyline = polyline1;
    const otherPoints = polyline2.points;
    const { length } = otherPoints;
    const segment = new (0, _lineMjs.Line)();
    for(let i = 0; i < length - 1; i++){
        segment.start = otherPoints[i];
        segment.end = otherPoints[i + 1];
        if (polylineWithLine(thisPolyline, segment)) return true;
    }
    return false;
}
function _polylineWithPolygon(polyline, polygon, opt) {
    return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);
}
function _ellipsesIntersection(e1, w1, e2, w2) {
    const { cos, sin } = Math;
    const sinW1 = sin(w1);
    const cosW1 = cos(w1);
    const sinW2 = sin(w2);
    const cosW2 = cos(w2);
    const sinW1s = sinW1 * sinW1;
    const cosW1s = cosW1 * cosW1;
    const sinCos1 = sinW1 * cosW1;
    const sinW2s = sinW2 * sinW2;
    const cosW2s = cosW2 * cosW2;
    const sinCos2 = sinW2 * cosW2;
    const a1s = e1.a * e1.a;
    const b1s = e1.b * e1.b;
    const a2s = e2.a * e2.a;
    const b2s = e2.b * e2.b;
    const A1 = a1s * sinW1s + b1s * cosW1s;
    const A2 = a2s * sinW2s + b2s * cosW2s;
    const B1 = a1s * cosW1s + b1s * sinW1s;
    const B2 = a2s * cosW2s + b2s * sinW2s;
    let C1 = 2 * (b1s - a1s) * sinCos1;
    let C2 = 2 * (b2s - a2s) * sinCos2;
    let D1 = -2 * A1 * e1.x - C1 * e1.y;
    let D2 = -2 * A2 * e2.x - C2 * e2.y;
    let E1 = -C1 * e1.x - 2 * B1 * e1.y;
    let E2 = -C2 * e2.x - 2 * B2 * e2.y;
    const F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;
    const F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;
    C1 = C1 / 2;
    C2 = C2 / 2;
    D1 = D1 / 2;
    D2 = D2 / 2;
    E1 = E1 / 2;
    E2 = E2 / 2;
    const l3 = det3([
        [
            A1,
            C1,
            D1
        ],
        [
            C1,
            B1,
            E1
        ],
        [
            D1,
            E1,
            F1
        ]
    ]);
    const l0 = det3([
        [
            A2,
            C2,
            D2
        ],
        [
            C2,
            B2,
            E2
        ],
        [
            D2,
            E2,
            F2
        ]
    ]);
    const l2 = 0.33333333 * (det3([
        [
            A2,
            C1,
            D1
        ],
        [
            C2,
            B1,
            E1
        ],
        [
            D2,
            E1,
            F1
        ]
    ]) + det3([
        [
            A1,
            C2,
            D1
        ],
        [
            C1,
            B2,
            E1
        ],
        [
            D1,
            E2,
            F1
        ]
    ]) + det3([
        [
            A1,
            C1,
            D2
        ],
        [
            C1,
            B1,
            E2
        ],
        [
            D1,
            E1,
            F2
        ]
    ]));
    const l1 = 0.33333333 * (det3([
        [
            A1,
            C2,
            D2
        ],
        [
            C1,
            B2,
            E2
        ],
        [
            D1,
            E2,
            F2
        ]
    ]) + det3([
        [
            A2,
            C1,
            D2
        ],
        [
            C2,
            B1,
            E2
        ],
        [
            D2,
            E1,
            F2
        ]
    ]) + det3([
        [
            A2,
            C2,
            D1
        ],
        [
            C2,
            B2,
            E1
        ],
        [
            D2,
            E2,
            F1
        ]
    ]));
    const delta1 = det2([
        [
            l3,
            l2
        ],
        [
            l2,
            l1
        ]
    ]);
    const delta2 = det2([
        [
            l3,
            l1
        ],
        [
            l2,
            l0
        ]
    ]);
    const delta3 = det2([
        [
            l2,
            l1
        ],
        [
            l1,
            l0
        ]
    ]);
    const dP = det2([
        [
            2 * delta1,
            delta2
        ],
        [
            delta2,
            2 * delta3
        ]
    ]);
    if (dP > 0 && (l1 > 0 || l2 > 0)) return false;
    return true;
}
function det2(m) {
    return m[0][0] * m[1][1] - m[0][1] * m[1][0];
}
function det3(m) {
    return m[0][0] * m[1][1] * m[2][2] - m[0][0] * m[1][2] * m[2][1] - m[0][1] * m[1][0] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[1][0] * m[2][1] - m[0][2] * m[1][1] * m[2][0];
}

},{"./line.mjs":"f7trh","./polygon.mjs":"6G1L0","./rect.mjs":"6MvV7","./types.mjs":"217db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Vsch":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "config", ()=>config);
const config = {
    // When set to `true` the cell selectors could be defined as CSS selectors.
    // If not, only JSON Markup selectors are taken into account.
    // export let useCSSSelectors = true;
    useCSSSelectors: true,
    // The class name prefix config is for advanced use only.
    // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.
    // export let classNamePrefix = 'joint-';
    // export let defaultTheme = 'default';
    classNamePrefix: "joint-",
    defaultTheme: "default",
    // The maximum delay required for two consecutive touchend events to be interpreted
    // as a double-tap.
    doubleTapInterval: 300
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4e0W7":[function(require,module,exports) {
// code is inspired by https://github.com/lodash/lodash
/* eslint-disable no-case-declarations */ // -- helper constants
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBoolean", ()=>isBoolean);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "isNumber", ()=>isNumber);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "assign", ()=>assign);
parcelHelpers.export(exports, "mixin", ()=>mixin);
parcelHelpers.export(exports, "deepMixin", ()=>deepMixin);
parcelHelpers.export(exports, "supplement", ()=>supplement);
parcelHelpers.export(exports, "defaults", ()=>defaults);
parcelHelpers.export(exports, "deepSupplement", ()=>deepSupplement);
parcelHelpers.export(exports, "defaultsDeep", ()=>defaultsDeep);
parcelHelpers.export(exports, "invoke", ()=>invoke);
parcelHelpers.export(exports, "invokeProperty", ()=>invokeProperty);
parcelHelpers.export(exports, "sortedIndex", ()=>sortedIndex);
parcelHelpers.export(exports, "uniq", ()=>uniq);
parcelHelpers.export(exports, "clone", ()=>clone);
parcelHelpers.export(exports, "cloneDeep", ()=>cloneDeep);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "isEqual", ()=>isEqual);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject);
parcelHelpers.export(exports, "toArray", ()=>toArray);
parcelHelpers.export(exports, "debounce", ()=>debounce);
parcelHelpers.export(exports, "groupBy", ()=>groupBy);
parcelHelpers.export(exports, "sortBy", ()=>sortBy);
parcelHelpers.export(exports, "flattenDeep", ()=>flattenDeep);
parcelHelpers.export(exports, "without", ()=>without);
parcelHelpers.export(exports, "difference", ()=>difference);
parcelHelpers.export(exports, "intersection", ()=>intersection);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "has", ()=>has);
parcelHelpers.export(exports, "result", ()=>result);
parcelHelpers.export(exports, "omit", ()=>omit);
parcelHelpers.export(exports, "pick", ()=>pick);
parcelHelpers.export(exports, "bindAll", ()=>bindAll);
parcelHelpers.export(exports, "forIn", ()=>forIn);
parcelHelpers.export(exports, "camelCase", ()=>camelCase);
parcelHelpers.export(exports, "uniqueId", ()=>uniqueId);
parcelHelpers.export(exports, "merge", ()=>merge);
const argsTag = "[object Arguments]";
const arrayTag = "[object Array]";
const boolTag = "[object Boolean]";
const dateTag = "[object Date]";
const errorTag = "[object Error]";
const funcTag = "[object Function]";
const mapTag = "[object Map]";
const numberTag = "[object Number]";
const nullTag = "[object Null]";
const objectTag = "[object Object]";
const regexpTag = "[object RegExp]";
const setTag = "[object Set]";
const stringTag = "[object String]";
const symbolTag = "[object Symbol]";
const undefinedTag = "[object Undefined]";
const weakMapTag = "[object WeakMap]";
const arrayBufferTag = "[object ArrayBuffer]";
const dataViewTag = "[object DataView]";
const float32Tag = "[object Float32Array]";
const float64Tag = "[object Float64Array]";
const int8Tag = "[object Int8Array]";
const int16Tag = "[object Int16Array]";
const int32Tag = "[object Int32Array]";
const uint8Tag = "[object Uint8Array]";
const uint8ClampedTag = "[object Uint8ClampedArray]";
const uint16Tag = "[object Uint16Array]";
const uint32Tag = "[object Uint32Array]";
const CLONEABLE_TAGS = {
    [argsTag]: true,
    [arrayTag]: true,
    [arrayBufferTag]: true,
    [dataViewTag]: true,
    [boolTag]: true,
    [dateTag]: true,
    [float32Tag]: true,
    [float64Tag]: true,
    [int8Tag]: true,
    [int16Tag]: true,
    [int32Tag]: true,
    [mapTag]: true,
    [numberTag]: true,
    [objectTag]: true,
    [regexpTag]: true,
    [setTag]: true,
    [stringTag]: true,
    [symbolTag]: true,
    [uint8Tag]: true,
    [uint8ClampedTag]: true,
    [uint16Tag]: true,
    [uint32Tag]: true,
    [errorTag]: false,
    [funcTag]: false,
    [weakMapTag]: false
};
/** Used to compose unicode character classes. */ const rsAstralRange = "\ud800-\udfff";
const rsComboMarksRange = "\\u0300-\\u036f";
const reComboHalfMarksRange = "\\ufe20-\\ufe2f";
const rsComboSymbolsRange = "\\u20d0-\\u20ff";
const rsComboMarksExtendedRange = "\\u1ab0-\\u1aff";
const rsComboMarksSupplementRange = "\\u1dc0-\\u1dff";
const rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;
const rsDingbatRange = "\\u2700-\\u27bf";
const rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
const rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
const rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
const rsPunctuationRange = "\\u2000-\\u206f";
const rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
const rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
const rsVarRange = "\\ufe0e\\ufe0f";
const rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
/** Used to compose unicode capture groups. */ const rsApos = "['‚Äô]";
const rsBreak = `[${rsBreakRange}]`;
const rsCombo = `[${rsComboRange}]`;
const rsDigit = "\\d";
const rsDingbat = `[${rsDingbatRange}]`;
const rsLower = `[${rsLowerRange}]`;
const rsMisc = `[^${rsAstralRange}${rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange}]`;
const rsFitz = "\ud83c[\udffb-\udfff]";
const rsModifier = `(?:${rsCombo}|${rsFitz})`;
const rsNonAstral = `[^${rsAstralRange}]`;
const rsRegional = "(?:\ud83c[\udde6-\uddff]){2}";
const rsSurrPair = "[\ud800-\udbff][\udc00-\udfff]";
const rsUpper = `[${rsUpperRange}]`;
const rsZWJ = "\\u200d";
/** Used to compose unicode regexes. */ const rsMiscLower = `(?:${rsLower}|${rsMisc})`;
const rsMiscUpper = `(?:${rsUpper}|${rsMisc})`;
const rsOptContrLower = `(?:${rsApos}(?:d|ll|m|re|s|t|ve))?`;
const rsOptContrUpper = `(?:${rsApos}(?:D|LL|M|RE|S|T|VE))?`;
const reOptMod = `${rsModifier}?`;
const rsOptVar = `[${rsVarRange}]?`;
const rsOptJoin = `(?:${rsZWJ}(?:${[
    rsNonAstral,
    rsRegional,
    rsSurrPair
].join("|")})${rsOptVar + reOptMod})*`;
const rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
const rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
const rsSeq = rsOptVar + reOptMod + rsOptJoin;
const rsEmoji = `(?:${[
    rsDingbat,
    rsRegional,
    rsSurrPair
].join("|")})${rsSeq}`;
const reUnicodeWords = RegExp([
    `${rsUpper}?${rsLower}+${rsOptContrLower}(?=${[
        rsBreak,
        rsUpper,
        "$"
    ].join("|")})`,
    `${rsMiscUpper}+${rsOptContrUpper}(?=${[
        rsBreak,
        rsUpper + rsMiscLower,
        "$"
    ].join("|")})`,
    `${rsUpper}?${rsMiscLower}+${rsOptContrLower}`,
    `${rsUpper}+${rsOptContrUpper}`,
    rsOrdUpper,
    rsOrdLower,
    `${rsDigit}+`,
    rsEmoji
].join("|"), "g");
const LARGE_ARRAY_SIZE = 200;
const HASH_UNDEFINED = "__hash_undefined__";
// Used to match `toStringTag` values of typed arrays
const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
// Used to compose unicode capture groups
const rsAstral = `[${rsAstralRange}]`;
// Used to compose unicode regexes
const rsNonAstralCombo = `${rsNonAstral}${rsCombo}?`;
const rsSymbol = `(?:${[
    rsNonAstralCombo,
    rsCombo,
    rsRegional,
    rsSurrPair,
    rsAstral
].join("|")})`;
// Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode)
const reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol + rsSeq}`, "g");
const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
const reIsPlainProp = /^\w*$/;
const charCodeOfDot = ".".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(// Match anything that isn't a dot or bracket.
"[^.[\\]]+|\\[(?:([^\"'][^[]*)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))", "g");
const reIsUint = /^(?:0|[1-9]\d*)$/;
const hasUnicodeWord = RegExp.prototype.test.bind(/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/);
const MAX_ARRAY_INDEX = 4294967294;
/** Used to match words composed of alphanumeric characters. */ // eslint-disable-next-line no-control-regex
const reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
// -- helper functions
const hasUnicode = (string)=>{
    return reUnicode.test(string);
};
const unicodeToArray = (string)=>{
    return string.match(reUnicode) || [];
};
const asciiToArray = (string)=>{
    return string.split("");
};
const stringToArray = (string)=>{
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
};
const values = (object)=>{
    if (object == null) return [];
    return keys(object).map((key)=>object[key]);
};
const keys = (object)=>{
    return isArrayLike(object) ? arrayLikeKeys(object) : Object.keys(Object(object));
};
const baseKeys = (object)=>{
    if (!isPrototype(object)) return Object.keys(object);
    var result = [];
    for(var key in Object(object))if (hasOwnProperty.call(object, key) && key != "constructor") result.push(key);
    return result;
};
const arrayLikeKeys = (value, inherited)=>{
    const isArr = Array.isArray(value);
    const isArg = !isArr && isObjectLike(value) && getTag(value) === argsTag;
    const isType = !isArr && !isArg && isTypedArray(value);
    const skipIndexes = isArr || isArg || isType;
    const length = value.length;
    const result = new Array(skipIndexes ? length : 0);
    let index = skipIndexes ? -1 : length;
    while(++index < length)result[index] = `${index}`;
    for(const key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key === "length" || // Skip index properties.
    isIndex(key, length)))) result.push(key);
    return result;
};
const assocIndexOf = (array, key)=>{
    let { length } = array;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
};
const eq = (value, other)=>{
    return value === other || value !== value && other !== other;
};
const isObjectLike = (value)=>{
    return value != null && typeof value == "object";
};
const isIterateeCall = (value, index, object)=>{
    if (!isObject(object)) return false;
    const type = typeof index;
    const isPossibleIteratee = type == "number" ? isArrayLike(object) && index > -1 && index < object.length : type == "string" && index in object;
    if (isPossibleIteratee) return eq(object[index], value);
    return false;
};
const isSet = (value)=>{
    return isObjectLike(value) && getTag(value) == setTag;
};
const isMap = (value)=>{
    return isObjectLike(value) && getTag(value) == mapTag;
};
const isPrototype = (value)=>{
    const Ctor = value && value.constructor;
    const proto = typeof Ctor === "function" && Ctor.prototype || Object.prototype;
    return value === proto;
};
const assignValue = (object, key, value)=>{
    const objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) object[key] = value;
};
const copyObject = (source, props, object)=>{
    let index = -1;
    const length = props.length;
    while(++index < length){
        const key = props[index];
        assignValue(object, key, source[key]);
    }
    return object;
};
const isArrayLike = (value)=>{
    return value != null && typeof value !== "function" && typeof value.length === "number" && value.length > -1 && value.length % 1 === 0;
};
const isSymbol = (value)=>{
    return typeof value == "symbol" || isObjectLike(value) && getTag(value) === symbolTag;
};
const initCloneArray = (array)=>{
    const length = array.length;
    let result = new array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
    }
    return result;
};
const copyArray = (source, array)=>{
    let index = -1;
    const length = source.length;
    array || (array = new Array(length));
    while(++index < length)array[index] = source[index];
    return array;
};
const getTag = (value)=>{
    if (value == null) return value === undefined ? undefinedTag : nullTag;
    return Object.prototype.toString.call(value);
};
const cloneArrayBuffer = (arrayBuffer)=>{
    const result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
};
const cloneTypedArray = (typedArray, isDeep)=>{
    const buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
};
const cloneRegExp = (regexp)=>{
    const result = new regexp.constructor(regexp.source, /\w*$/.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
};
const initCloneObject = (object)=>{
    return typeof object.constructor == "function" && !isPrototype(object) ? Object.create(Object.getPrototypeOf(object)) : {};
};
const getSymbols = (object)=>{
    if (object == null) return [];
    object = Object(object);
    const symbols = Object.getOwnPropertySymbols(object);
    return symbols.filter((symbol)=>propertyIsEnumerable.call(object, symbol));
};
const copySymbols = (source, object)=>{
    return copyObject(source, getSymbols(source), object);
};
function cloneDataView(dataView, isDeep) {
    const buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
const initCloneByTag = (object, tag, isDeep)=>{
    const Constructor = object.constructor;
    switch(tag){
        case arrayBufferTag:
            return cloneArrayBuffer(object, isDeep);
        case boolTag:
        case dateTag:
            return new Constructor(+object);
        case dataViewTag:
            return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
            return cloneTypedArray(object, isDeep);
        case mapTag:
            return new Constructor(object);
        case numberTag:
        case stringTag:
            return new Constructor(object);
        case regexpTag:
            return cloneRegExp(object);
        case setTag:
            return new Constructor;
        case symbolTag:
            return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(object)) : {};
    }
};
const isTypedArray = (value)=>{
    return isObjectLike(value) && reTypedTag.test(getTag(value));
};
const getAllKeys = (object)=>{
    const result = Object.keys(object);
    if (!Array.isArray(object) && object != null) result.push(...getSymbols(Object(object)));
    return result;
};
const getSymbolsIn = (object)=>{
    const result = [];
    while(object){
        result.push(...getSymbols(object));
        object = Object.getPrototypeOf(Object(object));
    }
    return result;
};
const getAllKeysIn = (object)=>{
    const result = [];
    for(const key in object)result.push(key);
    if (!Array.isArray(object)) result.push(...getSymbolsIn(object));
    return result;
};
const getMapData = ({ __data__ }, key)=>{
    const data = __data__;
    return isKeyable(key) ? data[typeof key === "string" ? "string" : "hash"] : data.map;
};
const equalObjects = (object, other, equalFunc, stack)=>{
    const objProps = getAllKeys(object);
    const objLength = objProps.length;
    const othProps = getAllKeys(other);
    const othLength = othProps.length;
    if (objLength != othLength) return false;
    let key;
    let index = objLength;
    while(index--){
        key = objProps[index];
        if (!hasOwnProperty.call(other, key)) return false;
    }
    const objStacked = stack.get(object);
    const othStacked = stack.get(other);
    if (objStacked && othStacked) return objStacked == other && othStacked == object;
    let result = true;
    stack.set(object, other);
    stack.set(other, object);
    let compared;
    let skipCtor;
    while(++index < objLength){
        key = objProps[index];
        const objValue = object[key];
        const othValue = other[key];
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
        const objCtor = object.constructor;
        const othCtor = other.constructor;
        if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor === "function" && objCtor instanceof objCtor && typeof othCtor === "function" && othCtor instanceof othCtor)) result = false;
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
};
const baseIsEqual = (value, other, stack)=>{
    if (value === other) return true;
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) return value !== value && other !== other;
    return baseIsEqualDeep(value, other, baseIsEqual, stack);
};
const baseIsEqualDeep = (object, other, equalFunc, stack)=>{
    let objIsArr = Array.isArray(object);
    const othIsArr = Array.isArray(other);
    let objTag = objIsArr ? arrayTag : getTag(object);
    let othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    let objIsObj = objTag == objectTag;
    const othIsObj = othTag == objectTag;
    const isSameTag = objTag == othTag;
    if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, false, equalFunc, stack) : equalByTag(object, other, objTag, equalFunc, stack);
    }
    const objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__");
    const othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
        const objUnwrapped = objIsWrapped ? object.value() : object;
        const othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack);
        return equalFunc(objUnwrapped, othUnwrapped, stack);
    }
    if (!isSameTag) return false;
    stack || (stack = new Stack);
    return equalObjects(object, other, equalFunc, stack);
};
const equalArrays = (array, other, compareUnordered, equalFunc, stack)=>{
    const isPartial = false;
    const arrLength = array.length;
    const othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
    // Assume cyclic values are equal.
    const arrStacked = stack.get(array);
    const othStacked = stack.get(other);
    if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
    let index = -1;
    let result = true;
    const seen = compareUnordered ? new SetCache : undefined;
    stack.set(array, other);
    stack.set(other, array);
    while(++index < arrLength){
        let compared;
        const arrValue = array[index];
        const othValue = other[index];
        if (compared !== undefined) {
            if (compared) continue;
            result = false;
            break;
        }
        if (seen) {
            if (!some(other, (othValue, othIndex)=>{
                if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, stack))) return seen.push(othIndex);
            })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, stack))) {
            result = false;
            break;
        }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
};
const some = (array, predicate)=>{
    let index = -1;
    const length = array == null ? 0 : array.length;
    while(++index < length){
        if (predicate(array[index], index, array)) return true;
    }
    return false;
};
const cacheHas = (cache, key)=>{
    return cache.has(key);
};
const compareArrayBufferTag = (object, other, equalFunc, stack)=>{
    if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other), stack)) return false;
    return true;
};
const equalByTag = (object, other, tag, equalFunc, stack)=>{
    switch(tag){
        case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
            object = object.buffer;
            other = other.buffer;
            return compareArrayBufferTag(object, other, equalFunc, stack);
        case arrayBufferTag:
            return compareArrayBufferTag(object, other, equalFunc, stack);
        case boolTag:
        case dateTag:
        case numberTag:
            return eq(+object, +other);
        case errorTag:
            return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
            return object == `${other}`;
        case mapTag:
            let convert = mapToArray;
        // Intentional fallthrough
        // eslint-disable-next-line no-fallthrough
        case setTag:
            convert || (convert = setToArray);
            if (object.size != other.size) return false;
            // Assume cyclic values are equal.
            const stacked = stack.get(object);
            if (stacked) return stacked == other;
            // Recursively compare objects (susceptible to call stack limits).
            stack.set(object, other);
            const result = equalArrays(convert(object), convert(other), true, equalFunc, stack);
            stack["delete"](object);
            return result;
        case symbolTag:
            return Symbol.prototype.valueOf.call(object) == Symbol.prototype.valueOf.call(other);
    }
    return false;
};
const mapToArray = (map)=>{
    let index = -1;
    let result = Array(map.size);
    map.forEach((value, key)=>{
        result[++index] = [
            key,
            value
        ];
    });
    return result;
};
const setToArray = (set)=>{
    let index = -1;
    const result = new Array(set.size);
    set.forEach((value)=>{
        result[++index] = value;
    });
    return result;
};
const isKey = (value, object)=>{
    if (Array.isArray(value)) return false;
    const type = typeof value;
    if (type === "number" || type === "boolean" || value == null || isSymbol(value)) return true;
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
};
const stringToPath = (string)=>{
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) result.push("");
    string.replace(rePropName, (match, expression, quote, subString)=>{
        let key = match;
        if (quote) key = subString.replace(reEscapeChar, "$1");
        else if (expression) key = expression.trim();
        result.push(key);
    });
    return result;
};
const castPath = (path, object)=>{
    if (Array.isArray(path)) return path;
    return isKey(path, object) ? [
        path
    ] : stringToPath(`${path}`);
};
const get = (object, path)=>{
    path = castPath(path, object);
    let index = 0;
    const length = path.length;
    while(object != null && index < length){
        object = object[toKey(path[index])];
        index++;
    }
    return index && index == length ? object : undefined;
};
function compareAscending(value, other) {
    if (value !== other) {
        const valIsDefined = value !== undefined;
        const valIsNull = value === null;
        const valIsReflexive = value === value;
        const valIsSymbol = isSymbol(value);
        const othIsDefined = other !== undefined;
        const othIsNull = other === null;
        const othIsReflexive = other === other;
        const othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;
    }
    return 0;
}
function compareMultiple(object, other, orders) {
    let index = -1;
    const objCriteria = object.criteria;
    const othCriteria = other.criteria;
    const length = objCriteria.length;
    const ordersLength = orders.length;
    while(++index < length){
        const order = index < ordersLength ? orders[index] : null;
        const cmpFn = order && typeof order === "function" ? order : compareAscending;
        const result = cmpFn(objCriteria[index], othCriteria[index]);
        if (result) {
            if (order && typeof order !== "function") return result * (order == "desc" ? -1 : 1);
            return result;
        }
    }
    return object.index - other.index;
}
const diff = (array, values)=>{
    let includes = (array, value)=>{
        const length = array == null ? 0 : array.length;
        return !!length && array.indexOf(value) > -1;
    };
    let isCommon = true;
    const result = [];
    const valuesLength = values.length;
    if (!array.length) return result;
    if (values.length >= LARGE_ARRAY_SIZE) {
        includes = (cache, key)=>cache.has(key);
        isCommon = false;
        values = new SetCache(values);
    }
    outer: for(let key in array){
        let value = array[key];
        const computed = value;
        value = value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
            let valuesIndex = valuesLength;
            while(valuesIndex--){
                if (values[valuesIndex] === computed) continue outer;
            }
            result.push(value);
        } else if (!includes(values, computed)) result.push(value);
    }
    return result;
};
const intersect = (arrays)=>{
    const includes = (array, value)=>{
        const length = array == null ? 0 : array.length;
        return !!length && array.indexOf(value) > -1;
    };
    const cacheHas = (cache, key)=>cache.has(key);
    const length = arrays[0].length;
    const othLength = arrays.length;
    const caches = new Array(othLength);
    const result = [];
    let array;
    let maxLength = Infinity;
    let othIndex = othLength;
    while(othIndex--){
        array = arrays[othIndex];
        maxLength = Math.min(array.length, maxLength);
        caches[othIndex] = length >= 120 && array.length >= 120 ? new SetCache(othIndex && array) : undefined;
    }
    array = arrays[0];
    let index = -1;
    const seen = caches[0];
    outer: while(++index < length && result.length < maxLength){
        let value = array[index];
        const computed = value;
        value = value !== 0 ? value : 0;
        if (!(seen ? cacheHas(seen, computed) : includes(result, computed))) {
            othIndex = othLength;
            while(--othIndex){
                const cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed))) continue outer;
            }
            if (seen) seen.push(computed);
            result.push(value);
        }
    }
    return result;
};
const toKey = (value)=>{
    if (typeof value === "string" || isSymbol(value)) return value;
    const result = `${value}`;
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
};
const baseClone = (value, isDeep = false, isFlat = false, isFull = true, customizer, key, object, stack)=>{
    let result;
    if (customizer) result = object ? customizer(value, key, object, stack) : customizer(value);
    if (result !== undefined) return result;
    if (!isObject(value)) return value;
    const isArr = Array.isArray(value);
    const tag = getTag(value);
    if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) return copyArray(value, result);
    } else {
        const isFunc = typeof value === "function";
        if (tag === objectTag || tag === argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) return isFlat ? copySymbolsIn(value, copyObject(value, Object.keys(value), result)) : copySymbols(value, Object.assign(result, value));
        } else {
            if (isFunc || !CLONEABLE_TAGS[tag]) return object ? value : {};
            result = initCloneByTag(value, tag, isDeep);
        }
    }
    stack || (stack = new Stack);
    const stacked = stack.get(value);
    if (stacked) return stacked;
    stack.set(value, result);
    if (isMap(value)) {
        value.forEach((subValue, key)=>{
            result.set(key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));
        });
        return result;
    }
    if (isSet(value)) {
        value.forEach((subValue)=>{
            result.add(baseClone(subValue, isDeep, isFlat, isFull, customizer, subValue, value, stack));
        });
        return result;
    }
    if (isTypedArray(value)) return result;
    const keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    const props = isArr ? undefined : keysFunc(value);
    (props || value).forEach((subValue, key)=>{
        if (props) {
            key = subValue;
            subValue = value[key];
        }
        assignValue(result, key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));
    });
    return result;
};
const copySymbolsIn = (source, object)=>{
    return copyObject(source, getSymbolsIn(source), object);
};
const parent = (object, path)=>{
    return path.length < 2 ? object : get(object, path.slice(0, -1));
};
const set = (object, path, value)=>{
    if (!isObject(object)) return object;
    path = castPath(path, object);
    const length = path.length;
    const lastIndex = length - 1;
    let index = -1;
    let nested = object;
    while(nested != null && ++index < length){
        const key = toKey(path[index]);
        let newValue = value;
        if (index != lastIndex) {
            const objValue = nested[key];
            newValue = undefined;
            if (newValue === undefined) newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
    }
    return object;
};
const isIndex = (value, length)=>{
    const type = typeof value;
    length = length == null ? Number.MAX_SAFE_INTEGER : length;
    return !!length && (type === "number" || type !== "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
};
const unset = (object, path)=>{
    path = castPath(path, object);
    object = parent(object, path);
    const lastSegment = path[path.length - 1];
    return object == null || delete object[toKey(lastSegment)];
};
const isKeyable = (value)=>{
    const type = typeof value;
    return type === "string" || type === "number" || type === "symbol" || type === "boolean" ? value !== "__proto__" : value === null;
};
const keysIn = (object)=>{
    const result = [];
    for(const key in object)result.push(key);
    return result;
};
const toPlainObject = (value)=>{
    value = Object(value);
    const result = {};
    for(const key in value)result[key] = value[key];
    return result;
};
const safeGet = (object, key)=>{
    if (key === "constructor" && typeof object[key] === "function") return;
    if (key == "__proto__") return;
    return object[key];
};
function createAssigner(assigner, isMerge = false) {
    return (object, ...sources)=>{
        let index = -1;
        let length = sources.length;
        let customizer = length > 1 ? sources[length - 1] : undefined;
        const guard = length > 2 ? sources[2] : undefined;
        customizer = assigner.length > 3 && typeof customizer === "function" ? (length--, customizer) : isMerge ? (a, b)=>{
            if (Array.isArray(a) && !Array.isArray(b)) return b;
        } : undefined;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined : customizer;
            length = 1;
        }
        object = Object(object);
        while(++index < length){
            const source = sources[index];
            if (source) assigner(object, source, index, customizer);
        }
        return object;
    };
}
const baseMerge = (object, source, srcIndex, customizer, stack)=>{
    if (object === source) return;
    forIn(source, (srcValue, key)=>{
        if (isObject(srcValue)) {
            stack || (stack = new Stack);
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
            let newValue = customizer ? customizer(object[key], srcValue, `${key}`, object, source, stack) : undefined;
            if (newValue === undefined) newValue = srcValue;
            assignMergeValue(object, key, newValue);
        }
    }, keysIn);
};
const baseMergeDeep = (object, source, key, srcIndex, mergeFunc, customizer, stack)=>{
    const objValue = safeGet(object, key);
    const srcValue = safeGet(source, key);
    const stacked = stack.get(srcValue);
    if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
    }
    let newValue = customizer ? customizer(objValue, srcValue, `${key}`, object, source, stack) : undefined;
    let isCommon = newValue === undefined;
    if (isCommon) {
        const isArr = Array.isArray(srcValue);
        const isTyped = !isArr && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isTyped) {
            if (Array.isArray(objValue)) newValue = objValue;
            else if (isObjectLike(objValue) && isArrayLike(objValue)) newValue = copyArray(objValue);
            else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
            } else newValue = [];
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) newValue = toPlainObject(objValue);
            else if (typeof objValue === "function" || !isObject(objValue)) newValue = initCloneObject(srcValue);
        } else isCommon = false;
    }
    if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
};
const assignMergeValue = (object, key, value)=>{
    if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) assignValue(object, key, value);
};
function baseFor(object, iteratee, keysFunc) {
    const iterable = Object(object);
    const props = keysFunc(object);
    let { length } = props;
    let index = -1;
    while(length--){
        const key = props[++index];
        if (iteratee(iterable[key], key, iterable) === false) break;
    }
    return object;
}
const baseForOwn = (object, iteratee)=>{
    return object && baseFor(object, iteratee, keys);
};
const baseEach = (collection, iteratee)=>{
    if (collection == null) return collection;
    if (!isArrayLike(collection)) return baseForOwn(collection, iteratee);
    const length = collection.length;
    const iterable = Object(collection);
    let index = -1;
    while(++index < length){
        if (iteratee(iterable[index], index, iterable) === false) break;
    }
    return collection;
};
function last(array) {
    const length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
}
const createSet = Set && 1 / setToArray(new Set([
    undefined,
    -0
]))[1] == 1 / 0 ? (values)=>new Set(values) : ()=>{};
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
    if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack["delete"](srcValue);
    }
    return objValue;
}
function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) iteratees = iteratees.map((iteratee)=>{
        if (Array.isArray(iteratee)) return (value)=>get(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        return iteratee;
    });
    else iteratees = [
        (value)=>value
    ];
    let criteriaIndex = -1;
    let eachIndex = -1;
    const result = isArrayLike(collection) ? new Array(collection.length) : [];
    baseEach(collection, (value)=>{
        const criteria = iteratees.map((iteratee)=>iteratee(value));
        result[++eachIndex] = {
            criteria,
            index: ++criteriaIndex,
            value
        };
    });
    return baseSortBy(result, (object, other)=>compareMultiple(object, other, orders));
}
function baseSortBy(array, comparer) {
    let { length } = array;
    array.sort(comparer);
    while(length--)array[length] = array[length].value;
    return array;
}
function isStrictComparable(value) {
    return value === value && !isObject(value);
}
function matchesStrictComparable(key, srcValue) {
    return (object)=>{
        if (object == null) return false;
        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
}
function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
}
function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) return matchesStrictComparable(toKey(path), srcValue);
    return (object)=>{
        const objValue = get(object, path);
        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue);
    };
}
function baseMatches(source) {
    const matchData = getMatchData(source);
    if (matchData.length === 1 && matchData[0][2]) return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    return (object)=>object === source || baseIsMatch(object, source, matchData);
}
function getMatchData(object) {
    const result = keys(object);
    let length = result.length;
    while(length--){
        const key = result[length];
        const value = object[key];
        result[length] = [
            key,
            value,
            isStrictComparable(value)
        ];
    }
    return result;
}
function baseIsMatch(object, source, matchData, customizer) {
    let index = matchData.length;
    const length = index;
    const noCustomizer = !customizer;
    if (object == null) return !length;
    let data;
    let result;
    object = Object(object);
    while(index--){
        data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;
    }
    while(++index < length){
        data = matchData[index];
        const key = data[0];
        const objValue = object[key];
        const srcValue = data[1];
        if (noCustomizer && data[2]) {
            if (objValue === undefined && !(key in object)) return false;
        } else {
            const stack = new Stack;
            if (customizer) result = customizer(objValue, srcValue, key, object, source, stack);
            if (!(result === undefined ? baseIsEqual(srcValue, objValue, stack) : result)) return false;
        }
    }
    return true;
}
function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseProperty(key) {
    return (object)=>object == null ? undefined : object[key];
}
function basePropertyDeep(path) {
    return (object)=>get(object, path);
}
function baseIteratee(value) {
    if (typeof value == "function") return value;
    if (value == null) return (val)=>val;
    if (typeof value == "object") return Array.isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    return property(value);
}
function getIteratee() {
    const result = baseIteratee;
    return arguments.length ? result(arguments[0], arguments[1]) : result;
}
const arrayReduce = (array, iteratee, accumulator, initAccum)=>{
    let index = -1;
    const length = array == null ? 0 : array.length;
    if (initAccum && length) accumulator = array[++index];
    while(++index < length)accumulator = iteratee(accumulator, array[index], index, array);
    return accumulator;
};
const baseReduce = (collection, iteratee, accumulator, initAccum, eachFunc)=>{
    eachFunc(collection, (value, index, collection)=>{
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
};
function reduce(collection, iteratee, accumulator) {
    const func = Array.isArray(collection) ? arrayReduce : baseReduce;
    const initAccum = arguments.length < 3;
    return func(collection, iteratee, accumulator, initAccum, baseEach);
}
const isFlattenable = (value)=>{
    return Array.isArray(value) || isArguments(value) || !!(value && value[Symbol.isConcatSpreadable]);
};
function baseFlatten(array, depth, predicate, isStrict, result) {
    let index = -1;
    const length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while(++index < length){
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
            else result.push(...value);
        } else if (!isStrict) result[result.length] = value;
    }
    return result;
}
const isArguments = (value)=>{
    return isObjectLike(value) && getTag(value) == "[object Arguments]";
};
const basePick = (object, paths)=>{
    return basePickBy(object, paths, (value, path)=>hasIn(object, path));
};
const basePickBy = (object, paths, predicate)=>{
    let index = -1;
    const length = paths.length;
    const result = {};
    while(++index < length){
        const path = paths[index];
        const value = get(object, path);
        if (predicate(value, path)) set(result, castPath(path, object), value);
    }
    return result;
};
const isLength = (value)=>{
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;
};
const baseHasIn = (object, key)=>{
    return object != null && key in Object(object);
};
const hasPath = (object, path, hasFunc)=>{
    path = castPath(path, object);
    var index = -1, length = path.length, result = false;
    while(++index < length){
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) break;
        object = object[key];
    }
    if (result || ++index != length) return result;
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (Array.isArray(object) || isArguments(object));
};
const asciiWords = (string)=>{
    return string.match(reAsciiWord);
};
const unicodeWords = (string)=>{
    return string.match(reUnicodeWords);
};
const words = (string, pattern)=>{
    if (pattern === undefined) {
        const result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        return result || [];
    }
    return string.match(pattern) || [];
};
const castSlice = (array, start, end)=>{
    const { length } = array;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : array.slice(start, end);
};
const upperFirst = createCaseFirst("toUpperCase");
function createCaseFirst(methodName) {
    return (string)=>{
        if (!string) return "";
        const strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
        const chr = strSymbols ? strSymbols[0] : string[0];
        const trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
    };
}
// -- helper classes
class Stack {
    constructor(entries){
        const data = this.__data__ = new ListCache(entries);
        this.size = data.size;
    }
    clear() {
        this.__data__ = new ListCache;
        this.size = 0;
    }
    delete(key) {
        const data = this.__data__;
        const result = data["delete"](key);
        this.size = data.size;
        return result;
    }
    get(key) {
        return this.__data__.get(key);
    }
    has(key) {
        return this.__data__.has(key);
    }
    set(key, value) {
        let data = this.__data__;
        if (data instanceof ListCache) {
            const pairs = data.__data__;
            if (pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([
                    key,
                    value
                ]);
                this.size = ++data.size;
                return this;
            }
            data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
    }
}
class ListCache {
    constructor(entries){
        let index = -1;
        const length = entries == null ? 0 : entries.length;
        this.clear();
        while(++index < length){
            const entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    clear() {
        this.__data__ = [];
        this.size = 0;
    }
    delete(key) {
        const data = this.__data__;
        const index = assocIndexOf(data, key);
        if (index < 0) return false;
        const lastIndex = data.length - 1;
        if (index == lastIndex) data.pop();
        else data.splice(index, 1);
        --this.size;
        return true;
    }
    get(key) {
        const data = this.__data__;
        const index = assocIndexOf(data, key);
        return index < 0 ? undefined : data[index][1];
    }
    has(key) {
        return assocIndexOf(this.__data__, key) > -1;
    }
    set(key, value) {
        const data = this.__data__;
        const index = assocIndexOf(data, key);
        if (index < 0) {
            ++this.size;
            data.push([
                key,
                value
            ]);
        } else data[index][1] = value;
        return this;
    }
}
class MapCache {
    constructor(entries){
        let index = -1;
        const length = entries == null ? 0 : entries.length;
        this.clear();
        while(++index < length){
            const entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    clear() {
        this.size = 0;
        this.__data__ = {
            "hash": new Hash,
            "map": new Map,
            "string": new Hash
        };
    }
    delete(key) {
        const result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
    }
    get(key) {
        return getMapData(this, key).get(key);
    }
    has(key) {
        return getMapData(this, key).has(key);
    }
    set(key, value) {
        const data = getMapData(this, key);
        const size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
    }
}
class Hash {
    constructor(entries){
        let index = -1;
        const length = entries == null ? 0 : entries.length;
        this.clear();
        while(++index < length){
            const entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    clear() {
        this.__data__ = Object.create(null);
        this.size = 0;
    }
    delete(key) {
        const result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
    }
    get(key) {
        const data = this.__data__;
        const result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    has(key) {
        const data = this.__data__;
        return data[key] !== undefined;
    }
    set(key, value) {
        const data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = value === undefined ? HASH_UNDEFINED : value;
        return this;
    }
}
class SetCache {
    constructor(values){
        let index = -1;
        const length = values == null ? 0 : values.length;
        this.__data__ = new MapCache;
        while(++index < length)this.add(values[index]);
    }
    add(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
    }
    has(value) {
        return this.__data__.has(value);
    }
}
SetCache.prototype.push = SetCache.prototype.add;
const isBoolean = function(value) {
    var toString = Object.prototype.toString;
    return value === true || value === false || !!value && typeof value === "object" && toString.call(value) === boolTag;
};
const isObject = function(value) {
    return !!value && (typeof value === "object" || typeof value === "function");
};
const isNumber = function(value) {
    var toString = Object.prototype.toString;
    return typeof value === "number" || !!value && typeof value === "object" && toString.call(value) === numberTag;
};
const isString = function(value) {
    var toString = Object.prototype.toString;
    return typeof value === "string" || !!value && typeof value === "object" && toString.call(value) === stringTag;
};
const assign = createAssigner((object, source)=>{
    if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
    }
    for(var key in source)if (hasOwnProperty.call(source, key)) assignValue(object, key, source[key]);
});
const mixin = assign;
const deepMixin = mixin;
const supplement = (object, ...sources)=>{
    let index = -1;
    let length = sources.length;
    const guard = length > 2 ? sources[2] : undefined;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) length = 1;
    while(++index < length){
        const source = sources[index];
        if (source == null) continue;
        const props = Object.keys(source);
        const propsLength = props.length;
        let propsIndex = -1;
        while(++propsIndex < propsLength){
            const key = props[propsIndex];
            const value = object[key];
            if (value === undefined || eq(value, Object.prototype[key]) && !hasOwnProperty.call(object, key)) object[key] = source[key];
        }
    }
    return object;
};
const defaults = supplement;
const deepSupplement = function defaultsDeep(...args) {
    args.push(undefined, customDefaultsMerge);
    return merge.apply(undefined, args);
};
const defaultsDeep = deepSupplement;
const invoke = (collection, path, ...args)=>{
    let index = -1;
    const isFunc = typeof path === "function";
    const result = isArrayLike(collection) ? new Array(collection.length) : [];
    baseEach(collection, (value)=>{
        result[++index] = isFunc ? path.apply(value, args) : invokeProperty(value, path, ...args);
    });
    return result;
};
const invokeProperty = (object, path, ...args)=>{
    path = castPath(path, object);
    object = parent(object, path);
    const func = object == null ? object : object[toKey(last(path))];
    return func == null ? undefined : func.apply(object, args);
};
const sortedIndex = (array, value, iteratee)=>{
    let low = 0;
    let high = array == null ? 0 : array.length;
    if (high == 0) return 0;
    iteratee = getIteratee(iteratee, 2);
    value = iteratee(value);
    const valIsNaN = value !== value;
    const valIsNull = value === null;
    const valIsSymbol = isSymbol(value);
    const valIsUndefined = value === undefined;
    while(low < high){
        let setLow;
        const mid = Math.floor((low + high) / 2);
        const computed = iteratee(array[mid]);
        const othIsDefined = computed !== undefined;
        const othIsNull = computed === null;
        const othIsReflexive = computed === computed;
        const othIsSymbol = isSymbol(computed);
        if (valIsNaN) setLow = othIsReflexive;
        else if (valIsUndefined) setLow = othIsReflexive && othIsDefined;
        else if (valIsNull) setLow = othIsReflexive && othIsDefined && !othIsNull;
        else if (valIsSymbol) setLow = othIsReflexive && othIsDefined && !othIsNull && !othIsSymbol;
        else if (othIsNull || othIsSymbol) setLow = false;
        else setLow = computed < value;
        if (setLow) low = mid + 1;
        else high = mid;
    }
    return Math.min(high, MAX_ARRAY_INDEX);
};
const uniq = (array, iteratee)=>{
    let index = -1;
    let includes = (array, value)=>{
        const length = array == null ? 0 : array.length;
        return !!length && array.indexOf(value) > -1;
    };
    iteratee = getIteratee(iteratee, 2);
    let isCommon = true;
    const { length } = array;
    const result = [];
    let seen = result;
    if (length >= LARGE_ARRAY_SIZE) {
        const set = iteratee ? null : createSet(array);
        if (set) return setToArray(set);
        isCommon = false;
        includes = (cache, key)=>cache.has(key);
        seen = new SetCache;
    } else seen = iteratee ? [] : result;
    outer: while(++index < length){
        let value = array[index];
        const computed = iteratee ? iteratee(value) : value;
        value = value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
            let seenIndex = seen.length;
            while(seenIndex--){
                if (seen[seenIndex] === computed) continue outer;
            }
            if (iteratee) seen.push(computed);
            result.push(value);
        } else if (!includes(seen, computed)) {
            if (seen !== result) seen.push(computed);
            result.push(value);
        }
    }
    return result;
};
const clone = (value)=>baseClone(value);
const cloneDeep = (value)=>baseClone(value, true);
const isEmpty = (value)=>{
    if (value == null) return true;
    if (isArrayLike(value) && (Array.isArray(value) || typeof value === "string" || typeof value.splice === "function" || isTypedArray(value) || isArguments(value))) return !value.length;
    const tag = getTag(value);
    if (tag == "[object Map]" || tag == "[object Set]") return !value.size;
    if (isPrototype(value)) return !baseKeys(value).length;
    for(const key in value){
        if (hasOwnProperty.call(value, key)) return false;
    }
    return true;
};
const isEqual = (object, other)=>baseIsEqual(object, other);
const isFunction = (value)=>typeof value === "function";
const isPlainObject = (value)=>{
    if (!isObjectLike(value) || getTag(value) != "[object Object]") return false;
    if (Object.getPrototypeOf(value) === null) return true;
    let proto = value;
    while(Object.getPrototypeOf(proto) !== null)proto = Object.getPrototypeOf(proto);
    return Object.getPrototypeOf(value) === proto;
};
const toArray = (value)=>{
    if (!value) return [];
    if (isArrayLike(value)) return isString(value) ? stringToArray(value) : copyArray(value);
    if (Symbol.iterator && Symbol.iterator in Object(value)) {
        const iterator = value[Symbol.iterator]();
        let data;
        const result = [];
        while(!(data = iterator.next()).done)result.push(data.value);
        return result;
    }
    const tag = getTag(value);
    const func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
    return func(value);
};
function debounce(func, wait, opt) {
    if (typeof func !== "function") throw new TypeError("Expected a function");
    let lastArgs;
    let lastThis;
    let maxWait;
    let result;
    let timerId;
    let lastCallTime;
    let lastInvokeTime = 0;
    let leading = false;
    let maxing = false;
    let trailing = true;
    const useRaf = !wait && wait !== 0 && window && typeof window.requestAnimationFrame === "function";
    wait = +wait || 0;
    if (isObject(opt)) {
        leading = !!opt.leading;
        maxing = "maxWait" in opt;
        maxWait = maxing ? Math.max(+opt.maxWait || 0, wait) : maxWait;
        trailing = "trailing" in opt ? !!opt.trailing : trailing;
    }
    function invokeFunc(time) {
        const args = lastArgs;
        const thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function startTimer(pendingFunc, wait) {
        if (useRaf) {
            window.cancelAnimationFrame(timerId);
            return window.requestAnimationFrame(pendingFunc);
        }
        return setTimeout(pendingFunc, wait);
    }
    function cancelTimer(id) {
        if (useRaf) return window.cancelAnimationFrame(id);
        clearTimeout(id);
    }
    function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = startTimer(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        const timeSinceLastCall = time - lastCallTime;
        const timeSinceLastInvoke = time - lastInvokeTime;
        const timeWaiting = wait - timeSinceLastCall;
        return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
        const timeSinceLastCall = time - lastCallTime;
        const timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
        const time = Date.now();
        if (shouldInvoke(time)) return trailingEdge(time);
        timerId = startTimer(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = undefined;
        if (trailing && lastArgs) return invokeFunc(time);
        lastArgs = lastThis = undefined;
        return result;
    }
    function debounced(...args) {
        const time = Date.now();
        const isInvoking = shouldInvoke(time);
        lastArgs = args;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === undefined) return leadingEdge(lastCallTime);
            if (maxing) {
                timerId = startTimer(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) timerId = startTimer(timerExpired, wait);
        return result;
    }
    debounced.cancel = ()=>{
        if (timerId !== undefined) cancelTimer(timerId);
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    };
    debounced.flush = ()=>timerId === undefined ? result : trailingEdge(Date.now());
    debounced.pending = ()=>timerId !== undefined;
    return debounced;
}
const groupBy = (collection, iteratee)=>{
    iteratee = getIteratee(iteratee, 2);
    return reduce(collection, (result, value, key)=>{
        key = iteratee(value);
        if (hasOwnProperty.call(result, key)) result[key].push(value);
        else assignValue(result, key, [
            value
        ]);
        return result;
    }, {});
};
const sortBy = (collection, iteratees = [])=>{
    if (collection == null) return [];
    const length = iteratees.length;
    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) iteratees = [];
    else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) iteratees = [
        iteratees[0]
    ];
    if (!Array.isArray(iteratees)) iteratees = [
        getIteratee(iteratees, 2)
    ];
    return baseOrderBy(collection, iteratees.flat(1), []);
};
const flattenDeep = (array)=>{
    const length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, Infinity) : [];
};
const without = (array, ...values)=>isArrayLike(array) ? diff(array, values) : [];
const difference = (array, ...values)=>isObjectLike(array) && isArrayLike(array) ? diff(array, values.flat(1)) : [];
const intersection = (...arrays)=>{
    const mapped = arrays.map((array)=>isObjectLike(array) && isArrayLike(array) ? array : []);
    return mapped.length && mapped[0] === arrays[0] ? intersect(mapped) : [];
};
const union = (...arrays)=>{
    const array = arrays.flat(1);
    return uniq(array);
};
const has = (object, key)=>{
    if (object == null) return false;
    if (typeof key === "string") key = key.split(".");
    let index = -1;
    let value = object;
    while(++index < key.length){
        if (!value || !hasOwnProperty.call(value, key[index])) return false;
        value = value[key[index]];
    }
    return true;
};
const result = (object, path, defaultValue)=>{
    path = castPath(path, object);
    let index = -1;
    let length = path.length;
    if (!length) {
        length = 1;
        object = undefined;
    }
    while(++index < length){
        let value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
            index = length;
            value = defaultValue;
        }
        object = typeof value === "function" ? value.call(object) : value;
    }
    return object;
};
const omit = (object, ...paths)=>{
    let result = {};
    if (object == null) return result;
    let isDeep = false;
    paths = paths.flat(1).map((path)=>{
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
    });
    copyObject(object, getAllKeysIn(object), result);
    if (isDeep) result = baseClone(result, true, true, true, (value)=>isPlainObject(value) ? undefined : value);
    let length = paths.length;
    while(length--)unset(result, paths[length]);
    return result;
};
const pick = (object, ...paths)=>{
    return object == null ? {} : basePick(object, paths.flat(Infinity));
};
const bindAll = (object, ...methodNames)=>{
    methodNames.flat(1).forEach((key)=>{
        key = toKey(key);
        assignValue(object, key, object[key].bind(object));
    });
    return object;
};
const forIn = (object, iteratee = (value)=>value)=>{
    let index = -1;
    const iterable = Object(object);
    const props = isArrayLike(object) ? arrayLikeKeys(object, true) : keysIn(object);
    let length = props.length;
    while(length--){
        const key = props[++index];
        if (iteratee(iterable[key], key, iterable) === false) break;
    }
};
const camelCase = (string = "")=>words(`${string}`.replace(/['\u2019]/g, "")).reduce((result, word, index)=>{
        word = word.toLowerCase();
        return result + (index ? upperFirst(word) : word);
    }, "");
let idCounter = 0;
const uniqueId = (prefix = "")=>{
    const id = ++idCounter;
    return `${prefix}` + id;
};
const merge = createAssigner((object, source, srcIndex, customizer)=>{
    baseMerge(object, source, srcIndex, customizer);
}, true);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5qBbR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Clone `cells` returning an object that maps the original cell ID to the clone. The number
// of clones is exactly the same as the `cells.length`.
// This function simply clones all the `cells`. However, it also reconstructs
// all the `source/target` and `parent/embed` references within the `cells`.
// This is the main difference from the `cell.clone()` method. The
// `cell.clone()` method works on one single cell only.
// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`
// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.
// the source and target of the link `L2` is changed to point to `A2` and `B2`.
parcelHelpers.export(exports, "cloneCells", ()=>cloneCells);
var _utilMjs = require("./util.mjs");
function cloneCells(cells) {
    cells = (0, _utilMjs.uniq)(cells);
    // A map of the form [original cell ID] -> [clone] helping
    // us to reconstruct references for source/target and parent/embeds.
    // This is also the returned value.
    const cloneMap = (0, _utilMjs.toArray)(cells).reduce(function(map, cell) {
        map[cell.id] = cell.clone();
        return map;
    }, {});
    (0, _utilMjs.toArray)(cells).forEach(function(cell) {
        const clone = cloneMap[cell.id];
        // assert(clone exists)
        if (clone.isLink()) {
            const source = clone.source();
            const target = clone.target();
            if (source.id && cloneMap[source.id]) // Source points to an element and the element is among the clones.
            // => Update the source of the cloned link.
            clone.prop("source/id", cloneMap[source.id].id);
            if (target.id && cloneMap[target.id]) // Target points to an element and the element is among the clones.
            // => Update the target of the cloned link.
            clone.prop("target/id", cloneMap[target.id].id);
        }
        // Find the parent of the original cell
        const parent = cell.get("parent");
        if (parent && cloneMap[parent]) clone.set("parent", cloneMap[parent].id);
        // Find the embeds of the original cell
        const embeds = (0, _utilMjs.toArray)(cell.get("embeds")).reduce(function(newEmbeds, embed) {
            // Embedded cells that are not being cloned can not be carried
            // over with other embedded cells.
            if (cloneMap[embed]) newEmbeds.push(cloneMap[embed].id);
            return newEmbeds;
        }, []);
        if (!(0, _utilMjs.isEmpty)(embeds)) clone.set("embeds", embeds);
    });
    return cloneMap;
}

},{"./util.mjs":"5j2Qt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9p63m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "attributes", ()=>attributes);
var _indexMjs = require("../../g/index.mjs");
var _utilMjs = require("../../util/util.mjs");
var _calcMjs = require("./calc.mjs");
var _propsMjs = require("./props.mjs");
var _propsMjsDefault = parcelHelpers.interopDefault(_propsMjs);
var _jquery = require("jquery");
var _jqueryDefault = parcelHelpers.interopDefault(_jquery);
var _indexMjs1 = require("../../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
function setWrapper(attrName, dimension) {
    return function(value, refBBox) {
        var isValuePercentage = (0, _utilMjs.isPercentage)(value);
        value = parseFloat(value);
        if (isValuePercentage) value /= 100;
        var attrs = {};
        if (isFinite(value)) {
            var attrValue = isValuePercentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);
            attrs[attrName] = attrValue;
        }
        return attrs;
    };
}
function positionWrapper(axis, dimension, origin) {
    return function(value, refBBox) {
        var valuePercentage = (0, _utilMjs.isPercentage)(value);
        value = parseFloat(value);
        if (valuePercentage) value /= 100;
        var delta;
        if (isFinite(value)) {
            var refOrigin = refBBox[origin]();
            if (valuePercentage || value > 0 && value < 1) delta = refOrigin[axis] + refBBox[dimension] * value;
            else delta = refOrigin[axis] + value;
        }
        var point = (0, _indexMjs.Point)();
        point[axis] = delta || 0;
        return point;
    };
}
function offsetWrapper(axis, dimension, corner) {
    return function(value, nodeBBox) {
        var delta;
        if (value === "middle") delta = nodeBBox[dimension] / 2;
        else if (value === corner) delta = nodeBBox[dimension];
        else if (isFinite(value)) // TODO: or not to do a breaking change?
        delta = value > -1 && value < 1 ? -nodeBBox[dimension] * value : -value;
        else if ((0, _utilMjs.isPercentage)(value)) delta = nodeBBox[dimension] * parseFloat(value) / 100;
        else delta = 0;
        var point = (0, _indexMjs.Point)();
        point[axis] = -(nodeBBox[axis] + delta);
        return point;
    };
}
function shapeWrapper(shapeConstructor, opt) {
    var cacheName = "joint-shape";
    var resetOffset = opt && opt.resetOffset;
    return function(value, refBBox, node) {
        var $node = (0, _jqueryDefault.default)(node);
        var cache = $node.data(cacheName);
        if (!cache || cache.value !== value) {
            // only recalculate if value has changed
            var cachedShape = shapeConstructor(value);
            cache = {
                value: value,
                shape: cachedShape,
                shapeBBox: cachedShape.bbox()
            };
            $node.data(cacheName, cache);
        }
        var shape = cache.shape.clone();
        var shapeBBox = cache.shapeBBox.clone();
        var shapeOrigin = shapeBBox.origin();
        var refOrigin = refBBox.origin();
        shapeBBox.x = refOrigin.x;
        shapeBBox.y = refOrigin.y;
        var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);
        // `maxRectScaleToFit` can give Infinity if width or height is 0
        var sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;
        var sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;
        shape.scale(sx, sy, shapeOrigin);
        if (resetOffset) shape.translate(-shapeOrigin.x, -shapeOrigin.y);
        return shape;
    };
}
// `d` attribute for SVGPaths
function dWrapper(opt) {
    function pathConstructor(value) {
        return new (0, _indexMjs.Path)((0, _indexMjsDefault.default).normalizePathData(value));
    }
    var shape = shapeWrapper(pathConstructor, opt);
    return function(value, refBBox, node) {
        var path = shape(value, refBBox, node);
        return {
            d: path.serialize()
        };
    };
}
// `points` attribute for SVGPolylines and SVGPolygons
function pointsWrapper(opt) {
    var shape = shapeWrapper((0, _indexMjs.Polyline), opt);
    return function(value, refBBox, node) {
        var polyline = shape(value, refBBox, node);
        return {
            points: polyline.serialize()
        };
    };
}
function atConnectionWrapper(method, opt) {
    var zeroVector = new (0, _indexMjs.Point)(1, 0);
    return function(value) {
        var p, angle;
        var tangent = this[method](value);
        if (tangent) {
            angle = opt.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;
            p = tangent.start;
        } else {
            p = this.path.start;
            angle = 0;
        }
        if (angle === 0) return {
            transform: "translate(" + p.x + "," + p.y + ")"
        };
        return {
            transform: "translate(" + p.x + "," + p.y + ") rotate(" + angle + ")"
        };
    };
}
function setIfChangedWrapper(attribute) {
    return function setIfChanged(value, _, node) {
        const vel = (0, _indexMjsDefault.default)(node);
        if (vel.attr(attribute) === value) return;
        vel.attr(attribute, value);
    };
}
function isTextInUse(_value, _node, attrs) {
    return attrs.text !== undefined;
}
function isLinkView() {
    return this.model.isLink();
}
function contextMarker(context) {
    var marker = {};
    // Stroke
    // The context 'fill' is disregared here. The usual case is to use the marker with a connection
    // (for which 'fill' attribute is set to 'none').
    var stroke = context.stroke;
    if (typeof stroke === "string") {
        marker["stroke"] = stroke;
        marker["fill"] = stroke;
    }
    // Opacity
    // Again the context 'fill-opacity' is ignored.
    var strokeOpacity = context.strokeOpacity;
    if (strokeOpacity === undefined) strokeOpacity = context["stroke-opacity"];
    if (strokeOpacity === undefined) strokeOpacity = context.opacity;
    if (strokeOpacity !== undefined) {
        marker["stroke-opacity"] = strokeOpacity;
        marker["fill-opacity"] = strokeOpacity;
    }
    return marker;
}
function setPaintURL(def) {
    const { paper } = this;
    const url = def.type === "pattern" ? paper.definePattern(def) : paper.defineGradient(def);
    return `url(#${url})`;
}
const attributesNS = {
    xlinkShow: {
        set: "xlink:show"
    },
    xlinkRole: {
        set: "xlink:role"
    },
    xlinkType: {
        set: "xlink:type"
    },
    xlinkArcrole: {
        set: "xlink:arcrole"
    },
    xlinkTitle: {
        set: "xlink:title"
    },
    xlinkActuate: {
        set: "xlink:actuate"
    },
    xmlSpace: {
        set: "xml:space"
    },
    xmlBase: {
        set: "xml:base"
    },
    xmlLang: {
        set: "xml:lang"
    },
    preserveAspectRatio: {
        set: "preserveAspectRatio"
    },
    requiredExtension: {
        set: "requiredExtension"
    },
    requiredFeatures: {
        set: "requiredFeatures"
    },
    systemLanguage: {
        set: "systemLanguage"
    },
    externalResourcesRequired: {
        set: "externalResourceRequired"
    },
    href: {
        set: setIfChangedWrapper("href")
    },
    xlinkHref: {
        set: setIfChangedWrapper("xlink:href")
    },
    filter: {
        qualify: (0, _utilMjs.isPlainObject),
        set: function(filter) {
            return "url(#" + this.paper.defineFilter(filter) + ")";
        }
    },
    fill: {
        qualify: (0, _utilMjs.isPlainObject),
        set: setPaintURL
    },
    stroke: {
        qualify: (0, _utilMjs.isPlainObject),
        set: setPaintURL
    },
    sourceMarker: {
        qualify: (0, _utilMjs.isPlainObject),
        set: function(marker, refBBox, node, attrs) {
            marker = (0, _utilMjs.assign)(contextMarker(attrs), marker);
            return {
                "marker-start": "url(#" + this.paper.defineMarker(marker) + ")"
            };
        }
    },
    targetMarker: {
        qualify: (0, _utilMjs.isPlainObject),
        set: function(marker, refBBox, node, attrs) {
            marker = (0, _utilMjs.assign)(contextMarker(attrs), {
                "transform": "rotate(180)"
            }, marker);
            return {
                "marker-end": "url(#" + this.paper.defineMarker(marker) + ")"
            };
        }
    },
    vertexMarker: {
        qualify: (0, _utilMjs.isPlainObject),
        set: function(marker, refBBox, node, attrs) {
            marker = (0, _utilMjs.assign)(contextMarker(attrs), marker);
            return {
                "marker-mid": "url(#" + this.paper.defineMarker(marker) + ")"
            };
        }
    },
    text: {
        qualify: function(_text, _node, attrs) {
            return !attrs.textWrap || !(0, _utilMjs.isPlainObject)(attrs.textWrap);
        },
        set: function(text, refBBox, node, attrs) {
            var $node = (0, _jqueryDefault.default)(node);
            var cacheName = "joint-text";
            var cache = $node.data(cacheName);
            var textAttrs = (0, _utilMjs.pick)(attrs, "lineHeight", "annotations", "textPath", "x", "textVerticalAnchor", "eol", "displayEmpty");
            // eval `x` if using calc()
            const { x } = textAttrs;
            if ((0, _calcMjs.isCalcAttribute)(x)) textAttrs.x = (0, _calcMjs.evalCalcAttribute)(x, refBBox);
            let fontSizeAttr = attrs["font-size"] || attrs["fontSize"];
            if ((0, _calcMjs.isCalcAttribute)(fontSizeAttr)) fontSizeAttr = (0, _calcMjs.evalCalcAttribute)(fontSizeAttr, refBBox);
            var fontSize = textAttrs.fontSize = fontSizeAttr;
            var textHash = JSON.stringify([
                text,
                textAttrs
            ]);
            // Update the text only if there was a change in the string
            // or any of its attributes.
            if (cache === undefined || cache !== textHash) {
                // Chrome bug:
                // Tspans positions defined as `em` are not updated
                // when container `font-size` change.
                if (fontSize) node.setAttribute("font-size", fontSize);
                // Text Along Path Selector
                var textPath = textAttrs.textPath;
                if ((0, _utilMjs.isObject)(textPath)) {
                    var pathSelector = textPath.selector;
                    if (typeof pathSelector === "string") {
                        var pathNode = this.findBySelector(pathSelector)[0];
                        if (pathNode instanceof SVGPathElement) textAttrs.textPath = (0, _utilMjs.assign)({
                            "xlink:href": "#" + pathNode.id
                        }, textPath);
                    }
                }
                (0, _indexMjsDefault.default)(node).text("" + text, textAttrs);
                $node.data(cacheName, textHash);
            }
        }
    },
    textWrap: {
        qualify: (0, _utilMjs.isPlainObject),
        set: function(value, refBBox, node, attrs) {
            var size = {};
            // option `width`
            var width = value.width || 0;
            if ((0, _utilMjs.isPercentage)(width)) size.width = refBBox.width * parseFloat(width) / 100;
            else if ((0, _calcMjs.isCalcAttribute)(width)) size.width = Number((0, _calcMjs.evalCalcAttribute)(width, refBBox));
            else {
                if (value.width === null) // breakText() requires width to be specified.
                size.width = Infinity;
                else if (width <= 0) size.width = refBBox.width + width;
                else size.width = width;
            }
            // option `height`
            var height = value.height || 0;
            if ((0, _utilMjs.isPercentage)(height)) size.height = refBBox.height * parseFloat(height) / 100;
            else if ((0, _calcMjs.isCalcAttribute)(height)) size.height = Number((0, _calcMjs.evalCalcAttribute)(height, refBBox));
            else {
                if (value.height === null) ;
                else if (height <= 0) size.height = refBBox.height + height;
                else size.height = height;
            }
            // option `text`
            var wrappedText;
            var text = value.text;
            if (text === undefined) text = attrs.text;
            if (text !== undefined) {
                const breakTextFn = value.breakText || (0, _utilMjs.breakText);
                const fontSizeAttr = attrs["font-size"] || attrs.fontSize;
                wrappedText = breakTextFn("" + text, size, {
                    "font-weight": attrs["font-weight"] || attrs.fontWeight,
                    "font-size": (0, _calcMjs.isCalcAttribute)(fontSizeAttr) ? (0, _calcMjs.evalCalcAttribute)(fontSizeAttr, refBBox) : fontSizeAttr,
                    "font-family": attrs["font-family"] || attrs.fontFamily,
                    "lineHeight": attrs.lineHeight,
                    "letter-spacing": "letter-spacing" in attrs ? attrs["letter-spacing"] : attrs.letterSpacing
                }, {
                    // Provide an existing SVG Document here
                    // instead of creating a temporary one over again.
                    svgDocument: this.paper.svg,
                    ellipsis: value.ellipsis,
                    hyphen: value.hyphen,
                    maxLineCount: value.maxLineCount,
                    preserveSpaces: value.preserveSpaces
                });
            } else wrappedText = "";
            attributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);
        }
    },
    title: {
        qualify: function(title, node) {
            // HTMLElement title is specified via an attribute (i.e. not an element)
            return node instanceof SVGElement;
        },
        set: function(title, refBBox, node) {
            var $node = (0, _jqueryDefault.default)(node);
            var cacheName = "joint-title";
            var cache = $node.data(cacheName);
            if (cache === undefined || cache !== title) {
                $node.data(cacheName, title);
                if (node.tagName === "title") {
                    // The target node is a <title> element.
                    node.textContent = title;
                    return;
                }
                // Generally <title> element should be the first child element of its parent.
                var firstChild = node.firstElementChild;
                if (firstChild && firstChild.tagName === "title") // Update an existing title
                firstChild.textContent = title;
                else {
                    // Create a new title
                    var titleNode = document.createElementNS(node.namespaceURI, "title");
                    titleNode.textContent = title;
                    node.insertBefore(titleNode, firstChild);
                }
            }
        }
    },
    lineHeight: {
        qualify: isTextInUse
    },
    textVerticalAnchor: {
        qualify: isTextInUse
    },
    textPath: {
        qualify: isTextInUse
    },
    annotations: {
        qualify: isTextInUse
    },
    eol: {
        qualify: isTextInUse
    },
    displayEmpty: {
        qualify: isTextInUse
    },
    // `port` attribute contains the `id` of the port that the underlying magnet represents.
    port: {
        set: function(port) {
            return port === null || port.id === undefined ? port : port.id;
        }
    },
    // `style` attribute is special in the sense that it sets the CSS style of the subelement.
    style: {
        qualify: (0, _utilMjs.isPlainObject),
        set: function(styles, refBBox, node) {
            (0, _jqueryDefault.default)(node).css(styles);
        }
    },
    html: {
        set: function(html, refBBox, node) {
            (0, _jqueryDefault.default)(node).html(html + "");
        }
    },
    props: // Properties setter (set various properties on the node)
    (0, _propsMjsDefault.default),
    ref: {
    },
    // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width
    // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box
    // otherwise, `refX` is the left coordinate of the bounding box
    refX: {
        position: positionWrapper("x", "width", "origin")
    },
    refY: {
        position: positionWrapper("y", "height", "origin")
    },
    // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom
    // coordinate of the reference element.
    refDx: {
        position: positionWrapper("x", "width", "corner")
    },
    refDy: {
        position: positionWrapper("y", "height", "corner")
    },
    // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to
    // the reference element size
    // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width
    // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20
    refWidth: {
        set: setWrapper("width", "width")
    },
    refHeight: {
        set: setWrapper("height", "height")
    },
    refRx: {
        set: setWrapper("rx", "width")
    },
    refRy: {
        set: setWrapper("ry", "height")
    },
    refRInscribed: {
        set: function(attrName) {
            var widthFn = setWrapper(attrName, "width");
            var heightFn = setWrapper(attrName, "height");
            return function(value, refBBox) {
                var fn = refBBox.height > refBBox.width ? widthFn : heightFn;
                return fn(value, refBBox);
            };
        }("r")
    },
    refRCircumscribed: {
        set: function(value, refBBox) {
            var isValuePercentage = (0, _utilMjs.isPercentage)(value);
            value = parseFloat(value);
            if (isValuePercentage) value /= 100;
            var diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);
            var rValue;
            if (isFinite(value)) {
                if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;
                else rValue = Math.max(value + diagonalLength, 0);
            }
            return {
                r: rValue
            };
        }
    },
    refCx: {
        set: setWrapper("cx", "width")
    },
    refCy: {
        set: setWrapper("cy", "height")
    },
    // `x-alignment` when set to `middle` causes centering of the subelement around its new x coordinate.
    // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.
    xAlignment: {
        offset: offsetWrapper("x", "width", "right")
    },
    // `y-alignment` when set to `middle` causes centering of the subelement around its new y coordinate.
    // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.
    yAlignment: {
        offset: offsetWrapper("y", "height", "bottom")
    },
    resetOffset: {
        offset: function(val, nodeBBox) {
            return val ? {
                x: -nodeBBox.x,
                y: -nodeBBox.y
            } : {
                x: 0,
                y: 0
            };
        }
    },
    refDResetOffset: {
        set: dWrapper({
            resetOffset: true
        })
    },
    refDKeepOffset: {
        set: dWrapper({
            resetOffset: false
        })
    },
    refPointsResetOffset: {
        set: pointsWrapper({
            resetOffset: true
        })
    },
    refPointsKeepOffset: {
        set: pointsWrapper({
            resetOffset: false
        })
    },
    // LinkView Attributes
    connection: {
        qualify: isLinkView,
        set: function({ stubs = 0 }) {
            let d;
            if (isFinite(stubs) && stubs !== 0) {
                let offset;
                if (stubs < 0) offset = (this.getConnectionLength() + stubs) / 2;
                else offset = stubs;
                const path = this.getConnection();
                const segmentSubdivisions = this.getConnectionSubdivisions();
                const sourceParts = path.divideAtLength(offset, {
                    segmentSubdivisions
                });
                const targetParts = path.divideAtLength(-offset, {
                    segmentSubdivisions
                });
                if (sourceParts && targetParts) d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;
            }
            return {
                d: d || this.getSerializedConnection()
            };
        }
    },
    atConnectionLengthKeepGradient: {
        qualify: isLinkView,
        set: atConnectionWrapper("getTangentAtLength", {
            rotate: true
        })
    },
    atConnectionLengthIgnoreGradient: {
        qualify: isLinkView,
        set: atConnectionWrapper("getTangentAtLength", {
            rotate: false
        })
    },
    atConnectionRatioKeepGradient: {
        qualify: isLinkView,
        set: atConnectionWrapper("getTangentAtRatio", {
            rotate: true
        })
    },
    atConnectionRatioIgnoreGradient: {
        qualify: isLinkView,
        set: atConnectionWrapper("getTangentAtRatio", {
            rotate: false
        })
    }
};
attributesNS["xlink:href"] = attributesNS.xlinkHref;
// Support `calc()` with the following SVG attributes
[
    "transform",
    "d",
    "points",
    "cx",
    "cy",
    "x1",
    "x2",
    "y1",
    "y2",
    "x",
    "y",
    "dx",
    "dy" // text
].forEach((attribute)=>{
    attributesNS[attribute] = {
        qualify: (0, _calcMjs.isCalcAttribute),
        set: function setCalcAttribute(value, refBBox) {
            return {
                [attribute]: (0, _calcMjs.evalCalcAttribute)(value, refBBox)
            };
        }
    };
});
// Prevent "A negative value is not valid" error.
[
    "width",
    "height",
    "r",
    "rx",
    "ry",
    "font-size",
    "stroke-width" // elements
].forEach((attribute)=>{
    attributesNS[attribute] = {
        qualify: (0, _calcMjs.isCalcAttribute),
        set: function setCalcAttribute(value, refBBox) {
            return {
                [attribute]: Math.max(0, (0, _calcMjs.evalCalcAttribute)(value, refBBox))
            };
        }
    };
});
// Aliases
attributesNS.refR = attributesNS.refRInscribed;
attributesNS.refD = attributesNS.refDResetOffset;
attributesNS.refPoints = attributesNS.refPointsResetOffset;
attributesNS.atConnectionLength = attributesNS.atConnectionLengthKeepGradient;
attributesNS.atConnectionRatio = attributesNS.atConnectionRatioKeepGradient;
attributesNS.fontSize = attributesNS["font-size"];
attributesNS.strokeWidth = attributesNS["stroke-width"];
// This allows to combine both absolute and relative positioning
// refX: 50%, refX2: 20
attributesNS.refX2 = attributesNS.refX;
attributesNS.refY2 = attributesNS.refY;
attributesNS.refWidth2 = attributesNS.refWidth;
attributesNS.refHeight2 = attributesNS.refHeight;
// Aliases for backwards compatibility
attributesNS["ref-x"] = attributesNS.refX;
attributesNS["ref-y"] = attributesNS.refY;
attributesNS["ref-dy"] = attributesNS.refDy;
attributesNS["ref-dx"] = attributesNS.refDx;
attributesNS["ref-width"] = attributesNS.refWidth;
attributesNS["ref-height"] = attributesNS.refHeight;
attributesNS["x-alignment"] = attributesNS.xAlignment;
attributesNS["y-alignment"] = attributesNS.yAlignment;
const attributes = attributesNS;

},{"../../g/index.mjs":"i91Db","../../util/util.mjs":"5j2Qt","./calc.mjs":"azta0","./props.mjs":"ha4jU","jquery":"7jr44","../../V/index.mjs":"iw8UN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"azta0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "evalCalcExpression", ()=>evalCalcExpression);
parcelHelpers.export(exports, "isCalcAttribute", ()=>isCalcAttribute);
parcelHelpers.export(exports, "evalCalcAttribute", ()=>evalCalcAttribute);
const props = {
    x: "x",
    y: "y",
    width: "w",
    height: "h",
    minimum: "s",
    maximum: "l",
    diagonal: "d"
};
const propsList = Object.keys(props).map((key)=>props[key]).join("");
const numberPattern = "[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?";
const findSpacesRegex = /\s/g;
const parseExpressionRegExp = new RegExp(`^(${numberPattern}\\*)?([${propsList}])(/${numberPattern})?([-+]{1,2}${numberPattern})?$`, "g");
function throwInvalid(expression) {
    throw new Error(`Invalid calc() expression: ${expression}`);
}
function evalCalcExpression(expression, bbox) {
    const match = parseExpressionRegExp.exec(expression.replace(findSpacesRegex, ""));
    if (!match) throwInvalid(expression);
    parseExpressionRegExp.lastIndex = 0; // reset regex results for the next run
    const [, multiply, property, divide, add] = match;
    const { x, y, width, height } = bbox;
    let value = 0;
    switch(property){
        case props.width:
            value = width;
            break;
        case props.height:
            value = height;
            break;
        case props.x:
            value = x;
            break;
        case props.y:
            value = y;
            break;
        case props.minimum:
            value = Math.min(height, width);
            break;
        case props.maximum:
            value = Math.max(height, width);
            break;
        case props.diagonal:
            value = Math.sqrt(height * height + width * width);
            break;
    }
    if (multiply) // e.g "2*"
    value *= parseFloat(multiply);
    if (divide) // e.g "/2"
    value /= parseFloat(divide.slice(1));
    if (add) value += evalAddExpression(add);
    return value;
}
function evalAddExpression(addExpression) {
    if (!addExpression) return 0;
    const [sign] = addExpression;
    switch(sign){
        case "+":
            return parseFloat(addExpression.substr(1));
        case "-":
            return -parseFloat(addExpression.substr(1));
    }
    return parseFloat(addExpression);
}
function isCalcAttribute(value) {
    return typeof value === "string" && value.includes("calc");
}
const calcStart = "calc(";
const calcStartOffset = calcStart.length;
function evalCalcAttribute(attributeValue, refBBox) {
    let value = attributeValue;
    let startSearchIndex = 0;
    do {
        let calcIndex = value.indexOf(calcStart, startSearchIndex);
        if (calcIndex === -1) return value;
        let calcEndIndex = calcIndex + calcStartOffset;
        let brackets = 1;
        findClosingBracket: do {
            switch(value[calcEndIndex]){
                case "(":
                    brackets++;
                    break;
                case ")":
                    brackets--;
                    if (brackets === 0) break findClosingBracket;
                    break;
                case undefined:
                    // Could not find the closing bracket.
                    throwInvalid(value);
            }
            calcEndIndex++;
        }while (true);
        // Get the calc() expression without nested calcs (recursion)
        let expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);
        if (isCalcAttribute(expression)) expression = evalCalcAttribute(expression, refBBox);
        // Eval the calc() expression without nested calcs.
        const calcValue = String(evalCalcExpression(expression, refBBox));
        // Replace the calc() expression and continue search
        value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);
        startSearchIndex = calcIndex + calcValue.length;
    }while (true);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ha4jU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilMjs = require("../../util/util.mjs");
const validPropertiesList = [
    "checked",
    "selected",
    "disabled",
    "readOnly",
    "contentEditable",
    "value",
    "indeterminate"
];
const validProperties = validPropertiesList.reduce((acc, key)=>{
    acc[key] = true;
    return acc;
}, {});
const props = {
    qualify: function(properties) {
        return (0, _utilMjs.isPlainObject)(properties);
    },
    set: function(properties, _, node) {
        Object.keys(properties).forEach(function(key) {
            if (validProperties[key] && key in node) {
                const value = properties[key];
                if (node.tagName === "SELECT" && Array.isArray(value)) Array.from(node.options).forEach(function(option, index) {
                    option.selected = value.includes(option.value);
                });
                else node[key] = value;
            }
        });
    }
};
exports.default = props;

},{"../../util/util.mjs":"5j2Qt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eL7pI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getRectPoint", ()=>(0, _getRectPointMjs.getRectPoint));
var _wrappersMjs = require("./wrappers.mjs");
parcelHelpers.exportAll(_wrappersMjs, exports);
var _utilMjs = require("./util.mjs");
parcelHelpers.exportAll(_utilMjs, exports);
var _cloneCellsMjs = require("./cloneCells.mjs");
parcelHelpers.exportAll(_cloneCellsMjs, exports);
var _svgTagTemplateMjs = require("./svgTagTemplate.mjs");
parcelHelpers.exportAll(_svgTagTemplateMjs, exports);
var _getRectPointMjs = require("./getRectPoint.mjs");

},{"./wrappers.mjs":"2cXQb","./util.mjs":"5j2Qt","./cloneCells.mjs":"5qBbR","./svgTagTemplate.mjs":"9vXcT","./getRectPoint.mjs":"fsMP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2cXQb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "wrapWith", ()=>wrapWith);
parcelHelpers.export(exports, "wrappers", ()=>wrappers);
var _cellMjs = require("../dia/Cell.mjs");
var _utilMjs = require("./util.mjs");
const wrapWith = function(object, methods, wrapper) {
    if ((0, _utilMjs.isString)(wrapper)) {
        if (!wrappers[wrapper]) throw new Error('Unknown wrapper: "' + wrapper + '"');
        wrapper = wrappers[wrapper];
    }
    if (!(0, _utilMjs.isFunction)(wrapper)) throw new Error("Wrapper must be a function.");
    (0, _utilMjs.toArray)(methods).forEach(function(method) {
        object[method] = wrapper(object[method]);
    });
};
const wrappers = {
    cells: function(fn) {
        return function() {
            var args = Array.from(arguments);
            var n = args.length;
            var cells = n > 0 && args[0] || [];
            var opt = n > 1 && args[n - 1] || {};
            if (!Array.isArray(cells)) {
                if (opt instanceof (0, _cellMjs.Cell)) cells = args;
                else if (cells instanceof (0, _cellMjs.Cell)) {
                    if (args.length > 1) args.pop();
                    cells = args;
                }
            }
            if (opt instanceof (0, _cellMjs.Cell)) opt = {};
            return fn.call(this, cells, opt);
        };
    }
};

},{"../dia/Cell.mjs":"vHapP","./util.mjs":"5j2Qt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9vXcT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "svg", ()=>svg);
var _indexMjs = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
function svg(strings, ...expressions) {
    const svgParts = [];
    strings.forEach((part, index)=>{
        svgParts.push(part);
        if (index in expressions) svgParts.push(expressions[index]);
    });
    const markup = parseFromSVGString(svgParts.join(""));
    return markup;
}
function parseFromSVGString(str) {
    const parser = new DOMParser();
    const markupString = `<svg>${str.trim()}</svg>`;
    const xmldocument = parser.parseFromString(markupString.replace(/@/g, ""), "application/xml");
    if (xmldocument.getElementsByTagName("parsererror")[0]) throw new Error("Invalid SVG markup");
    const document = parser.parseFromString(markupString, "text/html");
    const svg = document.querySelector("svg");
    return build(svg);
}
function buildNode(node) {
    const markupNode = {};
    const { tagName, attributes, namespaceURI, style, childNodes } = node;
    markupNode.namespaceURI = namespaceURI;
    markupNode.tagName = namespaceURI === (0, _indexMjsDefault.default).namespace.xhtml ? tagName.toLowerCase() : tagName;
    const stylesObject = {};
    for(var i = style.length; i--;){
        var nameString = style[i];
        stylesObject[nameString] = style.getPropertyValue(nameString);
    }
    markupNode.style = stylesObject;
    // selector fallbacks to tagName
    const selectorAttribute = attributes.getNamedItem("@selector");
    if (selectorAttribute) {
        markupNode.selector = selectorAttribute.value;
        attributes.removeNamedItem("@selector");
    }
    const groupSelectorAttribute = attributes.getNamedItem("@group-selector");
    if (groupSelectorAttribute) {
        const groupSelectors = groupSelectorAttribute.value.split(",");
        markupNode.groupSelector = groupSelectors.map((s)=>s.trim());
        attributes.removeNamedItem("@group-selector");
    }
    const className = attributes.getNamedItem("class");
    if (className) markupNode.className = className.value;
    const children = [];
    childNodes.forEach((node)=>{
        switch(node.nodeType){
            case Node.TEXT_NODE:
                {
                    const trimmedText = node.data.replace(/\s\s+/g, " ");
                    if (trimmedText.trim()) children.push(trimmedText);
                    break;
                }
            case Node.ELEMENT_NODE:
                children.push(buildNode(node));
                break;
            default:
                break;
        }
    });
    if (children.length) markupNode.children = children;
    const nodeAttrs = {};
    Array.from(attributes).forEach((nodeAttribute)=>{
        const { name, value } = nodeAttribute;
        nodeAttrs[name] = value;
    });
    if (Object.keys(nodeAttrs).length > 0) markupNode.attributes = nodeAttrs;
    return markupNode;
}
function build(root) {
    const markup = [];
    Array.from(root.children).forEach((node)=>{
        markup.push(buildNode(node));
    });
    return markup;
}

},{"../V/index.mjs":"iw8UN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fsMP9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Positions", ()=>Positions);
parcelHelpers.export(exports, "getRectPoint", ()=>getRectPoint);
var _indexMjs = require("../g/index.mjs");
const Positions = {
    TOP: "top",
    RIGHT: "right",
    BOTTOM: "bottom",
    LEFT: "left",
    TOP_LEFT: "top-left",
    TOP_RIGHT: "top-right",
    BOTTOM_LEFT: "bottom-left",
    BOTTOM_RIGHT: "bottom-right",
    CENTER: "center"
};
function getRectPoint(rect, position) {
    const r = new _indexMjs.Rect(rect);
    switch(position){
        case undefined:
            throw new Error("Position required");
        // Middle Points
        case Positions.LEFT:
        case "leftMiddle":
            return r.leftMiddle();
        case Positions.RIGHT:
        case "rightMiddle":
            return r.rightMiddle();
        case Positions.TOP:
        case "topMiddle":
            return r.topMiddle();
        case Positions.BOTTOM:
        case "bottomMiddle":
            return r.bottomMiddle();
        // Corners
        case Positions.TOP_LEFT:
        case "topLeft":
        case "origin":
            return r.topLeft();
        case Positions.TOP_RIGHT:
        case "topRight":
            return r.topRight();
        case Positions.BOTTOM_LEFT:
        case "bottomLeft":
            return r.bottomLeft();
        case Positions.BOTTOM_RIGHT:
        case "bottomRight":
        case "corner":
            return r.bottomRight();
        // Center
        case Positions.CENTER:
            return r.center();
        // TODO: calc(), percentage etc.
        default:
            throw new Error(`Unknown position: ${position}`);
    }
}

},{"../g/index.mjs":"i91Db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Us97":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "elementPortPrototype", ()=>elementPortPrototype);
parcelHelpers.export(exports, "elementViewPortPrototype", ()=>elementViewPortPrototype);
var _indexMjs = require("../util/index.mjs");
var _indexMjs1 = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
var _indexMjs2 = require("../g/index.mjs");
var _portMjs = require("../layout/ports/port.mjs");
var _portLabelMjs = require("../layout/ports/portLabel.mjs");
var PortData = function(data) {
    var clonedData = _indexMjs.cloneDeep(data) || {};
    this.ports = [];
    this.groups = {};
    this.portLayoutNamespace = _portMjs;
    this.portLabelLayoutNamespace = _portLabelMjs;
    this._init(clonedData);
};
PortData.prototype = {
    getPorts: function() {
        return this.ports;
    },
    getGroup: function(name) {
        return this.groups[name] || {};
    },
    getPortsByGroup: function(groupName) {
        return this.ports.filter(function(port) {
            return port.group === groupName;
        });
    },
    getGroupPortsMetrics: function(groupName, elBBox) {
        var group = this.getGroup(groupName);
        var ports = this.getPortsByGroup(groupName);
        var groupPosition = group.position || {};
        var groupPositionName = groupPosition.name;
        var namespace = this.portLayoutNamespace;
        if (!namespace[groupPositionName]) groupPositionName = "left";
        var groupArgs = groupPosition.args || {};
        var portsArgs = ports.map(function(port) {
            return port && port.position && port.position.args;
        });
        var groupPortTransformations = namespace[groupPositionName](portsArgs, elBBox, groupArgs);
        var accumulator = {
            ports: ports,
            result: []
        };
        _indexMjs.toArray(groupPortTransformations).reduce((function(res, portTransformation, index) {
            var port = res.ports[index];
            res.result.push({
                portId: port.id,
                portTransformation: portTransformation,
                labelTransformation: this._getPortLabelLayout(port, (0, _indexMjs2.Point)(portTransformation), elBBox),
                portAttrs: port.attrs,
                portSize: port.size,
                labelSize: port.label.size
            });
            return res;
        }).bind(this), accumulator);
        return accumulator.result;
    },
    _getPortLabelLayout: function(port, portPosition, elBBox) {
        var namespace = this.portLabelLayoutNamespace;
        var labelPosition = port.label.position.name || "left";
        if (namespace[labelPosition]) return namespace[labelPosition](portPosition, elBBox, port.label.position.args);
        return null;
    },
    _init: function(data) {
        // prepare groups
        if (_indexMjs.isObject(data.groups)) {
            var groups = Object.keys(data.groups);
            for(var i = 0, n = groups.length; i < n; i++){
                var key = groups[i];
                this.groups[key] = this._evaluateGroup(data.groups[key]);
            }
        }
        // prepare ports
        var ports = _indexMjs.toArray(data.items);
        for(var j = 0, m = ports.length; j < m; j++)this.ports.push(this._evaluatePort(ports[j]));
    },
    _evaluateGroup: function(group) {
        return _indexMjs.merge(group, {
            position: this._getPosition(group.position, true),
            label: this._getLabel(group, true)
        });
    },
    _evaluatePort: function(port) {
        var evaluated = _indexMjs.assign({}, port);
        var group = this.getGroup(port.group);
        evaluated.markup = evaluated.markup || group.markup;
        evaluated.attrs = _indexMjs.merge({}, group.attrs, evaluated.attrs);
        evaluated.position = this._createPositionNode(group, evaluated);
        evaluated.label = _indexMjs.merge({}, group.label, this._getLabel(evaluated));
        evaluated.z = this._getZIndex(group, evaluated);
        evaluated.size = _indexMjs.assign({}, group.size, evaluated.size);
        return evaluated;
    },
    _getZIndex: function(group, port) {
        if (_indexMjs.isNumber(port.z)) return port.z;
        if (_indexMjs.isNumber(group.z) || group.z === "auto") return group.z;
        return "auto";
    },
    _createPositionNode: function(group, port) {
        return _indexMjs.merge({
            name: "left",
            args: {}
        }, group.position, {
            args: port.args
        });
    },
    _getPosition: function(position, setDefault) {
        var args = {};
        var positionName;
        if (_indexMjs.isFunction(position)) {
            positionName = "fn";
            args.fn = position;
        } else if (_indexMjs.isString(position)) positionName = position;
        else if (position === undefined) positionName = setDefault ? "left" : null;
        else if (Array.isArray(position)) {
            positionName = "absolute";
            args.x = position[0];
            args.y = position[1];
        } else if (_indexMjs.isObject(position)) {
            positionName = position.name;
            _indexMjs.assign(args, position.args);
        }
        var result = {
            args: args
        };
        if (positionName) result.name = positionName;
        return result;
    },
    _getLabel: function(item, setDefaults) {
        var label = item.label || {};
        var ret = label;
        ret.position = this._getPosition(label.position, setDefaults);
        return ret;
    }
};
const elementPortPrototype = {
    _initializePorts: function() {
        this._createPortData();
        this.on("change:ports", function() {
            this._processRemovedPort();
            this._createPortData();
        }, this);
    },
    /**
     * remove links tied wiht just removed element
     * @private
     */ _processRemovedPort: function() {
        var current = this.get("ports") || {};
        var currentItemsMap = {};
        _indexMjs.toArray(current.items).forEach(function(item) {
            currentItemsMap[item.id] = true;
        });
        var previous = this.previous("ports") || {};
        var removed = {};
        _indexMjs.toArray(previous.items).forEach(function(item) {
            if (!currentItemsMap[item.id]) removed[item.id] = true;
        });
        var graph = this.graph;
        if (graph && !_indexMjs.isEmpty(removed)) {
            var inboundLinks = graph.getConnectedLinks(this, {
                inbound: true
            });
            inboundLinks.forEach(function(link) {
                if (removed[link.get("target").port]) link.remove();
            });
            var outboundLinks = graph.getConnectedLinks(this, {
                outbound: true
            });
            outboundLinks.forEach(function(link) {
                if (removed[link.get("source").port]) link.remove();
            });
        }
    },
    /**
     * @returns {boolean}
     */ hasPorts: function() {
        var ports = this.prop("ports/items");
        return Array.isArray(ports) && ports.length > 0;
    },
    /**
     * @param {string} id
     * @returns {boolean}
     */ hasPort: function(id) {
        return this.getPortIndex(id) !== -1;
    },
    /**
     * @returns {Array<object>}
     */ getPorts: function() {
        return _indexMjs.cloneDeep(this.prop("ports/items")) || [];
    },
    /**
     * @returns {Array<object>}
     */ getGroupPorts: function(groupName) {
        const groupPorts = _indexMjs.toArray(this.prop([
            "ports",
            "items"
        ])).filter((port)=>port.group === groupName);
        return _indexMjs.cloneDeep(groupPorts);
    },
    /**
     * @param {string} id
     * @returns {object}
     */ getPort: function(id) {
        return _indexMjs.cloneDeep(_indexMjs.toArray(this.prop("ports/items")).find(function(port) {
            return port.id && port.id === id;
        }));
    },
    /**
     * @param {string} groupName
     * @returns {Object<portId, {x: number, y: number, angle: number}>}
     */ getPortsPositions: function(groupName) {
        var portsMetrics = this._portSettingsData.getGroupPortsMetrics(groupName, (0, _indexMjs2.Rect)(this.size()));
        return portsMetrics.reduce(function(positions, metrics) {
            var transformation = metrics.portTransformation;
            positions[metrics.portId] = {
                x: transformation.x,
                y: transformation.y,
                angle: transformation.angle
            };
            return positions;
        }, {});
    },
    /**
     * @param {string|Port} port port id or port
     * @returns {number} port index
     */ getPortIndex: function(port) {
        var id = _indexMjs.isObject(port) ? port.id : port;
        if (!this._isValidPortId(id)) return -1;
        return _indexMjs.toArray(this.prop("ports/items")).findIndex(function(item) {
            return item.id === id;
        });
    },
    /**
     * @param {object} port
     * @param {object} [opt]
     * @returns {joint.dia.Element}
     */ addPort: function(port, opt) {
        if (!_indexMjs.isObject(port) || Array.isArray(port)) throw new Error("Element: addPort requires an object.");
        var ports = _indexMjs.assign([], this.prop("ports/items"));
        ports.push(port);
        this.prop("ports/items", ports, opt);
        return this;
    },
    /**
     * @param {string|Port|number} before
     * @param {object} port
     * @param {object} [opt]
     * @returns {joint.dia.Element}
     */ insertPort: function(before, port, opt) {
        const index = typeof before === "number" ? before : this.getPortIndex(before);
        if (!_indexMjs.isObject(port) || Array.isArray(port)) throw new Error("dia.Element: insertPort requires an object.");
        const ports = _indexMjs.assign([], this.prop("ports/items"));
        ports.splice(index, 0, port);
        this.prop("ports/items", ports, opt);
        return this;
    },
    /**
     * @param {string} portId
     * @param {string|object=} path
     * @param {*=} value
     * @param {object=} opt
     * @returns {joint.dia.Element}
     */ portProp: function(portId, path, value, opt) {
        var index = this.getPortIndex(portId);
        if (index === -1) throw new Error("Element: unable to find port with id " + portId);
        var args = Array.prototype.slice.call(arguments, 1);
        if (Array.isArray(path)) args[0] = [
            "ports",
            "items",
            index
        ].concat(path);
        else if (_indexMjs.isString(path)) // Get/set an attribute by a special path syntax that delimits
        // nested objects by the colon character.
        args[0] = [
            "ports/items/",
            index,
            "/",
            path
        ].join("");
        else {
            args = [
                "ports/items/" + index
            ];
            if (_indexMjs.isPlainObject(path)) {
                args.push(path);
                args.push(value);
            }
        }
        return this.prop.apply(this, args);
    },
    _validatePorts: function() {
        var portsAttr = this.get("ports") || {};
        var errorMessages = [];
        portsAttr = portsAttr || {};
        var ports = _indexMjs.toArray(portsAttr.items);
        ports.forEach(function(p) {
            if (typeof p !== "object") errorMessages.push("Element: invalid port ", p);
            if (!this._isValidPortId(p.id)) p.id = this.generatePortId();
        }, this);
        if (_indexMjs.uniq(ports, "id").length !== ports.length) errorMessages.push("Element: found id duplicities in ports.");
        return errorMessages;
    },
    generatePortId: function() {
        return this.generateId();
    },
    /**
     * @param {string} id port id
     * @returns {boolean}
     * @private
     */ _isValidPortId: function(id) {
        return id !== null && id !== undefined && !_indexMjs.isObject(id);
    },
    addPorts: function(ports, opt) {
        if (ports.length) this.prop("ports/items", _indexMjs.assign([], this.prop("ports/items")).concat(ports), opt);
        return this;
    },
    removePort: function(port, opt) {
        const options = opt || {};
        const index = this.getPortIndex(port);
        if (index !== -1) {
            const ports = _indexMjs.assign([], this.prop([
                "ports",
                "items"
            ]));
            ports.splice(index, 1);
            options.rewrite = true;
            this.startBatch("port-remove");
            this.prop([
                "ports",
                "items"
            ], ports, options);
            this.stopBatch("port-remove");
        }
        return this;
    },
    removePorts: function(portsForRemoval, opt) {
        let options, newPorts;
        if (Array.isArray(portsForRemoval)) {
            options = opt || {};
            if (portsForRemoval.length === 0) return this.this;
            const currentPorts = _indexMjs.assign([], this.prop([
                "ports",
                "items"
            ]));
            newPorts = currentPorts.filter(function(cp) {
                return !portsForRemoval.some(function(rp) {
                    const rpId = _indexMjs.isObject(rp) ? rp.id : rp;
                    return cp.id === rpId;
                });
            });
        } else {
            options = portsForRemoval || {};
            newPorts = [];
        }
        this.startBatch("port-remove");
        options.rewrite = true;
        this.prop([
            "ports",
            "items"
        ], newPorts, options);
        this.stopBatch("port-remove");
        return this;
    },
    /**
     * @private
     */ _createPortData: function() {
        var err = this._validatePorts();
        if (err.length > 0) {
            this.set("ports", this.previous("ports"));
            throw new Error(err.join(" "));
        }
        var prevPortData;
        if (this._portSettingsData) prevPortData = this._portSettingsData.getPorts();
        this._portSettingsData = new PortData(this.get("ports"));
        var curPortData = this._portSettingsData.getPorts();
        if (prevPortData) {
            var added = curPortData.filter(function(item) {
                if (!prevPortData.find(function(prevPort) {
                    return prevPort.id === item.id;
                })) return item;
            });
            var removed = prevPortData.filter(function(item) {
                if (!curPortData.find(function(curPort) {
                    return curPort.id === item.id;
                })) return item;
            });
            if (removed.length > 0) this.trigger("ports:remove", this, removed);
            if (added.length > 0) this.trigger("ports:add", this, added);
        }
    }
};
const elementViewPortPrototype = {
    portContainerMarkup: "g",
    portMarkup: [
        {
            tagName: "circle",
            selector: "circle",
            attributes: {
                "r": 10,
                "fill": "#FFFFFF",
                "stroke": "#000000"
            }
        }
    ],
    portLabelMarkup: [
        {
            tagName: "text",
            selector: "text",
            attributes: {
                "fill": "#000000"
            }
        }
    ],
    /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */ _portElementsCache: null,
    /**
     * @private
     */ _initializePorts: function() {
        this._cleanPortsCache();
    },
    /**
     * @typedef {Object} Port
     *
     * @property {string} id
     * @property {Object} position
     * @property {Object} label
     * @property {Object} attrs
     * @property {string} markup
     * @property {string} group
     */ /**
     * @private
     */ _refreshPorts: function() {
        this._removePorts();
        this._cleanPortsCache();
        this._renderPorts();
    },
    _cleanPortsCache: function() {
        this._portElementsCache = {};
    },
    /**
     * @private
     */ _renderPorts: function() {
        // references to rendered elements without z-index
        var elementReferences = [];
        var elem = this._getContainerElement();
        for(var i = 0, count = elem.node.childNodes.length; i < count; i++)elementReferences.push(elem.node.childNodes[i]);
        var portsGropsByZ = _indexMjs.groupBy(this.model._portSettingsData.getPorts(), "z");
        var withoutZKey = "auto";
        // render non-z first
        _indexMjs.toArray(portsGropsByZ[withoutZKey]).forEach(function(port) {
            var portElement = this._getPortElement(port);
            elem.append(portElement);
            elementReferences.push(portElement);
        }, this);
        var groupNames = Object.keys(portsGropsByZ);
        for(var k = 0; k < groupNames.length; k++){
            var groupName = groupNames[k];
            if (groupName !== withoutZKey) {
                var z = parseInt(groupName, 10);
                this._appendPorts(portsGropsByZ[groupName], z, elementReferences);
            }
        }
        this._updatePorts();
    },
    /**
     * @returns {V}
     * @private
     */ _getContainerElement: function() {
        return this.rotatableNode || this.vel;
    },
    /**
     * @param {Array<Port>}ports
     * @param {number} z
     * @param refs
     * @private
     */ _appendPorts: function(ports, z, refs) {
        var containerElement = this._getContainerElement();
        var portElements = _indexMjs.toArray(ports).map(this._getPortElement, this);
        if (refs[z] || z < 0) (0, _indexMjsDefault.default)(refs[Math.max(z, 0)]).before(portElements);
        else containerElement.append(portElements);
    },
    /**
     * Try to get element from cache,
     * @param port
     * @returns {*}
     * @private
     */ _getPortElement: function(port) {
        if (this._portElementsCache[port.id]) return this._portElementsCache[port.id].portElement;
        return this._createPortElement(port);
    },
    findPortNode: function(portId, selector) {
        const portCache = this._portElementsCache[portId];
        if (!portCache) return null;
        if (!selector) return portCache.portContentElement.node;
        const portRoot = portCache.portElement.node;
        const portSelectors = portCache.portSelectors;
        const [node = null] = this.findBySelector(selector, portRoot, portSelectors);
        return node;
    },
    /**
     * @private
     */ _updatePorts: function() {
        // layout ports without group
        this._updatePortGroup(undefined);
        // layout ports with explicit group
        var groupsNames = Object.keys(this.model._portSettingsData.groups);
        groupsNames.forEach(this._updatePortGroup, this);
    },
    /**
     * @private
     */ _removePorts: function() {
        _indexMjs.invoke(this._portElementsCache, "portElement.remove");
    },
    /**
     * @param {Port} port
     * @returns {V}
     * @private
     */ _createPortElement: function(port) {
        let portElement;
        let labelElement;
        let labelSelectors;
        let portSelectors;
        var portContainerElement = (0, _indexMjsDefault.default)(this.portContainerMarkup).addClass("joint-port");
        var portMarkup = this._getPortMarkup(port);
        if (Array.isArray(portMarkup)) {
            var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);
            var portFragment = portDoc.fragment;
            if (portFragment.childNodes.length > 1) portElement = (0, _indexMjsDefault.default)("g").append(portFragment);
            else portElement = (0, _indexMjsDefault.default)(portFragment.firstChild);
            portSelectors = portDoc.selectors;
        } else {
            portElement = (0, _indexMjsDefault.default)(portMarkup);
            if (Array.isArray(portElement)) portElement = (0, _indexMjsDefault.default)("g").append(portElement);
        }
        if (!portElement) throw new Error("ElementView: Invalid port markup.");
        portElement.attr({
            "port": port.id,
            "port-group": port.group
        });
        const labelMarkupDef = this._getPortLabelMarkup(port.label);
        if (Array.isArray(labelMarkupDef)) {
            // JSON Markup
            const { fragment, selectors } = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);
            const childCount = fragment.childNodes.length;
            if (childCount > 0) {
                labelSelectors = selectors;
                labelElement = childCount === 1 ? (0, _indexMjsDefault.default)(fragment.firstChild) : (0, _indexMjsDefault.default)("g").append(fragment);
            }
        } else {
            // String Markup
            labelElement = (0, _indexMjsDefault.default)(labelMarkupDef);
            if (Array.isArray(labelElement)) labelElement = (0, _indexMjsDefault.default)("g").append(labelElement);
        }
        var portContainerSelectors;
        if (portSelectors && labelSelectors) {
            for(var key in labelSelectors){
                if (portSelectors[key] && key !== this.selector) throw new Error("ElementView: selectors within port must be unique.");
            }
            portContainerSelectors = _indexMjs.assign({}, portSelectors, labelSelectors);
        } else portContainerSelectors = portSelectors || labelSelectors || {};
        // The `portRootSelector` points to the root SVGNode of the port.
        // Either the implicit wrapping group <g/> in case the port consist of multiple SVGNodes.
        // Or the single SVGNode of the port.
        const portRootSelector = "portRoot";
        // The `labelRootSelector` points to the root SVGNode of the label.
        const labelRootSelector = "labelRoot";
        // The `labelTextSelector` points to all text SVGNodes of the label.
        const labelTextSelector = "labelText";
        if (!(portRootSelector in portContainerSelectors)) portContainerSelectors[portRootSelector] = portElement.node;
        if (labelElement) {
            const labelNode = labelElement.node;
            if (!(labelRootSelector in portContainerSelectors)) portContainerSelectors[labelRootSelector] = labelNode;
            if (!(labelTextSelector in portContainerSelectors)) {
                // If the label is a <text> element, we can use it directly.
                // Otherwise, we need to find the <text> element within the label.
                const labelTextNode = labelElement.tagName() === "TEXT" ? labelNode : Array.from(labelNode.querySelectorAll("text"));
                portContainerSelectors[labelTextSelector] = labelTextNode;
                if (!labelSelectors) labelSelectors = {};
                labelSelectors[labelTextSelector] = labelTextNode;
            }
        }
        portContainerElement.append(portElement.addClass("joint-port-body"));
        if (labelElement) portContainerElement.append(labelElement.addClass("joint-port-label"));
        this._portElementsCache[port.id] = {
            portElement: portContainerElement,
            portLabelElement: labelElement,
            portSelectors: portContainerSelectors,
            portLabelSelectors: labelSelectors,
            portContentElement: portElement,
            portContentSelectors: portSelectors
        };
        return portContainerElement;
    },
    /**
     * @param {string=} groupName
     * @private
     */ _updatePortGroup: function(groupName) {
        var elementBBox = (0, _indexMjs2.Rect)(this.model.size());
        var portsMetrics = this.model._portSettingsData.getGroupPortsMetrics(groupName, elementBBox);
        for(var i = 0, n = portsMetrics.length; i < n; i++){
            var metrics = portsMetrics[i];
            var portId = metrics.portId;
            var cached = this._portElementsCache[portId] || {};
            var portTransformation = metrics.portTransformation;
            var labelTransformation = metrics.labelTransformation;
            if (labelTransformation && cached.portLabelElement) {
                this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {
                    rootBBox: new (0, _indexMjs2.Rect)(metrics.labelSize),
                    selectors: cached.portLabelSelectors
                });
                this.applyPortTransform(cached.portLabelElement, labelTransformation, -portTransformation.angle || 0);
            }
            this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {
                rootBBox: new (0, _indexMjs2.Rect)(metrics.portSize),
                selectors: cached.portSelectors
            });
            this.applyPortTransform(cached.portElement, portTransformation);
        }
    },
    /**
     * @param {Vectorizer} element
     * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData
     * @param {number=} initialAngle
     * @constructor
     */ applyPortTransform: function(element, transformData, initialAngle) {
        var matrix = (0, _indexMjsDefault.default).createSVGMatrix().rotate(initialAngle || 0).translate(transformData.x || 0, transformData.y || 0).rotate(transformData.angle || 0);
        element.transform(matrix, {
            absolute: true
        });
    },
    /**
     * @param {Port} port
     * @returns {string}
     * @private
     */ _getPortMarkup: function(port) {
        return port.markup || this.model.get("portMarkup") || this.model.portMarkup || this.portMarkup;
    },
    /**
     * @param {Object} label
     * @returns {string}
     * @private
     */ _getPortLabelMarkup: function(label) {
        return label.markup || this.model.get("portLabelMarkup") || this.model.portLabelMarkup || this.portLabelMarkup;
    }
};

},{"../util/index.mjs":"eL7pI","../V/index.mjs":"iw8UN","../g/index.mjs":"i91Db","../layout/ports/port.mjs":"8tv5s","../layout/ports/portLabel.mjs":"lkFuH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8tv5s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "absolute", ()=>absolute);
parcelHelpers.export(exports, "fn", ()=>fn);
parcelHelpers.export(exports, "line", ()=>line);
parcelHelpers.export(exports, "left", ()=>left);
parcelHelpers.export(exports, "right", ()=>right);
parcelHelpers.export(exports, "top", ()=>top);
parcelHelpers.export(exports, "bottom", ()=>bottom);
parcelHelpers.export(exports, "ellipseSpread", ()=>ellipseSpread);
parcelHelpers.export(exports, "ellipse", ()=>ellipse);
var _calcMjs = require("../../dia/attributes/calc.mjs");
var _indexMjs = require("../../g/index.mjs");
var _indexMjs1 = require("../../util/index.mjs");
function portTransformAttrs(point, angle, opt) {
    var trans = point.toJSON();
    trans.angle = angle || 0;
    return _indexMjs1.defaults({}, opt, trans);
}
function lineLayout(ports, p1, p2, elBBox) {
    return ports.map(function(port, index, ports) {
        var p = this.pointAt((index + 0.5) / ports.length);
        // `dx`,`dy` per port offset option
        if (port.dx || port.dy) p.offset(port.dx || 0, port.dy || 0);
        return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));
    }, _indexMjs.line(p1, p2));
}
function ellipseLayout(ports, elBBox, startAngle, stepFn) {
    var center = elBBox.center();
    var ratio = elBBox.width / elBBox.height;
    var p1 = elBBox.topMiddle();
    var ellipse = _indexMjs.Ellipse.fromRect(elBBox);
    return ports.map(function(port, index, ports) {
        var angle = startAngle + stepFn(index, ports.length);
        var p2 = p1.clone().rotate(center, -angle).scale(ratio, 1, center);
        var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;
        // `dx`,`dy` per port offset option
        if (port.dx || port.dy) p2.offset(port.dx || 0, port.dy || 0);
        // `dr` delta radius option
        if (port.dr) p2.move(center, port.dr);
        return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));
    });
}
function argTransform(bbox, args) {
    let { x, y, angle } = args;
    if (_indexMjs1.isPercentage(x)) x = parseFloat(x) / 100 * bbox.width;
    else if ((0, _calcMjs.isCalcAttribute)(x)) x = Number((0, _calcMjs.evalCalcAttribute)(x, bbox));
    if (_indexMjs1.isPercentage(y)) y = parseFloat(y) / 100 * bbox.height;
    else if ((0, _calcMjs.isCalcAttribute)(y)) y = Number((0, _calcMjs.evalCalcAttribute)(y, bbox));
    return {
        x,
        y,
        angle
    };
}
// Creates a point stored in arguments
function argPoint(bbox, args) {
    const { x, y } = argTransform(bbox, args);
    return new _indexMjs.Point(x || 0, y || 0);
}
const absolute = function(ports, elBBox) {
    return ports.map((port)=>{
        const transformation = argPoint(elBBox, port).round().toJSON();
        transformation.angle = port.angle || 0;
        return transformation;
    });
};
const fn = function(ports, elBBox, opt) {
    return opt.fn(ports, elBBox, opt);
};
const line = function(ports, elBBox, opt) {
    var start = argPoint(elBBox, opt.start || elBBox.origin());
    var end = argPoint(elBBox, opt.end || elBBox.corner());
    return lineLayout(ports, start, end, elBBox);
};
const left = function(ports, elBBox, opt) {
    return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);
};
const right = function(ports, elBBox, opt) {
    return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);
};
const top = function(ports, elBBox, opt) {
    return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);
};
const bottom = function(ports, elBBox, opt) {
    return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);
};
const ellipseSpread = function(ports, elBBox, opt) {
    var startAngle = opt.startAngle || 0;
    var stepAngle = opt.step || 360 / ports.length;
    return ellipseLayout(ports, elBBox, startAngle, function(index) {
        return index * stepAngle;
    });
};
const ellipse = function(ports, elBBox, opt) {
    var startAngle = opt.startAngle || 0;
    var stepAngle = opt.step || 20;
    return ellipseLayout(ports, elBBox, startAngle, function(index, count) {
        return (index + 0.5 - count / 2) * stepAngle;
    });
};

},{"../../dia/attributes/calc.mjs":"azta0","../../g/index.mjs":"i91Db","../../util/index.mjs":"eL7pI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lkFuH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "manual", ()=>manual);
parcelHelpers.export(exports, "left", ()=>left);
parcelHelpers.export(exports, "right", ()=>right);
parcelHelpers.export(exports, "top", ()=>top);
parcelHelpers.export(exports, "bottom", ()=>bottom);
parcelHelpers.export(exports, "outsideOriented", ()=>outsideOriented);
parcelHelpers.export(exports, "outside", ()=>outside);
parcelHelpers.export(exports, "insideOriented", ()=>insideOriented);
parcelHelpers.export(exports, "inside", ()=>inside);
parcelHelpers.export(exports, "radial", ()=>radial);
parcelHelpers.export(exports, "radialOriented", ()=>radialOriented);
var _indexMjs = require("../../g/index.mjs");
var _indexMjs1 = require("../../util/index.mjs");
function labelAttributes(opt1, opt2) {
    // use value from `opt2` if it is missing in `opt1`
    // use value from this object if it is missing in `opt2` as well
    return _indexMjs1.defaultsDeep({}, opt1, opt2, {
        x: 0,
        y: 0,
        angle: 0,
        attrs: {}
    });
}
function getBBoxAngles(elBBox) {
    var center = elBBox.center();
    var tl = center.theta(elBBox.origin());
    var bl = center.theta(elBBox.bottomLeft());
    var br = center.theta(elBBox.corner());
    var tr = center.theta(elBBox.topRight());
    return [
        tl,
        tr,
        br,
        bl
    ];
}
function outsideLayout(portPosition, elBBox, autoOrient, opt) {
    opt = _indexMjs1.defaults({}, opt, {
        offset: 15
    });
    var angle = elBBox.center().theta(portPosition);
    var tx, ty, y, textAnchor;
    var offset = opt.offset;
    var orientAngle = 0;
    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);
    if (angle < bottomLeftAngle || angle > bottomRightAngle) {
        y = ".3em";
        tx = offset;
        ty = 0;
        textAnchor = "start";
    } else if (angle < topLeftAngle) {
        tx = 0;
        ty = -offset;
        if (autoOrient) {
            orientAngle = -90;
            textAnchor = "start";
            y = ".3em";
        } else {
            textAnchor = "middle";
            y = "0";
        }
    } else if (angle < topRightAngle) {
        y = ".3em";
        tx = -offset;
        ty = 0;
        textAnchor = "end";
    } else {
        tx = 0;
        ty = offset;
        if (autoOrient) {
            orientAngle = 90;
            textAnchor = "start";
            y = ".3em";
        } else {
            textAnchor = "middle";
            y = ".6em";
        }
    }
    var round = Math.round;
    return labelAttributes(opt, {
        x: round(tx),
        y: round(ty),
        angle: orientAngle,
        attrs: {
            labelText: {
                y,
                textAnchor
            }
        }
    });
}
function insideLayout(portPosition, elBBox, autoOrient, opt) {
    opt = _indexMjs1.defaults({}, opt, {
        offset: 15
    });
    var angle = elBBox.center().theta(portPosition);
    var tx, ty, y, textAnchor;
    var offset = opt.offset;
    var orientAngle = 0;
    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);
    if (angle < bottomLeftAngle || angle > bottomRightAngle) {
        y = ".3em";
        tx = -offset;
        ty = 0;
        textAnchor = "end";
    } else if (angle < topLeftAngle) {
        tx = 0;
        ty = offset;
        if (autoOrient) {
            orientAngle = 90;
            textAnchor = "start";
            y = ".3em";
        } else {
            textAnchor = "middle";
            y = ".6em";
        }
    } else if (angle < topRightAngle) {
        y = ".3em";
        tx = offset;
        ty = 0;
        textAnchor = "start";
    } else {
        tx = 0;
        ty = -offset;
        if (autoOrient) {
            orientAngle = -90;
            textAnchor = "start";
            y = ".3em";
        } else {
            textAnchor = "middle";
            y = "0";
        }
    }
    var round = Math.round;
    return labelAttributes(opt, {
        x: round(tx),
        y: round(ty),
        angle: orientAngle,
        attrs: {
            labelText: {
                y,
                textAnchor
            }
        }
    });
}
function radialLayout(portCenterOffset, autoOrient, opt) {
    opt = _indexMjs1.defaults({}, opt, {
        offset: 20
    });
    var origin = _indexMjs.point(0, 0);
    var angle = -portCenterOffset.theta(origin);
    var orientAngle = angle;
    var offset = portCenterOffset.clone().move(origin, opt.offset).difference(portCenterOffset).round();
    var y = ".3em";
    var textAnchor;
    if ((angle + 90) % 180 === 0) {
        textAnchor = autoOrient ? "end" : "middle";
        if (!autoOrient && angle === -270) y = "0em";
    } else if (angle > -270 && angle < -90) {
        textAnchor = "start";
        orientAngle = angle - 180;
    } else textAnchor = "end";
    var round = Math.round;
    return labelAttributes(opt, {
        x: round(offset.x),
        y: round(offset.y),
        angle: autoOrient ? orientAngle : 0,
        attrs: {
            labelText: {
                y,
                textAnchor
            }
        }
    });
}
const manual = function(_portPosition, _elBBox, opt) {
    return labelAttributes(opt);
};
const left = function(portPosition, elBBox, opt) {
    return labelAttributes(opt, {
        x: -15,
        attrs: {
            labelText: {
                y: ".3em",
                textAnchor: "end"
            }
        }
    });
};
const right = function(portPosition, elBBox, opt) {
    return labelAttributes(opt, {
        x: 15,
        attrs: {
            labelText: {
                y: ".3em",
                textAnchor: "start"
            }
        }
    });
};
const top = function(portPosition, elBBox, opt) {
    return labelAttributes(opt, {
        y: -15,
        attrs: {
            labelText: {
                y: "0",
                textAnchor: "middle"
            }
        }
    });
};
const bottom = function(portPosition, elBBox, opt) {
    return labelAttributes(opt, {
        y: 15,
        attrs: {
            labelText: {
                y: ".6em",
                textAnchor: "middle"
            }
        }
    });
};
const outsideOriented = function(portPosition, elBBox, opt) {
    return outsideLayout(portPosition, elBBox, true, opt);
};
const outside = function(portPosition, elBBox, opt) {
    return outsideLayout(portPosition, elBBox, false, opt);
};
const insideOriented = function(portPosition, elBBox, opt) {
    return insideLayout(portPosition, elBBox, true, opt);
};
const inside = function(portPosition, elBBox, opt) {
    return insideLayout(portPosition, elBBox, false, opt);
};
const radial = function(portPosition, elBBox, opt) {
    return radialLayout(portPosition.difference(elBBox.center()), false, opt);
};
const radialOriented = function(portPosition, elBBox, opt) {
    return radialLayout(portPosition.difference(elBBox.center()), true, opt);
};

},{"../../g/index.mjs":"i91Db","../../util/index.mjs":"eL7pI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dHPd6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ElementView", ()=>ElementView);
var _indexMjs = require("../config/index.mjs");
var _indexMjs1 = require("../util/index.mjs");
var _cellViewMjs = require("./CellView.mjs");
var _cellMjs = require("./Cell.mjs");
var _indexMjs2 = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs2);
var _portsMjs = require("./ports.mjs");
var _indexMjs3 = require("../g/index.mjs");
const Flags = {
    TOOLS: (0, _cellViewMjs.CellView).Flags.TOOLS,
    UPDATE: "UPDATE",
    TRANSLATE: "TRANSLATE",
    RESIZE: "RESIZE",
    PORTS: "PORTS",
    ROTATE: "ROTATE",
    RENDER: "RENDER"
};
const DragActions = {
    MOVE: "move",
    MAGNET: "magnet"
};
const ElementView = (0, _cellViewMjs.CellView).extend({
    /**
     * @abstract
     */ _removePorts: function() {
    // implemented in ports.js
    },
    /**
     *
     * @abstract
     */ _renderPorts: function() {
    // implemented in ports.js
    },
    className: function() {
        var classNames = (0, _cellViewMjs.CellView).prototype.className.apply(this).split(" ");
        classNames.push("element");
        return classNames.join(" ");
    },
    initialize: function() {
        (0, _cellViewMjs.CellView).prototype.initialize.apply(this, arguments);
        this._initializePorts();
    },
    presentationAttributes: {
        "attrs": [
            Flags.UPDATE
        ],
        "position": [
            Flags.TRANSLATE,
            Flags.TOOLS
        ],
        "size": [
            Flags.RESIZE,
            Flags.PORTS,
            Flags.TOOLS
        ],
        "angle": [
            Flags.ROTATE,
            Flags.TOOLS
        ],
        "markup": [
            Flags.RENDER
        ],
        "ports": [
            Flags.PORTS
        ]
    },
    initFlag: [
        Flags.RENDER
    ],
    UPDATE_PRIORITY: 0,
    confirmUpdate: function(flag, opt) {
        const { useCSSSelectors } = (0, _indexMjs.config);
        if (this.hasFlag(flag, Flags.PORTS)) {
            this._removePorts();
            this._cleanPortsCache();
        }
        let transformHighlighters = false;
        if (this.hasFlag(flag, Flags.RENDER)) {
            this.render();
            this.updateTools(opt);
            this.updateHighlighters(true);
            transformHighlighters = true;
            flag = this.removeFlag(flag, [
                Flags.RENDER,
                Flags.UPDATE,
                Flags.RESIZE,
                Flags.TRANSLATE,
                Flags.ROTATE,
                Flags.PORTS,
                Flags.TOOLS
            ]);
        } else {
            let updateHighlighters = false;
            // Skip this branch if render is required
            if (this.hasFlag(flag, Flags.RESIZE)) {
                this.resize(opt);
                updateHighlighters = true;
                // Resize method is calling `update()` internally
                flag = this.removeFlag(flag, [
                    Flags.RESIZE,
                    Flags.UPDATE
                ]);
                if (useCSSSelectors) // `resize()` rendered the ports when useCSSSelectors are enabled
                flag = this.removeFlag(flag, Flags.PORTS);
            }
            if (this.hasFlag(flag, Flags.UPDATE)) {
                this.update(this.model, null, opt);
                flag = this.removeFlag(flag, Flags.UPDATE);
                updateHighlighters = true;
                if (useCSSSelectors) // `update()` will render ports when useCSSSelectors are enabled
                flag = this.removeFlag(flag, Flags.PORTS);
            }
            if (this.hasFlag(flag, Flags.TRANSLATE)) {
                this.translate();
                flag = this.removeFlag(flag, Flags.TRANSLATE);
                transformHighlighters = true;
            }
            if (this.hasFlag(flag, Flags.ROTATE)) {
                this.rotate();
                flag = this.removeFlag(flag, Flags.ROTATE);
                transformHighlighters = true;
            }
            if (this.hasFlag(flag, Flags.PORTS)) {
                this._renderPorts();
                updateHighlighters = true;
                flag = this.removeFlag(flag, Flags.PORTS);
            }
            if (updateHighlighters) this.updateHighlighters(false);
        }
        if (transformHighlighters) this.transformHighlighters();
        if (this.hasFlag(flag, Flags.TOOLS)) {
            this.updateTools(opt);
            flag = this.removeFlag(flag, Flags.TOOLS);
        }
        return flag;
    },
    /**
     * @abstract
     */ _initializePorts: function() {},
    update: function(_, renderingOnlyAttrs) {
        this.cleanNodesCache();
        // When CSS selector strings are used, make sure no rule matches port nodes.
        const { useCSSSelectors } = (0, _indexMjs.config);
        if (useCSSSelectors) this._removePorts();
        var model = this.model;
        var modelAttrs = model.attr();
        this.updateDOMSubtreeAttributes(this.el, modelAttrs, {
            rootBBox: new (0, _indexMjs3.Rect)(model.size()),
            selectors: this.selectors,
            scalableNode: this.scalableNode,
            rotatableNode: this.rotatableNode,
            // Use rendering only attributes if they differs from the model attributes
            roAttributes: renderingOnlyAttrs === modelAttrs ? null : renderingOnlyAttrs
        });
        if (useCSSSelectors) this._renderPorts();
    },
    rotatableSelector: "rotatable",
    scalableSelector: "scalable",
    scalableNode: null,
    rotatableNode: null,
    // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the
    // default markup is not desirable.
    renderMarkup: function() {
        var element = this.model;
        var markup = element.get("markup") || element.markup;
        if (!markup) throw new Error("dia.ElementView: markup required");
        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);
        if (typeof markup === "string") return this.renderStringMarkup(markup);
        throw new Error("dia.ElementView: invalid markup");
    },
    renderJSONMarkup: function(markup) {
        var doc = this.parseDOMJSON(markup, this.el);
        var selectors = this.selectors = doc.selectors;
        this.rotatableNode = (0, _indexMjsDefault.default)(selectors[this.rotatableSelector]) || null;
        this.scalableNode = (0, _indexMjsDefault.default)(selectors[this.scalableSelector]) || null;
        // Fragment
        this.vel.append(doc.fragment);
    },
    renderStringMarkup: function(markup) {
        var vel = this.vel;
        vel.append((0, _indexMjsDefault.default)(markup));
        // Cache transformation groups
        this.rotatableNode = vel.findOne(".rotatable");
        this.scalableNode = vel.findOne(".scalable");
        var selectors = this.selectors = {};
        selectors[this.selector] = this.el;
    },
    render: function() {
        this.vel.empty();
        this.renderMarkup();
        if (this.scalableNode) // Double update is necessary for elements with the scalable group only
        // Note the resize() triggers the other `update`.
        this.update();
        this.resize();
        if (this.rotatableNode) {
            // Translate transformation is applied on `this.el` while the rotation transformation
            // on `this.rotatableNode`
            this.rotate();
            this.translate();
        } else this.updateTransformation();
        if (!(0, _indexMjs.config).useCSSSelectors) this._renderPorts();
        return this;
    },
    resize: function(opt) {
        if (this.scalableNode) return this.sgResize(opt);
        if (this.model.attributes.angle) this.rotate();
        this.update();
    },
    translate: function() {
        if (this.rotatableNode) return this.rgTranslate();
        this.updateTransformation();
    },
    rotate: function() {
        if (this.rotatableNode) {
            this.rgRotate();
            // It's necessary to call the update for the nodes outside
            // the rotatable group referencing nodes inside the group
            this.update();
            return;
        }
        this.updateTransformation();
    },
    updateTransformation: function() {
        var transformation = this.getTranslateString();
        var rotateString = this.getRotateString();
        if (rotateString) transformation += " " + rotateString;
        this.vel.attr("transform", transformation);
    },
    getTranslateString: function() {
        var position = this.model.attributes.position;
        return "translate(" + position.x + "," + position.y + ")";
    },
    getRotateString: function() {
        var attributes = this.model.attributes;
        var angle = attributes.angle;
        if (!angle) return null;
        var size = attributes.size;
        return "rotate(" + angle + "," + size.width / 2 + "," + size.height / 2 + ")";
    },
    // Rotatable & Scalable Group
    // always slower, kept mainly for backwards compatibility
    rgRotate: function() {
        this.rotatableNode.attr("transform", this.getRotateString());
    },
    rgTranslate: function() {
        this.vel.attr("transform", this.getTranslateString());
    },
    sgResize: function(opt) {
        var model = this.model;
        var angle = model.angle();
        var size = model.size();
        var scalable = this.scalableNode;
        // Getting scalable group's bbox.
        // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.
        // To work around the issue, we need to check whether there are any path elements inside the scalable group.
        var recursive = false;
        if (scalable.node.getElementsByTagName("path").length > 0) // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.
        // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.
        recursive = true;
        var scalableBBox = scalable.getBBox({
            recursive: recursive
        });
        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making
        // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.
        var sx = size.width / (scalableBBox.width || 1);
        var sy = size.height / (scalableBBox.height || 1);
        scalable.attr("transform", "scale(" + sx + "," + sy + ")");
        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`
        // Order of transformations is significant but we want to reconstruct the object always in the order:
        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,
        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the
        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation
        // around the center of the resized object (which is a different origin then the origin of the previous rotation)
        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.
        // Cancel the rotation but now around a different origin, which is the center of the scaled object.
        var rotatable = this.rotatableNode;
        var rotation = rotatable && rotatable.attr("transform");
        if (rotation) {
            rotatable.attr("transform", rotation + " rotate(" + -angle + "," + size.width / 2 + "," + size.height / 2 + ")");
            var rotatableBBox = scalable.getBBox({
                target: this.paper.cells
            });
            // Store new x, y and perform rotate() again against the new rotation origin.
            model.set("position", {
                x: rotatableBBox.x,
                y: rotatableBBox.y
            }, (0, _indexMjs1.assign)({
                updateHandled: true
            }, opt));
            this.translate();
            this.rotate();
        }
        // Update must always be called on non-rotated element. Otherwise, relative positioning
        // would work with wrong (rotated) bounding boxes.
        this.update();
    },
    // Embedding mode methods.
    // -----------------------
    prepareEmbedding: function(data = {}) {
        const element = data.model || this.model;
        const paper = data.paper || this.paper;
        const graph = paper.model;
        const initialZIndices = data.initialZIndices = {};
        const embeddedCells = element.getEmbeddedCells({
            deep: true
        });
        const connectedLinks = graph.getConnectedLinks(element, {
            deep: true,
            includeEnclosed: true
        });
        // Note: an embedded cell can be a connect link, but it's fine
        // to iterate over the cell twice.
        [
            element,
            ...embeddedCells,
            ...connectedLinks
        ].forEach((cell)=>initialZIndices[cell.id] = cell.attributes.z);
        element.startBatch("to-front");
        // Bring the model to the front with all his embeds.
        element.toFront({
            deep: true,
            ui: true
        });
        // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see
        // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.
        const maxZ = graph.getElements().reduce((max, cell)=>Math.max(max, cell.attributes.z || 0), 0);
        // Move to front also all the inbound and outbound links that are connected
        // to any of the element descendant. If we bring to front only embedded elements,
        // links connected to them would stay in the background.
        connectedLinks.forEach((link)=>{
            if (link.attributes.z <= maxZ) link.set("z", maxZ + 1, {
                ui: true
            });
        });
        element.stopBatch("to-front");
        // Before we start looking for suitable parent we remove the current one.
        const parentId = element.parent();
        if (parentId) {
            const parent = graph.getCell(parentId);
            parent.unembed(element, {
                ui: true
            });
            data.initialParentId = parentId;
        } else data.initialParentId = null;
    },
    processEmbedding: function(data = {}, evt, x, y) {
        const model = data.model || this.model;
        const paper = data.paper || this.paper;
        const graph = paper.model;
        const { findParentBy, frontParentOnly, validateEmbedding } = paper.options;
        let candidates;
        if ((0, _indexMjs1.isFunction)(findParentBy)) candidates = (0, _indexMjs1.toArray)(findParentBy.call(graph, this, evt, x, y));
        else if (findParentBy === "pointer") candidates = (0, _indexMjs1.toArray)(graph.findModelsFromPoint({
            x,
            y
        }));
        else candidates = graph.findModelsUnderElement(model, {
            searchBy: findParentBy
        });
        candidates = candidates.filter((el)=>{
            return el instanceof (0, _cellMjs.Cell) && model.id !== el.id && !el.isEmbeddedIn(model);
        });
        if (frontParentOnly) // pick the element with the highest `z` index
        candidates = candidates.slice(-1);
        let newCandidateView = null;
        const prevCandidateView = data.candidateEmbedView;
        // iterate over all candidates starting from the last one (has the highest z-index).
        for(let i = candidates.length - 1; i >= 0; i--){
            const candidate = candidates[i];
            if (prevCandidateView && prevCandidateView.model.id == candidate.id) {
                // candidate remains the same
                newCandidateView = prevCandidateView;
                break;
            } else {
                const view = candidate.findView(paper);
                if (!(0, _indexMjs1.isFunction)(validateEmbedding) || validateEmbedding.call(paper, this, view)) {
                    // flip to the new candidate
                    newCandidateView = view;
                    break;
                }
            }
        }
        if (newCandidateView && newCandidateView != prevCandidateView) {
            // A new candidate view found. Highlight the new one.
            this.clearEmbedding(data);
            data.candidateEmbedView = newCandidateView.highlight(newCandidateView.findProxyNode(null, "container"), {
                embedding: true
            });
        }
        if (!newCandidateView && prevCandidateView) // No candidate view found. Unhighlight the previous candidate.
        this.clearEmbedding(data);
    },
    clearEmbedding: function(data) {
        data || (data = {});
        var candidateView = data.candidateEmbedView;
        if (candidateView) {
            // No candidate view found. Unhighlight the previous candidate.
            candidateView.unhighlight(candidateView.findProxyNode(null, "container"), {
                embedding: true
            });
            data.candidateEmbedView = null;
        }
    },
    finalizeEmbedding: function(data = {}) {
        const candidateView = data.candidateEmbedView;
        const element = data.model || this.model;
        const paper = data.paper || this.paper;
        if (candidateView) {
            // We finished embedding. Candidate view is chosen to become the parent of the model.
            candidateView.model.embed(element, {
                ui: true
            });
            candidateView.unhighlight(candidateView.findProxyNode(null, "container"), {
                embedding: true
            });
            data.candidateEmbedView = null;
        } else {
            const { validateUnembedding } = paper.options;
            const { initialParentId } = data;
            // The element was originally embedded into another element.
            // The interaction would unembed the element. Let's validate
            // if the element can be unembedded.
            if (initialParentId && typeof validateUnembedding === "function" && !validateUnembedding.call(paper, this)) {
                this._disallowUnembed(data);
                return;
            }
        }
        paper.model.getConnectedLinks(element, {
            deep: true
        }).forEach((link)=>{
            link.reparent({
                ui: true
            });
        });
    },
    _disallowUnembed: function(data) {
        const { model, whenNotAllowed = "revert" } = data;
        const element = model || this.model;
        const paper = data.paper || this.paper;
        const graph = paper.model;
        switch(whenNotAllowed){
            case "remove":
                element.remove({
                    ui: true
                });
                break;
            case "revert":
                {
                    const { initialParentId, initialPosition, initialZIndices } = data;
                    // Revert the element's position (and the position of its embedded cells if any)
                    if (initialPosition) {
                        const { x, y } = initialPosition;
                        element.position(x, y, {
                            deep: true,
                            ui: true
                        });
                    }
                    // Revert all the z-indices changed during the embedding
                    if (initialZIndices) Object.keys(initialZIndices).forEach((id)=>{
                        const cell = graph.getCell(id);
                        if (cell) cell.set("z", initialZIndices[id], {
                            ui: true
                        });
                    });
                    // Revert the original parent
                    const parent = graph.getCell(initialParentId);
                    if (parent) parent.embed(element, {
                        ui: true
                    });
                    break;
                }
        }
    },
    getDelegatedView: function() {
        var view = this;
        var model = view.model;
        var paper = view.paper;
        while(view){
            if (model.isLink()) break;
            if (!model.isEmbedded() || view.can("stopDelegation")) return view;
            model = model.getParentCell();
            view = paper.findViewByModel(model);
        }
        return null;
    },
    findProxyNode: function(el, type) {
        el || (el = this.el);
        const nodeSelector = el.getAttribute(`${type}-selector`);
        if (nodeSelector) {
            const port = this.findAttribute("port", el);
            if (port) {
                const proxyPortNode = this.findPortNode(port, nodeSelector);
                if (proxyPortNode) return proxyPortNode;
            } else {
                const [proxyNode] = this.findBySelector(nodeSelector);
                if (proxyNode) return proxyNode;
            }
        }
        return el;
    },
    // Interaction. The controller part.
    // ---------------------------------
    notifyPointerdown (evt, x, y) {
        (0, _cellViewMjs.CellView).prototype.pointerdown.call(this, evt, x, y);
        this.notify("element:pointerdown", evt, x, y);
    },
    notifyPointermove (evt, x, y) {
        (0, _cellViewMjs.CellView).prototype.pointermove.call(this, evt, x, y);
        this.notify("element:pointermove", evt, x, y);
    },
    notifyPointerup (evt, x, y) {
        this.notify("element:pointerup", evt, x, y);
        (0, _cellViewMjs.CellView).prototype.pointerup.call(this, evt, x, y);
    },
    pointerdblclick: function(evt, x, y) {
        (0, _cellViewMjs.CellView).prototype.pointerdblclick.apply(this, arguments);
        this.notify("element:pointerdblclick", evt, x, y);
    },
    pointerclick: function(evt, x, y) {
        (0, _cellViewMjs.CellView).prototype.pointerclick.apply(this, arguments);
        this.notify("element:pointerclick", evt, x, y);
    },
    contextmenu: function(evt, x, y) {
        (0, _cellViewMjs.CellView).prototype.contextmenu.apply(this, arguments);
        this.notify("element:contextmenu", evt, x, y);
    },
    pointerdown: function(evt, x, y) {
        this.notifyPointerdown(evt, x, y);
        this.dragStart(evt, x, y);
    },
    pointermove: function(evt, x, y) {
        const data = this.eventData(evt);
        const { targetMagnet, action, delegatedView } = data;
        if (targetMagnet) this.magnetpointermove(evt, targetMagnet, x, y);
        switch(action){
            case DragActions.MAGNET:
                this.dragMagnet(evt, x, y);
                break;
            case DragActions.MOVE:
                (delegatedView || this).drag(evt, x, y);
            // eslint: no-fallthrough=false
            default:
                if (data.preventPointerEvents) break;
                this.notifyPointermove(evt, x, y);
                break;
        }
        // Make sure the element view data is passed along.
        // It could have been wiped out in the handlers above.
        this.eventData(evt, data);
    },
    pointerup: function(evt, x, y) {
        const data = this.eventData(evt);
        const { targetMagnet, action, delegatedView } = data;
        if (targetMagnet) this.magnetpointerup(evt, targetMagnet, x, y);
        switch(action){
            case DragActions.MAGNET:
                this.dragMagnetEnd(evt, x, y);
                break;
            case DragActions.MOVE:
                (delegatedView || this).dragEnd(evt, x, y);
            // eslint: no-fallthrough=false
            default:
                if (data.preventPointerEvents) break;
                this.notifyPointerup(evt, x, y);
        }
        if (targetMagnet) this.magnetpointerclick(evt, targetMagnet, x, y);
        this.checkMouseleave(evt);
    },
    mouseover: function(evt) {
        (0, _cellViewMjs.CellView).prototype.mouseover.apply(this, arguments);
        this.notify("element:mouseover", evt);
    },
    mouseout: function(evt) {
        (0, _cellViewMjs.CellView).prototype.mouseout.apply(this, arguments);
        this.notify("element:mouseout", evt);
    },
    mouseenter: function(evt) {
        (0, _cellViewMjs.CellView).prototype.mouseenter.apply(this, arguments);
        this.notify("element:mouseenter", evt);
    },
    mouseleave: function(evt) {
        (0, _cellViewMjs.CellView).prototype.mouseleave.apply(this, arguments);
        this.notify("element:mouseleave", evt);
    },
    mousewheel: function(evt, x, y, delta) {
        (0, _cellViewMjs.CellView).prototype.mousewheel.apply(this, arguments);
        this.notify("element:mousewheel", evt, x, y, delta);
    },
    onmagnet: function(evt, x, y) {
        const { currentTarget: targetMagnet } = evt;
        this.magnetpointerdown(evt, targetMagnet, x, y);
        this.eventData(evt, {
            targetMagnet
        });
        this.dragMagnetStart(evt, x, y);
    },
    magnetpointerdown: function(evt, magnet, x, y) {
        this.notify("element:magnet:pointerdown", evt, magnet, x, y);
    },
    magnetpointermove: function(evt, magnet, x, y) {
        this.notify("element:magnet:pointermove", evt, magnet, x, y);
    },
    magnetpointerup: function(evt, magnet, x, y) {
        this.notify("element:magnet:pointerup", evt, magnet, x, y);
    },
    magnetpointerdblclick: function(evt, magnet, x, y) {
        this.notify("element:magnet:pointerdblclick", evt, magnet, x, y);
    },
    magnetcontextmenu: function(evt, magnet, x, y) {
        this.notify("element:magnet:contextmenu", evt, magnet, x, y);
    },
    // Drag Start Handlers
    dragStart: function(evt, x, y) {
        if (this.isDefaultInteractionPrevented(evt)) return;
        var view = this.getDelegatedView();
        if (!view || !view.can("elementMove")) return;
        this.eventData(evt, {
            action: DragActions.MOVE,
            delegatedView: view
        });
        const position = view.model.position();
        view.eventData(evt, {
            initialPosition: position,
            pointerOffset: position.difference(x, y),
            restrictedArea: this.paper.getRestrictedArea(view, x, y)
        });
    },
    dragMagnetStart: function(evt, x, y) {
        const { paper } = this;
        const isPropagationAlreadyStopped = evt.isPropagationStopped();
        if (isPropagationAlreadyStopped) // Special case when the propagation was already stopped
        // on the `element:magnet:pointerdown` event.
        // Do not trigger any `element:pointer*` events
        // but still start the magnet dragging.
        this.eventData(evt, {
            preventPointerEvents: true
        });
        if (this.isDefaultInteractionPrevented(evt) || !this.can("addLinkFromMagnet")) // Stop the default action, which is to start dragging a link.
        return;
        const { targetMagnet = evt.currentTarget } = this.eventData(evt);
        evt.stopPropagation();
        // Invalid (Passive) magnet. Start dragging the element.
        if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {
            if (isPropagationAlreadyStopped) // Do not trigger `element:pointerdown` and start element dragging
            // if the propagation was stopped.
            this.dragStart(evt, x, y);
            else // We need to reset the action
            // to `MOVE` so that the element is dragged.
            this.pointerdown(evt, x, y);
            return;
        }
        // Valid magnet. Start dragging a link.
        if (paper.options.magnetThreshold <= 0) this.dragLinkStart(evt, targetMagnet, x, y);
        this.eventData(evt, {
            action: DragActions.MAGNET
        });
    },
    // Drag Handlers
    drag: function(evt, x, y) {
        var paper = this.paper;
        var grid = paper.options.gridSize;
        var element = this.model;
        var data = this.eventData(evt);
        var { pointerOffset, restrictedArea, embedding } = data;
        // Make sure the new element's position always snaps to the current grid
        var elX = (0, _indexMjs3.snapToGrid)(x + pointerOffset.x, grid);
        var elY = (0, _indexMjs3.snapToGrid)(y + pointerOffset.y, grid);
        element.position(elX, elY, {
            restrictedArea,
            deep: true,
            ui: true
        });
        if (paper.options.embeddingMode) {
            if (!embedding) {
                // Prepare the element for embedding only if the pointer moves.
                // We don't want to do unnecessary action with the element
                // if an user only clicks/dblclicks on it.
                this.prepareEmbedding(data);
                embedding = true;
            }
            this.processEmbedding(data, evt, x, y);
        }
        this.eventData(evt, {
            embedding
        });
    },
    dragMagnet: function(evt, x, y) {
        this.dragLink(evt, x, y);
    },
    // Drag End Handlers
    dragEnd: function(evt, x, y) {
        var data = this.eventData(evt);
        if (data.embedding) this.finalizeEmbedding(data);
    },
    dragMagnetEnd: function(evt, x, y) {
        this.dragLinkEnd(evt, x, y);
    },
    magnetpointerclick: function(evt, magnet, x, y) {
        var paper = this.paper;
        if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;
        this.notify("element:magnet:pointerclick", evt, magnet, x, y);
    }
}, {
    Flags: Flags
});
(0, _indexMjs1.assign)(ElementView.prototype, (0, _portsMjs.elementViewPortPrototype));

},{"../config/index.mjs":"7Vsch","../util/index.mjs":"eL7pI","./CellView.mjs":"5Rm2b","./Cell.mjs":"vHapP","../V/index.mjs":"iw8UN","./ports.mjs":"8Us97","../g/index.mjs":"i91Db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Rm2b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CellView", ()=>CellView);
var _indexMjs = require("../config/index.mjs");
var _indexMjs1 = require("../mvc/index.mjs");
var _indexMjs2 = require("../util/index.mjs");
var _indexMjs3 = require("../g/index.mjs");
var _indexMjs4 = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs4);
var _jquery = require("jquery");
var _jqueryDefault = parcelHelpers.interopDefault(_jquery);
var _highlighterViewMjs = require("./HighlighterView.mjs");
const HighlightingTypes = {
    DEFAULT: "default",
    EMBEDDING: "embedding",
    CONNECTING: "connecting",
    MAGNET_AVAILABILITY: "magnetAvailability",
    ELEMENT_AVAILABILITY: "elementAvailability"
};
const Flags = {
    TOOLS: "TOOLS"
};
const CellView = (0, _indexMjs1.View).extend({
    tagName: "g",
    svgElement: true,
    selector: "root",
    metrics: null,
    className: function() {
        var classNames = [
            "cell"
        ];
        var type = this.model.get("type");
        if (type) type.toLowerCase().split(".").forEach(function(value, index, list) {
            classNames.push("type-" + list.slice(0, index + 1).join("-"));
        });
        return classNames.join(" ");
    },
    _presentationAttributes: null,
    _flags: null,
    setFlags: function() {
        var flags = {};
        var attributes = {};
        var shift = 0;
        var i, n, label;
        var presentationAttributes = (0, _indexMjs2.result)(this, "presentationAttributes");
        for(var attribute in presentationAttributes){
            if (!presentationAttributes.hasOwnProperty(attribute)) continue;
            var labels = presentationAttributes[attribute];
            if (!Array.isArray(labels)) labels = [
                labels
            ];
            for(i = 0, n = labels.length; i < n; i++){
                label = labels[i];
                var flag = flags[label];
                if (!flag) flag = flags[label] = 1 << shift++;
                attributes[attribute] |= flag;
            }
        }
        var initFlag = (0, _indexMjs2.result)(this, "initFlag");
        if (!Array.isArray(initFlag)) initFlag = [
            initFlag
        ];
        for(i = 0, n = initFlag.length; i < n; i++){
            label = initFlag[i];
            if (!flags[label]) flags[label] = 1 << shift++;
        }
        // 26 - 30 are reserved for paper flags
        // 31+ overflows maximal number
        if (shift > 25) throw new Error("dia.CellView: Maximum number of flags exceeded.");
        this._flags = flags;
        this._presentationAttributes = attributes;
    },
    hasFlag: function(flag, label) {
        return flag & this.getFlag(label);
    },
    removeFlag: function(flag, label) {
        return flag ^ flag & this.getFlag(label);
    },
    getFlag: function(label) {
        var flags = this._flags;
        if (!flags) return 0;
        var flag = 0;
        if (Array.isArray(label)) for(var i = 0, n = label.length; i < n; i++)flag |= flags[label[i]];
        else flag |= flags[label];
        return flag;
    },
    attributes: function() {
        var cell = this.model;
        return {
            "model-id": cell.id,
            "data-type": cell.attributes.type
        };
    },
    constructor: function(options) {
        // Make sure a global unique id is assigned to this view. Store this id also to the properties object.
        // The global unique id makes sure that the same view can be rendered on e.g. different machines and
        // still be associated to the same object among all those clients. This is necessary for real-time
        // collaboration mechanism.
        options.id = options.id || (0, _indexMjs2.guid)(this);
        (0, _indexMjs1.View).call(this, options);
    },
    initialize: function() {
        this.setFlags();
        (0, _indexMjs1.View).prototype.initialize.apply(this, arguments);
        this.cleanNodesCache();
        // Store reference to this to the <g> DOM element so that the view is accessible through the DOM tree.
        this.$el.data("view", this);
        this.startListening();
    },
    startListening: function() {
        this.listenTo(this.model, "change", this.onAttributesChange);
    },
    onAttributesChange: function(model, opt) {
        var flag = model.getChangeFlag(this._presentationAttributes);
        if (opt.updateHandled || !flag) return;
        if (opt.dirty && this.hasFlag(flag, "UPDATE")) flag |= this.getFlag("RENDER");
        // TODO: tool changes does not need to be sync
        // Fix Segments tools
        if (opt.tool) opt.async = false;
        this.requestUpdate(flag, opt);
    },
    requestUpdate: function(flags, opt) {
        const { paper } = this;
        if (paper && flags > 0) paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);
    },
    parseDOMJSON: function(markup, root) {
        var doc = (0, _indexMjs2.parseDOMJSON)(markup);
        var selectors = doc.selectors;
        var groups = doc.groupSelectors;
        for(var group in groups){
            if (selectors[group]) throw new Error("dia.CellView: ambiguous group selector");
            selectors[group] = groups[group];
        }
        if (root) {
            var rootSelector = this.selector;
            if (selectors[rootSelector]) throw new Error("dia.CellView: ambiguous root selector.");
            selectors[rootSelector] = root;
        }
        return {
            fragment: doc.fragment,
            selectors: selectors
        };
    },
    // Return `true` if cell link is allowed to perform a certain UI `feature`.
    // Example: `can('vertexMove')`, `can('labelMove')`.
    can: function(feature) {
        var interactive = (0, _indexMjs2.isFunction)(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;
        return (0, _indexMjs2.isObject)(interactive) && interactive[feature] !== false || (0, _indexMjs2.isBoolean)(interactive) && interactive !== false;
    },
    findBySelector: function(selector, root, selectors) {
        root || (root = this.el);
        selectors || (selectors = this.selectors);
        // These are either descendants of `this.$el` of `this.$el` itself.
        // `.` is a special selector used to select the wrapping `<g>` element.
        if (!selector || selector === ".") return [
            root
        ];
        if (selectors) {
            var nodes = selectors[selector];
            if (nodes) {
                if (Array.isArray(nodes)) return nodes;
                return [
                    nodes
                ];
            }
        }
        // Maintaining backwards compatibility
        // e.g. `circle:first` would fail with querySelector() call
        if ((0, _indexMjs.config).useCSSSelectors) return (0, _jqueryDefault.default)(root).find(selector).toArray();
        return [];
    },
    notify: function(eventName) {
        if (this.paper) {
            var args = Array.prototype.slice.call(arguments, 1);
            // Trigger the event on both the element itself and also on the paper.
            this.trigger.apply(this, [
                eventName
            ].concat(args));
            // Paper event handlers receive the view object as the first argument.
            this.paper.trigger.apply(this.paper, [
                eventName,
                this
            ].concat(args));
        }
    },
    getBBox: function(opt) {
        var bbox;
        if (opt && opt.useModelGeometry) {
            var model = this.model;
            bbox = model.getBBox().bbox(model.angle());
        } else bbox = this.getNodeBBox(this.el);
        return this.paper.localToPaperRect(bbox);
    },
    getNodeBBox: function(magnet) {
        const rect = this.getNodeBoundingRect(magnet);
        const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));
        const magnetMatrix = this.getNodeMatrix(magnet);
        return (0, _indexMjsDefault.default).transformRect(rect, transformMatrix.multiply(magnetMatrix));
    },
    getNodeRotateMatrix (node) {
        if (!this.rotatableNode || this.rotatableNode.contains(node)) // Rotate transformation is applied to all nodes when no rotatableGroup
        // is present or to nodes inside the rotatableGroup only.
        return this.getRootRotateMatrix();
        // Nodes outside the rotatable group
        return (0, _indexMjsDefault.default).createSVGMatrix();
    },
    getNodeUnrotatedBBox: function(magnet) {
        var rect = this.getNodeBoundingRect(magnet);
        var magnetMatrix = this.getNodeMatrix(magnet);
        var translateMatrix = this.getRootTranslateMatrix();
        return (0, _indexMjsDefault.default).transformRect(rect, translateMatrix.multiply(magnetMatrix));
    },
    getRootTranslateMatrix: function() {
        var model = this.model;
        var position = model.position();
        var mt = (0, _indexMjsDefault.default).createSVGMatrix().translate(position.x, position.y);
        return mt;
    },
    getRootRotateMatrix: function() {
        var mr = (0, _indexMjsDefault.default).createSVGMatrix();
        var model = this.model;
        var angle = model.angle();
        if (angle) {
            var bbox = model.getBBox();
            var cx = bbox.width / 2;
            var cy = bbox.height / 2;
            mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);
        }
        return mr;
    },
    _notifyHighlight: function(eventName, el, opt = {}) {
        const { el: rootNode } = this;
        let node;
        if (typeof el === "string") [node = rootNode] = this.findBySelector(el);
        else [node = rootNode] = this.$(el);
        // set partial flag if the highlighted element is not the entire view.
        opt.partial = node !== rootNode;
        // translate type flag into a type string
        if (opt.type === undefined) {
            let type;
            switch(true){
                case opt.embedding:
                    type = HighlightingTypes.EMBEDDING;
                    break;
                case opt.connecting:
                    type = HighlightingTypes.CONNECTING;
                    break;
                case opt.magnetAvailability:
                    type = HighlightingTypes.MAGNET_AVAILABILITY;
                    break;
                case opt.elementAvailability:
                    type = HighlightingTypes.ELEMENT_AVAILABILITY;
                    break;
                default:
                    type = HighlightingTypes.DEFAULT;
                    break;
            }
            opt.type = type;
        }
        this.notify(eventName, node, opt);
        return this;
    },
    highlight: function(el, opt) {
        return this._notifyHighlight("cell:highlight", el, opt);
    },
    unhighlight: function(el, opt = {}) {
        return this._notifyHighlight("cell:unhighlight", el, opt);
    },
    // Find the closest element that has the `magnet` attribute set to `true`. If there was not such
    // an element found, return the root element of the cell view.
    findMagnet: function(el) {
        const root = this.el;
        let magnet = this.$(el)[0];
        if (!magnet) magnet = root;
        do {
            const magnetAttribute = magnet.getAttribute("magnet");
            const isMagnetRoot = magnet === root;
            if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== "false") return magnet;
            if (isMagnetRoot) // If the overall cell has set `magnet === false`, then return `undefined` to
            // announce there is no magnet found for this cell.
            // This is especially useful to set on cells that have 'ports'. In this case,
            // only the ports have set `magnet === true` and the overall element has `magnet === false`.
            return undefined;
            magnet = magnet.parentNode;
        }while (magnet);
        return undefined;
    },
    findProxyNode: function(el, type) {
        el || (el = this.el);
        const nodeSelector = el.getAttribute(`${type}-selector`);
        if (nodeSelector) {
            const [proxyNode] = this.findBySelector(nodeSelector);
            if (proxyNode) return proxyNode;
        }
        return el;
    },
    // Construct a unique selector for the `el` element within this view.
    // `prevSelector` is being collected through the recursive call.
    // No value for `prevSelector` is expected when using this method.
    getSelector: function(el, prevSelector) {
        var selector;
        if (el === this.el) {
            if (typeof prevSelector === "string") selector = "> " + prevSelector;
            return selector;
        }
        if (el) {
            var nthChild = (0, _indexMjsDefault.default)(el).index() + 1;
            selector = el.tagName + ":nth-child(" + nthChild + ")";
            if (prevSelector) selector += " > " + prevSelector;
            selector = this.getSelector(el.parentNode, selector);
        }
        return selector;
    },
    addLinkFromMagnet: function(magnet, x, y) {
        var paper = this.paper;
        var graph = paper.model;
        var link = paper.getDefaultLink(this, magnet);
        link.set({
            source: this.getLinkEnd(magnet, x, y, link, "source"),
            target: {
                x: x,
                y: y
            }
        }).addTo(graph, {
            async: false,
            ui: true
        });
        return link.findView(paper);
    },
    getLinkEnd: function(magnet, ...args) {
        var model = this.model;
        var id = model.id;
        var port = this.findAttribute("port", magnet);
        // Find a unique `selector` of the element under pointer that is a magnet.
        var selector = magnet.getAttribute("joint-selector");
        var end = {
            id: id
        };
        if (selector != null) end.magnet = selector;
        if (port != null) {
            end.port = port;
            if (!model.hasPort(port) && !selector) // port created via the `port` attribute (not API)
            end.selector = this.getSelector(magnet);
        } else if (selector == null && this.el !== magnet) end.selector = this.getSelector(magnet);
        return this.customizeLinkEnd(end, magnet, ...args);
    },
    customizeLinkEnd: function(end, magnet, x, y, link, endType) {
        const { paper } = this;
        const { connectionStrategy } = paper.options;
        if (typeof connectionStrategy === "function") {
            var strategy = connectionStrategy.call(paper, end, this, magnet, new (0, _indexMjs3.Point)(x, y), link, endType, paper);
            if (strategy) return strategy;
        }
        return end;
    },
    getMagnetFromLinkEnd: function(end) {
        var root = this.el;
        var port = end.port;
        var selector = end.magnet;
        var model = this.model;
        var magnet;
        if (port != null && model.isElement() && model.hasPort(port)) magnet = this.findPortNode(port, selector) || root;
        else {
            if (!selector) selector = end.selector;
            if (!selector && port != null) // link end has only `id` and `port` property referencing
            // a port created via the `port` attribute (not API).
            selector = '[port="' + port + '"]';
            magnet = this.findBySelector(selector, root, this.selectors)[0];
        }
        return this.findProxyNode(magnet, "magnet");
    },
    dragLinkStart: function(evt, magnet, x, y) {
        this.model.startBatch("add-link");
        const linkView = this.addLinkFromMagnet(magnet, x, y);
        // backwards compatibility events
        linkView.notifyPointerdown(evt, x, y);
        linkView.eventData(evt, linkView.startArrowheadMove("target", {
            whenNotAllowed: "remove"
        }));
        this.eventData(evt, {
            linkView
        });
    },
    dragLink: function(evt, x, y) {
        var data = this.eventData(evt);
        var linkView = data.linkView;
        if (linkView) linkView.pointermove(evt, x, y);
        else {
            var paper = this.paper;
            var magnetThreshold = paper.options.magnetThreshold;
            var currentTarget = this.getEventTarget(evt);
            var targetMagnet = data.targetMagnet;
            if (magnetThreshold === "onleave") {
                // magnetThreshold when the pointer leaves the magnet
                if (targetMagnet === currentTarget || (0, _indexMjsDefault.default)(targetMagnet).contains(currentTarget)) return;
            } else {
                // magnetThreshold defined as a number of movements
                if (paper.eventData(evt).mousemoved <= magnetThreshold) return;
            }
            this.dragLinkStart(evt, targetMagnet, x, y);
        }
    },
    dragLinkEnd: function(evt, x, y) {
        var data = this.eventData(evt);
        var linkView = data.linkView;
        if (!linkView) return;
        linkView.pointerup(evt, x, y);
        this.model.stopBatch("add-link");
    },
    getAttributeDefinition: function(attrName) {
        return this.model.constructor.getAttributeDefinition(attrName);
    },
    setNodeAttributes: function(node, attrs) {
        if (!(0, _indexMjs2.isEmpty)(attrs)) {
            if (node instanceof SVGElement) (0, _indexMjsDefault.default)(node).attr(attrs);
            else (0, _jqueryDefault.default)(node).attr(attrs);
        }
    },
    processNodeAttributes: function(node, attrs) {
        var attrName, attrVal, def, i, n;
        var normalAttrs, setAttrs, positionAttrs, offsetAttrs;
        var relatives = [];
        // divide the attributes between normal and special
        for(attrName in attrs){
            if (!attrs.hasOwnProperty(attrName)) continue;
            attrVal = attrs[attrName];
            def = this.getAttributeDefinition(attrName);
            if (def && (!(0, _indexMjs2.isFunction)(def.qualify) || def.qualify.call(this, attrVal, node, attrs, this))) {
                if ((0, _indexMjs2.isString)(def.set)) {
                    normalAttrs || (normalAttrs = {});
                    normalAttrs[def.set] = attrVal;
                }
                if (attrVal !== null) relatives.push(attrName, def);
            } else {
                normalAttrs || (normalAttrs = {});
                normalAttrs[(0, _indexMjs2.toKebabCase)(attrName)] = attrVal;
            }
        }
        // handle the rest of attributes via related method
        // from the special attributes namespace.
        for(i = 0, n = relatives.length; i < n; i += 2){
            attrName = relatives[i];
            def = relatives[i + 1];
            attrVal = attrs[attrName];
            if ((0, _indexMjs2.isFunction)(def.set)) {
                setAttrs || (setAttrs = {});
                setAttrs[attrName] = attrVal;
            }
            if ((0, _indexMjs2.isFunction)(def.position)) {
                positionAttrs || (positionAttrs = {});
                positionAttrs[attrName] = attrVal;
            }
            if ((0, _indexMjs2.isFunction)(def.offset)) {
                offsetAttrs || (offsetAttrs = {});
                offsetAttrs[attrName] = attrVal;
            }
        }
        return {
            raw: attrs,
            normal: normalAttrs,
            set: setAttrs,
            position: positionAttrs,
            offset: offsetAttrs
        };
    },
    updateRelativeAttributes: function(node, attrs, refBBox, opt) {
        opt || (opt = {});
        var attrName, attrVal, def;
        var rawAttrs = attrs.raw || {};
        var nodeAttrs = attrs.normal || {};
        var setAttrs = attrs.set;
        var positionAttrs = attrs.position;
        var offsetAttrs = attrs.offset;
        for(attrName in setAttrs){
            attrVal = setAttrs[attrName];
            def = this.getAttributeDefinition(attrName);
            // SET - set function should return attributes to be set on the node,
            // which will affect the node dimensions based on the reference bounding
            // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points
            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, rawAttrs, this);
            if ((0, _indexMjs2.isObject)(setResult)) (0, _indexMjs2.assign)(nodeAttrs, setResult);
            else if (setResult !== undefined) nodeAttrs[attrName] = setResult;
        }
        if (node instanceof HTMLElement) {
            // TODO: setting the `transform` attribute on HTMLElements
            // via `node.style.transform = 'matrix(...)';` would introduce
            // a breaking change (e.g. basic.TextBlock).
            this.setNodeAttributes(node, nodeAttrs);
            return;
        }
        // The final translation of the subelement.
        var nodeTransform = nodeAttrs.transform;
        var nodeMatrix = (0, _indexMjsDefault.default).transformStringToMatrix(nodeTransform);
        var nodePosition = (0, _indexMjs3.Point)(nodeMatrix.e, nodeMatrix.f);
        if (nodeTransform) {
            nodeAttrs = (0, _indexMjs2.omit)(nodeAttrs, "transform");
            nodeMatrix.e = nodeMatrix.f = 0;
        }
        // Calculate node scale determined by the scalable group
        // only if later needed.
        var sx, sy, translation;
        if (positionAttrs || offsetAttrs) {
            var nodeScale = this.getNodeScale(node, opt.scalableNode);
            sx = nodeScale.sx;
            sy = nodeScale.sy;
        }
        var positioned = false;
        for(attrName in positionAttrs){
            attrVal = positionAttrs[attrName];
            def = this.getAttributeDefinition(attrName);
            // POSITION - position function should return a point from the
            // reference bounding box. The default position of the node is x:0, y:0 of
            // the reference bounding box or could be further specify by some
            // SVG attributes e.g. `x`, `y`
            translation = def.position.call(this, attrVal, refBBox.clone(), node, rawAttrs, this);
            if (translation) {
                nodePosition.offset((0, _indexMjs3.Point)(translation).scale(sx, sy));
                positioned || (positioned = true);
            }
        }
        // The node bounding box could depend on the `size` set from the previous loop.
        // Here we know, that all the size attributes have been already set.
        this.setNodeAttributes(node, nodeAttrs);
        var offseted = false;
        if (offsetAttrs) {
            // Check if the node is visible
            var nodeBoundingRect = this.getNodeBoundingRect(node);
            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {
                var nodeBBox = (0, _indexMjsDefault.default).transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);
                for(attrName in offsetAttrs){
                    attrVal = offsetAttrs[attrName];
                    def = this.getAttributeDefinition(attrName);
                    // OFFSET - offset function should return a point from the element
                    // bounding box. The default offset point is x:0, y:0 (origin) or could be further
                    // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`
                    translation = def.offset.call(this, attrVal, nodeBBox, node, rawAttrs, this);
                    if (translation) {
                        nodePosition.offset((0, _indexMjs3.Point)(translation).scale(sx, sy));
                        offseted || (offseted = true);
                    }
                }
            }
        }
        // Do not touch node's transform attribute if there is no transformation applied.
        if (nodeTransform !== undefined || positioned || offseted) {
            // Round the coordinates to 1 decimal point.
            nodePosition.round(1);
            nodeMatrix.e = nodePosition.x;
            nodeMatrix.f = nodePosition.y;
            node.setAttribute("transform", (0, _indexMjsDefault.default).matrixToTransformString(nodeMatrix));
        // TODO: store nodeMatrix metrics?
        }
    },
    getNodeScale: function(node, scalableNode) {
        // Check if the node is a descendant of the scalable group.
        var sx, sy;
        if (scalableNode && scalableNode.contains(node)) {
            var scale = scalableNode.scale();
            sx = 1 / scale.sx;
            sy = 1 / scale.sy;
        } else {
            sx = 1;
            sy = 1;
        }
        return {
            sx: sx,
            sy: sy
        };
    },
    cleanNodesCache: function() {
        this.metrics = {};
    },
    nodeCache: function(magnet) {
        var metrics = this.metrics;
        // Don't use cache? It most likely a custom view with overridden update.
        if (!metrics) return {};
        var id = (0, _indexMjsDefault.default).ensureId(magnet);
        var value = metrics[id];
        if (!value) value = metrics[id] = {};
        return value;
    },
    getNodeData: function(magnet) {
        var metrics = this.nodeCache(magnet);
        if (!metrics.data) metrics.data = {};
        return metrics.data;
    },
    getNodeBoundingRect: function(magnet) {
        var metrics = this.nodeCache(magnet);
        if (metrics.boundingRect === undefined) metrics.boundingRect = (0, _indexMjsDefault.default)(magnet).getBBox();
        return new (0, _indexMjs3.Rect)(metrics.boundingRect);
    },
    getNodeMatrix: function(magnet) {
        const metrics = this.nodeCache(magnet);
        if (metrics.magnetMatrix === undefined) {
            const { rotatableNode, el } = this;
            let target;
            if (rotatableNode && rotatableNode.contains(magnet)) target = rotatableNode;
            else target = el;
            metrics.magnetMatrix = (0, _indexMjsDefault.default)(magnet).getTransformToElement(target);
        }
        return (0, _indexMjsDefault.default).createSVGMatrix(metrics.magnetMatrix);
    },
    getNodeShape: function(magnet) {
        var metrics = this.nodeCache(magnet);
        if (metrics.geometryShape === undefined) metrics.geometryShape = (0, _indexMjsDefault.default)(magnet).toGeometryShape();
        return metrics.geometryShape.clone();
    },
    isNodeConnection: function(node) {
        return this.model.isLink() && (!node || node === this.el);
    },
    findNodesAttributes: function(attrs, root, selectorCache, selectors) {
        var i, n, nodeAttrs, nodeId;
        var nodesAttrs = {};
        var mergeIds = [];
        for(var selector in attrs){
            if (!attrs.hasOwnProperty(selector)) continue;
            nodeAttrs = attrs[selector];
            if (!(0, _indexMjs2.isPlainObject)(nodeAttrs)) continue; // Not a valid selector-attributes pair
            var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);
            for(i = 0, n = selected.length; i < n; i++){
                var node = selected[i];
                nodeId = (0, _indexMjsDefault.default).ensureId(node);
                // "unique" selectors are selectors that referencing a single node (defined by `selector`)
                // groupSelector referencing a single node is not "unique"
                var unique = selectors && selectors[selector] === node;
                var prevNodeAttrs = nodesAttrs[nodeId];
                if (prevNodeAttrs) {
                    // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.
                    // e.g. css:`.circle` and selector:`circle` can be applied in a random order
                    if (!prevNodeAttrs.array) {
                        mergeIds.push(nodeId);
                        prevNodeAttrs.array = true;
                        prevNodeAttrs.attributes = [
                            prevNodeAttrs.attributes
                        ];
                        prevNodeAttrs.selectedLength = [
                            prevNodeAttrs.selectedLength
                        ];
                    }
                    var attributes = prevNodeAttrs.attributes;
                    var selectedLength = prevNodeAttrs.selectedLength;
                    if (unique) {
                        // node referenced by `selector`
                        attributes.unshift(nodeAttrs);
                        selectedLength.unshift(-1);
                    } else {
                        // node referenced by `groupSelector`
                        var sortIndex = (0, _indexMjs2.sortedIndex)(selectedLength, n);
                        attributes.splice(sortIndex, 0, nodeAttrs);
                        selectedLength.splice(sortIndex, 0, n);
                    }
                } else nodesAttrs[nodeId] = {
                    attributes: nodeAttrs,
                    selectedLength: unique ? -1 : n,
                    node: node,
                    array: false
                };
            }
        }
        for(i = 0, n = mergeIds.length; i < n; i++){
            nodeId = mergeIds[i];
            nodeAttrs = nodesAttrs[nodeId];
            nodeAttrs.attributes = (0, _indexMjs2.merge)({}, ...nodeAttrs.attributes.reverse());
        }
        return nodesAttrs;
    },
    getEventTarget: function(evt, opt = {}) {
        const { target, type, clientX = 0, clientY = 0 } = evt;
        if (// Explicitly defined `fromPoint` option
        opt.fromPoint || // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.
        // It holds the element when a touchstart triggered.
        type === "touchmove" || type === "touchend" || // Pointermove/Pointerup event with the pointer captured
        "pointerId" in evt && target.hasPointerCapture(evt.pointerId)) return document.elementFromPoint(clientX, clientY);
        return target;
    },
    // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,
    // unless `attrs` parameter was passed.
    updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {
        opt || (opt = {});
        opt.rootBBox || (opt.rootBBox = (0, _indexMjs3.Rect)());
        opt.selectors || (opt.selectors = this.selectors); // selector collection to use
        // Cache table for query results and bounding box calculation.
        // Note that `selectorCache` needs to be invalidated for all
        // `updateAttributes` calls, as the selectors might pointing
        // to nodes designated by an attribute or elements dynamically
        // created.
        var selectorCache = {};
        var bboxCache = {};
        var relativeItems = [];
        var relativeRefItems = [];
        var item, node, nodeAttrs, nodeData, processedAttrs;
        var roAttrs = opt.roAttributes;
        var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);
        // `nodesAttrs` are different from all attributes, when
        // rendering only  attributes sent to this method.
        var nodesAllAttrs = roAttrs ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors) : nodesAttrs;
        for(var nodeId in nodesAttrs){
            nodeData = nodesAttrs[nodeId];
            nodeAttrs = nodeData.attributes;
            node = nodeData.node;
            processedAttrs = this.processNodeAttributes(node, nodeAttrs);
            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset) // Set all the normal attributes right on the SVG/HTML element.
            this.setNodeAttributes(node, processedAttrs.normal);
            else {
                var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;
                var refSelector = nodeAllAttrs && nodeAttrs.ref === undefined ? nodeAllAttrs.ref : nodeAttrs.ref;
                var refNode;
                if (refSelector) {
                    refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];
                    if (!refNode) throw new Error('dia.CellView: "' + refSelector + '" reference does not exist.');
                } else refNode = null;
                item = {
                    node: node,
                    refNode: refNode,
                    processedAttributes: processedAttrs,
                    allAttributes: nodeAllAttrs
                };
                if (refNode) {
                    // If an element in the list is positioned relative to this one, then
                    // we want to insert this one before it in the list.
                    var itemIndex = relativeRefItems.findIndex(function(item) {
                        return item.refNode === node;
                    });
                    if (itemIndex > -1) relativeRefItems.splice(itemIndex, 0, item);
                    else relativeRefItems.push(item);
                } else // A node with no ref attribute. To be updated before the nodes referencing other nodes.
                // The order of no-ref-items is not specified/important.
                relativeItems.push(item);
            }
        }
        relativeItems.push(...relativeRefItems);
        for(let i = 0, n = relativeItems.length; i < n; i++){
            item = relativeItems[i];
            node = item.node;
            refNode = item.refNode;
            // Find the reference element bounding box. If no reference was provided, we
            // use the optional bounding box.
            const refNodeId = refNode ? (0, _indexMjsDefault.default).ensureId(refNode) : "";
            let refBBox = bboxCache[refNodeId];
            if (!refBBox) // Get the bounding box of the reference element using to the common ancestor
            // transformation space.
            //
            // @example 1
            // <g transform="translate(11, 13)">
            //     <rect @selector="b" x="1" y="2" width="3" height="4"/>
            //     <rect @selector="a"/>
            // </g>
            //
            // In this case, the reference bounding box can not be affected
            // by the `transform` attribute of the `<g>` element,
            // because the exact transformation will be applied to the `a` element
            // as well as to the `b` element.
            //
            // @example 2
            // <g transform="translate(11, 13)">
            //     <rect @selector="b" x="1" y="2" width="3" height="4"/>
            // </g>
            // <rect @selector="a"/>
            //
            // In this case, the reference bounding box have to be affected by the
            // `transform` attribute of the `<g>` element, because the `a` element
            // is not descendant of the `<g>` element and will not be affected
            // by the transformation.
            refBBox = bboxCache[refNodeId] = refNode ? (0, _indexMjsDefault.default)(refNode).getBBox({
                target: getCommonAncestorNode(node, refNode)
            }) : opt.rootBBox;
            if (roAttrs) {
                // if there was a special attribute affecting the position amongst passed-in attributes
                // we have to merge it with the rest of the element's attributes as they are necessary
                // to update the position relatively (i.e `ref-x` && 'ref-dx')
                processedAttrs = this.processNodeAttributes(node, item.allAttributes);
                this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);
            } else processedAttrs = item.processedAttributes;
            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);
        }
    },
    mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {
        processedAttrs.set || (processedAttrs.set = {});
        processedAttrs.position || (processedAttrs.position = {});
        processedAttrs.offset || (processedAttrs.offset = {});
        (0, _indexMjs2.assign)(processedAttrs.set, roProcessedAttrs.set);
        (0, _indexMjs2.assign)(processedAttrs.position, roProcessedAttrs.position);
        (0, _indexMjs2.assign)(processedAttrs.offset, roProcessedAttrs.offset);
        // Handle also the special transform property.
        var transform = processedAttrs.normal && processedAttrs.normal.transform;
        if (transform !== undefined && roProcessedAttrs.normal) roProcessedAttrs.normal.transform = transform;
        processedAttrs.normal = roProcessedAttrs.normal;
    },
    // Lifecycle methods
    // Called when the view is attached to the DOM,
    // as result of `cell.addTo(graph)` being called (isInitialMount === true)
    // or `paper.options.viewport` returning `true` (isInitialMount === false).
    onMount (isInitialMount) {
        if (isInitialMount) return;
        this.mountTools();
        (0, _highlighterViewMjs.HighlighterView).mount(this);
    },
    // Called when the view is detached from the DOM,
    // as result of `paper.options.viewport` returning `false`.
    onDetach () {
        this.unmountTools();
        (0, _highlighterViewMjs.HighlighterView).unmount(this);
    },
    // Called when the view is removed from the DOM
    // as result of `cell.remove()`.
    onRemove: function() {
        this.removeTools();
        this.removeHighlighters();
    },
    _toolsView: null,
    hasTools: function(name) {
        var toolsView = this._toolsView;
        if (!toolsView) return false;
        if (!name) return true;
        return toolsView.getName() === name;
    },
    addTools: function(toolsView) {
        this.removeTools();
        if (toolsView) {
            this._toolsView = toolsView;
            toolsView.configure({
                relatedView: this
            });
            toolsView.listenTo(this.paper, "tools:event", this.onToolEvent.bind(this));
        }
        return this;
    },
    unmountTools () {
        const toolsView = this._toolsView;
        if (toolsView) toolsView.unmount();
        return this;
    },
    mountTools () {
        const toolsView = this._toolsView;
        // Prevent unnecessary re-appending of the tools.
        if (toolsView && !toolsView.isMounted()) toolsView.mount();
        return this;
    },
    updateTools: function(opt) {
        var toolsView = this._toolsView;
        if (toolsView) toolsView.update(opt);
        return this;
    },
    removeTools: function() {
        var toolsView = this._toolsView;
        if (toolsView) {
            toolsView.remove();
            this._toolsView = null;
        }
        return this;
    },
    hideTools: function() {
        var toolsView = this._toolsView;
        if (toolsView) toolsView.hide();
        return this;
    },
    showTools: function() {
        var toolsView = this._toolsView;
        if (toolsView) toolsView.show();
        return this;
    },
    onToolEvent: function(event) {
        switch(event){
            case "remove":
                this.removeTools();
                break;
            case "hide":
                this.hideTools();
                break;
            case "show":
                this.showTools();
                break;
        }
    },
    removeHighlighters: function() {
        (0, _highlighterViewMjs.HighlighterView).remove(this);
    },
    updateHighlighters: function(dirty = false) {
        (0, _highlighterViewMjs.HighlighterView).update(this, null, dirty);
    },
    transformHighlighters: function() {
        (0, _highlighterViewMjs.HighlighterView).transform(this);
    },
    // Interaction. The controller part.
    // ---------------------------------
    preventDefaultInteraction (evt) {
        this.eventData(evt, {
            defaultInteractionPrevented: true
        });
    },
    isDefaultInteractionPrevented (evt) {
        const { defaultInteractionPrevented = false } = this.eventData(evt);
        return defaultInteractionPrevented;
    },
    // Interaction is handled by the paper and delegated to the view in interest.
    // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.
    // If necessary, real coordinates can be obtained from the `evt` event object.
    // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,
    // i.e. `joint.dia.Element` and `joint.dia.Link`.
    pointerdblclick: function(evt, x, y) {
        this.notify("cell:pointerdblclick", evt, x, y);
    },
    pointerclick: function(evt, x, y) {
        this.notify("cell:pointerclick", evt, x, y);
    },
    contextmenu: function(evt, x, y) {
        this.notify("cell:contextmenu", evt, x, y);
    },
    pointerdown: function(evt, x, y) {
        const { model } = this;
        const { graph } = model;
        if (graph) {
            model.startBatch("pointer");
            this.eventData(evt, {
                graph
            });
        }
        this.notify("cell:pointerdown", evt, x, y);
    },
    pointermove: function(evt, x, y) {
        this.notify("cell:pointermove", evt, x, y);
    },
    pointerup: function(evt, x, y) {
        const { graph } = this.eventData(evt);
        this.notify("cell:pointerup", evt, x, y);
        if (graph) // we don't want to trigger event on model as model doesn't
        // need to be member of collection anymore (remove)
        graph.stopBatch("pointer", {
            cell: this.model
        });
    },
    mouseover: function(evt) {
        this.notify("cell:mouseover", evt);
    },
    mouseout: function(evt) {
        this.notify("cell:mouseout", evt);
    },
    mouseenter: function(evt) {
        this.notify("cell:mouseenter", evt);
    },
    mouseleave: function(evt) {
        this.notify("cell:mouseleave", evt);
    },
    mousewheel: function(evt, x, y, delta) {
        this.notify("cell:mousewheel", evt, x, y, delta);
    },
    onevent: function(evt, eventName, x, y) {
        this.notify(eventName, evt, x, y);
    },
    onmagnet: function() {
    // noop
    },
    magnetpointerdblclick: function() {
    // noop
    },
    magnetcontextmenu: function() {
    // noop
    },
    checkMouseleave (evt) {
        const { paper, model } = this;
        if (paper.isAsync()) {
            // Make sure the source/target views are updated before this view.
            // It's not 100% bulletproof (see below) but it's a good enough solution for now.
            // The connected cells could be links as well. In that case, we would
            // need to recursively go through all the connected links and update
            // their source/target views as well.
            if (model.isLink()) {
                // The `this.sourceView` and `this.targetView` might not be updated yet.
                // We need to find the view by the model.
                const sourceElement = model.getSourceElement();
                if (sourceElement) {
                    const sourceView = paper.findViewByModel(sourceElement);
                    if (sourceView) {
                        paper.dumpView(sourceView);
                        paper.checkViewVisibility(sourceView);
                    }
                }
                const targetElement = model.getTargetElement();
                if (targetElement) {
                    const targetView = paper.findViewByModel(targetElement);
                    if (targetView) {
                        paper.dumpView(targetView);
                        paper.checkViewVisibility(targetView);
                    }
                }
            }
            // Do the updates of the current view synchronously now
            paper.dumpView(this);
            paper.checkViewVisibility(this);
        }
        const target = this.getEventTarget(evt, {
            fromPoint: true
        });
        const view = paper.findView(target);
        if (view === this) return;
        // Leaving the current view
        this.mouseleave(evt);
        if (!view) return;
        // Entering another view
        view.mouseenter(evt);
    },
    setInteractivity: function(value) {
        this.options.interactive = value;
    }
}, {
    Flags,
    Highlighting: HighlightingTypes,
    addPresentationAttributes: function(presentationAttributes) {
        return (0, _indexMjs2.merge)({}, (0, _indexMjs2.result)(this.prototype, "presentationAttributes"), presentationAttributes, function(a, b) {
            if (!a || !b) return;
            if (typeof a === "string") a = [
                a
            ];
            if (typeof b === "string") b = [
                b
            ];
            if (Array.isArray(a) && Array.isArray(b)) return (0, _indexMjs2.uniq)(a.concat(b));
        });
    }
});
// TODO: Move to Vectorizer library.
function getCommonAncestorNode(node1, node2) {
    let parent = node1;
    do {
        if (parent.contains(node2)) return parent;
        parent = parent.parentNode;
    }while (parent);
    return null;
}

},{"../config/index.mjs":"7Vsch","../mvc/index.mjs":"c2o6n","../util/index.mjs":"eL7pI","../g/index.mjs":"i91Db","../V/index.mjs":"iw8UN","jquery":"7jr44","./HighlighterView.mjs":"1vHPf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c2o6n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _viewMjs = require("./View.mjs");
parcelHelpers.exportAll(_viewMjs, exports);
var _listenerMjs = require("./Listener.mjs");
parcelHelpers.exportAll(_listenerMjs, exports);

},{"./View.mjs":"kkz7p","./Listener.mjs":"dJG9j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kkz7p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "views", ()=>views);
parcelHelpers.export(exports, "View", ()=>View);
var _backbone = require("backbone");
var _backboneDefault = parcelHelpers.interopDefault(_backbone);
var _jquery = require("jquery");
var _jqueryDefault = parcelHelpers.interopDefault(_jquery);
var _indexMjs = require("../util/index.mjs");
var _indexMjs1 = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
var _indexMjs2 = require("../config/index.mjs");
const views = {};
const View = (0, _backboneDefault.default).View.extend({
    options: {},
    theme: null,
    themeClassNamePrefix: _indexMjs.addClassNamePrefix("theme-"),
    requireSetThemeOverride: false,
    defaultTheme: (0, _indexMjs2.config).defaultTheme,
    children: null,
    childNodes: null,
    DETACHABLE: true,
    UPDATE_PRIORITY: 2,
    FLAG_INSERT: 1073741824,
    FLAG_REMOVE: 536870912,
    FLAG_INIT: 268435456,
    constructor: function(options) {
        this.requireSetThemeOverride = options && !!options.theme;
        this.options = _indexMjs.assign({}, this.options, options);
        (0, _backboneDefault.default).View.call(this, options);
    },
    initialize: function() {
        views[this.cid] = this;
        this.setTheme(this.options.theme || this.defaultTheme);
        this.init();
    },
    unmount: function() {
        if (this.svgElement) this.vel.remove();
        else this.$el.remove();
    },
    isMounted: function() {
        return this.el.parentNode !== null;
    },
    renderChildren: function(children) {
        children || (children = _indexMjs.result(this, "children"));
        if (children) {
            var isSVG = this.svgElement;
            var namespace = (0, _indexMjsDefault.default).namespace[isSVG ? "svg" : "xhtml"];
            var doc = _indexMjs.parseDOMJSON(children, namespace);
            (isSVG ? this.vel : this.$el).empty().append(doc.fragment);
            this.childNodes = doc.selectors;
        }
        return this;
    },
    findAttribute: function(attributeName, node) {
        var currentNode = node;
        while(currentNode && currentNode.nodeType === 1){
            var attributeValue = currentNode.getAttribute(attributeName);
            // attribute found
            if (attributeValue) return attributeValue;
            // do not climb up the DOM
            if (currentNode === this.el) return null;
            // try parent node
            currentNode = currentNode.parentNode;
        }
        return null;
    },
    // Override the Backbone `_ensureElement()` method in order to create an
    // svg element (e.g., `<g>`) node that wraps all the nodes of the Cell view.
    // Expose class name setter as a separate method.
    _ensureElement: function() {
        if (!this.el) {
            var tagName = _indexMjs.result(this, "tagName");
            var attrs = _indexMjs.assign({}, _indexMjs.result(this, "attributes"));
            var style = _indexMjs.assign({}, _indexMjs.result(this, "style"));
            if (this.id) attrs.id = _indexMjs.result(this, "id");
            this.setElement(this._createElement(tagName));
            this._setAttributes(attrs);
            this._setStyle(style);
        } else this.setElement(_indexMjs.result(this, "el"));
        this._ensureElClassName();
    },
    _setAttributes: function(attrs) {
        if (this.svgElement) this.vel.attr(attrs);
        else this.$el.attr(attrs);
    },
    _setStyle: function(style) {
        this.$el.css(style);
    },
    _createElement: function(tagName) {
        if (this.svgElement) return document.createElementNS((0, _indexMjsDefault.default).namespace.svg, tagName);
        else return document.createElement(tagName);
    },
    // Utilize an alternative DOM manipulation API by
    // adding an element reference wrapped in Vectorizer.
    _setElement: function(el) {
        this.$el = el instanceof (0, _backboneDefault.default).$ ? el : (0, _backboneDefault.default).$(el);
        this.el = this.$el[0];
        if (this.svgElement) this.vel = (0, _indexMjsDefault.default)(this.el);
    },
    _ensureElClassName: function() {
        var className = _indexMjs.result(this, "className");
        if (!className) return;
        var prefixedClassName = _indexMjs.addClassNamePrefix(className);
        // Note: className removal here kept for backwards compatibility only
        if (this.svgElement) this.vel.removeClass(className).addClass(prefixedClassName);
        else this.$el.removeClass(className).addClass(prefixedClassName);
    },
    init: function() {
    // Intentionally empty.
    // This method is meant to be overridden.
    },
    onRender: function() {
    // Intentionally empty.
    // This method is meant to be overridden.
    },
    confirmUpdate: function() {
        // Intentionally empty.
        // This method is meant to be overridden.
        return 0;
    },
    setTheme: function(theme, opt) {
        opt = opt || {};
        // Theme is already set, override is required, and override has not been set.
        // Don't set the theme.
        if (this.theme && this.requireSetThemeOverride && !opt.override) return this;
        this.removeThemeClassName();
        this.addThemeClassName(theme);
        this.onSetTheme(this.theme /* oldTheme */ , theme /* newTheme */ );
        this.theme = theme;
        return this;
    },
    addThemeClassName: function(theme) {
        theme = theme || this.theme;
        if (!theme) return this;
        var className = this.themeClassNamePrefix + theme;
        if (this.svgElement) this.vel.addClass(className);
        else this.$el.addClass(className);
        return this;
    },
    removeThemeClassName: function(theme) {
        theme = theme || this.theme;
        var className = this.themeClassNamePrefix + theme;
        if (this.svgElement) this.vel.removeClass(className);
        else this.$el.removeClass(className);
        return this;
    },
    onSetTheme: function(oldTheme, newTheme) {
    // Intentionally empty.
    // This method is meant to be overridden.
    },
    remove: function() {
        this.onRemove();
        this.undelegateDocumentEvents();
        views[this.cid] = null;
        (0, _backboneDefault.default).View.prototype.remove.apply(this, arguments);
        return this;
    },
    onRemove: function() {
    // Intentionally empty.
    // This method is meant to be overridden.
    },
    getEventNamespace: function() {
        // Returns a per-session unique namespace
        return ".joint-event-ns-" + this.cid;
    },
    delegateElementEvents: function(element, events, data) {
        if (!events) return this;
        data || (data = {});
        var eventNS = this.getEventNamespace();
        for(var eventName in events){
            var method = events[eventName];
            if (typeof method !== "function") method = this[method];
            if (!method) continue;
            (0, _jqueryDefault.default)(element).on(eventName + eventNS, data, method.bind(this));
        }
        return this;
    },
    undelegateElementEvents: function(element) {
        (0, _jqueryDefault.default)(element).off(this.getEventNamespace());
        return this;
    },
    delegateDocumentEvents: function(events, data) {
        events || (events = _indexMjs.result(this, "documentEvents"));
        return this.delegateElementEvents(document, events, data);
    },
    undelegateDocumentEvents: function() {
        return this.undelegateElementEvents(document);
    },
    eventData: function(evt, data) {
        if (!evt) throw new Error("eventData(): event object required.");
        var currentData = evt.data;
        var key = "__" + this.cid + "__";
        if (data === undefined) {
            if (!currentData) return {};
            return currentData[key] || {};
        }
        currentData || (currentData = evt.data = {});
        currentData[key] || (currentData[key] = {});
        _indexMjs.assign(currentData[key], data);
        return this;
    },
    stopPropagation: function(evt) {
        this.eventData(evt, {
            propagationStopped: true
        });
        return this;
    },
    isPropagationStopped: function(evt) {
        return !!this.eventData(evt).propagationStopped;
    }
}, {
    extend: function() {
        var args = Array.from(arguments);
        // Deep clone the prototype and static properties objects.
        // This prevents unexpected behavior where some properties are overwritten outside of this function.
        var protoProps = args[0] && _indexMjs.assign({}, args[0]) || {};
        var staticProps = args[1] && _indexMjs.assign({}, args[1]) || {};
        // Need the real render method so that we can wrap it and call it later.
        var renderFn = protoProps.render || this.prototype && this.prototype.render || null;
        /*
            Wrap the real render method so that:
                .. `onRender` is always called.
                .. `this` is always returned.
        */ protoProps.render = function() {
            if (typeof renderFn === "function") // Call the original render method.
            renderFn.apply(this, arguments);
            if (this.render.__render__ === renderFn) // Should always call onRender() method.
            // Should call it only once when renderFn is actual prototype method i.e. not the wrapper
            this.onRender();
            // Should always return itself.
            return this;
        };
        protoProps.render.__render__ = renderFn;
        return (0, _backboneDefault.default).View.extend.call(this, protoProps, staticProps);
    }
});
const DoubleTapEventName = "dbltap";
if ((0, _jqueryDefault.default).event && !(DoubleTapEventName in (0, _jqueryDefault.default).event.special)) {
    const maxDelay = (0, _indexMjs2.config).doubleTapInterval;
    const minDelay = 30;
    (0, _jqueryDefault.default).event.special[DoubleTapEventName] = {
        bindType: "touchend",
        delegateType: "touchend",
        handle: function(event, ...args) {
            const { handleObj, target } = event;
            const targetData = (0, _jqueryDefault.default).data(target);
            const now = new Date().getTime();
            const delta = "lastTouch" in targetData ? now - targetData.lastTouch : 0;
            if (delta < maxDelay && delta > minDelay) {
                targetData.lastTouch = null;
                event.type = handleObj.origType;
                // let jQuery handle the triggering of "dbltap" event handlers
                handleObj.handler.call(this, event, ...args);
            } else targetData.lastTouch = now;
        }
    };
}

},{"backbone":"gM9rO","jquery":"7jr44","../util/index.mjs":"eL7pI","../V/index.mjs":"iw8UN","../config/index.mjs":"7Vsch","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dJG9j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Listener", ()=>Listener);
var _backbone = require("backbone");
var _backboneDefault = parcelHelpers.interopDefault(_backbone);
var _indexMjs = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
class Listener {
    constructor(...callbackArguments){
        this.callbackArguments = callbackArguments;
    }
    listenTo(object, evt, ...args) {
        const { callbackArguments } = this;
        // signature 1 - (object, eventHashMap, context)
        if ((0, _indexMjsDefault.default).isObject(evt)) {
            const [context = null] = args;
            Object.entries(evt).forEach(([eventName, cb])=>{
                if (typeof cb !== "function") return;
                // Invoke the callback with callbackArguments passed first
                if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);
                (0, _backboneDefault.default).Events.listenTo.call(this, object, eventName, cb);
            });
        } else if (typeof evt === "string" && typeof args[0] === "function") {
            let [cb, context = null] = args;
            // Invoke the callback with callbackArguments passed first
            if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);
            (0, _backboneDefault.default).Events.listenTo.call(this, object, evt, cb);
        }
    }
    stopListening() {
        (0, _backboneDefault.default).Events.stopListening.call(this);
    }
}

},{"backbone":"gM9rO","../V/index.mjs":"iw8UN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1vHPf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HighlighterView", ()=>HighlighterView);
var _indexMjs = require("../mvc/index.mjs");
var _indexMjs1 = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
var _utilMjs = require("../util/util.mjs");
function toArray(obj) {
    if (!obj) return [];
    if (Array.isArray(obj)) return obj;
    return [
        obj
    ];
}
const HighlighterView = _indexMjs.View.extend({
    tagName: "g",
    svgElement: true,
    className: "highlight",
    HIGHLIGHT_FLAG: 1,
    UPDATE_PRIORITY: 3,
    DETACHABLE: false,
    UPDATABLE: true,
    MOUNTABLE: true,
    cellView: null,
    nodeSelector: null,
    node: null,
    updateRequested: false,
    postponedUpdate: false,
    transformGroup: null,
    detachedTransformGroup: null,
    requestUpdate (cellView, nodeSelector) {
        const { paper } = cellView;
        this.cellView = cellView;
        this.nodeSelector = nodeSelector;
        if (paper) {
            this.updateRequested = true;
            paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);
        }
    },
    confirmUpdate () {
        // The cellView is now rendered/updated since it has a higher update priority.
        this.updateRequested = false;
        const { cellView, nodeSelector } = this;
        if (!cellView.isMounted()) {
            this.postponedUpdate = true;
            return 0;
        }
        this.update(cellView, nodeSelector);
        this.mount();
        this.transform();
        return 0;
    },
    findNode (cellView, nodeSelector = null) {
        let el;
        if (typeof nodeSelector === "string") [el] = cellView.findBySelector(nodeSelector);
        else if ((0, _utilMjs.isPlainObject)(nodeSelector)) {
            const isLink = cellView.model.isLink();
            const { label = null, port, selector } = nodeSelector;
            if (isLink && label !== null) // Link Label Selector
            el = cellView.findLabelNode(label, selector);
            else if (!isLink && port) // Element Port Selector
            el = cellView.findPortNode(port, selector);
            else // Cell Selector
            [el] = cellView.findBySelector(selector);
        } else if (nodeSelector) {
            el = (0, _indexMjsDefault.default).toNode(nodeSelector);
            if (!(el instanceof SVGElement)) el = null;
        }
        return el ? el : null;
    },
    getNodeMatrix (cellView, node) {
        const { options } = this;
        const { layer } = options;
        const { rotatableNode } = cellView;
        const nodeMatrix = cellView.getNodeMatrix(node);
        if (rotatableNode) {
            if (layer) {
                if (rotatableNode.contains(node)) return nodeMatrix;
                // The node is outside of the rotatable group.
                // Compensate the rotation set by transformGroup.
                return cellView.getRootRotateMatrix().inverse().multiply(nodeMatrix);
            } else return cellView.getNodeRotateMatrix(node).multiply(nodeMatrix);
        }
        return nodeMatrix;
    },
    mount () {
        const { MOUNTABLE, cellView, el, options, transformGroup, detachedTransformGroup, postponedUpdate, nodeSelector } = this;
        if (!MOUNTABLE || transformGroup) return;
        if (postponedUpdate) {
            // The cellView was not mounted when the update was requested.
            // The update was postponed until the cellView is mounted.
            this.update(cellView, nodeSelector);
            this.transform();
            return;
        }
        const { vel: cellViewRoot, paper } = cellView;
        const { layer: layerName } = options;
        if (layerName) {
            let vGroup;
            if (detachedTransformGroup) {
                vGroup = detachedTransformGroup;
                this.detachedTransformGroup = null;
            } else vGroup = (0, _indexMjsDefault.default)("g").addClass("highlight-transform").append(el);
            this.transformGroup = vGroup;
            paper.getLayerView(layerName).insertSortedNode(vGroup.node, options.z);
        } else // TODO: prepend vs append
        if (!el.parentNode || el.nextSibling) // Not appended yet or not the last child
        cellViewRoot.append(el);
    },
    unmount () {
        const { MOUNTABLE, transformGroup, vel } = this;
        if (!MOUNTABLE) return;
        if (transformGroup) {
            this.transformGroup = null;
            this.detachedTransformGroup = transformGroup;
            transformGroup.remove();
        } else vel.remove();
    },
    transform () {
        const { transformGroup, cellView, updateRequested } = this;
        if (!transformGroup || cellView.model.isLink() || updateRequested) return;
        const translateMatrix = cellView.getRootTranslateMatrix();
        const rotateMatrix = cellView.getRootRotateMatrix();
        const transformMatrix = translateMatrix.multiply(rotateMatrix);
        transformGroup.attr("transform", (0, _indexMjsDefault.default).matrixToTransformString(transformMatrix));
    },
    update () {
        const { node: prevNode, cellView, nodeSelector, updateRequested, id } = this;
        if (updateRequested) return;
        this.postponedUpdate = false;
        const node = this.node = this.findNode(cellView, nodeSelector);
        if (prevNode) this.unhighlight(cellView, prevNode);
        if (node) {
            this.highlight(cellView, node);
            this.mount();
        } else {
            this.unmount();
            cellView.notify("cell:highlight:invalid", id, this);
        }
    },
    onRemove () {
        const { node, cellView, id, constructor } = this;
        if (node) this.unhighlight(cellView, node);
        this.unmount();
        constructor._removeRef(cellView, id);
    },
    highlight (_cellView, _node) {
    // to be overridden
    },
    unhighlight (_cellView, _node) {
    // to be overridden
    },
    // Update Attributes
    listenToUpdateAttributes (cellView) {
        const attributes = (0, _utilMjs.result)(this, "UPDATE_ATTRIBUTES");
        if (!Array.isArray(attributes) || attributes.length === 0) return;
        this.listenTo(cellView.model, "change", this.onCellAttributeChange);
    },
    onCellAttributeChange () {
        const { cellView } = this;
        if (!cellView) return;
        const { model, paper } = cellView;
        const attributes = (0, _utilMjs.result)(this, "UPDATE_ATTRIBUTES");
        if (!attributes.some((attribute)=>model.hasChanged(attribute))) return;
        paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);
    }
}, {
    _views: {},
    // Used internally by CellView highlight()
    highlight: function(cellView, node, opt) {
        const id = this.uniqueId(node, opt);
        this.add(cellView, node, id, opt);
    },
    // Used internally by CellView unhighlight()
    unhighlight: function(cellView, node, opt) {
        const id = this.uniqueId(node, opt);
        this.remove(cellView, id);
    },
    get (cellView, id = null) {
        const { cid } = cellView;
        const { _views } = this;
        const refs = _views[cid];
        if (id === null) {
            // all highlighters
            const views = [];
            if (!refs) return views;
            for(let hid in refs){
                const ref = refs[hid];
                if (ref instanceof this) views.push(ref);
            }
            return views;
        } else {
            // single highlighter
            if (!refs) return null;
            if (id in refs) {
                const ref = refs[id];
                if (ref instanceof this) return ref;
            }
            return null;
        }
    },
    add (cellView, nodeSelector, id, opt = {}) {
        if (!id) throw new Error("dia.HighlighterView: An ID required.");
        // Search the existing view amongst all the highlighters
        const previousView = HighlighterView.get(cellView, id);
        if (previousView) previousView.remove();
        const view = new this(opt);
        view.id = id;
        this._addRef(cellView, id, view);
        view.requestUpdate(cellView, nodeSelector);
        view.listenToUpdateAttributes(cellView);
        return view;
    },
    _addRef (cellView, id, view) {
        const { cid } = cellView;
        const { _views } = this;
        let refs = _views[cid];
        if (!refs) refs = _views[cid] = {};
        refs[id] = view;
    },
    _removeRef (cellView, id) {
        const { cid } = cellView;
        const { _views } = this;
        const refs = _views[cid];
        if (!refs) return;
        if (id) delete refs[id];
        for(let _ in refs)return;
        delete _views[cid];
    },
    remove (cellView, id = null) {
        toArray(this.get(cellView, id)).forEach((view)=>{
            view.remove();
        });
    },
    removeAll (paper, id = null) {
        const { _views } = this;
        for(let cid in _views)for(let hid in _views[cid]){
            const view = _views[cid][hid];
            if (view.cellView.paper === paper && view instanceof this && (id === null || hid === id)) view.remove();
        }
    },
    update (cellView, id = null, dirty = false) {
        toArray(this.get(cellView, id)).forEach((view)=>{
            if (dirty || view.UPDATABLE) view.update();
        });
    },
    transform (cellView, id = null) {
        toArray(this.get(cellView, id)).forEach((view)=>{
            if (view.UPDATABLE) view.transform();
        });
    },
    unmount (cellView, id = null) {
        toArray(this.get(cellView, id)).forEach((view)=>view.unmount());
    },
    mount (cellView, id = null) {
        toArray(this.get(cellView, id)).forEach((view)=>view.mount());
    },
    uniqueId (node, opt = "") {
        return (0, _indexMjsDefault.default).ensureId(node) + JSON.stringify(opt);
    }
});

},{"../mvc/index.mjs":"c2o6n","../V/index.mjs":"iw8UN","../util/util.mjs":"5j2Qt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Ex7a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "env", ()=>env);
const env = {
    _results: {},
    _tests: {
        svgforeignobject: function() {
            return !!document.createElementNS && /SVGForeignObject/.test(({}).toString.call(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")));
        }
    },
    addTest: function(name, fn) {
        return this._tests[name] = fn;
    },
    test: function(name) {
        var fn = this._tests[name];
        if (!fn) throw new Error('Test not defined ("' + name + '"). Use `joint.env.addTest(name, fn) to add a new test.`');
        var result = this._results[name];
        if (typeof result !== "undefined") return result;
        try {
            result = fn();
        } catch (error) {
            result = false;
        }
        // Cache the test result.
        this._results[name] = result;
        return result;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bIoDe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Rectangle", ()=>Rectangle);
parcelHelpers.export(exports, "Circle", ()=>Circle);
parcelHelpers.export(exports, "Ellipse", ()=>Ellipse);
parcelHelpers.export(exports, "Path", ()=>Path);
parcelHelpers.export(exports, "Polygon", ()=>Polygon);
parcelHelpers.export(exports, "Polyline", ()=>Polyline);
parcelHelpers.export(exports, "Image", ()=>Image);
parcelHelpers.export(exports, "BorderedImage", ()=>BorderedImage);
parcelHelpers.export(exports, "EmbeddedImage", ()=>EmbeddedImage);
parcelHelpers.export(exports, "InscribedImage", ()=>InscribedImage);
parcelHelpers.export(exports, "HeaderedRectangle", ()=>HeaderedRectangle);
parcelHelpers.export(exports, "Cylinder", ()=>Cylinder);
parcelHelpers.export(exports, "TextBlock", ()=>TextBlock);
parcelHelpers.export(exports, "Link", ()=>Link);
parcelHelpers.export(exports, "DoubleLink", ()=>DoubleLink);
parcelHelpers.export(exports, "ShadowLink", ()=>ShadowLink);
var _indexMjs = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _elementMjs = require("../dia/Element.mjs");
var _linkMjs = require("../dia/Link.mjs");
var _indexMjs1 = require("../util/index.mjs");
var _indexMjs2 = require("../dia/attributes/index.mjs");
var _indexMjs3 = require("../env/index.mjs");
const Rectangle = (0, _elementMjs.Element).define("standard.Rectangle", {
    attrs: {
        body: {
            refWidth: "100%",
            refHeight: "100%",
            strokeWidth: 2,
            stroke: "#000000",
            fill: "#FFFFFF"
        },
        label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            refX: "50%",
            refY: "50%",
            fontSize: 14,
            fill: "#333333"
        }
    }
}, {
    markup: [
        {
            tagName: "rect",
            selector: "body"
        },
        {
            tagName: "text",
            selector: "label"
        }
    ]
});
const Circle = (0, _elementMjs.Element).define("standard.Circle", {
    attrs: {
        body: {
            refCx: "50%",
            refCy: "50%",
            refR: "50%",
            strokeWidth: 2,
            stroke: "#333333",
            fill: "#FFFFFF"
        },
        label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            refX: "50%",
            refY: "50%",
            fontSize: 14,
            fill: "#333333"
        }
    }
}, {
    markup: [
        {
            tagName: "circle",
            selector: "body"
        },
        {
            tagName: "text",
            selector: "label"
        }
    ]
});
const Ellipse = (0, _elementMjs.Element).define("standard.Ellipse", {
    attrs: {
        body: {
            refCx: "50%",
            refCy: "50%",
            refRx: "50%",
            refRy: "50%",
            strokeWidth: 2,
            stroke: "#333333",
            fill: "#FFFFFF"
        },
        label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            refX: "50%",
            refY: "50%",
            fontSize: 14,
            fill: "#333333"
        }
    }
}, {
    markup: [
        {
            tagName: "ellipse",
            selector: "body"
        },
        {
            tagName: "text",
            selector: "label"
        }
    ]
});
const Path = (0, _elementMjs.Element).define("standard.Path", {
    attrs: {
        body: {
            refD: "M 0 0 L 10 0 10 10 0 10 Z",
            strokeWidth: 2,
            stroke: "#333333",
            fill: "#FFFFFF"
        },
        label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            refX: "50%",
            refY: "50%",
            fontSize: 14,
            fill: "#333333"
        }
    }
}, {
    markup: [
        {
            tagName: "path",
            selector: "body"
        },
        {
            tagName: "text",
            selector: "label"
        }
    ]
});
const Polygon = (0, _elementMjs.Element).define("standard.Polygon", {
    attrs: {
        body: {
            refPoints: "0 0 10 0 10 10 0 10",
            strokeWidth: 2,
            stroke: "#333333",
            fill: "#FFFFFF"
        },
        label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            refX: "50%",
            refY: "50%",
            fontSize: 14,
            fill: "#333333"
        }
    }
}, {
    markup: [
        {
            tagName: "polygon",
            selector: "body"
        },
        {
            tagName: "text",
            selector: "label"
        }
    ]
});
const Polyline = (0, _elementMjs.Element).define("standard.Polyline", {
    attrs: {
        body: {
            refPoints: "0 0 10 0 10 10 0 10 0 0",
            strokeWidth: 2,
            stroke: "#333333",
            fill: "#FFFFFF"
        },
        label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            refX: "50%",
            refY: "50%",
            fontSize: 14,
            fill: "#333333"
        }
    }
}, {
    markup: [
        {
            tagName: "polyline",
            selector: "body"
        },
        {
            tagName: "text",
            selector: "label"
        }
    ]
});
const Image = (0, _elementMjs.Element).define("standard.Image", {
    attrs: {
        image: {
            refWidth: "100%",
            refHeight: "100%"
        },
        label: {
            textVerticalAnchor: "top",
            textAnchor: "middle",
            refX: "50%",
            refY: "100%",
            refY2: 10,
            fontSize: 14,
            fill: "#333333"
        }
    }
}, {
    markup: [
        {
            tagName: "image",
            selector: "image"
        },
        {
            tagName: "text",
            selector: "label"
        }
    ]
});
const BorderedImage = (0, _elementMjs.Element).define("standard.BorderedImage", {
    attrs: {
        border: {
            refWidth: "100%",
            refHeight: "100%",
            stroke: "#333333",
            strokeWidth: 2
        },
        background: {
            refWidth: -1,
            refHeight: -1,
            x: 0.5,
            y: 0.5,
            fill: "#FFFFFF"
        },
        image: {
            // xlinkHref: '[URL]'
            refWidth: -1,
            refHeight: -1,
            x: 0.5,
            y: 0.5
        },
        label: {
            textVerticalAnchor: "top",
            textAnchor: "middle",
            refX: "50%",
            refY: "100%",
            refY2: 10,
            fontSize: 14,
            fill: "#333333"
        }
    }
}, {
    markup: [
        {
            tagName: "rect",
            selector: "background",
            attributes: {
                "stroke": "none"
            }
        },
        {
            tagName: "image",
            selector: "image"
        },
        {
            tagName: "rect",
            selector: "border",
            attributes: {
                "fill": "none"
            }
        },
        {
            tagName: "text",
            selector: "label"
        }
    ]
});
const EmbeddedImage = (0, _elementMjs.Element).define("standard.EmbeddedImage", {
    attrs: {
        body: {
            refWidth: "100%",
            refHeight: "100%",
            stroke: "#333333",
            fill: "#FFFFFF",
            strokeWidth: 2
        },
        image: {
            // xlinkHref: '[URL]'
            refWidth: "30%",
            refHeight: -20,
            x: 10,
            y: 10,
            preserveAspectRatio: "xMidYMin"
        },
        label: {
            textVerticalAnchor: "top",
            textAnchor: "left",
            refX: "30%",
            refX2: 20,
            refY: 10,
            fontSize: 14,
            fill: "#333333"
        }
    }
}, {
    markup: [
        {
            tagName: "rect",
            selector: "body"
        },
        {
            tagName: "image",
            selector: "image"
        },
        {
            tagName: "text",
            selector: "label"
        }
    ]
});
const InscribedImage = (0, _elementMjs.Element).define("standard.InscribedImage", {
    attrs: {
        border: {
            refRx: "50%",
            refRy: "50%",
            refCx: "50%",
            refCy: "50%",
            stroke: "#333333",
            strokeWidth: 2
        },
        background: {
            refRx: "50%",
            refRy: "50%",
            refCx: "50%",
            refCy: "50%",
            fill: "#FFFFFF"
        },
        image: {
            // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%
            refWidth: "68%",
            refHeight: "68%",
            // The image offset is calculated as (100% - 68%) / 2
            refX: "16%",
            refY: "16%",
            preserveAspectRatio: "xMidYMid"
        },
        label: {
            textVerticalAnchor: "top",
            textAnchor: "middle",
            refX: "50%",
            refY: "100%",
            refY2: 10,
            fontSize: 14,
            fill: "#333333"
        }
    }
}, {
    markup: [
        {
            tagName: "ellipse",
            selector: "background"
        },
        {
            tagName: "image",
            selector: "image"
        },
        {
            tagName: "ellipse",
            selector: "border",
            attributes: {
                "fill": "none"
            }
        },
        {
            tagName: "text",
            selector: "label"
        }
    ]
});
const HeaderedRectangle = (0, _elementMjs.Element).define("standard.HeaderedRectangle", {
    attrs: {
        body: {
            refWidth: "100%",
            refHeight: "100%",
            strokeWidth: 2,
            stroke: "#000000",
            fill: "#FFFFFF"
        },
        header: {
            refWidth: "100%",
            height: 30,
            strokeWidth: 2,
            stroke: "#000000",
            fill: "#FFFFFF"
        },
        headerText: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            refX: "50%",
            refY: 15,
            fontSize: 16,
            fill: "#333333"
        },
        bodyText: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            refX: "50%",
            refY: "50%",
            refY2: 15,
            fontSize: 14,
            fill: "#333333"
        }
    }
}, {
    markup: [
        {
            tagName: "rect",
            selector: "body"
        },
        {
            tagName: "rect",
            selector: "header"
        },
        {
            tagName: "text",
            selector: "headerText"
        },
        {
            tagName: "text",
            selector: "bodyText"
        }
    ]
});
var CYLINDER_TILT = 10;
const Cylinder = (0, _elementMjs.Element).define("standard.Cylinder", {
    attrs: {
        body: {
            lateralArea: CYLINDER_TILT,
            fill: "#FFFFFF",
            stroke: "#333333",
            strokeWidth: 2
        },
        top: {
            refCx: "50%",
            cy: CYLINDER_TILT,
            refRx: "50%",
            ry: CYLINDER_TILT,
            fill: "#FFFFFF",
            stroke: "#333333",
            strokeWidth: 2
        },
        label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            refX: "50%",
            refY: "100%",
            refY2: 15,
            fontSize: 14,
            fill: "#333333"
        }
    }
}, {
    markup: [
        {
            tagName: "path",
            selector: "body"
        },
        {
            tagName: "ellipse",
            selector: "top"
        },
        {
            tagName: "text",
            selector: "label"
        }
    ],
    topRy: function(t, opt) {
        // getter
        if (t === undefined) return this.attr("body/lateralArea");
        // setter
        var isPercentageSetter = (0, _indexMjs1.isPercentage)(t);
        var bodyAttrs = {
            lateralArea: t
        };
        var topAttrs = isPercentageSetter ? {
            refCy: t,
            refRy: t,
            cy: null,
            ry: null
        } : {
            refCy: null,
            refRy: null,
            cy: t,
            ry: t
        };
        return this.attr({
            body: bodyAttrs,
            top: topAttrs
        }, opt);
    }
}, {
    attributes: {
        lateralArea: {
            set: function(t, refBBox) {
                var isPercentageSetter = (0, _indexMjs1.isPercentage)(t);
                if (isPercentageSetter) t = parseFloat(t) / 100;
                var x = refBBox.x;
                var y = refBBox.y;
                var w = refBBox.width;
                var h = refBBox.height;
                // curve control point variables
                var rx = w / 2;
                var ry = isPercentageSetter ? h * t : t;
                var kappa = (0, _indexMjsDefault.default).KAPPA;
                var cx = kappa * rx;
                var cy = kappa * (isPercentageSetter ? h * t : t);
                // shape variables
                var xLeft = x;
                var xCenter = x + w / 2;
                var xRight = x + w;
                var ySideTop = y + ry;
                var yCurveTop = ySideTop - ry;
                var ySideBottom = y + h - ry;
                var yCurveBottom = y + h;
                // return calculated shape
                var data = [
                    "M",
                    xLeft,
                    ySideTop,
                    "L",
                    xLeft,
                    ySideBottom,
                    "C",
                    x,
                    ySideBottom + cy,
                    xCenter - cx,
                    yCurveBottom,
                    xCenter,
                    yCurveBottom,
                    "C",
                    xCenter + cx,
                    yCurveBottom,
                    xRight,
                    ySideBottom + cy,
                    xRight,
                    ySideBottom,
                    "L",
                    xRight,
                    ySideTop,
                    "C",
                    xRight,
                    ySideTop - cy,
                    xCenter + cx,
                    yCurveTop,
                    xCenter,
                    yCurveTop,
                    "C",
                    xCenter - cx,
                    yCurveTop,
                    xLeft,
                    ySideTop - cy,
                    xLeft,
                    ySideTop,
                    "Z"
                ];
                return {
                    d: data.join(" ")
                };
            }
        }
    }
});
var foLabelMarkup = {
    tagName: "foreignObject",
    selector: "foreignObject",
    attributes: {
        "overflow": "hidden"
    },
    children: [
        {
            tagName: "div",
            namespaceURI: "http://www.w3.org/1999/xhtml",
            selector: "label",
            style: {
                width: "100%",
                height: "100%",
                position: "static",
                backgroundColor: "transparent",
                textAlign: "center",
                margin: 0,
                padding: "0px 5px",
                boxSizing: "border-box",
                display: "flex",
                alignItems: "center",
                justifyContent: "center"
            }
        }
    ]
};
var svgLabelMarkup = {
    tagName: "text",
    selector: "label",
    attributes: {
        "text-anchor": "middle"
    }
};
var labelMarkup = (0, _indexMjs3.env).test("svgforeignobject") ? foLabelMarkup : svgLabelMarkup;
const TextBlock = (0, _elementMjs.Element).define("standard.TextBlock", {
    attrs: {
        body: {
            refWidth: "100%",
            refHeight: "100%",
            stroke: "#333333",
            fill: "#ffffff",
            strokeWidth: 2
        },
        foreignObject: {
            refWidth: "100%",
            refHeight: "100%"
        },
        label: {
            style: {
                fontSize: 14
            }
        }
    }
}, {
    markup: [
        {
            tagName: "rect",
            selector: "body"
        },
        labelMarkup
    ]
}, {
    attributes: {
        text: {
            set: function(text, refBBox, node, attrs) {
                if (node instanceof HTMLElement) node.textContent = text;
                else {
                    // No foreign object
                    var style = attrs.style || {};
                    var wrapValue = {
                        text: text,
                        width: -5,
                        height: "100%"
                    };
                    var wrapAttrs = (0, _indexMjs1.assign)({
                        textVerticalAnchor: "middle"
                    }, style);
                    (0, _indexMjs2.attributes).textWrap.set.call(this, wrapValue, refBBox, node, wrapAttrs);
                    return {
                        fill: style.color || null
                    };
                }
            },
            position: function(text, refBBox, node) {
                // No foreign object
                if (node instanceof SVGElement) return refBBox.center();
            }
        }
    }
});
const Link = (0, _linkMjs.Link).define("standard.Link", {
    attrs: {
        line: {
            connection: true,
            stroke: "#333333",
            strokeWidth: 2,
            strokeLinejoin: "round",
            targetMarker: {
                "type": "path",
                "d": "M 10 -5 0 0 10 5 z"
            }
        },
        wrapper: {
            connection: true,
            strokeWidth: 10,
            strokeLinejoin: "round"
        }
    }
}, {
    markup: [
        {
            tagName: "path",
            selector: "wrapper",
            attributes: {
                "fill": "none",
                "cursor": "pointer",
                "stroke": "transparent",
                "stroke-linecap": "round"
            }
        },
        {
            tagName: "path",
            selector: "line",
            attributes: {
                "fill": "none",
                "pointer-events": "none"
            }
        }
    ]
});
const DoubleLink = (0, _linkMjs.Link).define("standard.DoubleLink", {
    attrs: {
        line: {
            connection: true,
            stroke: "#DDDDDD",
            strokeWidth: 4,
            strokeLinejoin: "round",
            targetMarker: {
                type: "path",
                stroke: "#000000",
                d: "M 10 -3 10 -10 -2 0 10 10 10 3"
            }
        },
        outline: {
            connection: true,
            stroke: "#000000",
            strokeWidth: 6,
            strokeLinejoin: "round"
        }
    }
}, {
    markup: [
        {
            tagName: "path",
            selector: "outline",
            attributes: {
                "fill": "none"
            }
        },
        {
            tagName: "path",
            selector: "line",
            attributes: {
                "fill": "none"
            }
        }
    ]
});
const ShadowLink = (0, _linkMjs.Link).define("standard.ShadowLink", {
    attrs: {
        line: {
            connection: true,
            stroke: "#FF0000",
            strokeWidth: 20,
            strokeLinejoin: "round",
            targetMarker: {
                "type": "path",
                "stroke": "none",
                "d": "M 0 -10 -10 0 0 10 z"
            },
            sourceMarker: {
                "type": "path",
                "stroke": "none",
                "d": "M -10 -10 0 0 -10 10 0 10 0 -10 z"
            }
        },
        shadow: {
            connection: true,
            refX: 3,
            refY: 6,
            stroke: "#000000",
            strokeOpacity: 0.2,
            strokeWidth: 20,
            strokeLinejoin: "round",
            targetMarker: {
                "type": "path",
                "d": "M 0 -10 -10 0 0 10 z",
                "stroke": "none"
            },
            sourceMarker: {
                "type": "path",
                "stroke": "none",
                "d": "M -10 -10 0 0 -10 10 0 10 0 -10 z"
            }
        }
    }
}, {
    markup: [
        {
            tagName: "path",
            selector: "shadow",
            attributes: {
                "fill": "none"
            }
        },
        {
            tagName: "path",
            selector: "line",
            attributes: {
                "fill": "none"
            }
        }
    ]
});

},{"../V/index.mjs":"iw8UN","../dia/Element.mjs":"hcQWn","../dia/Link.mjs":"kX2vg","../util/index.mjs":"eL7pI","../dia/attributes/index.mjs":"9p63m","../env/index.mjs":"1Ex7a","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kX2vg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Link", ()=>Link);
var _cellMjs = require("./Cell.mjs");
var _indexMjs = require("../util/index.mjs");
var _indexMjs1 = require("../g/index.mjs");
const Link = (0, _cellMjs.Cell).extend({
    // The default markup for links.
    markup: [
        '<path class="connection" stroke="black" d="M 0 0 0 0"/>',
        '<path class="marker-source" fill="black" stroke="black" d="M 0 0 0 0"/>',
        '<path class="marker-target" fill="black" stroke="black" d="M 0 0 0 0"/>',
        '<path class="connection-wrap" d="M 0 0 0 0"/>',
        '<g class="labels"/>',
        '<g class="marker-vertices"/>',
        '<g class="marker-arrowheads"/>',
        '<g class="link-tools"/>'
    ].join(""),
    toolMarkup: [
        '<g class="link-tool">',
        '<g class="tool-remove" event="remove">',
        '<circle r="11" />',
        '<path transform="scale(.8) translate(-16, -16)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z" />',
        "<title>Remove link.</title>",
        "</g>",
        '<g class="tool-options" event="link:options">',
        '<circle r="11" transform="translate(25)"/>',
        '<path fill="white" transform="scale(.55) translate(29, -16)" d="M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z"/>',
        "<title>Link options.</title>",
        "</g>",
        "</g>"
    ].join(""),
    doubleToolMarkup: undefined,
    // The default markup for showing/removing vertices. These elements are the children of the .marker-vertices element (see `this.markup`).
    // Only .marker-vertex and .marker-vertex-remove element have special meaning. The former is used for
    // dragging vertices (changing their position). The latter is used for removing vertices.
    vertexMarkup: [
        '<g class="marker-vertex-group" transform="translate(<%= x %>, <%= y %>)">',
        '<circle class="marker-vertex" idx="<%= idx %>" r="10" />',
        '<path class="marker-vertex-remove-area" idx="<%= idx %>" d="M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z" transform="translate(5, -33)"/>',
        '<path class="marker-vertex-remove" idx="<%= idx %>" transform="scale(.8) translate(9.5, -37)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z">',
        "<title>Remove vertex.</title>",
        "</path>",
        "</g>"
    ].join(""),
    arrowheadMarkup: [
        '<g class="marker-arrowhead-group marker-arrowhead-group-<%= end %>">',
        '<path class="marker-arrowhead" end="<%= end %>" d="M 26 0 L 0 13 L 26 26 z" />',
        "</g>"
    ].join(""),
    // may be overwritten by user to change default label (its markup, size, attrs, position)
    defaultLabel: undefined,
    // deprecated
    // may be overwritten by user to change default label markup
    // lower priority than defaultLabel.markup
    labelMarkup: undefined,
    // private
    _builtins: {
        defaultLabel: {
            // builtin default markup:
            // used if neither defaultLabel.markup
            // nor label.markup is set
            markup: [
                {
                    tagName: "rect",
                    selector: "rect" // faster than tagName CSS selector
                },
                {
                    tagName: "text",
                    selector: "text" // faster than tagName CSS selector
                }
            ],
            // builtin default attributes:
            // applied only if builtin default markup is used
            attrs: {
                text: {
                    fill: "#000000",
                    fontSize: 14,
                    textAnchor: "middle",
                    yAlignment: "middle",
                    pointerEvents: "none"
                },
                rect: {
                    ref: "text",
                    fill: "#ffffff",
                    rx: 3,
                    ry: 3,
                    refWidth: 1,
                    refHeight: 1,
                    refX: 0,
                    refY: 0
                }
            },
            // builtin default position:
            // used if neither defaultLabel.position
            // nor label.position is set
            position: {
                distance: 0.5
            }
        }
    },
    defaults: {
        type: "link",
        source: {},
        target: {}
    },
    isLink: function() {
        return true;
    },
    disconnect: function(opt) {
        return this.set({
            source: {
                x: 0,
                y: 0
            },
            target: {
                x: 0,
                y: 0
            }
        }, opt);
    },
    source: function(source, args, opt) {
        // getter
        if (source === undefined) return (0, _indexMjs.clone)(this.get("source"));
        // setter
        var setSource;
        var setOpt;
        // `source` is a cell
        // take only its `id` and combine with `args`
        var isCellProvided = source instanceof (0, _cellMjs.Cell);
        if (isCellProvided) {
            setSource = (0, _indexMjs.clone)(args) || {};
            setSource.id = source.id;
            setOpt = opt;
            return this.set("source", setSource, setOpt);
        }
        // `source` is a point-like object
        // for example, a g.Point
        // take only its `x` and `y` and combine with `args`
        var isPointProvided = !(0, _indexMjs.isPlainObject)(source);
        if (isPointProvided) {
            setSource = (0, _indexMjs.clone)(args) || {};
            setSource.x = source.x;
            setSource.y = source.y;
            setOpt = opt;
            return this.set("source", setSource, setOpt);
        }
        // `source` is an object
        // no checking
        // two arguments
        setSource = source;
        setOpt = args;
        return this.set("source", setSource, setOpt);
    },
    target: function(target, args, opt) {
        // getter
        if (target === undefined) return (0, _indexMjs.clone)(this.get("target"));
        // setter
        var setTarget;
        var setOpt;
        // `target` is a cell
        // take only its `id` argument and combine with `args`
        var isCellProvided = target instanceof (0, _cellMjs.Cell);
        if (isCellProvided) {
            setTarget = (0, _indexMjs.clone)(args) || {};
            setTarget.id = target.id;
            setOpt = opt;
            return this.set("target", setTarget, setOpt);
        }
        // `target` is a point-like object
        // for example, a g.Point
        // take only its `x` and `y` and combine with `args`
        var isPointProvided = !(0, _indexMjs.isPlainObject)(target);
        if (isPointProvided) {
            setTarget = (0, _indexMjs.clone)(args) || {};
            setTarget.x = target.x;
            setTarget.y = target.y;
            setOpt = opt;
            return this.set("target", setTarget, setOpt);
        }
        // `target` is an object
        // no checking
        // two arguments
        setTarget = target;
        setOpt = args;
        return this.set("target", setTarget, setOpt);
    },
    router: function(name, args, opt) {
        // getter
        if (name === undefined) {
            var router = this.get("router");
            if (!router) {
                if (this.get("manhattan")) return {
                    name: "orthogonal"
                }; // backwards compatibility
                return null;
            }
            if (typeof router === "object") return (0, _indexMjs.clone)(router);
            return router; // e.g. a function
        }
        // setter
        var isRouterProvided = typeof name === "object" || typeof name === "function";
        var localRouter = isRouterProvided ? name : {
            name: name,
            args: args
        };
        var localOpt = isRouterProvided ? args : opt;
        return this.set("router", localRouter, localOpt);
    },
    connector: function(name, args, opt) {
        // getter
        if (name === undefined) {
            var connector = this.get("connector");
            if (!connector) {
                if (this.get("smooth")) return {
                    name: "smooth"
                }; // backwards compatibility
                return null;
            }
            if (typeof connector === "object") return (0, _indexMjs.clone)(connector);
            return connector; // e.g. a function
        }
        // setter
        var isConnectorProvided = typeof name === "object" || typeof name === "function";
        var localConnector = isConnectorProvided ? name : {
            name: name,
            args: args
        };
        var localOpt = isConnectorProvided ? args : opt;
        return this.set("connector", localConnector, localOpt);
    },
    // Labels API
    // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.
    label: function(idx, label, opt) {
        var labels = this.labels();
        idx = isFinite(idx) && idx !== null ? idx | 0 : 0;
        if (idx < 0) idx = labels.length + idx;
        // getter
        if (arguments.length <= 1) return this.prop([
            "labels",
            idx
        ]);
        // setter
        return this.prop([
            "labels",
            idx
        ], label, opt);
    },
    labels: function(labels, opt) {
        // getter
        if (arguments.length === 0) {
            labels = this.get("labels");
            if (!Array.isArray(labels)) return [];
            return labels.slice();
        }
        // setter
        if (!Array.isArray(labels)) labels = [];
        return this.set("labels", labels, opt);
    },
    hasLabels: function() {
        const { labels } = this.attributes;
        return Array.isArray(labels) && labels.length > 0;
    },
    insertLabel: function(idx, label, opt) {
        if (!label) throw new Error("dia.Link: no label provided");
        var labels = this.labels();
        var n = labels.length;
        idx = isFinite(idx) && idx !== null ? idx | 0 : n;
        if (idx < 0) idx = n + idx + 1;
        labels.splice(idx, 0, label);
        return this.labels(labels, opt);
    },
    // convenience function
    // add label to end of labels array
    appendLabel: function(label, opt) {
        return this.insertLabel(-1, label, opt);
    },
    removeLabel: function(idx, opt) {
        var labels = this.labels();
        idx = isFinite(idx) && idx !== null ? idx | 0 : -1;
        labels.splice(idx, 1);
        return this.labels(labels, opt);
    },
    // Vertices API
    vertex: function(idx, vertex, opt) {
        var vertices = this.vertices();
        idx = isFinite(idx) && idx !== null ? idx | 0 : 0;
        if (idx < 0) idx = vertices.length + idx;
        // getter
        if (arguments.length <= 1) return this.prop([
            "vertices",
            idx
        ]);
        // setter
        var setVertex = this._normalizeVertex(vertex);
        return this.prop([
            "vertices",
            idx
        ], setVertex, opt);
    },
    vertices: function(vertices, opt) {
        // getter
        if (arguments.length === 0) {
            vertices = this.get("vertices");
            if (!Array.isArray(vertices)) return [];
            return vertices.slice();
        }
        // setter
        if (!Array.isArray(vertices)) vertices = [];
        var setVertices = [];
        for(var i = 0; i < vertices.length; i++){
            var vertex = vertices[i];
            var setVertex = this._normalizeVertex(vertex);
            setVertices.push(setVertex);
        }
        return this.set("vertices", setVertices, opt);
    },
    insertVertex: function(idx, vertex, opt) {
        if (!vertex) throw new Error("dia.Link: no vertex provided");
        var vertices = this.vertices();
        var n = vertices.length;
        idx = isFinite(idx) && idx !== null ? idx | 0 : n;
        if (idx < 0) idx = n + idx + 1;
        var setVertex = this._normalizeVertex(vertex);
        vertices.splice(idx, 0, setVertex);
        return this.vertices(vertices, opt);
    },
    removeVertex: function(idx, opt) {
        var vertices = this.vertices();
        idx = isFinite(idx) && idx !== null ? idx | 0 : -1;
        vertices.splice(idx, 1);
        return this.vertices(vertices, opt);
    },
    _normalizeVertex: function(vertex) {
        // is vertex a point-like object?
        // for example, a g.Point
        var isPointProvided = !(0, _indexMjs.isPlainObject)(vertex);
        if (isPointProvided) return {
            x: vertex.x,
            y: vertex.y
        };
        // else: return vertex unchanged
        return vertex;
    },
    // Transformations
    translate: function(tx, ty, opt) {
        // enrich the option object
        opt = opt || {};
        opt.translateBy = opt.translateBy || this.id;
        opt.tx = tx;
        opt.ty = ty;
        return this.applyToPoints(function(p) {
            return {
                x: (p.x || 0) + tx,
                y: (p.y || 0) + ty
            };
        }, opt);
    },
    scale: function(sx, sy, origin, opt) {
        return this.applyToPoints(function(p) {
            return (0, _indexMjs1.Point)(p).scale(sx, sy, origin).toJSON();
        }, opt);
    },
    applyToPoints: function(fn, opt) {
        if (!(0, _indexMjs.isFunction)(fn)) throw new TypeError("dia.Link: applyToPoints expects its first parameter to be a function.");
        var attrs = {};
        var { source, target } = this.attributes;
        if (!source.id) attrs.source = fn(source);
        if (!target.id) attrs.target = fn(target);
        var vertices = this.vertices();
        if (vertices.length > 0) attrs.vertices = vertices.map(fn);
        return this.set(attrs, opt);
    },
    getSourcePoint: function() {
        var sourceCell = this.getSourceCell();
        if (!sourceCell) return new (0, _indexMjs1.Point)(this.source());
        return sourceCell.getPointFromConnectedLink(this, "source");
    },
    getTargetPoint: function() {
        var targetCell = this.getTargetCell();
        if (!targetCell) return new (0, _indexMjs1.Point)(this.target());
        return targetCell.getPointFromConnectedLink(this, "target");
    },
    getPointFromConnectedLink: function() {
        return this.getPolyline().pointAt(0.5);
    },
    getPolyline: function() {
        const points = [
            this.getSourcePoint(),
            ...this.vertices().map((0, _indexMjs1.Point)),
            this.getTargetPoint()
        ];
        return new (0, _indexMjs1.Polyline)(points);
    },
    getBBox: function() {
        return this.getPolyline().bbox();
    },
    reparent: function(opt) {
        var newParent;
        if (this.graph) {
            var source = this.getSourceElement();
            var target = this.getTargetElement();
            var prevParent = this.getParentCell();
            if (source && target) {
                if (source === target || source.isEmbeddedIn(target)) newParent = target;
                else if (target.isEmbeddedIn(source)) newParent = source;
                else newParent = this.graph.getCommonAncestor(source, target);
            }
            if (prevParent && (!newParent || newParent.id !== prevParent.id)) // Unembed the link if source and target has no common ancestor
            // or common ancestor changed
            prevParent.unembed(this, opt);
            if (newParent) newParent.embed(this, opt);
        }
        return newParent;
    },
    hasLoop: function(opt) {
        opt = opt || {};
        var { source, target } = this.attributes;
        var sourceId = source.id;
        var targetId = target.id;
        if (!sourceId || !targetId) // Link "pinned" to the paper does not have a loop.
        return false;
        var loop = sourceId === targetId;
        // Note that there in the deep mode a link can have a loop,
        // even if it connects only a parent and its embed.
        // A loop "target equals source" is valid in both shallow and deep mode.
        if (!loop && opt.deep && this.graph) {
            var sourceElement = this.getSourceCell();
            var targetElement = this.getTargetCell();
            loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);
        }
        return loop;
    },
    // unlike source(), this method returns null if source is a point
    getSourceCell: function() {
        const { graph, attributes } = this;
        var source = attributes.source;
        return source && source.id && graph && graph.getCell(source.id) || null;
    },
    getSourceElement: function() {
        var cell = this;
        var visited = {};
        do {
            if (visited[cell.id]) return null;
            visited[cell.id] = true;
            cell = cell.getSourceCell();
        }while (cell && cell.isLink());
        return cell;
    },
    // unlike target(), this method returns null if target is a point
    getTargetCell: function() {
        const { graph, attributes } = this;
        var target = attributes.target;
        return target && target.id && graph && graph.getCell(target.id) || null;
    },
    getTargetElement: function() {
        var cell = this;
        var visited = {};
        do {
            if (visited[cell.id]) return null;
            visited[cell.id] = true;
            cell = cell.getTargetCell();
        }while (cell && cell.isLink());
        return cell;
    },
    // Returns the common ancestor for the source element,
    // target element and the link itself.
    getRelationshipAncestor: function() {
        var connectionAncestor;
        if (this.graph) {
            var cells = [
                this,
                this.getSourceElement(),
                this.getTargetElement() // null if target is a point
            ].filter(function(item) {
                return !!item;
            });
            connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);
        }
        return connectionAncestor || null;
    },
    // Is source, target and the link itself embedded in a given cell?
    isRelationshipEmbeddedIn: function(cell) {
        var cellId = (0, _indexMjs.isString)(cell) || (0, _indexMjs.isNumber)(cell) ? cell : cell.id;
        var ancestor = this.getRelationshipAncestor();
        return !!ancestor && (ancestor.id === cellId || ancestor.isEmbeddedIn(cellId));
    },
    // Get resolved default label.
    _getDefaultLabel: function() {
        var defaultLabel = this.get("defaultLabel") || this.defaultLabel || {};
        var label = {};
        label.markup = defaultLabel.markup || this.get("labelMarkup") || this.labelMarkup;
        label.position = defaultLabel.position;
        label.attrs = defaultLabel.attrs;
        label.size = defaultLabel.size;
        return label;
    }
}, {
    endsEqual: function(a, b) {
        var portsEqual = a.port === b.port || !a.port && !b.port;
        return a.id === b.id && portsEqual;
    }
});

},{"./Cell.mjs":"vHapP","../util/index.mjs":"eL7pI","../g/index.mjs":"i91Db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"VCKG3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Model", ()=>Model);
parcelHelpers.export(exports, "Atomic", ()=>Atomic);
parcelHelpers.export(exports, "Coupled", ()=>Coupled);
parcelHelpers.export(exports, "Link", ()=>Link);
var _basicMjs = require("./basic.mjs");
var _linkMjs = require("../dia/Link.mjs");
var _indexMjs = require("../util/index.mjs");
const Model = (0, _basicMjs.Generic).define("devs.Model", {
    inPorts: [],
    outPorts: [],
    size: {
        width: 80,
        height: 80
    },
    attrs: {
        ".": {
            magnet: false
        },
        ".label": {
            text: "Model",
            "ref-x": .5,
            "ref-y": 10,
            "font-size": 18,
            "text-anchor": "middle",
            fill: "#000"
        },
        ".body": {
            "ref-width": "100%",
            "ref-height": "100%",
            stroke: "#000"
        }
    },
    ports: {
        groups: {
            "in": {
                position: {
                    name: "left"
                },
                attrs: {
                    ".port-label": {
                        fill: "#000"
                    },
                    ".port-body": {
                        fill: "#fff",
                        stroke: "#000",
                        r: 10,
                        magnet: true
                    }
                },
                label: {
                    position: {
                        name: "left",
                        args: {
                            y: 10
                        }
                    }
                }
            },
            "out": {
                position: {
                    name: "right"
                },
                attrs: {
                    ".port-label": {
                        fill: "#000"
                    },
                    ".port-body": {
                        fill: "#fff",
                        stroke: "#000",
                        r: 10,
                        magnet: true
                    }
                },
                label: {
                    position: {
                        name: "right",
                        args: {
                            y: 10
                        }
                    }
                }
            }
        }
    }
}, {
    markup: '<g class="rotatable"><rect class="body"/><text class="label"/></g>',
    portMarkup: '<circle class="port-body"/>',
    portLabelMarkup: '<text class="port-label"/>',
    initialize: function() {
        (0, _basicMjs.Generic).prototype.initialize.apply(this, arguments);
        this.on("change:inPorts change:outPorts", this.updatePortItems, this);
        this.updatePortItems();
    },
    updatePortItems: function(model, changed, opt) {
        // Make sure all ports are unique.
        var inPorts = (0, _indexMjs.uniq)(this.get("inPorts"));
        var outPorts = (0, _indexMjs.difference)((0, _indexMjs.uniq)(this.get("outPorts")), inPorts);
        var inPortItems = this.createPortItems("in", inPorts);
        var outPortItems = this.createPortItems("out", outPorts);
        this.prop("ports/items", inPortItems.concat(outPortItems), (0, _indexMjs.assign)({
            rewrite: true
        }, opt));
    },
    createPortItem: function(group, port) {
        return {
            id: port,
            group: group,
            attrs: {
                ".port-label": {
                    text: port
                }
            }
        };
    },
    createPortItems: function(group, ports) {
        return (0, _indexMjs.toArray)(ports).map(this.createPortItem.bind(this, group));
    },
    _addGroupPort: function(port, group, opt) {
        var ports = this.get(group);
        return this.set(group, Array.isArray(ports) ? ports.concat(port) : [
            port
        ], opt);
    },
    addOutPort: function(port, opt) {
        return this._addGroupPort(port, "outPorts", opt);
    },
    addInPort: function(port, opt) {
        return this._addGroupPort(port, "inPorts", opt);
    },
    _removeGroupPort: function(port, group, opt) {
        return this.set(group, (0, _indexMjs.without)(this.get(group), port), opt);
    },
    removeOutPort: function(port, opt) {
        return this._removeGroupPort(port, "outPorts", opt);
    },
    removeInPort: function(port, opt) {
        return this._removeGroupPort(port, "inPorts", opt);
    },
    _changeGroup: function(group, properties, opt) {
        return this.prop("ports/groups/" + group, (0, _indexMjs.isObject)(properties) ? properties : {}, opt);
    },
    changeInGroup: function(properties, opt) {
        return this._changeGroup("in", properties, opt);
    },
    changeOutGroup: function(properties, opt) {
        return this._changeGroup("out", properties, opt);
    }
});
const Atomic = Model.define("devs.Atomic", {
    size: {
        width: 80,
        height: 80
    },
    attrs: {
        ".label": {
            text: "Atomic"
        }
    }
});
const Coupled = Model.define("devs.Coupled", {
    size: {
        width: 200,
        height: 300
    },
    attrs: {
        ".label": {
            text: "Coupled"
        }
    }
});
const Link = (0, _linkMjs.Link).define("devs.Link", {
    attrs: {
        ".connection": {
            "stroke-width": 2
        }
    }
});

},{"./basic.mjs":"frFBw","../dia/Link.mjs":"kX2vg","../util/index.mjs":"eL7pI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"S4KOp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Gate", ()=>Gate);
parcelHelpers.export(exports, "IO", ()=>IO);
parcelHelpers.export(exports, "Input", ()=>Input);
parcelHelpers.export(exports, "Output", ()=>Output);
parcelHelpers.export(exports, "Gate11", ()=>Gate11);
parcelHelpers.export(exports, "Gate21", ()=>Gate21);
parcelHelpers.export(exports, "Repeater", ()=>Repeater);
parcelHelpers.export(exports, "Not", ()=>Not);
parcelHelpers.export(exports, "Or", ()=>Or);
parcelHelpers.export(exports, "And", ()=>And);
parcelHelpers.export(exports, "Nor", ()=>Nor);
parcelHelpers.export(exports, "Nand", ()=>Nand);
parcelHelpers.export(exports, "Xor", ()=>Xor);
parcelHelpers.export(exports, "Xnor", ()=>Xnor);
parcelHelpers.export(exports, "Wire", ()=>Wire);
var _basicMjs = require("./basic.mjs");
var _linkMjs = require("../dia/Link.mjs");
const Gate = (0, _basicMjs.Generic).define("logic.Gate", {
    size: {
        width: 80,
        height: 40
    },
    attrs: {
        ".": {
            magnet: false
        },
        ".body": {
            width: 100,
            height: 50
        },
        circle: {
            r: 7,
            stroke: "black",
            fill: "transparent",
            "stroke-width": 2
        }
    }
}, {
    operation: function() {
        return true;
    }
});
const IO = Gate.define("logic.IO", {
    size: {
        width: 60,
        height: 30
    },
    attrs: {
        ".body": {
            fill: "white",
            stroke: "black",
            "stroke-width": 2
        },
        ".wire": {
            ref: ".body",
            "ref-y": .5,
            stroke: "black"
        },
        text: {
            fill: "black",
            ref: ".body",
            "ref-x": .5,
            "ref-y": .5,
            "y-alignment": "middle",
            "text-anchor": "middle",
            "font-weight": "bold",
            "font-variant": "small-caps",
            "text-transform": "capitalize",
            "font-size": "14px"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><rect class="body"/></g><path class="wire"/><circle/><text/></g>'
});
const Input = IO.define("logic.Input", {
    attrs: {
        ".wire": {
            "ref-dx": 0,
            d: "M 0 0 L 23 0"
        },
        circle: {
            ref: ".body",
            "ref-dx": 30,
            "ref-y": 0.5,
            magnet: true,
            "class": "output",
            port: "out"
        },
        text: {
            text: "input"
        }
    }
});
const Output = IO.define("logic.Output", {
    attrs: {
        ".wire": {
            "ref-x": 0,
            d: "M 0 0 L -23 0"
        },
        circle: {
            ref: ".body",
            "ref-x": -30,
            "ref-y": 0.5,
            magnet: "passive",
            "class": "input",
            port: "in"
        },
        text: {
            text: "output"
        }
    }
});
const Gate11 = Gate.define("logic.Gate11", {
    attrs: {
        ".input": {
            ref: ".body",
            "ref-x": -2,
            "ref-y": 0.5,
            magnet: "passive",
            port: "in"
        },
        ".output": {
            ref: ".body",
            "ref-dx": 2,
            "ref-y": 0.5,
            magnet: true,
            port: "out"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><image class="body"/></g><circle class="input"/><circle class="output"/></g>'
});
const Gate21 = Gate.define("logic.Gate21", {
    attrs: {
        ".input1": {
            ref: ".body",
            "ref-x": -2,
            "ref-y": 0.3,
            magnet: "passive",
            port: "in1"
        },
        ".input2": {
            ref: ".body",
            "ref-x": -2,
            "ref-y": 0.7,
            magnet: "passive",
            port: "in2"
        },
        ".output": {
            ref: ".body",
            "ref-dx": 2,
            "ref-y": 0.5,
            magnet: true,
            port: "out"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><image class="body"/></g><circle class="input input1"/><circle  class="input input2"/><circle class="output"/></g>'
});
const Repeater = Gate11.define("logic.Repeater", {
    attrs: {
        image: {
            "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzIuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICA8L2c+Cjwvc3ZnPgo="
        }
    }
}, {
    operation: function(input) {
        return input;
    }
});
const Not = Gate11.define("logic.Not", {
    attrs: {
        image: {
            "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzkuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDI2NzEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzYiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA4MCwyNSBBIDQsNCAwIDEgMSA3MiwyNSBBIDQsNCAwIDEgMSA4MCwyNSB6IgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEsMCkiIC8+CiAgPC9nPgo8L3N2Zz4K"
        }
    }
}, {
    operation: function(input) {
        return !input;
    }
});
const Or = Gate21.define("logic.Or", {
    attrs: {
        image: {
            "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik9SIEFOU0kuc3ZnIgogICBpbmtzY2FwZTpvdXRwdXRfZXh0ZW5zaW9uPSJvcmcuaW5rc2NhcGUub3V0cHV0LnN2Zy5pbmtzY2FwZSI+CiAgPGRlZnMKICAgICBpZD0iZGVmczQiPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTAgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjcxNCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iMSA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMC41IDogMC4zMzMzMzMzMyA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODA2IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODE5IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjM3Mi4wNDcyNCA6IDM1MC43ODczOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI3NDQuMDk0NDggOiA1MjYuMTgxMDkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzc3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49Ijc1IDogNDAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTUwIDogNjAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDYwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTMyNzUiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNTAgOiAzMy4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTAwIDogNTAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTU1MzMiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzIgOiAyMS4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNjQgOiAzMiA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMzIgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjU1NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDE2LjY2NjY2NyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDI1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAyNSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iNCIKICAgICBpbmtzY2FwZTpjeD0iMTEzLjAwMDM5IgogICAgIGlua3NjYXBlOmN5PSIxMi44OTM3MzEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImcyNTYwIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTpncmlkLWJib3g9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1wb2ludHM9InRydWUiCiAgICAgZ3JpZHRvbGVyYW5jZT0iMTAwMDAiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxMzk5IgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9Ijg3NCIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMzciCiAgICAgaW5rc2NhcGU6d2luZG93LXk9Ii00IgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNzAsMjUgYyAyMCwwIDI1LDAgMjUsMCIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMSwxNSA1LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzIsMzUgNSwzNSIKICAgICAgIGlkPSJwYXRoMzk0NCIgLz4KICAgIDxnCiAgICAgICBpZD0iZzI1NjAiCiAgICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI2LjUsLTM5LjUpIj4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICA8L2c+Cjwvc3ZnPgo="
        }
    }
}, {
    operation: function(input1, input2) {
        return input1 || input2;
    }
});
const And = Gate21.define("logic.And", {
    attrs: {
        image: {
            "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IkFORCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI4IgogICAgIGlua3NjYXBlOmN4PSI1Ni42OTgzNDgiCiAgICAgaW5rc2NhcGU6Y3k9IjI1LjMyNjg5OSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZvbnQtc2l6ZTptZWRpdW07Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDt0ZXh0LWluZGVudDowO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6bm9ybWFsO2xldHRlci1zcGFjaW5nOm5vcm1hbDt3b3JkLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7ZGlyZWN0aW9uOmx0cjtibG9jay1wcm9ncmVzc2lvbjp0Yjt3cml0aW5nLW1vZGU6bHItdGI7dGV4dC1hbmNob3I6c3RhcnQ7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDozO21hcmtlcjpub25lO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGU7Zm9udC1mYW1pbHk6Qml0c3RyZWFtIFZlcmEgU2FuczstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkJpdHN0cmVhbSBWZXJhIFNhbnMiCiAgICAgICBkPSJNIDMwLDUgTCAzMCw2LjQyODU3MTQgTCAzMCw0My41NzE0MjkgTCAzMCw0NSBMIDMxLjQyODU3MSw0NSBMIDUwLjQ3NjE5LDQ1IEMgNjEuNzQ0MDk4LDQ1IDcwLjQ3NjE5LDM1Ljk5OTk1NSA3MC40NzYxOSwyNSBDIDcwLjQ3NjE5LDE0LjAwMDA0NSA2MS43NDQwOTksNS4wMDAwMDAyIDUwLjQ3NjE5LDUgQyA1MC40NzYxOSw1IDUwLjQ3NjE5LDUgMzEuNDI4NTcxLDUgTCAzMCw1IHogTSAzMi44NTcxNDMsNy44NTcxNDI5IEMgNDAuODM0MjY0LDcuODU3MTQyOSA0NS45MTgzNjgsNy44NTcxNDI5IDQ4LjA5NTIzOCw3Ljg1NzE0MjkgQyA0OS4yODU3MTQsNy44NTcxNDI5IDQ5Ljg4MDk1Miw3Ljg1NzE0MjkgNTAuMTc4NTcxLDcuODU3MTQyOSBDIDUwLjMyNzM4MSw3Ljg1NzE0MjkgNTAuNDA5MjI3LDcuODU3MTQyOSA1MC40NDY0MjksNy44NTcxNDI5IEMgNTAuNDY1MDI5LDcuODU3MTQyOSA1MC40NzE1NDMsNy44NTcxNDI5IDUwLjQ3NjE5LDcuODU3MTQyOSBDIDYwLjIzNjg1Myw3Ljg1NzE0MyA2Ny4xNDI4NTcsMTUuNDk3MDk4IDY3LjE0Mjg1NywyNSBDIDY3LjE0Mjg1NywzNC41MDI5MDIgNTkuNzYwNjYyLDQyLjE0Mjg1NyA1MCw0Mi4xNDI4NTcgTCAzMi44NTcxNDMsNDIuMTQyODU3IEwgMzIuODU3MTQzLDcuODU3MTQyOSB6IgogICAgICAgaWQ9InBhdGgyODg0IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2NjY2NzY2NjY3Nzc3NzY2NjIiAvPgogIDwvZz4KPC9zdmc+Cg=="
        }
    }
}, {
    operation: function(input1, input2) {
        return input1 && input2;
    }
});
const Nor = Gate21.define("logic.Nor", {
    attrs: {
        image: {
            "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjEiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjY3NzY0NCIKICAgICBpbmtzY2FwZTpjeT0iMjIuMTAyMzQ0IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjM3IgogICAgIGlua3NjYXBlOndpbmRvdy15PSItNCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc5LDI1IEMgOTksMjUgOTUsMjUgOTUsMjUiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHNvZGlwb2RpOnR5cGU9ImFyYyIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgICBpZD0icGF0aDI2MDQiCiAgICAgICAgIHNvZGlwb2RpOmN4PSI3NSIKICAgICAgICAgc29kaXBvZGk6Y3k9IjI1IgogICAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgICAgc29kaXBvZGk6cnk9IjQiCiAgICAgICAgIGQ9Ik0gNzksMjUgQSA0LDQgMCAxIDEgNzEsMjUgQSA0LDQgMCAxIDEgNzksMjUgeiIKICAgICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTI2LjUsMzkuNSkiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K"
        }
    }
}, {
    operation: function(input1, input2) {
        return !(input1 || input2);
    }
});
const Nand = Gate21.define("logic.Nand", {
    attrs: {
        image: {
            "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5BTkQgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iMTYiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjI4MzMwNyIKICAgICBpbmtzY2FwZTpjeT0iMTYuNDQyODQzIgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzksMjUgQyA5MS44LDI1IDk1LDI1IDk1LDI1IgogICAgICAgaWQ9InBhdGgzMDU5IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMxLDE1IDUsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMiwzNSA1LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MzttYXJrZXI6bm9uZTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlO2ZvbnQtZmFtaWx5OkJpdHN0cmVhbSBWZXJhIFNhbnM7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpCaXRzdHJlYW0gVmVyYSBTYW5zIgogICAgICAgZD0iTSAzMCw1IEwgMzAsNi40Mjg1NzE0IEwgMzAsNDMuNTcxNDI5IEwgMzAsNDUgTCAzMS40Mjg1NzEsNDUgTCA1MC40NzYxOSw0NSBDIDYxLjc0NDA5OCw0NSA3MC40NzYxOSwzNS45OTk5NTUgNzAuNDc2MTksMjUgQyA3MC40NzYxOSwxNC4wMDAwNDUgNjEuNzQ0MDk5LDUuMDAwMDAwMiA1MC40NzYxOSw1IEMgNTAuNDc2MTksNSA1MC40NzYxOSw1IDMxLjQyODU3MSw1IEwgMzAsNSB6IE0gMzIuODU3MTQzLDcuODU3MTQyOSBDIDQwLjgzNDI2NCw3Ljg1NzE0MjkgNDUuOTE4MzY4LDcuODU3MTQyOSA0OC4wOTUyMzgsNy44NTcxNDI5IEMgNDkuMjg1NzE0LDcuODU3MTQyOSA0OS44ODA5NTIsNy44NTcxNDI5IDUwLjE3ODU3MSw3Ljg1NzE0MjkgQyA1MC4zMjczODEsNy44NTcxNDI5IDUwLjQwOTIyNyw3Ljg1NzE0MjkgNTAuNDQ2NDI5LDcuODU3MTQyOSBDIDUwLjQ2NTAyOSw3Ljg1NzE0MjkgNTAuNDcxNTQzLDcuODU3MTQyOSA1MC40NzYxOSw3Ljg1NzE0MjkgQyA2MC4yMzY4NTMsNy44NTcxNDMgNjcuMTQyODU3LDE1LjQ5NzA5OCA2Ny4xNDI4NTcsMjUgQyA2Ny4xNDI4NTcsMzQuNTAyOTAyIDU5Ljc2MDY2Miw0Mi4xNDI4NTcgNTAsNDIuMTQyODU3IEwgMzIuODU3MTQzLDQyLjE0Mjg1NyBMIDMyLjg1NzE0Myw3Ljg1NzE0MjkgeiIKICAgICAgIGlkPSJwYXRoMjg4NCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2Njc2NjY2Nzc3Nzc2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDQwMDgiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg=="
        }
    }
}, {
    operation: function(input1, input2) {
        return !(input1 && input2);
    }
});
const Xor = Gate21.define("logic.Xor", {
    attrs: {
        image: {
            "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhPUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjUuNjU2ODU0MiIKICAgICBpbmtzY2FwZTpjeD0iMjUuOTM4MTE2IgogICAgIGlua3NjYXBlOmN5PSIxNy4yMzAwNSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzAuMzg1NzE3LDE1IEwgNC45OTk5OTk4LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5NzY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEuMzYyMDkxLDM1IEwgNC45OTk5OTk4LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPGcKICAgICAgIGlkPSJnMjU2MCIKICAgICAgIGlua3NjYXBlOmxhYmVsPSJMYXllciAxIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYuNSwtMzkuNSkiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM1MTYiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi4yNSw4MS41MDAwMDUgQyAtMy44NDczNzQsODQuMTQ0NDA1IC00LjUsODQuNTAwMDA1IC00LjUsODQuNTAwMDA1IEwgLTguMTU2MjUsODQuNTAwMDA1IEwgLTYuMTU2MjUsODIuMDYyNTA1IEMgLTYuMTU2MjUsODIuMDYyNTA1IC0wLjUsNzUuMDYyNDUxIC0wLjUsNjQuNSBDIC0wLjUsNTMuOTM3NTQ5IC02LjE1NjI1LDQ2LjkzNzUgLTYuMTU2MjUsNDYuOTM3NSBMIC04LjE1NjI1LDQ0LjUgTCAtNC41LDQ0LjUgQyAtMy43MTg3NSw0NS40Mzc1IC0zLjA3ODEyNSw0Ni4xNTYyNSAtMi4yODEyNSw0Ny41IEMgLTAuNDA4NTMxLDUwLjU5OTgxNSAyLjUsNTYuNTI2NjQ2IDIuNSw2NC41IEMgMi41LDcyLjQ1MDY1IC0wLjM5NjY5Nyw3OC4zNzk0MjUgLTIuMjUsODEuNTAwMDA1IHoiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY3NjY2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K"
        }
    }
}, {
    operation: function(input1, input2) {
        return (!input1 || input2) && (input1 || !input2);
    }
});
const Xnor = Gate21.define("logic.Xnor", {
    attrs: {
        image: {
            "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhOT1IgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNTU3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTYuNjY2NjY3IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDI1IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI0IgogICAgIGlua3NjYXBlOmN4PSI5NS43MjM2NiIKICAgICBpbmtzY2FwZTpjeT0iLTI2Ljc3NTAyMyIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjAwMDAwMDI0O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc4LjMzMzMzMiwyNSBDIDkxLjY2NjY2NiwyNSA5NSwyNSA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMC4zODU3MTcsMTUgTCA0Ljk5OTk5OTgsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk3NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMS4zNjIwOTEsMzUgTCA0Ljk5OTk5OTgsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMzUxNiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjI1LDgxLjUwMDAwNSBDIC0zLjg0NzM3NCw4NC4xNDQ0MDUgLTQuNSw4NC41MDAwMDUgLTQuNSw4NC41MDAwMDUgTCAtOC4xNTYyNSw4NC41MDAwMDUgTCAtNi4xNTYyNSw4Mi4wNjI1MDUgQyAtNi4xNTYyNSw4Mi4wNjI1MDUgLTAuNSw3NS4wNjI0NTEgLTAuNSw2NC41IEMgLTAuNSw1My45Mzc1NDkgLTYuMTU2MjUsNDYuOTM3NSAtNi4xNTYyNSw0Ni45Mzc1IEwgLTguMTU2MjUsNDQuNSBMIC00LjUsNDQuNSBDIC0zLjcxODc1LDQ1LjQzNzUgLTMuMDc4MTI1LDQ2LjE1NjI1IC0yLjI4MTI1LDQ3LjUgQyAtMC40MDg1MzEsNTAuNTk5ODE1IDIuNSw1Ni41MjY2NDYgMi41LDY0LjUgQyAyLjUsNzIuNDUwNjUgLTAuMzk2Njk3LDc4LjM3OTQyNSAtMi4yNSw4MS41MDAwMDUgeiIKICAgICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2Njc2NjY2NzYyIgLz4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDM1NTEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg=="
        }
    }
}, {
    operation: function(input1, input2) {
        return (!input1 || !input2) && (input1 || input2);
    }
});
const Wire = (0, _linkMjs.Link).define("logic.Wire", {
    attrs: {
        ".connection": {
            "stroke-width": 2
        },
        ".marker-vertex": {
            r: 7
        }
    },
    router: {
        name: "orthogonal"
    },
    connector: {
        name: "rounded",
        args: {
            radius: 10
        }
    }
}, {
    arrowheadMarkup: [
        '<g class="marker-arrowhead-group marker-arrowhead-group-<%= end %>">',
        '<circle class="marker-arrowhead" end="<%= end %>" r="7"/>',
        "</g>"
    ].join(""),
    vertexMarkup: [
        '<g class="marker-vertex-group" transform="translate(<%= x %>, <%= y %>)">',
        '<circle class="marker-vertex" idx="<%= idx %>" r="10" />',
        '<g class="marker-vertex-remove-group">',
        '<path class="marker-vertex-remove-area" idx="<%= idx %>" d="M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z" transform="translate(5, -33)"/>',
        '<path class="marker-vertex-remove" idx="<%= idx %>" transform="scale(.8) translate(9.5, -37)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z">',
        "<title>Remove vertex.</title>",
        "</path>",
        "</g>",
        "</g>"
    ].join("")
});

},{"./basic.mjs":"frFBw","../dia/Link.mjs":"kX2vg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dcpUb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KingWhite", ()=>KingWhite);
parcelHelpers.export(exports, "KingBlack", ()=>KingBlack);
parcelHelpers.export(exports, "QueenWhite", ()=>QueenWhite);
parcelHelpers.export(exports, "QueenBlack", ()=>QueenBlack);
parcelHelpers.export(exports, "RookWhite", ()=>RookWhite);
parcelHelpers.export(exports, "RookBlack", ()=>RookBlack);
parcelHelpers.export(exports, "BishopWhite", ()=>BishopWhite);
parcelHelpers.export(exports, "BishopBlack", ()=>BishopBlack);
parcelHelpers.export(exports, "KnightWhite", ()=>KnightWhite);
parcelHelpers.export(exports, "KnightBlack", ()=>KnightBlack);
parcelHelpers.export(exports, "PawnWhite", ()=>PawnWhite);
parcelHelpers.export(exports, "PawnBlack", ()=>PawnBlack);
var _basicMjs = require("./basic.mjs");
const KingWhite = (0, _basicMjs.Generic).define("chess.KingWhite", {
    size: {
        width: 42,
        height: 38
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><g style="fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;"><path      d="M 22.5,11.63 L 22.5,6"      style="fill:none; stroke:#000000; stroke-linejoin:miter;" />    <path      d="M 20,8 L 25,8"      style="fill:none; stroke:#000000; stroke-linejoin:miter;" />    <path      d="M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25"      style="fill:#ffffff; stroke:#000000; stroke-linecap:butt; stroke-linejoin:miter;" />    <path      d="M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z "      style="fill:#ffffff; stroke:#000000;" />    <path      d="M 11.5,30 C 17,27 27,27 32.5,30"      style="fill:none; stroke:#000000;" />    <path      d="M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5"      style="fill:none; stroke:#000000;" />    <path      d="M 11.5,37 C 17,34 27,34 32.5,37"      style="fill:none; stroke:#000000;" />  </g></g></g>'
});
const KingBlack = (0, _basicMjs.Generic).define("chess.KingBlack", {
    size: {
        width: 42,
        height: 38
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><g style="fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path       d="M 22.5,11.63 L 22.5,6"       style="fill:none; stroke:#000000; stroke-linejoin:miter;"       id="path6570" />    <path       d="M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25"       style="fill:#000000;fill-opacity:1; stroke-linecap:butt; stroke-linejoin:miter;" />    <path       d="M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z "       style="fill:#000000; stroke:#000000;" />    <path       d="M 20,8 L 25,8"       style="fill:none; stroke:#000000; stroke-linejoin:miter;" />    <path       d="M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.51,26.6 L 22.5,24.5 C 20,18 9.906,14 6.997,19.85 C 4.5,25.5 11.85,28.85 11.85,28.85"       style="fill:none; stroke:#ffffff;" />    <path       d="M 11.5,30 C 17,27 27,27 32.5,30 M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5 M 11.5,37 C 17,34 27,34 32.5,37"       style="fill:none; stroke:#ffffff;" />  </g></g></g>'
});
const QueenWhite = (0, _basicMjs.Generic).define("chess.QueenWhite", {
    size: {
        width: 42,
        height: 38
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(-1,-1)" />    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(15.5,-5.5)" />    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(32,-1)" />    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(7,-4.5)" />    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(24,-4)" />    <path      d="M 9,26 C 17.5,24.5 30,24.5 36,26 L 38,14 L 31,25 L 31,11 L 25.5,24.5 L 22.5,9.5 L 19.5,24.5 L 14,10.5 L 14,25 L 7,14 L 9,26 z "      style="stroke-linecap:butt;" />    <path      d="M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z "      style="stroke-linecap:butt;" />    <path      d="M 11.5,30 C 15,29 30,29 33.5,30"      style="fill:none;" />    <path      d="M 12,33.5 C 18,32.5 27,32.5 33,33.5"      style="fill:none;" />  </g></g></g>'
});
const QueenBlack = (0, _basicMjs.Generic).define("chess.QueenBlack", {
    size: {
        width: 42,
        height: 38
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <g style="fill:#000000; stroke:none;">      <circle cx="6"    cy="12" r="2.75" />      <circle cx="14"   cy="9"  r="2.75" />      <circle cx="22.5" cy="8"  r="2.75" />      <circle cx="31"   cy="9"  r="2.75" />      <circle cx="39"   cy="12" r="2.75" />    </g>    <path       d="M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z"       style="stroke-linecap:butt; stroke:#000000;" />    <path       d="M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z"       style="stroke-linecap:butt;" />    <path       d="M 11,38.5 A 35,35 1 0 0 34,38.5"       style="fill:none; stroke:#000000; stroke-linecap:butt;" />    <path       d="M 11,29 A 35,35 1 0 1 34,29"       style="fill:none; stroke:#ffffff;" />    <path       d="M 12.5,31.5 L 32.5,31.5"       style="fill:none; stroke:#ffffff;" />    <path       d="M 11.5,34.5 A 35,35 1 0 0 33.5,34.5"       style="fill:none; stroke:#ffffff;" />    <path       d="M 10.5,37.5 A 35,35 1 0 0 34.5,37.5"       style="fill:none; stroke:#ffffff;" />  </g></g></g>'
});
const RookWhite = (0, _basicMjs.Generic).define("chess.RookWhite", {
    size: {
        width: 32,
        height: 34
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z "      style="stroke-linecap:butt;" />    <path      d="M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z "      style="stroke-linecap:butt;" />    <path      d="M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14"      style="stroke-linecap:butt;" />    <path      d="M 34,14 L 31,17 L 14,17 L 11,14" />    <path      d="M 31,17 L 31,29.5 L 14,29.5 L 14,17"      style="stroke-linecap:butt; stroke-linejoin:miter;" />    <path      d="M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5" />    <path      d="M 11,14 L 34,14"      style="fill:none; stroke:#000000; stroke-linejoin:miter;" />  </g></g></g>'
});
const RookBlack = (0, _basicMjs.Generic).define("chess.RookBlack", {
    size: {
        width: 32,
        height: 34
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z "      style="stroke-linecap:butt;" />    <path      d="M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z "      style="stroke-linecap:butt;" />    <path      d="M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z "      style="stroke-linecap:butt;" />    <path      d="M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z "      style="stroke-linecap:butt;stroke-linejoin:miter;" />    <path      d="M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z "      style="stroke-linecap:butt;" />    <path      d="M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z "      style="stroke-linecap:butt;" />    <path      d="M 12,35.5 L 33,35.5 L 33,35.5"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />    <path      d="M 13,31.5 L 32,31.5"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />    <path      d="M 14,29.5 L 31,29.5"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />    <path      d="M 14,16.5 L 31,16.5"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />    <path      d="M 11,14 L 34,14"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />  </g></g></g>'
});
const BishopWhite = (0, _basicMjs.Generic).define("chess.BishopWhite", {
    size: {
        width: 38,
        height: 38
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <g style="fill:#ffffff; stroke:#000000; stroke-linecap:butt;">       <path        d="M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z" />      <path        d="M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" />      <path        d="M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" />    </g>    <path      d="M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18"      style="fill:none; stroke:#000000; stroke-linejoin:miter;" />  </g></g></g>'
});
const BishopBlack = (0, _basicMjs.Generic).define("chess.BishopBlack", {
    size: {
        width: 38,
        height: 38
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <g style="fill:#000000; stroke:#000000; stroke-linecap:butt;">       <path        d="M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z" />      <path        d="M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" />      <path        d="M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" />    </g>    <path       d="M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18"       style="fill:none; stroke:#ffffff; stroke-linejoin:miter;" />  </g></g></g>'
});
const KnightWhite = (0, _basicMjs.Generic).define("chess.KnightWhite", {
    size: {
        width: 38,
        height: 37
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18"      style="fill:#ffffff; stroke:#000000;" />    <path      d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10"      style="fill:#ffffff; stroke:#000000;" />    <path      d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z"      style="fill:#000000; stroke:#000000;" />    <path      d="M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z"      transform="matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)"      style="fill:#000000; stroke:#000000;" />  </g></g></g>'
});
const KnightBlack = (0, _basicMjs.Generic).define("chess.KnightBlack", {
    size: {
        width: 38,
        height: 37
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18"      style="fill:#000000; stroke:#000000;" />    <path      d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10"      style="fill:#000000; stroke:#000000;" />    <path      d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z"      style="fill:#ffffff; stroke:#ffffff;" />    <path      d="M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z"      transform="matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)"      style="fill:#ffffff; stroke:#ffffff;" />    <path      d="M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z "      style="fill:#ffffff; stroke:none;" />  </g></g></g>'
});
const PawnWhite = (0, _basicMjs.Generic).define("chess.PawnWhite", {
    size: {
        width: 28,
        height: 33
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><path d="M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z "  style="opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;" /></g></g>'
});
const PawnBlack = (0, _basicMjs.Generic).define("chess.PawnBlack", {
    size: {
        width: 28,
        height: 33
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><path d="M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z "  style="opacity:1; fill:#000000; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;" /></g></g>'
});

},{"./basic.mjs":"frFBw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hUvpP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Entity", ()=>Entity);
parcelHelpers.export(exports, "WeakEntity", ()=>WeakEntity);
parcelHelpers.export(exports, "Relationship", ()=>Relationship);
parcelHelpers.export(exports, "IdentifyingRelationship", ()=>IdentifyingRelationship);
parcelHelpers.export(exports, "Attribute", ()=>Attribute);
parcelHelpers.export(exports, "Multivalued", ()=>Multivalued);
parcelHelpers.export(exports, "Derived", ()=>Derived);
parcelHelpers.export(exports, "Key", ()=>Key);
parcelHelpers.export(exports, "Normal", ()=>Normal);
parcelHelpers.export(exports, "ISA", ()=>ISA);
parcelHelpers.export(exports, "Line", ()=>Line);
var _elementMjs = require("../dia/Element.mjs");
var _linkMjs = require("../dia/Link.mjs");
const Entity = (0, _elementMjs.Element).define("erd.Entity", {
    size: {
        width: 150,
        height: 60
    },
    attrs: {
        ".outer": {
            fill: "#2ECC71",
            stroke: "#27AE60",
            "stroke-width": 2,
            points: "100,0 100,60 0,60 0,0"
        },
        ".inner": {
            fill: "#2ECC71",
            stroke: "#27AE60",
            "stroke-width": 2,
            points: "95,5 95,55 5,55 5,5",
            display: "none"
        },
        text: {
            text: "Entity",
            "font-family": "Arial",
            "font-size": 14,
            "ref-x": .5,
            "ref-y": .5,
            "y-alignment": "middle",
            "text-anchor": "middle"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><polygon class="outer"/><polygon class="inner"/></g><text/></g>'
});
const WeakEntity = Entity.define("erd.WeakEntity", {
    attrs: {
        ".inner": {
            display: "auto"
        },
        text: {
            text: "Weak Entity"
        }
    }
});
const Relationship = (0, _elementMjs.Element).define("erd.Relationship", {
    size: {
        width: 80,
        height: 80
    },
    attrs: {
        ".outer": {
            fill: "#3498DB",
            stroke: "#2980B9",
            "stroke-width": 2,
            points: "40,0 80,40 40,80 0,40"
        },
        ".inner": {
            fill: "#3498DB",
            stroke: "#2980B9",
            "stroke-width": 2,
            points: "40,5 75,40 40,75 5,40",
            display: "none"
        },
        text: {
            text: "Relationship",
            "font-family": "Arial",
            "font-size": 12,
            "ref-x": .5,
            "ref-y": .5,
            "y-alignment": "middle",
            "text-anchor": "middle"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><polygon class="outer"/><polygon class="inner"/></g><text/></g>'
});
const IdentifyingRelationship = Relationship.define("erd.IdentifyingRelationship", {
    attrs: {
        ".inner": {
            display: "auto"
        },
        text: {
            text: "Identifying"
        }
    }
});
const Attribute = (0, _elementMjs.Element).define("erd.Attribute", {
    size: {
        width: 100,
        height: 50
    },
    attrs: {
        "ellipse": {
            transform: "translate(50, 25)"
        },
        ".outer": {
            stroke: "#D35400",
            "stroke-width": 2,
            cx: 0,
            cy: 0,
            rx: 50,
            ry: 25,
            fill: "#E67E22"
        },
        ".inner": {
            stroke: "#D35400",
            "stroke-width": 2,
            cx: 0,
            cy: 0,
            rx: 45,
            ry: 20,
            fill: "#E67E22",
            display: "none"
        },
        text: {
            "font-family": "Arial",
            "font-size": 14,
            "ref-x": .5,
            "ref-y": .5,
            "y-alignment": "middle",
            "text-anchor": "middle"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><ellipse class="outer"/><ellipse class="inner"/></g><text/></g>'
});
const Multivalued = Attribute.define("erd.Multivalued", {
    attrs: {
        ".inner": {
            display: "block"
        },
        text: {
            text: "multivalued"
        }
    }
});
const Derived = Attribute.define("erd.Derived", {
    attrs: {
        ".outer": {
            "stroke-dasharray": "3,5"
        },
        text: {
            text: "derived"
        }
    }
});
const Key = Attribute.define("erd.Key", {
    attrs: {
        ellipse: {
            "stroke-width": 4
        },
        text: {
            text: "key",
            "font-weight": "800",
            "text-decoration": "underline"
        }
    }
});
const Normal = Attribute.define("erd.Normal", {
    attrs: {
        text: {
            text: "Normal"
        }
    }
});
const ISA = (0, _elementMjs.Element).define("erd.ISA", {
    type: "erd.ISA",
    size: {
        width: 100,
        height: 50
    },
    attrs: {
        polygon: {
            points: "0,0 50,50 100,0",
            fill: "#F1C40F",
            stroke: "#F39C12",
            "stroke-width": 2
        },
        text: {
            text: "ISA",
            "font-size": 18,
            "ref-x": .5,
            "ref-y": .3,
            "y-alignment": "middle",
            "text-anchor": "middle"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><polygon/></g><text/></g>'
});
const Line = (0, _linkMjs.Link).define("erd.Line", {}, {
    cardinality: function(value) {
        this.set("labels", [
            {
                position: -20,
                attrs: {
                    text: {
                        dy: -8,
                        text: value
                    }
                }
            }
        ]);
    }
});

},{"../dia/Element.mjs":"hcQWn","../dia/Link.mjs":"kX2vg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"66MG9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "State", ()=>State);
parcelHelpers.export(exports, "StartState", ()=>StartState);
parcelHelpers.export(exports, "EndState", ()=>EndState);
parcelHelpers.export(exports, "Arrow", ()=>Arrow);
var _basicMjs = require("./basic.mjs");
var _elementMjs = require("../dia/Element.mjs");
var _linkMjs = require("../dia/Link.mjs");
const State = (0, _basicMjs.Circle).define("fsa.State", {
    attrs: {
        circle: {
            "stroke-width": 3
        },
        text: {
            "font-weight": "800"
        }
    }
});
const StartState = (0, _elementMjs.Element).define("fsa.StartState", {
    size: {
        width: 20,
        height: 20
    },
    attrs: {
        circle: {
            transform: "translate(10, 10)",
            r: 10,
            fill: "#000000"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><circle/></g></g>'
});
const EndState = (0, _elementMjs.Element).define("fsa.EndState", {
    size: {
        width: 20,
        height: 20
    },
    attrs: {
        ".outer": {
            transform: "translate(10, 10)",
            r: 10,
            fill: "#ffffff",
            stroke: "#000000"
        },
        ".inner": {
            transform: "translate(10, 10)",
            r: 6,
            fill: "#000000"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><circle class="outer"/><circle class="inner"/></g></g>'
});
const Arrow = (0, _linkMjs.Link).define("fsa.Arrow", {
    attrs: {
        ".marker-target": {
            d: "M 10 0 L 0 5 L 10 10 z"
        }
    },
    smooth: true
});

},{"./basic.mjs":"frFBw","../dia/Element.mjs":"hcQWn","../dia/Link.mjs":"kX2vg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6mYmX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Member", ()=>Member);
parcelHelpers.export(exports, "Arrow", ()=>Arrow);
var _elementMjs = require("../dia/Element.mjs");
var _linkMjs = require("../dia/Link.mjs");
const Member = (0, _elementMjs.Element).define("org.Member", {
    size: {
        width: 180,
        height: 70
    },
    attrs: {
        rect: {
            width: 170,
            height: 60
        },
        ".card": {
            fill: "#FFFFFF",
            stroke: "#000000",
            "stroke-width": 2,
            "pointer-events": "visiblePainted",
            rx: 10,
            ry: 10
        },
        image: {
            width: 48,
            height: 48,
            ref: ".card",
            "ref-x": 10,
            "ref-y": 5
        },
        ".rank": {
            "text-decoration": "underline",
            ref: ".card",
            "ref-x": 0.9,
            "ref-y": 0.2,
            "font-family": "Courier New",
            "font-size": 14,
            "text-anchor": "end"
        },
        ".name": {
            "font-weight": "800",
            ref: ".card",
            "ref-x": 0.9,
            "ref-y": 0.6,
            "font-family": "Courier New",
            "font-size": 14,
            "text-anchor": "end"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><rect class="card"/><image/></g><text class="rank"/><text class="name"/></g>'
});
const Arrow = (0, _linkMjs.Link).define("org.Arrow", {
    source: {
        selector: ".card"
    },
    target: {
        selector: ".card"
    },
    attrs: {
        ".connection": {
            stroke: "#585858",
            "stroke-width": 3
        }
    },
    z: -1
});

},{"../dia/Element.mjs":"hcQWn","../dia/Link.mjs":"kX2vg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"coP6k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Place", ()=>Place);
parcelHelpers.export(exports, "PlaceView", ()=>PlaceView);
parcelHelpers.export(exports, "Transition", ()=>Transition);
parcelHelpers.export(exports, "Link", ()=>Link);
var _basicMjs = require("./basic.mjs");
var _elementViewMjs = require("../dia/ElementView.mjs");
var _indexMjs = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _linkMjs = require("../dia/Link.mjs");
const Place = (0, _basicMjs.Generic).define("pn.Place", {
    size: {
        width: 50,
        height: 50
    },
    attrs: {
        ".root": {
            r: 25,
            fill: "#ffffff",
            stroke: "#000000",
            transform: "translate(25, 25)"
        },
        ".label": {
            "text-anchor": "middle",
            "ref-x": .5,
            "ref-y": -20,
            ref: ".root",
            fill: "#000000",
            "font-size": 12
        },
        ".tokens > circle": {
            fill: "#000000",
            r: 5
        },
        ".tokens.one > circle": {
            transform: "translate(25, 25)"
        },
        ".tokens.two > circle:nth-child(1)": {
            transform: "translate(19, 25)"
        },
        ".tokens.two > circle:nth-child(2)": {
            transform: "translate(31, 25)"
        },
        ".tokens.three > circle:nth-child(1)": {
            transform: "translate(18, 29)"
        },
        ".tokens.three > circle:nth-child(2)": {
            transform: "translate(25, 19)"
        },
        ".tokens.three > circle:nth-child(3)": {
            transform: "translate(32, 29)"
        },
        ".tokens.alot > text": {
            transform: "translate(25, 18)",
            "text-anchor": "middle",
            fill: "#000000"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><circle class="root"/><g class="tokens" /></g><text class="label"/></g>'
});
const PlaceView = (0, _elementViewMjs.ElementView).extend({
    presentationAttributes: (0, _elementViewMjs.ElementView).addPresentationAttributes({
        tokens: [
            "TOKENS"
        ]
    }),
    initFlag: (0, _elementViewMjs.ElementView).prototype.initFlag.concat([
        "TOKENS"
    ]),
    confirmUpdate: function(...args) {
        let flags = (0, _elementViewMjs.ElementView).prototype.confirmUpdate.call(this, ...args);
        if (this.hasFlag(flags, "TOKENS")) {
            this.renderTokens();
            this.update();
            flags = this.removeFlag(flags, "TOKENS");
        }
        return flags;
    },
    renderTokens: function() {
        const vTokens = this.vel.findOne(".tokens").empty();
        [
            "one",
            "two",
            "three",
            "alot"
        ].forEach(function(className) {
            vTokens.removeClass(className);
        });
        var tokens = this.model.get("tokens");
        if (!tokens) return;
        switch(tokens){
            case 1:
                vTokens.addClass("one");
                vTokens.append((0, _indexMjsDefault.default)("circle"));
                break;
            case 2:
                vTokens.addClass("two");
                vTokens.append([
                    (0, _indexMjsDefault.default)("circle"),
                    (0, _indexMjsDefault.default)("circle")
                ]);
                break;
            case 3:
                vTokens.addClass("three");
                vTokens.append([
                    (0, _indexMjsDefault.default)("circle"),
                    (0, _indexMjsDefault.default)("circle"),
                    (0, _indexMjsDefault.default)("circle")
                ]);
                break;
            default:
                vTokens.addClass("alot");
                vTokens.append((0, _indexMjsDefault.default)("text").text(tokens + ""));
                break;
        }
    }
});
const Transition = (0, _basicMjs.Generic).define("pn.Transition", {
    size: {
        width: 12,
        height: 50
    },
    attrs: {
        "rect": {
            width: 12,
            height: 50,
            fill: "#000000",
            stroke: "#000000"
        },
        ".label": {
            "text-anchor": "middle",
            "ref-x": .5,
            "ref-y": -20,
            ref: "rect",
            fill: "#000000",
            "font-size": 12
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><rect class="root"/></g></g><text class="label"/>'
});
const Link = (0, _linkMjs.Link).define("pn.Link", {
    attrs: {
        ".marker-target": {
            d: "M 10 0 L 0 5 L 10 10 z"
        }
    }
});

},{"./basic.mjs":"frFBw","../dia/ElementView.mjs":"dHPd6","../V/index.mjs":"iw8UN","../dia/Link.mjs":"kX2vg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5EuxX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Class", ()=>Class);
parcelHelpers.export(exports, "ClassView", ()=>ClassView);
parcelHelpers.export(exports, "Abstract", ()=>Abstract);
parcelHelpers.export(exports, "AbstractView", ()=>AbstractView);
parcelHelpers.export(exports, "Interface", ()=>Interface);
parcelHelpers.export(exports, "InterfaceView", ()=>InterfaceView);
parcelHelpers.export(exports, "Generalization", ()=>Generalization);
parcelHelpers.export(exports, "Implementation", ()=>Implementation);
parcelHelpers.export(exports, "Aggregation", ()=>Aggregation);
parcelHelpers.export(exports, "Composition", ()=>Composition);
parcelHelpers.export(exports, "Association", ()=>Association);
parcelHelpers.export(exports, "State", ()=>State);
parcelHelpers.export(exports, "StartState", ()=>StartState);
parcelHelpers.export(exports, "EndState", ()=>EndState);
parcelHelpers.export(exports, "Transition", ()=>Transition);
var _elementViewMjs = require("../dia/ElementView.mjs");
var _linkMjs = require("../dia/Link.mjs");
var _basicMjs = require("./basic.mjs");
const Class = (0, _basicMjs.Generic).define("uml.Class", {
    attrs: {
        rect: {
            "width": 200
        },
        ".uml-class-name-rect": {
            "stroke": "black",
            "stroke-width": 2,
            "fill": "#3498db"
        },
        ".uml-class-attrs-rect": {
            "stroke": "black",
            "stroke-width": 2,
            "fill": "#2980b9"
        },
        ".uml-class-methods-rect": {
            "stroke": "black",
            "stroke-width": 2,
            "fill": "#2980b9"
        },
        ".uml-class-name-text": {
            "ref": ".uml-class-name-rect",
            "ref-y": .5,
            "ref-x": .5,
            "text-anchor": "middle",
            "y-alignment": "middle",
            "font-weight": "bold",
            "fill": "black",
            "font-size": 12,
            "font-family": "Times New Roman"
        },
        ".uml-class-attrs-text": {
            "ref": ".uml-class-attrs-rect",
            "ref-y": 5,
            "ref-x": 5,
            "fill": "black",
            "font-size": 12,
            "font-family": "Times New Roman"
        },
        ".uml-class-methods-text": {
            "ref": ".uml-class-methods-rect",
            "ref-y": 5,
            "ref-x": 5,
            "fill": "black",
            "font-size": 12,
            "font-family": "Times New Roman"
        }
    },
    name: [],
    attributes: [],
    methods: []
}, {
    markup: [
        '<g class="rotatable">',
        '<g class="scalable">',
        '<rect class="uml-class-name-rect"/><rect class="uml-class-attrs-rect"/><rect class="uml-class-methods-rect"/>',
        "</g>",
        '<text class="uml-class-name-text"/><text class="uml-class-attrs-text"/><text class="uml-class-methods-text"/>',
        "</g>"
    ].join(""),
    initialize: function() {
        this.on("change:name change:attributes change:methods", function() {
            this.updateRectangles();
            this.trigger("uml-update");
        }, this);
        this.updateRectangles();
        (0, _basicMjs.Generic).prototype.initialize.apply(this, arguments);
    },
    getClassName: function() {
        return this.get("name");
    },
    updateRectangles: function() {
        var attrs = this.get("attrs");
        var rects = [
            {
                type: "name",
                text: this.getClassName()
            },
            {
                type: "attrs",
                text: this.get("attributes")
            },
            {
                type: "methods",
                text: this.get("methods")
            }
        ];
        var offsetY = 0;
        rects.forEach(function(rect) {
            var lines = Array.isArray(rect.text) ? rect.text : [
                rect.text
            ];
            var rectHeight = lines.length * 20 + 20;
            attrs[".uml-class-" + rect.type + "-text"].text = lines.join("\n");
            attrs[".uml-class-" + rect.type + "-rect"].height = rectHeight;
            attrs[".uml-class-" + rect.type + "-rect"].transform = "translate(0," + offsetY + ")";
            offsetY += rectHeight;
        });
    }
});
const ClassView = (0, _elementViewMjs.ElementView).extend({
    initialize: function() {
        (0, _elementViewMjs.ElementView).prototype.initialize.apply(this, arguments);
        this.listenTo(this.model, "uml-update", function() {
            this.update();
            this.resize();
        });
    }
});
const Abstract = Class.define("uml.Abstract", {
    attrs: {
        ".uml-class-name-rect": {
            fill: "#e74c3c"
        },
        ".uml-class-attrs-rect": {
            fill: "#c0392b"
        },
        ".uml-class-methods-rect": {
            fill: "#c0392b"
        }
    }
}, {
    getClassName: function() {
        return [
            "<<Abstract>>",
            this.get("name")
        ];
    }
});
const AbstractView = ClassView;
const Interface = Class.define("uml.Interface", {
    attrs: {
        ".uml-class-name-rect": {
            fill: "#f1c40f"
        },
        ".uml-class-attrs-rect": {
            fill: "#f39c12"
        },
        ".uml-class-methods-rect": {
            fill: "#f39c12"
        }
    }
}, {
    getClassName: function() {
        return [
            "<<Interface>>",
            this.get("name")
        ];
    }
});
const InterfaceView = ClassView;
const Generalization = (0, _linkMjs.Link).define("uml.Generalization", {
    attrs: {
        ".marker-target": {
            d: "M 20 0 L 0 10 L 20 20 z",
            fill: "white"
        }
    }
});
const Implementation = (0, _linkMjs.Link).define("uml.Implementation", {
    attrs: {
        ".marker-target": {
            d: "M 20 0 L 0 10 L 20 20 z",
            fill: "white"
        },
        ".connection": {
            "stroke-dasharray": "3,3"
        }
    }
});
const Aggregation = (0, _linkMjs.Link).define("uml.Aggregation", {
    attrs: {
        ".marker-target": {
            d: "M 40 10 L 20 20 L 0 10 L 20 0 z",
            fill: "white"
        }
    }
});
const Composition = (0, _linkMjs.Link).define("uml.Composition", {
    attrs: {
        ".marker-target": {
            d: "M 40 10 L 20 20 L 0 10 L 20 0 z",
            fill: "black"
        }
    }
});
const Association = (0, _linkMjs.Link).define("uml.Association");
const State = (0, _basicMjs.Generic).define("uml.State", {
    attrs: {
        ".uml-state-body": {
            "width": 200,
            "height": 200,
            "rx": 10,
            "ry": 10,
            "fill": "#ecf0f1",
            "stroke": "#bdc3c7",
            "stroke-width": 3
        },
        ".uml-state-separator": {
            "stroke": "#bdc3c7",
            "stroke-width": 2
        },
        ".uml-state-name": {
            "ref": ".uml-state-body",
            "ref-x": .5,
            "ref-y": 5,
            "text-anchor": "middle",
            "fill": "#000000",
            "font-family": "Courier New",
            "font-size": 14
        },
        ".uml-state-events": {
            "ref": ".uml-state-separator",
            "ref-x": 5,
            "ref-y": 5,
            "fill": "#000000",
            "font-family": "Courier New",
            "font-size": 14
        }
    },
    name: "State",
    events: []
}, {
    markup: [
        '<g class="rotatable">',
        '<g class="scalable">',
        '<rect class="uml-state-body"/>',
        "</g>",
        '<path class="uml-state-separator"/>',
        '<text class="uml-state-name"/>',
        '<text class="uml-state-events"/>',
        "</g>"
    ].join(""),
    initialize: function() {
        this.on({
            "change:name": this.updateName,
            "change:events": this.updateEvents,
            "change:size": this.updatePath
        }, this);
        this.updateName();
        this.updateEvents();
        this.updatePath();
        (0, _basicMjs.Generic).prototype.initialize.apply(this, arguments);
    },
    updateName: function() {
        this.attr(".uml-state-name/text", this.get("name"));
    },
    updateEvents: function() {
        this.attr(".uml-state-events/text", this.get("events").join("\n"));
    },
    updatePath: function() {
        var d = "M 0 20 L " + this.get("size").width + " 20";
        // We are using `silent: true` here because updatePath() is meant to be called
        // on resize and there's no need to to update the element twice (`change:size`
        // triggers also an update).
        this.attr(".uml-state-separator/d", d, {
            silent: true
        });
    }
});
const StartState = (0, _basicMjs.Circle).define("uml.StartState", {
    type: "uml.StartState",
    attrs: {
        circle: {
            "fill": "#34495e",
            "stroke": "#2c3e50",
            "stroke-width": 2,
            "rx": 1
        }
    }
});
const EndState = (0, _basicMjs.Generic).define("uml.EndState", {
    size: {
        width: 20,
        height: 20
    },
    attrs: {
        "circle.outer": {
            transform: "translate(10, 10)",
            r: 10,
            fill: "#ffffff",
            stroke: "#2c3e50"
        },
        "circle.inner": {
            transform: "translate(10, 10)",
            r: 6,
            fill: "#34495e"
        }
    }
}, {
    markup: '<g class="rotatable"><g class="scalable"><circle class="outer"/><circle class="inner"/></g></g>'
});
const Transition = (0, _linkMjs.Link).define("uml.Transition", {
    attrs: {
        ".marker-target": {
            d: "M 10 0 L 0 5 L 10 10 z",
            fill: "#34495e",
            stroke: "#2c3e50"
        },
        ".connection": {
            stroke: "#2c3e50"
        }
    }
});

},{"../dia/ElementView.mjs":"dHPd6","../dia/Link.mjs":"kX2vg","./basic.mjs":"frFBw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hOAcI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "env", ()=>(0, _indexMjs15.env));
parcelHelpers.export(exports, "Vectorizer", ()=>Vectorizer);
parcelHelpers.export(exports, "layout", ()=>layout);
parcelHelpers.export(exports, "config", ()=>(0, _indexMjs13.config));
parcelHelpers.export(exports, "anchors", ()=>_indexMjs5);
parcelHelpers.export(exports, "linkAnchors", ()=>_indexMjs6);
parcelHelpers.export(exports, "connectionPoints", ()=>_indexMjs2);
parcelHelpers.export(exports, "connectionStrategies", ()=>_indexMjs3);
parcelHelpers.export(exports, "connectors", ()=>_indexMjs);
parcelHelpers.export(exports, "dia", ()=>_indexMjs7);
parcelHelpers.export(exports, "highlighters", ()=>_indexMjs1);
parcelHelpers.export(exports, "mvc", ()=>_indexMjs11);
parcelHelpers.export(exports, "routers", ()=>_indexMjs4);
parcelHelpers.export(exports, "util", ()=>_indexMjs10);
parcelHelpers.export(exports, "linkTools", ()=>_indexMjs8);
parcelHelpers.export(exports, "elementTools", ()=>_indexMjs9);
parcelHelpers.export(exports, "V", ()=>(0, _indexMjsDefault.default));
parcelHelpers.export(exports, "g", ()=>_indexMjs12);
parcelHelpers.export(exports, "setTheme", ()=>setTheme);
var _indexMjs = require("./connectors/index.mjs");
var _indexMjs1 = require("./highlighters/index.mjs");
var _indexMjs2 = require("./connectionPoints/index.mjs");
var _indexMjs3 = require("./connectionStrategies/index.mjs");
var _indexMjs4 = require("./routers/index.mjs");
var _indexMjs5 = require("./anchors/index.mjs");
var _indexMjs6 = require("./linkAnchors/index.mjs");
var _indexMjs7 = require("./dia/index.mjs");
var _indexMjs8 = require("./linkTools/index.mjs");
var _indexMjs9 = require("./elementTools/index.mjs");
var _indexMjs10 = require("./util/index.mjs");
var _indexMjs11 = require("./mvc/index.mjs");
var _indexMjs12 = require("./g/index.mjs");
var _indexMjs13 = require("./config/index.mjs");
var _indexMjs14 = require("./V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs14);
var _portMjs = require("./layout/ports/port.mjs");
var _portLabelMjs = require("./layout/ports/portLabel.mjs");
var _versionMjs = require("../dist/version.mjs");
parcelHelpers.exportAll(_versionMjs, exports);
var _indexMjs15 = require("./env/index.mjs");
const Vectorizer = (0, _indexMjsDefault.default);
const layout = {
    PortLabel: _portLabelMjs,
    Port: _portMjs
};
const setTheme = function(theme, opt) {
    opt = opt || {};
    _indexMjs10.invoke(_indexMjs11.views, "setTheme", theme, opt);
    // Update the default theme on the view prototype.
    _indexMjs11.View.prototype.defaultTheme = theme;
};

},{"./connectors/index.mjs":false,"./highlighters/index.mjs":false,"./connectionPoints/index.mjs":false,"./connectionStrategies/index.mjs":false,"./routers/index.mjs":false,"./anchors/index.mjs":"bihsF","./linkAnchors/index.mjs":false,"./dia/index.mjs":"28Zj5","./linkTools/index.mjs":false,"./elementTools/index.mjs":false,"./util/index.mjs":"eL7pI","./mvc/index.mjs":"c2o6n","./g/index.mjs":false,"./config/index.mjs":false,"./V/index.mjs":"iw8UN","./layout/ports/port.mjs":"8tv5s","./layout/ports/portLabel.mjs":"lkFuH","../dist/version.mjs":false,"./env/index.mjs":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hiSTf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _straightMjs = require("./straight.mjs");
parcelHelpers.exportAll(_straightMjs, exports);
var _jumpoverMjs = require("./jumpover.mjs");
parcelHelpers.exportAll(_jumpoverMjs, exports);
var _normalMjs = require("./normal.mjs");
parcelHelpers.exportAll(_normalMjs, exports);
var _roundedMjs = require("./rounded.mjs");
parcelHelpers.exportAll(_roundedMjs, exports);
var _smoothMjs = require("./smooth.mjs");
parcelHelpers.exportAll(_smoothMjs, exports);
var _curveMjs = require("./curve.mjs");
parcelHelpers.exportAll(_curveMjs, exports);

},{"./straight.mjs":"6FGM1","./jumpover.mjs":"5aXn2","./normal.mjs":"gXakZ","./rounded.mjs":"hKbjo","./smooth.mjs":"jsrYa","./curve.mjs":"dbXIY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6FGM1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "straight", ()=>straight);
var _indexMjs = require("../g/index.mjs");
const CornerTypes = {
    POINT: "point",
    CUBIC: "cubic",
    LINE: "line",
    GAP: "gap"
};
const DEFINED_CORNER_TYPES = Object.values(CornerTypes);
const CORNER_RADIUS = 10;
const PRECISION = 1;
const straight = function(sourcePoint, targetPoint, routePoints = [], opt = {}) {
    const { cornerType = CornerTypes.POINT, cornerRadius = CORNER_RADIUS, cornerPreserveAspectRatio = false, precision = PRECISION, raw = false } = opt;
    if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) // unknown `cornerType` provided => error
    throw new Error("Invalid `cornerType` provided to `straight` connector.");
    let path;
    if (cornerType === CornerTypes.POINT || !cornerRadius) {
        // default option => normal connector
        // simply connect all points with straight lines
        const points = [
            sourcePoint
        ].concat(routePoints).concat([
            targetPoint
        ]);
        const polyline = new _indexMjs.Polyline(points);
        path = new _indexMjs.Path(polyline);
    } else {
        // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types
        path = new _indexMjs.Path();
        // add initial gap segment = to source point
        path.appendSegment(_indexMjs.Path.createSegment("M", sourcePoint));
        let nextDistance;
        const routePointsLength = routePoints.length;
        for(let i = 0; i < routePointsLength; i++){
            const curr = new _indexMjs.Point(routePoints[i]);
            const prev = routePoints[i - 1] || sourcePoint;
            const next = routePoints[i + 1] || targetPoint;
            const prevDistance = nextDistance || curr.distance(prev) / 2; // try to re-use previously-computed `nextDistance`
            nextDistance = curr.distance(next) / 2;
            let startMove, endMove;
            if (!cornerPreserveAspectRatio) {
                // `startMove` and `endMove` may be different
                // (this happens when next or previous path point is closer than `2 * cornerRadius`)
                startMove = -Math.min(cornerRadius, prevDistance);
                endMove = -Math.min(cornerRadius, nextDistance);
            } else // force `startMove` and `endMove` to be the same
            startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);
            // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):
            // - find a point lying on the line `prev - startMove` such that...
            // - ...the point lies `abs(startMove)` distance away from `curr`...
            // - ...and its coordinates are rounded to whole numbers
            const cornerStart = curr.clone().move(prev, startMove).round(precision);
            const cornerEnd = curr.clone().move(next, endMove).round(precision);
            // add in-between straight segment = from previous route point to corner start point
            // (may have zero length)
            path.appendSegment(_indexMjs.Path.createSegment("L", cornerStart));
            // add corner segment = from corner start point to corner end point
            switch(cornerType){
                case CornerTypes.CUBIC:
                    {
                        // corner is rounded
                        const _13 = 1 / 3;
                        const _23 = 2 / 3;
                        const control1 = new _indexMjs.Point(_13 * cornerStart.x + _23 * curr.x, _23 * curr.y + _13 * cornerStart.y);
                        const control2 = new _indexMjs.Point(_13 * cornerEnd.x + _23 * curr.x, _23 * curr.y + _13 * cornerEnd.y);
                        path.appendSegment(_indexMjs.Path.createSegment("C", control1, control2, cornerEnd));
                        break;
                    }
                case CornerTypes.LINE:
                    // corner has bevel
                    path.appendSegment(_indexMjs.Path.createSegment("L", cornerEnd));
                    break;
                case CornerTypes.GAP:
                    // corner has empty space
                    path.appendSegment(_indexMjs.Path.createSegment("M", cornerEnd));
                    break;
            }
        }
        // add final straight segment = from last corner end point to target point
        // (= or from start point to end point, if there are no route points)
        // (may have zero length)
        path.appendSegment(_indexMjs.Path.createSegment("L", targetPoint));
    }
    return raw ? path : path.serialize();
};

},{"../g/index.mjs":"i91Db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5aXn2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "jumpover", ()=>jumpover);
var _indexMjs = require("../util/index.mjs");
var _indexMjs1 = require("../g/index.mjs");
// default size of jump if not specified in options
var JUMP_SIZE = 5;
// available jump types
// first one taken as default
var JUMP_TYPES = [
    "arc",
    "gap",
    "cubic"
];
// default radius
var RADIUS = 0;
// takes care of math. error for case when jump is too close to end of line
var CLOSE_PROXIMITY_PADDING = 1;
// list of connector types not to jump over.
var IGNORED_CONNECTORS = [
    "smooth"
];
// internal constants for round segment
var _13 = 1 / 3;
var _23 = 2 / 3;
function sortPointsAscending(p1, p2) {
    let { x: x1, y: y1 } = p1;
    let { x: x2, y: y2 } = p2;
    if (x1 > x2) {
        let swap = x1;
        x1 = x2;
        x2 = swap;
        swap = y1;
        y1 = y2;
        y2 = swap;
    }
    if (y1 > y2) {
        let swap = x1;
        x1 = x2;
        x2 = swap;
        swap = y1;
        y1 = y2;
        y2 = swap;
    }
    return [
        new _indexMjs1.Point(x1, y1),
        new _indexMjs1.Point(x2, y2)
    ];
}
function overlapExists(line1, line2) {
    const [{ x: x1, y: y1 }, { x: x2, y: y2 }] = sortPointsAscending(line1.start, line1.end);
    const [{ x: x3, y: y3 }, { x: x4, y: y4 }] = sortPointsAscending(line2.start, line2.end);
    const xMatch = x1 <= x4 && x3 <= x2;
    const yMatch = y1 <= y4 && y3 <= y2;
    return xMatch && yMatch;
}
/**
 * Transform start/end and route into series of lines
 * @param {g.point} sourcePoint start point
 * @param {g.point} targetPoint end point
 * @param {g.point[]} route optional list of route
 * @return {g.line[]} [description]
 */ function createLines(sourcePoint, targetPoint, route) {
    // make a flattened array of all points
    var points = [].concat(sourcePoint, route, targetPoint);
    return points.reduce(function(resultLines, point, idx) {
        // if there is a next point, make a line with it
        var nextPoint = points[idx + 1];
        if (nextPoint != null) resultLines[idx] = _indexMjs1.line(point, nextPoint);
        return resultLines;
    }, []);
}
function setupUpdating(jumpOverLinkView) {
    var paper = jumpOverLinkView.paper;
    var updateList = paper._jumpOverUpdateList;
    // first time setup for this paper
    if (updateList == null) {
        updateList = paper._jumpOverUpdateList = [];
        var graph = paper.model;
        graph.on("batch:stop", function() {
            if (this.hasActiveBatch()) return;
            updateJumpOver(paper);
        });
        graph.on("reset", function() {
            updateList = paper._jumpOverUpdateList = [];
        });
    }
    // add this link to a list so it can be updated when some other link is updated
    if (updateList.indexOf(jumpOverLinkView) < 0) {
        updateList.push(jumpOverLinkView);
        // watch for change of connector type or removal of link itself
        // to remove the link from a list of jump over connectors
        jumpOverLinkView.listenToOnce(jumpOverLinkView.model, "change:connector remove", function() {
            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);
        });
    }
}
/**
 * Handler for a batch:stop event to force
 * update of all registered links with jump over connector
 * @param {object} batchEvent optional object with info about batch
 */ function updateJumpOver(paper) {
    var updateList = paper._jumpOverUpdateList;
    for(var i = 0; i < updateList.length; i++){
        const linkView = updateList[i];
        const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);
        linkView.requestUpdate(updateFlag);
    }
}
/**
 * Utility function to collect all intersection points of a single
 * line against group of other lines.
 * @param {g.line} line where to find points
 * @param {g.line[]} crossCheckLines lines to cross
 * @return {g.point[]} list of intersection points
 */ function findLineIntersections(line, crossCheckLines) {
    return _indexMjs.toArray(crossCheckLines).reduce(function(res, crossCheckLine) {
        var intersection = line.intersection(crossCheckLine);
        if (intersection) res.push(intersection);
        return res;
    }, []);
}
/**
 * Sorting function for list of points by their distance.
 * @param {g.point} p1 first point
 * @param {g.point} p2 second point
 * @return {number} squared distance between points
 */ function sortPoints(p1, p2) {
    return _indexMjs1.line(p1, p2).squaredLength();
}
/**
 * Split input line into multiple based on intersection points.
 * @param {g.line} line input line to split
 * @param {g.point[]} intersections points where to split the line
 * @param {number} jumpSize the size of jump arc (length empty spot on a line)
 * @return {g.line[]} list of lines being split
 */ function createJumps(line, intersections, jumpSize) {
    return intersections.reduce(function(resultLines, point, idx) {
        // skipping points that were merged with the previous line
        // to make bigger arc over multiple lines that are close to each other
        if (point.skip === true) return resultLines;
        // always grab the last line from buffer and modify it
        var lastLine = resultLines.pop() || line;
        // calculate start and end of jump by moving by a given size of jump
        var jumpStart = _indexMjs1.point(point).move(lastLine.start, -jumpSize);
        var jumpEnd = _indexMjs1.point(point).move(lastLine.start, +jumpSize);
        // now try to look at the next intersection point
        var nextPoint = intersections[idx + 1];
        if (nextPoint != null) {
            var distance = jumpEnd.distance(nextPoint);
            if (distance <= jumpSize) {
                // next point is close enough, move the jump end by this
                // difference and mark the next point to be skipped
                jumpEnd = nextPoint.move(lastLine.start, distance);
                nextPoint.skip = true;
            }
        } else {
            // this block is inside of `else` as an optimization so the distance is
            // not calculated when we know there are no other intersection points
            var endDistance = jumpStart.distance(lastLine.end);
            // if the end is too close to possible jump, draw remaining line instead of a jump
            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
                resultLines.push(lastLine);
                return resultLines;
            }
        }
        var startDistance = jumpEnd.distance(lastLine.start);
        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
            // if the start of line is too close to jump, draw that line instead of a jump
            resultLines.push(lastLine);
            return resultLines;
        }
        // finally create a jump line
        var jumpLine = _indexMjs1.line(jumpStart, jumpEnd);
        // it's just simple line but with a `isJump` property
        jumpLine.isJump = true;
        resultLines.push(_indexMjs1.line(lastLine.start, jumpStart), jumpLine, _indexMjs1.line(jumpEnd, lastLine.end));
        return resultLines;
    }, []);
}
/**
 * Assemble `D` attribute of a SVG path by iterating given lines.
 * @param {g.line[]} lines source lines to use
 * @param {number} jumpSize the size of jump arc (length empty spot on a line)
 * @param {number} radius the radius
 * @return {string}
 */ function buildPath(lines, jumpSize, jumpType, radius) {
    var path = new _indexMjs1.Path();
    var segment;
    // first move to the start of a first line
    segment = _indexMjs1.Path.createSegment("M", lines[0].start);
    path.appendSegment(segment);
    // make a paths from lines
    _indexMjs.toArray(lines).forEach(function(line, index) {
        if (line.isJump) {
            var angle, diff;
            var control1, control2;
            if (jumpType === "arc") {
                angle = -90;
                // determine rotation of arc based on difference between points
                diff = line.start.difference(line.end);
                // make sure the arc always points up (or right)
                var xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);
                if (xAxisRotate) angle += 180;
                var midpoint = line.midpoint();
                var centerLine = new _indexMjs1.Line(midpoint, line.end).rotate(midpoint, angle);
                var halfLine;
                // first half
                halfLine = new _indexMjs1.Line(line.start, midpoint);
                control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);
                control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);
                segment = _indexMjs1.Path.createSegment("C", control1, control2, centerLine.end);
                path.appendSegment(segment);
                // second half
                halfLine = new _indexMjs1.Line(midpoint, line.end);
                control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);
                control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);
                segment = _indexMjs1.Path.createSegment("C", control1, control2, line.end);
                path.appendSegment(segment);
            } else if (jumpType === "gap") {
                segment = _indexMjs1.Path.createSegment("M", line.end);
                path.appendSegment(segment);
            } else if (jumpType === "cubic") {
                angle = line.start.theta(line.end);
                var xOffset = jumpSize * 0.6;
                var yOffset = jumpSize * 1.35;
                // determine rotation of arc based on difference between points
                diff = line.start.difference(line.end);
                // make sure the arc always points up (or right)
                xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);
                if (xAxisRotate) yOffset *= -1;
                control1 = _indexMjs1.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);
                control2 = _indexMjs1.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);
                segment = _indexMjs1.Path.createSegment("C", control1, control2, line.end);
                path.appendSegment(segment);
            }
        } else {
            var nextLine = lines[index + 1];
            if (radius == 0 || !nextLine || nextLine.isJump) {
                segment = _indexMjs1.Path.createSegment("L", line.end);
                path.appendSegment(segment);
            } else buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);
        }
    });
    return path;
}
function buildRoundedSegment(offset, path, curr, prev, next) {
    var prevDistance = curr.distance(prev) / 2;
    var nextDistance = curr.distance(next) / 2;
    var startMove = -Math.min(offset, prevDistance);
    var endMove = -Math.min(offset, nextDistance);
    var roundedStart = curr.clone().move(prev, startMove).round();
    var roundedEnd = curr.clone().move(next, endMove).round();
    var control1 = new _indexMjs1.Point(_13 * roundedStart.x + _23 * curr.x, _23 * curr.y + _13 * roundedStart.y);
    var control2 = new _indexMjs1.Point(_13 * roundedEnd.x + _23 * curr.x, _23 * curr.y + _13 * roundedEnd.y);
    var segment;
    segment = _indexMjs1.Path.createSegment("L", roundedStart);
    path.appendSegment(segment);
    segment = _indexMjs1.Path.createSegment("C", control1, control2, roundedEnd);
    path.appendSegment(segment);
}
const jumpover = function(sourcePoint, targetPoint, route, opt) {
    setupUpdating(this);
    var raw = opt.raw;
    var jumpSize = opt.size || JUMP_SIZE;
    var jumpType = opt.jump && ("" + opt.jump).toLowerCase();
    var radius = opt.radius || RADIUS;
    var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;
    // grab the first jump type as a default if specified one is invalid
    if (JUMP_TYPES.indexOf(jumpType) === -1) jumpType = JUMP_TYPES[0];
    var paper = this.paper;
    var graph = paper.model;
    var allLinks = graph.getLinks();
    // there is just one link, draw it directly
    if (allLinks.length === 1) return buildPath(createLines(sourcePoint, targetPoint, route), jumpSize, jumpType, radius);
    var thisModel = this.model;
    var thisIndex = allLinks.indexOf(thisModel);
    var defaultConnector = paper.options.defaultConnector || {};
    // not all links are meant to be jumped over.
    var links = allLinks.filter(function(link, idx) {
        var connector = link.get("connector") || defaultConnector;
        // avoid jumping over links with connector type listed in `ignored connectors`.
        if (_indexMjs.toArray(ignoreConnectors).includes(connector.name)) return false;
        // filter out links that are above this one and  have the same connector type
        // otherwise there would double hoops for each intersection
        if (idx > thisIndex) return connector.name !== "jumpover";
        return true;
    });
    // find views for all links
    var linkViews = links.map(function(link) {
        return paper.findViewByModel(link);
    });
    // create lines for this link
    var thisLines = createLines(sourcePoint, targetPoint, route);
    // create lines for all other links
    var linkLines = linkViews.map(function(linkView) {
        if (linkView == null) return [];
        if (linkView === this) return thisLines;
        return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.route);
    }, this);
    // transform lines for this link by splitting with jump lines at
    // points of intersection with other links
    var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {
        // iterate all links and grab the intersections with this line
        // these are then sorted by distance so the line can be split more easily
        var intersections = links.reduce(function(res, link, i) {
            // don't intersection with itself
            if (link !== thisModel) {
                const linkLinesToTest = linkLines[i].slice();
                const overlapIndex = linkLinesToTest.findIndex((line)=>overlapExists(thisLine, line));
                // Overlap occurs and the end point of one segment lies on thisLine
                if (overlapIndex > -1 && thisLine.containsPoint(linkLinesToTest[overlapIndex].end)) // Remove the next segment because there will never be a jump
                linkLinesToTest.splice(overlapIndex + 1, 1);
                const lineIntersections = findLineIntersections(thisLine, linkLinesToTest);
                res.push.apply(res, lineIntersections);
            }
            return res;
        }, []).sort(function(a, b) {
            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);
        });
        if (intersections.length > 0) // split the line based on found intersection points
        resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));
        else // without any intersection the line goes uninterrupted
        resultLines.push(thisLine);
        return resultLines;
    }, []);
    var path = buildPath(jumpingLines, jumpSize, jumpType, radius);
    return raw ? path : path.serialize();
};

},{"../util/index.mjs":"eL7pI","../g/index.mjs":"i91Db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gXakZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normal", ()=>normal);
var _straightMjs = require("./straight.mjs");
const normal = function(sourcePoint, targetPoint, route = [], opt = {}) {
    const { raw } = opt;
    const localOpt = {
        cornerType: "point",
        raw
    };
    return (0, _straightMjs.straight)(sourcePoint, targetPoint, route, localOpt);
};

},{"./straight.mjs":"6FGM1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hKbjo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rounded", ()=>rounded);
var _straightMjs = require("./straight.mjs");
const CORNER_RADIUS = 10;
const PRECISION = 0;
const rounded = function(sourcePoint, targetPoint, route = [], opt = {}) {
    const { radius = CORNER_RADIUS, raw } = opt;
    const localOpt = {
        cornerType: "cubic",
        cornerRadius: radius,
        precision: PRECISION,
        raw
    };
    return (0, _straightMjs.straight)(sourcePoint, targetPoint, route, localOpt);
};

},{"./straight.mjs":"6FGM1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jsrYa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "smooth", ()=>smooth);
var _indexMjs = require("../g/index.mjs");
const smooth = function(sourcePoint, targetPoint, route, opt) {
    var raw = opt && opt.raw;
    var path;
    if (route && route.length !== 0) {
        var points = [
            sourcePoint
        ].concat(route).concat([
            targetPoint
        ]);
        var curves = _indexMjs.Curve.throughPoints(points);
        path = new _indexMjs.Path(curves);
    } else {
        // if we have no route, use a default cubic bezier curve
        // cubic bezier requires two control points
        // the control points have `x` midway between source and target
        // this produces an S-like curve
        path = new _indexMjs.Path();
        var segment;
        segment = _indexMjs.Path.createSegment("M", sourcePoint);
        path.appendSegment(segment);
        if (Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y)) {
            var controlPointX = (sourcePoint.x + targetPoint.x) / 2;
            segment = _indexMjs.Path.createSegment("C", controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);
            path.appendSegment(segment);
        } else {
            var controlPointY = (sourcePoint.y + targetPoint.y) / 2;
            segment = _indexMjs.Path.createSegment("C", sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);
            path.appendSegment(segment);
        }
    }
    return raw ? path : path.serialize();
};

},{"../g/index.mjs":"i91Db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dbXIY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "curve", ()=>curve);
var _indexMjs = require("../g/index.mjs");
const Directions = {
    AUTO: "auto",
    HORIZONTAL: "horizontal",
    VERTICAL: "vertical",
    CLOSEST_POINT: "closest-point",
    OUTWARDS: "outwards"
};
const TangentDirections = {
    UP: "up",
    DOWN: "down",
    LEFT: "left",
    RIGHT: "right",
    AUTO: "auto",
    CLOSEST_POINT: "closest-point",
    OUTWARDS: "outwards"
};
const curve = function(sourcePoint, targetPoint, route = [], opt = {}, linkView) {
    const raw = Boolean(opt.raw);
    // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.
    // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.
    // tension - a Catmull-Rom curve tension parameter.
    // sourceTangent - a tangent vector along the curve at the sourcePoint.
    // sourceDirection - a unit direction vector along the curve at the sourcePoint.
    // targetTangent - a tangent vector along the curve at the targetPoint.
    // targetDirection - a unit direction vector along the curve at the targetPoint.
    // precision - a rounding precision for path values.
    const { direction = Directions.AUTO, precision = 3 } = opt;
    const options = {
        coeff: opt.distanceCoefficient || 0.6,
        angleTangentCoefficient: opt.angleTangentCoefficient || 80,
        tau: opt.tension || 0.5,
        sourceTangent: opt.sourceTangent ? new (0, _indexMjs.Point)(opt.sourceTangent) : null,
        targetTangent: opt.targetTangent ? new (0, _indexMjs.Point)(opt.targetTangent) : null,
        rotate: Boolean(opt.rotate)
    };
    if (typeof opt.sourceDirection === "string") options.sourceDirection = opt.sourceDirection;
    else if (typeof opt.sourceDirection === "number") options.sourceDirection = new (0, _indexMjs.Point)(1, 0).rotate(null, opt.sourceDirection);
    else options.sourceDirection = opt.sourceDirection ? new (0, _indexMjs.Point)(opt.sourceDirection).normalize() : null;
    if (typeof opt.targetDirection === "string") options.targetDirection = opt.targetDirection;
    else if (typeof opt.targetDirection === "number") options.targetDirection = new (0, _indexMjs.Point)(1, 0).rotate(null, opt.targetDirection);
    else options.targetDirection = opt.targetDirection ? new (0, _indexMjs.Point)(opt.targetDirection).normalize() : null;
    const completeRoute = [
        sourcePoint,
        ...route,
        targetPoint
    ].map((p)=>new (0, _indexMjs.Point)(p));
    // The calculation of a sourceTangent
    let sourceTangent;
    if (options.sourceTangent) sourceTangent = options.sourceTangent;
    else {
        const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);
        const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;
        const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();
        const angle = angleBetweenVectors(sourceDirection, pointsVector);
        if (angle > Math.PI / 4) {
            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;
            sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);
        } else sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);
    }
    // The calculation of a targetTangent
    let targetTangent;
    if (options.targetTangent) targetTangent = options.targetTangent;
    else {
        const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);
        const last = completeRoute.length - 1;
        const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;
        const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();
        const angle = angleBetweenVectors(targetDirection, pointsVector);
        if (angle > Math.PI / 4) {
            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;
            targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);
        } else targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);
    }
    const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);
    const bezierCurves = catmullRomCurves.map((curve)=>catmullRomToBezier(curve, options));
    const path = new (0, _indexMjs.Path)(bezierCurves).round(precision);
    return raw ? path : path.serialize();
};
curve.Directions = Directions;
curve.TangentDirections = TangentDirections;
function getHorizontalSourceDirection(linkView, route, options) {
    const { sourceBBox } = linkView;
    let sourceSide;
    let rotation;
    if (!linkView.sourceView) {
        if (sourceBBox.x > route[1].x) sourceSide = "right";
        else sourceSide = "left";
    } else {
        rotation = linkView.sourceView.model.angle();
        if (options.rotate && rotation) {
            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);
            const sourcePoint = route[0].clone();
            sourcePoint.rotate(sourceBBox.center(), rotation);
            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);
        } else sourceSide = sourceBBox.sideNearestToPoint(route[0]);
    }
    let direction;
    switch(sourceSide){
        case "left":
            direction = new (0, _indexMjs.Point)(-1, 0);
            break;
        case "right":
        default:
            direction = new (0, _indexMjs.Point)(1, 0);
            break;
    }
    if (options.rotate && rotation) direction.rotate(null, -rotation);
    return direction;
}
function getHorizontalTargetDirection(linkView, route, options) {
    const { targetBBox } = linkView;
    let targetSide;
    let rotation;
    if (!linkView.targetView) {
        if (targetBBox.x > route[route.length - 2].x) targetSide = "left";
        else targetSide = "right";
    } else {
        rotation = linkView.targetView.model.angle();
        if (options.rotate && rotation) {
            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);
            const targetPoint = route[route.length - 1].clone();
            targetPoint.rotate(targetBBox.center(), rotation);
            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);
        } else targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);
    }
    let direction;
    switch(targetSide){
        case "left":
            direction = new (0, _indexMjs.Point)(-1, 0);
            break;
        case "right":
        default:
            direction = new (0, _indexMjs.Point)(1, 0);
            break;
    }
    if (options.rotate && rotation) direction.rotate(null, -rotation);
    return direction;
}
function getVerticalSourceDirection(linkView, route, options) {
    const { sourceBBox } = linkView;
    let sourceSide;
    let rotation;
    if (!linkView.sourceView) {
        if (sourceBBox.y > route[1].y) sourceSide = "bottom";
        else sourceSide = "top";
    } else {
        rotation = linkView.sourceView.model.angle();
        if (options.rotate && rotation) {
            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);
            const sourcePoint = route[0].clone();
            sourcePoint.rotate(sourceBBox.center(), rotation);
            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);
        } else sourceSide = sourceBBox.sideNearestToPoint(route[0]);
    }
    let direction;
    switch(sourceSide){
        case "top":
            direction = new (0, _indexMjs.Point)(0, -1);
            break;
        case "bottom":
        default:
            direction = new (0, _indexMjs.Point)(0, 1);
            break;
    }
    if (options.rotate && rotation) direction.rotate(null, -rotation);
    return direction;
}
function getVerticalTargetDirection(linkView, route, options) {
    const { targetBBox } = linkView;
    let targetSide;
    let rotation;
    if (!linkView.targetView) {
        if (targetBBox.y > route[route.length - 2].y) targetSide = "top";
        else targetSide = "bottom";
    } else {
        rotation = linkView.targetView.model.angle();
        if (options.rotate && rotation) {
            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);
            const targetPoint = route[route.length - 1].clone();
            targetPoint.rotate(targetBBox.center(), rotation);
            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);
        } else targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);
    }
    let direction;
    switch(targetSide){
        case "top":
            direction = new (0, _indexMjs.Point)(0, -1);
            break;
        case "bottom":
        default:
            direction = new (0, _indexMjs.Point)(0, 1);
            break;
    }
    if (options.rotate && rotation) direction.rotate(null, -rotation);
    return direction;
}
function getAutoSourceDirection(linkView, route, options) {
    const { sourceBBox } = linkView;
    let sourceSide;
    let rotation;
    if (!linkView.sourceView) sourceSide = sourceBBox.sideNearestToPoint(route[1]);
    else {
        rotation = linkView.sourceView.model.angle();
        if (options.rotate && rotation) {
            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);
            const sourcePoint = route[0].clone();
            sourcePoint.rotate(sourceBBox.center(), rotation);
            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);
        } else sourceSide = sourceBBox.sideNearestToPoint(route[0]);
    }
    let direction;
    switch(sourceSide){
        case "top":
            direction = new (0, _indexMjs.Point)(0, -1);
            break;
        case "bottom":
            direction = new (0, _indexMjs.Point)(0, 1);
            break;
        case "right":
            direction = new (0, _indexMjs.Point)(1, 0);
            break;
        case "left":
            direction = new (0, _indexMjs.Point)(-1, 0);
            break;
    }
    if (options.rotate && rotation) direction.rotate(null, -rotation);
    return direction;
}
function getAutoTargetDirection(linkView, route, options) {
    const { targetBBox } = linkView;
    let targetSide;
    let rotation;
    if (!linkView.targetView) targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);
    else {
        rotation = linkView.targetView.model.angle();
        if (options.rotate && rotation) {
            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);
            const targetPoint = route[route.length - 1].clone();
            targetPoint.rotate(targetBBox.center(), rotation);
            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);
        } else targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);
    }
    let direction;
    switch(targetSide){
        case "top":
            direction = new (0, _indexMjs.Point)(0, -1);
            break;
        case "bottom":
            direction = new (0, _indexMjs.Point)(0, 1);
            break;
        case "right":
            direction = new (0, _indexMjs.Point)(1, 0);
            break;
        case "left":
            direction = new (0, _indexMjs.Point)(-1, 0);
            break;
    }
    if (options.rotate && rotation) direction.rotate(null, -rotation);
    return direction;
}
function getClosestPointSourceDirection(linkView, route, options) {
    return route[1].difference(route[0]).normalize();
}
function getClosestPointTargetDirection(linkView, route, options) {
    const last = route.length - 1;
    return route[last - 1].difference(route[last]).normalize();
}
function getOutwardsSourceDirection(linkView, route, options) {
    const { sourceBBox } = linkView;
    const sourceCenter = sourceBBox.center();
    return route[0].difference(sourceCenter).normalize();
}
function getOutwardsTargetDirection(linkView, route, options) {
    const { targetBBox } = linkView;
    const targetCenter = targetBBox.center();
    return route[route.length - 1].difference(targetCenter).normalize();
}
function getSourceTangentDirection(linkView, route, direction, options) {
    if (options.sourceDirection) switch(options.sourceDirection){
        case TangentDirections.UP:
            return new (0, _indexMjs.Point)(0, -1);
        case TangentDirections.DOWN:
            return new (0, _indexMjs.Point)(0, 1);
        case TangentDirections.LEFT:
            return new (0, _indexMjs.Point)(-1, 0);
        case TangentDirections.RIGHT:
            return new (0, _indexMjs.Point)(1, 0);
        case TangentDirections.AUTO:
            return getAutoSourceDirection(linkView, route, options);
        case TangentDirections.CLOSEST_POINT:
            return getClosestPointSourceDirection(linkView, route, options);
        case TangentDirections.OUTWARDS:
            return getOutwardsSourceDirection(linkView, route, options);
        default:
            return options.sourceDirection;
    }
    switch(direction){
        case Directions.HORIZONTAL:
            return getHorizontalSourceDirection(linkView, route, options);
        case Directions.VERTICAL:
            return getVerticalSourceDirection(linkView, route, options);
        case Directions.CLOSEST_POINT:
            return getClosestPointSourceDirection(linkView, route, options);
        case Directions.OUTWARDS:
            return getOutwardsSourceDirection(linkView, route, options);
        case Directions.AUTO:
        default:
            return getAutoSourceDirection(linkView, route, options);
    }
}
function getTargetTangentDirection(linkView, route, direction, options) {
    if (options.targetDirection) switch(options.targetDirection){
        case TangentDirections.UP:
            return new (0, _indexMjs.Point)(0, -1);
        case TangentDirections.DOWN:
            return new (0, _indexMjs.Point)(0, 1);
        case TangentDirections.LEFT:
            return new (0, _indexMjs.Point)(-1, 0);
        case TangentDirections.RIGHT:
            return new (0, _indexMjs.Point)(0, 1);
        case TangentDirections.AUTO:
            return getAutoTargetDirection(linkView, route, options);
        case TangentDirections.CLOSEST_POINT:
            return getClosestPointTargetDirection(linkView, route, options);
        case TangentDirections.OUTWARDS:
            return getOutwardsTargetDirection(linkView, route, options);
        default:
            return options.targetDirection;
    }
    switch(direction){
        case Directions.HORIZONTAL:
            return getHorizontalTargetDirection(linkView, route, options);
        case Directions.VERTICAL:
            return getVerticalTargetDirection(linkView, route, options);
        case Directions.CLOSEST_POINT:
            return getClosestPointTargetDirection(linkView, route, options);
        case Directions.OUTWARDS:
            return getOutwardsTargetDirection(linkView, route, options);
        case Directions.AUTO:
        default:
            return getAutoTargetDirection(linkView, route, options);
    }
}
function rotateVector(vector, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const x = cos * vector.x - sin * vector.y;
    const y = sin * vector.x + cos * vector.y;
    vector.x = x;
    vector.y = y;
}
function angleBetweenVectors(v1, v2) {
    let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());
    if (cos < -1) cos = -1;
    if (cos > 1) cos = 1;
    return Math.acos(cos);
}
function determinant(v1, v2) {
    return v1.x * v2.y - v1.y * v2.x;
}
function createCatmullRomCurves(points, sourceTangent, targetTangent, options) {
    const { tau, coeff } = options;
    const distances = [];
    const tangents = [];
    const catmullRomCurves = [];
    const n = points.length - 1;
    for(let i = 0; i < n; i++)distances[i] = points[i].distance(points[i + 1]);
    tangents[0] = sourceTangent;
    tangents[n] = targetTangent;
    // The calculation of tangents of vertices
    for(let i = 1; i < n; i++){
        let tpPrev;
        let tpNext;
        if (i === 1) tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);
        else tpPrev = points[i - 1].clone();
        if (i === n - 1) tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);
        else tpNext = points[i + 1].clone();
        const v1 = tpPrev.difference(points[i]).normalize();
        const v2 = tpNext.difference(points[i]).normalize();
        const vAngle = angleBetweenVectors(v1, v2);
        let rot = (Math.PI - vAngle) / 2;
        let t;
        const vectorDeterminant = determinant(v1, v2);
        let pointsDeterminant;
        pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));
        if (vectorDeterminant < 0) rot = -rot;
        if (vAngle < Math.PI / 2 && (rot < 0 && pointsDeterminant < 0 || rot > 0 && pointsDeterminant > 0)) rot = rot - Math.PI;
        t = v2.clone();
        rotateVector(t, rot);
        const t1 = t.clone();
        const t2 = t.clone();
        const scaleFactor1 = distances[i - 1] * coeff;
        const scaleFactor2 = distances[i] * coeff;
        t1.scale(scaleFactor1, scaleFactor1);
        t2.scale(scaleFactor2, scaleFactor2);
        tangents[i] = [
            t1,
            t2
        ];
    }
    // The building of a Catmull-Rom curve based of tangents of points
    for(let i = 0; i < n; i++){
        let p0;
        let p3;
        if (i === 0) p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);
        else p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);
        if (i === n - 1) p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);
        else p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);
        catmullRomCurves[i] = [
            p0,
            points[i],
            points[i + 1],
            p3
        ];
    }
    return catmullRomCurves;
}
// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)
function catmullRomToBezier(points, options) {
    const { tau } = options;
    const bcp1 = new (0, _indexMjs.Point)();
    bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);
    bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);
    const bcp2 = new (0, _indexMjs.Point)();
    bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);
    bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);
    return new (0, _indexMjs.Curve)(points[1], bcp1, bcp2, points[2]);
}

},{"../g/index.mjs":"i91Db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5aoGO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _strokeMjs = require("./stroke.mjs");
parcelHelpers.exportAll(_strokeMjs, exports);
var _maskMjs = require("./mask.mjs");
parcelHelpers.exportAll(_maskMjs, exports);
var _opacityMjs = require("./opacity.mjs");
parcelHelpers.exportAll(_opacityMjs, exports);
var _addClassMjs = require("./addClass.mjs");
parcelHelpers.exportAll(_addClassMjs, exports);
var _listMjs = require("./list.mjs");
parcelHelpers.exportAll(_listMjs, exports);

},{"./stroke.mjs":"kwy9e","./mask.mjs":"f7jRp","./opacity.mjs":"bawSK","./addClass.mjs":"54jlF","./list.mjs":"ejBbe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kwy9e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stroke", ()=>stroke);
var _indexMjs = require("../util/index.mjs");
var _indexMjs1 = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
var _highlighterViewMjs = require("../dia/HighlighterView.mjs");
const stroke = (0, _highlighterViewMjs.HighlighterView).extend({
    tagName: "path",
    className: "highlight-stroke",
    attributes: {
        "pointer-events": "none",
        "vector-effect": "non-scaling-stroke",
        "fill": "none"
    },
    options: {
        padding: 3,
        rx: 0,
        ry: 0,
        useFirstSubpath: false,
        attrs: {
            "stroke-width": 3,
            "stroke": "#FEB663"
        }
    },
    getPathData (cellView, node) {
        const { options } = this;
        const { useFirstSubpath } = options;
        let d;
        try {
            const vNode = (0, _indexMjsDefault.default)(node);
            d = vNode.convertToPathData().trim();
            if (vNode.tagName() === "PATH" && useFirstSubpath) {
                const secondSubpathIndex = d.search(/.M/i) + 1;
                if (secondSubpathIndex > 0) d = d.substr(0, secondSubpathIndex);
            }
        } catch (error) {
            // Failed to get path data from magnet element.
            // Draw a rectangle around the node instead.
            const nodeBBox = cellView.getNodeBoundingRect(node);
            d = (0, _indexMjsDefault.default).rectToPath((0, _indexMjs.assign)({}, options, nodeBBox.toJSON()));
        }
        return d;
    },
    highlightConnection (cellView) {
        this.vel.attr("d", cellView.getSerializedConnection());
    },
    highlightNode (cellView, node) {
        const { vel, options } = this;
        const { padding, layer } = options;
        let highlightMatrix = this.getNodeMatrix(cellView, node);
        // Add padding to the highlight element.
        if (padding) {
            if (!layer && node === cellView.el) // If the highlighter is appended to the cellView
            // and we measure the size of the cellView wrapping group
            // it's necessary to remove the highlighter first
            vel.remove();
            let nodeBBox = cellView.getNodeBoundingRect(node);
            const cx = nodeBBox.x + nodeBBox.width / 2;
            const cy = nodeBBox.y + nodeBBox.height / 2;
            nodeBBox = (0, _indexMjsDefault.default).transformRect(nodeBBox, highlightMatrix);
            const width = Math.max(nodeBBox.width, 1);
            const height = Math.max(nodeBBox.height, 1);
            const sx = (width + padding) / width;
            const sy = (height + padding) / height;
            const paddingMatrix = (0, _indexMjsDefault.default).createSVGMatrix({
                a: sx,
                b: 0,
                c: 0,
                d: sy,
                e: cx - sx * cx,
                f: cy - sy * cy
            });
            highlightMatrix = highlightMatrix.multiply(paddingMatrix);
        }
        vel.attr({
            "d": this.getPathData(cellView, node),
            "transform": (0, _indexMjsDefault.default).matrixToTransformString(highlightMatrix)
        });
    },
    highlight (cellView, node) {
        const { vel, options } = this;
        vel.attr(options.attrs);
        if (cellView.isNodeConnection(node)) this.highlightConnection(cellView);
        else this.highlightNode(cellView, node);
    }
});

},{"../util/index.mjs":"eL7pI","../V/index.mjs":"iw8UN","../dia/HighlighterView.mjs":"1vHPf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f7jRp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mask", ()=>mask);
var _indexMjs = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _highlighterViewMjs = require("../dia/HighlighterView.mjs");
const MASK_CLIP = 20;
function forEachDescendant(vel, fn) {
    const descendants = vel.children();
    while(descendants.length > 0){
        const descendant = descendants.shift();
        if (fn(descendant)) descendants.push(...descendant.children());
    }
}
const mask = (0, _highlighterViewMjs.HighlighterView).extend({
    tagName: "rect",
    className: "highlight-mask",
    attributes: {
        "pointer-events": "none"
    },
    options: {
        padding: 3,
        maskClip: MASK_CLIP,
        deep: false,
        attrs: {
            "stroke": "#FEB663",
            "stroke-width": 3,
            "stroke-linecap": "butt",
            "stroke-linejoin": "miter"
        }
    },
    VISIBLE: "white",
    INVISIBLE: "black",
    MASK_ROOT_ATTRIBUTE_BLACKLIST: [
        "marker-start",
        "marker-end",
        "marker-mid",
        "transform",
        "stroke-dasharray",
        "class"
    ],
    MASK_CHILD_ATTRIBUTE_BLACKLIST: [
        "stroke",
        "fill",
        "stroke-width",
        "stroke-opacity",
        "stroke-dasharray",
        "fill-opacity",
        "marker-start",
        "marker-end",
        "marker-mid",
        "class"
    ],
    // TODO: change the list to a function callback
    MASK_REPLACE_TAGS: [
        "FOREIGNOBJECT",
        "IMAGE",
        "USE",
        "TEXT",
        "TSPAN",
        "TEXTPATH"
    ],
    // TODO: change the list to a function callback
    MASK_REMOVE_TAGS: [
        "TEXT",
        "TSPAN",
        "TEXTPATH"
    ],
    transformMaskChild (cellView, childEl) {
        const { MASK_CHILD_ATTRIBUTE_BLACKLIST, MASK_REPLACE_TAGS, MASK_REMOVE_TAGS } = this;
        const childTagName = childEl.tagName();
        // Do not include the element in the mask's image
        if (!(0, _indexMjsDefault.default).isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {
            childEl.remove();
            return false;
        }
        // Replace the element with a rectangle
        if (MASK_REPLACE_TAGS.includes(childTagName)) {
            // Note: clone() method does not change the children ids
            const originalChild = cellView.vel.findOne(`#${childEl.id}`);
            if (originalChild) {
                const { node: originalNode } = originalChild;
                let childBBox = cellView.getNodeBoundingRect(originalNode);
                if (cellView.model.isElement()) childBBox = (0, _indexMjsDefault.default).transformRect(childBBox, cellView.getNodeMatrix(originalNode));
                const replacement = (0, _indexMjsDefault.default)("rect", childBBox.toJSON());
                const { x: ox, y: oy } = childBBox.center();
                const { angle, cx = ox, cy = oy } = originalChild.rotate();
                if (angle) replacement.rotate(angle, cx, cy);
                // Note: it's not important to keep the same sibling index since all subnodes are filled
                childEl.parent().append(replacement);
            }
            childEl.remove();
            return false;
        }
        // Keep the element, but clean it from certain attributes
        MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach((attrName)=>{
            if (attrName === "fill" && childEl.attr("fill") === "none") return;
            childEl.removeAttr(attrName);
        });
        return true;
    },
    transformMaskRoot (_cellView, rootEl) {
        const { MASK_ROOT_ATTRIBUTE_BLACKLIST } = this;
        MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach((attrName)=>{
            rootEl.removeAttr(attrName);
        });
    },
    getMaskShape (cellView, vel) {
        const { options, MASK_REPLACE_TAGS } = this;
        const { deep } = options;
        const tagName = vel.tagName();
        let maskRoot;
        if (tagName === "G") {
            if (!deep) return null;
            maskRoot = vel.clone();
            forEachDescendant(maskRoot, (maskChild)=>this.transformMaskChild(cellView, maskChild));
        } else {
            if (MASK_REPLACE_TAGS.includes(tagName)) return null;
            maskRoot = vel.clone();
        }
        this.transformMaskRoot(cellView, maskRoot);
        return maskRoot;
    },
    getMaskId () {
        return `highlight-mask-${this.cid}`;
    },
    getMask (cellView, vNode) {
        const { VISIBLE, INVISIBLE, options } = this;
        const { padding, attrs } = options;
        const strokeWidth = "stroke-width" in attrs ? attrs["stroke-width"] : 1;
        const hasNodeFill = vNode.attr("fill") !== "none";
        let magnetStrokeWidth = parseFloat(vNode.attr("stroke-width"));
        if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;
        // stroke of the invisible shape
        const minStrokeWidth = magnetStrokeWidth + padding * 2;
        // stroke of the visible shape
        const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;
        let maskEl = this.getMaskShape(cellView, vNode);
        if (!maskEl) {
            const nodeBBox = cellView.getNodeBoundingRect(vNode.node);
            // Make sure the rect is visible
            nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);
            maskEl = (0, _indexMjsDefault.default)("rect", nodeBBox.toJSON());
        }
        maskEl.attr(attrs);
        return (0, _indexMjsDefault.default)("mask", {
            "id": this.getMaskId()
        }).append([
            maskEl.clone().attr({
                "fill": hasNodeFill ? VISIBLE : "none",
                "stroke": VISIBLE,
                "stroke-width": maxStrokeWidth
            }),
            maskEl.clone().attr({
                "fill": hasNodeFill ? INVISIBLE : "none",
                "stroke": INVISIBLE,
                "stroke-width": minStrokeWidth
            })
        ]);
    },
    removeMask (paper) {
        const maskNode = paper.svg.getElementById(this.getMaskId());
        if (maskNode) paper.defs.removeChild(maskNode);
    },
    addMask (paper, maskEl) {
        paper.defs.appendChild(maskEl.node);
    },
    highlight (cellView, node) {
        const { options, vel } = this;
        const { padding, attrs, maskClip = MASK_CLIP, layer } = options;
        const color = "stroke" in attrs ? attrs["stroke"] : "#000000";
        if (!layer && node === cellView.el) // If the highlighter is appended to the cellView
        // and we measure the size of the cellView wrapping group
        // it's necessary to remove the highlighter first
        vel.remove();
        const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);
        const highlightMatrix = this.getNodeMatrix(cellView, node);
        const maskEl = this.getMask(cellView, (0, _indexMjsDefault.default)(node));
        this.addMask(cellView.paper, maskEl);
        vel.attr(highlighterBBox.toJSON());
        vel.attr({
            "transform": (0, _indexMjsDefault.default).matrixToTransformString(highlightMatrix),
            "mask": `url(#${maskEl.id})`,
            "fill": color
        });
    },
    unhighlight (cellView) {
        this.removeMask(cellView.paper);
    }
});

},{"../V/index.mjs":"iw8UN","../dia/HighlighterView.mjs":"1vHPf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bawSK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "opacity", ()=>opacity);
var _indexMjs = require("../util/index.mjs");
var _indexMjs1 = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
var _highlighterViewMjs = require("../dia/HighlighterView.mjs");
const opacity = (0, _highlighterViewMjs.HighlighterView).extend({
    UPDATABLE: false,
    MOUNTABLE: false,
    opacityClassName: _indexMjs.addClassNamePrefix("highlight-opacity"),
    highlight: function(_cellView, node) {
        (0, _indexMjsDefault.default)(node).addClass(this.opacityClassName);
    },
    unhighlight: function(_cellView, node) {
        (0, _indexMjsDefault.default)(node).removeClass(this.opacityClassName);
    }
});

},{"../util/index.mjs":"eL7pI","../V/index.mjs":"iw8UN","../dia/HighlighterView.mjs":"1vHPf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"54jlF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addClass", ()=>addClass);
var _indexMjs = require("../util/index.mjs");
var _indexMjs1 = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
var _highlighterViewMjs = require("../dia/HighlighterView.mjs");
const className = _indexMjs.addClassNamePrefix("highlighted");
const addClass = (0, _highlighterViewMjs.HighlighterView).extend({
    UPDATABLE: false,
    MOUNTABLE: false,
    options: {
        className
    },
    highlight: function(_cellView, node) {
        (0, _indexMjsDefault.default)(node).addClass(this.options.className);
    },
    unhighlight: function(_cellView, node) {
        (0, _indexMjsDefault.default)(node).removeClass(this.options.className);
    }
}, {
    // Backwards Compatibility
    className
});

},{"../util/index.mjs":"eL7pI","../V/index.mjs":"iw8UN","../dia/HighlighterView.mjs":"1vHPf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ejBbe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "list", ()=>list);
var _indexMjs = require("../g/index.mjs");
var _highlighterViewMjs = require("../dia/HighlighterView.mjs");
var _indexMjs1 = require("../util/index.mjs");
var _getRectPointMjs = require("../util/getRectPoint.mjs");
const Directions = {
    ROW: "row",
    COLUMN: "column"
};
const list = (0, _highlighterViewMjs.HighlighterView).extend({
    tagName: "g",
    MOUNTABLE: true,
    UPDATE_ATTRIBUTES: function() {
        return [
            this.options.attribute
        ];
    },
    _prevItems: null,
    highlight (elementView, node) {
        const element = elementView.model;
        const { attribute, size = 20, gap = 5, direction = Directions.ROW } = this.options;
        if (!attribute) throw new Error("List: attribute is required");
        const normalizedSize = typeof size === "number" ? {
            width: size,
            height: size
        } : size;
        const isRowDirection = direction === Directions.ROW;
        const itemWidth = isRowDirection ? normalizedSize.width : normalizedSize.height;
        let items = element.get(attribute);
        if (!Array.isArray(items)) items = [];
        const prevItems = this._prevItems || [];
        const comparison = items.map((item, index)=>(0, _indexMjs1.isEqual)(prevItems[index], items[index]));
        if (prevItems.length !== items.length || comparison.some((unchanged)=>!unchanged)) {
            const prevEls = this.vel.children();
            const itemsEls = items.map((item, index)=>{
                const prevEl = index in prevEls ? prevEls[index].node : null;
                if (comparison[index]) return prevEl;
                const itemEl = this.createListItem(item, normalizedSize, prevEl);
                if (!itemEl) return null;
                if (!(itemEl instanceof SVGElement)) throw new Error("List: item must be an SVGElement");
                itemEl.dataset.index = index;
                itemEl.dataset.attribute = attribute;
                const offset = index * (itemWidth + gap);
                itemEl.setAttribute("transform", isRowDirection ? `translate(${offset}, 0)` : `translate(0, ${offset})`);
                return itemEl;
            });
            this.vel.empty().append(itemsEls);
            this._prevItems = items;
        }
        const itemsCount = items.length;
        const length = itemsCount === 0 ? 0 : itemsCount * itemWidth + (itemsCount - 1) * gap;
        const listSize = isRowDirection ? {
            width: length,
            height: normalizedSize.height
        } : {
            width: normalizedSize.width,
            height: length
        };
        this.position(element, listSize);
    },
    position (element, listSize) {
        const { vel, options } = this;
        const { margin = 5, position = "top-left" } = options;
        const { width, height } = element.size();
        const { left, right, top, bottom } = (0, _indexMjs1.normalizeSides)(margin);
        const bbox = new (0, _indexMjs.Rect)(left, top, width - (left + right), height - (top + bottom));
        let { x, y } = (0, _getRectPointMjs.getRectPoint)(bbox, position);
        // x
        switch(position){
            case (0, _getRectPointMjs.Positions).CENTER:
            case (0, _getRectPointMjs.Positions).TOP:
            case (0, _getRectPointMjs.Positions).BOTTOM:
                x -= listSize.width / 2;
                break;
            case (0, _getRectPointMjs.Positions).RIGHT:
            case (0, _getRectPointMjs.Positions).BOTTOM_RIGHT:
            case (0, _getRectPointMjs.Positions).TOP_RIGHT:
                x -= listSize.width;
                break;
        }
        // y
        switch(position){
            case (0, _getRectPointMjs.Positions).CENTER:
            case (0, _getRectPointMjs.Positions).RIGHT:
            case (0, _getRectPointMjs.Positions).LEFT:
                y -= listSize.height / 2;
                break;
            case (0, _getRectPointMjs.Positions).BOTTOM:
            case (0, _getRectPointMjs.Positions).BOTTOM_RIGHT:
            case (0, _getRectPointMjs.Positions).BOTTOM_LEFT:
                y -= listSize.height;
                break;
        }
        vel.attr("transform", `translate(${x}, ${y})`);
    }
}, {
    Directions,
    Positions: (0, _getRectPointMjs.Positions)
});

},{"../g/index.mjs":"i91Db","../dia/HighlighterView.mjs":"1vHPf","../util/index.mjs":"eL7pI","../util/getRectPoint.mjs":"fsMP9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5MgYT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "anchor", ()=>anchor);
parcelHelpers.export(exports, "bbox", ()=>bbox);
parcelHelpers.export(exports, "rectangle", ()=>rectangle);
parcelHelpers.export(exports, "boundary", ()=>boundary);
var _indexMjs = require("../g/index.mjs");
var _indexMjs1 = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
var _indexMjs2 = require("../util/index.mjs");
function offsetPoint(p1, p2, offset) {
    if (_indexMjs2.isPlainObject(offset)) {
        const { x, y } = offset;
        if (isFinite(y)) {
            const line = new _indexMjs.Line(p2, p1);
            const { start, end } = line.parallel(y);
            p2 = start;
            p1 = end;
        }
        offset = x;
    }
    if (!isFinite(offset)) return p1;
    var length = p1.distance(p2);
    if (offset === 0 && length > 0) return p1;
    return p1.move(p2, -Math.min(offset, length - 1));
}
function stroke(magnet) {
    var stroke = magnet.getAttribute("stroke-width");
    if (stroke === null) return 0;
    return parseFloat(stroke) || 0;
}
function alignLine(line, type, offset = 0) {
    let coordinate, a, b, direction;
    const { start, end } = line;
    switch(type){
        case "left":
            coordinate = "x";
            a = end;
            b = start;
            direction = -1;
            break;
        case "right":
            coordinate = "x";
            a = start;
            b = end;
            direction = 1;
            break;
        case "top":
            coordinate = "y";
            a = end;
            b = start;
            direction = -1;
            break;
        case "bottom":
            coordinate = "y";
            a = start;
            b = end;
            direction = 1;
            break;
        default:
            return;
    }
    if (start[coordinate] < end[coordinate]) a[coordinate] = b[coordinate];
    else b[coordinate] = a[coordinate];
    if (isFinite(offset)) {
        a[coordinate] += direction * offset;
        b[coordinate] += direction * offset;
    }
}
// Connection Points
function anchorConnectionPoint(line, _view, _magnet, opt) {
    let { offset, alignOffset, align } = opt;
    if (align) alignLine(line, align, alignOffset);
    return offsetPoint(line.end, line.start, offset);
}
function bboxIntersection(line, view, magnet, opt) {
    var bbox = view.getNodeBBox(magnet);
    if (opt.stroke) bbox.inflate(stroke(magnet) / 2);
    var intersections = line.intersect(bbox);
    var cp = intersections ? line.start.chooseClosest(intersections) : line.end;
    return offsetPoint(cp, line.start, opt.offset);
}
function rectangleIntersection(line, view, magnet, opt) {
    var angle = view.model.angle();
    if (angle === 0) return bboxIntersection(line, view, magnet, opt);
    var bboxWORotation = view.getNodeUnrotatedBBox(magnet);
    if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);
    var center = bboxWORotation.center();
    var lineWORotation = line.clone().rotate(center, angle);
    var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);
    var cp = intersections ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle) : line.end;
    return offsetPoint(cp, line.start, opt.offset);
}
function findShapeNode(magnet) {
    if (!magnet) return null;
    var node = magnet;
    do {
        var tagName = node.tagName;
        if (typeof tagName !== "string") return null;
        tagName = tagName.toUpperCase();
        if (tagName === "G") node = node.firstElementChild;
        else if (tagName === "TITLE") node = node.nextElementSibling;
        else break;
    }while (node);
    return node;
}
var BNDR_SUBDIVISIONS = "segmentSubdivisons";
var BNDR_SHAPE_BBOX = "shapeBBox";
function boundaryIntersection(line, view, magnet, opt) {
    var node, intersection;
    var selector = opt.selector;
    var anchor = line.end;
    if (typeof selector === "string") node = view.findBySelector(selector)[0];
    else if (selector === false) node = magnet;
    else if (Array.isArray(selector)) node = _indexMjs2.getByPath(magnet, selector);
    else node = findShapeNode(magnet);
    if (!(0, _indexMjsDefault.default).isSVGGraphicsElement(node)) {
        if (node === magnet || !(0, _indexMjsDefault.default).isSVGGraphicsElement(magnet)) return anchor;
        node = magnet;
    }
    var localShape = view.getNodeShape(node);
    var magnetMatrix = view.getNodeMatrix(node);
    var translateMatrix = view.getRootTranslateMatrix();
    var rotateMatrix = view.getRootRotateMatrix();
    var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);
    var localMatrix = targetMatrix.inverse();
    var localLine = (0, _indexMjsDefault.default).transformLine(line, localMatrix);
    var localRef = localLine.start.clone();
    var data = view.getNodeData(node);
    if (opt.insideout === false) {
        if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();
        var localBBox = data[BNDR_SHAPE_BBOX];
        if (localBBox.containsPoint(localRef)) return anchor;
    }
    // Caching segment subdivisions for paths
    var pathOpt;
    if (localShape instanceof _indexMjs.Path) {
        var precision = opt.precision || 2;
        if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({
            precision: precision
        });
        pathOpt = {
            precision: precision,
            segmentSubdivisions: data[BNDR_SUBDIVISIONS]
        };
    }
    if (opt.extrapolate === true) localLine.setLength(1e6);
    intersection = localLine.intersect(localShape, pathOpt);
    if (intersection) // More than one intersection
    {
        if ((0, _indexMjsDefault.default).isArray(intersection)) intersection = localRef.chooseClosest(intersection);
    } else if (opt.sticky === true) {
        // No intersection, find the closest point instead
        if (localShape instanceof _indexMjs.Rect) intersection = localShape.pointNearestToPoint(localRef);
        else if (localShape instanceof _indexMjs.Ellipse) intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);
        else intersection = localShape.closestPoint(localRef, pathOpt);
    }
    var cp = intersection ? (0, _indexMjsDefault.default).transformPoint(intersection, targetMatrix) : anchor;
    var cpOffset = opt.offset || 0;
    if (opt.stroke) cpOffset += stroke(node) / 2;
    return offsetPoint(cp, line.start, cpOffset);
}
const anchor = anchorConnectionPoint;
const bbox = bboxIntersection;
const rectangle = rectangleIntersection;
const boundary = boundaryIntersection;

},{"../g/index.mjs":"i91Db","../V/index.mjs":"iw8UN","../util/index.mjs":"eL7pI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ms06":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _normalMjs = require("./normal.mjs");
parcelHelpers.exportAll(_normalMjs, exports);
var _oneSideMjs = require("./oneSide.mjs");
parcelHelpers.exportAll(_oneSideMjs, exports);
var _orthogonalMjs = require("./orthogonal.mjs");
parcelHelpers.exportAll(_orthogonalMjs, exports);
var _manhattanMjs = require("./manhattan.mjs");
parcelHelpers.exportAll(_manhattanMjs, exports);
var _metroMjs = require("./metro.mjs");
parcelHelpers.exportAll(_metroMjs, exports);
var _rightAngleMjs = require("./rightAngle.mjs");
parcelHelpers.exportAll(_rightAngleMjs, exports);

},{"./normal.mjs":"jyCtz","./oneSide.mjs":"34whS","./orthogonal.mjs":"hrB0D","./manhattan.mjs":"1Zztm","./metro.mjs":"dlLru","./rightAngle.mjs":"hvFgL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jyCtz":[function(require,module,exports) {
// Does not make any changes to vertices.
// Returns the arguments that are passed to it, unchanged.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normal", ()=>normal);
const normal = function(vertices, opt, linkView) {
    return vertices;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"34whS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "oneSide", ()=>oneSide);
var _indexMjs = require("../util/index.mjs");
const oneSide = function(vertices, opt, linkView) {
    var side = opt.side || "bottom";
    var padding = _indexMjs.normalizeSides(opt.padding || 40);
    // LinkView contains cached source an target bboxes.
    // Note that those are Geometry rectangle objects.
    var sourceBBox = linkView.sourceBBox;
    var targetBBox = linkView.targetBBox;
    var sourcePoint = sourceBBox.center();
    var targetPoint = targetBBox.center();
    var coordinate, dimension, direction;
    switch(side){
        case "bottom":
            direction = 1;
            coordinate = "y";
            dimension = "height";
            break;
        case "top":
            direction = -1;
            coordinate = "y";
            dimension = "height";
            break;
        case "left":
            direction = -1;
            coordinate = "x";
            dimension = "width";
            break;
        case "right":
            direction = 1;
            coordinate = "x";
            dimension = "width";
            break;
        default:
            throw new Error("Router: invalid side");
    }
    // move the points from the center of the element to outside of it.
    sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);
    targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);
    // make link orthogonal (at least the first and last vertex).
    if (direction * (sourcePoint[coordinate] - targetPoint[coordinate]) > 0) targetPoint[coordinate] = sourcePoint[coordinate];
    else sourcePoint[coordinate] = targetPoint[coordinate];
    return [
        sourcePoint
    ].concat(vertices, targetPoint);
};

},{"../util/index.mjs":"eL7pI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hrB0D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// MAIN ROUTER //
// Return points through which a connection needs to be drawn in order to obtain an orthogonal link
// routing from source to target going through `vertices`.
parcelHelpers.export(exports, "orthogonal", ()=>orthogonal);
var _indexMjs = require("../g/index.mjs");
var _indexMjs1 = require("../util/index.mjs");
// bearing -> opposite bearing
var opposites = {
    N: "S",
    S: "N",
    E: "W",
    W: "E"
};
// bearing -> radians
var radians = {
    N: -Math.PI / 2 * 3,
    S: -Math.PI / 2,
    E: 0,
    W: Math.PI
};
// HELPERS //
// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained
// in the given box
function freeJoin(p1, p2, bbox) {
    var p = new _indexMjs.Point(p1.x, p2.y);
    if (bbox.containsPoint(p)) p = new _indexMjs.Point(p2.x, p1.y);
    // kept for reference
    // if (bbox.containsPoint(p)) p = null;
    return p;
}
// returns either width or height of a bbox based on the given bearing
function getBBoxSize(bbox, bearing) {
    return bbox[bearing === "W" || bearing === "E" ? "width" : "height"];
}
// simple bearing method (calculates only orthogonal cardinals)
function getBearing(from, to) {
    if (from.x === to.x) return from.y > to.y ? "N" : "S";
    if (from.y === to.y) return from.x > to.x ? "W" : "E";
    return null;
}
// transform point to a rect
function getPointBox(p) {
    return new _indexMjs.Rect(p.x, p.y, 0, 0);
}
function getPaddingBox(opt) {
    // if both provided, opt.padding wins over opt.elementPadding
    var sides = _indexMjs1.normalizeSides(opt.padding || opt.elementPadding || 20);
    return {
        x: -sides.left,
        y: -sides.top,
        width: sides.left + sides.right,
        height: sides.top + sides.bottom
    };
}
// return source bbox
function getSourceBBox(linkView, opt) {
    return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));
}
// return target bbox
function getTargetBBox(linkView, opt) {
    return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));
}
// return source anchor
function getSourceAnchor(linkView, opt) {
    if (linkView.sourceAnchor) return linkView.sourceAnchor;
    // fallback: center of bbox
    var sourceBBox = getSourceBBox(linkView, opt);
    return sourceBBox.center();
}
// return target anchor
function getTargetAnchor(linkView, opt) {
    if (linkView.targetAnchor) return linkView.targetAnchor;
    // fallback: center of bbox
    var targetBBox = getTargetBBox(linkView, opt);
    return targetBBox.center(); // default
}
// PARTIAL ROUTERS //
function vertexVertex(from, to, bearing) {
    var p1 = new _indexMjs.Point(from.x, to.y);
    var p2 = new _indexMjs.Point(to.x, from.y);
    var d1 = getBearing(from, p1);
    var d2 = getBearing(from, p2);
    var opposite = opposites[bearing];
    var p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;
    return {
        points: [
            p
        ],
        direction: getBearing(p, to)
    };
}
function elementVertex(from, to, fromBBox) {
    var p = freeJoin(from, to, fromBBox);
    return {
        points: [
            p
        ],
        direction: getBearing(p, to)
    };
}
function vertexElement(from, to, toBBox, bearing) {
    var route = {};
    var points = [
        new _indexMjs.Point(from.x, to.y),
        new _indexMjs.Point(to.x, from.y)
    ];
    var freePoints = points.filter(function(pt) {
        return !toBBox.containsPoint(pt);
    });
    var freeBearingPoints = freePoints.filter(function(pt) {
        return getBearing(pt, from) !== bearing;
    });
    var p;
    if (freeBearingPoints.length > 0) {
        // Try to pick a point which bears the same direction as the previous segment.
        p = freeBearingPoints.filter(function(pt) {
            return getBearing(from, pt) === bearing;
        }).pop();
        p = p || freeBearingPoints[0];
        route.points = [
            p
        ];
        route.direction = getBearing(p, to);
    } else {
        // Here we found only points which are either contained in the element or they would create
        // a link segment going in opposite direction from the previous one.
        // We take the point inside element and move it outside the element in the direction the
        // route is going. Now we can join this point with the current end (using freeJoin).
        p = _indexMjs1.difference(points, freePoints)[0];
        var p2 = new _indexMjs.Point(to).move(p, -getBBoxSize(toBBox, bearing) / 2);
        var p1 = freeJoin(p2, from, toBBox);
        route.points = [
            p1,
            p2
        ];
        route.direction = getBearing(p2, to);
    }
    return route;
}
function elementElement(from, to, fromBBox, toBBox) {
    var route = elementVertex(to, from, toBBox);
    var p1 = route.points[0];
    if (fromBBox.containsPoint(p1)) {
        route = elementVertex(from, to, fromBBox);
        var p2 = route.points[0];
        if (toBBox.containsPoint(p2)) {
            var fromBorder = new _indexMjs.Point(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);
            var toBorder = new _indexMjs.Point(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);
            var mid = new _indexMjs.Line(fromBorder, toBorder).midpoint();
            var startRoute = elementVertex(from, mid, fromBBox);
            var endRoute = vertexVertex(mid, to, startRoute.direction);
            route.points = [
                startRoute.points[0],
                endRoute.points[0]
            ];
            route.direction = endRoute.direction;
        }
    }
    return route;
}
// Finds route for situations where one element is inside the other.
// Typically the route is directed outside the outer element first and
// then back towards the inner element.
function insideElement(from, to, fromBBox, toBBox, bearing) {
    var route = {};
    var boundary = fromBBox.union(toBBox).inflate(1);
    // start from the point which is closer to the boundary
    var reversed = boundary.center().distance(to) > boundary.center().distance(from);
    var start = reversed ? to : from;
    var end = reversed ? from : to;
    var p1, p2, p3;
    if (bearing) {
        // Points on circle with radius equals 'W + H` are always outside the rectangle
        // with width W and height H if the center of that circle is the center of that rectangle.
        p1 = _indexMjs.Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);
        p1 = boundary.pointNearestToPoint(p1).move(p1, -1);
    } else p1 = boundary.pointNearestToPoint(start).move(start, 1);
    p2 = freeJoin(p1, end, boundary);
    if (p1.round().equals(p2.round())) {
        p2 = _indexMjs.Point.fromPolar(boundary.width + boundary.height, _indexMjs.toRad(p1.theta(start)) + Math.PI / 2, end);
        p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();
        p3 = freeJoin(p1, p2, boundary);
        route.points = reversed ? [
            p2,
            p3,
            p1
        ] : [
            p1,
            p3,
            p2
        ];
    } else route.points = reversed ? [
        p2,
        p1
    ] : [
        p1,
        p2
    ];
    route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);
    return route;
}
function orthogonal(vertices, opt, linkView) {
    var sourceBBox = getSourceBBox(linkView, opt);
    var targetBBox = getTargetBBox(linkView, opt);
    var sourceAnchor = getSourceAnchor(linkView, opt);
    var targetAnchor = getTargetAnchor(linkView, opt);
    // if anchor lies outside of bbox, the bbox expands to include it
    sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));
    targetBBox = targetBBox.union(getPointBox(targetAnchor));
    vertices = _indexMjs1.toArray(vertices).map(_indexMjs.Point);
    vertices.unshift(sourceAnchor);
    vertices.push(targetAnchor);
    var bearing; // bearing of previous route segment
    var orthogonalVertices = []; // the array of found orthogonal vertices to be returned
    for(var i = 0, max = vertices.length - 1; i < max; i++){
        var route = null;
        var from = vertices[i];
        var to = vertices[i + 1];
        var isOrthogonal = !!getBearing(from, to);
        if (i === 0) {
            if (i + 1 === max) {
                // Expand one of the elements by 1px to detect situations when the two
                // elements are positioned next to each other with no gap in between.
                if (sourceBBox.intersect(targetBBox.clone().inflate(1))) route = insideElement(from, to, sourceBBox, targetBBox);
                else if (!isOrthogonal) route = elementElement(from, to, sourceBBox, targetBBox);
            } else {
                if (sourceBBox.containsPoint(to)) route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));
                else if (!isOrthogonal) route = elementVertex(from, to, sourceBBox);
            }
        } else if (i + 1 === max) {
            // prevent overlaps with previous line segment
            var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;
            if (targetBBox.containsPoint(from) || isOrthogonalLoop) route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);
            else if (!isOrthogonal) route = vertexElement(from, to, targetBBox, bearing);
        } else if (!isOrthogonal) route = vertexVertex(from, to, bearing);
        // applicable to all routes:
        // set bearing for next iteration
        if (route) {
            Array.prototype.push.apply(orthogonalVertices, route.points);
            bearing = route.direction;
        } else // orthogonal route and not looped
        bearing = getBearing(from, to);
        // push `to` point to identified orthogonal vertices array
        if (i + 1 < max) orthogonalVertices.push(to);
    }
    return orthogonalVertices;
}

},{"../g/index.mjs":"i91Db","../util/index.mjs":"eL7pI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Zztm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "manhattan", ()=>manhattan);
var _indexMjs = require("../g/index.mjs");
var _indexMjs1 = require("../util/index.mjs");
var _orthogonalMjs = require("./orthogonal.mjs");
var config = {
    // size of the step to find a route (the grid of the manhattan pathfinder)
    step: 10,
    // the number of route finding loops that cause the router to abort
    // returns fallback route instead
    maximumLoops: 2000,
    // the number of decimal places to round floating point coordinates
    precision: 1,
    // maximum change of direction
    maxAllowedDirectionChange: 90,
    // should the router use perpendicular linkView option?
    // does not connect anchor of element but rather a point close-by that is orthogonal
    // this looks much better
    perpendicular: true,
    // should the source and/or target not be considered as obstacles?
    excludeEnds: [],
    // should certain types of elements not be considered as obstacles?
    excludeTypes: [
        "basic.Text"
    ],
    // possible starting directions from an element
    startDirections: [
        "top",
        "right",
        "bottom",
        "left"
    ],
    // possible ending directions to an element
    endDirections: [
        "top",
        "right",
        "bottom",
        "left"
    ],
    // specify the directions used above and what they mean
    directionMap: {
        top: {
            x: 0,
            y: -1
        },
        right: {
            x: 1,
            y: 0
        },
        bottom: {
            x: 0,
            y: 1
        },
        left: {
            x: -1,
            y: 0
        }
    },
    // cost of an orthogonal step
    cost: function() {
        return this.step;
    },
    // an array of directions to find next points on the route
    // different from start/end directions
    directions: function() {
        var step = this.step;
        var cost = this.cost();
        return [
            {
                offsetX: step,
                offsetY: 0,
                cost: cost
            },
            {
                offsetX: -step,
                offsetY: 0,
                cost: cost
            },
            {
                offsetX: 0,
                offsetY: step,
                cost: cost
            },
            {
                offsetX: 0,
                offsetY: -step,
                cost: cost
            }
        ];
    },
    // a penalty received for direction change
    penalties: function() {
        return {
            0: 0,
            45: this.step / 2,
            90: this.step / 2
        };
    },
    // padding applied on the element bounding boxes
    paddingBox: function() {
        var step = this.step;
        return {
            x: -step,
            y: -step,
            width: 2 * step,
            height: 2 * step
        };
    },
    // A function that determines whether a given point is an obstacle or not.
    // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.
    // (point: dia.Point) => boolean;
    isPointObstacle: null,
    // a router to use when the manhattan router fails
    // (one of the partial routes returns null)
    fallbackRouter: function(vertices, opt, linkView) {
        if (!_indexMjs1.isFunction((0, _orthogonalMjs.orthogonal))) throw new Error("Manhattan requires the orthogonal router as default fallback.");
        return (0, _orthogonalMjs.orthogonal)(vertices, _indexMjs1.assign({}, config, opt), linkView);
    },
    /* Deprecated */ // a simple route used in situations when main routing method fails
    // (exceed max number of loop iterations, inaccessible)
    fallbackRoute: function(from, to, opt) {
        return null; // null result will trigger the fallbackRouter
    // left for reference:
    /*// Find an orthogonal route ignoring obstacles.

        var point = ((opt.previousDirAngle || 0) % 180 === 0)
                ? new g.Point(from.x, to.y)
                : new g.Point(to.x, from.y);

        return [point];*/ },
    // if a function is provided, it's used to route the link while dragging an end
    // i.e. function(from, to, opt) { return []; }
    draggingRoute: null
};
// HELPER CLASSES //
// Map of obstacles
// Helper structure to identify whether a point lies inside an obstacle.
function ObstacleMap(opt) {
    this.map = {};
    this.options = opt;
    // tells how to divide the paper when creating the elements map
    this.mapGridSize = 100;
}
ObstacleMap.prototype.build = function(graph, link) {
    var opt = this.options;
    // source or target element could be excluded from set of obstacles
    var excludedEnds = _indexMjs1.toArray(opt.excludeEnds).reduce(function(res, item) {
        var end = link.get(item);
        if (end) {
            var cell = graph.getCell(end.id);
            if (cell) res.push(cell);
        }
        return res;
    }, []);
    // Exclude any embedded elements from the source and the target element.
    var excludedAncestors = [];
    var source = graph.getCell(link.get("source").id);
    if (source) excludedAncestors = _indexMjs1.union(excludedAncestors, source.getAncestors().map(function(cell) {
        return cell.id;
    }));
    var target = graph.getCell(link.get("target").id);
    if (target) excludedAncestors = _indexMjs1.union(excludedAncestors, target.getAncestors().map(function(cell) {
        return cell.id;
    }));
    // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained
    // in any obstacle?) (a simplified grid search).
    // The paper is divided into smaller cells, where each holds information about which
    // elements belong to it. When we query whether a point lies inside an obstacle we
    // don't need to go through all obstacles, we check only those in a particular cell.
    var mapGridSize = this.mapGridSize;
    graph.getElements().reduce(function(map, element) {
        var isExcludedType = _indexMjs1.toArray(opt.excludeTypes).includes(element.get("type"));
        var isExcludedEnd = excludedEnds.find(function(excluded) {
            return excluded.id === element.id;
        });
        var isExcludedAncestor = excludedAncestors.includes(element.id);
        var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;
        if (!isExcluded) {
            var bbox = element.getBBox().moveAndExpand(opt.paddingBox);
            var origin = bbox.origin().snapToGrid(mapGridSize);
            var corner = bbox.corner().snapToGrid(mapGridSize);
            for(var x = origin.x; x <= corner.x; x += mapGridSize)for(var y = origin.y; y <= corner.y; y += mapGridSize){
                var gridKey = x + "@" + y;
                map[gridKey] = map[gridKey] || [];
                map[gridKey].push(bbox);
            }
        }
        return map;
    }, this.map);
    return this;
};
ObstacleMap.prototype.isPointAccessible = function(point) {
    var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();
    return _indexMjs1.toArray(this.map[mapKey]).every(function(obstacle) {
        return !obstacle.containsPoint(point);
    });
};
// Sorted Set
// Set of items sorted by given value.
function SortedSet() {
    this.items = [];
    this.hash = {};
    this.values = {};
    this.OPEN = 1;
    this.CLOSE = 2;
}
SortedSet.prototype.add = function(item, value) {
    if (this.hash[item]) // item removal
    this.items.splice(this.items.indexOf(item), 1);
    else this.hash[item] = this.OPEN;
    this.values[item] = value;
    var index = _indexMjs1.sortedIndex(this.items, item, (function(i) {
        return this.values[i];
    }).bind(this));
    this.items.splice(index, 0, item);
};
SortedSet.prototype.remove = function(item) {
    this.hash[item] = this.CLOSE;
};
SortedSet.prototype.isOpen = function(item) {
    return this.hash[item] === this.OPEN;
};
SortedSet.prototype.isClose = function(item) {
    return this.hash[item] === this.CLOSE;
};
SortedSet.prototype.isEmpty = function() {
    return this.items.length === 0;
};
SortedSet.prototype.pop = function() {
    var item = this.items.shift();
    this.remove(item);
    return item;
};
// HELPERS //
// return source bbox
function getSourceBBox(linkView, opt) {
    // expand by padding box
    if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);
    return linkView.sourceBBox.clone();
}
// return target bbox
function getTargetBBox(linkView, opt) {
    // expand by padding box
    if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);
    return linkView.targetBBox.clone();
}
// return source anchor
function getSourceAnchor(linkView, opt) {
    if (linkView.sourceAnchor) return linkView.sourceAnchor;
    // fallback: center of bbox
    var sourceBBox = getSourceBBox(linkView, opt);
    return sourceBBox.center();
}
// return target anchor
function getTargetAnchor(linkView, opt) {
    if (linkView.targetAnchor) return linkView.targetAnchor;
    // fallback: center of bbox
    var targetBBox = getTargetBBox(linkView, opt);
    return targetBBox.center(); // default
}
// returns a direction index from start point to end point
// corrects for grid deformation between start and end
function getDirectionAngle(start, end, numDirections, grid, opt) {
    var quadrant = 360 / numDirections;
    var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));
    var normalizedAngle = _indexMjs.normalizeAngle(angleTheta + quadrant / 2);
    return quadrant * Math.floor(normalizedAngle / quadrant);
}
// helper function for getDirectionAngle()
// corrects for grid deformation
// (if a point is one grid steps away from another in both dimensions,
// it is considered to be 45 degrees away, even if the real angle is different)
// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`
function fixAngleEnd(start, end, grid, opt) {
    var step = opt.step;
    var diffX = end.x - start.x;
    var diffY = end.y - start.y;
    var gridStepsX = diffX / grid.x;
    var gridStepsY = diffY / grid.y;
    var distanceX = gridStepsX * step;
    var distanceY = gridStepsY * step;
    return new _indexMjs.Point(start.x + distanceX, start.y + distanceY);
}
// return the change in direction between two direction angles
function getDirectionChange(angle1, angle2) {
    var directionChange = Math.abs(angle1 - angle2);
    return directionChange > 180 ? 360 - directionChange : directionChange;
}
// fix direction offsets according to current grid
function getGridOffsets(directions, grid, opt) {
    var step = opt.step;
    _indexMjs1.toArray(opt.directions).forEach(function(direction) {
        direction.gridOffsetX = direction.offsetX / step * grid.x;
        direction.gridOffsetY = direction.offsetY / step * grid.y;
    });
}
// get grid size in x and y dimensions, adapted to source and target positions
function getGrid(step, source, target) {
    return {
        source: source.clone(),
        x: getGridDimension(target.x - source.x, step),
        y: getGridDimension(target.y - source.y, step)
    };
}
// helper function for getGrid()
function getGridDimension(diff, step) {
    // return step if diff = 0
    if (!diff) return step;
    var absDiff = Math.abs(diff);
    var numSteps = Math.round(absDiff / step);
    // return absDiff if less than one step apart
    if (!numSteps) return absDiff;
    // otherwise, return corrected step
    var roundedDiff = numSteps * step;
    var remainder = absDiff - roundedDiff;
    var stepCorrection = remainder / numSteps;
    return step + stepCorrection;
}
// return a clone of point snapped to grid
function snapToGrid(point, grid) {
    var source = grid.source;
    var snappedX = _indexMjs.snapToGrid(point.x - source.x, grid.x) + source.x;
    var snappedY = _indexMjs.snapToGrid(point.y - source.y, grid.y) + source.y;
    return new _indexMjs.Point(snappedX, snappedY);
}
// round the point to opt.precision
function round(point, precision) {
    return point.round(precision);
}
// snap to grid and then round the point
function align(point, grid, precision) {
    return round(snapToGrid(point.clone(), grid), precision);
}
// return a string representing the point
// string is rounded in both dimensions
function getKey(point) {
    return point.clone().toString();
}
// return a normalized vector from given point
// used to determine the direction of a difference of two points
function normalizePoint(point) {
    return new _indexMjs.Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);
}
// PATHFINDING //
// reconstructs a route by concatenating points with their parents
function reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {
    var route = [];
    var prevDiff = normalizePoint(to.difference(tailPoint));
    // tailPoint is assumed to be aligned already
    var currentKey = getKey(tailPoint);
    var parent = parents[currentKey];
    var point;
    while(parent){
        // point is assumed to be aligned already
        point = points[currentKey];
        var diff = normalizePoint(point.difference(parent));
        if (!diff.equals(prevDiff)) {
            route.unshift(point);
            prevDiff = diff;
        }
        // parent is assumed to be aligned already
        currentKey = getKey(parent);
        parent = parents[currentKey];
    }
    // leadPoint is assumed to be aligned already
    var leadPoint = points[currentKey];
    var fromDiff = normalizePoint(leadPoint.difference(from));
    if (!fromDiff.equals(prevDiff)) route.unshift(leadPoint);
    return route;
}
// heuristic method to determine the distance between two points
function estimateCost(from, endPoints) {
    var min = Infinity;
    for(var i = 0, len = endPoints.length; i < len; i++){
        var cost = from.manhattanDistance(endPoints[i]);
        if (cost < min) min = cost;
    }
    return min;
}
// find points around the bbox taking given directions into account
// lines are drawn from anchor in given directions, intersections recorded
// if anchor is outside bbox, only those directions that intersect get a rect point
// the anchor itself is returned as rect point (representing some directions)
// (since those directions are unobstructed by the bbox)
function getRectPoints(anchor, bbox, directionList, grid, opt) {
    var precision = opt.precision;
    var directionMap = opt.directionMap;
    var anchorCenterVector = anchor.difference(bbox.center());
    var keys = _indexMjs1.isObject(directionMap) ? Object.keys(directionMap) : [];
    var dirList = _indexMjs1.toArray(directionList);
    var rectPoints = keys.reduce(function(res, key) {
        if (dirList.includes(key)) {
            var direction = directionMap[key];
            // create a line that is guaranteed to intersect the bbox if bbox is in the direction
            // even if anchor lies outside of bbox
            var endpoint = new _indexMjs.Point(anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height));
            var intersectionLine = new _indexMjs.Line(anchor, endpoint);
            // get the farther intersection, in case there are two
            // (that happens if anchor lies next to bbox)
            var intersections = intersectionLine.intersect(bbox) || [];
            var numIntersections = intersections.length;
            var farthestIntersectionDistance;
            var farthestIntersection = null;
            for(var i = 0; i < numIntersections; i++){
                var currentIntersection = intersections[i];
                var distance = anchor.squaredDistance(currentIntersection);
                if (farthestIntersectionDistance === undefined || distance > farthestIntersectionDistance) {
                    farthestIntersectionDistance = distance;
                    farthestIntersection = currentIntersection;
                }
            }
            // if an intersection was found in this direction, it is our rectPoint
            if (farthestIntersection) {
                var point = align(farthestIntersection, grid, precision);
                // if the rectPoint lies inside the bbox, offset it by one more step
                if (bbox.containsPoint(point)) point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);
                // then add the point to the result array
                // aligned
                res.push(point);
            }
        }
        return res;
    }, []);
    // if anchor lies outside of bbox, add it to the array of points
    if (!bbox.containsPoint(anchor)) // aligned
    rectPoints.push(align(anchor, grid, precision));
    return rectPoints;
}
// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm
// rectangles get rect points assigned by getRectPoints()
function findRoute(from, to, isPointObstacle, opt) {
    var precision = opt.precision;
    // Get grid for this route.
    var sourceAnchor, targetAnchor;
    if (from instanceof _indexMjs.Rect) sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);
    else sourceAnchor = round(from.clone(), precision);
    if (to instanceof _indexMjs.Rect) targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);
    else targetAnchor = round(to.clone(), precision);
    var grid = getGrid(opt.step, sourceAnchor, targetAnchor);
    // Get pathfinding points.
    var start, end; // aligned with grid by definition
    var startPoints, endPoints; // assumed to be aligned with grid already
    // set of points we start pathfinding from
    if (from instanceof _indexMjs.Rect) {
        start = sourceAnchor;
        startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);
    } else {
        start = sourceAnchor;
        startPoints = [
            start
        ];
    }
    // set of points we want the pathfinding to finish at
    if (to instanceof _indexMjs.Rect) {
        end = targetAnchor;
        endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);
    } else {
        end = targetAnchor;
        endPoints = [
            end
        ];
    }
    // take into account only accessible rect points (those not under obstacles)
    startPoints = startPoints.filter((p)=>!isPointObstacle(p));
    endPoints = endPoints.filter((p)=>!isPointObstacle(p));
    // Check that there is an accessible route point on both sides.
    // Otherwise, use fallbackRoute().
    if (startPoints.length > 0 && endPoints.length > 0) {
        // The set of tentative points to be evaluated, initially containing the start points.
        // Rounded to nearest integer for simplicity.
        var openSet = new SortedSet();
        // Keeps reference to actual points for given elements of the open set.
        var points = {};
        // Keeps reference to a point that is immediate predecessor of given element.
        var parents = {};
        // Cost from start to a point along best known path.
        var costs = {};
        for(var i = 0, n = startPoints.length; i < n; i++){
            // startPoint is assumed to be aligned already
            var startPoint = startPoints[i];
            var key = getKey(startPoint);
            openSet.add(key, estimateCost(startPoint, endPoints));
            points[key] = startPoint;
            costs[key] = 0;
        }
        var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route
        var isPathBeginning = previousRouteDirectionAngle === undefined;
        // directions
        var direction, directionChange;
        var directions = opt.directions;
        getGridOffsets(directions, grid, opt);
        var numDirections = directions.length;
        var endPointsKeys = _indexMjs1.toArray(endPoints).reduce(function(res, endPoint) {
            // endPoint is assumed to be aligned already
            var key = getKey(endPoint);
            res.push(key);
            return res;
        }, []);
        // main route finding loop
        var loopsRemaining = opt.maximumLoops;
        while(!openSet.isEmpty() && loopsRemaining > 0){
            // remove current from the open list
            var currentKey = openSet.pop();
            var currentPoint = points[currentKey];
            var currentParent = parents[currentKey];
            var currentCost = costs[currentKey];
            var isRouteBeginning = currentParent === undefined; // undefined for route starts
            var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction
            var previousDirectionAngle;
            if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route
            else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path
            else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point
            else previousDirectionAngle = null; // beginning of path, source anchor or `from` point
            // check if we reached any endpoint
            var samePoints = startPoints.length === endPoints.length;
            if (samePoints) {
                for(var j = 0; j < startPoints.length; j++)if (!startPoints[j].equals(endPoints[j])) {
                    samePoints = false;
                    break;
                }
            }
            var skipEndCheck = isRouteBeginning && samePoints;
            if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {
                opt.previousDirectionAngle = previousDirectionAngle;
                return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);
            }
            // go over all possible directions and find neighbors
            for(i = 0; i < numDirections; i++){
                direction = directions[i];
                var directionAngle = direction.angle;
                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);
                // if the direction changed rapidly, don't use this point
                // any direction is allowed for starting points
                if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;
                var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);
                var neighborKey = getKey(neighborPoint);
                // Closed points from the openSet were already evaluated.
                if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;
                // We can only enter end points at an acceptable angle.
                if (endPointsKeys.indexOf(neighborKey) >= 0) {
                    var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction
                    if (!isNeighborEnd) {
                        var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);
                        var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);
                        if (endDirectionChange > opt.maxAllowedDirectionChange) continue;
                    }
                }
                // The current direction is ok.
                var neighborCost = direction.cost;
                var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point
                var costFromStart = currentCost + neighborCost + neighborPenalty;
                if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {
                    // neighbor point has not been processed yet
                    // or the cost of the path from start is lower than previously calculated
                    points[neighborKey] = neighborPoint;
                    parents[neighborKey] = currentPoint;
                    costs[neighborKey] = costFromStart;
                    openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));
                }
            }
            loopsRemaining--;
        }
    }
    // no route found (`to` point either wasn't accessible or finding route took
    // way too much calculation)
    return opt.fallbackRoute.call(this, start, end, opt);
}
// resolve some of the options
function resolveOptions(opt) {
    opt.directions = _indexMjs1.result(opt, "directions");
    opt.penalties = _indexMjs1.result(opt, "penalties");
    opt.paddingBox = _indexMjs1.result(opt, "paddingBox");
    opt.padding = _indexMjs1.result(opt, "padding");
    if (opt.padding) {
        // if both provided, opt.padding wins over opt.paddingBox
        var sides = _indexMjs1.normalizeSides(opt.padding);
        opt.paddingBox = {
            x: -sides.left,
            y: -sides.top,
            width: sides.left + sides.right,
            height: sides.top + sides.bottom
        };
    }
    _indexMjs1.toArray(opt.directions).forEach(function(direction) {
        var point1 = new _indexMjs.Point(0, 0);
        var point2 = new _indexMjs.Point(direction.offsetX, direction.offsetY);
        direction.angle = _indexMjs.normalizeAngle(point1.theta(point2));
    });
}
// initialization of the route finding
function router(vertices, opt, linkView) {
    resolveOptions(opt);
    // enable/disable linkView perpendicular option
    linkView.options.perpendicular = !!opt.perpendicular;
    var sourceBBox = getSourceBBox(linkView, opt);
    var targetBBox = getTargetBBox(linkView, opt);
    var sourceAnchor = getSourceAnchor(linkView, opt);
    //var targetAnchor = getTargetAnchor(linkView, opt);
    // pathfinding
    let isPointObstacle;
    if (typeof opt.isPointObstacle === "function") isPointObstacle = opt.isPointObstacle;
    else {
        const map = new ObstacleMap(opt);
        map.build(linkView.paper.model, linkView.model);
        isPointObstacle = (point)=>!map.isPointAccessible(point);
    }
    var oldVertices = _indexMjs1.toArray(vertices).map(_indexMjs.Point);
    var newVertices = [];
    var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping
    // find a route by concatenating all partial routes (routes need to pass through vertices)
    // source -> vertex[1] -> ... -> vertex[n] -> target
    var to, from;
    for(var i = 0, len = oldVertices.length; i <= len; i++){
        var partialRoute = null;
        from = to || sourceBBox;
        to = oldVertices[i];
        if (!to) {
            // this is the last iteration
            // we ran through all vertices in oldVertices
            // 'to' is not a vertex.
            to = targetBBox;
            // If the target is a point (i.e. it's not an element), we
            // should use dragging route instead of main routing method if it has been provided.
            var isEndingAtPoint = !linkView.model.get("source").id || !linkView.model.get("target").id;
            if (isEndingAtPoint && _indexMjs1.isFunction(opt.draggingRoute)) {
                // Make sure we are passing points only (not rects).
                var dragFrom = from === sourceBBox ? sourceAnchor : from;
                var dragTo = to.origin();
                partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);
            }
        }
        // if partial route has not been calculated yet use the main routing method to find one
        partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);
        if (partialRoute === null) return opt.fallbackRouter(vertices, opt, linkView);
        var leadPoint = partialRoute[0];
        // remove the first point if the previous partial route had the same point as last
        if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();
        // save tailPoint for next iteration
        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;
        Array.prototype.push.apply(newVertices, partialRoute);
    }
    return newVertices;
}
const manhattan = function(vertices, opt, linkView) {
    return router(vertices, _indexMjs1.assign({}, config, opt), linkView);
};

},{"../g/index.mjs":"i91Db","../util/index.mjs":"eL7pI","./orthogonal.mjs":"hrB0D","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dlLru":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "metro", ()=>metro);
var _manhattanMjs = require("./manhattan.mjs");
var _indexMjs = require("../util/index.mjs");
var _indexMjs1 = require("../g/index.mjs");
var config = {
    maxAllowedDirectionChange: 45,
    // cost of a diagonal step
    diagonalCost: function() {
        var step = this.step;
        return Math.ceil(Math.sqrt(step * step << 1));
    },
    // an array of directions to find next points on the route
    // different from start/end directions
    directions: function() {
        var step = this.step;
        var cost = this.cost();
        var diagonalCost = this.diagonalCost();
        return [
            {
                offsetX: step,
                offsetY: 0,
                cost: cost
            },
            {
                offsetX: step,
                offsetY: step,
                cost: diagonalCost
            },
            {
                offsetX: 0,
                offsetY: step,
                cost: cost
            },
            {
                offsetX: -step,
                offsetY: step,
                cost: diagonalCost
            },
            {
                offsetX: -step,
                offsetY: 0,
                cost: cost
            },
            {
                offsetX: -step,
                offsetY: -step,
                cost: diagonalCost
            },
            {
                offsetX: 0,
                offsetY: -step,
                cost: cost
            },
            {
                offsetX: step,
                offsetY: -step,
                cost: diagonalCost
            }
        ];
    },
    // a simple route used in situations when main routing method fails
    // (exceed max number of loop iterations, inaccessible)
    fallbackRoute: function(from, to, opt) {
        // Find a route which breaks by 45 degrees ignoring all obstacles.
        var theta = from.theta(to);
        var route = [];
        var a = {
            x: to.x,
            y: from.y
        };
        var b = {
            x: from.x,
            y: to.y
        };
        if (theta % 180 > 90) {
            var t = a;
            a = b;
            b = t;
        }
        var p1 = theta % 90 < 45 ? a : b;
        var l1 = new _indexMjs1.Line(from, p1);
        var alpha = 90 * Math.ceil(theta / 90);
        var p2 = _indexMjs1.Point.fromPolar(l1.squaredLength(), _indexMjs1.toRad(alpha + 135), p1);
        var l2 = new _indexMjs1.Line(to, p2);
        var intersectionPoint = l1.intersection(l2);
        var point = intersectionPoint ? intersectionPoint : to;
        var directionFrom = intersectionPoint ? point : from;
        var quadrant = 360 / opt.directions.length;
        var angleTheta = directionFrom.theta(to);
        var normalizedAngle = _indexMjs1.normalizeAngle(angleTheta + quadrant / 2);
        var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);
        opt.previousDirectionAngle = directionAngle;
        if (point) route.push(point.round());
        route.push(to);
        return route;
    }
};
const metro = function(vertices, opt, linkView) {
    if (!_indexMjs.isFunction((0, _manhattanMjs.manhattan))) throw new Error("Metro requires the manhattan router.");
    return (0, _manhattanMjs.manhattan)(vertices, _indexMjs.assign({}, config, opt), linkView);
};

},{"./manhattan.mjs":"1Zztm","../util/index.mjs":"eL7pI","../g/index.mjs":"i91Db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hvFgL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rightAngle", ()=>rightAngle);
var _indexMjs = require("../g/index.mjs");
const Directions = {
    AUTO: "auto",
    LEFT: "left",
    RIGHT: "right",
    TOP: "top",
    BOTTOM: "bottom",
    ANCHOR_SIDE: "anchor-side",
    MAGNET_SIDE: "magnet-side"
};
const DEFINED_DIRECTIONS = [
    Directions.LEFT,
    Directions.RIGHT,
    Directions.TOP,
    Directions.BOTTOM
];
function getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {
    const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));
    const roundedAngle = Math.round(tangent.angle() / 90) * 90;
    switch(roundedAngle){
        case 0:
        case 360:
            return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;
        case 90:
            return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;
        case 180:
            return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;
        case 270:
            return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;
    }
}
function rightAngleRouter(_vertices, opt, linkView) {
    const margin = opt.margin || 20;
    let { sourceDirection = Directions.AUTO, targetDirection = Directions.AUTO } = opt;
    const sourceView = linkView.sourceView;
    const targetView = linkView.targetView;
    const isSourcePort = !!linkView.model.source().port;
    const isTargetPort = !!linkView.model.target().port;
    if (sourceDirection === Directions.AUTO) sourceDirection = isSourcePort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;
    if (targetDirection === Directions.AUTO) targetDirection = isTargetPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;
    const sourceBBox = linkView.sourceBBox;
    const targetBBox = linkView.targetBBox;
    const sourcePoint = linkView.sourceAnchor;
    const targetPoint = linkView.targetAnchor;
    let { x: sx0, y: sy0, width: sourceWidth = 0, height: sourceHeight = 0 } = sourceView && sourceView.model.isElement() ? _indexMjs.Rect.fromRectUnion(sourceBBox, sourceView.model.getBBox()) : linkView.sourceAnchor;
    let { x: tx0, y: ty0, width: targetWidth = 0, height: targetHeight = 0 } = targetView && targetView.model.isElement() ? _indexMjs.Rect.fromRectUnion(targetBBox, targetView.model.getBBox()) : linkView.targetAnchor;
    const tx1 = tx0 + targetWidth;
    const ty1 = ty0 + targetHeight;
    const sx1 = sx0 + sourceWidth;
    const sy1 = sy0 + sourceHeight;
    // Key coordinates including the margin
    const smx0 = sx0 - margin;
    const smx1 = sx1 + margin;
    const smy0 = sy0 - margin;
    const smy1 = sy1 + margin;
    const tmx0 = tx0 - margin;
    const tmx1 = tx1 + margin;
    const tmy0 = ty0 - margin;
    const tmy1 = ty1 + margin;
    const sourceOutsidePoint = sourcePoint.clone();
    let sourceSide;
    if (!sourceView) {
        const sourceLinkAnchorBBox = new _indexMjs.Rect(sx0, sy0, 0, 0);
        sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);
    } else if (sourceView.model.isLink()) sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);
    else if (sourceDirection === Directions.ANCHOR_SIDE) sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);
    else if (sourceDirection === Directions.MAGNET_SIDE) sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);
    else sourceSide = sourceDirection;
    switch(sourceSide){
        case "left":
            sourceOutsidePoint.x = smx0;
            break;
        case "right":
            sourceOutsidePoint.x = smx1;
            break;
        case "top":
            sourceOutsidePoint.y = smy0;
            break;
        case "bottom":
            sourceOutsidePoint.y = smy1;
            break;
    }
    const targetOutsidePoint = targetPoint.clone();
    let targetSide;
    if (!targetView) {
        const targetLinkAnchorBBox = new _indexMjs.Rect(tx0, ty0, 0, 0);
        targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);
    } else if (targetView.model.isLink()) targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);
    else if (targetDirection === Directions.ANCHOR_SIDE) targetSide = targetBBox.sideNearestToPoint(targetPoint);
    else if (targetDirection === Directions.MAGNET_SIDE) targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);
    else targetSide = targetDirection;
    switch(targetSide){
        case "left":
            targetOutsidePoint.x = tmx0;
            break;
        case "right":
            targetOutsidePoint.x = tmx1;
            break;
        case "top":
            targetOutsidePoint.y = tmy0;
            break;
        case "bottom":
            targetOutsidePoint.y = tmy1;
            break;
    }
    const { x: sox, y: soy } = sourceOutsidePoint;
    const { x: tox, y: toy } = targetOutsidePoint;
    const tcx = (tx0 + tx1) / 2;
    const tcy = (ty0 + ty1) / 2;
    const scx = (sx0 + sx1) / 2;
    const scy = (sy0 + sy1) / 2;
    const middleOfVerticalSides = (scx < tcx ? sx1 + tx0 : tx1 + sx0) / 2;
    const middleOfHorizontalSides = (scy < tcy ? sy1 + ty0 : ty1 + sy0) / 2;
    if (sourceSide === "left" && targetSide === "right") {
        if (smx0 <= tx1) {
            let y = middleOfHorizontalSides;
            if (sx1 <= tx0) {
                if (ty1 >= smy0 && toy < soy) y = Math.min(tmy0, smy0);
                else if (ty0 <= smy1 && toy >= soy) y = Math.max(tmy1, smy1);
            }
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y
                },
                {
                    x: tox,
                    y
                },
                {
                    x: tox,
                    y: toy
                }
            ];
        }
        const x = (sox + tox) / 2;
        return [
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
    } else if (sourceSide === "right" && targetSide === "left") {
        if (smx1 >= tx0) {
            let y = middleOfHorizontalSides;
            if (sox > tx1) {
                if (ty1 >= smy0 && toy < soy) y = Math.min(tmy0, smy0);
                else if (ty0 <= smy1 && toy >= soy) y = Math.max(tmy1, smy1);
            }
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y
                },
                {
                    x: tox,
                    y
                },
                {
                    x: tox,
                    y: toy
                }
            ];
        }
        const x = (sox + tox) / 2;
        return [
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
    } else if (sourceSide === "top" && targetSide === "bottom") {
        if (soy < toy) {
            let x = middleOfVerticalSides;
            let y = soy;
            if (soy < ty0) {
                if (tx1 >= smx0 && tox < sox) x = Math.min(tmx0, smx0);
                else if (tx0 <= smx1 && tox >= sox) x = Math.max(tmx1, smx1);
            }
            return [
                {
                    x: sox,
                    y
                },
                {
                    x,
                    y
                },
                {
                    x,
                    y: toy
                },
                {
                    x: tox,
                    y: toy
                }
            ];
        }
        const y = (soy + toy) / 2;
        return [
            {
                x: sox,
                y
            },
            {
                x: tox,
                y
            }
        ];
    } else if (sourceSide === "bottom" && targetSide === "top") {
        if (soy - margin > toy) {
            let x = middleOfVerticalSides;
            let y = soy;
            if (soy > ty1) {
                if (tx1 >= smx0 && tox < sox) x = Math.min(tmx0, smx0);
                else if (tx0 <= smx1 && tox >= sox) x = Math.max(tmx1, smx1);
            }
            return [
                {
                    x: sox,
                    y
                },
                {
                    x,
                    y
                },
                {
                    x,
                    y: toy
                },
                {
                    x: tox,
                    y: toy
                }
            ];
        }
        const y = (soy + toy) / 2;
        return [
            {
                x: sox,
                y
            },
            {
                x: tox,
                y
            }
        ];
    } else if (sourceSide === "top" && targetSide === "top") {
        let x;
        let y1 = Math.min((sy1 + ty0) / 2, toy);
        let y2 = Math.min((sy0 + ty1) / 2, soy);
        if (toy < soy) {
            if (sox >= tmx1 || sox <= tmx0) return [
                {
                    x: sox,
                    y: Math.min(soy, toy)
                },
                {
                    x: tox,
                    y: Math.min(soy, toy)
                }
            ];
            else if (tox > sox) x = Math.min(sox, tmx0);
            else x = Math.max(sox, tmx1);
        } else {
            if (tox >= smx1 || tox <= smx0) return [
                {
                    x: sox,
                    y: Math.min(soy, toy)
                },
                {
                    x: tox,
                    y: Math.min(soy, toy)
                }
            ];
            else if (tox >= sox) x = Math.max(tox, smx1);
            else x = Math.min(tox, smx0);
        }
        return [
            {
                x: sox,
                y: y2
            },
            {
                x,
                y: y2
            },
            {
                x,
                y: y1
            },
            {
                x: tox,
                y: y1
            }
        ];
    } else if (sourceSide === "bottom" && targetSide === "bottom") {
        if (tx0 >= sox + margin || tx1 <= sox - margin) return [
            {
                x: sox,
                y: Math.max(soy, toy)
            },
            {
                x: tox,
                y: Math.max(soy, toy)
            }
        ];
        let x;
        let y1;
        let y2;
        if (toy > soy) {
            y1 = Math.max((sy1 + ty0) / 2, toy);
            y2 = Math.max((sy1 + ty0) / 2, soy);
            if (tox > sox) x = Math.min(sox, tmx0);
            else x = Math.max(sox, tmx1);
        } else {
            y1 = Math.max((sy0 + ty1) / 2, toy);
            y2 = Math.max((sy0 + ty1) / 2, soy);
            if (tox > sox) x = Math.min(tox, smx0);
            else x = Math.max(tox, smx1);
        }
        return [
            {
                x: sox,
                y: y2
            },
            {
                x,
                y: y2
            },
            {
                x,
                y: y1
            },
            {
                x: tox,
                y: y1
            }
        ];
    } else if (sourceSide === "left" && targetSide === "left") {
        let y;
        let x1 = Math.min((sx1 + tx0) / 2, tox);
        let x2 = Math.min((sx0 + tx1) / 2, sox);
        if (tox > sox) {
            if (toy <= soy) y = Math.min(smy0, toy);
            else y = Math.max(smy1, toy);
        } else if (toy >= soy) y = Math.min(tmy0, soy);
        else y = Math.max(tmy1, soy);
        return [
            {
                x: x2,
                y: soy
            },
            {
                x: x2,
                y
            },
            {
                x: x1,
                y
            },
            {
                x: x1,
                y: toy
            }
        ];
    } else if (sourceSide === "right" && targetSide === "right") {
        let y;
        let x1 = Math.max((sx0 + tx1) / 2, tox);
        let x2 = Math.max((sx1 + tx0) / 2, sox);
        if (tox < sox) {
            if (toy <= soy) y = Math.min(smy0, toy);
            else y = Math.max(smy1, toy);
        } else if (toy >= soy) y = Math.min(tmy0, soy);
        else y = Math.max(tmy1, soy);
        return [
            {
                x: x2,
                y: soy
            },
            {
                x: x2,
                y
            },
            {
                x: x1,
                y
            },
            {
                x: x1,
                y: toy
            }
        ];
    } else if (sourceSide === "top" && targetSide === "right") {
        if (soy > toy) {
            if (sox < tox) {
                let y = (sy0 + ty1) / 2;
                if (y > tcy && y < tmy1 && sox < tmx0) y = tmy0;
                return [
                    {
                        x: sox,
                        y
                    },
                    {
                        x: tox,
                        y
                    },
                    {
                        x: tox,
                        y: toy
                    }
                ];
            }
            return [
                {
                    x: sox,
                    y: toy
                }
            ];
        }
        const x = (sx0 + tx1) / 2;
        if (sox > tox && sy1 >= toy) return [
            {
                x: sox,
                y: soy
            },
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
        if (x > smx0 && soy < ty1) {
            const y = Math.min(sy0, ty0) - margin;
            const x = Math.max(sx1, tx1) + margin;
            return [
                {
                    x: sox,
                    y
                },
                {
                    x,
                    y
                },
                {
                    x,
                    y: toy
                }
            ];
        }
        return [
            {
                x: sox,
                y: soy
            },
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
    } else if (sourceSide === "top" && targetSide === "left") {
        if (soy > toy) {
            if (sox > tox) {
                let y = (sy0 + ty1) / 2;
                if (y > tcy && y < tmy1 && sox > tmx1) y = tmy0;
                return [
                    {
                        x: sox,
                        y
                    },
                    {
                        x: tox,
                        y
                    },
                    {
                        x: tox,
                        y: toy
                    }
                ];
            }
            return [
                {
                    x: sox,
                    y: toy
                }
            ];
        }
        const x = (sx1 + tx0) / 2;
        if (sox < tox && sy1 >= toy) return [
            {
                x: sox,
                y: soy
            },
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
        if (x < smx1 && soy < ty1) {
            const y = Math.min(sy0, ty0) - margin;
            const x = Math.min(sx0, tx0) - margin;
            return [
                {
                    x: sox,
                    y
                },
                {
                    x,
                    y
                },
                {
                    x,
                    y: toy
                }
            ];
        }
        return [
            {
                x: sox,
                y: soy
            },
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
    } else if (sourceSide === "bottom" && targetSide === "right") {
        if (soy < toy) {
            if (sox < tox) {
                let y = (sy1 + ty0) / 2;
                if (y < tcy && y > tmy0 && sox < tmx0) y = tmy1;
                return [
                    {
                        x: sox,
                        y
                    },
                    {
                        x: tox,
                        y
                    },
                    {
                        x: tox,
                        y: toy
                    }
                ];
            }
            return [
                {
                    x: sox,
                    y: toy
                }
            ];
        } else if (sx0 < tox) {
            const y = Math.max(sy1, ty1) + margin;
            const x = Math.max(sx1, tx1) + margin;
            return [
                {
                    x: sox,
                    y
                },
                {
                    x,
                    y
                },
                {
                    x,
                    y: toy
                }
            ];
        }
        const x = middleOfVerticalSides;
        return [
            {
                x: sox,
                y: soy
            },
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
    } else if (sourceSide === "bottom" && targetSide === "left") {
        if (soy < toy) {
            if (sox > tox) {
                let y = (sy1 + ty0) / 2;
                if (y < tcy && y > tmy0 && sox > tmx1) y = tmy1;
                return [
                    {
                        x: sox,
                        y
                    },
                    {
                        x: tox,
                        y
                    },
                    {
                        x: tox,
                        y: toy
                    }
                ];
            }
            return [
                {
                    x: sox,
                    y: toy
                }
            ];
        } else if (sx1 > tox) {
            const y = Math.max(sy1, ty1) + margin;
            const x = Math.min(sx0, tx0) - margin;
            return [
                {
                    x: sox,
                    y
                },
                {
                    x,
                    y
                },
                {
                    x,
                    y: toy
                }
            ];
        }
        const x = middleOfVerticalSides;
        return [
            {
                x: sox,
                y: soy
            },
            {
                x,
                y: soy
            },
            {
                x,
                y: toy
            }
        ];
    } else if (sourceSide === "left" && targetSide === "bottom") {
        if (sox > tox && soy >= tmy1) return [
            {
                x: tox,
                y: soy
            }
        ];
        if (sox >= tx1 && soy < toy) {
            const x = (sx1 + tx0) / 2;
            return [
                {
                    x,
                    y: soy
                },
                {
                    x,
                    y: toy
                },
                {
                    x: tox,
                    y: toy
                }
            ];
        }
        if (tox < sx1 && ty1 <= sy0) {
            const y = (sy0 + ty1) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y
                },
                {
                    x: tox,
                    y
                }
            ];
        }
        const x = Math.min(tmx0, sox);
        const y = Math.max(sy1, ty1) + margin;
        return [
            {
                x,
                y: soy
            },
            {
                x,
                y
            },
            {
                x: tox,
                y
            }
        ];
    } else if (sourceSide === "left" && targetSide === "top") {
        if (sox > tox && soy < tmy0) return [
            {
                x: tox,
                y: soy
            }
        ];
        if (sox >= tx1) {
            if (soy > toy) {
                const x = (sx0 + tx1) / 2;
                return [
                    {
                        x,
                        y: soy
                    },
                    {
                        x,
                        y: toy
                    },
                    {
                        x: tox,
                        y: toy
                    }
                ];
            }
        }
        if (tox <= sx1 && toy > soy) {
            const y = (ty0 + sy1) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y
                },
                {
                    x: tox,
                    y
                }
            ];
        }
        const x = toy < soy ? Math.min(sx0, tx0) - margin : smx0;
        const y = Math.min(sy0, ty0) - margin;
        return [
            {
                x,
                y: soy
            },
            {
                x,
                y
            },
            {
                x: tox,
                y
            }
        ];
    } else if (sourceSide === "right" && targetSide === "top") {
        if (sox < tox && soy < tmy0) return [
            {
                x: tox,
                y: soy
            }
        ];
        if (sx1 < tx0 && soy > toy) {
            let x = (sx1 + tx0) / 2;
            return [
                {
                    x,
                    y: soy
                },
                {
                    x,
                    y: toy
                },
                {
                    x: tox,
                    y: toy
                }
            ];
        }
        if (tox < sox && ty0 > sy1) {
            const y = (sy1 + ty0) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y
                },
                {
                    x: tox,
                    y
                }
            ];
        }
        const x = Math.max(sx1, tx1) + margin;
        const y = Math.min(sy0, ty0) - margin;
        return [
            {
                x,
                y: soy
            },
            {
                x,
                y
            },
            {
                x: tox,
                y
            }
        ];
    } else if (sourceSide === "right" && targetSide === "bottom") {
        if (sox < tox && soy >= tmy1) return [
            {
                x: tox,
                y: soy
            }
        ];
        if (sox <= tx0 && soy < toy) {
            const x = (sx1 + tx0) / 2;
            return [
                {
                    x,
                    y: soy
                },
                {
                    x,
                    y: toy
                },
                {
                    x: tox,
                    y: toy
                }
            ];
        }
        if (tox > sx0 && ty1 < sy0) {
            const y = (sy0 + ty1) / 2;
            return [
                {
                    x: sox,
                    y: soy
                },
                {
                    x: sox,
                    y
                },
                {
                    x: tox,
                    y
                }
            ];
        }
        const x = Math.max(tmx1, sox);
        const y = Math.max(sy1, ty1) + margin;
        return [
            {
                x,
                y: soy
            },
            {
                x,
                y
            },
            {
                x: tox,
                y
            }
        ];
    }
}
rightAngleRouter.Directions = Directions;
const rightAngle = rightAngleRouter;

},{"../g/index.mjs":"i91Db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bihsF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "center", ()=>center);
parcelHelpers.export(exports, "top", ()=>top);
parcelHelpers.export(exports, "bottom", ()=>bottom);
parcelHelpers.export(exports, "left", ()=>left);
parcelHelpers.export(exports, "right", ()=>right);
parcelHelpers.export(exports, "topLeft", ()=>topLeft);
parcelHelpers.export(exports, "topRight", ()=>topRight);
parcelHelpers.export(exports, "bottomLeft", ()=>bottomLeft);
parcelHelpers.export(exports, "bottomRight", ()=>bottomRight);
parcelHelpers.export(exports, "perpendicular", ()=>perpendicular);
parcelHelpers.export(exports, "midSide", ()=>midSide);
parcelHelpers.export(exports, "modelCenter", ()=>modelCenter);
var _indexMjs = require("../util/index.mjs");
var _indexMjs1 = require("../g/index.mjs");
var _indexMjs2 = require("../linkAnchors/index.mjs");
function bboxWrapper(method) {
    return function(view, magnet, ref, opt) {
        var rotate = !!opt.rotate;
        var bbox = rotate ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);
        var anchor = bbox[method]();
        var dx = opt.dx;
        if (dx) {
            var dxPercentage = _indexMjs.isPercentage(dx);
            dx = parseFloat(dx);
            if (isFinite(dx)) {
                if (dxPercentage) {
                    dx /= 100;
                    dx *= bbox.width;
                }
                anchor.x += dx;
            }
        }
        var dy = opt.dy;
        if (dy) {
            var dyPercentage = _indexMjs.isPercentage(dy);
            dy = parseFloat(dy);
            if (isFinite(dy)) {
                if (dyPercentage) {
                    dy /= 100;
                    dy *= bbox.height;
                }
                anchor.y += dy;
            }
        }
        return rotate ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;
    };
}
function _perpendicular(view, magnet, refPoint, opt) {
    var angle = view.model.angle();
    var bbox = view.getNodeBBox(magnet);
    var anchor = bbox.center();
    var topLeft = bbox.origin();
    var bottomRight = bbox.corner();
    var padding = opt.padding;
    if (!isFinite(padding)) padding = 0;
    if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {
        var dy = refPoint.y - anchor.y;
        anchor.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan((0, _indexMjs1.toRad)(angle));
        anchor.y += dy;
    } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {
        var dx = refPoint.x - anchor.x;
        anchor.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan((0, _indexMjs1.toRad)(angle));
        anchor.x += dx;
    }
    return anchor;
}
function _midSide(view, magnet, refPoint, opt) {
    var rotate = !!opt.rotate;
    var bbox, angle, center;
    if (rotate) {
        bbox = view.getNodeUnrotatedBBox(magnet);
        center = view.model.getBBox().center();
        angle = view.model.angle();
    } else bbox = view.getNodeBBox(magnet);
    var padding = opt.padding;
    if (isFinite(padding)) bbox.inflate(padding);
    if (rotate) refPoint.rotate(center, angle);
    var side = bbox.sideNearestToPoint(refPoint);
    var anchor;
    switch(side){
        case "left":
            anchor = bbox.leftMiddle();
            break;
        case "right":
            anchor = bbox.rightMiddle();
            break;
        case "top":
            anchor = bbox.topMiddle();
            break;
        case "bottom":
            anchor = bbox.bottomMiddle();
            break;
    }
    return rotate ? anchor.rotate(center, -angle) : anchor;
}
// Can find anchor from model, when there is no selector or the link end
// is connected to a port
function _modelCenter(view, _magnet, _refPoint, opt, endType) {
    return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);
}
const center = bboxWrapper("center");
const top = bboxWrapper("topMiddle");
const bottom = bboxWrapper("bottomMiddle");
const left = bboxWrapper("leftMiddle");
const right = bboxWrapper("rightMiddle");
const topLeft = bboxWrapper("origin");
const topRight = bboxWrapper("topRight");
const bottomLeft = bboxWrapper("bottomLeft");
const bottomRight = bboxWrapper("corner");
const perpendicular = (0, _indexMjs2.resolveRef)(_perpendicular);
const midSide = (0, _indexMjs2.resolveRef)(_midSide);
const modelCenter = _modelCenter;

},{"../util/index.mjs":"eL7pI","../g/index.mjs":"i91Db","../linkAnchors/index.mjs":"5YGns","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5YGns":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "resolveRef", ()=>resolveRef);
// joint.linkAnchors
parcelHelpers.export(exports, "connectionRatio", ()=>connectionRatio);
parcelHelpers.export(exports, "connectionLength", ()=>connectionLength);
parcelHelpers.export(exports, "connectionPerpendicular", ()=>connectionPerpendicular);
parcelHelpers.export(exports, "connectionClosest", ()=>connectionClosest);
var _indexMjs = require("../g/index.mjs");
var _indexMjs1 = require("../util/index.mjs");
function connectionRatio(view, _magnet, _refPoint, opt) {
    var ratio = "ratio" in opt ? opt.ratio : 0.5;
    return view.getPointAtRatio(ratio);
}
function connectionLength(view, _magnet, _refPoint, opt) {
    var length = "length" in opt ? opt.length : 20;
    return view.getPointAtLength(length);
}
function _connectionPerpendicular(view, _magnet, refPoint, opt) {
    var OFFSET = 1e6;
    var path = view.getConnection();
    var segmentSubdivisions = view.getConnectionSubdivisions();
    var verticalLine = new (0, _indexMjs.Line)(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));
    var horizontalLine = new (0, _indexMjs.Line)(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));
    var verticalIntersections = verticalLine.intersect(path, {
        segmentSubdivisions: segmentSubdivisions
    });
    var horizontalIntersections = horizontalLine.intersect(path, {
        segmentSubdivisions: segmentSubdivisions
    });
    var intersections = [];
    if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);
    if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);
    if (intersections.length > 0) return refPoint.chooseClosest(intersections);
    if ("fallbackAt" in opt) return getPointAtLink(view, opt.fallbackAt);
    return connectionClosest(view, _magnet, refPoint, opt);
}
function _connectionClosest(view, _magnet, refPoint, _opt) {
    var closestPoint = view.getClosestPoint(refPoint);
    if (!closestPoint) return new (0, _indexMjs.Point)();
    return closestPoint;
}
function resolveRef(fn) {
    return function(view, magnet, ref, opt) {
        if (ref instanceof Element) {
            var refView = this.paper.findView(ref);
            var refPoint;
            if (refView) {
                if (refView.isNodeConnection(ref)) {
                    var distance = "fixedAt" in opt ? opt.fixedAt : "50%";
                    refPoint = getPointAtLink(refView, distance);
                } else refPoint = refView.getNodeBBox(ref).center();
            } else // Something went wrong
            refPoint = new (0, _indexMjs.Point)();
            return fn.call(this, view, magnet, refPoint, opt);
        }
        return fn.apply(this, arguments);
    };
}
function getPointAtLink(view, value) {
    var parsedValue = parseFloat(value);
    if ((0, _indexMjs1.isPercentage)(value)) return view.getPointAtRatio(parsedValue / 100);
    else return view.getPointAtLength(parsedValue);
}
const connectionPerpendicular = resolveRef(_connectionPerpendicular);
const connectionClosest = resolveRef(_connectionClosest);

},{"../g/index.mjs":"i91Db","../util/index.mjs":"eL7pI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"28Zj5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _graphMjs = require("./Graph.mjs");
parcelHelpers.exportAll(_graphMjs, exports);
var _indexMjs = require("./attributes/index.mjs");
parcelHelpers.exportAll(_indexMjs, exports);
var _paperLayerMjs = require("./PaperLayer.mjs");
parcelHelpers.exportAll(_paperLayerMjs, exports);
var _cellMjs = require("./Cell.mjs");
parcelHelpers.exportAll(_cellMjs, exports);
var _cellViewMjs = require("./CellView.mjs");
parcelHelpers.exportAll(_cellViewMjs, exports);
var _elementMjs = require("./Element.mjs");
parcelHelpers.exportAll(_elementMjs, exports);
var _elementViewMjs = require("./ElementView.mjs");
parcelHelpers.exportAll(_elementViewMjs, exports);
var _linkMjs = require("./Link.mjs");
parcelHelpers.exportAll(_linkMjs, exports);
var _linkViewMjs = require("./LinkView.mjs");
parcelHelpers.exportAll(_linkViewMjs, exports);
var _paperMjs = require("./Paper.mjs");
parcelHelpers.exportAll(_paperMjs, exports);
var _toolViewMjs = require("./ToolView.mjs");
parcelHelpers.exportAll(_toolViewMjs, exports);
var _toolsViewMjs = require("./ToolsView.mjs");
parcelHelpers.exportAll(_toolsViewMjs, exports);
var _highlighterViewMjs = require("./HighlighterView.mjs");
parcelHelpers.exportAll(_highlighterViewMjs, exports);

},{"./Graph.mjs":"efPXe","./attributes/index.mjs":"9p63m","./PaperLayer.mjs":"cJg4l","./Cell.mjs":"vHapP","./CellView.mjs":"5Rm2b","./Element.mjs":"hcQWn","./ElementView.mjs":"dHPd6","./Link.mjs":"kX2vg","./LinkView.mjs":"bsn5r","./Paper.mjs":"3MwEo","./ToolView.mjs":"iOzZj","./ToolsView.mjs":"eMvN7","./HighlighterView.mjs":"1vHPf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"efPXe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Graph", ()=>Graph);
var _backbone = require("backbone");
var _backboneDefault = parcelHelpers.interopDefault(_backbone);
var _indexMjs = require("../util/index.mjs");
var _indexMjs1 = require("../g/index.mjs");
var _linkMjs = require("./Link.mjs");
var _elementMjs = require("./Element.mjs");
var _wrappersMjs = require("../util/wrappers.mjs");
const GraphCells = (0, _backboneDefault.default).Collection.extend({
    initialize: function(models, opt) {
        // Set the optional namespace where all model classes are defined.
        if (opt.cellNamespace) this.cellNamespace = opt.cellNamespace;
        else /* eslint-disable no-undef */ this.cellNamespace = typeof joint !== "undefined" && _indexMjs.has(joint, "shapes") ? joint.shapes : null;
        this.graph = opt.graph;
    },
    model: function(attrs, opt) {
        var collection = opt.collection;
        var namespace = collection.cellNamespace;
        // Find the model class in the namespace or use the default one.
        var ModelClass = attrs.type === "link" ? (0, _linkMjs.Link) : _indexMjs.getByPath(namespace, attrs.type, ".") || (0, _elementMjs.Element);
        var cell = new ModelClass(attrs, opt);
        // Add a reference to the graph. It is necessary to do this here because this is the earliest place
        // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.
        if (!opt.dry) cell.graph = collection.graph;
        return cell;
    },
    // `comparator` makes it easy to sort cells based on their `z` index.
    comparator: function(model) {
        return model.get("z") || 0;
    }
});
const Graph = (0, _backboneDefault.default).Model.extend({
    initialize: function(attrs, opt) {
        opt = opt || {};
        // Passing `cellModel` function in the options object to graph allows for
        // setting models based on attribute objects. This is especially handy
        // when processing JSON graphs that are in a different than JointJS format.
        var cells = new GraphCells([], {
            model: opt.cellModel,
            cellNamespace: opt.cellNamespace,
            graph: this
        });
        (0, _backboneDefault.default).Model.prototype.set.call(this, "cells", cells);
        // Make all the events fired in the `cells` collection available.
        // to the outside world.
        cells.on("all", this.trigger, this);
        // Backbone automatically doesn't trigger re-sort if models attributes are changed later when
        // they're already in the collection. Therefore, we're triggering sort manually here.
        this.on("change:z", this._sortOnChangeZ, this);
        // `joint.dia.Graph` keeps an internal data structure (an adjacency list)
        // for fast graph queries. All changes that affect the structure of the graph
        // must be reflected in the `al` object. This object provides fast answers to
        // questions such as "what are the neighbours of this node" or "what
        // are the sibling links of this link".
        // Outgoing edges per node. Note that we use a hash-table for the list
        // of outgoing edges for a faster lookup.
        // [nodeId] -> Object [edgeId] -> true
        this._out = {};
        // Ingoing edges per node.
        // [nodeId] -> Object [edgeId] -> true
        this._in = {};
        // `_nodes` is useful for quick lookup of all the elements in the graph, without
        // having to go through the whole cells array.
        // [node ID] -> true
        this._nodes = {};
        // `_edges` is useful for quick lookup of all the links in the graph, without
        // having to go through the whole cells array.
        // [edgeId] -> true
        this._edges = {};
        this._batches = {};
        cells.on("add", this._restructureOnAdd, this);
        cells.on("remove", this._restructureOnRemove, this);
        cells.on("reset", this._restructureOnReset, this);
        cells.on("change:source", this._restructureOnChangeSource, this);
        cells.on("change:target", this._restructureOnChangeTarget, this);
        cells.on("remove", this._removeCell, this);
    },
    _sortOnChangeZ: function() {
        this.get("cells").sort();
    },
    _restructureOnAdd: function(cell) {
        if (cell.isLink()) {
            this._edges[cell.id] = true;
            var { source, target } = cell.attributes;
            if (source.id) (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;
            if (target.id) (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;
        } else this._nodes[cell.id] = true;
    },
    _restructureOnRemove: function(cell) {
        if (cell.isLink()) {
            delete this._edges[cell.id];
            var { source, target } = cell.attributes;
            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) delete this._out[source.id][cell.id];
            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) delete this._in[target.id][cell.id];
        } else delete this._nodes[cell.id];
    },
    _restructureOnReset: function(cells) {
        // Normalize into an array of cells. The original `cells` is GraphCells Backbone collection.
        cells = cells.models;
        this._out = {};
        this._in = {};
        this._nodes = {};
        this._edges = {};
        cells.forEach(this._restructureOnAdd, this);
    },
    _restructureOnChangeSource: function(link) {
        var prevSource = link.previous("source");
        if (prevSource.id && this._out[prevSource.id]) delete this._out[prevSource.id][link.id];
        var source = link.attributes.source;
        if (source.id) (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;
    },
    _restructureOnChangeTarget: function(link) {
        var prevTarget = link.previous("target");
        if (prevTarget.id && this._in[prevTarget.id]) delete this._in[prevTarget.id][link.id];
        var target = link.get("target");
        if (target.id) (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;
    },
    // Return all outbound edges for the node. Return value is an object
    // of the form: [edgeId] -> true
    getOutboundEdges: function(node) {
        return this._out && this._out[node] || {};
    },
    // Return all inbound edges for the node. Return value is an object
    // of the form: [edgeId] -> true
    getInboundEdges: function(node) {
        return this._in && this._in[node] || {};
    },
    toJSON: function() {
        // Backbone does not recursively call `toJSON()` on attributes that are themselves models/collections.
        // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.
        var json = (0, _backboneDefault.default).Model.prototype.toJSON.apply(this, arguments);
        json.cells = this.get("cells").toJSON();
        return json;
    },
    fromJSON: function(json, opt) {
        if (!json.cells) throw new Error("Graph JSON must contain cells array.");
        return this.set(json, opt);
    },
    set: function(key, val, opt) {
        var attrs;
        // Handle both `key`, value and {key: value} style arguments.
        if (typeof key === "object") {
            attrs = key;
            opt = val;
        } else (attrs = {})[key] = val;
        // Make sure that `cells` attribute is handled separately via resetCells().
        if (attrs.hasOwnProperty("cells")) {
            this.resetCells(attrs.cells, opt);
            attrs = _indexMjs.omit(attrs, "cells");
        }
        // The rest of the attributes are applied via original set method.
        return (0, _backboneDefault.default).Model.prototype.set.call(this, attrs, opt);
    },
    clear: function(opt) {
        opt = _indexMjs.assign({}, opt, {
            clear: true
        });
        var collection = this.get("cells");
        if (collection.length === 0) return this;
        this.startBatch("clear", opt);
        // The elements come after the links.
        var cells = collection.sortBy(function(cell) {
            return cell.isLink() ? 1 : 2;
        });
        do // Remove all the cells one by one.
        // Note that all the links are removed first, so it's
        // safe to remove the elements without removing the connected
        // links first.
        cells.shift().remove(opt);
        while (cells.length > 0);
        this.stopBatch("clear");
        return this;
    },
    _prepareCell: function(cell, opt) {
        var attrs;
        if (cell instanceof (0, _backboneDefault.default).Model) {
            attrs = cell.attributes;
            if (!cell.graph && (!opt || !opt.dry)) // An element can not be member of more than one graph.
            // A cell stops being the member of the graph after it's explicitly removed.
            cell.graph = this;
        } else // In case we're dealing with a plain JS object, we have to set the reference
        // to the `graph` right after the actual model is created. This happens in the `model()` function
        // of `joint.dia.GraphCells`.
        attrs = cell;
        if (!_indexMjs.isString(attrs.type)) throw new TypeError("dia.Graph: cell type must be a string.");
        return cell;
    },
    minZIndex: function() {
        var firstCell = this.get("cells").first();
        return firstCell ? firstCell.get("z") || 0 : 0;
    },
    maxZIndex: function() {
        var lastCell = this.get("cells").last();
        return lastCell ? lastCell.get("z") || 0 : 0;
    },
    addCell: function(cell, opt) {
        if (Array.isArray(cell)) return this.addCells(cell, opt);
        if (cell instanceof (0, _backboneDefault.default).Model) {
            if (!cell.has("z")) cell.set("z", this.maxZIndex() + 1);
        } else if (cell.z === undefined) cell.z = this.maxZIndex() + 1;
        this.get("cells").add(this._prepareCell(cell, opt), opt || {});
        return this;
    },
    addCells: function(cells, opt) {
        if (cells.length === 0) return this;
        cells = _indexMjs.flattenDeep(cells);
        opt.maxPosition = opt.position = cells.length - 1;
        this.startBatch("add", opt);
        cells.forEach(function(cell) {
            this.addCell(cell, opt);
            opt.position--;
        }, this);
        this.stopBatch("add", opt);
        return this;
    },
    // When adding a lot of cells, it is much more efficient to
    // reset the entire cells collection in one go.
    // Useful for bulk operations and optimizations.
    resetCells: function(cells, opt) {
        var preparedCells = _indexMjs.toArray(cells).map(function(cell) {
            return this._prepareCell(cell, opt);
        }, this);
        this.get("cells").reset(preparedCells, opt);
        return this;
    },
    removeCells: function(cells, opt) {
        if (cells.length) {
            this.startBatch("remove");
            _indexMjs.invoke(cells, "remove", opt);
            this.stopBatch("remove");
        }
        return this;
    },
    _removeCell: function(cell, collection, options) {
        options = options || {};
        if (!options.clear) {
            // Applications might provide a `disconnectLinks` option set to `true` in order to
            // disconnect links when a cell is removed rather then removing them. The default
            // is to remove all the associated links.
            if (options.disconnectLinks) this.disconnectLinks(cell, options);
            else this.removeLinks(cell, options);
        }
        // Silently remove the cell from the cells collection. Silently, because
        // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is
        // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events
        // would be triggered on the graph model.
        this.get("cells").remove(cell, {
            silent: true
        });
        if (cell.graph === this) // Remove the element graph reference only if the cell is the member of this graph.
        cell.graph = null;
    },
    // Get a cell by `id`.
    getCell: function(id) {
        return this.get("cells").get(id);
    },
    getCells: function() {
        return this.get("cells").toArray();
    },
    getElements: function() {
        return this.get("cells").filter((cell)=>cell.isElement());
    },
    getLinks: function() {
        return this.get("cells").filter((cell)=>cell.isLink());
    },
    getFirstCell: function() {
        return this.get("cells").first();
    },
    getLastCell: function() {
        return this.get("cells").last();
    },
    // Get all inbound and outbound links connected to the cell `model`.
    getConnectedLinks: function(model, opt) {
        opt = opt || {};
        var indirect = opt.indirect;
        var inbound = opt.inbound;
        var outbound = opt.outbound;
        if (inbound === undefined && outbound === undefined) inbound = outbound = true;
        // the final array of connected link models
        var links = [];
        // a hash table of connected edges of the form: [edgeId] -> true
        // used for quick lookups to check if we already added a link
        var edges = {};
        if (outbound) addOutbounds(this, model);
        if (inbound) addInbounds(this, model);
        function addOutbounds(graph, model) {
            _indexMjs.forIn(graph.getOutboundEdges(model.id), (function(_, edge) {
                // skip links that were already added
                // (those must be self-loop links)
                // (because they are inbound and outbound edges of the same two elements)
                if (edges[edge]) return;
                var link = graph.getCell(edge);
                links.push(link);
                edges[edge] = true;
                if (indirect) {
                    if (inbound) addInbounds(graph, link);
                    if (outbound) addOutbounds(graph, link);
                }
            }).bind(graph));
            if (indirect && model.isLink()) {
                var outCell = model.getTargetCell();
                if (outCell && outCell.isLink()) {
                    if (!edges[outCell.id]) {
                        links.push(outCell);
                        addOutbounds(graph, outCell);
                    }
                }
            }
        }
        function addInbounds(graph, model) {
            _indexMjs.forIn(graph.getInboundEdges(model.id), (function(_, edge) {
                // skip links that were already added
                // (those must be self-loop links)
                // (because they are inbound and outbound edges of the same two elements)
                if (edges[edge]) return;
                var link = graph.getCell(edge);
                links.push(link);
                edges[edge] = true;
                if (indirect) {
                    if (inbound) addInbounds(graph, link);
                    if (outbound) addOutbounds(graph, link);
                }
            }).bind(graph));
            if (indirect && model.isLink()) {
                var inCell = model.getSourceCell();
                if (inCell && inCell.isLink()) {
                    if (!edges[inCell.id]) {
                        links.push(inCell);
                        addInbounds(graph, inCell);
                    }
                }
            }
        }
        // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells
        if (opt.deep) {
            var embeddedCells = model.getEmbeddedCells({
                deep: true
            });
            // in the first round, we collect all the embedded elements
            var embeddedElements = {};
            embeddedCells.forEach(function(cell) {
                if (cell.isElement()) embeddedElements[cell.id] = true;
            });
            embeddedCells.forEach(function(cell) {
                if (cell.isLink()) return;
                if (outbound) _indexMjs.forIn(this.getOutboundEdges(cell.id), (function(exists, edge) {
                    if (!edges[edge]) {
                        var edgeCell = this.getCell(edge);
                        var { source, target } = edgeCell.attributes;
                        var sourceId = source.id;
                        var targetId = target.id;
                        // if `includeEnclosed` option is falsy, skip enclosed links
                        if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) return;
                        links.push(this.getCell(edge));
                        edges[edge] = true;
                    }
                }).bind(this));
                if (inbound) _indexMjs.forIn(this.getInboundEdges(cell.id), (function(exists, edge) {
                    if (!edges[edge]) {
                        var edgeCell = this.getCell(edge);
                        var { source, target } = edgeCell.attributes;
                        var sourceId = source.id;
                        var targetId = target.id;
                        // if `includeEnclosed` option is falsy, skip enclosed links
                        if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) return;
                        links.push(this.getCell(edge));
                        edges[edge] = true;
                    }
                }).bind(this));
            }, this);
        }
        return links;
    },
    getNeighbors: function(model, opt) {
        opt || (opt = {});
        var inbound = opt.inbound;
        var outbound = opt.outbound;
        if (inbound === undefined && outbound === undefined) inbound = outbound = true;
        var neighbors = this.getConnectedLinks(model, opt).reduce((function(res, link) {
            var { source, target } = link.attributes;
            var loop = link.hasLoop(opt);
            // Discard if it is a point, or if the neighbor was already added.
            if (inbound && _indexMjs.has(source, "id") && !res[source.id]) {
                var sourceElement = this.getCell(source.id);
                if (sourceElement.isElement()) {
                    if (loop || sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model))) res[source.id] = sourceElement;
                }
            }
            // Discard if it is a point, or if the neighbor was already added.
            if (outbound && _indexMjs.has(target, "id") && !res[target.id]) {
                var targetElement = this.getCell(target.id);
                if (targetElement.isElement()) {
                    if (loop || targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model))) res[target.id] = targetElement;
                }
            }
            return res;
        }).bind(this), {});
        if (model.isLink()) {
            if (inbound) {
                var sourceCell = model.getSourceCell();
                if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) neighbors[sourceCell.id] = sourceCell;
            }
            if (outbound) {
                var targetCell = model.getTargetCell();
                if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) neighbors[targetCell.id] = targetCell;
            }
        }
        return _indexMjs.toArray(neighbors);
    },
    getCommonAncestor: function() {
        var cellsAncestors = Array.from(arguments).map(function(cell) {
            var ancestors = [];
            var parentId = cell.get("parent");
            while(parentId){
                ancestors.push(parentId);
                parentId = this.getCell(parentId).get("parent");
            }
            return ancestors;
        }, this);
        cellsAncestors = cellsAncestors.sort(function(a, b) {
            return a.length - b.length;
        });
        var commonAncestor = _indexMjs.toArray(cellsAncestors.shift()).find(function(ancestor) {
            return cellsAncestors.every(function(cellAncestors) {
                return cellAncestors.includes(ancestor);
            });
        });
        return this.getCell(commonAncestor);
    },
    // Find the whole branch starting at `element`.
    // If `opt.deep` is `true`, take into account embedded elements too.
    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.
    getSuccessors: function(element, opt) {
        opt = opt || {};
        var res = [];
        // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.
        this.search(element, function(el) {
            if (el !== element) res.push(el);
        }, _indexMjs.assign({}, opt, {
            outbound: true
        }));
        return res;
    },
    cloneCells: (0, _indexMjs.cloneCells),
    // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).
    // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.
    // Return a map of the form: [original cell ID] -> [clone].
    cloneSubgraph: function(cells, opt) {
        var subgraph = this.getSubgraph(cells, opt);
        return this.cloneCells(subgraph);
    },
    // Return `cells` and all the connected links that connect cells in the `cells` array.
    // If `opt.deep` is `true`, return all the cells including all their embedded cells
    // and all the links that connect any of the returned cells.
    // For example, for a single shallow element, the result is that very same element.
    // For two elements connected with a link: `A --- L ---> B`, the result for
    // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.
    getSubgraph: function(cells, opt) {
        opt = opt || {};
        var subgraph = [];
        // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.
        var cellMap = {};
        var elements = [];
        var links = [];
        _indexMjs.toArray(cells).forEach(function(cell) {
            if (!cellMap[cell.id]) {
                subgraph.push(cell);
                cellMap[cell.id] = cell;
                if (cell.isLink()) links.push(cell);
                else elements.push(cell);
            }
            if (opt.deep) {
                var embeds = cell.getEmbeddedCells({
                    deep: true
                });
                embeds.forEach(function(embed) {
                    if (!cellMap[embed.id]) {
                        subgraph.push(embed);
                        cellMap[embed.id] = embed;
                        if (embed.isLink()) links.push(embed);
                        else elements.push(embed);
                    }
                });
            }
        });
        links.forEach(function(link) {
            // For links, return their source & target (if they are elements - not points).
            var { source, target } = link.attributes;
            if (source.id && !cellMap[source.id]) {
                var sourceElement = this.getCell(source.id);
                subgraph.push(sourceElement);
                cellMap[sourceElement.id] = sourceElement;
                elements.push(sourceElement);
            }
            if (target.id && !cellMap[target.id]) {
                var targetElement = this.getCell(target.id);
                subgraph.push(this.getCell(target.id));
                cellMap[targetElement.id] = targetElement;
                elements.push(targetElement);
            }
        }, this);
        elements.forEach(function(element) {
            // For elements, include their connected links if their source/target is in the subgraph;
            var links = this.getConnectedLinks(element, opt);
            links.forEach(function(link) {
                var { source, target } = link.attributes;
                if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {
                    subgraph.push(link);
                    cellMap[link.id] = link;
                }
            });
        }, this);
        return subgraph;
    },
    // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.
    // If `opt.deep` is `true`, take into account embedded elements too.
    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.
    getPredecessors: function(element, opt) {
        opt = opt || {};
        var res = [];
        // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.
        this.search(element, function(el) {
            if (el !== element) res.push(el);
        }, _indexMjs.assign({}, opt, {
            inbound: true
        }));
        return res;
    },
    // Perform search on the graph.
    // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.
    // By setting `opt.inbound` to `true`, you can reverse the direction of the search.
    // If `opt.deep` is `true`, take into account embedded elements too.
    // `iteratee` is a function of the form `function(element) {}`.
    // If `iteratee` explicitly returns `false`, the searching stops.
    search: function(element, iteratee, opt) {
        opt = opt || {};
        if (opt.breadthFirst) this.bfs(element, iteratee, opt);
        else this.dfs(element, iteratee, opt);
    },
    // Breadth-first search.
    // If `opt.deep` is `true`, take into account embedded elements too.
    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).
    // `iteratee` is a function of the form `function(element, distance) {}`.
    // where `element` is the currently visited element and `distance` is the distance of that element
    // from the root `element` passed the `bfs()`, i.e. the element we started the search from.
    // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels
    // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.
    // If `iteratee` explicitly returns `false`, the searching stops.
    bfs: function(element, iteratee, opt = {}) {
        const visited = {};
        const distance = {};
        const queue = [];
        queue.push(element);
        distance[element.id] = 0;
        while(queue.length > 0){
            var next = queue.shift();
            if (visited[next.id]) continue;
            visited[next.id] = true;
            if (iteratee.call(this, next, distance[next.id]) === false) continue;
            const neighbors = this.getNeighbors(next, opt);
            for(let i = 0, n = neighbors.length; i < n; i++){
                const neighbor = neighbors[i];
                distance[neighbor.id] = distance[next.id] + 1;
                queue.push(neighbor);
            }
        }
    },
    // Depth-first search.
    // If `opt.deep` is `true`, take into account embedded elements too.
    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).
    // `iteratee` is a function of the form `function(element, distance) {}`.
    // If `iteratee` explicitly returns `false`, the search stops.
    dfs: function(element, iteratee, opt = {}) {
        const visited = {};
        const distance = {};
        const queue = [];
        queue.push(element);
        distance[element.id] = 0;
        while(queue.length > 0){
            const next = queue.pop();
            if (visited[next.id]) continue;
            visited[next.id] = true;
            if (iteratee.call(this, next, distance[next.id]) === false) continue;
            const neighbors = this.getNeighbors(next, opt);
            const lastIndex = queue.length;
            for(let i = 0, n = neighbors.length; i < n; i++){
                const neighbor = neighbors[i];
                distance[neighbor.id] = distance[next.id] + 1;
                queue.splice(lastIndex, 0, neighbor);
            }
        }
    },
    // Get all the roots of the graph. Time complexity: O(|V|).
    getSources: function() {
        var sources = [];
        _indexMjs.forIn(this._nodes, (function(exists, node) {
            if (!this._in[node] || _indexMjs.isEmpty(this._in[node])) sources.push(this.getCell(node));
        }).bind(this));
        return sources;
    },
    // Get all the leafs of the graph. Time complexity: O(|V|).
    getSinks: function() {
        var sinks = [];
        _indexMjs.forIn(this._nodes, (function(exists, node) {
            if (!this._out[node] || _indexMjs.isEmpty(this._out[node])) sinks.push(this.getCell(node));
        }).bind(this));
        return sinks;
    },
    // Return `true` if `element` is a root. Time complexity: O(1).
    isSource: function(element) {
        return !this._in[element.id] || _indexMjs.isEmpty(this._in[element.id]);
    },
    // Return `true` if `element` is a leaf. Time complexity: O(1).
    isSink: function(element) {
        return !this._out[element.id] || _indexMjs.isEmpty(this._out[element.id]);
    },
    // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.
    isSuccessor: function(elementA, elementB) {
        var isSuccessor = false;
        this.search(elementA, function(element) {
            if (element === elementB && element !== elementA) {
                isSuccessor = true;
                return false;
            }
        }, {
            outbound: true
        });
        return isSuccessor;
    },
    // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.
    isPredecessor: function(elementA, elementB) {
        var isPredecessor = false;
        this.search(elementA, function(element) {
            if (element === elementB && element !== elementA) {
                isPredecessor = true;
                return false;
            }
        }, {
            inbound: true
        });
        return isPredecessor;
    },
    // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.
    // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`
    // for more details.
    // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.
    // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.
    isNeighbor: function(elementA, elementB, opt) {
        opt = opt || {};
        var inbound = opt.inbound;
        var outbound = opt.outbound;
        if (inbound === undefined && outbound === undefined) inbound = outbound = true;
        var isNeighbor = false;
        this.getConnectedLinks(elementA, opt).forEach(function(link) {
            var { source, target } = link.attributes;
            // Discard if it is a point.
            if (inbound && _indexMjs.has(source, "id") && source.id === elementB.id) {
                isNeighbor = true;
                return false;
            }
            // Discard if it is a point, or if the neighbor was already added.
            if (outbound && _indexMjs.has(target, "id") && target.id === elementB.id) {
                isNeighbor = true;
                return false;
            }
        });
        return isNeighbor;
    },
    // Disconnect links connected to the cell `model`.
    disconnectLinks: function(model, opt) {
        this.getConnectedLinks(model).forEach(function(link) {
            link.set(link.attributes.source.id === model.id ? "source" : "target", {
                x: 0,
                y: 0
            }, opt);
        });
    },
    // Remove links connected to the cell `model` completely.
    removeLinks: function(model, opt) {
        _indexMjs.invoke(this.getConnectedLinks(model), "remove", opt);
    },
    // Find all elements at given point
    findModelsFromPoint: function(p) {
        return this.getElements().filter((el)=>el.getBBox({
                rotate: true
            }).containsPoint(p));
    },
    // Find all elements in given area
    findModelsInArea: function(rect, opt = {}) {
        const r = new _indexMjs1.Rect(rect);
        const { strict = false } = opt;
        const method = strict ? "containsRect" : "intersect";
        return this.getElements().filter((el)=>r[method](el.getBBox({
                rotate: true
            })));
    },
    // Find all elements under the given element.
    findModelsUnderElement: function(element, opt = {}) {
        const { searchBy = "bbox" } = opt;
        const bbox = element.getBBox().rotateAroundCenter(element.angle());
        const elements = searchBy === "bbox" ? this.findModelsInArea(bbox) : this.findModelsFromPoint(_indexMjs.getRectPoint(bbox, searchBy));
        // don't account element itself or any of its descendants
        return elements.filter((el)=>element.id !== el.id && !el.isEmbeddedIn(element));
    },
    // Return bounding box of all elements.
    getBBox: function() {
        return this.getCellsBBox(this.getCells());
    },
    // Return the bounding box of all cells in array provided.
    getCellsBBox: function(cells, opt = {}) {
        const { rotate = true } = opt;
        return _indexMjs.toArray(cells).reduce(function(memo, cell) {
            const rect = cell.getBBox({
                rotate
            });
            if (!rect) return memo;
            if (memo) return memo.union(rect);
            return rect;
        }, null);
    },
    translate: function(dx, dy, opt) {
        // Don't translate cells that are embedded in any other cell.
        var cells = this.getCells().filter(function(cell) {
            return !cell.isEmbedded();
        });
        _indexMjs.invoke(cells, "translate", dx, dy, opt);
        return this;
    },
    resize: function(width, height, opt) {
        return this.resizeCells(width, height, this.getCells(), opt);
    },
    resizeCells: function(width, height, cells, opt) {
        // `getBBox` method returns `null` if no elements provided.
        // i.e. cells can be an array of links
        var bbox = this.getCellsBBox(cells);
        if (bbox) {
            var sx = Math.max(width / bbox.width, 0);
            var sy = Math.max(height / bbox.height, 0);
            _indexMjs.invoke(cells, "scale", sx, sy, bbox.origin(), opt);
        }
        return this;
    },
    startBatch: function(name, data) {
        data = data || {};
        this._batches[name] = (this._batches[name] || 0) + 1;
        return this.trigger("batch:start", _indexMjs.assign({}, data, {
            batchName: name
        }));
    },
    stopBatch: function(name, data) {
        data = data || {};
        this._batches[name] = (this._batches[name] || 0) - 1;
        return this.trigger("batch:stop", _indexMjs.assign({}, data, {
            batchName: name
        }));
    },
    hasActiveBatch: function(name) {
        const batches = this._batches;
        let names;
        if (arguments.length === 0) names = Object.keys(batches);
        else if (Array.isArray(name)) names = name;
        else names = [
            name
        ];
        return names.some((batch)=>batches[batch] > 0);
    }
}, {
    validations: {
        multiLinks: function(graph, link) {
            // Do not allow multiple links to have the same source and target.
            var { source, target } = link.attributes;
            if (source.id && target.id) {
                var sourceModel = link.getSourceCell();
                if (sourceModel) {
                    var connectedLinks = graph.getConnectedLinks(sourceModel, {
                        outbound: true
                    });
                    var sameLinks = connectedLinks.filter(function(_link) {
                        var { source: _source, target: _target } = _link.attributes;
                        return _source && _source.id === source.id && (!_source.port || _source.port === source.port) && _target && _target.id === target.id && (!_target.port || _target.port === target.port);
                    });
                    if (sameLinks.length > 1) return false;
                }
            }
            return true;
        },
        linkPinning: function(_graph, link) {
            var { source, target } = link.attributes;
            return source.id && target.id;
        }
    }
});
(0, _wrappersMjs.wrapWith)(Graph.prototype, [
    "resetCells",
    "addCells",
    "removeCells"
], (0, _wrappersMjs.wrappers).cells);

},{"backbone":"gM9rO","../util/index.mjs":"eL7pI","../g/index.mjs":"i91Db","./Link.mjs":"kX2vg","./Element.mjs":"hcQWn","../util/wrappers.mjs":"2cXQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cJg4l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LayersNames", ()=>LayersNames);
parcelHelpers.export(exports, "PaperLayer", ()=>PaperLayer);
var _indexMjs = require("../mvc/index.mjs");
var _utilMjs = require("../util/util.mjs");
const LayersNames = {
    CELLS: "cells",
    BACK: "back",
    FRONT: "front",
    TOOLS: "tools",
    LABELS: "labels"
};
const PaperLayer = (0, _indexMjs.View).extend({
    tagName: "g",
    svgElement: true,
    pivotNodes: null,
    defaultTheme: null,
    options: {
        name: ""
    },
    className: function() {
        return (0, _utilMjs.addClassNamePrefix)(`${this.options.name}-layer`);
    },
    init: function() {
        this.pivotNodes = {};
    },
    insertSortedNode: function(node, z) {
        this.el.insertBefore(node, this.insertPivot(z));
    },
    insertNode: function(node) {
        const { el } = this;
        if (node.parentNode !== el) el.appendChild(node);
    },
    insertPivot: function(z) {
        const { el, pivotNodes } = this;
        z = +z;
        z || (z = 0);
        let pivotNode = pivotNodes[z];
        if (pivotNode) return pivotNode;
        pivotNode = pivotNodes[z] = document.createComment("z-index:" + (z + 1));
        let neighborZ = -Infinity;
        for(let currentZ in pivotNodes){
            currentZ = +currentZ;
            if (currentZ < z && currentZ > neighborZ) {
                neighborZ = currentZ;
                if (neighborZ === z - 1) continue;
            }
        }
        if (neighborZ !== -Infinity) {
            const neighborPivot = pivotNodes[neighborZ];
            // Insert After
            el.insertBefore(pivotNode, neighborPivot.nextSibling);
        } else // First Child
        el.insertBefore(pivotNode, el.firstChild);
        return pivotNode;
    },
    removePivots: function() {
        const { el, pivotNodes } = this;
        for(let z in pivotNodes)el.removeChild(pivotNodes[z]);
        this.pivotNodes = {};
    }
});

},{"../mvc/index.mjs":"c2o6n","../util/util.mjs":"5j2Qt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bsn5r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LinkView", ()=>LinkView);
var _cellViewMjs = require("./CellView.mjs");
var _linkMjs = require("./Link.mjs");
var _indexMjs = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _indexMjs1 = require("../util/index.mjs");
var _indexMjs2 = require("../g/index.mjs");
var _indexMjs3 = require("../routers/index.mjs");
var _indexMjs4 = require("../connectors/index.mjs");
var _jquery = require("jquery");
var _jqueryDefault = parcelHelpers.interopDefault(_jquery);
const Flags = {
    TOOLS: (0, _cellViewMjs.CellView).Flags.TOOLS,
    RENDER: "RENDER",
    UPDATE: "UPDATE",
    LEGACY_TOOLS: "LEGACY_TOOLS",
    LABELS: "LABELS",
    VERTICES: "VERTICES",
    SOURCE: "SOURCE",
    TARGET: "TARGET",
    CONNECTOR: "CONNECTOR"
};
const LinkView = (0, _cellViewMjs.CellView).extend({
    className: function() {
        var classNames = (0, _cellViewMjs.CellView).prototype.className.apply(this).split(" ");
        classNames.push("link");
        return classNames.join(" ");
    },
    options: {
        shortLinkLength: 105,
        doubleLinkTools: false,
        longLinkLength: 155,
        linkToolsOffset: 40,
        doubleLinkToolsOffset: 65,
        sampleInterval: 50
    },
    _labelCache: null,
    _labelSelectors: null,
    _markerCache: null,
    _V: null,
    _dragData: null,
    metrics: null,
    decimalsRounding: 2,
    initialize: function() {
        (0, _cellViewMjs.CellView).prototype.initialize.apply(this, arguments);
        // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to
        // `<g class="label">` nodes wrapped by Vectorizer. This allows for quick access to the
        // nodes in `updateLabelPosition()` in order to update the label positions.
        this._labelCache = {};
        // a cache of label selectors
        this._labelSelectors = {};
        // keeps markers bboxes and positions again for quicker access
        this._markerCache = {};
        // cache of default markup nodes
        this._V = {};
        // connection path metrics
        this.cleanNodesCache();
    },
    presentationAttributes: {
        markup: [
            Flags.RENDER
        ],
        attrs: [
            Flags.UPDATE
        ],
        router: [
            Flags.UPDATE
        ],
        connector: [
            Flags.CONNECTOR
        ],
        smooth: [
            Flags.UPDATE
        ],
        manhattan: [
            Flags.UPDATE
        ],
        toolMarkup: [
            Flags.LEGACY_TOOLS
        ],
        labels: [
            Flags.LABELS
        ],
        labelMarkup: [
            Flags.LABELS
        ],
        vertices: [
            Flags.VERTICES,
            Flags.UPDATE
        ],
        vertexMarkup: [
            Flags.VERTICES
        ],
        source: [
            Flags.SOURCE,
            Flags.UPDATE
        ],
        target: [
            Flags.TARGET,
            Flags.UPDATE
        ]
    },
    initFlag: [
        Flags.RENDER,
        Flags.SOURCE,
        Flags.TARGET,
        Flags.TOOLS
    ],
    UPDATE_PRIORITY: 1,
    confirmUpdate: function(flags, opt) {
        opt || (opt = {});
        if (this.hasFlag(flags, Flags.SOURCE)) {
            if (!this.updateEndProperties("source")) return flags;
            flags = this.removeFlag(flags, Flags.SOURCE);
        }
        if (this.hasFlag(flags, Flags.TARGET)) {
            if (!this.updateEndProperties("target")) return flags;
            flags = this.removeFlag(flags, Flags.TARGET);
        }
        const { paper, sourceView, targetView } = this;
        if (paper && (sourceView && !paper.isViewMounted(sourceView) || targetView && !paper.isViewMounted(targetView))) // Wait for the sourceView and targetView to be rendered
        return flags;
        if (this.hasFlag(flags, Flags.RENDER)) {
            this.render();
            this.updateHighlighters(true);
            this.updateTools(opt);
            flags = this.removeFlag(flags, [
                Flags.RENDER,
                Flags.UPDATE,
                Flags.VERTICES,
                Flags.LABELS,
                Flags.TOOLS,
                Flags.LEGACY_TOOLS,
                Flags.CONNECTOR
            ]);
            return flags;
        }
        let updateHighlighters = false;
        if (this.hasFlag(flags, Flags.VERTICES)) {
            this.renderVertexMarkers();
            flags = this.removeFlag(flags, Flags.VERTICES);
        }
        const { model } = this;
        const { attributes } = model;
        let updateLabels = this.hasFlag(flags, Flags.LABELS);
        let updateLegacyTools = this.hasFlag(flags, Flags.LEGACY_TOOLS);
        if (updateLabels) {
            this.onLabelsChange(model, attributes.labels, opt);
            flags = this.removeFlag(flags, Flags.LABELS);
            updateHighlighters = true;
        }
        if (updateLegacyTools) {
            this.renderTools();
            flags = this.removeFlag(flags, Flags.LEGACY_TOOLS);
        }
        const updateAll = this.hasFlag(flags, Flags.UPDATE);
        const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);
        if (updateAll || updateConnector) {
            if (!updateAll) {
                // Keep the current route and update the geometry
                this.updatePath();
                this.updateDOM();
            } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) // The link is being translated by an ancestor that will
            // shift source point, target point and all vertices
            // by an equal distance.
            this.translate(opt.tx, opt.ty);
            else this.update();
            this.updateTools(opt);
            flags = this.removeFlag(flags, [
                Flags.UPDATE,
                Flags.TOOLS,
                Flags.CONNECTOR
            ]);
            updateLabels = false;
            updateLegacyTools = false;
            updateHighlighters = true;
        }
        if (updateLabels) this.updateLabelPositions();
        if (updateLegacyTools) this.updateToolsPosition();
        if (updateHighlighters) this.updateHighlighters();
        if (this.hasFlag(flags, Flags.TOOLS)) {
            this.updateTools(opt);
            flags = this.removeFlag(flags, Flags.TOOLS);
        }
        return flags;
    },
    requestConnectionUpdate: function(opt) {
        this.requestUpdate(this.getFlag(Flags.UPDATE), opt);
    },
    isLabelsRenderRequired: function(opt = {}) {
        const previousLabels = this.model.previous("labels");
        if (!previousLabels) return true;
        // Here is an optimization for cases when we know, that change does
        // not require re-rendering of all labels.
        if ("propertyPathArray" in opt && "propertyValue" in opt) {
            // The label is setting by `prop()` method
            var pathArray = opt.propertyPathArray || [];
            var pathLength = pathArray.length;
            if (pathLength > 1) {
                // We are changing a single label here e.g. 'labels/0/position'
                var labelExists = !!previousLabels[pathArray[1]];
                if (labelExists) {
                    if (pathLength === 2) // We are changing the entire label. Need to check if the
                    // markup is also being changed.
                    return "markup" in Object(opt.propertyValue);
                    else if (pathArray[2] !== "markup") // We are changing a label property but not the markup
                    return false;
                }
            }
        }
        return true;
    },
    onLabelsChange: function(_link, _labels, opt) {
        // Note: this optimization works in async=false mode only
        if (this.isLabelsRenderRequired(opt)) this.renderLabels();
        else this.updateLabels();
    },
    // Rendering.
    // ----------
    render: function() {
        this.vel.empty();
        this.unmountLabels();
        this._V = {};
        this.renderMarkup();
        // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox
        // returns zero values)
        this.renderLabels();
        this.update();
        return this;
    },
    renderMarkup: function() {
        var link = this.model;
        var markup = link.get("markup") || link.markup;
        if (!markup) throw new Error("dia.LinkView: markup required");
        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);
        if (typeof markup === "string") return this.renderStringMarkup(markup);
        throw new Error("dia.LinkView: invalid markup");
    },
    renderJSONMarkup: function(markup) {
        var doc = this.parseDOMJSON(markup, this.el);
        // Selectors
        this.selectors = doc.selectors;
        // Fragment
        this.vel.append(doc.fragment);
    },
    renderStringMarkup: function(markup) {
        // A special markup can be given in the `properties.markup` property. This might be handy
        // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.
        // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors
        // of elements with special meaning though. Therefore, those classes should be preserved in any
        // special markup passed in `properties.markup`.
        var children = (0, _indexMjsDefault.default)(markup);
        // custom markup may contain only one children
        if (!Array.isArray(children)) children = [
            children
        ];
        // Cache all children elements for quicker access.
        var cache = this._V; // vectorized markup;
        for(var i = 0, n = children.length; i < n; i++){
            var child = children[i];
            var className = child.attr("class");
            if (className) {
                // Strip the joint class name prefix, if there is one.
                className = (0, _indexMjs1.removeClassNamePrefix)(className);
                cache[(0, _jqueryDefault.default).camelCase(className)] = child;
            }
        }
        // partial rendering
        this.renderTools();
        this.renderVertexMarkers();
        this.renderArrowheadMarkers();
        this.vel.append(children);
    },
    _getLabelMarkup: function(labelMarkup) {
        if (!labelMarkup) return undefined;
        if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);
        if (typeof labelMarkup === "string") return this._getLabelStringMarkup(labelMarkup);
        throw new Error("dia.linkView: invalid label markup");
    },
    _getLabelStringMarkup: function(labelMarkup) {
        var children = (0, _indexMjsDefault.default)(labelMarkup);
        var fragment = document.createDocumentFragment();
        if (!Array.isArray(children)) fragment.appendChild(children.node);
        else for(var i = 0, n = children.length; i < n; i++){
            var currentChild = children[i].node;
            fragment.appendChild(currentChild);
        }
        return {
            fragment: fragment,
            selectors: {}
        }; // no selectors
    },
    // Label markup fragment may come wrapped in <g class="label" />, or not.
    // If it doesn't, add the <g /> container here.
    _normalizeLabelMarkup: function(markup) {
        if (!markup) return undefined;
        var fragment = markup.fragment;
        if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error("dia.LinkView: invalid label markup.");
        var vNode;
        var childNodes = fragment.childNodes;
        if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== "G") // default markup fragment is not wrapped in <g />
        // add a <g /> container
        vNode = (0, _indexMjsDefault.default)("g").append(fragment);
        else vNode = (0, _indexMjsDefault.default)(childNodes[0]);
        vNode.addClass("label");
        return {
            node: vNode.node,
            selectors: markup.selectors
        };
    },
    renderLabels: function() {
        var cache = this._V;
        var vLabels = cache.labels;
        var labelCache = this._labelCache = {};
        var labelSelectors = this._labelSelectors = {};
        var model = this.model;
        var labels = model.attributes.labels || [];
        var labelsCount = labels.length;
        if (labelsCount === 0) {
            if (vLabels) vLabels.remove();
            return this;
        }
        if (vLabels) vLabels.empty();
        else {
            // there is no label container in the markup but some labels are defined
            // add a <g class="labels" /> container
            vLabels = cache.labels = (0, _indexMjsDefault.default)("g").addClass("labels");
            if (this.options.labelsLayer) {
                vLabels.addClass((0, _indexMjs1.addClassNamePrefix)((0, _indexMjs1.result)(this, "className")));
                vLabels.attr("model-id", model.id);
            }
        }
        for(var i = 0; i < labelsCount; i++){
            var label = labels[i];
            var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));
            var labelNode;
            var selectors;
            if (labelMarkup) {
                labelNode = labelMarkup.node;
                selectors = labelMarkup.selectors;
            } else {
                var builtinDefaultLabel = model._builtins.defaultLabel;
                var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));
                var defaultLabel = model._getDefaultLabel();
                var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));
                var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;
                labelNode = defaultMarkup.node;
                selectors = defaultMarkup.selectors;
            }
            labelNode.setAttribute("label-idx", i); // assign label-idx
            vLabels.append(labelNode);
            labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions
            var rootSelector = this.selector;
            if (selectors[rootSelector]) throw new Error("dia.LinkView: ambiguous label root selector.");
            selectors[rootSelector] = labelNode;
            labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`
        }
        if (!vLabels.parent()) this.mountLabels();
        this.updateLabels();
        return this;
    },
    mountLabels: function() {
        const { el, paper, model, _V, options } = this;
        const { labels: vLabels } = _V;
        if (!vLabels || !model.hasLabels()) return;
        const { node } = vLabels;
        if (options.labelsLayer) paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get("z"));
        else if (node.parentNode !== el) el.appendChild(node);
    },
    unmountLabels: function() {
        const { options, _V } = this;
        if (!_V) return;
        const { labels: vLabels } = _V;
        if (vLabels && options.labelsLayer) vLabels.remove();
    },
    findLabelNode: function(labelIndex, selector) {
        const labelRoot = this._labelCache[labelIndex];
        if (!labelRoot) return null;
        const labelSelectors = this._labelSelectors[labelIndex];
        const [node = null] = this.findBySelector(selector, labelRoot, labelSelectors);
        return node;
    },
    // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)
    // keep `undefined` or `null` because `{}` means something else
    _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {
        if (labelAttrs === null) return null;
        if (labelAttrs === undefined) {
            if (defaultLabelAttrs === null) return null;
            if (defaultLabelAttrs === undefined) {
                if (hasCustomMarkup) return undefined;
                return builtinDefaultLabelAttrs;
            }
            if (hasCustomMarkup) return defaultLabelAttrs;
            return (0, _indexMjs1.merge)({}, builtinDefaultLabelAttrs, defaultLabelAttrs);
        }
        if (hasCustomMarkup) return (0, _indexMjs1.merge)({}, defaultLabelAttrs, labelAttrs);
        return (0, _indexMjs1.merge)({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);
    },
    // merge default label size into label size (no built-in default)
    // keep `undefined` or `null` because `{}` means something else
    _mergeLabelSize: function(labelSize, defaultLabelSize) {
        if (labelSize === null) return null;
        if (labelSize === undefined) {
            if (defaultLabelSize === null) return null;
            if (defaultLabelSize === undefined) return undefined;
            return defaultLabelSize;
        }
        return (0, _indexMjs1.merge)({}, defaultLabelSize, labelSize);
    },
    updateLabels: function() {
        if (!this._V.labels) return this;
        var model = this.model;
        var labels = model.get("labels") || [];
        var canLabelMove = this.can("labelMove");
        var builtinDefaultLabel = model._builtins.defaultLabel;
        var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;
        var defaultLabel = model._getDefaultLabel();
        var defaultLabelMarkup = defaultLabel.markup;
        var defaultLabelAttrs = defaultLabel.attrs;
        var defaultLabelSize = defaultLabel.size;
        for(var i = 0, n = labels.length; i < n; i++){
            var labelNode = this._labelCache[i];
            labelNode.setAttribute("cursor", canLabelMove ? "move" : "default");
            var selectors = this._labelSelectors[i];
            var label = labels[i];
            var labelMarkup = label.markup;
            var labelAttrs = label.attrs;
            var labelSize = label.size;
            var attrs = this._mergeLabelAttrs(labelMarkup || defaultLabelMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs);
            var size = this._mergeLabelSize(labelSize, defaultLabelSize);
            this.updateDOMSubtreeAttributes(labelNode, attrs, {
                rootBBox: new (0, _indexMjs2.Rect)(size),
                selectors: selectors
            });
        }
        return this;
    },
    renderTools: function() {
        if (!this._V.linkTools) return this;
        // Tools are a group of clickable elements that manipulate the whole link.
        // A good example of this is the remove tool that removes the whole link.
        // Tools appear after hovering the link close to the `source` element/point of the link
        // but are offset a bit so that they don't cover the `marker-arrowhead`.
        var $tools = (0, _jqueryDefault.default)(this._V.linkTools.node).empty();
        var toolTemplate = (0, _indexMjs1.template)(this.model.get("toolMarkup") || this.model.toolMarkup);
        var tool = (0, _indexMjsDefault.default)(toolTemplate());
        $tools.append(tool.node);
        // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.
        this._toolCache = tool;
        // If `doubleLinkTools` is enabled, we render copy of the tools on the other side of the
        // link as well but only if the link is longer than `longLinkLength`.
        if (this.options.doubleLinkTools) {
            var tool2;
            if (this.model.get("doubleToolMarkup") || this.model.doubleToolMarkup) {
                toolTemplate = (0, _indexMjs1.template)(this.model.get("doubleToolMarkup") || this.model.doubleToolMarkup);
                tool2 = (0, _indexMjsDefault.default)(toolTemplate());
            } else tool2 = tool.clone();
            $tools.append(tool2.node);
            this._tool2Cache = tool2;
        }
        return this;
    },
    renderVertexMarkers: function() {
        if (!this._V.markerVertices) return this;
        var $markerVertices = (0, _jqueryDefault.default)(this._V.markerVertices.node).empty();
        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy
        // if default styling (elements) are not desired. This makes it possible to use any
        // SVG elements for .marker-vertex and .marker-vertex-remove tools.
        var markupTemplate = (0, _indexMjs1.template)(this.model.get("vertexMarkup") || this.model.vertexMarkup);
        this.model.vertices().forEach(function(vertex, idx) {
            $markerVertices.append((0, _indexMjsDefault.default)(markupTemplate((0, _indexMjs1.assign)({
                idx: idx
            }, vertex))).node);
        });
        return this;
    },
    renderArrowheadMarkers: function() {
        // Custom markups might not have arrowhead markers. Therefore, jump of this function immediately if that's the case.
        if (!this._V.markerArrowheads) return this;
        var $markerArrowheads = (0, _jqueryDefault.default)(this._V.markerArrowheads.node);
        $markerArrowheads.empty();
        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy
        // if default styling (elements) are not desired. This makes it possible to use any
        // SVG elements for .marker-vertex and .marker-vertex-remove tools.
        var markupTemplate = (0, _indexMjs1.template)(this.model.get("arrowheadMarkup") || this.model.arrowheadMarkup);
        this._V.sourceArrowhead = (0, _indexMjsDefault.default)(markupTemplate({
            end: "source"
        }));
        this._V.targetArrowhead = (0, _indexMjsDefault.default)(markupTemplate({
            end: "target"
        }));
        $markerArrowheads.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node);
        return this;
    },
    // remove vertices that lie on (or nearly on) straight lines within the link
    // return the number of removed points
    removeRedundantLinearVertices: function(opt) {
        const SIMPLIFY_THRESHOLD = 0.001;
        const link = this.model;
        const vertices = link.vertices();
        const routePoints = [
            this.sourceAnchor,
            ...vertices,
            this.targetAnchor
        ];
        const numRoutePoints = routePoints.length;
        // put routePoints into a polyline and try to simplify
        const polyline = new (0, _indexMjs2.Polyline)(routePoints);
        polyline.simplify({
            threshold: SIMPLIFY_THRESHOLD
        });
        const polylinePoints = polyline.points.map((point)=>point.toJSON()); // JSON of points after simplification
        const numPolylinePoints = polylinePoints.length; // number of points after simplification
        // shortcut if simplification did not remove any redundant vertices:
        if (numRoutePoints === numPolylinePoints) return 0;
        // else: set simplified polyline points as link vertices
        // remove first and last polyline points again (= source/target anchors)
        link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);
        return numRoutePoints - numPolylinePoints;
    },
    updateDefaultConnectionPath: function() {
        var cache = this._V;
        if (cache.connection) cache.connection.attr("d", this.getSerializedConnection());
        if (cache.connectionWrap) cache.connectionWrap.attr("d", this.getSerializedConnection());
        if (cache.markerSource && cache.markerTarget) this._translateAndAutoOrientArrows(cache.markerSource, cache.markerTarget);
    },
    getEndView: function(type) {
        switch(type){
            case "source":
                return this.sourceView || null;
            case "target":
                return this.targetView || null;
            default:
                throw new Error("dia.LinkView: type parameter required.");
        }
    },
    getEndAnchor: function(type) {
        switch(type){
            case "source":
                return new (0, _indexMjs2.Point)(this.sourceAnchor);
            case "target":
                return new (0, _indexMjs2.Point)(this.targetAnchor);
            default:
                throw new Error("dia.LinkView: type parameter required.");
        }
    },
    getEndConnectionPoint: function(type) {
        switch(type){
            case "source":
                return new (0, _indexMjs2.Point)(this.sourcePoint);
            case "target":
                return new (0, _indexMjs2.Point)(this.targetPoint);
            default:
                throw new Error("dia.LinkView: type parameter required.");
        }
    },
    getEndMagnet: function(type) {
        switch(type){
            case "source":
                var sourceView = this.sourceView;
                if (!sourceView) break;
                return this.sourceMagnet || sourceView.el;
            case "target":
                var targetView = this.targetView;
                if (!targetView) break;
                return this.targetMagnet || targetView.el;
            default:
                throw new Error("dia.LinkView: type parameter required.");
        }
        return null;
    },
    // Updating.
    // ---------
    update: function() {
        this.updateRoute();
        this.updatePath();
        this.updateDOM();
        return this;
    },
    translate: function(tx = 0, ty = 0) {
        const { route, path } = this;
        if (!route || !path) return;
        // translate the route
        const polyline = new (0, _indexMjs2.Polyline)(route);
        polyline.translate(tx, ty);
        this.route = polyline.points;
        // translate source and target connection and marker points.
        this._translateConnectionPoints(tx, ty);
        // translate the geometry path
        path.translate(tx, ty);
        this.updateDOM();
    },
    updateDOM () {
        const { el, model, selectors } = this;
        this.cleanNodesCache();
        // update SVG attributes defined by 'attrs/'.
        this.updateDOMSubtreeAttributes(el, model.attr(), {
            selectors
        });
        // legacy link path update
        this.updateDefaultConnectionPath();
        // update the label position etc.
        this.updateLabelPositions();
        this.updateToolsPosition();
        this.updateArrowheadMarkers();
        // *Deprecated*
        // Local perpendicular flag (as opposed to one defined on paper).
        // Could be enabled inside a connector/router. It's valid only
        // during the update execution.
        this.options.perpendicular = null;
    },
    updateRoute: function() {
        const { model } = this;
        const vertices = model.vertices();
        // 1. Find Anchors
        const anchors = this.findAnchors(vertices);
        const sourceAnchor = this.sourceAnchor = anchors.source;
        const targetAnchor = this.targetAnchor = anchors.target;
        // 2. Find Route
        const route = this.findRoute(vertices);
        this.route = route;
        // 3. Find Connection Points
        var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);
        this.sourcePoint = connectionPoints.source;
        this.targetPoint = connectionPoints.target;
    },
    updatePath: function() {
        const { route, sourcePoint, targetPoint } = this;
        // 3b. Find Marker Connection Point - Backwards Compatibility
        const markerPoints = this.findMarkerPoints(route, sourcePoint, targetPoint);
        // 4. Find Connection
        const path = this.findPath(route, markerPoints.source || sourcePoint, markerPoints.target || targetPoint);
        this.path = path;
    },
    findMarkerPoints: function(route, sourcePoint, targetPoint) {
        var firstWaypoint = route[0];
        var lastWaypoint = route[route.length - 1];
        // Move the source point by the width of the marker taking into account
        // its scale around x-axis. Note that scale is the only transform that
        // makes sense to be set in `.marker-source` attributes object
        // as all other transforms (translate/rotate) will be replaced
        // by the `translateAndAutoOrient()` function.
        var cache = this._markerCache;
        // cache source and target points
        var sourceMarkerPoint, targetMarkerPoint;
        if (this._V.markerSource) {
            cache.sourceBBox = cache.sourceBBox || this._V.markerSource.getBBox();
            sourceMarkerPoint = (0, _indexMjs2.Point)(sourcePoint).move(firstWaypoint || targetPoint, cache.sourceBBox.width * this._V.markerSource.scale().sx * -1).round();
        }
        if (this._V.markerTarget) {
            cache.targetBBox = cache.targetBBox || this._V.markerTarget.getBBox();
            targetMarkerPoint = (0, _indexMjs2.Point)(targetPoint).move(lastWaypoint || sourcePoint, cache.targetBBox.width * this._V.markerTarget.scale().sx * -1).round();
        }
        // if there was no markup for the marker, use the connection point.
        cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();
        cache.targetPoint = targetMarkerPoint || targetPoint.clone();
        return {
            source: sourceMarkerPoint,
            target: targetMarkerPoint
        };
    },
    findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {
        var firstAnchor, secondAnchor;
        var firstAnchorRef, secondAnchorRef;
        var model = this.model;
        var firstDef = model.get(firstEndType);
        var secondDef = model.get(secondEndType);
        var firstView = this.getEndView(firstEndType);
        var secondView = this.getEndView(secondEndType);
        var firstMagnet = this.getEndMagnet(firstEndType);
        var secondMagnet = this.getEndMagnet(secondEndType);
        // Anchor first
        if (firstView) {
            if (firstRef) firstAnchorRef = new (0, _indexMjs2.Point)(firstRef);
            else if (secondView) firstAnchorRef = secondMagnet;
            else firstAnchorRef = new (0, _indexMjs2.Point)(secondDef);
            firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);
        } else firstAnchor = new (0, _indexMjs2.Point)(firstDef);
        // Anchor second
        if (secondView) {
            secondAnchorRef = new (0, _indexMjs2.Point)(secondRef || firstAnchor);
            secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);
        } else secondAnchor = new (0, _indexMjs2.Point)(secondDef);
        var res = {};
        res[firstEndType] = firstAnchor;
        res[secondEndType] = secondAnchor;
        return res;
    },
    findAnchors: function(vertices) {
        var model = this.model;
        var firstVertex = vertices[0];
        var lastVertex = vertices[vertices.length - 1];
        if (model.target().priority && !model.source().priority) // Reversed order
        return this.findAnchorsOrdered("target", lastVertex, "source", firstVertex);
        // Usual order
        return this.findAnchorsOrdered("source", firstVertex, "target", lastVertex);
    },
    findConnectionPoints: function(route, sourceAnchor, targetAnchor) {
        var firstWaypoint = route[0];
        var lastWaypoint = route[route.length - 1];
        var model = this.model;
        var sourceDef = model.get("source");
        var targetDef = model.get("target");
        var sourceView = this.sourceView;
        var targetView = this.targetView;
        var paperOptions = this.paper.options;
        var sourceMagnet, targetMagnet;
        // Connection Point Source
        var sourcePoint;
        if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {
            sourceMagnet = this.sourceMagnet || sourceView.el;
            var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;
            var sourcePointRef = firstWaypoint || targetAnchor;
            var sourceLine = new (0, _indexMjs2.Line)(sourcePointRef, sourceAnchor);
            sourcePoint = this.getConnectionPoint(sourceConnectionPointDef, sourceView, sourceMagnet, sourceLine, "source");
        } else sourcePoint = sourceAnchor;
        // Connection Point Target
        var targetPoint;
        if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {
            targetMagnet = this.targetMagnet || targetView.el;
            var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;
            var targetPointRef = lastWaypoint || sourceAnchor;
            var targetLine = new (0, _indexMjs2.Line)(targetPointRef, targetAnchor);
            targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, "target");
        } else targetPoint = targetAnchor;
        return {
            source: sourcePoint,
            target: targetPoint
        };
    },
    getAnchor: function(anchorDef, cellView, magnet, ref, endType) {
        var isConnection = cellView.isNodeConnection(magnet);
        var paperOptions = this.paper.options;
        if (!anchorDef) {
            if (isConnection) anchorDef = paperOptions.defaultLinkAnchor;
            else if (paperOptions.perpendicularLinks || this.options.perpendicular) // Backwards compatibility
            // If `perpendicularLinks` flag is set on the paper and there are vertices
            // on the link, then try to find a connection point that makes the link perpendicular
            // even though the link won't point to the center of the targeted object.
            anchorDef = {
                name: "perpendicular"
            };
            else anchorDef = paperOptions.defaultAnchor;
        }
        if (!anchorDef) throw new Error("Anchor required.");
        var anchorFn;
        if (typeof anchorDef === "function") anchorFn = anchorDef;
        else {
            var anchorName = anchorDef.name;
            var anchorNamespace = isConnection ? "linkAnchorNamespace" : "anchorNamespace";
            anchorFn = paperOptions[anchorNamespace][anchorName];
            if (typeof anchorFn !== "function") throw new Error("Unknown anchor: " + anchorName);
        }
        var anchor = anchorFn.call(this, cellView, magnet, ref, anchorDef.args || {}, endType, this);
        if (!anchor) return new (0, _indexMjs2.Point)();
        return anchor.round(this.decimalsRounding);
    },
    getConnectionPoint: function(connectionPointDef, view, magnet, line, endType) {
        var connectionPoint;
        var anchor = line.end;
        var paperOptions = this.paper.options;
        // Backwards compatibility
        if (typeof paperOptions.linkConnectionPoint === "function") {
            var linkConnectionMagnet = magnet === view.el ? undefined : magnet;
            connectionPoint = paperOptions.linkConnectionPoint(this, view, linkConnectionMagnet, line.start, endType);
            if (connectionPoint) return connectionPoint;
        }
        if (!connectionPointDef) return anchor;
        var connectionPointFn;
        if (typeof connectionPointDef === "function") connectionPointFn = connectionPointDef;
        else {
            var connectionPointName = connectionPointDef.name;
            connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];
            if (typeof connectionPointFn !== "function") throw new Error("Unknown connection point: " + connectionPointName);
        }
        connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);
        if (!connectionPoint) return anchor;
        return connectionPoint.round(this.decimalsRounding);
    },
    _translateConnectionPoints: function(tx, ty) {
        var cache = this._markerCache;
        cache.sourcePoint.offset(tx, ty);
        cache.targetPoint.offset(tx, ty);
        this.sourcePoint.offset(tx, ty);
        this.targetPoint.offset(tx, ty);
        this.sourceAnchor.offset(tx, ty);
        this.targetAnchor.offset(tx, ty);
    },
    // combine default label position with built-in default label position
    _getDefaultLabelPositionProperty: function() {
        var model = this.model;
        var builtinDefaultLabel = model._builtins.defaultLabel;
        var builtinDefaultLabelPosition = builtinDefaultLabel.position;
        var defaultLabel = model._getDefaultLabel();
        var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);
        return (0, _indexMjs1.merge)({}, builtinDefaultLabelPosition, defaultLabelPosition);
    },
    // if label position is a number, normalize it to a position object
    // this makes sure that label positions can be merged properly
    _normalizeLabelPosition: function(labelPosition) {
        if (typeof labelPosition === "number") return {
            distance: labelPosition,
            offset: null,
            angle: 0,
            args: null
        };
        return labelPosition;
    },
    // expects normalized position properties
    // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`
    _mergeLabelPositionProperty: function(normalizedLabelPosition, normalizedDefaultLabelPosition) {
        if (normalizedLabelPosition === null) return null;
        if (normalizedLabelPosition === undefined) {
            if (normalizedDefaultLabelPosition === null) return null;
            return normalizedDefaultLabelPosition;
        }
        return (0, _indexMjs1.merge)({}, normalizedDefaultLabelPosition, normalizedLabelPosition);
    },
    updateLabelPositions: function() {
        if (!this._V.labels) return this;
        var path = this.path;
        if (!path) return this;
        // This method assumes all the label nodes are stored in the `this._labelCache` hash table
        // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.
        var model = this.model;
        var labels = model.get("labels") || [];
        if (!labels.length) return this;
        var defaultLabelPosition = this._getDefaultLabelPositionProperty();
        for(var idx = 0, n = labels.length; idx < n; idx++){
            var labelNode = this._labelCache[idx];
            if (!labelNode) continue;
            var label = labels[idx];
            var labelPosition = this._normalizeLabelPosition(label.position);
            var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);
            var transformationMatrix = this._getLabelTransformationMatrix(position);
            labelNode.setAttribute("transform", (0, _indexMjsDefault.default).matrixToTransformString(transformationMatrix));
            this._cleanLabelMatrices(idx);
        }
        return this;
    },
    _cleanLabelMatrices: function(index) {
        // Clean magnetMatrix for all nodes of the label.
        // Cached BoundingRect does not need to updated when the position changes
        // TODO: this doesn't work for labels with XML String markups.
        const { metrics, _labelSelectors } = this;
        const selectors = _labelSelectors[index];
        if (!selectors) return;
        for(let selector in selectors){
            const { id } = selectors[selector];
            if (id && id in metrics) delete metrics[id].magnetMatrix;
        }
    },
    updateToolsPosition: function() {
        if (!this._V.linkTools) return this;
        // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.
        // Note that the offset is hardcoded here. The offset should be always
        // more than the `this.$('.marker-arrowhead[end="source"]')[0].bbox().width` but looking
        // this up all the time would be slow.
        var scale = "";
        var offset = this.options.linkToolsOffset;
        var connectionLength = this.getConnectionLength();
        // Firefox returns connectionLength=NaN in odd cases (for bezier curves).
        // In that case we won't update tools position at all.
        if (!Number.isNaN(connectionLength)) {
            // If the link is too short, make the tools half the size and the offset twice as low.
            if (connectionLength < this.options.shortLinkLength) {
                scale = "scale(.5)";
                offset /= 2;
            }
            var toolPosition = this.getPointAtLength(offset);
            this._toolCache.attr("transform", "translate(" + toolPosition.x + ", " + toolPosition.y + ") " + scale);
            if (this.options.doubleLinkTools && connectionLength >= this.options.longLinkLength) {
                var doubleLinkToolsOffset = this.options.doubleLinkToolsOffset || offset;
                toolPosition = this.getPointAtLength(connectionLength - doubleLinkToolsOffset);
                this._tool2Cache.attr("transform", "translate(" + toolPosition.x + ", " + toolPosition.y + ") " + scale);
                this._tool2Cache.attr("visibility", "visible");
            } else if (this.options.doubleLinkTools) this._tool2Cache.attr("visibility", "hidden");
        }
        return this;
    },
    updateArrowheadMarkers: function() {
        if (!this._V.markerArrowheads) return this;
        // getting bbox of an element with `display="none"` in IE9 ends up with access violation
        if ((0, _jqueryDefault.default).css(this._V.markerArrowheads.node, "display") === "none") return this;
        var sx = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;
        this._V.sourceArrowhead.scale(sx);
        this._V.targetArrowhead.scale(sx);
        this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead);
        return this;
    },
    updateEndProperties: function(endType) {
        const { model, paper } = this;
        const endViewProperty = `${endType}View`;
        const endDef = model.get(endType);
        const endId = endDef && endDef.id;
        if (!endId) {
            // the link end is a point ~ rect 0x0
            this[endViewProperty] = null;
            this.updateEndMagnet(endType);
            return true;
        }
        const endModel = paper.getModelById(endId);
        if (!endModel) throw new Error("LinkView: invalid " + endType + " cell.");
        const endView = endModel.findView(paper);
        if (!endView) // A view for a model should always exist
        return false;
        this[endViewProperty] = endView;
        this.updateEndMagnet(endType);
        return true;
    },
    updateEndMagnet: function(endType) {
        const endMagnetProperty = `${endType}Magnet`;
        const endView = this.getEndView(endType);
        if (endView) {
            let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));
            if (connectedMagnet === endView.el) connectedMagnet = null;
            this[endMagnetProperty] = connectedMagnet;
        } else this[endMagnetProperty] = null;
    },
    _translateAndAutoOrientArrows: function(sourceArrow, targetArrow) {
        // Make the markers "point" to their sticky points being auto-oriented towards
        // `targetPosition`/`sourcePosition`. And do so only if there is a markup for them.
        var route = (0, _indexMjs1.toArray)(this.route);
        if (sourceArrow) sourceArrow.translateAndAutoOrient(this.sourcePoint, route[0] || this.targetPoint, this.paper.cells);
        if (targetArrow) targetArrow.translateAndAutoOrient(this.targetPoint, route[route.length - 1] || this.sourcePoint, this.paper.cells);
    },
    _getLabelPositionProperty: function(idx) {
        return this.model.label(idx).position || {};
    },
    _getLabelPositionAngle: function(idx) {
        var labelPosition = this._getLabelPositionProperty(idx);
        return labelPosition.angle || 0;
    },
    _getLabelPositionArgs: function(idx) {
        var labelPosition = this._getLabelPositionProperty(idx);
        return labelPosition.args;
    },
    _getDefaultLabelPositionArgs: function() {
        var defaultLabel = this.model._getDefaultLabel();
        var defaultLabelPosition = defaultLabel.position || {};
        return defaultLabelPosition.args;
    },
    // merge default label position args into label position args
    // keep `undefined` or `null` because `{}` means something else
    _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {
        if (labelPositionArgs === null) return null;
        if (labelPositionArgs === undefined) {
            if (defaultLabelPositionArgs === null) return null;
            return defaultLabelPositionArgs;
        }
        return (0, _indexMjs1.merge)({}, defaultLabelPositionArgs, labelPositionArgs);
    },
    // Add default label at given position at end of `labels` array.
    // Four signatures:
    // - obj, obj = point, opt
    // - obj, num, obj = point, angle, opt
    // - num, num, obj = x, y, opt
    // - num, num, num, obj = x, y, angle, opt
    // Assigns relative coordinates by default:
    // `opt.absoluteDistance` forces absolute coordinates.
    // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).
    // `opt.absoluteOffset` forces absolute coordinates for offset.
    // Additional args:
    // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.
    // `opt.ensureLegibility` rotates labels so they are never upside-down.
    addLabel: function(p1, p2, p3, p4) {
        // normalize data from the four possible signatures
        var localX;
        var localY;
        var localAngle = 0;
        var localOpt;
        if (typeof p1 !== "number") {
            // {x, y} object provided as first parameter
            localX = p1.x;
            localY = p1.y;
            if (typeof p2 === "number") {
                // angle and opt provided as second and third parameters
                localAngle = p2;
                localOpt = p3;
            } else // opt provided as second parameter
            localOpt = p2;
        } else {
            // x and y provided as first and second parameters
            localX = p1;
            localY = p2;
            if (typeof p3 === "number") {
                // angle and opt provided as third and fourth parameters
                localAngle = p3;
                localOpt = p4;
            } else // opt provided as third parameter
            localOpt = p3;
        }
        // merge label position arguments
        var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();
        var labelPositionArgs = localOpt;
        var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
        // append label to labels array
        var label = {
            position: this.getLabelPosition(localX, localY, localAngle, positionArgs)
        };
        var idx = -1;
        this.model.insertLabel(idx, label, localOpt);
        return idx;
    },
    // Add a new vertex at calculated index to the `vertices` array.
    addVertex: function(x, y, opt) {
        // accept input in form `{ x, y }, opt` or `x, y, opt`
        var isPointProvided = typeof x !== "number";
        var localX = isPointProvided ? x.x : x;
        var localY = isPointProvided ? x.y : y;
        var localOpt = isPointProvided ? y : opt;
        var vertex = {
            x: localX,
            y: localY
        };
        var idx = this.getVertexIndex(localX, localY);
        this.model.insertVertex(idx, vertex, localOpt);
        return idx;
    },
    // Send a token (an SVG element, usually a circle) along the connection path.
    // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`
    // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.
    // `opt.directon` is optional and it determines whether the token goes from source to target or other way round (`reverse`)
    // `opt.connection` is an optional selector to the connection path.
    // `callback` is optional and is a function to be called once the token reaches the target.
    sendToken: function(token, opt, callback) {
        function onAnimationEnd(vToken, callback) {
            return function() {
                vToken.remove();
                if (typeof callback === "function") callback();
            };
        }
        var duration, isReversed, selector;
        if ((0, _indexMjs1.isObject)(opt)) {
            duration = opt.duration;
            isReversed = opt.direction === "reverse";
            selector = opt.connection;
        } else {
            // Backwards compatibility
            duration = opt;
            isReversed = false;
            selector = null;
        }
        duration = duration || 1000;
        var animationAttributes = {
            dur: duration + "ms",
            repeatCount: 1,
            calcMode: "linear",
            fill: "freeze"
        };
        if (isReversed) {
            animationAttributes.keyPoints = "1;0";
            animationAttributes.keyTimes = "0;1";
        }
        var vToken = (0, _indexMjsDefault.default)(token);
        var connection;
        if (typeof selector === "string") // Use custom connection path.
        connection = this.findBySelector(selector, this.el, this.selectors)[0];
        else {
            // Select connection path automatically.
            var cache = this._V;
            connection = cache.connection ? cache.connection.node : this.el.querySelector("path");
        }
        if (!(connection instanceof SVGPathElement)) throw new Error("dia.LinkView: token animation requires a valid connection path.");
        vToken.appendTo(this.paper.cells).animateAlongPath(animationAttributes, connection);
        setTimeout(onAnimationEnd(vToken, callback), duration);
    },
    findRoute: function(vertices) {
        vertices || (vertices = []);
        var namespace = this.paper.options.routerNamespace || _indexMjs3;
        var router = this.model.router();
        var defaultRouter = this.paper.options.defaultRouter;
        if (!router) {
            if (defaultRouter) router = defaultRouter;
            else return vertices.map((0, _indexMjs2.Point)); // no router specified
        }
        var routerFn = (0, _indexMjs1.isFunction)(router) ? router : namespace[router.name];
        if (!(0, _indexMjs1.isFunction)(routerFn)) throw new Error('dia.LinkView: unknown router: "' + router.name + '".');
        var args = router.args || {};
        var route = routerFn.call(this, vertices, args, this // linkView
        );
        if (!route) return vertices.map((0, _indexMjs2.Point));
        return route;
    },
    // Return the `d` attribute value of the `<path>` element representing the link
    // between `source` and `target`.
    findPath: function(route, sourcePoint, targetPoint) {
        var namespace = this.paper.options.connectorNamespace || _indexMjs4;
        var connector = this.model.connector();
        var defaultConnector = this.paper.options.defaultConnector;
        if (!connector) connector = defaultConnector || {};
        var connectorFn = (0, _indexMjs1.isFunction)(connector) ? connector : namespace[connector.name];
        if (!(0, _indexMjs1.isFunction)(connectorFn)) throw new Error('dia.LinkView: unknown connector: "' + connector.name + '".');
        var args = (0, _indexMjs1.clone)(connector.args || {});
        args.raw = true; // Request raw g.Path as the result.
        var path = connectorFn.call(this, sourcePoint, targetPoint, route, args, this // linkView
        );
        if (typeof path === "string") // Backwards compatibility for connectors not supporting `raw` option.
        path = new (0, _indexMjs2.Path)((0, _indexMjsDefault.default).normalizePathData(path));
        return path;
    },
    // Public API.
    // -----------
    getConnection: function() {
        var path = this.path;
        if (!path) return null;
        return path.clone();
    },
    getSerializedConnection: function() {
        var path = this.path;
        if (!path) return null;
        var metrics = this.metrics;
        if (metrics.hasOwnProperty("data")) return metrics.data;
        var data = path.serialize();
        metrics.data = data;
        return data;
    },
    getConnectionSubdivisions: function() {
        var path = this.path;
        if (!path) return null;
        var metrics = this.metrics;
        if (metrics.hasOwnProperty("segmentSubdivisions")) return metrics.segmentSubdivisions;
        var subdivisions = path.getSegmentSubdivisions();
        metrics.segmentSubdivisions = subdivisions;
        return subdivisions;
    },
    getConnectionLength: function() {
        var path = this.path;
        if (!path) return 0;
        var metrics = this.metrics;
        if (metrics.hasOwnProperty("length")) return metrics.length;
        var length = path.length({
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
        metrics.length = length;
        return length;
    },
    getPointAtLength: function(length) {
        var path = this.path;
        if (!path) return null;
        return path.pointAtLength(length, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    getPointAtRatio: function(ratio) {
        var path = this.path;
        if (!path) return null;
        if ((0, _indexMjs1.isPercentage)(ratio)) ratio = parseFloat(ratio) / 100;
        return path.pointAt(ratio, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    getTangentAtLength: function(length) {
        var path = this.path;
        if (!path) return null;
        return path.tangentAtLength(length, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    getTangentAtRatio: function(ratio) {
        var path = this.path;
        if (!path) return null;
        return path.tangentAt(ratio, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    getClosestPoint: function(point) {
        var path = this.path;
        if (!path) return null;
        return path.closestPoint(point, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    getClosestPointLength: function(point) {
        var path = this.path;
        if (!path) return null;
        return path.closestPointLength(point, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    getClosestPointRatio: function(point) {
        var path = this.path;
        if (!path) return null;
        return path.closestPointNormalizedLength(point, {
            segmentSubdivisions: this.getConnectionSubdivisions()
        });
    },
    // Get label position object based on two provided coordinates, x and y.
    // (Used behind the scenes when user moves labels around.)
    // Two signatures:
    // - num, num, obj = x, y, options
    // - num, num, num, obj = x, y, angle, options
    // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`
    // - `absoluteOffset` is necessary in order to move beyond connection endpoints
    // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`
    getLabelPosition: function(x, y, p3, p4) {
        var position = {};
        // normalize data from the two possible signatures
        var localAngle = 0;
        var localOpt;
        if (typeof p3 === "number") {
            // angle and opt provided as third and fourth argument
            localAngle = p3;
            localOpt = p4;
        } else // opt provided as third argument
        localOpt = p3;
        // save localOpt as `args` of the position object that is passed along
        if (localOpt) position.args = localOpt;
        // identify distance/offset settings
        var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default
        var isDistanceAbsoluteReverse = localOpt && localOpt.absoluteDistance && localOpt.reverseDistance; // non-reverse by default
        var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default
        // find closest point t
        var path = this.path;
        var pathOpt = {
            segmentSubdivisions: this.getConnectionSubdivisions()
        };
        var labelPoint = new (0, _indexMjs2.Point)(x, y);
        var t = path.closestPointT(labelPoint, pathOpt);
        // DISTANCE:
        var labelDistance = path.lengthAtT(t, pathOpt);
        if (isDistanceRelative) labelDistance = labelDistance / this.getConnectionLength() || 0; // fix to prevent NaN for 0 length
        if (isDistanceAbsoluteReverse) labelDistance = -1 * (this.getConnectionLength() - labelDistance) || 1; // fix for end point (-0 => 1)
        position.distance = labelDistance;
        // OFFSET:
        // use absolute offset if:
        // - opt.absoluteOffset is true,
        // - opt.absoluteOffset is not true but there is no tangent
        var tangent;
        if (!isOffsetAbsolute) tangent = path.tangentAtT(t);
        var labelOffset;
        if (tangent) labelOffset = tangent.pointOffset(labelPoint);
        else {
            var closestPoint = path.pointAtT(t);
            var labelOffsetDiff = labelPoint.difference(closestPoint);
            labelOffset = {
                x: labelOffsetDiff.x,
                y: labelOffsetDiff.y
            };
        }
        position.offset = labelOffset;
        // ANGLE:
        position.angle = localAngle;
        return position;
    },
    _getLabelTransformationMatrix: function(labelPosition) {
        var labelDistance;
        var labelAngle = 0;
        var args = {};
        if (typeof labelPosition === "number") labelDistance = labelPosition;
        else if (typeof labelPosition.distance === "number") {
            args = labelPosition.args || {};
            labelDistance = labelPosition.distance;
            labelAngle = labelPosition.angle || 0;
        } else throw new Error("dia.LinkView: invalid label position distance.");
        var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;
        var labelOffset = 0;
        var labelOffsetCoordinates = {
            x: 0,
            y: 0
        };
        if (labelPosition.offset) {
            var positionOffset = labelPosition.offset;
            if (typeof positionOffset === "number") labelOffset = positionOffset;
            if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;
            if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;
        }
        var isOffsetAbsolute = labelOffsetCoordinates.x !== 0 || labelOffsetCoordinates.y !== 0 || labelOffset === 0;
        var isKeepGradient = args.keepGradient;
        var isEnsureLegibility = args.ensureLegibility;
        var path = this.path;
        var pathOpt = {
            segmentSubdivisions: this.getConnectionSubdivisions()
        };
        var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;
        var tangent = path.tangentAtLength(distance, pathOpt);
        var translation;
        var angle = labelAngle;
        if (tangent) {
            if (isOffsetAbsolute) {
                translation = tangent.start.clone();
                translation.offset(labelOffsetCoordinates);
            } else {
                var normal = tangent.clone();
                normal.rotate(tangent.start, -90);
                normal.setLength(labelOffset);
                translation = normal.end;
            }
            if (isKeepGradient) {
                angle = tangent.angle() + labelAngle;
                if (isEnsureLegibility) angle = (0, _indexMjs2.normalizeAngle)((angle + 90) % 180 - 90);
            }
        } else {
            // fallback - the connection has zero length
            translation = path.start.clone();
            if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);
        }
        return (0, _indexMjsDefault.default).createSVGMatrix().translate(translation.x, translation.y).rotate(angle);
    },
    getLabelCoordinates: function(labelPosition) {
        var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);
        return new (0, _indexMjs2.Point)(transformationMatrix.e, transformationMatrix.f);
    },
    getVertexIndex: function(x, y) {
        var model = this.model;
        var vertices = model.vertices();
        var vertexLength = this.getClosestPointLength(new (0, _indexMjs2.Point)(x, y));
        var idx = 0;
        for(var n = vertices.length; idx < n; idx++){
            var currentVertex = vertices[idx];
            var currentVertexLength = this.getClosestPointLength(currentVertex);
            if (vertexLength < currentVertexLength) break;
        }
        return idx;
    },
    // Interaction. The controller part.
    // ---------------------------------
    notifyPointerdown (evt, x, y) {
        (0, _cellViewMjs.CellView).prototype.pointerdown.call(this, evt, x, y);
        this.notify("link:pointerdown", evt, x, y);
    },
    notifyPointermove (evt, x, y) {
        (0, _cellViewMjs.CellView).prototype.pointermove.call(this, evt, x, y);
        this.notify("link:pointermove", evt, x, y);
    },
    notifyPointerup (evt, x, y) {
        this.notify("link:pointerup", evt, x, y);
        (0, _cellViewMjs.CellView).prototype.pointerup.call(this, evt, x, y);
    },
    pointerdblclick: function(evt, x, y) {
        (0, _cellViewMjs.CellView).prototype.pointerdblclick.apply(this, arguments);
        this.notify("link:pointerdblclick", evt, x, y);
    },
    pointerclick: function(evt, x, y) {
        (0, _cellViewMjs.CellView).prototype.pointerclick.apply(this, arguments);
        this.notify("link:pointerclick", evt, x, y);
    },
    contextmenu: function(evt, x, y) {
        (0, _cellViewMjs.CellView).prototype.contextmenu.apply(this, arguments);
        this.notify("link:contextmenu", evt, x, y);
    },
    pointerdown: function(evt, x, y) {
        this.notifyPointerdown(evt, x, y);
        // Backwards compatibility for the default markup
        var className = evt.target.getAttribute("class");
        switch(className){
            case "marker-vertex":
                this.dragVertexStart(evt, x, y);
                return;
            case "marker-vertex-remove":
            case "marker-vertex-remove-area":
                this.dragVertexRemoveStart(evt, x, y);
                return;
            case "marker-arrowhead":
                this.dragArrowheadStart(evt, x, y);
                return;
            case "connection":
            case "connection-wrap":
                this.dragConnectionStart(evt, x, y);
                return;
            case "marker-source":
            case "marker-target":
                return;
        }
        this.dragStart(evt, x, y);
    },
    pointermove: function(evt, x, y) {
        // Backwards compatibility
        var dragData = this._dragData;
        if (dragData) this.eventData(evt, dragData);
        var data = this.eventData(evt);
        switch(data.action){
            case "vertex-move":
                this.dragVertex(evt, x, y);
                break;
            case "label-move":
                this.dragLabel(evt, x, y);
                break;
            case "arrowhead-move":
                this.dragArrowhead(evt, x, y);
                break;
            case "move":
                this.drag(evt, x, y);
                break;
        }
        // Backwards compatibility
        if (dragData) (0, _indexMjs1.assign)(dragData, this.eventData(evt));
        this.notifyPointermove(evt, x, y);
    },
    pointerup: function(evt, x, y) {
        // Backwards compatibility
        var dragData = this._dragData;
        if (dragData) {
            this.eventData(evt, dragData);
            this._dragData = null;
        }
        var data = this.eventData(evt);
        switch(data.action){
            case "vertex-move":
                this.dragVertexEnd(evt, x, y);
                break;
            case "label-move":
                this.dragLabelEnd(evt, x, y);
                break;
            case "arrowhead-move":
                this.dragArrowheadEnd(evt, x, y);
                break;
            case "move":
                this.dragEnd(evt, x, y);
        }
        this.notifyPointerup(evt, x, y);
        this.checkMouseleave(evt);
    },
    mouseover: function(evt) {
        (0, _cellViewMjs.CellView).prototype.mouseover.apply(this, arguments);
        this.notify("link:mouseover", evt);
    },
    mouseout: function(evt) {
        (0, _cellViewMjs.CellView).prototype.mouseout.apply(this, arguments);
        this.notify("link:mouseout", evt);
    },
    mouseenter: function(evt) {
        (0, _cellViewMjs.CellView).prototype.mouseenter.apply(this, arguments);
        this.notify("link:mouseenter", evt);
    },
    mouseleave: function(evt) {
        (0, _cellViewMjs.CellView).prototype.mouseleave.apply(this, arguments);
        this.notify("link:mouseleave", evt);
    },
    mousewheel: function(evt, x, y, delta) {
        (0, _cellViewMjs.CellView).prototype.mousewheel.apply(this, arguments);
        this.notify("link:mousewheel", evt, x, y, delta);
    },
    onevent: function(evt, eventName, x, y) {
        // Backwards compatibility
        var linkTool = (0, _indexMjsDefault.default)(evt.target).findParentByClass("link-tool", this.el);
        if (linkTool) {
            // No further action to be executed
            evt.stopPropagation();
            // Allow `interactive.useLinkTools=false`
            if (this.can("useLinkTools")) {
                if (eventName === "remove") {
                    // Built-in remove event
                    this.model.remove({
                        ui: true
                    });
                    // Do not trigger link pointerdown
                    return;
                } else // link:options and other custom events inside the link tools
                this.notify(eventName, evt, x, y);
            }
            this.notifyPointerdown(evt, x, y);
            this.paper.delegateDragEvents(this, evt.data);
        } else (0, _cellViewMjs.CellView).prototype.onevent.apply(this, arguments);
    },
    onlabel: function(evt, x, y) {
        this.notifyPointerdown(evt, x, y);
        this.dragLabelStart(evt, x, y);
        var stopPropagation = this.eventData(evt).stopPropagation;
        if (stopPropagation) evt.stopPropagation();
    },
    // Drag Start Handlers
    dragConnectionStart: function(evt, x, y) {
        if (!this.can("vertexAdd")) return;
        // Store the index at which the new vertex has just been placed.
        // We'll be update the very same vertex position in `pointermove()`.
        var vertexIdx = this.addVertex({
            x: x,
            y: y
        }, {
            ui: true
        });
        this.eventData(evt, {
            action: "vertex-move",
            vertexIdx: vertexIdx
        });
    },
    dragLabelStart: function(evt, x, y) {
        if (this.can("labelMove")) {
            if (this.isDefaultInteractionPrevented(evt)) return;
            var labelNode = evt.currentTarget;
            var labelIdx = parseInt(labelNode.getAttribute("label-idx"), 10);
            var defaultLabelPosition = this._getDefaultLabelPositionProperty();
            var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));
            var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);
            var coords = this.getLabelCoordinates(position);
            var dx = coords.x - x; // how much needs to be added to cursor x to get to label x
            var dy = coords.y - y; // how much needs to be added to cursor y to get to label y
            var positionAngle = this._getLabelPositionAngle(labelIdx);
            var labelPositionArgs = this._getLabelPositionArgs(labelIdx);
            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();
            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
            this.eventData(evt, {
                action: "label-move",
                labelIdx: labelIdx,
                dx: dx,
                dy: dy,
                positionAngle: positionAngle,
                positionArgs: positionArgs,
                stopPropagation: true
            });
        } else // Backwards compatibility:
        // If labels can't be dragged no default action is triggered.
        this.eventData(evt, {
            stopPropagation: true
        });
        this.paper.delegateDragEvents(this, evt.data);
    },
    dragVertexStart: function(evt, x, y) {
        if (!this.can("vertexMove")) return;
        var vertexNode = evt.target;
        var vertexIdx = parseInt(vertexNode.getAttribute("idx"), 10);
        this.eventData(evt, {
            action: "vertex-move",
            vertexIdx: vertexIdx
        });
    },
    dragVertexRemoveStart: function(evt, x, y) {
        if (!this.can("vertexRemove")) return;
        var removeNode = evt.target;
        var vertexIdx = parseInt(removeNode.getAttribute("idx"), 10);
        this.model.removeVertex(vertexIdx);
    },
    dragArrowheadStart: function(evt, x, y) {
        if (!this.can("arrowheadMove")) return;
        var arrowheadNode = evt.target;
        var arrowheadType = arrowheadNode.getAttribute("end");
        var data = this.startArrowheadMove(arrowheadType, {
            ignoreBackwardsCompatibility: true
        });
        this.eventData(evt, data);
    },
    dragStart: function(evt, x, y) {
        if (this.isDefaultInteractionPrevented(evt)) return;
        if (!this.can("linkMove")) return;
        this.eventData(evt, {
            action: "move",
            dx: x,
            dy: y
        });
    },
    // Drag Handlers
    dragLabel: function(evt, x, y) {
        var data = this.eventData(evt);
        var label = {
            position: this.getLabelPosition(x + data.dx, y + data.dy, data.positionAngle, data.positionArgs)
        };
        if (this.paper.options.snapLabels) delete label.position.offset;
        // The `touchmove' events are not fired
        // when the original event target is removed from the DOM.
        // The labels are currently re-rendered completely when only
        // the position changes. This is why we need to make sure that
        // the label is updated synchronously.
        // TODO: replace `touchmove` with `pointermove` (breaking change).
        const setOptions = {
            ui: true
        };
        if (this.paper.isAsync() && evt.type === "touchmove") setOptions.async = false;
        this.model.label(data.labelIdx, label, setOptions);
    },
    dragVertex: function(evt, x, y) {
        var data = this.eventData(evt);
        this.model.vertex(data.vertexIdx, {
            x: x,
            y: y
        }, {
            ui: true
        });
    },
    dragArrowhead: function(evt, x, y) {
        if (this.paper.options.snapLinks) {
            const isSnapped = this._snapArrowhead(evt, x, y);
            if (!isSnapped && this.paper.options.snapLinksSelf) this._snapArrowheadSelf(evt, x, y);
        } else if (this.paper.options.snapLinksSelf) this._snapArrowheadSelf(evt, x, y);
        else this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));
    },
    drag: function(evt, x, y) {
        var data = this.eventData(evt);
        this.model.translate(x - data.dx, y - data.dy, {
            ui: true
        });
        this.eventData(evt, {
            dx: x,
            dy: y
        });
    },
    // Drag End Handlers
    dragLabelEnd: function() {
    // noop
    },
    dragVertexEnd: function() {
    // noop
    },
    dragArrowheadEnd: function(evt, x, y) {
        var data = this.eventData(evt);
        var paper = this.paper;
        if (paper.options.snapLinks) this._snapArrowheadEnd(data);
        else this._connectArrowheadEnd(data, x, y);
        if (!paper.linkAllowed(this)) // If the changed link is not allowed, revert to its previous state.
        this._disallow(data);
        else {
            this._finishEmbedding(data);
            this._notifyConnectEvent(data, evt);
        }
        this._afterArrowheadMove(data);
    },
    dragEnd: function() {
    // noop
    },
    _disallow: function(data) {
        switch(data.whenNotAllowed){
            case "remove":
                this.model.remove({
                    ui: true
                });
                break;
            case "revert":
            default:
                this.model.set(data.arrowhead, data.initialEnd, {
                    ui: true
                });
                break;
        }
    },
    _finishEmbedding: function(data) {
        // Reparent the link if embedding is enabled
        if (this.paper.options.embeddingMode && this.model.reparent()) // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).
        data.z = null;
    },
    _notifyConnectEvent: function(data, evt) {
        var arrowhead = data.arrowhead;
        var initialEnd = data.initialEnd;
        var currentEnd = this.model.prop(arrowhead);
        var endChanged = currentEnd && !(0, _linkMjs.Link).endsEqual(initialEnd, currentEnd);
        if (endChanged) {
            var paper = this.paper;
            if (initialEnd.id) this.notify("link:disconnect", evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);
            if (currentEnd.id) this.notify("link:connect", evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);
        }
    },
    _snapToPoints: function(snapPoint, points, radius) {
        let closestPointX = null;
        let closestDistanceX = Infinity;
        let closestPointY = null;
        let closestDistanceY = Infinity;
        let x = snapPoint.x;
        let y = snapPoint.y;
        for(let i = 0; i < points.length; i++){
            const distX = Math.abs(points[i].x - snapPoint.x);
            if (distX < closestDistanceX) {
                closestDistanceX = distX;
                closestPointX = points[i];
            }
            const distY = Math.abs(points[i].y - snapPoint.y);
            if (distY < closestDistanceY) {
                closestDistanceY = distY;
                closestPointY = points[i];
            }
        }
        if (closestDistanceX < radius) x = closestPointX.x;
        if (closestDistanceY < radius) y = closestPointY.y;
        return {
            x,
            y
        };
    },
    _snapArrowheadSelf: function(evt, x, y) {
        const { paper, model } = this;
        const { snapLinksSelf } = paper.options;
        const data = this.eventData(evt);
        const radius = snapLinksSelf.radius || 20;
        const anchor = this.getEndAnchor(data.arrowhead === "source" ? "target" : "source");
        const vertices = model.vertices();
        const points = [
            anchor,
            ...vertices
        ];
        const snapPoint = this._snapToPoints({
            x: x,
            y: y
        }, points, radius);
        const point = paper.localToClientPoint(snapPoint);
        this._connectArrowhead(document.elementFromPoint(point.x, point.y), snapPoint.x, snapPoint.y, this.eventData(evt));
    },
    _snapArrowhead: function(evt, x, y) {
        const { paper } = this;
        const { snapLinks, connectionStrategy } = paper.options;
        const data = this.eventData(evt);
        let isSnapped = false;
        // checking view in close area of the pointer
        var r = snapLinks.radius || 50;
        var viewsInArea = paper.findViewsInArea({
            x: x - r,
            y: y - r,
            width: 2 * r,
            height: 2 * r
        });
        var prevClosestView = data.closestView || null;
        var prevClosestMagnet = data.closestMagnet || null;
        var prevMagnetProxy = data.magnetProxy || null;
        data.closestView = data.closestMagnet = data.magnetProxy = null;
        var minDistance = Number.MAX_VALUE;
        var pointer = new (0, _indexMjs2.Point)(x, y);
        viewsInArea.forEach(function(view) {
            const candidates = [];
            // skip connecting to the element in case '.': { magnet: false } attribute present
            if (view.el.getAttribute("magnet") !== "false") candidates.push({
                bbox: view.model.getBBox(),
                magnet: view.el
            });
            view.$("[magnet]").toArray().forEach((magnet)=>{
                candidates.push({
                    bbox: view.getNodeBBox(magnet),
                    magnet
                });
            });
            candidates.forEach((candidate)=>{
                const { magnet, bbox } = candidate;
                // find distance from the center of the model to pointer coordinates
                const distance = bbox.center().squaredDistance(pointer);
                // the connection is looked up in a circle area by `distance < r`
                if (distance < minDistance) {
                    const isAlreadyValidated = prevClosestMagnet === magnet;
                    if (isAlreadyValidated || paper.options.validateConnection.apply(paper, data.validateConnectionArgs(view, view.el === magnet ? null : magnet))) {
                        minDistance = distance;
                        data.closestView = view;
                        data.closestMagnet = magnet;
                    }
                }
            });
        }, this);
        var end;
        var magnetProxy = null;
        var closestView = data.closestView;
        var closestMagnet = data.closestMagnet;
        if (closestMagnet) magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, "highlighter");
        var endType = data.arrowhead;
        var newClosestMagnet = prevClosestMagnet !== closestMagnet;
        if (prevClosestView && newClosestMagnet) prevClosestView.unhighlight(prevMagnetProxy, {
            connecting: true,
            snapping: true
        });
        if (closestView) {
            const { prevEnd, prevX, prevY } = data;
            data.prevX = x;
            data.prevY = y;
            isSnapped = true;
            if (!newClosestMagnet) {
                if (typeof connectionStrategy !== "function" || prevX === x && prevY === y) // the magnet has not changed and the link's end does not depend on the x and y
                return isSnapped;
            }
            end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);
            if (!newClosestMagnet && (0, _indexMjs1.isEqual)(prevEnd, end)) // the source/target json has not changed
            return isSnapped;
            data.prevEnd = end;
            if (newClosestMagnet) closestView.highlight(magnetProxy, {
                connecting: true,
                snapping: true
            });
        } else end = {
            x: x,
            y: y
        };
        this.model.set(endType, end || {
            x: x,
            y: y
        }, {
            ui: true
        });
        if (prevClosestView) this.notify("link:snap:disconnect", evt, prevClosestView, prevClosestMagnet, endType);
        if (closestView) this.notify("link:snap:connect", evt, closestView, closestMagnet, endType);
        return isSnapped;
    },
    _snapArrowheadEnd: function(data) {
        // Finish off link snapping.
        // Everything except view unhighlighting was already done on pointermove.
        var closestView = data.closestView;
        var closestMagnet = data.closestMagnet;
        if (closestView && closestMagnet) {
            closestView.unhighlight(data.magnetProxy, {
                connecting: true,
                snapping: true
            });
            data.magnetUnderPointer = closestView.findMagnet(closestMagnet);
        }
        data.closestView = data.closestMagnet = null;
    },
    _connectArrowhead: function(target, x, y, data) {
        // checking views right under the pointer
        const { paper, model } = this;
        if (data.eventTarget !== target) {
            // Unhighlight the previous view under pointer if there was one.
            if (data.magnetProxy) data.viewUnderPointer.unhighlight(data.magnetProxy, {
                connecting: true
            });
            const viewUnderPointer = data.viewUnderPointer = paper.findView(target);
            if (viewUnderPointer) {
                // If we found a view that is under the pointer, we need to find the closest
                // magnet based on the real target element of the event.
                const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);
                const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, "highlighter");
                if (magnetUnderPointer && this.paper.options.validateConnection.apply(paper, data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer))) // If there was no magnet found, do not highlight anything and assume there
                // is no view under pointer we're interested in reconnecting to.
                // This can only happen if the overall element has the attribute `'.': { magnet: false }`.
                {
                    if (magnetProxy) viewUnderPointer.highlight(magnetProxy, {
                        connecting: true
                    });
                } else {
                    // This type of connection is not valid. Disregard this magnet.
                    data.magnetUnderPointer = null;
                    data.magnetProxy = null;
                }
            } else {
                // Make sure we'll unset previous magnet.
                data.magnetUnderPointer = null;
                data.magnetProxy = null;
            }
        }
        data.eventTarget = target;
        model.set(data.arrowhead, {
            x: x,
            y: y
        }, {
            ui: true
        });
    },
    _connectArrowheadEnd: function(data = {}, x, y) {
        const { model } = this;
        const { viewUnderPointer, magnetUnderPointer, magnetProxy, arrowhead } = data;
        if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;
        viewUnderPointer.unhighlight(magnetProxy, {
            connecting: true
        });
        // The link end is taken from the magnet under the pointer, not the proxy.
        const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);
        model.set(arrowhead, end, {
            ui: true
        });
    },
    _beforeArrowheadMove: function(data) {
        data.z = this.model.get("z");
        this.model.toFront();
        // Let the pointer propagate through the link view elements so that
        // the `evt.target` is another element under the pointer, not the link itself.
        var style = this.el.style;
        data.pointerEvents = style.pointerEvents;
        style.pointerEvents = "none";
        if (this.paper.options.markAvailable) this._markAvailableMagnets(data);
    },
    _afterArrowheadMove: function(data) {
        if (data.z !== null) {
            this.model.set("z", data.z, {
                ui: true
            });
            data.z = null;
        }
        // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.
        this.el.style.pointerEvents = data.pointerEvents;
        if (this.paper.options.markAvailable) this._unmarkAvailableMagnets(data);
    },
    _createValidateConnectionArgs: function(arrowhead) {
        // It makes sure the arguments for validateConnection have the following form:
        // (source view, source magnet, target view, target magnet and link view)
        var args = [];
        args[4] = arrowhead;
        args[5] = this;
        var oppositeArrowhead;
        var i = 0;
        var j = 0;
        if (arrowhead === "source") {
            i = 2;
            oppositeArrowhead = "target";
        } else {
            j = 2;
            oppositeArrowhead = "source";
        }
        var end = this.model.get(oppositeArrowhead);
        if (end.id) {
            var view = args[i] = this.paper.findViewByModel(end.id);
            var magnet = view.getMagnetFromLinkEnd(end);
            if (magnet === view.el) magnet = undefined;
            args[i + 1] = magnet;
        }
        function validateConnectionArgs(cellView, magnet) {
            args[j] = cellView;
            args[j + 1] = cellView.el === magnet ? undefined : magnet;
            return args;
        }
        return validateConnectionArgs;
    },
    _markAvailableMagnets: function(data) {
        function isMagnetAvailable(view, magnet) {
            var paper = view.paper;
            var validate = paper.options.validateConnection;
            return validate.apply(paper, this.validateConnectionArgs(view, magnet));
        }
        var paper = this.paper;
        var elements = paper.model.getCells();
        data.marked = {};
        for(var i = 0, n = elements.length; i < n; i++){
            var view = elements[i].findView(paper);
            if (!view) continue;
            var magnets = Array.prototype.slice.call(view.el.querySelectorAll("[magnet]"));
            if (view.el.getAttribute("magnet") !== "false") // Element wrapping group is also a magnet
            magnets.push(view.el);
            var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));
            if (availableMagnets.length > 0) {
                // highlight all available magnets
                for(var j = 0, m = availableMagnets.length; j < m; j++)view.highlight(availableMagnets[j], {
                    magnetAvailability: true
                });
                // highlight the entire view
                view.highlight(null, {
                    elementAvailability: true
                });
                data.marked[view.model.id] = availableMagnets;
            }
        }
    },
    _unmarkAvailableMagnets: function(data) {
        var markedKeys = Object.keys(data.marked);
        var id;
        var markedMagnets;
        for(var i = 0, n = markedKeys.length; i < n; i++){
            id = markedKeys[i];
            markedMagnets = data.marked[id];
            var view = this.paper.findViewByModel(id);
            if (view) {
                for(var j = 0, m = markedMagnets.length; j < m; j++)view.unhighlight(markedMagnets[j], {
                    magnetAvailability: true
                });
                view.unhighlight(null, {
                    elementAvailability: true
                });
            }
        }
        data.marked = null;
    },
    startArrowheadMove: function(end, opt) {
        opt || (opt = {});
        // Allow to delegate events from an another view to this linkView in order to trigger arrowhead
        // move without need to click on the actual arrowhead dom element.
        var data = {
            action: "arrowhead-move",
            arrowhead: end,
            whenNotAllowed: opt.whenNotAllowed || "revert",
            initialMagnet: this[end + "Magnet"] || (this[end + "View"] ? this[end + "View"].el : null),
            initialEnd: (0, _indexMjs1.clone)(this.model.get(end)),
            validateConnectionArgs: this._createValidateConnectionArgs(end)
        };
        this._beforeArrowheadMove(data);
        if (opt.ignoreBackwardsCompatibility !== true) this._dragData = data;
        return data;
    },
    // Lifecycle methods
    onMount: function() {
        (0, _cellViewMjs.CellView).prototype.onMount.apply(this, arguments);
        this.mountLabels();
    },
    onDetach: function() {
        (0, _cellViewMjs.CellView).prototype.onDetach.apply(this, arguments);
        this.unmountLabels();
    },
    onRemove: function() {
        (0, _cellViewMjs.CellView).prototype.onRemove.apply(this, arguments);
        this.unmountLabels();
    }
}, {
    Flags: Flags
});
Object.defineProperty(LinkView.prototype, "sourceBBox", {
    enumerable: true,
    get: function() {
        var sourceView = this.sourceView;
        if (!sourceView) {
            var sourceDef = this.model.source();
            return new (0, _indexMjs2.Rect)(sourceDef.x, sourceDef.y);
        }
        var sourceMagnet = this.sourceMagnet;
        if (sourceView.isNodeConnection(sourceMagnet)) return new (0, _indexMjs2.Rect)(this.sourceAnchor);
        return sourceView.getNodeBBox(sourceMagnet || sourceView.el);
    }
});
Object.defineProperty(LinkView.prototype, "targetBBox", {
    enumerable: true,
    get: function() {
        var targetView = this.targetView;
        if (!targetView) {
            var targetDef = this.model.target();
            return new (0, _indexMjs2.Rect)(targetDef.x, targetDef.y);
        }
        var targetMagnet = this.targetMagnet;
        if (targetView.isNodeConnection(targetMagnet)) return new (0, _indexMjs2.Rect)(this.targetAnchor);
        return targetView.getNodeBBox(targetMagnet || targetView.el);
    }
});

},{"./CellView.mjs":"5Rm2b","./Link.mjs":"kX2vg","../V/index.mjs":"iw8UN","../util/index.mjs":"eL7pI","../g/index.mjs":"i91Db","../routers/index.mjs":"3ms06","../connectors/index.mjs":"hiSTf","jquery":"7jr44","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3MwEo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Paper", ()=>Paper);
var _indexMjs = require("../V/index.mjs");
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _indexMjs1 = require("../util/index.mjs");
var _indexMjs2 = require("../g/index.mjs");
var _indexMjs3 = require("../mvc/index.mjs");
var _cellViewMjs = require("./CellView.mjs");
var _elementViewMjs = require("./ElementView.mjs");
var _linkViewMjs = require("./LinkView.mjs");
var _linkMjs = require("./Link.mjs");
var _cellMjs = require("./Cell.mjs");
var _graphMjs = require("./Graph.mjs");
var _paperLayerMjs = require("./PaperLayer.mjs");
var _indexMjs4 = require("../highlighters/index.mjs");
var _indexMjs5 = require("../linkAnchors/index.mjs");
var _indexMjs6 = require("../connectionPoints/index.mjs");
var _indexMjs7 = require("../anchors/index.mjs");
var _jquery = require("jquery");
var _jqueryDefault = parcelHelpers.interopDefault(_jquery);
var _backbone = require("backbone");
var _backboneDefault = parcelHelpers.interopDefault(_backbone);
const sortingTypes = {
    NONE: "sorting-none",
    APPROX: "sorting-approximate",
    EXACT: "sorting-exact"
};
const WHEEL_CAP = 50;
const WHEEL_WAIT_MS = 20;
const MOUNT_BATCH_SIZE = 1000;
const UPDATE_BATCH_SIZE = Infinity;
const MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER
const HighlightingTypes = (0, _cellViewMjs.CellView).Highlighting;
const defaultHighlighting = {
    [HighlightingTypes.DEFAULT]: {
        name: "stroke",
        options: {
            padding: 3
        }
    },
    [HighlightingTypes.MAGNET_AVAILABILITY]: {
        name: "addClass",
        options: {
            className: "available-magnet"
        }
    },
    [HighlightingTypes.ELEMENT_AVAILABILITY]: {
        name: "addClass",
        options: {
            className: "available-cell"
        }
    }
};
const defaultLayers = [
    {
        name: (0, _paperLayerMjs.LayersNames).BACK
    },
    {
        name: (0, _paperLayerMjs.LayersNames).CELLS
    },
    {
        name: (0, _paperLayerMjs.LayersNames).LABELS
    },
    {
        name: (0, _paperLayerMjs.LayersNames).FRONT
    },
    {
        name: (0, _paperLayerMjs.LayersNames).TOOLS
    }
];
const Paper = (0, _indexMjs3.View).extend({
    className: "paper",
    options: {
        width: 800,
        height: 600,
        origin: {
            x: 0,
            y: 0
        },
        gridSize: 1,
        // Whether or not to draw the grid lines on the paper's DOM element.
        // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }
        drawGrid: false,
        // If not set, the size of the visual grid is the same as the `gridSize`.
        drawGridSize: null,
        // Whether or not to draw the background on the paper's DOM element.
        // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }
        background: false,
        perpendicularLinks: false,
        elementView: (0, _elementViewMjs.ElementView),
        linkView: (0, _linkViewMjs.LinkView),
        snapLabels: false,
        snapLinks: false,
        snapLinksSelf: false,
        // Should the link labels be rendered into its own layer?
        // `false` - the labels are part of the links
        // `true` - the labels are appended to LayersName.LABELS
        // [LayersName] - the labels are appended to the layer specified
        labelsLayer: false,
        // When set to FALSE, an element may not have more than 1 link with the same source and target element.
        multiLinks: true,
        // For adding custom guard logic.
        guard: function(evt, view) {
            // FALSE means the event isn't guarded.
            return false;
        },
        highlighting: defaultHighlighting,
        // Prevent the default context menu from being displayed.
        preventContextMenu: true,
        // Prevent the default action for blank:pointer<action>.
        preventDefaultBlankAction: true,
        // Prevent the default action for cell:pointer<action>.
        preventDefaultViewAction: true,
        // Restrict the translation of elements by given bounding box.
        // Option accepts a boolean:
        //  true - the translation is restricted to the paper area
        //  false - no restrictions
        // A method:
        // restrictTranslate: function(elementView) {
        //     var parentId = elementView.model.get('parent');
        //     return parentId && this.model.getCell(parentId).getBBox();
        // },
        // Or a bounding box:
        // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }
        restrictTranslate: false,
        // Marks all available magnets with 'available-magnet' class name and all available cells with
        // 'available-cell' class name. Marks them when dragging a link is started and unmark
        // when the dragging is stopped.
        markAvailable: false,
        // Defines what link model is added to the graph after an user clicks on an active magnet.
        // Value could be the Backbone.model or a function returning the Backbone.model
        // defaultLink: function(elementView, magnet) { return condition ? new customLink1() : new customLink2() }
        defaultLink: new (0, _linkMjs.Link),
        // A connector that is used by links with no connector defined on the model.
        // e.g. { name: 'rounded', args: { radius: 5 }} or a function
        defaultConnector: {
            name: "normal"
        },
        // A router that is used by links with no router defined on the model.
        // e.g. { name: 'oneSide', args: { padding: 10 }} or a function
        defaultRouter: {
            name: "normal"
        },
        defaultAnchor: {
            name: "center"
        },
        defaultLinkAnchor: {
            name: "connectionRatio"
        },
        defaultConnectionPoint: {
            name: "bbox"
        },
        /* CONNECTING */ connectionStrategy: null,
        // Check whether to add a new link to the graph when user clicks on an a magnet.
        validateMagnet: function(_cellView, magnet, _evt) {
            return magnet.getAttribute("magnet") !== "passive";
        },
        // Check whether to allow or disallow the link connection while an arrowhead end (source/target)
        // being changed.
        validateConnection: function(cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {
            return (end === "target" ? cellViewT : cellViewS) instanceof (0, _elementViewMjs.ElementView);
        },
        /* EMBEDDING */ // Enables embedding. Re-parent the dragged element with elements under it and makes sure that
        // all links and elements are visible taken the level of embedding into account.
        embeddingMode: false,
        // Check whether to allow or disallow the element embedding while an element being translated.
        validateEmbedding: function(childView, parentView) {
            // by default all elements can be in relation child-parent
            return true;
        },
        // Check whether to allow or disallow an embedded element to be unembedded / to become a root.
        validateUnembedding: function(childView) {
            // by default all elements can become roots
            return true;
        },
        // Determines the way how a cell finds a suitable parent when it's dragged over the paper.
        // The cell with the highest z-index (visually on the top) will be chosen.
        findParentBy: "bbox",
        // If enabled only the element on the very front is taken into account for the embedding.
        // If disabled the elements under the dragged view are tested one by one
        // (from front to back) until a valid parent found.
        frontParentOnly: true,
        // Interactive flags. See online docs for the complete list of interactive flags.
        interactive: {
            labelMove: false
        },
        // When set to true the links can be pinned to the paper.
        // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };
        linkPinning: true,
        // Custom validation after an interaction with a link ends.
        // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)
        // (linkView, paper) => boolean
        allowLink: null,
        // Allowed number of mousemove events after which the pointerclick event will be still triggered.
        clickThreshold: 0,
        // Number of required mousemove events before the first pointermove event will be triggered.
        moveThreshold: 0,
        // Number of required mousemove events before a link is created out of the magnet.
        // Or string `onleave` so the link is created when the pointer leaves the magnet
        magnetThreshold: 0,
        // Rendering Options
        sorting: sortingTypes.EXACT,
        frozen: false,
        autoFreeze: false,
        // no docs yet
        onViewUpdate: function(view, flag, priority, opt, paper) {
            // Do not update connected links when:
            // 1. the view was just inserted (added to the graph and rendered)
            // 2. the view was just mounted (added back to the paper by viewport function)
            // 3. the change was marked as `isolate`.
            // 4. the view model was just removed from the graph
            if (flag & (view.FLAG_INSERT | view.FLAG_REMOVE) || opt.mounting || opt.isolate) return;
            paper.requestConnectedLinksUpdate(view, priority, opt);
        },
        // no docs yet
        onViewPostponed: function(view, flag, paper) {
            return paper.forcePostponedViewUpdate(view, flag);
        },
        beforeRender: null,
        afterRender: null,
        viewport: null,
        // Default namespaces
        cellViewNamespace: null,
        routerNamespace: null,
        connectorNamespace: null,
        highlighterNamespace: _indexMjs4,
        anchorNamespace: _indexMjs7,
        linkAnchorNamespace: _indexMjs5,
        connectionPointNamespace: _indexMjs6,
        overflow: false
    },
    events: {
        "dblclick": "pointerdblclick",
        "dbltap": "pointerdblclick",
        "contextmenu": "contextmenu",
        "mousedown": "pointerdown",
        "touchstart": "pointerdown",
        "mouseover": "mouseover",
        "mouseout": "mouseout",
        "mouseenter": "mouseenter",
        "mouseleave": "mouseleave",
        "wheel": "mousewheel",
        "mouseenter .joint-cell": "mouseenter",
        "mouseleave .joint-cell": "mouseleave",
        "mouseenter .joint-tools": "mouseenter",
        "mouseleave .joint-tools": "mouseleave",
        "dblclick .joint-cell [magnet]": "magnetpointerdblclick",
        "contextmenu .joint-cell [magnet]": "magnetcontextmenu",
        "mousedown .joint-link .label": "onlabel",
        "touchstart .joint-link .label": "onlabel",
        "dragstart .joint-cell image": "onImageDragStart" // firefox fix
    },
    documentEvents: {
        "mousemove": "pointermove",
        "touchmove": "pointermove",
        "mouseup": "pointerup",
        "touchend": "pointerup",
        "touchcancel": "pointerup"
    },
    svg: null,
    viewport: null,
    defs: null,
    tools: null,
    $background: null,
    layers: null,
    $grid: null,
    $document: null,
    // For storing the current transformation matrix (CTM) of the paper's viewport.
    _viewportMatrix: null,
    // For verifying whether the CTM is up-to-date. The viewport transform attribute
    // could have been manipulated directly.
    _viewportTransformString: null,
    // Updates data (priorities, unmounted views etc.)
    _updates: null,
    // Paper Layers
    _layers: null,
    SORT_DELAYING_BATCHES: [
        "add",
        "to-front",
        "to-back"
    ],
    UPDATE_DELAYING_BATCHES: [
        "translate"
    ],
    // If you interact with these elements,
    // the default interaction such as `element move` is prevented.
    FORM_CONTROL_TAG_NAMES: [
        "TEXTAREA",
        "INPUT",
        "BUTTON",
        "SELECT",
        "OPTION"
    ],
    // If you interact with these elements, the events are not propagated to the paper
    // i.e. paper events such as `element:pointerdown` are not triggered.
    GUARDED_TAG_NAMES: [
        // Guard <select> for consistency. When you click on it:
        // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open
        // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).
        //          on close. However, if you open and then close by clicking elsewhere on the page,
        //           no other event is triggered.
        // Safari: when you open it, it triggers `pointerdown`. That's it.
        "SELECT"
    ],
    MIN_SCALE: 1e-6,
    init: function() {
        const { options, el } = this;
        if (!options.cellViewNamespace) /* eslint-disable no-undef */ options.cellViewNamespace = typeof joint !== "undefined" && (0, _indexMjs1.has)(joint, "shapes") ? joint.shapes : null;
        const model = this.model = options.model || new (0, _graphMjs.Graph);
        // Layers (SVGGroups)
        this._layers = {};
        this.setGrid(options.drawGrid);
        this.cloneOptions();
        this.render();
        this._setDimensions();
        this.startListening();
        // Hash of all cell views.
        this._views = {};
        // Mouse wheel events buffer
        this._mw_evt_buffer = {
            event: null,
            deltas: []
        };
        // Reference to the paper owner document
        this.$document = (0, _jqueryDefault.default)(el.ownerDocument);
        // Render existing cells in the graph
        this.resetViews(model.attributes.cells.models);
        // Start the Rendering Loop
        if (!this.isFrozen() && this.isAsync()) this.updateViewsAsync();
    },
    _resetUpdates: function() {
        return this._updates = {
            id: null,
            priorities: [
                {},
                {},
                {}
            ],
            unmountedCids: [],
            mountedCids: [],
            unmounted: {},
            mounted: {},
            count: 0,
            keyFrozen: false,
            freezeKey: null,
            sort: false,
            disabled: false,
            idle: false
        };
    },
    startListening: function() {
        var model = this.model;
        this.listenTo(model, "add", this.onCellAdded).listenTo(model, "remove", this.onCellRemoved).listenTo(model, "change", this.onCellChange).listenTo(model, "reset", this.onGraphReset).listenTo(model, "sort", this.onGraphSort).listenTo(model, "batch:stop", this.onGraphBatchStop);
        this.on("cell:highlight", this.onCellHighlight).on("cell:unhighlight", this.onCellUnhighlight).on("scale translate", this.update);
    },
    onCellAdded: function(cell, _, opt) {
        var position = opt.position;
        if (this.isAsync() || !(0, _indexMjs1.isNumber)(position)) this.renderView(cell, opt);
        else {
            if (opt.maxPosition === position) this.freeze({
                key: "addCells"
            });
            this.renderView(cell, opt);
            if (position === 0) this.unfreeze({
                key: "addCells"
            });
        }
    },
    onCellRemoved: function(cell, _, opt) {
        const view = this.findViewByModel(cell);
        if (view) this.requestViewUpdate(view, view.FLAG_REMOVE, view.UPDATE_PRIORITY, opt);
    },
    onCellChange: function(cell, opt) {
        if (cell === this.model.attributes.cells) return;
        if (cell.hasChanged("z") && this.options.sorting === sortingTypes.APPROX) {
            const view = this.findViewByModel(cell);
            if (view) this.requestViewUpdate(view, view.FLAG_INSERT, view.UPDATE_PRIORITY, opt);
        }
    },
    onGraphReset: function(collection, opt) {
        this.resetLayers();
        this.resetViews(collection.models, opt);
    },
    onGraphSort: function() {
        if (this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;
        this.sortViews();
    },
    onGraphBatchStop: function(data) {
        if (this.isFrozen()) return;
        var name = data && data.batchName;
        var graph = this.model;
        if (!this.isAsync()) {
            var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;
            if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) this.updateViews(data);
        }
        var sortDelayingBatches = this.SORT_DELAYING_BATCHES;
        if (sortDelayingBatches.includes(name) && !graph.hasActiveBatch(sortDelayingBatches)) this.sortViews();
    },
    cloneOptions: function() {
        const { options } = this;
        const { defaultConnector, defaultRouter, defaultConnectionPoint, defaultAnchor, defaultLinkAnchor, origin, highlighting, cellViewNamespace, interactive } = options;
        // Default cellView namespace for ES5
        /* eslint-disable no-undef */ if (!cellViewNamespace && typeof joint !== "undefined" && (0, _indexMjs1.has)(joint, "shapes")) options.cellViewNamespace = joint.shapes;
        /* eslint-enable no-undef */ // Here if a function was provided, we can not clone it, as this would result in loosing the function.
        // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.
        if (!(0, _indexMjs1.isFunction)(defaultConnector)) options.defaultConnector = (0, _indexMjs1.cloneDeep)(defaultConnector);
        if (!(0, _indexMjs1.isFunction)(defaultRouter)) options.defaultRouter = (0, _indexMjs1.cloneDeep)(defaultRouter);
        if (!(0, _indexMjs1.isFunction)(defaultConnectionPoint)) options.defaultConnectionPoint = (0, _indexMjs1.cloneDeep)(defaultConnectionPoint);
        if (!(0, _indexMjs1.isFunction)(defaultAnchor)) options.defaultAnchor = (0, _indexMjs1.cloneDeep)(defaultAnchor);
        if (!(0, _indexMjs1.isFunction)(defaultLinkAnchor)) options.defaultLinkAnchor = (0, _indexMjs1.cloneDeep)(defaultLinkAnchor);
        if ((0, _indexMjs1.isPlainObject)(interactive)) options.interactive = (0, _indexMjs1.assign)({}, interactive);
        if ((0, _indexMjs1.isPlainObject)(highlighting)) // Return the default highlighting options into the user specified options.
        options.highlighting = (0, _indexMjs1.defaultsDeep)({}, highlighting, defaultHighlighting);
        options.origin = (0, _indexMjs1.assign)({}, origin);
    },
    children: function() {
        var ns = (0, _indexMjsDefault.default).namespace;
        return [
            {
                namespaceURI: ns.xhtml,
                tagName: "div",
                className: (0, _indexMjs1.addClassNamePrefix)("paper-background"),
                selector: "background"
            },
            {
                namespaceURI: ns.xhtml,
                tagName: "div",
                className: (0, _indexMjs1.addClassNamePrefix)("paper-grid"),
                selector: "grid"
            },
            {
                namespaceURI: ns.svg,
                tagName: "svg",
                attributes: {
                    "width": "100%",
                    "height": "100%",
                    "xmlns:xlink": ns.xlink
                },
                selector: "svg",
                children: [
                    {
                        // Append `<defs>` element to the SVG document. This is useful for filters and gradients.
                        // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).
                        tagName: "defs",
                        selector: "defs"
                    },
                    {
                        tagName: "g",
                        className: (0, _indexMjs1.addClassNamePrefix)("layers"),
                        selector: "layers"
                    }
                ]
            }
        ];
    },
    hasLayerView (layerName) {
        return layerName in this._layers;
    },
    getLayerView (layerName) {
        const { _layers } = this;
        if (layerName in _layers) return _layers[layerName];
        throw new Error(`dia.Paper: Unknown layer "${layerName}"`);
    },
    getLayerNode (layerName) {
        return this.getLayerView(layerName).el;
    },
    render: function() {
        this.renderChildren();
        const { childNodes, options } = this;
        const { svg, defs, layers, background, grid } = childNodes;
        svg.style.overflow = options.overflow ? "visible" : "hidden";
        this.svg = svg;
        this.defs = defs;
        this.layers = layers;
        this.$background = (0, _jqueryDefault.default)(background);
        this.$grid = (0, _jqueryDefault.default)(grid);
        this.renderLayers();
        (0, _indexMjsDefault.default).ensureId(svg);
        if (options.background) this.drawBackground(options.background);
        if (options.drawGrid) this.drawGrid();
        return this;
    },
    renderLayers: function(layers = defaultLayers) {
        this.removeLayers();
        // TODO: Layers to be read from the graph `layers` attribute
        layers.forEach(({ name, sorted })=>{
            const layerView = new (0, _paperLayerMjs.PaperLayer)({
                name
            });
            this.layers.appendChild(layerView.el);
            this._layers[name] = layerView;
        });
        // Throws an exception if doesn't exist
        const cellsLayerView = this.getLayerView((0, _paperLayerMjs.LayersNames).CELLS);
        const toolsLayerView = this.getLayerView((0, _paperLayerMjs.LayersNames).TOOLS);
        const labelsLayerView = this.getLayerView((0, _paperLayerMjs.LayersNames).LABELS);
        // backwards compatibility
        this.tools = toolsLayerView.el;
        this.cells = this.viewport = cellsLayerView.el;
        // user-select: none;
        cellsLayerView.vel.addClass((0, _indexMjs1.addClassNamePrefix)("viewport"));
        labelsLayerView.vel.addClass((0, _indexMjs1.addClassNamePrefix)("viewport"));
    },
    removeLayers: function() {
        const { _layers } = this;
        Object.keys(_layers).forEach((name)=>{
            _layers[name].remove();
            delete _layers[name];
        });
    },
    resetLayers: function() {
        const { _layers } = this;
        Object.keys(_layers).forEach((name)=>{
            _layers[name].removePivots();
        });
    },
    update: function() {
        if (this.options.drawGrid) this.drawGrid();
        if (this._background) this.updateBackgroundImage(this._background);
        return this;
    },
    matrix: function(ctm) {
        var viewport = this.layers;
        // Getter:
        if (ctm === undefined) {
            var transformString = viewport.getAttribute("transform");
            if ((this._viewportTransformString || null) === transformString) // It's ok to return the cached matrix. The transform attribute has not changed since
            // the matrix was stored.
            ctm = this._viewportMatrix;
            else {
                // The viewport transform attribute has changed. Measure the matrix and cache again.
                ctm = viewport.getCTM();
                this._viewportMatrix = ctm;
                this._viewportTransformString = transformString;
            }
            // Clone the cached current transformation matrix.
            // If no matrix previously stored the identity matrix is returned.
            return (0, _indexMjsDefault.default).createSVGMatrix(ctm);
        }
        // Setter:
        ctm = (0, _indexMjsDefault.default).createSVGMatrix(ctm);
        var ctmString = (0, _indexMjsDefault.default).matrixToTransformString(ctm);
        viewport.setAttribute("transform", ctmString);
        this._viewportMatrix = ctm;
        this._viewportTransformString = viewport.getAttribute("transform");
        return this;
    },
    clientMatrix: function() {
        return (0, _indexMjsDefault.default).createSVGMatrix(this.cells.getScreenCTM());
    },
    requestConnectedLinksUpdate: function(view, priority, opt) {
        if (view instanceof (0, _cellViewMjs.CellView)) {
            var model = view.model;
            var links = this.model.getConnectedLinks(model);
            for(var j = 0, n = links.length; j < n; j++){
                var link = links[j];
                var linkView = this.findViewByModel(link);
                if (!linkView) continue;
                var flagLabels = [
                    "UPDATE"
                ];
                if (link.getTargetCell() === model) flagLabels.push("TARGET");
                if (link.getSourceCell() === model) flagLabels.push("SOURCE");
                var nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);
                this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);
            }
        }
    },
    forcePostponedViewUpdate: function(view, flag) {
        if (!view || !(view instanceof (0, _cellViewMjs.CellView))) return false;
        var model = view.model;
        if (model.isElement()) return false;
        if ((flag & view.getFlag([
            "SOURCE",
            "TARGET"
        ])) === 0) {
            var dumpOptions = {
                silent: true
            };
            // LinkView is waiting for the target or the source cellView to be rendered
            // This can happen when the cells are not in the viewport.
            var sourceFlag = 0;
            var sourceView = this.findViewByModel(model.getSourceCell());
            if (sourceView && !this.isViewMounted(sourceView)) {
                sourceFlag = this.dumpView(sourceView, dumpOptions);
                view.updateEndMagnet("source");
            }
            var targetFlag = 0;
            var targetView = this.findViewByModel(model.getTargetCell());
            if (targetView && !this.isViewMounted(targetView)) {
                targetFlag = this.dumpView(targetView, dumpOptions);
                view.updateEndMagnet("target");
            }
            if (sourceFlag === 0 && targetFlag === 0) // If leftover flag is 0, all view updates were done.
            return !this.dumpView(view, dumpOptions);
        }
        return false;
    },
    requestViewUpdate: function(view, flag, priority, opt) {
        opt || (opt = {});
        this.scheduleViewUpdate(view, flag, priority, opt);
        var isAsync = this.isAsync();
        if (this.isFrozen() || isAsync && opt.async !== false) return;
        if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;
        var stats = this.updateViews(opt);
        if (isAsync) this.notifyAfterRender(stats, opt);
    },
    scheduleViewUpdate: function(view, type, priority, opt) {
        const { _updates: updates, options } = this;
        if (updates.idle) {
            if (options.autoFreeze) {
                updates.idle = false;
                this.unfreeze();
            }
        }
        const { FLAG_REMOVE, FLAG_INSERT, UPDATE_PRIORITY, cid } = view;
        let priorityUpdates = updates.priorities[priority];
        if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};
        // Move higher priority updates to this priority
        if (priority > UPDATE_PRIORITY) // Not the default priority for this view. It's most likely a link view
        // connected to another link view, which triggered the update.
        // TODO: If there is an update scheduled with a lower priority already, we should
        // change the requested priority to the lowest one. Does not seem to be critical
        // right now, as it "only" results in multiple updates on the same view.
        for(let i = priority - 1; i >= UPDATE_PRIORITY; i--){
            const prevPriorityUpdates = updates.priorities[i];
            if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;
            priorityUpdates[cid] |= prevPriorityUpdates[cid];
            delete prevPriorityUpdates[cid];
        }
        let currentType = priorityUpdates[cid] || 0;
        // Prevent cycling
        if ((currentType & type) === type) return;
        if (!currentType) updates.count++;
        if (type & FLAG_REMOVE && currentType & FLAG_INSERT) // When a view is removed we need to remove the insert flag as this is a reinsert
        priorityUpdates[cid] ^= FLAG_INSERT;
        else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) // When a view is added we need to remove the remove flag as this is view was previously removed
        priorityUpdates[cid] ^= FLAG_REMOVE;
        priorityUpdates[cid] |= type;
        const viewUpdateFn = options.onViewUpdate;
        if (typeof viewUpdateFn === "function") viewUpdateFn.call(this, view, type, priority, opt || {}, this);
    },
    dumpViewUpdate: function(view) {
        if (!view) return 0;
        var updates = this._updates;
        var cid = view.cid;
        var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];
        var flag = this.registerMountedView(view) | priorityUpdates[cid];
        delete priorityUpdates[cid];
        return flag;
    },
    dumpView: function(view, opt = {}) {
        const flag = this.dumpViewUpdate(view);
        if (!flag) return 0;
        const shouldNotify = !opt.silent;
        if (shouldNotify) this.notifyBeforeRender(opt);
        const leftover = this.updateView(view, flag, opt);
        if (shouldNotify) {
            const stats = {
                updated: 1,
                priority: view.UPDATE_PRIORITY
            };
            this.notifyAfterRender(stats, opt);
        }
        return leftover;
    },
    updateView: function(view, flag, opt) {
        if (!view) return 0;
        const { FLAG_REMOVE, FLAG_INSERT, FLAG_INIT, model } = view;
        if (view instanceof (0, _cellViewMjs.CellView)) {
            if (flag & FLAG_REMOVE) {
                this.removeView(model);
                return 0;
            }
            if (flag & FLAG_INSERT) {
                const isInitialInsert = !!(flag & FLAG_INIT);
                if (isInitialInsert) flag ^= FLAG_INIT;
                this.insertView(view, isInitialInsert);
                flag ^= FLAG_INSERT;
            }
        }
        if (!flag) return 0;
        return view.confirmUpdate(flag, opt || {});
    },
    requireView: function(model, opt) {
        var view = this.findViewByModel(model);
        if (!view) return null;
        this.dumpView(view, opt);
        return view;
    },
    registerUnmountedView: function(view) {
        var cid = view.cid;
        var updates = this._updates;
        if (cid in updates.unmounted) return 0;
        var flag = updates.unmounted[cid] |= view.FLAG_INSERT;
        updates.unmountedCids.push(cid);
        delete updates.mounted[cid];
        return flag;
    },
    registerMountedView: function(view) {
        var cid = view.cid;
        var updates = this._updates;
        if (cid in updates.mounted) return 0;
        updates.mounted[cid] = true;
        updates.mountedCids.push(cid);
        var flag = updates.unmounted[cid] || 0;
        delete updates.unmounted[cid];
        return flag;
    },
    isViewMounted: function(view) {
        if (!view) return false;
        var cid = view.cid;
        var updates = this._updates;
        return cid in updates.mounted;
    },
    dumpViews: function(opt) {
        var passingOpt = (0, _indexMjs1.defaults)({}, opt, {
            viewport: null
        });
        this.checkViewport(passingOpt);
        this.updateViews(passingOpt);
    },
    // Synchronous views update
    updateViews: function(opt) {
        this.notifyBeforeRender(opt);
        let batchStats;
        let updateCount = 0;
        let batchCount = 0;
        let priority = MIN_PRIORITY;
        do {
            batchCount++;
            batchStats = this.updateViewsBatch(opt);
            updateCount += batchStats.updated;
            priority = Math.min(batchStats.priority, priority);
        }while (!batchStats.empty);
        const stats = {
            updated: updateCount,
            batches: batchCount,
            priority
        };
        this.notifyAfterRender(stats, opt);
        return stats;
    },
    hasScheduledUpdates: function() {
        const priorities = this._updates.priorities;
        const priorityIndexes = Object.keys(priorities); // convert priorities to a dense array
        let i = priorityIndexes.length;
        while(i > 0 && i--){
            // a faster way how to check if an object is empty
            for(let _key in priorities[priorityIndexes[i]])return true;
        }
        return false;
    },
    updateViewsAsync: function(opt, data) {
        opt || (opt = {});
        data || (data = {
            processed: 0,
            priority: MIN_PRIORITY
        });
        const { _updates: updates, options } = this;
        const id = updates.id;
        if (id) {
            (0, _indexMjs1.cancelFrame)(id);
            if (data.processed === 0 && this.hasScheduledUpdates()) this.notifyBeforeRender(opt);
            const stats = this.updateViewsBatch(opt);
            const passingOpt = (0, _indexMjs1.defaults)({}, opt, {
                mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,
                unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted
            });
            const checkStats = this.checkViewport(passingOpt);
            const unmountCount = checkStats.unmounted;
            const mountCount = checkStats.mounted;
            let processed = data.processed;
            const total = updates.count;
            if (stats.updated > 0) {
                // Some updates have been just processed
                processed += stats.updated + stats.unmounted;
                stats.processed = processed;
                data.priority = Math.min(stats.priority, data.priority);
                if (stats.empty && mountCount === 0) {
                    stats.unmounted += unmountCount;
                    stats.mounted += mountCount;
                    stats.priority = data.priority;
                    this.notifyAfterRender(stats, opt);
                    data.processed = 0;
                    data.priority = MIN_PRIORITY;
                    updates.count = 0;
                } else data.processed = processed;
            } else {
                if (!updates.idle) {
                    if (options.autoFreeze) {
                        this.freeze();
                        updates.idle = true;
                        this.trigger("render:idle", opt);
                    }
                }
            }
            // Progress callback
            const progressFn = opt.progress;
            if (total && typeof progressFn === "function") progressFn.call(this, stats.empty, processed, total, stats, this);
            // The current frame could have been canceled in a callback
            if (updates.id !== id) return;
        }
        if (updates.disabled) throw new Error("dia.Paper: can not unfreeze the paper after it was removed");
        updates.id = (0, _indexMjs1.nextFrame)(this.updateViewsAsync, this, opt, data);
    },
    notifyBeforeRender: function(opt = {}) {
        let beforeFn = opt.beforeRender;
        if (typeof beforeFn !== "function") {
            beforeFn = this.options.beforeRender;
            if (typeof beforeFn !== "function") return;
        }
        beforeFn.call(this, opt, this);
    },
    notifyAfterRender: function(stats, opt = {}) {
        let afterFn = opt.afterRender;
        if (typeof afterFn !== "function") afterFn = this.options.afterRender;
        if (typeof afterFn === "function") afterFn.call(this, stats, opt, this);
        this.trigger("render:done", stats, opt);
    },
    updateViewsBatch: function(opt) {
        opt || (opt = {});
        var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;
        var updates = this._updates;
        var updateCount = 0;
        var postponeCount = 0;
        var unmountCount = 0;
        var mountCount = 0;
        var maxPriority = MIN_PRIORITY;
        var empty = true;
        var options = this.options;
        var priorities = updates.priorities;
        var viewportFn = "viewport" in opt ? opt.viewport : options.viewport;
        if (typeof viewportFn !== "function") viewportFn = null;
        var postponeViewFn = options.onViewPostponed;
        if (typeof postponeViewFn !== "function") postponeViewFn = null;
        var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array
        main: for(var i = 0, n = priorityIndexes.length; i < n; i++){
            var priority = +priorityIndexes[i];
            var priorityUpdates = priorities[priority];
            for(var cid in priorityUpdates){
                if (updateCount >= batchSize) {
                    empty = false;
                    break main;
                }
                var view = (0, _indexMjs3.views)[cid];
                if (!view) {
                    // This should not occur
                    delete priorityUpdates[cid];
                    continue;
                }
                var currentFlag = priorityUpdates[cid];
                if ((currentFlag & view.FLAG_REMOVE) === 0) {
                    // We should never check a view for viewport if we are about to remove the view
                    var isDetached = cid in updates.unmounted;
                    if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, !isDetached, this)) {
                        // Unmount View
                        if (!isDetached) {
                            this.registerUnmountedView(view);
                            this.detachView(view);
                        }
                        updates.unmounted[cid] |= currentFlag;
                        delete priorityUpdates[cid];
                        unmountCount++;
                        continue;
                    }
                    // Mount View
                    if (isDetached) {
                        currentFlag |= view.FLAG_INSERT;
                        mountCount++;
                    }
                    currentFlag |= this.registerMountedView(view);
                }
                var leftoverFlag = this.updateView(view, currentFlag, opt);
                if (leftoverFlag > 0) {
                    // View update has not finished completely
                    priorityUpdates[cid] = leftoverFlag;
                    if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {
                        postponeCount++;
                        empty = false;
                        continue;
                    }
                }
                if (maxPriority > priority) maxPriority = priority;
                updateCount++;
                delete priorityUpdates[cid];
            }
        }
        return {
            priority: maxPriority,
            updated: updateCount,
            postponed: postponeCount,
            unmounted: unmountCount,
            mounted: mountCount,
            empty: empty
        };
    },
    getUnmountedViews: function() {
        const updates = this._updates;
        const unmountedCids = Object.keys(updates.unmounted);
        const n = unmountedCids.length;
        const unmountedViews = new Array(n);
        for(var i = 0; i < n; i++)unmountedViews[i] = (0, _indexMjs3.views)[unmountedCids[i]];
        return unmountedViews;
    },
    getMountedViews: function() {
        const updates = this._updates;
        const mountedCids = Object.keys(updates.mounted);
        const n = mountedCids.length;
        const mountedViews = new Array(n);
        for(var i = 0; i < n; i++)mountedViews[i] = (0, _indexMjs3.views)[mountedCids[i]];
        return mountedViews;
    },
    checkUnmountedViews: function(viewportFn, opt) {
        opt || (opt = {});
        var mountCount = 0;
        if (typeof viewportFn !== "function") viewportFn = null;
        var batchSize = "mountBatchSize" in opt ? opt.mountBatchSize : Infinity;
        var updates = this._updates;
        var unmountedCids = updates.unmountedCids;
        var unmounted = updates.unmounted;
        for(var i = 0, n = Math.min(unmountedCids.length, batchSize); i < n; i++){
            var cid = unmountedCids[i];
            if (!(cid in unmounted)) continue;
            var view = (0, _indexMjs3.views)[cid];
            if (!view) continue;
            if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, false, this)) {
                // Push at the end of all unmounted ids, so this can be check later again
                unmountedCids.push(cid);
                continue;
            }
            mountCount++;
            var flag = this.registerMountedView(view);
            if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, {
                mounting: true
            });
        }
        // Get rid of views, that have been mounted
        unmountedCids.splice(0, i);
        return mountCount;
    },
    checkMountedViews: function(viewportFn, opt) {
        opt || (opt = {});
        var unmountCount = 0;
        if (typeof viewportFn !== "function") return unmountCount;
        var batchSize = "unmountBatchSize" in opt ? opt.unmountBatchSize : Infinity;
        var updates = this._updates;
        var mountedCids = updates.mountedCids;
        var mounted = updates.mounted;
        for(var i = 0, n = Math.min(mountedCids.length, batchSize); i < n; i++){
            var cid = mountedCids[i];
            if (!(cid in mounted)) continue;
            var view = (0, _indexMjs3.views)[cid];
            if (!view) continue;
            if (!view.DETACHABLE || viewportFn.call(this, view, true, this)) {
                // Push at the end of all mounted ids, so this can be check later again
                mountedCids.push(cid);
                continue;
            }
            unmountCount++;
            var flag = this.registerUnmountedView(view);
            if (flag) this.detachView(view);
        }
        // Get rid of views, that have been unmounted
        mountedCids.splice(0, i);
        return unmountCount;
    },
    checkViewVisibility: function(cellView, opt = {}) {
        let viewportFn = "viewport" in opt ? opt.viewport : this.options.viewport;
        if (typeof viewportFn !== "function") viewportFn = null;
        const updates = this._updates;
        const { mounted, unmounted } = updates;
        const visible = !cellView.DETACHABLE || !viewportFn || viewportFn.call(this, cellView, false, this);
        let isUnmounted = false;
        let isMounted = false;
        if (cellView.cid in mounted && !visible) {
            const flag = this.registerUnmountedView(cellView);
            if (flag) this.detachView(cellView);
            const i = updates.mountedCids.indexOf(cellView.cid);
            updates.mountedCids.splice(i, 1);
            isUnmounted = true;
        }
        if (!isUnmounted && cellView.cid in unmounted && visible) {
            const i = updates.unmountedCids.indexOf(cellView.cid);
            updates.unmountedCids.splice(i, 1);
            var flag = this.registerMountedView(cellView);
            if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, {
                mounting: true
            });
            isMounted = true;
        }
        return {
            mounted: isMounted ? 1 : 0,
            unmounted: isUnmounted ? 1 : 0
        };
    },
    checkViewport: function(opt) {
        var passingOpt = (0, _indexMjs1.defaults)({}, opt, {
            mountBatchSize: Infinity,
            unmountBatchSize: Infinity
        });
        var viewportFn = "viewport" in passingOpt ? passingOpt.viewport : this.options.viewport;
        var unmountedCount = this.checkMountedViews(viewportFn, passingOpt);
        if (unmountedCount > 0) {
            // Do not check views, that have been just unmounted and pushed at the end of the cids array
            var unmountedCids = this._updates.unmountedCids;
            passingOpt.mountBatchSize = Math.min(unmountedCids.length - unmountedCount, passingOpt.mountBatchSize);
        }
        var mountedCount = this.checkUnmountedViews(viewportFn, passingOpt);
        return {
            mounted: mountedCount,
            unmounted: unmountedCount
        };
    },
    freeze: function(opt) {
        opt || (opt = {});
        var updates = this._updates;
        var key = opt.key;
        var isFrozen = this.options.frozen;
        var freezeKey = updates.freezeKey;
        if (key && key !== freezeKey) {
            // key passed, but the paper is already freezed with another key
            if (isFrozen && freezeKey) return;
            updates.freezeKey = key;
            updates.keyFrozen = isFrozen;
        }
        this.options.frozen = true;
        var id = updates.id;
        updates.id = null;
        if (this.isAsync() && id) (0, _indexMjs1.cancelFrame)(id);
    },
    unfreeze: function(opt) {
        opt || (opt = {});
        var updates = this._updates;
        var key = opt.key;
        var freezeKey = updates.freezeKey;
        // key passed, but the paper is already freezed with another key
        if (key && freezeKey && key !== freezeKey) return;
        updates.freezeKey = null;
        // key passed, but the paper is already freezed
        if (key && key === freezeKey && updates.keyFrozen) return;
        if (this.isAsync()) {
            this.freeze();
            this.updateViewsAsync(opt);
        } else this.updateViews(opt);
        this.options.frozen = updates.keyFrozen = false;
        if (updates.sort) {
            this.sortViews();
            updates.sort = false;
        }
    },
    isAsync: function() {
        return !!this.options.async;
    },
    isFrozen: function() {
        return !!this.options.frozen;
    },
    isExactSorting: function() {
        return this.options.sorting === sortingTypes.EXACT;
    },
    onRemove: function() {
        this.freeze();
        this._updates.disabled = true;
        //clean up all DOM elements/views to prevent memory leaks
        this.removeLayers();
        this.removeViews();
    },
    getComputedSize: function() {
        var options = this.options;
        var w = options.width;
        var h = options.height;
        if (!(0, _indexMjs1.isNumber)(w)) w = this.el.clientWidth;
        if (!(0, _indexMjs1.isNumber)(h)) h = this.el.clientHeight;
        return {
            width: w,
            height: h
        };
    },
    setDimensions: function(width, height) {
        const { options } = this;
        const { width: currentWidth, height: currentHeight } = options;
        let w = width === undefined ? currentWidth : width;
        let h = height === undefined ? currentHeight : height;
        if (currentWidth === w && currentHeight === h) return;
        options.width = w;
        options.height = h;
        this._setDimensions();
        const computedSize = this.getComputedSize();
        this.trigger("resize", computedSize.width, computedSize.height);
    },
    _setDimensions: function() {
        const { options } = this;
        let w = options.width;
        let h = options.height;
        if ((0, _indexMjs1.isNumber)(w)) w = Math.round(w);
        if ((0, _indexMjs1.isNumber)(h)) h = Math.round(h);
        this.$el.css({
            width: w === null ? "" : w,
            height: h === null ? "" : h
        });
    },
    setOrigin: function(ox, oy) {
        return this.translate(ox || 0, oy || 0);
    },
    // Expand/shrink the paper to fit the content.
    // Alternatively signature function(opt)
    fitToContent: function(gridWidth, gridHeight, padding, opt) {
        if ((0, _indexMjs1.isObject)(gridWidth)) // first parameter is an option object
        opt = gridWidth;
        else // Support for a deprecated signature
        opt = (0, _indexMjs1.assign)({
            gridWidth,
            gridHeight,
            padding
        }, opt);
        const { x, y, width, height } = this.getFitToContentArea(opt);
        const { sx, sy } = this.scale();
        this.setOrigin(-x * sx, -y * sy);
        this.setDimensions(width * sx, height * sy);
        return new (0, _indexMjs2.Rect)(x, y, width, height);
    },
    getFitToContentArea: function(opt = {}) {
        // Calculate the paper size to accommodate all the graph's elements.
        const gridWidth = opt.gridWidth || 1;
        const gridHeight = opt.gridHeight || 1;
        const padding = (0, _indexMjs1.normalizeSides)(opt.padding || 0);
        const minWidth = Math.max(opt.minWidth || 0, gridWidth);
        const minHeight = Math.max(opt.minHeight || 0, gridHeight);
        const maxWidth = opt.maxWidth || Number.MAX_VALUE;
        const maxHeight = opt.maxHeight || Number.MAX_VALUE;
        const newOrigin = opt.allowNewOrigin;
        const area = "contentArea" in opt ? new (0, _indexMjs2.Rect)(opt.contentArea) : this.getContentArea(opt);
        const { sx, sy } = this.scale();
        area.x *= sx;
        area.y *= sy;
        area.width *= sx;
        area.height *= sy;
        let calcWidth = Math.ceil((area.width + area.x) / gridWidth);
        let calcHeight = Math.ceil((area.height + area.y) / gridHeight);
        if (!opt.allowNegativeBottomRight) {
            calcWidth = Math.max(calcWidth, 1);
            calcHeight = Math.max(calcHeight, 1);
        }
        calcWidth *= gridWidth;
        calcHeight *= gridHeight;
        let tx = 0;
        if (newOrigin === "negative" && area.x < 0 || newOrigin === "positive" && area.x >= 0 || newOrigin === "any") {
            tx = Math.ceil(-area.x / gridWidth) * gridWidth;
            tx += padding.left;
            calcWidth += tx;
        }
        let ty = 0;
        if (newOrigin === "negative" && area.y < 0 || newOrigin === "positive" && area.y >= 0 || newOrigin === "any") {
            ty = Math.ceil(-area.y / gridHeight) * gridHeight;
            ty += padding.top;
            calcHeight += ty;
        }
        calcWidth += padding.right;
        calcHeight += padding.bottom;
        // Make sure the resulting width and height are greater than minimum.
        calcWidth = Math.max(calcWidth, minWidth);
        calcHeight = Math.max(calcHeight, minHeight);
        // Make sure the resulting width and height are lesser than maximum.
        calcWidth = Math.min(calcWidth, maxWidth);
        calcHeight = Math.min(calcHeight, maxHeight);
        return new (0, _indexMjs2.Rect)(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);
    },
    transformToFitContent: function(opt) {
        opt || (opt = {});
        let contentBBox, contentLocalOrigin;
        if ("contentArea" in opt) {
            const contentArea = opt.contentArea;
            contentBBox = this.localToPaperRect(contentArea);
            contentLocalOrigin = new (0, _indexMjs2.Point)(contentArea);
        } else {
            contentBBox = this.getContentBBox(opt);
            contentLocalOrigin = this.paperToLocalPoint(contentBBox);
        }
        if (!contentBBox.width || !contentBBox.height) return;
        (0, _indexMjs1.defaults)(opt, {
            padding: 0,
            preserveAspectRatio: true,
            scaleGrid: null,
            minScale: 0,
            maxScale: Number.MAX_VALUE,
            verticalAlign: "top",
            horizontalAlign: "left"
        });
        const padding = (0, _indexMjs1.normalizeSides)(opt.padding);
        const minScaleX = opt.minScaleX || opt.minScale;
        const maxScaleX = opt.maxScaleX || opt.maxScale;
        const minScaleY = opt.minScaleY || opt.minScale;
        const maxScaleY = opt.maxScaleY || opt.maxScale;
        let fittingBBox;
        if (opt.fittingBBox) fittingBBox = opt.fittingBBox;
        else {
            const currentTranslate = this.translate();
            const computedSize = this.getComputedSize();
            fittingBBox = {
                x: currentTranslate.tx,
                y: currentTranslate.ty,
                width: computedSize.width,
                height: computedSize.height
            };
        }
        fittingBBox = new (0, _indexMjs2.Rect)(fittingBBox).moveAndExpand({
            x: padding.left,
            y: padding.top,
            width: -padding.left - padding.right,
            height: -padding.top - padding.bottom
        });
        const currentScale = this.scale();
        let newSx = fittingBBox.width / contentBBox.width * currentScale.sx;
        let newSy = fittingBBox.height / contentBBox.height * currentScale.sy;
        if (opt.preserveAspectRatio) newSx = newSy = Math.min(newSx, newSy);
        // snap scale to a grid
        if (opt.scaleGrid) {
            const gridSize = opt.scaleGrid;
            newSx = gridSize * Math.floor(newSx / gridSize);
            newSy = gridSize * Math.floor(newSy / gridSize);
        }
        // scale min/max boundaries
        newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));
        newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));
        const scaleDiff = {
            x: newSx / currentScale.sx,
            y: newSy / currentScale.sy
        };
        const origin = this.options.origin;
        let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - origin.x;
        let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - origin.y;
        switch(opt.verticalAlign){
            case "middle":
                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;
                break;
            case "bottom":
                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);
                break;
            case "top":
            default:
                break;
        }
        switch(opt.horizontalAlign){
            case "middle":
                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;
                break;
            case "right":
                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);
                break;
            case "left":
            default:
                break;
        }
        this.scale(newSx, newSy);
        this.translate(newOx, newOy);
    },
    scaleContentToFit: function(opt) {
        this.transformToFitContent(opt);
    },
    // Return the dimensions of the content area in local units (without transformations).
    getContentArea: function(opt) {
        if (opt && opt.useModelGeometry) return this.model.getBBox() || new (0, _indexMjs2.Rect)();
        return (0, _indexMjsDefault.default)(this.cells).getBBox();
    },
    // Return the dimensions of the content bbox in the paper units (as it appears on screen).
    getContentBBox: function(opt) {
        return this.localToPaperRect(this.getContentArea(opt));
    },
    // Returns a geometry rectangle representing the entire
    // paper area (coordinates from the left paper border to the right one
    // and the top border to the bottom one).
    getArea: function() {
        return this.paperToLocalRect(this.getComputedSize());
    },
    getRestrictedArea: function(...args) {
        const { restrictTranslate } = this.options;
        let restrictedArea;
        if ((0, _indexMjs1.isFunction)(restrictTranslate)) // A method returning a bounding box
        restrictedArea = restrictTranslate.apply(this, args);
        else if (restrictTranslate === true) // The paper area
        restrictedArea = this.getArea();
        else if (!restrictTranslate) // falsy value
        restrictedArea = null;
        else // any other value
        restrictedArea = new (0, _indexMjs2.Rect)(restrictTranslate);
        return restrictedArea;
    },
    createViewForModel: function(cell) {
        const { options } = this;
        // A class taken from the paper options.
        var optionalViewClass;
        // A default basic class (either dia.ElementView or dia.LinkView)
        var defaultViewClass;
        // A special class defined for this model in the corresponding namespace.
        // e.g. joint.shapes.basic.Rect searches for joint.shapes.basic.RectView
        var namespace = options.cellViewNamespace;
        var type = cell.get("type") + "View";
        var namespaceViewClass = (0, _indexMjs1.getByPath)(namespace, type, ".");
        if (cell.isLink()) {
            optionalViewClass = options.linkView;
            defaultViewClass = (0, _linkViewMjs.LinkView);
        } else {
            optionalViewClass = options.elementView;
            defaultViewClass = (0, _elementViewMjs.ElementView);
        }
        // a) the paper options view is a class (deprecated)
        //  1. search the namespace for a view
        //  2. if no view was found, use view from the paper options
        // b) the paper options view is a function
        //  1. call the function from the paper options
        //  2. if no view was return, search the namespace for a view
        //  3. if no view was found, use the default
        var ViewClass = optionalViewClass.prototype instanceof (0, _backboneDefault.default).View ? namespaceViewClass || optionalViewClass : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;
        return new ViewClass({
            model: cell,
            interactive: options.interactive,
            labelsLayer: options.labelsLayer === true ? (0, _paperLayerMjs.LayersNames).LABELS : options.labelsLayer
        });
    },
    removeView: function(cell) {
        const { id } = cell;
        const { _views, _updates } = this;
        const view = _views[id];
        if (view) {
            var { cid } = view;
            const { mounted, unmounted } = _updates;
            view.remove();
            delete _views[id];
            delete mounted[cid];
            delete unmounted[cid];
        }
        return view;
    },
    renderView: function(cell, opt) {
        const { id } = cell;
        const views = this._views;
        let view, flag;
        let create = true;
        if (id in views) {
            view = views[id];
            if (view.model === cell) {
                flag = view.FLAG_INSERT;
                create = false;
            } else // The view for this `id` already exist.
            // The cell is a new instance of the model with identical id
            // We simply remove the existing view and create a new one
            this.removeView(cell);
        }
        if (create) {
            view = views[id] = this.createViewForModel(cell);
            view.paper = this;
            flag = this.registerUnmountedView(view) | this.FLAG_INIT | view.getFlag((0, _indexMjs1.result)(view, "initFlag"));
        }
        this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);
        return view;
    },
    onImageDragStart: function() {
        // This is the only way to prevent image dragging in Firefox that works.
        // Setting -moz-user-select: none, draggable="false" attribute or user-drag: none didn't help.
        return false;
    },
    resetViews: function(cells, opt) {
        opt || (opt = {});
        cells || (cells = []);
        this._resetUpdates();
        // clearing views removes any event listeners
        this.removeViews();
        // Allows to unfreeze normally while in the idle state using autoFreeze option
        const key = this.options.autoFreeze ? null : "reset";
        this.freeze({
            key
        });
        for(var i = 0, n = cells.length; i < n; i++)this.renderView(cells[i], opt);
        this.unfreeze({
            key
        });
        this.sortViews();
    },
    removeViews: function() {
        (0, _indexMjs1.invoke)(this._views, "remove");
        this._views = {};
    },
    sortViews: function() {
        if (!this.isExactSorting()) // noop
        return;
        if (this.isFrozen()) {
            // sort views once unfrozen
            this._updates.sort = true;
            return;
        }
        this.sortViewsExact();
    },
    sortViewsExact: function() {
        // Run insertion sort algorithm in order to efficiently sort DOM elements according to their
        // associated model `z` attribute.
        var $cells = (0, _jqueryDefault.default)(this.cells).children("[model-id]");
        var cells = this.model.get("cells");
        (0, _indexMjs1.sortElements)($cells, function(a, b) {
            var cellA = cells.get(a.getAttribute("model-id"));
            var cellB = cells.get(b.getAttribute("model-id"));
            var zA = cellA.attributes.z || 0;
            var zB = cellB.attributes.z || 0;
            return zA === zB ? 0 : zA < zB ? -1 : 1;
        });
    },
    insertView: function(view, isInitialInsert) {
        const layerView = this.getLayerView((0, _paperLayerMjs.LayersNames).CELLS);
        const { el, model } = view;
        switch(this.options.sorting){
            case sortingTypes.APPROX:
                layerView.insertSortedNode(el, model.get("z"));
                break;
            case sortingTypes.EXACT:
            default:
                layerView.insertNode(el);
                break;
        }
        view.onMount(isInitialInsert);
    },
    detachView (view) {
        view.unmount();
        view.onDetach();
    },
    scale: function(sx, sy, ox, oy) {
        // getter
        if (sx === undefined) return (0, _indexMjsDefault.default).matrixToScale(this.matrix());
        // setter
        if (sy === undefined) sy = sx;
        if (ox === undefined) {
            ox = 0;
            oy = 0;
        }
        var translate = this.translate();
        if (ox || oy || translate.tx || translate.ty) {
            var newTx = translate.tx - ox * (sx - 1);
            var newTy = translate.ty - oy * (sy - 1);
            this.translate(newTx, newTy);
        }
        sx = Math.max(sx || 0, this.MIN_SCALE);
        sy = Math.max(sy || 0, this.MIN_SCALE);
        var ctm = this.matrix();
        ctm.a = sx;
        ctm.d = sy;
        this.matrix(ctm);
        this.trigger("scale", sx, sy, ox, oy);
        return this;
    },
    // Experimental - do not use in production.
    rotate: function(angle, cx, cy) {
        // getter
        if (angle === undefined) return (0, _indexMjsDefault.default).matrixToRotate(this.matrix());
        // setter
        // If the origin is not set explicitely, rotate around the center. Note that
        // we must use the plain bounding box (`this.el.getBBox()` instead of the one that gives us
        // the real bounding box (`bbox()`) including transformations).
        if (cx === undefined) {
            var bbox = this.cells.getBBox();
            cx = bbox.width / 2;
            cy = bbox.height / 2;
        }
        var ctm = this.matrix().translate(cx, cy).rotate(angle).translate(-cx, -cy);
        this.matrix(ctm);
        return this;
    },
    translate: function(tx, ty) {
        // getter
        if (tx === undefined) return (0, _indexMjsDefault.default).matrixToTranslate(this.matrix());
        const { options } = this;
        const { origin, drawGrid } = options;
        // setter
        tx || (tx = 0);
        ty || (ty = 0);
        const ctm = this.matrix();
        if (ctm.e === tx && ctm.f === ty) return this;
        ctm.e = tx;
        ctm.f = ty;
        this.matrix(ctm);
        const { tx: ox, ty: oy } = this.translate();
        origin.x = ox;
        origin.y = oy;
        this.trigger("translate", ox, oy);
        if (drawGrid) this.drawGrid();
        return this;
    },
    // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also
    // be a selector or a jQuery object.
    findView: function($el) {
        var el = (0, _indexMjs1.isString)($el) ? this.cells.querySelector($el) : $el instanceof (0, _jqueryDefault.default) ? $el[0] : $el;
        var id = this.findAttribute("model-id", el);
        if (id) return this._views[id];
        return undefined;
    },
    // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.
    findViewByModel: function(cell) {
        var id = (0, _indexMjs1.isString)(cell) || (0, _indexMjs1.isNumber)(cell) ? cell : cell && cell.id;
        return this._views[id];
    },
    // Find all views at given point
    findViewsFromPoint: function(p) {
        p = new (0, _indexMjs2.Point)(p);
        var views = this.model.getElements().map(this.findViewByModel, this);
        return views.filter(function(view) {
            return view && view.vel.getBBox({
                target: this.cells
            }).containsPoint(p);
        }, this);
    },
    // Find all views in given area
    findViewsInArea: function(rect, opt) {
        opt = (0, _indexMjs1.defaults)(opt || {}, {
            strict: false
        });
        rect = new (0, _indexMjs2.Rect)(rect);
        var views = this.model.getElements().map(this.findViewByModel, this);
        var method = opt.strict ? "containsRect" : "intersect";
        return views.filter(function(view) {
            return view && rect[method](view.vel.getBBox({
                target: this.cells
            }));
        }, this);
    },
    removeTools: function() {
        this.dispatchToolsEvent("remove");
        return this;
    },
    hideTools: function() {
        this.dispatchToolsEvent("hide");
        return this;
    },
    showTools: function() {
        this.dispatchToolsEvent("show");
        return this;
    },
    dispatchToolsEvent: function(event, ...args) {
        if (typeof event !== "string") return;
        this.trigger("tools:event", event, ...args);
    },
    getModelById: function(id) {
        return this.model.getCell(id);
    },
    snapToGrid: function(x, y) {
        // Convert global coordinates to the local ones of the `viewport`. Otherwise,
        // improper transformation would be applied when the viewport gets transformed (scaled/rotated).
        return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);
    },
    localToPaperPoint: function(x, y) {
        // allow `x` to be a point and `y` undefined
        var localPoint = new (0, _indexMjs2.Point)(x, y);
        var paperPoint = (0, _indexMjsDefault.default).transformPoint(localPoint, this.matrix());
        return paperPoint;
    },
    localToPaperRect: function(x, y, width, height) {
        // allow `x` to be a rectangle and rest arguments undefined
        var localRect = new (0, _indexMjs2.Rect)(x, y, width, height);
        var paperRect = (0, _indexMjsDefault.default).transformRect(localRect, this.matrix());
        return paperRect;
    },
    paperToLocalPoint: function(x, y) {
        // allow `x` to be a point and `y` undefined
        var paperPoint = new (0, _indexMjs2.Point)(x, y);
        var localPoint = (0, _indexMjsDefault.default).transformPoint(paperPoint, this.matrix().inverse());
        return localPoint;
    },
    paperToLocalRect: function(x, y, width, height) {
        // allow `x` to be a rectangle and rest arguments undefined
        var paperRect = new (0, _indexMjs2.Rect)(x, y, width, height);
        var localRect = (0, _indexMjsDefault.default).transformRect(paperRect, this.matrix().inverse());
        return localRect;
    },
    localToClientPoint: function(x, y) {
        // allow `x` to be a point and `y` undefined
        var localPoint = new (0, _indexMjs2.Point)(x, y);
        var clientPoint = (0, _indexMjsDefault.default).transformPoint(localPoint, this.clientMatrix());
        return clientPoint;
    },
    localToClientRect: function(x, y, width, height) {
        // allow `x` to be a point and `y` undefined
        var localRect = new (0, _indexMjs2.Rect)(x, y, width, height);
        var clientRect = (0, _indexMjsDefault.default).transformRect(localRect, this.clientMatrix());
        return clientRect;
    },
    // Transform client coordinates to the paper local coordinates.
    // Useful when you have a mouse event object and you'd like to get coordinates
    // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.
    // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });
    clientToLocalPoint: function(x, y) {
        // allow `x` to be a point and `y` undefined
        var clientPoint = new (0, _indexMjs2.Point)(x, y);
        var localPoint = (0, _indexMjsDefault.default).transformPoint(clientPoint, this.clientMatrix().inverse());
        return localPoint;
    },
    clientToLocalRect: function(x, y, width, height) {
        // allow `x` to be a point and `y` undefined
        var clientRect = new (0, _indexMjs2.Rect)(x, y, width, height);
        var localRect = (0, _indexMjsDefault.default).transformRect(clientRect, this.clientMatrix().inverse());
        return localRect;
    },
    localToPagePoint: function(x, y) {
        return this.localToPaperPoint(x, y).offset(this.pageOffset());
    },
    localToPageRect: function(x, y, width, height) {
        return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());
    },
    pageToLocalPoint: function(x, y) {
        var pagePoint = new (0, _indexMjs2.Point)(x, y);
        var paperPoint = pagePoint.difference(this.pageOffset());
        return this.paperToLocalPoint(paperPoint);
    },
    pageToLocalRect: function(x, y, width, height) {
        var pageOffset = this.pageOffset();
        var paperRect = new (0, _indexMjs2.Rect)(x, y, width, height);
        paperRect.x -= pageOffset.x;
        paperRect.y -= pageOffset.y;
        return this.paperToLocalRect(paperRect);
    },
    clientOffset: function() {
        var clientRect = this.svg.getBoundingClientRect();
        return new (0, _indexMjs2.Point)(clientRect.left, clientRect.top);
    },
    pageOffset: function() {
        return this.clientOffset().offset(window.scrollX, window.scrollY);
    },
    linkAllowed: function(linkView) {
        if (!(linkView instanceof (0, _linkViewMjs.LinkView))) throw new Error("Must provide a linkView.");
        var link = linkView.model;
        var paperOptions = this.options;
        var graph = this.model;
        var ns = graph.constructor.validations;
        if (!paperOptions.multiLinks) {
            if (!ns.multiLinks.call(this, graph, link)) return false;
        }
        if (!paperOptions.linkPinning) {
            // Link pinning is not allowed and the link is not connected to the target.
            if (!ns.linkPinning.call(this, graph, link)) return false;
        }
        if (typeof paperOptions.allowLink === "function") {
            if (!paperOptions.allowLink.call(this, linkView, this)) return false;
        }
        return true;
    },
    getDefaultLink: function(cellView, magnet) {
        return (0, _indexMjs1.isFunction)(this.options.defaultLink) ? this.options.defaultLink.call(this, cellView, magnet) : this.options.defaultLink.clone();
    },
    // Cell highlighting.
    // ------------------
    resolveHighlighter: function(opt = {}) {
        let { highlighter: highlighterDef, type } = opt;
        const { highlighting, highlighterNamespace } = this.options;
        /*
            Expecting opt.highlighter to have the following structure:
            {
                name: 'highlighter-name',
                options: {
                    some: 'value'
                }
            }
        */ if (highlighterDef === undefined) {
            // Is highlighting disabled?
            if (!highlighting) return false;
            // check for built-in types
            if (type) {
                highlighterDef = highlighting[type];
                // Is a specific type highlight disabled?
                if (highlighterDef === false) return false;
            }
            if (!highlighterDef) // Type not defined use default highlight
            highlighterDef = highlighting["default"];
        }
        // Do nothing if opt.highlighter is falsy.
        // This allows the case to not highlight cell(s) in certain cases.
        // For example, if you want to NOT highlight when embedding elements
        // or use a custom highlighter.
        if (!highlighterDef) return false;
        // Allow specifying a highlighter by name.
        if ((0, _indexMjs1.isString)(highlighterDef)) highlighterDef = {
            name: highlighterDef
        };
        const name = highlighterDef.name;
        const highlighter = highlighterNamespace[name];
        // Highlighter validation
        if (!highlighter) throw new Error('Unknown highlighter ("' + name + '")');
        if (typeof highlighter.highlight !== "function") throw new Error('Highlighter ("' + name + '") is missing required highlight() method');
        if (typeof highlighter.unhighlight !== "function") throw new Error('Highlighter ("' + name + '") is missing required unhighlight() method');
        return {
            highlighter,
            options: highlighterDef.options || {},
            name
        };
    },
    onCellHighlight: function(cellView, magnetEl, opt) {
        const highlighterDescriptor = this.resolveHighlighter(opt);
        if (!highlighterDescriptor) return;
        const { highlighter, options } = highlighterDescriptor;
        highlighter.highlight(cellView, magnetEl, options);
    },
    onCellUnhighlight: function(cellView, magnetEl, opt) {
        const highlighterDescriptor = this.resolveHighlighter(opt);
        if (!highlighterDescriptor) return;
        const { highlighter, options } = highlighterDescriptor;
        highlighter.unhighlight(cellView, magnetEl, options);
    },
    // Interaction.
    // ------------
    pointerdblclick: function(evt) {
        evt.preventDefault();
        // magnetpointerdblclick can stop propagation
        evt = (0, _indexMjs1.normalizeEvent)(evt);
        var view = this.findView(evt.target);
        if (this.guard(evt, view)) return;
        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
        if (view) view.pointerdblclick(evt, localPoint.x, localPoint.y);
        else this.trigger("blank:pointerdblclick", evt, localPoint.x, localPoint.y);
    },
    pointerclick: function(evt) {
        // magnetpointerclick can stop propagation
        var data = this.eventData(evt);
        // Trigger event only if mouse has not moved.
        if (data.mousemoved <= this.options.clickThreshold) {
            evt = (0, _indexMjs1.normalizeEvent)(evt);
            var view = this.findView(evt.target);
            if (this.guard(evt, view)) return;
            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
            if (view) view.pointerclick(evt, localPoint.x, localPoint.y);
            else this.trigger("blank:pointerclick", evt, localPoint.x, localPoint.y);
        }
    },
    contextmenu: function(evt) {
        if (this.options.preventContextMenu) evt.preventDefault();
        if (this.contextMenuFired) {
            this.contextMenuFired = false;
            return;
        }
        evt = (0, _indexMjs1.normalizeEvent)(evt);
        this.contextMenuTrigger(evt);
    },
    contextMenuTrigger: function(evt) {
        var view = this.findView(evt.target);
        if (this.guard(evt, view)) return;
        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
        if (view) view.contextmenu(evt, localPoint.x, localPoint.y);
        else this.trigger("blank:contextmenu", evt, localPoint.x, localPoint.y);
    },
    pointerdown: function(evt) {
        evt = (0, _indexMjs1.normalizeEvent)(evt);
        const { target, button } = evt;
        const view = this.findView(target);
        const isContextMenu = button === 2;
        if (view) {
            if (!isContextMenu && this.guard(evt, view)) return;
            const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);
            if (this.options.preventDefaultViewAction && !isTargetFormNode) // If the target is a form element, we do not want to prevent the default action.
            // For example, we want to be able to select text in a text input or
            // to be able to click on a checkbox.
            evt.preventDefault();
            if (isTargetFormNode) // If the target is a form element, we do not want to start dragging the element.
            // For example, we want to be able to select text by dragging the mouse.
            view.preventDefaultInteraction(evt);
            const rootViewEl = view.el;
            // Custom event
            const eventNode = target.closest("[event]");
            if (eventNode && rootViewEl !== eventNode && view.el.contains(eventNode)) {
                const eventEvt = (0, _indexMjs1.normalizeEvent)((0, _jqueryDefault.default).Event(evt.originalEvent, {
                    data: evt.data,
                    // Originally the event listener was attached to the event element.
                    currentTarget: eventNode
                }));
                this.onevent(eventEvt);
                if (eventEvt.isDefaultPrevented()) evt.preventDefault();
                // `onevent` can stop propagation
                if (eventEvt.isPropagationStopped()) return;
                evt.data = eventEvt.data;
            }
            // Element magnet
            const magnetNode = target.closest("[magnet]");
            if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {
                const magnetEvt = (0, _indexMjs1.normalizeEvent)((0, _jqueryDefault.default).Event(evt.originalEvent, {
                    data: evt.data,
                    // Originally the event listener was attached to the magnet element.
                    currentTarget: magnetNode
                }));
                this.onmagnet(magnetEvt);
                if (magnetEvt.isDefaultPrevented()) evt.preventDefault();
                // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed
                if (magnetEvt.isPropagationStopped()) {
                    // `magnet:pointermove` and `magnet:pointerup` events must be fired
                    if (isContextMenu) return;
                    this.delegateDragEvents(view, magnetEvt.data);
                    return;
                }
                evt.data = magnetEvt.data;
            }
        }
        if (isContextMenu) {
            this.contextMenuFired = true;
            const contextmenuEvt = (0, _jqueryDefault.default).Event(evt.originalEvent, {
                type: "contextmenu",
                data: evt.data
            });
            this.contextMenuTrigger(contextmenuEvt);
        } else {
            const localPoint = this.snapToGrid(evt.clientX, evt.clientY);
            if (view) view.pointerdown(evt, localPoint.x, localPoint.y);
            else {
                if (this.options.preventDefaultBlankAction) evt.preventDefault();
                this.trigger("blank:pointerdown", evt, localPoint.x, localPoint.y);
            }
            this.delegateDragEvents(view, evt.data);
        }
    },
    pointermove: function(evt) {
        // mouse moved counter
        var data = this.eventData(evt);
        if (!data.mousemoved) {
            data.mousemoved = 0;
            // Make sure that events like `mouseenter` and `mouseleave` are
            // not triggered while the user is dragging a cellView.
            this.undelegateEvents();
        // Note: the events are undelegated after the first `pointermove` event.
        // Not on `pointerdown` to make sure that `dbltap` is recognized.
        }
        var mousemoved = ++data.mousemoved;
        if (mousemoved <= this.options.moveThreshold) return;
        evt = (0, _indexMjs1.normalizeEvent)(evt);
        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
        var view = data.sourceView;
        if (view) view.pointermove(evt, localPoint.x, localPoint.y);
        else this.trigger("blank:pointermove", evt, localPoint.x, localPoint.y);
        this.eventData(evt, data);
    },
    pointerup: function(evt) {
        this.undelegateDocumentEvents();
        var normalizedEvt = (0, _indexMjs1.normalizeEvent)(evt);
        var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);
        var view = this.eventData(evt).sourceView;
        if (view) view.pointerup(normalizedEvt, localPoint.x, localPoint.y);
        else this.trigger("blank:pointerup", normalizedEvt, localPoint.x, localPoint.y);
        if (!normalizedEvt.isPropagationStopped()) this.pointerclick((0, _jqueryDefault.default).Event(evt.originalEvent, {
            type: "click",
            data: evt.data
        }));
        this.delegateEvents();
    },
    mouseover: function(evt) {
        evt = (0, _indexMjs1.normalizeEvent)(evt);
        var view = this.findView(evt.target);
        if (this.guard(evt, view)) return;
        if (view) view.mouseover(evt);
        else {
            if (this.el === evt.target) return; // prevent border of paper from triggering this
            this.trigger("blank:mouseover", evt);
        }
    },
    mouseout: function(evt) {
        evt = (0, _indexMjs1.normalizeEvent)(evt);
        var view = this.findView(evt.target);
        if (this.guard(evt, view)) return;
        if (view) view.mouseout(evt);
        else {
            if (this.el === evt.target) return; // prevent border of paper from triggering this
            this.trigger("blank:mouseout", evt);
        }
    },
    mouseenter: function(evt) {
        evt = (0, _indexMjs1.normalizeEvent)(evt);
        const { target, relatedTarget, currentTarget// The EventTarget on which the event listener was registered
         } = evt;
        const view = this.findView(target);
        if (this.guard(evt, view)) return;
        const relatedView = this.findView(relatedTarget);
        if (view) {
            if (relatedView === view) // Mouse left a cell tool
            return;
            view.mouseenter(evt);
            if (this.el.contains(relatedTarget)) // The pointer remains inside the paper.
            return;
        }
        if (relatedView) return;
        // prevent double `mouseenter` event if the `relatedTarget` is outside the paper
        // (mouseenter method would be fired twice)
        if (currentTarget === this.el) // `paper` (more descriptive), not `blank`
        this.trigger("paper:mouseenter", evt);
    },
    mouseleave: function(evt) {
        evt = (0, _indexMjs1.normalizeEvent)(evt);
        const { target, relatedTarget, currentTarget// The EventTarget on which the event listener was registered
         } = evt;
        const view = this.findView(target);
        if (this.guard(evt, view)) return;
        const relatedView = this.findView(relatedTarget);
        if (view) {
            if (relatedView === view) // Mouse entered a cell tool
            return;
            view.mouseleave(evt);
            if (this.el.contains(relatedTarget)) // The pointer has exited a cellView. The pointer is still inside of the paper.
            return;
        }
        if (relatedView) // The pointer has entered a new cellView
        return;
        // prevent double `mouseleave` event if the `relatedTarget` is outside the paper
        // (mouseleave method would be fired twice)
        if (currentTarget === this.el) // There is no cellView under the pointer, nor the blank area of the paper
        this.trigger("paper:mouseleave", evt);
    },
    _processMouseWheelEvtBuf: (0, _indexMjs1.debounce)(function() {
        const { event, deltas } = this._mw_evt_buffer;
        const deltaY = deltas.reduce((acc, deltaY)=>acc + (0, _indexMjs1.cap)(deltaY, WHEEL_CAP), 0);
        const scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom
        const { x, y } = this.clientToLocalPoint(event.clientX, event.clientY);
        this.trigger("paper:pinch", event, x, y, scale);
        this._mw_evt_buffer = {
            event: null,
            deltas: []
        };
    }, WHEEL_WAIT_MS, {
        maxWait: WHEEL_WAIT_MS
    }),
    mousewheel: function(evt) {
        evt = (0, _indexMjs1.normalizeEvent)(evt);
        const view = this.findView(evt.target);
        if (this.guard(evt, view)) return;
        const originalEvent = evt.originalEvent;
        const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);
        const { deltaX, deltaY } = (0, _indexMjs1.normalizeWheel)(originalEvent);
        const pinchHandlers = this._events["paper:pinch"];
        // Touchpad devices will send a fake CTRL press when a pinch is performed
        //
        // We also check if there are any subscribers to paper:pinch event. If there are none,
        // just skip the entire block of code (we don't want to blindly call
        // .preventDefault() if we really don't have to).
        if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {
            // This is a pinch gesture, it's safe to assume that we must call .preventDefault()
            originalEvent.preventDefault();
            this._mw_evt_buffer.event = originalEvent;
            this._mw_evt_buffer.deltas.push(deltaY);
            this._processMouseWheelEvtBuf();
        } else {
            const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));
            if (view) view.mousewheel(evt, localPoint.x, localPoint.y, delta);
            else this.trigger("blank:mousewheel", evt, localPoint.x, localPoint.y, delta);
            this.trigger("paper:pan", evt, deltaX, deltaY);
        }
    },
    onevent: function(evt) {
        var eventNode = evt.currentTarget;
        var eventName = eventNode.getAttribute("event");
        if (eventName) {
            var view = this.findView(eventNode);
            if (view) {
                evt = (0, _indexMjs1.normalizeEvent)(evt);
                if (this.guard(evt, view)) return;
                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
                view.onevent(evt, eventName, localPoint.x, localPoint.y);
            }
        }
    },
    magnetEvent: function(evt, handler) {
        var magnetNode = evt.currentTarget;
        var magnetValue = magnetNode.getAttribute("magnet");
        if (magnetValue) {
            var view = this.findView(magnetNode);
            if (view) {
                evt = (0, _indexMjs1.normalizeEvent)(evt);
                if (this.guard(evt, view)) return;
                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
                handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);
            }
        }
    },
    onmagnet: function(evt) {
        if (evt.button === 2) {
            this.contextMenuFired = true;
            this.magnetContextMenuFired = true;
            const contextmenuEvt = (0, _jqueryDefault.default).Event(evt.originalEvent, {
                type: "contextmenu",
                data: evt.data,
                currentTarget: evt.currentTarget
            });
            this.magnetContextMenuTrigger(contextmenuEvt);
            if (contextmenuEvt.isPropagationStopped()) evt.stopPropagation();
        } else this.magnetEvent(evt, function(view, evt, _, x, y) {
            view.onmagnet(evt, x, y);
        });
    },
    magnetpointerdblclick: function(evt) {
        this.magnetEvent(evt, function(view, evt, magnet, x, y) {
            view.magnetpointerdblclick(evt, magnet, x, y);
        });
    },
    magnetcontextmenu: function(evt) {
        if (this.options.preventContextMenu) evt.preventDefault();
        if (this.magnetContextMenuFired) {
            this.magnetContextMenuFired = false;
            return;
        }
        this.magnetContextMenuTrigger(evt);
    },
    magnetContextMenuTrigger: function(evt) {
        this.magnetEvent(evt, function(view, evt, magnet, x, y) {
            view.magnetcontextmenu(evt, magnet, x, y);
        });
    },
    onlabel: function(evt) {
        var labelNode = evt.currentTarget;
        var view = this.findView(labelNode);
        if (view) {
            evt = (0, _indexMjs1.normalizeEvent)(evt);
            if (this.guard(evt, view)) return;
            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
            view.onlabel(evt, localPoint.x, localPoint.y);
        }
    },
    getPointerArgs (evt) {
        const normalizedEvt = (0, _indexMjs1.normalizeEvent)(evt);
        const { x, y } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);
        return [
            normalizedEvt,
            x,
            y
        ];
    },
    delegateDragEvents: function(view, data) {
        data || (data = {});
        this.eventData({
            data: data
        }, {
            sourceView: view || null,
            mousemoved: 0
        });
        this.delegateDocumentEvents(null, data);
    },
    // Guard the specified event. If the event should be ignored, guard returns `true`.
    // Otherwise, it returns `false`.
    guard: function(evt, view) {
        if (evt.type === "mousedown" && evt.button === 2) // handled as `contextmenu` type
        return true;
        if (this.options.guard && this.options.guard(evt, view)) return true;
        if (evt.data && evt.data.guarded !== undefined) return evt.data.guarded;
        const { target } = evt;
        if (this.GUARDED_TAG_NAMES.includes(target.tagName)) return true;
        if (view && view.model && view.model instanceof (0, _cellMjs.Cell)) return false;
        if (this.svg === target || this.el === target || (0, _jqueryDefault.default).contains(this.svg, target)) return false;
        return true; // Event guarded. Paper should not react on it in any way.
    },
    setGridSize: function(gridSize) {
        const { options } = this;
        options.gridSize = gridSize;
        if (options.drawGrid && !options.drawGridSize) // Do not redraw the grid if the `drawGridSize` is set.
        this.drawGrid();
        return this;
    },
    clearGrid: function() {
        if (this.$grid) this.$grid.css("backgroundImage", "none");
        return this;
    },
    _getGridRefs: function() {
        if (!this._gridCache) this._gridCache = {
            root: (0, _indexMjsDefault.default)("svg", {
                width: "100%",
                height: "100%"
            }, (0, _indexMjsDefault.default)("defs")),
            patterns: {},
            add: function(id, vel) {
                (0, _indexMjsDefault.default)(this.root.node.childNodes[0]).append(vel);
                this.patterns[id] = vel;
                this.root.append((0, _indexMjsDefault.default)("rect", {
                    width: "100%",
                    height: "100%",
                    fill: "url(#" + id + ")"
                }));
            },
            get: function(id) {
                return this.patterns[id];
            },
            exist: function(id) {
                return this.patterns[id] !== undefined;
            }
        };
        return this._gridCache;
    },
    setGrid: function(drawGrid) {
        this.clearGrid();
        this._gridCache = null;
        this._gridSettings = [];
        var optionsList = Array.isArray(drawGrid) ? drawGrid : [
            drawGrid || {}
        ];
        optionsList.forEach(function(item) {
            this._gridSettings.push.apply(this._gridSettings, this._resolveDrawGridOption(item));
        }, this);
        return this;
    },
    _resolveDrawGridOption: function(opt) {
        var namespace = this.constructor.gridPatterns;
        if ((0, _indexMjs1.isString)(opt) && Array.isArray(namespace[opt])) return namespace[opt].map(function(item) {
            return (0, _indexMjs1.assign)({}, item);
        });
        var options = opt || {
            args: [
                {}
            ]
        };
        var isArray = Array.isArray(options);
        var name = options.name;
        if (!isArray && !name && !options.markup) name = "dot";
        if (name && Array.isArray(namespace[name])) {
            var pattern = namespace[name].map(function(item) {
                return (0, _indexMjs1.assign)({}, item);
            });
            var args = Array.isArray(options.args) ? options.args : [
                options.args || {}
            ];
            (0, _indexMjs1.defaults)(args[0], (0, _indexMjs1.omit)(opt, "args"));
            for(var i = 0; i < args.length; i++)if (pattern[i]) (0, _indexMjs1.assign)(pattern[i], args[i]);
            return pattern;
        }
        return isArray ? options : [
            options
        ];
    },
    drawGrid: function(opt) {
        const gridSize = this.options.drawGridSize || this.options.gridSize;
        if (gridSize <= 1) return this.clearGrid();
        var localOptions = Array.isArray(opt) ? opt : [
            opt
        ];
        var ctm = this.matrix();
        var refs = this._getGridRefs();
        this._gridSettings.forEach(function(gridLayerSetting, index) {
            var id = "pattern_" + index;
            var options = (0, _indexMjs1.merge)(gridLayerSetting, localOptions[index], {
                sx: ctm.a || 1,
                sy: ctm.d || 1,
                ox: ctm.e || 0,
                oy: ctm.f || 0
            });
            options.width = gridSize * (ctm.a || 1) * (options.scaleFactor || 1);
            options.height = gridSize * (ctm.d || 1) * (options.scaleFactor || 1);
            if (!refs.exist(id)) refs.add(id, (0, _indexMjsDefault.default)("pattern", {
                id: id,
                patternUnits: "userSpaceOnUse"
            }, (0, _indexMjsDefault.default)(options.markup)));
            var patternDefVel = refs.get(id);
            if ((0, _indexMjs1.isFunction)(options.update)) options.update(patternDefVel.node.childNodes[0], options);
            var x = options.ox % options.width;
            if (x < 0) x += options.width;
            var y = options.oy % options.height;
            if (y < 0) y += options.height;
            patternDefVel.attr({
                x: x,
                y: y,
                width: options.width,
                height: options.height
            });
        });
        var patternUri = new XMLSerializer().serializeToString(refs.root.node);
        patternUri = "url(data:image/svg+xml;base64," + btoa(patternUri) + ")";
        this.$grid.css("backgroundImage", patternUri);
        return this;
    },
    updateBackgroundImage: function(opt) {
        opt = opt || {};
        var backgroundPosition = opt.position || "center";
        var backgroundSize = opt.size || "auto auto";
        var currentScale = this.scale();
        var currentTranslate = this.translate();
        // backgroundPosition
        if ((0, _indexMjs1.isObject)(backgroundPosition)) {
            var x = currentTranslate.tx + currentScale.sx * (backgroundPosition.x || 0);
            var y = currentTranslate.ty + currentScale.sy * (backgroundPosition.y || 0);
            backgroundPosition = x + "px " + y + "px";
        }
        // backgroundSize
        if ((0, _indexMjs1.isObject)(backgroundSize)) {
            backgroundSize = new (0, _indexMjs2.Rect)(backgroundSize).scale(currentScale.sx, currentScale.sy);
            backgroundSize = backgroundSize.width + "px " + backgroundSize.height + "px";
        }
        this.$background.css({
            backgroundSize: backgroundSize,
            backgroundPosition: backgroundPosition
        });
    },
    drawBackgroundImage: function(img, opt) {
        // Clear the background image if no image provided
        if (!(img instanceof HTMLImageElement)) {
            this.$background.css("backgroundImage", "");
            return;
        }
        if (!this._background || this._background.id !== opt.id) // Draw only the last image requested (see drawBackground())
        return;
        opt = opt || {};
        var backgroundImage;
        var backgroundSize = opt.size;
        var backgroundRepeat = opt.repeat || "no-repeat";
        var backgroundOpacity = opt.opacity || 1;
        var backgroundQuality = Math.abs(opt.quality) || 1;
        var backgroundPattern = this.constructor.backgroundPatterns[(0, _indexMjs1.camelCase)(backgroundRepeat)];
        if ((0, _indexMjs1.isFunction)(backgroundPattern)) {
            // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom
            img.width *= backgroundQuality;
            img.height *= backgroundQuality;
            var canvas = backgroundPattern(img, opt);
            if (!(canvas instanceof HTMLCanvasElement)) throw new Error("dia.Paper: background pattern must return an HTML Canvas instance");
            backgroundImage = canvas.toDataURL("image/png");
            backgroundRepeat = "repeat";
            if ((0, _indexMjs1.isObject)(backgroundSize)) {
                // recalculate the tile size if an object passed in
                backgroundSize.width *= canvas.width / img.width;
                backgroundSize.height *= canvas.height / img.height;
            } else if (backgroundSize === undefined) // calculate the tile size if no provided
            opt.size = {
                width: canvas.width / backgroundQuality,
                height: canvas.height / backgroundQuality
            };
        } else {
            // backgroundRepeat:
            // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'
            backgroundImage = img.src;
            if (backgroundSize === undefined) // pass the image size for  the backgroundSize if no size provided
            opt.size = {
                width: img.width,
                height: img.height
            };
        }
        this.$background.css({
            opacity: backgroundOpacity,
            backgroundRepeat: backgroundRepeat,
            backgroundImage: "url(" + backgroundImage + ")"
        });
        this.updateBackgroundImage(opt);
    },
    updateBackgroundColor: function(color) {
        this.$el.css("backgroundColor", color || "");
    },
    drawBackground: function(opt) {
        opt = opt || {};
        this.updateBackgroundColor(opt.color);
        if (opt.image) {
            opt = this._background = (0, _indexMjs1.cloneDeep)(opt);
            (0, _indexMjs1.guid)(opt);
            var img = document.createElement("img");
            img.onload = this.drawBackgroundImage.bind(this, img, opt);
            img.src = opt.image;
        } else {
            this.drawBackgroundImage(null);
            this._background = null;
        }
        return this;
    },
    setInteractivity: function(value) {
        this.options.interactive = value;
        (0, _indexMjs1.invoke)(this._views, "setInteractivity", value);
    },
    // Paper definitions.
    // ------------------
    isDefined: function(defId) {
        return !!this.svg.getElementById(defId);
    },
    defineFilter: function(filter) {
        if (!(0, _indexMjs1.isObject)(filter)) throw new TypeError("dia.Paper: defineFilter() requires 1. argument to be an object.");
        var filterId = filter.id;
        var name = filter.name;
        // Generate a hash code from the stringified filter definition. This gives us
        // a unique filter ID for different definitions.
        if (!filterId) filterId = name + this.svg.id + (0, _indexMjs1.hashCode)(JSON.stringify(filter));
        // If the filter already exists in the document,
        // we're done and we can just use it (reference it using `url()`).
        // If not, create one.
        if (!this.isDefined(filterId)) {
            var namespace = (0, _indexMjs1.filter);
            var filterSVGString = namespace[name] && namespace[name](filter.args || {});
            if (!filterSVGString) throw new Error("Non-existing filter " + name);
            // Set the filter area to be 3x the bounding box of the cell
            // and center the filter around the cell.
            var filterAttrs = (0, _indexMjs1.assign)({
                filterUnits: "objectBoundingBox",
                x: -1,
                y: -1,
                width: 3,
                height: 3
            }, filter.attrs, {
                id: filterId
            });
            (0, _indexMjsDefault.default)(filterSVGString, filterAttrs).appendTo(this.defs);
        }
        return filterId;
    },
    defineGradient: function(gradient) {
        if (!(0, _indexMjs1.isObject)(gradient)) throw new TypeError("dia.Paper: defineGradient() requires 1. argument to be an object.");
        const { svg, defs } = this;
        const { type, // Generate a hash code from the stringified filter definition. This gives us
        // a unique filter ID for different definitions.
        id = type + svg.id + (0, _indexMjs1.hashCode)(JSON.stringify(gradient)), stops, attrs = {} } = gradient;
        // If the gradient already exists in the document,
        // we're done and we can just use it (reference it using `url()`).
        if (this.isDefined(id)) return id;
        // If not, create one.
        const stopVEls = (0, _indexMjs1.toArray)(stops).map(({ offset, color, opacity })=>{
            return (0, _indexMjsDefault.default)("stop").attr({
                "offset": offset,
                "stop-color": color,
                "stop-opacity": Number.isFinite(opacity) ? opacity : 1
            });
        });
        const gradientVEl = (0, _indexMjsDefault.default)(type, attrs, stopVEls);
        gradientVEl.id = id;
        gradientVEl.appendTo(defs);
        return id;
    },
    definePattern: function(pattern) {
        if (!(0, _indexMjs1.isObject)(pattern)) throw new TypeError("dia.Paper: definePattern() requires 1. argument to be an object.");
        const { svg, defs } = this;
        const { // Generate a hash code from the stringified filter definition. This gives us
        // a unique filter ID for different definitions.
        id = svg.id + (0, _indexMjs1.hashCode)(JSON.stringify(pattern)), markup, attrs = {} } = pattern;
        if (!markup) throw new TypeError("dia.Paper: definePattern() requires markup.");
        // If the gradient already exists in the document,
        // we're done and we can just use it (reference it using `url()`).
        if (this.isDefined(id)) return id;
        // If not, create one.
        const patternVEl = (0, _indexMjsDefault.default)("pattern", {
            patternUnits: "userSpaceOnUse"
        });
        patternVEl.id = id;
        patternVEl.attr(attrs);
        if (typeof markup === "string") patternVEl.append((0, _indexMjsDefault.default)(markup));
        else {
            const { fragment } = (0, _indexMjs1.parseDOMJSON)(markup);
            patternVEl.append(fragment);
        }
        patternVEl.appendTo(defs);
        return id;
    },
    defineMarker: function(marker) {
        if (!(0, _indexMjs1.isObject)(marker)) throw new TypeError("dia.Paper: defineMarker() requires the first argument to be an object.");
        const { svg, defs } = this;
        const { // Generate a hash code from the stringified filter definition. This gives us
        // a unique filter ID for different definitions.
        id = svg.id + (0, _indexMjs1.hashCode)(JSON.stringify(marker)), // user-provided markup
        // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)
        markup, // user-provided attributes
        // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)
        // note: `transform` attrs are ignored by browsers
        attrs = {}, // deprecated - use `attrs/markerUnits` instead (which has higher priority)
        markerUnits = "userSpaceOnUse" } = marker;
        // If the marker already exists in the document,
        // we're done and we can just use it (reference it using `url()`).
        if (this.isDefined(id)) return id;
        // If not, create one.
        const markerVEl = (0, _indexMjsDefault.default)("marker", {
            orient: "auto",
            overflow: "visible",
            markerUnits: markerUnits
        });
        markerVEl.id = id;
        markerVEl.attr(attrs);
        let markerContentVEl;
        if (markup) {
            let markupVEl;
            if (typeof markup === "string") {
                // Marker object has a `markup` property of type string.
                // - Construct V from the provided string.
                markupVEl = (0, _indexMjsDefault.default)(markup);
                // `markupVEl` is now either a single VEl, or an array of VEls.
                // - Coerce it to an array.
                markupVEl = Array.isArray(markupVEl) ? markupVEl : [
                    markupVEl
                ];
            } else {
                // Marker object has a `markup` property of type object.
                // - Construct V from the object by parsing it as DOM JSON.
                const { fragment } = (0, _indexMjs1.parseDOMJSON)(markup);
                markupVEl = (0, _indexMjsDefault.default)(fragment).children();
            }
            // `markupVEl` is an array with one or more VEls inside.
            // - If there are multiple VEls, wrap them in a newly-constructed <g> element
            if (markupVEl.length > 1) markerContentVEl = (0, _indexMjsDefault.default)("g").append(markupVEl);
            else markerContentVEl = markupVEl[0];
        } else {
            // Marker object is a flat structure.
            // - Construct a new V of type `marker.type`.
            const { type = "path" } = marker;
            markerContentVEl = (0, _indexMjsDefault.default)(type);
        }
        // `markerContentVEl` is a single VEl.
        // Assign additional attributes to it (= context attributes + marker attributes):
        // - Attribute values are taken from non-special properties of `marker`.
        const markerAttrs = (0, _indexMjs1.omit)(marker, "type", "id", "markup", "attrs", "markerUnits");
        const markerAttrsKeys = Object.keys(markerAttrs);
        markerAttrsKeys.forEach((key)=>{
            const value = markerAttrs[key];
            const markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority
            if (markupValue == null) // Default logic:
            markerContentVEl.attr(key, value);
            else // Properties with special logic should be added as cases to this switch block:
            switch(key){
                case "transform":
                    // - Prepend `transform` to existing value.
                    markerContentVEl.attr(key, value + " " + markupValue);
                    break;
            }
        });
        markerContentVEl.appendTo(markerVEl);
        markerVEl.appendTo(defs);
        return id;
    }
}, {
    sorting: sortingTypes,
    Layers: (0, _paperLayerMjs.LayersNames),
    backgroundPatterns: {
        flipXy: function(img) {
            // d b
            // q p
            var canvas = document.createElement("canvas");
            var imgWidth = img.width;
            var imgHeight = img.height;
            canvas.width = 2 * imgWidth;
            canvas.height = 2 * imgHeight;
            var ctx = canvas.getContext("2d");
            // top-left image
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            // xy-flipped bottom-right image
            ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            // x-flipped top-right image
            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            // y-flipped bottom-left image
            ctx.setTransform(1, 0, 0, -1, 0, canvas.height);
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            return canvas;
        },
        flipX: function(img) {
            // d b
            // d b
            var canvas = document.createElement("canvas");
            var imgWidth = img.width;
            var imgHeight = img.height;
            canvas.width = imgWidth * 2;
            canvas.height = imgHeight;
            var ctx = canvas.getContext("2d");
            // left image
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            // flipped right image
            ctx.translate(2 * imgWidth, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            return canvas;
        },
        flipY: function(img) {
            // d d
            // q q
            var canvas = document.createElement("canvas");
            var imgWidth = img.width;
            var imgHeight = img.height;
            canvas.width = imgWidth;
            canvas.height = imgHeight * 2;
            var ctx = canvas.getContext("2d");
            // top image
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            // flipped bottom image
            ctx.translate(0, 2 * imgHeight);
            ctx.scale(1, -1);
            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
            return canvas;
        },
        watermark: function(img, opt) {
            //   d
            // d
            opt = opt || {};
            var imgWidth = img.width;
            var imgHeight = img.height;
            var canvas = document.createElement("canvas");
            canvas.width = imgWidth * 3;
            canvas.height = imgHeight * 3;
            var ctx = canvas.getContext("2d");
            var angle = (0, _indexMjs1.isNumber)(opt.watermarkAngle) ? -opt.watermarkAngle : -20;
            var radians = (0, _indexMjs2.toRad)(angle);
            var stepX = canvas.width / 4;
            var stepY = canvas.height / 4;
            for(var i = 0; i < 4; i++){
                for(var j = 0; j < 4; j++)if ((i + j) % 2 > 0) {
                    // reset the current transformations
                    ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);
                    ctx.rotate(radians);
                    ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);
                }
            }
            return canvas;
        }
    },
    gridPatterns: {
        dot: [
            {
                color: "#AAAAAA",
                thickness: 1,
                markup: "rect",
                update: function(el, opt) {
                    (0, _indexMjsDefault.default)(el).attr({
                        width: opt.thickness * opt.sx,
                        height: opt.thickness * opt.sy,
                        fill: opt.color
                    });
                }
            }
        ],
        fixedDot: [
            {
                color: "#AAAAAA",
                thickness: 1,
                markup: "rect",
                update: function(el, opt) {
                    var size = opt.sx <= 1 ? opt.thickness * opt.sx : opt.thickness;
                    (0, _indexMjsDefault.default)(el).attr({
                        width: size,
                        height: size,
                        fill: opt.color
                    });
                }
            }
        ],
        mesh: [
            {
                color: "#AAAAAA",
                thickness: 1,
                markup: "path",
                update: function(el, opt) {
                    var d;
                    var width = opt.width;
                    var height = opt.height;
                    var thickness = opt.thickness;
                    if (width - thickness >= 0 && height - thickness >= 0) d = [
                        "M",
                        width,
                        0,
                        "H0 M0 0 V0",
                        height
                    ].join(" ");
                    else d = "M 0 0 0 0";
                    (0, _indexMjsDefault.default)(el).attr({
                        "d": d,
                        stroke: opt.color,
                        "stroke-width": opt.thickness
                    });
                }
            }
        ],
        doubleMesh: [
            {
                color: "#AAAAAA",
                thickness: 1,
                markup: "path",
                update: function(el, opt) {
                    var d;
                    var width = opt.width;
                    var height = opt.height;
                    var thickness = opt.thickness;
                    if (width - thickness >= 0 && height - thickness >= 0) d = [
                        "M",
                        width,
                        0,
                        "H0 M0 0 V0",
                        height
                    ].join(" ");
                    else d = "M 0 0 0 0";
                    (0, _indexMjsDefault.default)(el).attr({
                        "d": d,
                        stroke: opt.color,
                        "stroke-width": opt.thickness
                    });
                }
            },
            {
                color: "#000000",
                thickness: 3,
                scaleFactor: 4,
                markup: "path",
                update: function(el, opt) {
                    var d;
                    var width = opt.width;
                    var height = opt.height;
                    var thickness = opt.thickness;
                    if (width - thickness >= 0 && height - thickness >= 0) d = [
                        "M",
                        width,
                        0,
                        "H0 M0 0 V0",
                        height
                    ].join(" ");
                    else d = "M 0 0 0 0";
                    (0, _indexMjsDefault.default)(el).attr({
                        "d": d,
                        stroke: opt.color,
                        "stroke-width": opt.thickness
                    });
                }
            }
        ]
    }
});

},{"../V/index.mjs":"iw8UN","../util/index.mjs":"eL7pI","../g/index.mjs":"i91Db","../mvc/index.mjs":"c2o6n","./CellView.mjs":"5Rm2b","./ElementView.mjs":"dHPd6","./LinkView.mjs":"bsn5r","./Link.mjs":"kX2vg","./Cell.mjs":"vHapP","./Graph.mjs":"efPXe","./PaperLayer.mjs":"cJg4l","../highlighters/index.mjs":"5aoGO","../linkAnchors/index.mjs":"5YGns","../connectionPoints/index.mjs":"5MgYT","../anchors/index.mjs":"bihsF","jquery":"7jr44","backbone":"gM9rO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iOzZj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ToolView", ()=>ToolView);
var _indexMjs = require("../mvc/index.mjs");
const ToolView = _indexMjs.View.extend({
    name: null,
    tagName: "g",
    className: "tool",
    svgElement: true,
    _visible: true,
    init: function() {
        var name = this.name;
        if (name) this.vel.attr("data-tool-name", name);
    },
    configure: function(view, toolsView) {
        this.relatedView = view;
        this.paper = view.paper;
        this.parentView = toolsView;
        this.simulateRelatedView(this.el);
        // Delegate events in case the ToolView was removed from the DOM and reused.
        this.delegateEvents();
        return this;
    },
    simulateRelatedView: function(el) {
        if (el) el.setAttribute("model-id", this.relatedView.model.id);
    },
    getName: function() {
        return this.name;
    },
    show: function() {
        this.el.style.display = "";
        this._visible = true;
    },
    hide: function() {
        this.el.style.display = "none";
        this._visible = false;
    },
    isVisible: function() {
        return !!this._visible;
    },
    focus: function() {
        var opacity = this.options.focusOpacity;
        if (isFinite(opacity)) this.el.style.opacity = opacity;
        this.parentView.focusTool(this);
    },
    blur: function() {
        this.el.style.opacity = "";
        this.parentView.blurTool(this);
    },
    update: function() {
    // to be overridden
    },
    guard: function(evt) {
        // Let the context-menu event bubble up to the relatedView
        const { paper, relatedView } = this;
        if (!paper || !relatedView) return true;
        return paper.guard(evt, relatedView);
    }
});

},{"../mvc/index.mjs":"c2o6n","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eMvN7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ToolsView", ()=>ToolsView);
var _indexMjs = require("../mvc/index.mjs");
var _indexMjs1 = require("../util/index.mjs");
var _cellViewMjs = require("./CellView.mjs");
var _paperLayerMjs = require("./PaperLayer.mjs");
var _toolViewMjs = require("./ToolView.mjs");
const ToolsView = _indexMjs.View.extend({
    tagName: "g",
    className: "tools",
    svgElement: true,
    tools: null,
    isRendered: false,
    options: {
        tools: null,
        relatedView: null,
        name: null
    },
    configure: function(options) {
        options = _indexMjs1.assign(this.options, options);
        var tools = options.tools;
        if (!Array.isArray(tools)) return this;
        var relatedView = options.relatedView;
        if (!(relatedView instanceof (0, _cellViewMjs.CellView))) return this;
        var views = this.tools = [];
        for(var i = 0, n = tools.length; i < n; i++){
            var tool = tools[i];
            if (!(tool instanceof (0, _toolViewMjs.ToolView))) continue;
            tool.configure(relatedView, this);
            this.vel.append(tool.el);
            views.push(tool);
        }
        this.isRendered = false;
        relatedView.requestUpdate(relatedView.getFlag("TOOLS"));
        return this;
    },
    getName: function() {
        return this.options.name;
    },
    update: function(opt) {
        opt || (opt = {});
        var tools = this.tools;
        if (!tools) return this;
        var isRendered = this.isRendered;
        for(var i = 0, n = tools.length; i < n; i++){
            var tool = tools[i];
            if (!isRendered) // First update executes render()
            tool.render();
            else if (opt.tool !== tool.cid && tool.isVisible()) tool.update();
        }
        if (!this.isMounted()) this.mount();
        if (!isRendered) {
            // Make sure tools are visible (if they were hidden and the tool removed)
            this.blurTool();
            this.isRendered = true;
        }
        return this;
    },
    focusTool: function(focusedTool) {
        var tools = this.tools;
        if (!tools) return this;
        for(var i = 0, n = tools.length; i < n; i++){
            var tool = tools[i];
            if (focusedTool === tool) tool.show();
            else tool.hide();
        }
        return this;
    },
    blurTool: function(blurredTool) {
        var tools = this.tools;
        if (!tools) return this;
        for(var i = 0, n = tools.length; i < n; i++){
            var tool = tools[i];
            if (tool !== blurredTool && !tool.isVisible()) {
                tool.show();
                tool.update();
            }
        }
        return this;
    },
    hide: function() {
        return this.focusTool(null);
    },
    show: function() {
        return this.blurTool(null);
    },
    onRemove: function() {
        var tools = this.tools;
        if (!tools) return this;
        for(var i = 0, n = tools.length; i < n; i++)tools[i].remove();
        this.tools = null;
    },
    mount: function() {
        const { options, el } = this;
        const { relatedView, layer = (0, _paperLayerMjs.LayersNames).TOOLS, z } = options;
        if (relatedView) {
            if (layer) relatedView.paper.getLayerView(layer).insertSortedNode(el, z);
            else relatedView.el.appendChild(el);
        }
        return this;
    }
});

},{"../mvc/index.mjs":"c2o6n","../util/index.mjs":"eL7pI","./CellView.mjs":"5Rm2b","./PaperLayer.mjs":"cJg4l","./ToolView.mjs":"iOzZj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["2TPoR","9Ve7W"], "9Ve7W", "parcelRequirecea6")

//# sourceMappingURL=client.f147e69c.js.map
