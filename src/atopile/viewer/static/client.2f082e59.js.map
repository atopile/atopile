{"mappings":"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","sources":["<anon>","node_modules/backbone/backbone.js","src/visualiser_client/static/jointjs-3.7.1.js"],"sourcesContent":["var $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequirecea6\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequirecea6\"] = parcelRequire;\n}\nparcelRequire.register(\"kL2Ep\", function(module, exports) {\n\n\n//     Backbone.js 1.5.0\n//     (c) 2010-2022 Jeremy Ashkenas and DocumentCloud\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n(function(factory) {\n    // Establish the root object, `window` (`self`) in the browser, or `global` on the server.\n    // We use `self` instead of `window` for `WebWorker` support.\n    var root = typeof self == \"object\" && self.self === self && self || typeof $parcel$global == \"object\" && $parcel$global.global === $parcel$global && $parcel$global;\n    // Set up Backbone appropriately for the environment. Start with AMD.\n    if (typeof define === \"function\" && define.amd) define([\n        \"underscore\",\n        \"jquery\",\n        \"exports\"\n    ], function(_, $, exports1) {\n        // Export global even in AMD case in case this script is loaded with\n        // others that may still expect a global Backbone.\n        root.Backbone = factory(root, exports1, _, $);\n    });\n    else {\n        var _ = (parcelRequire(\"2q7Wm\")), $;\n        try {\n            $ = (parcelRequire(\"6KOho\"));\n        } catch (e) {}\n        factory(root, module.exports, _, $);\n    }\n})(function(root, Backbone, _, $) {\n    // Initial Setup\n    // -------------\n    // Save the previous value of the `Backbone` variable, so that it can be\n    // restored later on, if `noConflict` is used.\n    var previousBackbone = root.Backbone;\n    // Create a local reference to a common array method we'll want to use later.\n    var slice = Array.prototype.slice;\n    // Current version of the library. Keep in sync with `package.json`.\n    Backbone.VERSION = \"1.5.0\";\n    // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\n    // the `$` variable.\n    Backbone.$ = $;\n    // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n    // to its previous owner. Returns a reference to this Backbone object.\n    Backbone.noConflict = function() {\n        root.Backbone = previousBackbone;\n        return this;\n    };\n    // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n    // will fake `\"PATCH\"`, `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n    // set a `X-Http-Method-Override` header.\n    Backbone.emulateHTTP = false;\n    // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n    // `application/json` requests ... this will encode the body as\n    // `application/x-www-form-urlencoded` instead and will send the model in a\n    // form param named `model`.\n    Backbone.emulateJSON = false;\n    // Backbone.Events\n    // ---------------\n    // A module that can be mixed in to *any object* in order to provide it with\n    // a custom event channel. You may bind a callback to an event with `on` or\n    // remove with `off`; `trigger`-ing an event fires all callbacks in\n    // succession.\n    //\n    //     var object = {};\n    //     _.extend(object, Backbone.Events);\n    //     object.on('expand', function(){ alert('expanded'); });\n    //     object.trigger('expand');\n    //\n    var Events = Backbone.Events = {};\n    // Regular expression used to split event strings.\n    var eventSplitter = /\\s+/;\n    // A private global variable to share between listeners and listenees.\n    var _listening;\n    // Iterates over the standard `event, callback` (as well as the fancy multiple\n    // space-separated events `\"change blur\", callback` and jQuery-style event\n    // maps `{event: callback}`).\n    var eventsApi = function(iteratee, events, name, callback, opts) {\n        var i = 0, names;\n        if (name && typeof name === \"object\") {\n            // Handle event maps.\n            if (callback !== void 0 && \"context\" in opts && opts.context === void 0) opts.context = callback;\n            for(names = _.keys(name); i < names.length; i++)events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n        } else if (name && eventSplitter.test(name)) // Handle space-separated event names by delegating them individually.\n        for(names = name.split(eventSplitter); i < names.length; i++)events = iteratee(events, names[i], callback, opts);\n        else // Finally, standard events.\n        events = iteratee(events, name, callback, opts);\n        return events;\n    };\n    // Bind an event to a `callback` function. Passing `\"all\"` will bind\n    // the callback to all events fired.\n    Events.on = function(name, callback, context) {\n        this._events = eventsApi(onApi, this._events || {}, name, callback, {\n            context: context,\n            ctx: this,\n            listening: _listening\n        });\n        if (_listening) {\n            var listeners = this._listeners || (this._listeners = {});\n            listeners[_listening.id] = _listening;\n            // Allow the listening to use a counter, instead of tracking\n            // callbacks for library interop\n            _listening.interop = false;\n        }\n        return this;\n    };\n    // Inversion-of-control versions of `on`. Tell *this* object to listen to\n    // an event in another object... keeping track of what it's listening to\n    // for easier unbinding later.\n    Events.listenTo = function(obj, name, callback) {\n        if (!obj) return this;\n        var id = obj._listenId || (obj._listenId = _.uniqueId(\"l\"));\n        var listeningTo = this._listeningTo || (this._listeningTo = {});\n        var listening = _listening = listeningTo[id];\n        // This object is not listening to any other events on `obj` yet.\n        // Setup the necessary references to track the listening callbacks.\n        if (!listening) {\n            this._listenId || (this._listenId = _.uniqueId(\"l\"));\n            listening = _listening = listeningTo[id] = new Listening(this, obj);\n        }\n        // Bind callbacks on obj.\n        var error = tryCatchOn(obj, name, callback, this);\n        _listening = void 0;\n        if (error) throw error;\n        // If the target obj is not Backbone.Events, track events manually.\n        if (listening.interop) listening.on(name, callback);\n        return this;\n    };\n    // The reducing API that adds a callback to the `events` object.\n    var onApi = function(events, name, callback, options) {\n        if (callback) {\n            var handlers = events[name] || (events[name] = []);\n            var context = options.context, ctx = options.ctx, listening = options.listening;\n            if (listening) listening.count++;\n            handlers.push({\n                callback: callback,\n                context: context,\n                ctx: context || ctx,\n                listening: listening\n            });\n        }\n        return events;\n    };\n    // An try-catch guarded #on function, to prevent poisoning the global\n    // `_listening` variable.\n    var tryCatchOn = function(obj, name, callback, context) {\n        try {\n            obj.on(name, callback, context);\n        } catch (e) {\n            return e;\n        }\n    };\n    // Remove one or many callbacks. If `context` is null, removes all\n    // callbacks with that function. If `callback` is null, removes all\n    // callbacks for the event. If `name` is null, removes all bound\n    // callbacks for all events.\n    Events.off = function(name, callback, context) {\n        if (!this._events) return this;\n        this._events = eventsApi(offApi, this._events, name, callback, {\n            context: context,\n            listeners: this._listeners\n        });\n        return this;\n    };\n    // Tell this object to stop listening to either specific events ... or\n    // to every object it's currently listening to.\n    Events.stopListening = function(obj, name, callback) {\n        var listeningTo = this._listeningTo;\n        if (!listeningTo) return this;\n        var ids = obj ? [\n            obj._listenId\n        ] : _.keys(listeningTo);\n        for(var i = 0; i < ids.length; i++){\n            var listening = listeningTo[ids[i]];\n            // If listening doesn't exist, this object is not currently\n            // listening to obj. Break out early.\n            if (!listening) break;\n            listening.obj.off(name, callback, this);\n            if (listening.interop) listening.off(name, callback);\n        }\n        if (_.isEmpty(listeningTo)) this._listeningTo = void 0;\n        return this;\n    };\n    // The reducing API that removes a callback from the `events` object.\n    var offApi = function(events, name, callback, options) {\n        if (!events) return;\n        var context = options.context, listeners = options.listeners;\n        var i = 0, names;\n        // Delete all event listeners and \"drop\" events.\n        if (!name && !context && !callback) {\n            for(names = _.keys(listeners); i < names.length; i++)listeners[names[i]].cleanup();\n            return;\n        }\n        names = name ? [\n            name\n        ] : _.keys(events);\n        for(; i < names.length; i++){\n            name = names[i];\n            var handlers = events[name];\n            // Bail out if there are no events stored.\n            if (!handlers) break;\n            // Find any remaining events.\n            var remaining = [];\n            for(var j = 0; j < handlers.length; j++){\n                var handler = handlers[j];\n                if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) remaining.push(handler);\n                else {\n                    var listening = handler.listening;\n                    if (listening) listening.off(name, callback);\n                }\n            }\n            // Replace events if there are any remaining.  Otherwise, clean up.\n            if (remaining.length) events[name] = remaining;\n            else delete events[name];\n        }\n        return events;\n    };\n    // Bind an event to only be triggered a single time. After the first time\n    // the callback is invoked, its listener will be removed. If multiple events\n    // are passed in using the space-separated syntax, the handler will fire\n    // once for each event, not once for a combination of all events.\n    Events.once = function(name, callback, context) {\n        // Map the event into a `{event: once}` object.\n        var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));\n        if (typeof name === \"string\" && context == null) callback = void 0;\n        return this.on(events, callback, context);\n    };\n    // Inversion-of-control versions of `once`.\n    Events.listenToOnce = function(obj, name, callback) {\n        // Map the event into a `{event: once}` object.\n        var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));\n        return this.listenTo(obj, events);\n    };\n    // Reduces the event callbacks into a map of `{event: onceWrapper}`.\n    // `offer` unbinds the `onceWrapper` after it has been called.\n    var onceMap = function(map, name, callback, offer) {\n        if (callback) {\n            var once = map[name] = _.once(function() {\n                offer(name, once);\n                callback.apply(this, arguments);\n            });\n            once._callback = callback;\n        }\n        return map;\n    };\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    Events.trigger = function(name) {\n        if (!this._events) return this;\n        var length = Math.max(0, arguments.length - 1);\n        var args = Array(length);\n        for(var i = 0; i < length; i++)args[i] = arguments[i + 1];\n        eventsApi(triggerApi, this._events, name, void 0, args);\n        return this;\n    };\n    // Handles triggering the appropriate event callbacks.\n    var triggerApi = function(objEvents, name, callback, args) {\n        if (objEvents) {\n            var events = objEvents[name];\n            var allEvents = objEvents.all;\n            if (events && allEvents) allEvents = allEvents.slice();\n            if (events) triggerEvents(events, args);\n            if (allEvents) triggerEvents(allEvents, [\n                name\n            ].concat(args));\n        }\n        return objEvents;\n    };\n    // A difficult-to-believe, but optimized internal dispatch function for\n    // triggering events. Tries to keep the usual cases speedy (most internal\n    // Backbone events have 3 arguments).\n    var triggerEvents = function(events, args) {\n        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n        switch(args.length){\n            case 0:\n                while(++i < l)(ev = events[i]).callback.call(ev.ctx);\n                return;\n            case 1:\n                while(++i < l)(ev = events[i]).callback.call(ev.ctx, a1);\n                return;\n            case 2:\n                while(++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2);\n                return;\n            case 3:\n                while(++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n                return;\n            default:\n                while(++i < l)(ev = events[i]).callback.apply(ev.ctx, args);\n                return;\n        }\n    };\n    // A listening class that tracks and cleans up memory bindings\n    // when all callbacks have been offed.\n    var Listening = function(listener, obj) {\n        this.id = listener._listenId;\n        this.listener = listener;\n        this.obj = obj;\n        this.interop = true;\n        this.count = 0;\n        this._events = void 0;\n    };\n    Listening.prototype.on = Events.on;\n    // Offs a callback (or several).\n    // Uses an optimized counter if the listenee uses Backbone.Events.\n    // Otherwise, falls back to manual tracking to support events\n    // library interop.\n    Listening.prototype.off = function(name, callback) {\n        var cleanup;\n        if (this.interop) {\n            this._events = eventsApi(offApi, this._events, name, callback, {\n                context: void 0,\n                listeners: void 0\n            });\n            cleanup = !this._events;\n        } else {\n            this.count--;\n            cleanup = this.count === 0;\n        }\n        if (cleanup) this.cleanup();\n    };\n    // Cleans up memory bindings between the listener and the listenee.\n    Listening.prototype.cleanup = function() {\n        delete this.listener._listeningTo[this.obj._listenId];\n        if (!this.interop) delete this.obj._listeners[this.id];\n    };\n    // Aliases for backwards compatibility.\n    Events.bind = Events.on;\n    Events.unbind = Events.off;\n    // Allow the `Backbone` object to serve as a global event bus, for folks who\n    // want global \"pubsub\" in a convenient place.\n    _.extend(Backbone, Events);\n    // Backbone.Model\n    // --------------\n    // Backbone **Models** are the basic data object in the framework --\n    // frequently representing a row in a table in a database on your server.\n    // A discrete chunk of data and a bunch of useful, related methods for\n    // performing computations and transformations on that data.\n    // Create a new model with the specified attributes. A client id (`cid`)\n    // is automatically generated and assigned for you.\n    var Model = Backbone.Model = function(attributes, options) {\n        var attrs = attributes || {};\n        options || (options = {});\n        this.preinitialize.apply(this, arguments);\n        this.cid = _.uniqueId(this.cidPrefix);\n        this.attributes = {};\n        if (options.collection) this.collection = options.collection;\n        if (options.parse) attrs = this.parse(attrs, options) || {};\n        var defaults = _.result(this, \"defaults\");\n        // Just _.defaults would work fine, but the additional _.extends\n        // is in there for historical reasons. See #3843.\n        attrs = _.defaults(_.extend({}, defaults, attrs), defaults);\n        this.set(attrs, options);\n        this.changed = {};\n        this.initialize.apply(this, arguments);\n    };\n    // Attach all inheritable methods to the Model prototype.\n    _.extend(Model.prototype, Events, {\n        // A hash of attributes whose current and previous value differ.\n        changed: null,\n        // The value returned during the last failed validation.\n        validationError: null,\n        // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n        // CouchDB users may want to set this to `\"_id\"`.\n        idAttribute: \"id\",\n        // The prefix is used to create the client id which is used to identify models locally.\n        // You may want to override this if you're experiencing name clashes with model ids.\n        cidPrefix: \"c\",\n        // preinitialize is an empty function by default. You can override it with a function\n        // or object.  preinitialize will run before any instantiation logic is run in the Model.\n        preinitialize: function() {},\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function() {},\n        // Return a copy of the model's `attributes` object.\n        toJSON: function(options) {\n            return _.clone(this.attributes);\n        },\n        // Proxy `Backbone.sync` by default -- but override this if you need\n        // custom syncing semantics for *this* particular model.\n        sync: function() {\n            return Backbone.sync.apply(this, arguments);\n        },\n        // Get the value of an attribute.\n        get: function(attr) {\n            return this.attributes[attr];\n        },\n        // Get the HTML-escaped value of an attribute.\n        escape: function(attr) {\n            return _.escape(this.get(attr));\n        },\n        // Returns `true` if the attribute contains a value that is not null\n        // or undefined.\n        has: function(attr) {\n            return this.get(attr) != null;\n        },\n        // Special-cased proxy to underscore's `_.matches` method.\n        matches: function(attrs) {\n            return !!_.iteratee(attrs, this)(this.attributes);\n        },\n        // Set a hash of model attributes on the object, firing `\"change\"`. This is\n        // the core primitive operation of a model, updating the data and notifying\n        // anyone who needs to know about the change in state. The heart of the beast.\n        set: function(key, val, options) {\n            if (key == null) return this;\n            // Handle both `\"key\", value` and `{key: value}` -style arguments.\n            var attrs;\n            if (typeof key === \"object\") {\n                attrs = key;\n                options = val;\n            } else (attrs = {})[key] = val;\n            options || (options = {});\n            // Run validation.\n            if (!this._validate(attrs, options)) return false;\n            // Extract attributes and options.\n            var unset = options.unset;\n            var silent = options.silent;\n            var changes = [];\n            var changing = this._changing;\n            this._changing = true;\n            if (!changing) {\n                this._previousAttributes = _.clone(this.attributes);\n                this.changed = {};\n            }\n            var current = this.attributes;\n            var changed = this.changed;\n            var prev = this._previousAttributes;\n            // For each `set` attribute, update or delete the current value.\n            for(var attr in attrs){\n                val = attrs[attr];\n                if (!_.isEqual(current[attr], val)) changes.push(attr);\n                if (!_.isEqual(prev[attr], val)) changed[attr] = val;\n                else delete changed[attr];\n                unset ? delete current[attr] : current[attr] = val;\n            }\n            // Update the `id`.\n            if (this.idAttribute in attrs) {\n                var prevId = this.id;\n                this.id = this.get(this.idAttribute);\n                this.trigger(\"changeId\", this, prevId, options);\n            }\n            // Trigger all relevant attribute changes.\n            if (!silent) {\n                if (changes.length) this._pending = options;\n                for(var i = 0; i < changes.length; i++)this.trigger(\"change:\" + changes[i], this, current[changes[i]], options);\n            }\n            // You might be wondering why there's a `while` loop here. Changes can\n            // be recursively nested within `\"change\"` events.\n            if (changing) return this;\n            if (!silent) while(this._pending){\n                options = this._pending;\n                this._pending = false;\n                this.trigger(\"change\", this, options);\n            }\n            this._pending = false;\n            this._changing = false;\n            return this;\n        },\n        // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n        // if the attribute doesn't exist.\n        unset: function(attr, options) {\n            return this.set(attr, void 0, _.extend({}, options, {\n                unset: true\n            }));\n        },\n        // Clear all attributes on the model, firing `\"change\"`.\n        clear: function(options) {\n            var attrs = {};\n            for(var key in this.attributes)attrs[key] = void 0;\n            return this.set(attrs, _.extend({}, options, {\n                unset: true\n            }));\n        },\n        // Determine if the model has changed since the last `\"change\"` event.\n        // If you specify an attribute name, determine if that attribute has changed.\n        hasChanged: function(attr) {\n            if (attr == null) return !_.isEmpty(this.changed);\n            return _.has(this.changed, attr);\n        },\n        // Return an object containing all the attributes that have changed, or\n        // false if there are no changed attributes. Useful for determining what\n        // parts of a view need to be updated and/or what attributes need to be\n        // persisted to the server. Unset attributes will be set to undefined.\n        // You can also pass an attributes object to diff against the model,\n        // determining if there *would be* a change.\n        changedAttributes: function(diff) {\n            if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\n            var old = this._changing ? this._previousAttributes : this.attributes;\n            var changed = {};\n            var hasChanged;\n            for(var attr in diff){\n                var val = diff[attr];\n                if (_.isEqual(old[attr], val)) continue;\n                changed[attr] = val;\n                hasChanged = true;\n            }\n            return hasChanged ? changed : false;\n        },\n        // Get the previous value of an attribute, recorded at the time the last\n        // `\"change\"` event was fired.\n        previous: function(attr) {\n            if (attr == null || !this._previousAttributes) return null;\n            return this._previousAttributes[attr];\n        },\n        // Get all of the attributes of the model at the time of the previous\n        // `\"change\"` event.\n        previousAttributes: function() {\n            return _.clone(this._previousAttributes);\n        },\n        // Fetch the model from the server, merging the response with the model's\n        // local attributes. Any changed attributes will trigger a \"change\" event.\n        fetch: function(options) {\n            options = _.extend({\n                parse: true\n            }, options);\n            var model = this;\n            var success = options.success;\n            options.success = function(resp) {\n                var serverAttrs = options.parse ? model.parse(resp, options) : resp;\n                if (!model.set(serverAttrs, options)) return false;\n                if (success) success.call(options.context, model, resp, options);\n                model.trigger(\"sync\", model, resp, options);\n            };\n            wrapError(this, options);\n            return this.sync(\"read\", this, options);\n        },\n        // Set a hash of model attributes, and sync the model to the server.\n        // If the server returns an attributes hash that differs, the model's\n        // state will be `set` again.\n        save: function(key, val, options) {\n            // Handle both `\"key\", value` and `{key: value}` -style arguments.\n            var attrs;\n            if (key == null || typeof key === \"object\") {\n                attrs = key;\n                options = val;\n            } else (attrs = {})[key] = val;\n            options = _.extend({\n                validate: true,\n                parse: true\n            }, options);\n            var wait = options.wait;\n            // If we're not waiting and attributes exist, save acts as\n            // `set(attr).save(null, opts)` with validation. Otherwise, check if\n            // the model will be valid when the attributes, if any, are set.\n            if (attrs && !wait) {\n                if (!this.set(attrs, options)) return false;\n            } else if (!this._validate(attrs, options)) return false;\n            // After a successful server-side save, the client is (optionally)\n            // updated with the server-side state.\n            var model = this;\n            var success = options.success;\n            var attributes = this.attributes;\n            options.success = function(resp) {\n                // Ensure attributes are restored during synchronous saves.\n                model.attributes = attributes;\n                var serverAttrs = options.parse ? model.parse(resp, options) : resp;\n                if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);\n                if (serverAttrs && !model.set(serverAttrs, options)) return false;\n                if (success) success.call(options.context, model, resp, options);\n                model.trigger(\"sync\", model, resp, options);\n            };\n            wrapError(this, options);\n            // Set temporary attributes if `{wait: true}` to properly find new ids.\n            if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);\n            var method = this.isNew() ? \"create\" : options.patch ? \"patch\" : \"update\";\n            if (method === \"patch\" && !options.attrs) options.attrs = attrs;\n            var xhr = this.sync(method, this, options);\n            // Restore attributes.\n            this.attributes = attributes;\n            return xhr;\n        },\n        // Destroy this model on the server if it was already persisted.\n        // Optimistically removes the model from its collection, if it has one.\n        // If `wait: true` is passed, waits for the server to respond before removal.\n        destroy: function(options) {\n            options = options ? _.clone(options) : {};\n            var model = this;\n            var success = options.success;\n            var wait = options.wait;\n            var destroy = function() {\n                model.stopListening();\n                model.trigger(\"destroy\", model, model.collection, options);\n            };\n            options.success = function(resp) {\n                if (wait) destroy();\n                if (success) success.call(options.context, model, resp, options);\n                if (!model.isNew()) model.trigger(\"sync\", model, resp, options);\n            };\n            var xhr = false;\n            if (this.isNew()) _.defer(options.success);\n            else {\n                wrapError(this, options);\n                xhr = this.sync(\"delete\", this, options);\n            }\n            if (!wait) destroy();\n            return xhr;\n        },\n        // Default URL for the model's representation on the server -- if you're\n        // using Backbone's restful methods, override this to change the endpoint\n        // that will be called.\n        url: function() {\n            var base = _.result(this, \"urlRoot\") || _.result(this.collection, \"url\") || urlError();\n            if (this.isNew()) return base;\n            var id = this.get(this.idAttribute);\n            return base.replace(/[^\\/]$/, \"$&/\") + encodeURIComponent(id);\n        },\n        // **parse** converts a response into the hash of attributes to be `set` on\n        // the model. The default implementation is just to pass the response along.\n        parse: function(resp, options) {\n            return resp;\n        },\n        // Create a new model with identical attributes to this one.\n        clone: function() {\n            return new this.constructor(this.attributes);\n        },\n        // A model is new if it has never been saved to the server, and lacks an id.\n        isNew: function() {\n            return !this.has(this.idAttribute);\n        },\n        // Check if the model is currently in a valid state.\n        isValid: function(options) {\n            return this._validate({}, _.extend({}, options, {\n                validate: true\n            }));\n        },\n        // Run validation against the next complete set of model attributes,\n        // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n        _validate: function(attrs, options) {\n            if (!options.validate || !this.validate) return true;\n            attrs = _.extend({}, this.attributes, attrs);\n            var error = this.validationError = this.validate(attrs, options) || null;\n            if (!error) return true;\n            this.trigger(\"invalid\", this, error, _.extend(options, {\n                validationError: error\n            }));\n            return false;\n        }\n    });\n    // Backbone.Collection\n    // -------------------\n    // If models tend to represent a single row of data, a Backbone Collection is\n    // more analogous to a table full of data ... or a small slice or page of that\n    // table, or a collection of rows that belong together for a particular reason\n    // -- all of the messages in this particular folder, all of the documents\n    // belonging to this particular author, and so on. Collections maintain\n    // indexes of their models, both in order, and for lookup by `id`.\n    // Create a new **Collection**, perhaps to contain a specific type of `model`.\n    // If a `comparator` is specified, the Collection will maintain\n    // its models in sort order, as they're added and removed.\n    var Collection = Backbone.Collection = function(models, options) {\n        options || (options = {});\n        this.preinitialize.apply(this, arguments);\n        if (options.model) this.model = options.model;\n        if (options.comparator !== void 0) this.comparator = options.comparator;\n        this._reset();\n        this.initialize.apply(this, arguments);\n        if (models) this.reset(models, _.extend({\n            silent: true\n        }, options));\n    };\n    // Default options for `Collection#set`.\n    var setOptions = {\n        add: true,\n        remove: true,\n        merge: true\n    };\n    var addOptions = {\n        add: true,\n        remove: false\n    };\n    // Splices `insert` into `array` at index `at`.\n    var splice = function(array, insert, at) {\n        at = Math.min(Math.max(at, 0), array.length);\n        var tail = Array(array.length - at);\n        var length = insert.length;\n        var i;\n        for(i = 0; i < tail.length; i++)tail[i] = array[i + at];\n        for(i = 0; i < length; i++)array[i + at] = insert[i];\n        for(i = 0; i < tail.length; i++)array[i + length + at] = tail[i];\n    };\n    // Define the Collection's inheritable methods.\n    _.extend(Collection.prototype, Events, {\n        // The default model for a collection is just a **Backbone.Model**.\n        // This should be overridden in most cases.\n        model: Model,\n        // preinitialize is an empty function by default. You can override it with a function\n        // or object.  preinitialize will run before any instantiation logic is run in the Collection.\n        preinitialize: function() {},\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function() {},\n        // The JSON representation of a Collection is an array of the\n        // models' attributes.\n        toJSON: function(options) {\n            return this.map(function(model) {\n                return model.toJSON(options);\n            });\n        },\n        // Proxy `Backbone.sync` by default.\n        sync: function() {\n            return Backbone.sync.apply(this, arguments);\n        },\n        // Add a model, or list of models to the set. `models` may be Backbone\n        // Models or raw JavaScript objects to be converted to Models, or any\n        // combination of the two.\n        add: function(models, options) {\n            return this.set(models, _.extend({\n                merge: false\n            }, options, addOptions));\n        },\n        // Remove a model, or a list of models from the set.\n        remove: function(models, options) {\n            options = _.extend({}, options);\n            var singular = !_.isArray(models);\n            models = singular ? [\n                models\n            ] : models.slice();\n            var removed = this._removeModels(models, options);\n            if (!options.silent && removed.length) {\n                options.changes = {\n                    added: [],\n                    merged: [],\n                    removed: removed\n                };\n                this.trigger(\"update\", this, options);\n            }\n            return singular ? removed[0] : removed;\n        },\n        // Update a collection by `set`-ing a new list of models, adding new ones,\n        // removing models that are no longer present, and merging models that\n        // already exist in the collection, as necessary. Similar to **Model#set**,\n        // the core operation for updating the data contained by the collection.\n        set: function(models, options) {\n            if (models == null) return;\n            options = _.extend({}, setOptions, options);\n            if (options.parse && !this._isModel(models)) models = this.parse(models, options) || [];\n            var singular = !_.isArray(models);\n            models = singular ? [\n                models\n            ] : models.slice();\n            var at = options.at;\n            if (at != null) at = +at;\n            if (at > this.length) at = this.length;\n            if (at < 0) at += this.length + 1;\n            var set = [];\n            var toAdd = [];\n            var toMerge = [];\n            var toRemove = [];\n            var modelMap = {};\n            var add = options.add;\n            var merge = options.merge;\n            var remove = options.remove;\n            var sort = false;\n            var sortable = this.comparator && at == null && options.sort !== false;\n            var sortAttr = _.isString(this.comparator) ? this.comparator : null;\n            // Turn bare objects into model references, and prevent invalid models\n            // from being added.\n            var model, i;\n            for(i = 0; i < models.length; i++){\n                model = models[i];\n                // If a duplicate is found, prevent it from being added and\n                // optionally merge it into the existing model.\n                var existing = this.get(model);\n                if (existing) {\n                    if (merge && model !== existing) {\n                        var attrs = this._isModel(model) ? model.attributes : model;\n                        if (options.parse) attrs = existing.parse(attrs, options);\n                        existing.set(attrs, options);\n                        toMerge.push(existing);\n                        if (sortable && !sort) sort = existing.hasChanged(sortAttr);\n                    }\n                    if (!modelMap[existing.cid]) {\n                        modelMap[existing.cid] = true;\n                        set.push(existing);\n                    }\n                    models[i] = existing;\n                // If this is a new, valid model, push it to the `toAdd` list.\n                } else if (add) {\n                    model = models[i] = this._prepareModel(model, options);\n                    if (model) {\n                        toAdd.push(model);\n                        this._addReference(model, options);\n                        modelMap[model.cid] = true;\n                        set.push(model);\n                    }\n                }\n            }\n            // Remove stale models.\n            if (remove) {\n                for(i = 0; i < this.length; i++){\n                    model = this.models[i];\n                    if (!modelMap[model.cid]) toRemove.push(model);\n                }\n                if (toRemove.length) this._removeModels(toRemove, options);\n            }\n            // See if sorting is needed, update `length` and splice in new models.\n            var orderChanged = false;\n            var replace = !sortable && add && remove;\n            if (set.length && replace) {\n                orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {\n                    return m !== set[index];\n                });\n                this.models.length = 0;\n                splice(this.models, set, 0);\n                this.length = this.models.length;\n            } else if (toAdd.length) {\n                if (sortable) sort = true;\n                splice(this.models, toAdd, at == null ? this.length : at);\n                this.length = this.models.length;\n            }\n            // Silently sort the collection if appropriate.\n            if (sort) this.sort({\n                silent: true\n            });\n            // Unless silenced, it's time to fire all appropriate add/sort/update events.\n            if (!options.silent) {\n                for(i = 0; i < toAdd.length; i++){\n                    if (at != null) options.index = at + i;\n                    model = toAdd[i];\n                    model.trigger(\"add\", model, this, options);\n                }\n                if (sort || orderChanged) this.trigger(\"sort\", this, options);\n                if (toAdd.length || toRemove.length || toMerge.length) {\n                    options.changes = {\n                        added: toAdd,\n                        removed: toRemove,\n                        merged: toMerge\n                    };\n                    this.trigger(\"update\", this, options);\n                }\n            }\n            // Return the added (or merged) model (or models).\n            return singular ? models[0] : models;\n        },\n        // When you have more items than you want to add or remove individually,\n        // you can reset the entire set with a new list of models, without firing\n        // any granular `add` or `remove` events. Fires `reset` when finished.\n        // Useful for bulk operations and optimizations.\n        reset: function(models, options) {\n            options = options ? _.clone(options) : {};\n            for(var i = 0; i < this.models.length; i++)this._removeReference(this.models[i], options);\n            options.previousModels = this.models;\n            this._reset();\n            models = this.add(models, _.extend({\n                silent: true\n            }, options));\n            if (!options.silent) this.trigger(\"reset\", this, options);\n            return models;\n        },\n        // Add a model to the end of the collection.\n        push: function(model, options) {\n            return this.add(model, _.extend({\n                at: this.length\n            }, options));\n        },\n        // Remove a model from the end of the collection.\n        pop: function(options) {\n            var model = this.at(this.length - 1);\n            return this.remove(model, options);\n        },\n        // Add a model to the beginning of the collection.\n        unshift: function(model, options) {\n            return this.add(model, _.extend({\n                at: 0\n            }, options));\n        },\n        // Remove a model from the beginning of the collection.\n        shift: function(options) {\n            var model = this.at(0);\n            return this.remove(model, options);\n        },\n        // Slice out a sub-array of models from the collection.\n        slice: function() {\n            return slice.apply(this.models, arguments);\n        },\n        // Get a model from the set by id, cid, model object with id or cid\n        // properties, or an attributes object that is transformed through modelId.\n        get: function(obj) {\n            if (obj == null) return void 0;\n            return this._byId[obj] || this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj, obj.idAttribute)] || obj.cid && this._byId[obj.cid];\n        },\n        // Returns `true` if the model is in the collection.\n        has: function(obj) {\n            return this.get(obj) != null;\n        },\n        // Get the model at the given index.\n        at: function(index) {\n            if (index < 0) index += this.length;\n            return this.models[index];\n        },\n        // Return models with matching attributes. Useful for simple cases of\n        // `filter`.\n        where: function(attrs, first) {\n            return this[first ? \"find\" : \"filter\"](attrs);\n        },\n        // Return the first model with matching attributes. Useful for simple cases\n        // of `find`.\n        findWhere: function(attrs) {\n            return this.where(attrs, true);\n        },\n        // Force the collection to re-sort itself. You don't need to call this under\n        // normal circumstances, as the set will maintain sort order as each item\n        // is added.\n        sort: function(options) {\n            var comparator = this.comparator;\n            if (!comparator) throw new Error(\"Cannot sort a set without a comparator\");\n            options || (options = {});\n            var length = comparator.length;\n            if (_.isFunction(comparator)) comparator = comparator.bind(this);\n            // Run sort based on type of `comparator`.\n            if (length === 1 || _.isString(comparator)) this.models = this.sortBy(comparator);\n            else this.models.sort(comparator);\n            if (!options.silent) this.trigger(\"sort\", this, options);\n            return this;\n        },\n        // Pluck an attribute from each model in the collection.\n        pluck: function(attr) {\n            return this.map(attr + \"\");\n        },\n        // Fetch the default set of models for this collection, resetting the\n        // collection when they arrive. If `reset: true` is passed, the response\n        // data will be passed through the `reset` method instead of `set`.\n        fetch: function(options) {\n            options = _.extend({\n                parse: true\n            }, options);\n            var success = options.success;\n            var collection = this;\n            options.success = function(resp) {\n                var method = options.reset ? \"reset\" : \"set\";\n                collection[method](resp, options);\n                if (success) success.call(options.context, collection, resp, options);\n                collection.trigger(\"sync\", collection, resp, options);\n            };\n            wrapError(this, options);\n            return this.sync(\"read\", this, options);\n        },\n        // Create a new instance of a model in this collection. Add the model to the\n        // collection immediately, unless `wait: true` is passed, in which case we\n        // wait for the server to agree.\n        create: function(model, options) {\n            options = options ? _.clone(options) : {};\n            var wait = options.wait;\n            model = this._prepareModel(model, options);\n            if (!model) return false;\n            if (!wait) this.add(model, options);\n            var collection = this;\n            var success = options.success;\n            options.success = function(m, resp, callbackOpts) {\n                if (wait) {\n                    m.off(\"error\", this._forwardPristineError, this);\n                    collection.add(m, callbackOpts);\n                }\n                if (success) success.call(callbackOpts.context, m, resp, callbackOpts);\n            };\n            // In case of wait:true, our collection is not listening to any\n            // of the model's events yet, so it will not forward the error\n            // event. In this special case, we need to listen for it\n            // separately and handle the event just once.\n            // (The reason we don't need to do this for the sync event is\n            // in the success handler above: we add the model first, which\n            // causes the collection to listen, and then invoke the callback\n            // that triggers the event.)\n            if (wait) model.once(\"error\", this._forwardPristineError, this);\n            model.save(null, options);\n            return model;\n        },\n        // **parse** converts a response into a list of models to be added to the\n        // collection. The default implementation is just to pass it through.\n        parse: function(resp, options) {\n            return resp;\n        },\n        // Create a new collection with an identical list of models as this one.\n        clone: function() {\n            return new this.constructor(this.models, {\n                model: this.model,\n                comparator: this.comparator\n            });\n        },\n        // Define how to uniquely identify models in the collection.\n        modelId: function(attrs, idAttribute) {\n            return attrs[idAttribute || this.model.prototype.idAttribute || \"id\"];\n        },\n        // Get an iterator of all models in this collection.\n        values: function() {\n            return new CollectionIterator(this, ITERATOR_VALUES);\n        },\n        // Get an iterator of all model IDs in this collection.\n        keys: function() {\n            return new CollectionIterator(this, ITERATOR_KEYS);\n        },\n        // Get an iterator of all [ID, model] tuples in this collection.\n        entries: function() {\n            return new CollectionIterator(this, ITERATOR_KEYSVALUES);\n        },\n        // Private method to reset all internal state. Called when the collection\n        // is first initialized or reset.\n        _reset: function() {\n            this.length = 0;\n            this.models = [];\n            this._byId = {};\n        },\n        // Prepare a hash of attributes (or other model) to be added to this\n        // collection.\n        _prepareModel: function(attrs, options) {\n            if (this._isModel(attrs)) {\n                if (!attrs.collection) attrs.collection = this;\n                return attrs;\n            }\n            options = options ? _.clone(options) : {};\n            options.collection = this;\n            var model;\n            if (this.model.prototype) model = new this.model(attrs, options);\n            else // ES class methods didn't have prototype\n            model = this.model(attrs, options);\n            if (!model.validationError) return model;\n            this.trigger(\"invalid\", this, model.validationError, options);\n            return false;\n        },\n        // Internal method called by both remove and set.\n        _removeModels: function(models, options) {\n            var removed = [];\n            for(var i = 0; i < models.length; i++){\n                var model = this.get(models[i]);\n                if (!model) continue;\n                var index = this.indexOf(model);\n                this.models.splice(index, 1);\n                this.length--;\n                // Remove references before triggering 'remove' event to prevent an\n                // infinite loop. #3693\n                delete this._byId[model.cid];\n                var id = this.modelId(model.attributes, model.idAttribute);\n                if (id != null) delete this._byId[id];\n                if (!options.silent) {\n                    options.index = index;\n                    model.trigger(\"remove\", model, this, options);\n                }\n                removed.push(model);\n                this._removeReference(model, options);\n            }\n            if (models.length > 0 && !options.silent) delete options.index;\n            return removed;\n        },\n        // Method for checking whether an object should be considered a model for\n        // the purposes of adding to the collection.\n        _isModel: function(model) {\n            return model instanceof Model;\n        },\n        // Internal method to create a model's ties to a collection.\n        _addReference: function(model, options) {\n            this._byId[model.cid] = model;\n            var id = this.modelId(model.attributes, model.idAttribute);\n            if (id != null) this._byId[id] = model;\n            model.on(\"all\", this._onModelEvent, this);\n        },\n        // Internal method to sever a model's ties to a collection.\n        _removeReference: function(model, options) {\n            delete this._byId[model.cid];\n            var id = this.modelId(model.attributes, model.idAttribute);\n            if (id != null) delete this._byId[id];\n            if (this === model.collection) delete model.collection;\n            model.off(\"all\", this._onModelEvent, this);\n        },\n        // Internal method called every time a model in the set fires an event.\n        // Sets need to update their indexes when models change ids. All other\n        // events simply proxy through. \"add\" and \"remove\" events that originate\n        // in other collections are ignored.\n        _onModelEvent: function(event, model, collection, options) {\n            if (model) {\n                if ((event === \"add\" || event === \"remove\") && collection !== this) return;\n                if (event === \"destroy\") this.remove(model, options);\n                if (event === \"changeId\") {\n                    var prevId = this.modelId(model.previousAttributes(), model.idAttribute);\n                    var id = this.modelId(model.attributes, model.idAttribute);\n                    if (prevId != null) delete this._byId[prevId];\n                    if (id != null) this._byId[id] = model;\n                }\n            }\n            this.trigger.apply(this, arguments);\n        },\n        // Internal callback method used in `create`. It serves as a\n        // stand-in for the `_onModelEvent` method, which is not yet bound\n        // during the `wait` period of the `create` call. We still want to\n        // forward any `'error'` event at the end of the `wait` period,\n        // hence a customized callback.\n        _forwardPristineError: function(model, collection, options) {\n            // Prevent double forward if the model was already in the\n            // collection before the call to `create`.\n            if (this.has(model)) return;\n            this._onModelEvent(\"error\", model, collection, options);\n        }\n    });\n    // Defining an @@iterator method implements JavaScript's Iterable protocol.\n    // In modern ES2015 browsers, this value is found at Symbol.iterator.\n    /* global Symbol */ var $$iterator = typeof Symbol === \"function\" && Symbol.iterator;\n    if ($$iterator) Collection.prototype[$$iterator] = Collection.prototype.values;\n    // CollectionIterator\n    // ------------------\n    // A CollectionIterator implements JavaScript's Iterator protocol, allowing the\n    // use of `for of` loops in modern browsers and interoperation between\n    // Backbone.Collection and other JavaScript functions and third-party libraries\n    // which can operate on Iterables.\n    var CollectionIterator = function(collection, kind) {\n        this._collection = collection;\n        this._kind = kind;\n        this._index = 0;\n    };\n    // This \"enum\" defines the three possible kinds of values which can be emitted\n    // by a CollectionIterator that correspond to the values(), keys() and entries()\n    // methods on Collection, respectively.\n    var ITERATOR_VALUES = 1;\n    var ITERATOR_KEYS = 2;\n    var ITERATOR_KEYSVALUES = 3;\n    // All Iterators should themselves be Iterable.\n    if ($$iterator) CollectionIterator.prototype[$$iterator] = function() {\n        return this;\n    };\n    CollectionIterator.prototype.next = function() {\n        if (this._collection) {\n            // Only continue iterating if the iterated collection is long enough.\n            if (this._index < this._collection.length) {\n                var model = this._collection.at(this._index);\n                this._index++;\n                // Construct a value depending on what kind of values should be iterated.\n                var value;\n                if (this._kind === ITERATOR_VALUES) value = model;\n                else {\n                    var id = this._collection.modelId(model.attributes, model.idAttribute);\n                    if (this._kind === ITERATOR_KEYS) value = id;\n                    else value = [\n                        id,\n                        model\n                    ];\n                }\n                return {\n                    value: value,\n                    done: false\n                };\n            }\n            // Once exhausted, remove the reference to the collection so future\n            // calls to the next method always return done.\n            this._collection = void 0;\n        }\n        return {\n            value: void 0,\n            done: true\n        };\n    };\n    // Backbone.View\n    // -------------\n    // Backbone Views are almost more convention than they are actual code. A View\n    // is simply a JavaScript object that represents a logical chunk of UI in the\n    // DOM. This might be a single item, an entire list, a sidebar or panel, or\n    // even the surrounding frame which wraps your whole app. Defining a chunk of\n    // UI as a **View** allows you to define your DOM events declaratively, without\n    // having to worry about render order ... and makes it easy for the view to\n    // react to specific changes in the state of your models.\n    // Creating a Backbone.View creates its initial element outside of the DOM,\n    // if an existing element is not provided...\n    var View = Backbone.View = function(options) {\n        this.cid = _.uniqueId(\"view\");\n        this.preinitialize.apply(this, arguments);\n        _.extend(this, _.pick(options, viewOptions));\n        this._ensureElement();\n        this.initialize.apply(this, arguments);\n    };\n    // Cached regex to split keys for `delegate`.\n    var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n    // List of view options to be set as properties.\n    var viewOptions = [\n        \"model\",\n        \"collection\",\n        \"el\",\n        \"id\",\n        \"attributes\",\n        \"className\",\n        \"tagName\",\n        \"events\"\n    ];\n    // Set up all inheritable **Backbone.View** properties and methods.\n    _.extend(View.prototype, Events, {\n        // The default `tagName` of a View's element is `\"div\"`.\n        tagName: \"div\",\n        // jQuery delegate for element lookup, scoped to DOM elements within the\n        // current view. This should be preferred to global lookups where possible.\n        $: function(selector) {\n            return this.$el.find(selector);\n        },\n        // preinitialize is an empty function by default. You can override it with a function\n        // or object.  preinitialize will run before any instantiation logic is run in the View\n        preinitialize: function() {},\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function() {},\n        // **render** is the core function that your view should override, in order\n        // to populate its element (`this.el`), with the appropriate HTML. The\n        // convention is for **render** to always return `this`.\n        render: function() {\n            return this;\n        },\n        // Remove this view by taking the element out of the DOM, and removing any\n        // applicable Backbone.Events listeners.\n        remove: function() {\n            this._removeElement();\n            this.stopListening();\n            return this;\n        },\n        // Remove this view's element from the document and all event listeners\n        // attached to it. Exposed for subclasses using an alternative DOM\n        // manipulation API.\n        _removeElement: function() {\n            this.$el.remove();\n        },\n        // Change the view's element (`this.el` property) and re-delegate the\n        // view's events on the new element.\n        setElement: function(element) {\n            this.undelegateEvents();\n            this._setElement(element);\n            this.delegateEvents();\n            return this;\n        },\n        // Creates the `this.el` and `this.$el` references for this view using the\n        // given `el`. `el` can be a CSS selector or an HTML string, a jQuery\n        // context or an element. Subclasses can override this to utilize an\n        // alternative DOM manipulation API and are only required to set the\n        // `this.el` property.\n        _setElement: function(el) {\n            this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);\n            this.el = this.$el[0];\n        },\n        // Set callbacks, where `this.events` is a hash of\n        //\n        // *{\"event selector\": \"callback\"}*\n        //\n        //     {\n        //       'mousedown .title':  'edit',\n        //       'click .button':     'save',\n        //       'click .open':       function(e) { ... }\n        //     }\n        //\n        // pairs. Callbacks will be bound to the view, with `this` set properly.\n        // Uses event delegation for efficiency.\n        // Omitting the selector binds the event to `this.el`.\n        delegateEvents: function(events) {\n            events || (events = _.result(this, \"events\"));\n            if (!events) return this;\n            this.undelegateEvents();\n            for(var key in events){\n                var method = events[key];\n                if (!_.isFunction(method)) method = this[method];\n                if (!method) continue;\n                var match = key.match(delegateEventSplitter);\n                this.delegate(match[1], match[2], method.bind(this));\n            }\n            return this;\n        },\n        // Add a single event listener to the view's element (or a child element\n        // using `selector`). This only works for delegate-able events: not `focus`,\n        // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.\n        delegate: function(eventName, selector, listener) {\n            this.$el.on(eventName + \".delegateEvents\" + this.cid, selector, listener);\n            return this;\n        },\n        // Clears all callbacks previously bound to the view by `delegateEvents`.\n        // You usually don't need to use this, but may wish to if you have multiple\n        // Backbone views attached to the same DOM element.\n        undelegateEvents: function() {\n            if (this.$el) this.$el.off(\".delegateEvents\" + this.cid);\n            return this;\n        },\n        // A finer-grained `undelegateEvents` for removing a single delegated event.\n        // `selector` and `listener` are both optional.\n        undelegate: function(eventName, selector, listener) {\n            this.$el.off(eventName + \".delegateEvents\" + this.cid, selector, listener);\n            return this;\n        },\n        // Produces a DOM element to be assigned to your view. Exposed for\n        // subclasses using an alternative DOM manipulation API.\n        _createElement: function(tagName) {\n            return document.createElement(tagName);\n        },\n        // Ensure that the View has a DOM element to render into.\n        // If `this.el` is a string, pass it through `$()`, take the first\n        // matching element, and re-assign it to `el`. Otherwise, create\n        // an element from the `id`, `className` and `tagName` properties.\n        _ensureElement: function() {\n            if (!this.el) {\n                var attrs = _.extend({}, _.result(this, \"attributes\"));\n                if (this.id) attrs.id = _.result(this, \"id\");\n                if (this.className) attrs[\"class\"] = _.result(this, \"className\");\n                this.setElement(this._createElement(_.result(this, \"tagName\")));\n                this._setAttributes(attrs);\n            } else this.setElement(_.result(this, \"el\"));\n        },\n        // Set attributes from a hash on this view's element.  Exposed for\n        // subclasses using an alternative DOM manipulation API.\n        _setAttributes: function(attributes) {\n            this.$el.attr(attributes);\n        }\n    });\n    // Proxy Backbone class methods to Underscore functions, wrapping the model's\n    // `attributes` object or collection's `models` array behind the scenes.\n    //\n    // collection.filter(function(model) { return model.get('age') > 10 });\n    // collection.each(this.addView);\n    //\n    // `Function#apply` can be slow so we use the method's arg count, if we know it.\n    var addMethod = function(base, length, method, attribute) {\n        switch(length){\n            case 1:\n                return function() {\n                    return base[method](this[attribute]);\n                };\n            case 2:\n                return function(value) {\n                    return base[method](this[attribute], value);\n                };\n            case 3:\n                return function(iteratee, context) {\n                    return base[method](this[attribute], cb(iteratee, this), context);\n                };\n            case 4:\n                return function(iteratee, defaultVal, context) {\n                    return base[method](this[attribute], cb(iteratee, this), defaultVal, context);\n                };\n            default:\n                return function() {\n                    var args = slice.call(arguments);\n                    args.unshift(this[attribute]);\n                    return base[method].apply(base, args);\n                };\n        }\n    };\n    var addUnderscoreMethods = function(Class, base, methods, attribute) {\n        _.each(methods, function(length, method) {\n            if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute);\n        });\n    };\n    // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.\n    var cb = function(iteratee, instance) {\n        if (_.isFunction(iteratee)) return iteratee;\n        if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);\n        if (_.isString(iteratee)) return function(model) {\n            return model.get(iteratee);\n        };\n        return iteratee;\n    };\n    var modelMatcher = function(attrs) {\n        var matcher = _.matches(attrs);\n        return function(model) {\n            return matcher(model.attributes);\n        };\n    };\n    // Underscore methods that we want to implement on the Collection.\n    // 90% of the core usefulness of Backbone Collections is actually implemented\n    // right here:\n    var collectionMethods = {\n        forEach: 3,\n        each: 3,\n        map: 3,\n        collect: 3,\n        reduce: 0,\n        foldl: 0,\n        inject: 0,\n        reduceRight: 0,\n        foldr: 0,\n        find: 3,\n        detect: 3,\n        filter: 3,\n        select: 3,\n        reject: 3,\n        every: 3,\n        all: 3,\n        some: 3,\n        any: 3,\n        include: 3,\n        includes: 3,\n        contains: 3,\n        invoke: 0,\n        max: 3,\n        min: 3,\n        toArray: 1,\n        size: 1,\n        first: 3,\n        head: 3,\n        take: 3,\n        initial: 3,\n        rest: 3,\n        tail: 3,\n        drop: 3,\n        last: 3,\n        without: 0,\n        difference: 0,\n        indexOf: 3,\n        shuffle: 1,\n        lastIndexOf: 3,\n        isEmpty: 1,\n        chain: 1,\n        sample: 3,\n        partition: 3,\n        groupBy: 3,\n        countBy: 3,\n        sortBy: 3,\n        indexBy: 3,\n        findIndex: 3,\n        findLastIndex: 3\n    };\n    // Underscore methods that we want to implement on the Model, mapped to the\n    // number of arguments they take.\n    var modelMethods = {\n        keys: 1,\n        values: 1,\n        pairs: 1,\n        invert: 1,\n        pick: 0,\n        omit: 0,\n        chain: 1,\n        isEmpty: 1\n    };\n    // Mix in each Underscore method as a proxy to `Collection#models`.\n    _.each([\n        [\n            Collection,\n            collectionMethods,\n            \"models\"\n        ],\n        [\n            Model,\n            modelMethods,\n            \"attributes\"\n        ]\n    ], function(config) {\n        var Base = config[0], methods = config[1], attribute = config[2];\n        Base.mixin = function(obj) {\n            var mappings = _.reduce(_.functions(obj), function(memo, name) {\n                memo[name] = 0;\n                return memo;\n            }, {});\n            addUnderscoreMethods(Base, obj, mappings, attribute);\n        };\n        addUnderscoreMethods(Base, _, methods, attribute);\n    });\n    // Backbone.sync\n    // -------------\n    // Override this function to change the manner in which Backbone persists\n    // models to the server. You will be passed the type of request, and the\n    // model in question. By default, makes a RESTful Ajax request\n    // to the model's `url()`. Some possible customizations could be:\n    //\n    // * Use `setTimeout` to batch rapid-fire updates into a single request.\n    // * Send up the models as XML instead of JSON.\n    // * Persist models via WebSockets instead of Ajax.\n    //\n    // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n    // as `POST`, with a `_method` parameter containing the true HTTP method,\n    // as well as all requests with the body as `application/x-www-form-urlencoded`\n    // instead of `application/json` with the model in a param named `model`.\n    // Useful when interfacing with server-side languages like **PHP** that make\n    // it difficult to read the body of `PUT` requests.\n    Backbone.sync = function(method, model, options) {\n        var type = methodMap[method];\n        // Default options, unless specified.\n        _.defaults(options || (options = {}), {\n            emulateHTTP: Backbone.emulateHTTP,\n            emulateJSON: Backbone.emulateJSON\n        });\n        // Default JSON-request options.\n        var params = {\n            type: type,\n            dataType: \"json\"\n        };\n        // Ensure that we have a URL.\n        if (!options.url) params.url = _.result(model, \"url\") || urlError();\n        // Ensure that we have the appropriate request data.\n        if (options.data == null && model && (method === \"create\" || method === \"update\" || method === \"patch\")) {\n            params.contentType = \"application/json\";\n            params.data = JSON.stringify(options.attrs || model.toJSON(options));\n        }\n        // For older servers, emulate JSON by encoding the request into an HTML-form.\n        if (options.emulateJSON) {\n            params.contentType = \"application/x-www-form-urlencoded\";\n            params.data = params.data ? {\n                model: params.data\n            } : {};\n        }\n        // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n        // And an `X-HTTP-Method-Override` header.\n        if (options.emulateHTTP && (type === \"PUT\" || type === \"DELETE\" || type === \"PATCH\")) {\n            params.type = \"POST\";\n            if (options.emulateJSON) params.data._method = type;\n            var beforeSend = options.beforeSend;\n            options.beforeSend = function(xhr) {\n                xhr.setRequestHeader(\"X-HTTP-Method-Override\", type);\n                if (beforeSend) return beforeSend.apply(this, arguments);\n            };\n        }\n        // Don't process data on a non-GET request.\n        if (params.type !== \"GET\" && !options.emulateJSON) params.processData = false;\n        // Pass along `textStatus` and `errorThrown` from jQuery.\n        var error = options.error;\n        options.error = function(xhr, textStatus, errorThrown) {\n            options.textStatus = textStatus;\n            options.errorThrown = errorThrown;\n            if (error) error.call(options.context, xhr, textStatus, errorThrown);\n        };\n        // Make the request, allowing the user to override any Ajax options.\n        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\n        model.trigger(\"request\", model, xhr, options);\n        return xhr;\n    };\n    // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n    var methodMap = {\n        \"create\": \"POST\",\n        \"update\": \"PUT\",\n        \"patch\": \"PATCH\",\n        \"delete\": \"DELETE\",\n        \"read\": \"GET\"\n    };\n    // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n    // Override this if you'd like to use a different library.\n    Backbone.ajax = function() {\n        return Backbone.$.ajax.apply(Backbone.$, arguments);\n    };\n    // Backbone.Router\n    // ---------------\n    // Routers map faux-URLs to actions, and fire events when routes are\n    // matched. Creating a new one sets its `routes` hash, if not set statically.\n    var Router = Backbone.Router = function(options) {\n        options || (options = {});\n        this.preinitialize.apply(this, arguments);\n        if (options.routes) this.routes = options.routes;\n        this._bindRoutes();\n        this.initialize.apply(this, arguments);\n    };\n    // Cached regular expressions for matching named param parts and splatted\n    // parts of route strings.\n    var optionalParam = /\\((.*?)\\)/g;\n    var namedParam = /(\\(\\?)?:\\w+/g;\n    var splatParam = /\\*\\w+/g;\n    var escapeRegExp = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n    // Set up all inheritable **Backbone.Router** properties and methods.\n    _.extend(Router.prototype, Events, {\n        // preinitialize is an empty function by default. You can override it with a function\n        // or object.  preinitialize will run before any instantiation logic is run in the Router.\n        preinitialize: function() {},\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function() {},\n        // Manually bind a single named route to a callback. For example:\n        //\n        //     this.route('search/:query/p:num', 'search', function(query, num) {\n        //       ...\n        //     });\n        //\n        route: function(route, name, callback) {\n            if (!_.isRegExp(route)) route = this._routeToRegExp(route);\n            if (_.isFunction(name)) {\n                callback = name;\n                name = \"\";\n            }\n            if (!callback) callback = this[name];\n            var router = this;\n            Backbone.history.route(route, function(fragment) {\n                var args = router._extractParameters(route, fragment);\n                if (router.execute(callback, args, name) !== false) {\n                    router.trigger.apply(router, [\n                        \"route:\" + name\n                    ].concat(args));\n                    router.trigger(\"route\", name, args);\n                    Backbone.history.trigger(\"route\", router, name, args);\n                }\n            });\n            return this;\n        },\n        // Execute a route handler with the provided parameters.  This is an\n        // excellent place to do pre-route setup or post-route cleanup.\n        execute: function(callback, args, name) {\n            if (callback) callback.apply(this, args);\n        },\n        // Simple proxy to `Backbone.history` to save a fragment into the history.\n        navigate: function(fragment, options) {\n            Backbone.history.navigate(fragment, options);\n            return this;\n        },\n        // Bind all defined routes to `Backbone.history`. We have to reverse the\n        // order of the routes here to support behavior where the most general\n        // routes can be defined at the bottom of the route map.\n        _bindRoutes: function() {\n            if (!this.routes) return;\n            this.routes = _.result(this, \"routes\");\n            var route, routes = _.keys(this.routes);\n            while((route = routes.pop()) != null)this.route(route, this.routes[route]);\n        },\n        // Convert a route string into a regular expression, suitable for matching\n        // against the current location hash.\n        _routeToRegExp: function(route) {\n            route = route.replace(escapeRegExp, \"\\\\$&\").replace(optionalParam, \"(?:$1)?\").replace(namedParam, function(match, optional) {\n                return optional ? match : \"([^/?]+)\";\n            }).replace(splatParam, \"([^?]*?)\");\n            return new RegExp(\"^\" + route + \"(?:\\\\?([\\\\s\\\\S]*))?$\");\n        },\n        // Given a route, and a URL fragment that it matches, return the array of\n        // extracted decoded parameters. Empty or unmatched parameters will be\n        // treated as `null` to normalize cross-browser behavior.\n        _extractParameters: function(route, fragment) {\n            var params = route.exec(fragment).slice(1);\n            return _.map(params, function(param, i) {\n                // Don't decode the search params.\n                if (i === params.length - 1) return param || null;\n                return param ? decodeURIComponent(param) : null;\n            });\n        }\n    });\n    // Backbone.History\n    // ----------------\n    // Handles cross-browser history management, based on either\n    // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n    // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n    // and URL fragments. If the browser supports neither (old IE, natch),\n    // falls back to polling.\n    var History = Backbone.History = function() {\n        this.handlers = [];\n        this.checkUrl = this.checkUrl.bind(this);\n        // Ensure that `History` can be used outside of the browser.\n        if (typeof window !== \"undefined\") {\n            this.location = window.location;\n            this.history = window.history;\n        }\n    };\n    // Cached regex for stripping a leading hash/slash and trailing space.\n    var routeStripper = /^[#\\/]|\\s+$/g;\n    // Cached regex for stripping leading and trailing slashes.\n    var rootStripper = /^\\/+|\\/+$/g;\n    // Cached regex for stripping urls of hash.\n    var pathStripper = /#.*$/;\n    // Has the history handling already been started?\n    History.started = false;\n    // Set up all inheritable **Backbone.History** properties and methods.\n    _.extend(History.prototype, Events, {\n        // The default interval to poll for hash changes, if necessary, is\n        // twenty times a second.\n        interval: 50,\n        // Are we at the app root?\n        atRoot: function() {\n            var path = this.location.pathname.replace(/[^\\/]$/, \"$&/\");\n            return path === this.root && !this.getSearch();\n        },\n        // Does the pathname match the root?\n        matchRoot: function() {\n            var path = this.decodeFragment(this.location.pathname);\n            var rootPath = path.slice(0, this.root.length - 1) + \"/\";\n            return rootPath === this.root;\n        },\n        // Unicode characters in `location.pathname` are percent encoded so they're\n        // decoded for comparison. `%25` should not be decoded since it may be part\n        // of an encoded parameter.\n        decodeFragment: function(fragment) {\n            return decodeURI(fragment.replace(/%25/g, \"%2525\"));\n        },\n        // In IE6, the hash fragment and search params are incorrect if the\n        // fragment contains `?`.\n        getSearch: function() {\n            var match = this.location.href.replace(/#.*/, \"\").match(/\\?.+/);\n            return match ? match[0] : \"\";\n        },\n        // Gets the true hash value. Cannot use location.hash directly due to bug\n        // in Firefox where location.hash will always be decoded.\n        getHash: function(window1) {\n            var match = (window1 || this).location.href.match(/#(.*)$/);\n            return match ? match[1] : \"\";\n        },\n        // Get the pathname and search params, without the root.\n        getPath: function() {\n            var path = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);\n            return path.charAt(0) === \"/\" ? path.slice(1) : path;\n        },\n        // Get the cross-browser normalized URL fragment from the path or hash.\n        getFragment: function(fragment) {\n            if (fragment == null) {\n                if (this._usePushState || !this._wantsHashChange) fragment = this.getPath();\n                else fragment = this.getHash();\n            }\n            return fragment.replace(routeStripper, \"\");\n        },\n        // Start the hash change handling, returning `true` if the current URL matches\n        // an existing route, and `false` otherwise.\n        start: function(options) {\n            if (History.started) throw new Error(\"Backbone.history has already been started\");\n            History.started = true;\n            // Figure out the initial configuration. Do we need an iframe?\n            // Is pushState desired ... is it available?\n            this.options = _.extend({\n                root: \"/\"\n            }, this.options, options);\n            this.root = this.options.root;\n            this._trailingSlash = this.options.trailingSlash;\n            this._wantsHashChange = this.options.hashChange !== false;\n            this._hasHashChange = \"onhashchange\" in window && (document.documentMode === void 0 || document.documentMode > 7);\n            this._useHashChange = this._wantsHashChange && this._hasHashChange;\n            this._wantsPushState = !!this.options.pushState;\n            this._hasPushState = !!(this.history && this.history.pushState);\n            this._usePushState = this._wantsPushState && this._hasPushState;\n            this.fragment = this.getFragment();\n            // Normalize root to always include a leading and trailing slash.\n            this.root = (\"/\" + this.root + \"/\").replace(rootStripper, \"/\");\n            // Transition from hashChange to pushState or vice versa if both are\n            // requested.\n            if (this._wantsHashChange && this._wantsPushState) {\n                // If we've started off with a route from a `pushState`-enabled\n                // browser, but we're currently in a browser that doesn't support it...\n                if (!this._hasPushState && !this.atRoot()) {\n                    var rootPath = this.root.slice(0, -1) || \"/\";\n                    this.location.replace(rootPath + \"#\" + this.getPath());\n                    // Return immediately as browser will do redirect to new url\n                    return true;\n                // Or if we've started out with a hash-based route, but we're currently\n                // in a browser where it could be `pushState`-based instead...\n                } else if (this._hasPushState && this.atRoot()) this.navigate(this.getHash(), {\n                    replace: true\n                });\n            }\n            // Proxy an iframe to handle location events if the browser doesn't\n            // support the `hashchange` event, HTML5 history, or the user wants\n            // `hashChange` but not `pushState`.\n            if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {\n                this.iframe = document.createElement(\"iframe\");\n                this.iframe.src = \"javascript:0\";\n                this.iframe.style.display = \"none\";\n                this.iframe.tabIndex = -1;\n                var body = document.body;\n                // Using `appendChild` will throw on IE < 9 if the document is not ready.\n                var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;\n                iWindow.document.open();\n                iWindow.document.close();\n                iWindow.location.hash = \"#\" + this.fragment;\n            }\n            // Add a cross-platform `addEventListener` shim for older browsers.\n            var addEventListener = window.addEventListener || function(eventName, listener) {\n                return attachEvent(\"on\" + eventName, listener);\n            };\n            // Depending on whether we're using pushState or hashes, and whether\n            // 'onhashchange' is supported, determine how we check the URL state.\n            if (this._usePushState) addEventListener(\"popstate\", this.checkUrl, false);\n            else if (this._useHashChange && !this.iframe) addEventListener(\"hashchange\", this.checkUrl, false);\n            else if (this._wantsHashChange) this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n            if (!this.options.silent) return this.loadUrl();\n        },\n        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n        // but possibly useful for unit testing Routers.\n        stop: function() {\n            // Add a cross-platform `removeEventListener` shim for older browsers.\n            var removeEventListener = window.removeEventListener || function(eventName, listener) {\n                return detachEvent(\"on\" + eventName, listener);\n            };\n            // Remove window listeners.\n            if (this._usePushState) removeEventListener(\"popstate\", this.checkUrl, false);\n            else if (this._useHashChange && !this.iframe) removeEventListener(\"hashchange\", this.checkUrl, false);\n            // Clean up the iframe if necessary.\n            if (this.iframe) {\n                document.body.removeChild(this.iframe);\n                this.iframe = null;\n            }\n            // Some environments will throw when clearing an undefined interval.\n            if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\n            History.started = false;\n        },\n        // Add a route to be tested when the fragment changes. Routes added later\n        // may override previous routes.\n        route: function(route, callback) {\n            this.handlers.unshift({\n                route: route,\n                callback: callback\n            });\n        },\n        // Checks the current URL to see if it has changed, and if it has,\n        // calls `loadUrl`, normalizing across the hidden iframe.\n        checkUrl: function(e) {\n            var current = this.getFragment();\n            // If the user pressed the back button, the iframe's hash will have\n            // changed and we should use that for comparison.\n            if (current === this.fragment && this.iframe) current = this.getHash(this.iframe.contentWindow);\n            if (current === this.fragment) return false;\n            if (this.iframe) this.navigate(current);\n            this.loadUrl();\n        },\n        // Attempt to load the current URL fragment. If a route succeeds with a\n        // match, returns `true`. If no defined routes matches the fragment,\n        // returns `false`.\n        loadUrl: function(fragment) {\n            // If the root doesn't match, no routes can match either.\n            if (!this.matchRoot()) return false;\n            fragment = this.fragment = this.getFragment(fragment);\n            return _.some(this.handlers, function(handler) {\n                if (handler.route.test(fragment)) {\n                    handler.callback(fragment);\n                    return true;\n                }\n            });\n        },\n        // Save a fragment into the hash history, or replace the URL state if the\n        // 'replace' option is passed. You are responsible for properly URL-encoding\n        // the fragment in advance.\n        //\n        // The options object can contain `trigger: true` if you wish to have the\n        // route callback be fired (not usually desirable), or `replace: true`, if\n        // you wish to modify the current URL without adding an entry to the history.\n        navigate: function(fragment, options) {\n            if (!History.started) return false;\n            if (!options || options === true) options = {\n                trigger: !!options\n            };\n            // Normalize the fragment.\n            fragment = this.getFragment(fragment || \"\");\n            // Strip trailing slash on the root unless _trailingSlash is true\n            var rootPath = this.root;\n            if (!this._trailingSlash && (fragment === \"\" || fragment.charAt(0) === \"?\")) rootPath = rootPath.slice(0, -1) || \"/\";\n            var url = rootPath + fragment;\n            // Strip the fragment of the query and hash for matching.\n            fragment = fragment.replace(pathStripper, \"\");\n            // Decode for matching.\n            var decodedFragment = this.decodeFragment(fragment);\n            if (this.fragment === decodedFragment) return;\n            this.fragment = decodedFragment;\n            // If pushState is available, we use it to set the fragment as a real URL.\n            if (this._usePushState) this.history[options.replace ? \"replaceState\" : \"pushState\"]({}, document.title, url);\n            else if (this._wantsHashChange) {\n                this._updateHash(this.location, fragment, options.replace);\n                if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {\n                    var iWindow = this.iframe.contentWindow;\n                    // Opening and closing the iframe tricks IE7 and earlier to push a\n                    // history entry on hash-tag change.  When replace is true, we don't\n                    // want this.\n                    if (!options.replace) {\n                        iWindow.document.open();\n                        iWindow.document.close();\n                    }\n                    this._updateHash(iWindow.location, fragment, options.replace);\n                }\n            // If you've told us that you explicitly don't want fallback hashchange-\n            // based history, then `navigate` becomes a page refresh.\n            } else return this.location.assign(url);\n            if (options.trigger) return this.loadUrl(fragment);\n        },\n        // Update the hash location, either replacing the current entry, or adding\n        // a new one to the browser history.\n        _updateHash: function(location, fragment, replace) {\n            if (replace) {\n                var href = location.href.replace(/(javascript:|#).*$/, \"\");\n                location.replace(href + \"#\" + fragment);\n            } else // Some browsers require that `hash` contains a leading #.\n            location.hash = \"#\" + fragment;\n        }\n    });\n    // Create the default Backbone.history.\n    Backbone.history = new History;\n    // Helpers\n    // -------\n    // Helper function to correctly set up the prototype chain for subclasses.\n    // Similar to `goog.inherits`, but uses a hash of prototype properties and\n    // class properties to be extended.\n    var extend = function(protoProps, staticProps) {\n        var parent = this;\n        var child;\n        // The constructor function for the new subclass is either defined by you\n        // (the \"constructor\" property in your `extend` definition), or defaulted\n        // by us to simply call the parent constructor.\n        if (protoProps && _.has(protoProps, \"constructor\")) child = protoProps.constructor;\n        else child = function() {\n            return parent.apply(this, arguments);\n        };\n        // Add static properties to the constructor function, if supplied.\n        _.extend(child, parent, staticProps);\n        // Set the prototype chain to inherit from `parent`, without calling\n        // `parent`'s constructor function and add the prototype properties.\n        child.prototype = _.create(parent.prototype, protoProps);\n        child.prototype.constructor = child;\n        // Set a convenience property in case the parent's prototype is needed\n        // later.\n        child.__super__ = parent.prototype;\n        return child;\n    };\n    // Set up inheritance for the model, collection, router, view and history.\n    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\n    // Throw an error when a URL is needed, and none is supplied.\n    var urlError = function() {\n        throw new Error('A \"url\" property or function must be specified');\n    };\n    // Wrap an optional error callback with a fallback error event.\n    var wrapError = function(model, options) {\n        var error = options.error;\n        options.error = function(resp) {\n            if (error) error.call(options.context, model, resp, options);\n            model.trigger(\"error\", model, resp, options);\n        };\n    };\n    return Backbone;\n});\n\n});\n\nvar $f5012df62a53a94d$exports = {};\n\n\n/*! JointJS v3.7.1 (2023-04-28) - JavaScript diagramming library\n\n\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n*/ (function(global1, factory) {\n    factory($f5012df62a53a94d$exports, (parcelRequire(\"kL2Ep\")), (parcelRequire(\"6KOho\")));\n})($f5012df62a53a94d$exports, function(exports1, Backbone, $) {\n    \"use strict\";\n    Backbone = Backbone && Backbone.hasOwnProperty(\"default\") ? Backbone[\"default\"] : Backbone;\n    $ = $ && $.hasOwnProperty(\"default\") ? $[\"default\"] : $;\n    var commonjsGlobal = typeof window !== \"undefined\" ? window : typeof $parcel$global !== \"undefined\" ? $parcel$global : typeof self !== \"undefined\" ? self : {};\n    function commonjsRequire() {\n        throw new Error(\"Dynamic requires are not currently supported by rollup-plugin-commonjs\");\n    }\n    function unwrapExports(x) {\n        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x.default : x;\n    }\n    function createCommonjsModule(fn, module) {\n        return module = {\n            exports: {}\n        }, fn(module, module.exports), module.exports;\n    }\n    function getCjsExportFromNamespace(n) {\n        return n && n.default || n;\n    }\n    var check = function(it) {\n        return it && it.Math == Math && it;\n    };\n    // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n    var global_1 = // eslint-disable-next-line no-undef\n    check(typeof globalThis == \"object\" && globalThis) || check(typeof window == \"object\" && window) || check(typeof self == \"object\" && self) || check(typeof commonjsGlobal == \"object\" && commonjsGlobal) || // eslint-disable-next-line no-new-func\n    function() {\n        return this;\n    }() || Function(\"return this\")();\n    var fails = function(exec) {\n        try {\n            return !!exec();\n        } catch (error) {\n            return true;\n        }\n    };\n    // Detect IE8's incomplete defineProperty implementation\n    var descriptors = !fails(function() {\n        return Object.defineProperty({}, 1, {\n            get: function() {\n                return 7;\n            }\n        })[1] != 7;\n    });\n    \"use strict\";\n    var nativePropertyIsEnumerable = {}.propertyIsEnumerable;\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    // Nashorn ~ JDK8 bug\n    var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({\n        1: 2\n    }, 1);\n    // `Object.prototype.propertyIsEnumerable` method implementation\n    // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\n    var f = NASHORN_BUG ? function propertyIsEnumerable1(V) {\n        var descriptor = getOwnPropertyDescriptor(this, V);\n        return !!descriptor && descriptor.enumerable;\n    } : nativePropertyIsEnumerable;\n    var objectPropertyIsEnumerable = {\n        f: f\n    };\n    var createPropertyDescriptor = function(bitmap, value) {\n        return {\n            enumerable: !(bitmap & 1),\n            configurable: !(bitmap & 2),\n            writable: !(bitmap & 4),\n            value: value\n        };\n    };\n    var toString = {}.toString;\n    var classofRaw = function(it) {\n        return toString.call(it).slice(8, -1);\n    };\n    var split = \"\".split;\n    // fallback for non-array-like ES3 and non-enumerable old V8 strings\n    var indexedObject = fails(function() {\n        // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n        // eslint-disable-next-line no-prototype-builtins\n        return !Object(\"z\").propertyIsEnumerable(0);\n    }) ? function(it) {\n        return classofRaw(it) == \"String\" ? split.call(it, \"\") : Object(it);\n    } : Object;\n    // `RequireObjectCoercible` abstract operation\n    // https://tc39.es/ecma262/#sec-requireobjectcoercible\n    var requireObjectCoercible = function(it) {\n        if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n        return it;\n    };\n    // toObject with fallback for non-array-like ES3 strings\n    var toIndexedObject = function(it) {\n        return indexedObject(requireObjectCoercible(it));\n    };\n    var isObject = function(it) {\n        return typeof it === \"object\" ? it !== null : typeof it === \"function\";\n    };\n    // `ToPrimitive` abstract operation\n    // https://tc39.es/ecma262/#sec-toprimitive\n    // instead of the ES6 spec version, we didn't implement @@toPrimitive case\n    // and the second argument - flag - preferred type is a string\n    var toPrimitive = function(input, PREFERRED_STRING) {\n        if (!isObject(input)) return input;\n        var fn, val;\n        if (PREFERRED_STRING && typeof (fn = input.toString) == \"function\" && !isObject(val = fn.call(input))) return val;\n        if (typeof (fn = input.valueOf) == \"function\" && !isObject(val = fn.call(input))) return val;\n        if (!PREFERRED_STRING && typeof (fn = input.toString) == \"function\" && !isObject(val = fn.call(input))) return val;\n        throw TypeError(\"Can't convert object to primitive value\");\n    };\n    var hasOwnProperty$1 = {}.hasOwnProperty;\n    var has = function(it, key) {\n        return hasOwnProperty$1.call(it, key);\n    };\n    var document$1 = global_1.document;\n    // typeof document.createElement is 'object' in old IE\n    var EXISTS = isObject(document$1) && isObject(document$1.createElement);\n    var documentCreateElement = function(it) {\n        return EXISTS ? document$1.createElement(it) : {};\n    };\n    // Thank's IE8 for his funny defineProperty\n    var ie8DomDefine = !descriptors && !fails(function() {\n        return Object.defineProperty(documentCreateElement(\"div\"), \"a\", {\n            get: function() {\n                return 7;\n            }\n        }).a != 7;\n    });\n    var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    // `Object.getOwnPropertyDescriptor` method\n    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n    var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n        O = toIndexedObject(O);\n        P = toPrimitive(P, true);\n        if (ie8DomDefine) try {\n            return nativeGetOwnPropertyDescriptor(O, P);\n        } catch (error) {}\n        if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);\n    };\n    var objectGetOwnPropertyDescriptor = {\n        f: f$1\n    };\n    var anObject = function(it) {\n        if (!isObject(it)) throw TypeError(String(it) + \" is not an object\");\n        return it;\n    };\n    var nativeDefineProperty = Object.defineProperty;\n    // `Object.defineProperty` method\n    // https://tc39.es/ecma262/#sec-object.defineproperty\n    var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n        anObject(O);\n        P = toPrimitive(P, true);\n        anObject(Attributes);\n        if (ie8DomDefine) try {\n            return nativeDefineProperty(O, P, Attributes);\n        } catch (error) {}\n        if (\"get\" in Attributes || \"set\" in Attributes) throw TypeError(\"Accessors not supported\");\n        if (\"value\" in Attributes) O[P] = Attributes.value;\n        return O;\n    };\n    var objectDefineProperty = {\n        f: f$2\n    };\n    var createNonEnumerableProperty = descriptors ? function(object, key, value) {\n        return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));\n    } : function(object, key, value) {\n        object[key] = value;\n        return object;\n    };\n    var setGlobal = function(key, value) {\n        try {\n            createNonEnumerableProperty(global_1, key, value);\n        } catch (error) {\n            global_1[key] = value;\n        }\n        return value;\n    };\n    var SHARED = \"__core-js_shared__\";\n    var store = global_1[SHARED] || setGlobal(SHARED, {});\n    var sharedStore = store;\n    var functionToString = Function.toString;\n    // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper\n    if (typeof sharedStore.inspectSource != \"function\") sharedStore.inspectSource = function(it) {\n        return functionToString.call(it);\n    };\n    var inspectSource = sharedStore.inspectSource;\n    var WeakMap = global_1.WeakMap;\n    var nativeWeakMap = typeof WeakMap === \"function\" && /native code/.test(inspectSource(WeakMap));\n    var isPure = false;\n    var shared = createCommonjsModule(function(module) {\n        (module.exports = function(key, value) {\n            return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});\n        })(\"versions\", []).push({\n            version: \"3.8.3\",\n            mode: isPure ? \"pure\" : \"global\",\n            copyright: \"\\xa9 2021 Denis Pushkarev (zloirock.ru)\"\n        });\n    });\n    var id = 0;\n    var postfix = Math.random();\n    var uid = function(key) {\n        return \"Symbol(\" + String(key === undefined ? \"\" : key) + \")_\" + (++id + postfix).toString(36);\n    };\n    var keys = shared(\"keys\");\n    var sharedKey = function(key) {\n        return keys[key] || (keys[key] = uid(key));\n    };\n    var hiddenKeys = {};\n    var WeakMap$1 = global_1.WeakMap;\n    var set, get, has$1;\n    var enforce = function(it) {\n        return has$1(it) ? get(it) : set(it, {});\n    };\n    var getterFor = function(TYPE) {\n        return function(it) {\n            var state;\n            if (!isObject(it) || (state = get(it)).type !== TYPE) throw TypeError(\"Incompatible receiver, \" + TYPE + \" required\");\n            return state;\n        };\n    };\n    if (nativeWeakMap) {\n        var store$1 = sharedStore.state || (sharedStore.state = new WeakMap$1());\n        var wmget = store$1.get;\n        var wmhas = store$1.has;\n        var wmset = store$1.set;\n        set = function(it, metadata) {\n            metadata.facade = it;\n            wmset.call(store$1, it, metadata);\n            return metadata;\n        };\n        get = function(it) {\n            return wmget.call(store$1, it) || {};\n        };\n        has$1 = function(it) {\n            return wmhas.call(store$1, it);\n        };\n    } else {\n        var STATE = sharedKey(\"state\");\n        hiddenKeys[STATE] = true;\n        set = function(it, metadata) {\n            metadata.facade = it;\n            createNonEnumerableProperty(it, STATE, metadata);\n            return metadata;\n        };\n        get = function(it) {\n            return has(it, STATE) ? it[STATE] : {};\n        };\n        has$1 = function(it) {\n            return has(it, STATE);\n        };\n    }\n    var internalState = {\n        set: set,\n        get: get,\n        has: has$1,\n        enforce: enforce,\n        getterFor: getterFor\n    };\n    var internalState_1 = internalState.set;\n    var internalState_2 = internalState.get;\n    var internalState_3 = internalState.has;\n    var internalState_4 = internalState.enforce;\n    var internalState_5 = internalState.getterFor;\n    var redefine = createCommonjsModule(function(module) {\n        var getInternalState = internalState.get;\n        var enforceInternalState = internalState.enforce;\n        var TEMPLATE = String(String).split(\"String\");\n        (module.exports = function(O, key, value, options) {\n            var unsafe = options ? !!options.unsafe : false;\n            var simple = options ? !!options.enumerable : false;\n            var noTargetGet = options ? !!options.noTargetGet : false;\n            var state;\n            if (typeof value == \"function\") {\n                if (typeof key == \"string\" && !has(value, \"name\")) createNonEnumerableProperty(value, \"name\", key);\n                state = enforceInternalState(value);\n                if (!state.source) state.source = TEMPLATE.join(typeof key == \"string\" ? key : \"\");\n            }\n            if (O === global_1) {\n                if (simple) O[key] = value;\n                else setGlobal(key, value);\n                return;\n            } else if (!unsafe) delete O[key];\n            else if (!noTargetGet && O[key]) simple = true;\n            if (simple) O[key] = value;\n            else createNonEnumerableProperty(O, key, value);\n        // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n        })(Function.prototype, \"toString\", function toString() {\n            return typeof this == \"function\" && getInternalState(this).source || inspectSource(this);\n        });\n    });\n    var path = global_1;\n    var aFunction = function(variable) {\n        return typeof variable == \"function\" ? variable : undefined;\n    };\n    var getBuiltIn = function(namespace, method) {\n        return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];\n    };\n    var ceil = Math.ceil;\n    var floor = Math.floor;\n    // `ToInteger` abstract operation\n    // https://tc39.es/ecma262/#sec-tointeger\n    var toInteger = function(argument) {\n        return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n    };\n    var min = Math.min;\n    // `ToLength` abstract operation\n    // https://tc39.es/ecma262/#sec-tolength\n    var toLength = function(argument) {\n        return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n    };\n    var max = Math.max;\n    var min$1 = Math.min;\n    // Helper for a popular repeating case of the spec:\n    // Let integer be ? ToInteger(index).\n    // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n    var toAbsoluteIndex = function(index, length) {\n        var integer = toInteger(index);\n        return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n    };\n    // `Array.prototype.{ indexOf, includes }` methods implementation\n    var createMethod = function(IS_INCLUDES) {\n        return function($this, el, fromIndex) {\n            var O = toIndexedObject($this);\n            var length = toLength(O.length);\n            var index = toAbsoluteIndex(fromIndex, length);\n            var value;\n            // Array#includes uses SameValueZero equality algorithm\n            // eslint-disable-next-line no-self-compare\n            if (IS_INCLUDES && el != el) while(length > index){\n                value = O[index++];\n                // eslint-disable-next-line no-self-compare\n                if (value != value) return true;\n            // Array#indexOf ignores holes, Array#includes - not\n            }\n            else for(; length > index; index++){\n                if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n            }\n            return !IS_INCLUDES && -1;\n        };\n    };\n    var arrayIncludes = {\n        // `Array.prototype.includes` method\n        // https://tc39.es/ecma262/#sec-array.prototype.includes\n        includes: createMethod(true),\n        // `Array.prototype.indexOf` method\n        // https://tc39.es/ecma262/#sec-array.prototype.indexof\n        indexOf: createMethod(false)\n    };\n    var arrayIncludes_1 = arrayIncludes.includes;\n    var arrayIncludes_2 = arrayIncludes.indexOf;\n    var indexOf = arrayIncludes.indexOf;\n    var objectKeysInternal = function(object, names) {\n        var O = toIndexedObject(object);\n        var i = 0;\n        var result = [];\n        var key;\n        for(key in O)!has(hiddenKeys, key) && has(O, key) && result.push(key);\n        // Don't enum bug & hidden keys\n        while(names.length > i)if (has(O, key = names[i++])) ~indexOf(result, key) || result.push(key);\n        return result;\n    };\n    // IE8- don't enum bug keys\n    var enumBugKeys = [\n        \"constructor\",\n        \"hasOwnProperty\",\n        \"isPrototypeOf\",\n        \"propertyIsEnumerable\",\n        \"toLocaleString\",\n        \"toString\",\n        \"valueOf\"\n    ];\n    var hiddenKeys$1 = enumBugKeys.concat(\"length\", \"prototype\");\n    // `Object.getOwnPropertyNames` method\n    // https://tc39.es/ecma262/#sec-object.getownpropertynames\n    var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n        return objectKeysInternal(O, hiddenKeys$1);\n    };\n    var objectGetOwnPropertyNames = {\n        f: f$3\n    };\n    var f$4 = Object.getOwnPropertySymbols;\n    var objectGetOwnPropertySymbols = {\n        f: f$4\n    };\n    // all object keys, includes non-enumerable and symbols\n    var ownKeys = getBuiltIn(\"Reflect\", \"ownKeys\") || function ownKeys(it) {\n        var keys = objectGetOwnPropertyNames.f(anObject(it));\n        var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n        return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n    };\n    var copyConstructorProperties = function(target, source) {\n        var keys = ownKeys(source);\n        var defineProperty = objectDefineProperty.f;\n        var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n        for(var i = 0; i < keys.length; i++){\n            var key = keys[i];\n            if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n        }\n    };\n    var replacement = /#|\\.prototype\\./;\n    var isForced = function(feature, detection) {\n        var value = data[normalize(feature)];\n        return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == \"function\" ? fails(detection) : !!detection;\n    };\n    var normalize = isForced.normalize = function(string) {\n        return String(string).replace(replacement, \".\").toLowerCase();\n    };\n    var data = isForced.data = {};\n    var NATIVE = isForced.NATIVE = \"N\";\n    var POLYFILL = isForced.POLYFILL = \"P\";\n    var isForced_1 = isForced;\n    var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\n    /*\n\t  options.target      - name of the target object\n\t  options.global      - target is the global object\n\t  options.stat        - export as static methods of target\n\t  options.proto       - export as prototype methods of target\n\t  options.real        - real prototype method for the `pure` version\n\t  options.forced      - export even if the native feature is available\n\t  options.bind        - bind methods to the target, required for the `pure` version\n\t  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n\t  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n\t  options.sham        - add a flag to not completely full polyfills\n\t  options.enumerable  - export as enumerable property\n\t  options.noTargetGet - prevent calling a getter on target\n\t*/ var _export = function(options, source) {\n        var TARGET = options.target;\n        var GLOBAL = options.global;\n        var STATIC = options.stat;\n        var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n        if (GLOBAL) target = global_1;\n        else if (STATIC) target = global_1[TARGET] || setGlobal(TARGET, {});\n        else target = (global_1[TARGET] || {}).prototype;\n        if (target) for(key in source){\n            sourceProperty = source[key];\n            if (options.noTargetGet) {\n                descriptor = getOwnPropertyDescriptor$1(target, key);\n                targetProperty = descriptor && descriptor.value;\n            } else targetProperty = target[key];\n            FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n            // contained in target\n            if (!FORCED && targetProperty !== undefined) {\n                if (typeof sourceProperty === typeof targetProperty) continue;\n                copyConstructorProperties(sourceProperty, targetProperty);\n            }\n            // add a flag to not completely full polyfills\n            if (options.sham || targetProperty && targetProperty.sham) createNonEnumerableProperty(sourceProperty, \"sham\", true);\n            // extend global\n            redefine(target, key, sourceProperty, options);\n        }\n    };\n    var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function() {\n        // Chrome 38 Symbol has incorrect toString conversion\n        // eslint-disable-next-line no-undef\n        return !String(Symbol());\n    });\n    var useSymbolAsUid = nativeSymbol && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\n    var WellKnownSymbolsStore = shared(\"wks\");\n    var Symbol$1 = global_1.Symbol;\n    var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;\n    var wellKnownSymbol = function(name) {\n        if (!has(WellKnownSymbolsStore, name)) {\n            if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];\n            else WellKnownSymbolsStore[name] = createWellKnownSymbol(\"Symbol.\" + name);\n        }\n        return WellKnownSymbolsStore[name];\n    };\n    // `Object.keys` method\n    // https://tc39.es/ecma262/#sec-object.keys\n    var objectKeys = Object.keys || function keys(O) {\n        return objectKeysInternal(O, enumBugKeys);\n    };\n    // `Object.defineProperties` method\n    // https://tc39.es/ecma262/#sec-object.defineproperties\n    var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n        anObject(O);\n        var keys = objectKeys(Properties);\n        var length = keys.length;\n        var index = 0;\n        var key;\n        while(length > index)objectDefineProperty.f(O, key = keys[index++], Properties[key]);\n        return O;\n    };\n    var html = getBuiltIn(\"document\", \"documentElement\");\n    var GT = \">\";\n    var LT = \"<\";\n    var PROTOTYPE = \"prototype\";\n    var SCRIPT = \"script\";\n    var IE_PROTO = sharedKey(\"IE_PROTO\");\n    var EmptyConstructor = function() {};\n    var scriptTag = function(content) {\n        return LT + SCRIPT + GT + content + LT + \"/\" + SCRIPT + GT;\n    };\n    // Create object with fake `null` prototype: use ActiveX Object with cleared prototype\n    var NullProtoObjectViaActiveX = function(activeXDocument) {\n        activeXDocument.write(scriptTag(\"\"));\n        activeXDocument.close();\n        var temp = activeXDocument.parentWindow.Object;\n        activeXDocument = null; // avoid memory leak\n        return temp;\n    };\n    // Create object with fake `null` prototype: use iframe Object with cleared prototype\n    var NullProtoObjectViaIFrame = function() {\n        // Thrash, waste and sodomy: IE GC bug\n        var iframe = documentCreateElement(\"iframe\");\n        var JS = \"java\" + SCRIPT + \":\";\n        var iframeDocument;\n        iframe.style.display = \"none\";\n        html.appendChild(iframe);\n        // https://github.com/zloirock/core-js/issues/475\n        iframe.src = String(JS);\n        iframeDocument = iframe.contentWindow.document;\n        iframeDocument.open();\n        iframeDocument.write(scriptTag(\"document.F=Object\"));\n        iframeDocument.close();\n        return iframeDocument.F;\n    };\n    // Check for document.domain and active x support\n    // No need to use active x approach when document.domain is not set\n    // see https://github.com/es-shims/es5-shim/issues/150\n    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n    // avoid IE GC bug\n    var activeXDocument;\n    var NullProtoObject = function() {\n        try {\n            /* global ActiveXObject */ activeXDocument = document.domain && new ActiveXObject(\"htmlfile\");\n        } catch (error) {}\n        NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\n        var length = enumBugKeys.length;\n        while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n        return NullProtoObject();\n    };\n    hiddenKeys[IE_PROTO] = true;\n    // `Object.create` method\n    // https://tc39.es/ecma262/#sec-object.create\n    var objectCreate = Object.create || function create(O, Properties) {\n        var result;\n        if (O !== null) {\n            EmptyConstructor[PROTOTYPE] = anObject(O);\n            result = new EmptyConstructor();\n            EmptyConstructor[PROTOTYPE] = null;\n            // add \"__proto__\" for Object.getPrototypeOf polyfill\n            result[IE_PROTO] = O;\n        } else result = NullProtoObject();\n        return Properties === undefined ? result : objectDefineProperties(result, Properties);\n    };\n    var UNSCOPABLES = wellKnownSymbol(\"unscopables\");\n    var ArrayPrototype = Array.prototype;\n    // Array.prototype[@@unscopables]\n    // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n    if (ArrayPrototype[UNSCOPABLES] == undefined) objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {\n        configurable: true,\n        value: objectCreate(null)\n    });\n    // add a key to Array.prototype[@@unscopables]\n    var addToUnscopables = function(key) {\n        ArrayPrototype[UNSCOPABLES][key] = true;\n    };\n    var defineProperty = Object.defineProperty;\n    var cache = {};\n    var thrower = function(it) {\n        throw it;\n    };\n    var arrayMethodUsesToLength = function(METHOD_NAME, options) {\n        if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];\n        if (!options) options = {};\n        var method = [][METHOD_NAME];\n        var ACCESSORS = has(options, \"ACCESSORS\") ? options.ACCESSORS : false;\n        var argument0 = has(options, 0) ? options[0] : thrower;\n        var argument1 = has(options, 1) ? options[1] : undefined;\n        return cache[METHOD_NAME] = !!method && !fails(function() {\n            if (ACCESSORS && !descriptors) return true;\n            var O = {\n                length: -1\n            };\n            if (ACCESSORS) defineProperty(O, 1, {\n                enumerable: true,\n                get: thrower\n            });\n            else O[1] = 1;\n            method.call(O, argument0, argument1);\n        });\n    };\n    \"use strict\";\n    var $includes = arrayIncludes.includes;\n    var USES_TO_LENGTH = arrayMethodUsesToLength(\"indexOf\", {\n        ACCESSORS: true,\n        1: 0\n    });\n    // `Array.prototype.includes` method\n    // https://tc39.es/ecma262/#sec-array.prototype.includes\n    _export({\n        target: \"Array\",\n        proto: true,\n        forced: !USES_TO_LENGTH\n    }, {\n        includes: function includes(el /* , fromIndex = 0 */ ) {\n            return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n        }\n    });\n    // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n    addToUnscopables(\"includes\");\n    var es_array_includes = {};\n    var aFunction$1 = function(it) {\n        if (typeof it != \"function\") throw TypeError(String(it) + \" is not a function\");\n        return it;\n    };\n    // optional / simple context binding\n    var functionBindContext = function(fn, that, length) {\n        aFunction$1(fn);\n        if (that === undefined) return fn;\n        switch(length){\n            case 0:\n                return function() {\n                    return fn.call(that);\n                };\n            case 1:\n                return function(a) {\n                    return fn.call(that, a);\n                };\n            case 2:\n                return function(a, b) {\n                    return fn.call(that, a, b);\n                };\n            case 3:\n                return function(a, b, c) {\n                    return fn.call(that, a, b, c);\n                };\n        }\n        return function() {\n            return fn.apply(that, arguments);\n        };\n    };\n    var call = Function.call;\n    var entryUnbind = function(CONSTRUCTOR, METHOD, length) {\n        return functionBindContext(call, global_1[CONSTRUCTOR].prototype[METHOD], length);\n    };\n    var includes = entryUnbind(\"Array\", \"includes\");\n    var includes$1 = includes;\n    // `ToObject` abstract operation\n    // https://tc39.es/ecma262/#sec-toobject\n    var toObject = function(argument) {\n        return Object(requireObjectCoercible(argument));\n    };\n    // `IsArray` abstract operation\n    // https://tc39.es/ecma262/#sec-isarray\n    var isArray = Array.isArray || function isArray(arg) {\n        return classofRaw(arg) == \"Array\";\n    };\n    var SPECIES = wellKnownSymbol(\"species\");\n    // `ArraySpeciesCreate` abstract operation\n    // https://tc39.es/ecma262/#sec-arrayspeciescreate\n    var arraySpeciesCreate = function(originalArray, length) {\n        var C;\n        if (isArray(originalArray)) {\n            C = originalArray.constructor;\n            // cross-realm fallback\n            if (typeof C == \"function\" && (C === Array || isArray(C.prototype))) C = undefined;\n            else if (isObject(C)) {\n                C = C[SPECIES];\n                if (C === null) C = undefined;\n            }\n        }\n        return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n    };\n    var push = [].push;\n    // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation\n    var createMethod$1 = function(TYPE) {\n        var IS_MAP = TYPE == 1;\n        var IS_FILTER = TYPE == 2;\n        var IS_SOME = TYPE == 3;\n        var IS_EVERY = TYPE == 4;\n        var IS_FIND_INDEX = TYPE == 6;\n        var IS_FILTER_OUT = TYPE == 7;\n        var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n        return function($this, callbackfn, that, specificCreate) {\n            var O = toObject($this);\n            var self1 = indexedObject(O);\n            var boundFunction = functionBindContext(callbackfn, that, 3);\n            var length = toLength(self1.length);\n            var index = 0;\n            var create = specificCreate || arraySpeciesCreate;\n            var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;\n            var value, result;\n            for(; length > index; index++)if (NO_HOLES || index in self1) {\n                value = self1[index];\n                result = boundFunction(value, index, O);\n                if (TYPE) {\n                    if (IS_MAP) target[index] = result;\n                    else if (result) switch(TYPE){\n                        case 3:\n                            return true; // some\n                        case 5:\n                            return value; // find\n                        case 6:\n                            return index; // findIndex\n                        case 2:\n                            push.call(target, value); // filter\n                    }\n                    else switch(TYPE){\n                        case 4:\n                            return false; // every\n                        case 7:\n                            push.call(target, value); // filterOut\n                    }\n                }\n            }\n            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n        };\n    };\n    var arrayIteration = {\n        // `Array.prototype.forEach` method\n        // https://tc39.es/ecma262/#sec-array.prototype.foreach\n        forEach: createMethod$1(0),\n        // `Array.prototype.map` method\n        // https://tc39.es/ecma262/#sec-array.prototype.map\n        map: createMethod$1(1),\n        // `Array.prototype.filter` method\n        // https://tc39.es/ecma262/#sec-array.prototype.filter\n        filter: createMethod$1(2),\n        // `Array.prototype.some` method\n        // https://tc39.es/ecma262/#sec-array.prototype.some\n        some: createMethod$1(3),\n        // `Array.prototype.every` method\n        // https://tc39.es/ecma262/#sec-array.prototype.every\n        every: createMethod$1(4),\n        // `Array.prototype.find` method\n        // https://tc39.es/ecma262/#sec-array.prototype.find\n        find: createMethod$1(5),\n        // `Array.prototype.findIndex` method\n        // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n        findIndex: createMethod$1(6),\n        // `Array.prototype.filterOut` method\n        // https://github.com/tc39/proposal-array-filtering\n        filterOut: createMethod$1(7)\n    };\n    var arrayIteration_1 = arrayIteration.forEach;\n    var arrayIteration_2 = arrayIteration.map;\n    var arrayIteration_3 = arrayIteration.filter;\n    var arrayIteration_4 = arrayIteration.some;\n    var arrayIteration_5 = arrayIteration.every;\n    var arrayIteration_6 = arrayIteration.find;\n    var arrayIteration_7 = arrayIteration.findIndex;\n    var arrayIteration_8 = arrayIteration.filterOut;\n    \"use strict\";\n    var $find = arrayIteration.find;\n    var FIND = \"find\";\n    var SKIPS_HOLES = true;\n    var USES_TO_LENGTH$1 = arrayMethodUsesToLength(FIND);\n    // Shouldn't skip holes\n    if (FIND in []) Array(1)[FIND](function() {\n        SKIPS_HOLES = false;\n    });\n    // `Array.prototype.find` method\n    // https://tc39.es/ecma262/#sec-array.prototype.find\n    _export({\n        target: \"Array\",\n        proto: true,\n        forced: SKIPS_HOLES || !USES_TO_LENGTH$1\n    }, {\n        find: function find(callbackfn /* , that = undefined */ ) {\n            return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n        }\n    });\n    // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n    addToUnscopables(FIND);\n    var es_array_find = {};\n    var find = entryUnbind(\"Array\", \"find\");\n    var find$1 = find;\n    // `String.prototype.{ codePointAt, at }` methods implementation\n    var createMethod$2 = function(CONVERT_TO_STRING) {\n        return function($this, pos) {\n            var S = String(requireObjectCoercible($this));\n            var position = toInteger(pos);\n            var size = S.length;\n            var first, second;\n            if (position < 0 || position >= size) return CONVERT_TO_STRING ? \"\" : undefined;\n            first = S.charCodeAt(position);\n            return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n        };\n    };\n    var stringMultibyte = {\n        // `String.prototype.codePointAt` method\n        // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n        codeAt: createMethod$2(false),\n        // `String.prototype.at` method\n        // https://github.com/mathiasbynens/String.prototype.at\n        charAt: createMethod$2(true)\n    };\n    var stringMultibyte_1 = stringMultibyte.codeAt;\n    var stringMultibyte_2 = stringMultibyte.charAt;\n    var correctPrototypeGetter = !fails(function() {\n        function F() {}\n        F.prototype.constructor = null;\n        return Object.getPrototypeOf(new F()) !== F.prototype;\n    });\n    var IE_PROTO$1 = sharedKey(\"IE_PROTO\");\n    var ObjectPrototype = Object.prototype;\n    // `Object.getPrototypeOf` method\n    // https://tc39.es/ecma262/#sec-object.getprototypeof\n    var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function(O) {\n        O = toObject(O);\n        if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];\n        if (typeof O.constructor == \"function\" && O instanceof O.constructor) return O.constructor.prototype;\n        return O instanceof Object ? ObjectPrototype : null;\n    };\n    \"use strict\";\n    var ITERATOR = wellKnownSymbol(\"iterator\");\n    var BUGGY_SAFARI_ITERATORS = false;\n    var returnThis = function() {\n        return this;\n    };\n    // `%IteratorPrototype%` object\n    // https://tc39.es/ecma262/#sec-%iteratorprototype%-object\n    var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n    if ([].keys) {\n        arrayIterator = [].keys();\n        // Safari 8 has buggy iterators w/o `next`\n        if (!(\"next\" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n        else {\n            PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));\n            if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n        }\n    }\n    var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function() {\n        var test = {};\n        // FF44- legacy iterators case\n        return IteratorPrototype[ITERATOR].call(test) !== test;\n    });\n    if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\n    // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n    if ((!isPure || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\n    var iteratorsCore = {\n        IteratorPrototype: IteratorPrototype,\n        BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n    };\n    var iteratorsCore_1 = iteratorsCore.IteratorPrototype;\n    var iteratorsCore_2 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n    var defineProperty$1 = objectDefineProperty.f;\n    var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n    var setToStringTag = function(it, TAG, STATIC) {\n        if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) defineProperty$1(it, TO_STRING_TAG, {\n            configurable: true,\n            value: TAG\n        });\n    };\n    var iterators = {};\n    \"use strict\";\n    var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\n    var returnThis$1 = function() {\n        return this;\n    };\n    var createIteratorConstructor = function(IteratorConstructor, NAME, next) {\n        var TO_STRING_TAG = NAME + \" Iterator\";\n        IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {\n            next: createPropertyDescriptor(1, next)\n        });\n        setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n        iterators[TO_STRING_TAG] = returnThis$1;\n        return IteratorConstructor;\n    };\n    var aPossiblePrototype = function(it) {\n        if (!isObject(it) && it !== null) throw TypeError(\"Can't set \" + String(it) + \" as a prototype\");\n        return it;\n    };\n    // `Object.setPrototypeOf` method\n    // https://tc39.es/ecma262/#sec-object.setprototypeof\n    // Works with __proto__ only. Old v8 can't work with null proto objects.\n    /* eslint-disable no-proto */ var objectSetPrototypeOf = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n        var CORRECT_SETTER = false;\n        var test = {};\n        var setter;\n        try {\n            setter = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set;\n            setter.call(test, []);\n            CORRECT_SETTER = test instanceof Array;\n        } catch (error) {}\n        return function setPrototypeOf(O, proto) {\n            anObject(O);\n            aPossiblePrototype(proto);\n            if (CORRECT_SETTER) setter.call(O, proto);\n            else O.__proto__ = proto;\n            return O;\n        };\n    }() : undefined);\n    \"use strict\";\n    var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;\n    var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n    var ITERATOR$1 = wellKnownSymbol(\"iterator\");\n    var KEYS = \"keys\";\n    var VALUES = \"values\";\n    var ENTRIES = \"entries\";\n    var returnThis$2 = function() {\n        return this;\n    };\n    var defineIterator = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n        createIteratorConstructor(IteratorConstructor, NAME, next);\n        var getIterationMethod = function(KIND) {\n            if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n            if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];\n            switch(KIND){\n                case KEYS:\n                    return function keys() {\n                        return new IteratorConstructor(this, KIND);\n                    };\n                case VALUES:\n                    return function values() {\n                        return new IteratorConstructor(this, KIND);\n                    };\n                case ENTRIES:\n                    return function entries() {\n                        return new IteratorConstructor(this, KIND);\n                    };\n            }\n            return function() {\n                return new IteratorConstructor(this);\n            };\n        };\n        var TO_STRING_TAG = NAME + \" Iterator\";\n        var INCORRECT_VALUES_NAME = false;\n        var IterablePrototype = Iterable.prototype;\n        var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype[\"@@iterator\"] || DEFAULT && IterablePrototype[DEFAULT];\n        var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);\n        var anyNativeIterator = NAME == \"Array\" ? IterablePrototype.entries || nativeIterator : nativeIterator;\n        var CurrentIteratorPrototype, methods, KEY;\n        // fix native\n        if (anyNativeIterator) {\n            CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));\n            if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {\n                if (!isPure && objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {\n                    if (objectSetPrototypeOf) objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);\n                    else if (typeof CurrentIteratorPrototype[ITERATOR$1] != \"function\") createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);\n                }\n                // Set @@toStringTag to native iterators\n                setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n                if (isPure) iterators[TO_STRING_TAG] = returnThis$2;\n            }\n        }\n        // fix Array#{values, @@iterator}.name in V8 / FF\n        if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n            INCORRECT_VALUES_NAME = true;\n            defaultIterator = function values() {\n                return nativeIterator.call(this);\n            };\n        }\n        // define iterator\n        if ((!isPure || FORCED) && IterablePrototype[ITERATOR$1] !== defaultIterator) createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);\n        iterators[NAME] = defaultIterator;\n        // export additional methods\n        if (DEFAULT) {\n            methods = {\n                values: getIterationMethod(VALUES),\n                keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n                entries: getIterationMethod(ENTRIES)\n            };\n            if (FORCED) {\n                for(KEY in methods)if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) redefine(IterablePrototype, KEY, methods[KEY]);\n            } else _export({\n                target: NAME,\n                proto: true,\n                forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME\n            }, methods);\n        }\n        return methods;\n    };\n    \"use strict\";\n    var charAt = stringMultibyte.charAt;\n    var STRING_ITERATOR = \"String Iterator\";\n    var setInternalState = internalState.set;\n    var getInternalState = internalState.getterFor(STRING_ITERATOR);\n    // `String.prototype[@@iterator]` method\n    // https://tc39.es/ecma262/#sec-string.prototype-@@iterator\n    defineIterator(String, \"String\", function(iterated) {\n        setInternalState(this, {\n            type: STRING_ITERATOR,\n            string: String(iterated),\n            index: 0\n        });\n    // `%StringIteratorPrototype%.next` method\n    // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n    }, function next() {\n        var state = getInternalState(this);\n        var string = state.string;\n        var index = state.index;\n        var point;\n        if (index >= string.length) return {\n            value: undefined,\n            done: true\n        };\n        point = charAt(string, index);\n        state.index += point.length;\n        return {\n            value: point,\n            done: false\n        };\n    });\n    var es_string_iterator = {};\n    var iteratorClose = function(iterator) {\n        var returnMethod = iterator[\"return\"];\n        if (returnMethod !== undefined) return anObject(returnMethod.call(iterator)).value;\n    };\n    // call something on iterator step with safe closing on error\n    var callWithSafeIterationClosing = function(iterator, fn, value, ENTRIES) {\n        try {\n            return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n        // 7.4.6 IteratorClose(iterator, completion)\n        } catch (error) {\n            iteratorClose(iterator);\n            throw error;\n        }\n    };\n    var ITERATOR$2 = wellKnownSymbol(\"iterator\");\n    var ArrayPrototype$1 = Array.prototype;\n    // check on default Array iterator\n    var isArrayIteratorMethod = function(it) {\n        return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$2] === it);\n    };\n    \"use strict\";\n    var createProperty = function(object, key, value) {\n        var propertyKey = toPrimitive(key);\n        if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));\n        else object[propertyKey] = value;\n    };\n    var TO_STRING_TAG$1 = wellKnownSymbol(\"toStringTag\");\n    var test = {};\n    test[TO_STRING_TAG$1] = \"z\";\n    var toStringTagSupport = String(test) === \"[object z]\";\n    var TO_STRING_TAG$2 = wellKnownSymbol(\"toStringTag\");\n    // ES3 wrong here\n    var CORRECT_ARGUMENTS = classofRaw(function() {\n        return arguments;\n    }()) == \"Arguments\";\n    // fallback for IE11 Script Access Denied error\n    var tryGet = function(it, key) {\n        try {\n            return it[key];\n        } catch (error) {}\n    };\n    // getting tag from ES6+ `Object.prototype.toString`\n    var classof = toStringTagSupport ? classofRaw : function(it) {\n        var O, tag, result;\n        return it === undefined ? \"Undefined\" : it === null ? \"Null\" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == \"Object\" && typeof O.callee == \"function\" ? \"Arguments\" : result;\n    };\n    var ITERATOR$3 = wellKnownSymbol(\"iterator\");\n    var getIteratorMethod = function(it) {\n        if (it != undefined) return it[ITERATOR$3] || it[\"@@iterator\"] || iterators[classof(it)];\n    };\n    \"use strict\";\n    // `Array.from` method implementation\n    // https://tc39.es/ecma262/#sec-array.from\n    var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */ ) {\n        var O = toObject(arrayLike);\n        var C = typeof this == \"function\" ? this : Array;\n        var argumentsLength = arguments.length;\n        var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n        var mapping = mapfn !== undefined;\n        var iteratorMethod = getIteratorMethod(O);\n        var index = 0;\n        var length, result, step, iterator, next, value;\n        if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);\n        // if the target is not iterable or it's an array with the default iterator - use a simple case\n        if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n            iterator = iteratorMethod.call(O);\n            next = iterator.next;\n            result = new C();\n            for(; !(step = next.call(iterator)).done; index++){\n                value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [\n                    step.value,\n                    index\n                ], true) : step.value;\n                createProperty(result, index, value);\n            }\n        } else {\n            length = toLength(O.length);\n            result = new C(length);\n            for(; length > index; index++){\n                value = mapping ? mapfn(O[index], index) : O[index];\n                createProperty(result, index, value);\n            }\n        }\n        result.length = index;\n        return result;\n    };\n    var ITERATOR$4 = wellKnownSymbol(\"iterator\");\n    var SAFE_CLOSING = false;\n    try {\n        var called = 0;\n        var iteratorWithReturn = {\n            next: function() {\n                return {\n                    done: !!called++\n                };\n            },\n            \"return\": function() {\n                SAFE_CLOSING = true;\n            }\n        };\n        iteratorWithReturn[ITERATOR$4] = function() {\n            return this;\n        };\n        // eslint-disable-next-line no-throw-literal\n        Array.from(iteratorWithReturn, function() {\n            throw 2;\n        });\n    } catch (error) {}\n    var checkCorrectnessOfIteration = function(exec, SKIP_CLOSING) {\n        if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n        var ITERATION_SUPPORT = false;\n        try {\n            var object = {};\n            object[ITERATOR$4] = function() {\n                return {\n                    next: function() {\n                        return {\n                            done: ITERATION_SUPPORT = true\n                        };\n                    }\n                };\n            };\n            exec(object);\n        } catch (error) {}\n        return ITERATION_SUPPORT;\n    };\n    var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {\n        Array.from(iterable);\n    });\n    // `Array.from` method\n    // https://tc39.es/ecma262/#sec-array.from\n    _export({\n        target: \"Array\",\n        stat: true,\n        forced: INCORRECT_ITERATION\n    }, {\n        from: arrayFrom\n    });\n    var es_array_from = {};\n    var from_1 = path.Array.from;\n    var from_1$1 = from_1;\n    \"use strict\";\n    var $findIndex = arrayIteration.findIndex;\n    var FIND_INDEX = \"findIndex\";\n    var SKIPS_HOLES$1 = true;\n    var USES_TO_LENGTH$2 = arrayMethodUsesToLength(FIND_INDEX);\n    // Shouldn't skip holes\n    if (FIND_INDEX in []) Array(1)[FIND_INDEX](function() {\n        SKIPS_HOLES$1 = false;\n    });\n    // `Array.prototype.findIndex` method\n    // https://tc39.es/ecma262/#sec-array.prototype.findindex\n    _export({\n        target: \"Array\",\n        proto: true,\n        forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$2\n    }, {\n        findIndex: function findIndex(callbackfn /* , that = undefined */ ) {\n            return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n        }\n    });\n    // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n    addToUnscopables(FIND_INDEX);\n    var es_array_findIndex = {};\n    var findIndex = entryUnbind(\"Array\", \"findIndex\");\n    var findIndex$1 = findIndex;\n    var base64 = createCommonjsModule(function(module, exports1) {\n        (function() {\n            /**\n\t     * version: 0.3.0\n\t     * git://github.com/davidchambers/Base64.js.git\n\t     */ var object = exports1; // #8: web workers\n            var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n            function InvalidCharacterError(message) {\n                this.message = message;\n            }\n            InvalidCharacterError.prototype = new Error;\n            InvalidCharacterError.prototype.name = \"InvalidCharacterError\";\n            // encoder\n            // [https://gist.github.com/999166] by [https://github.com/nignag]\n            object.btoa || (object.btoa = function(input) {\n                var str = String(input);\n                for(// initialize result and counter\n                var block, charCode, idx = 0, map = chars, output = \"\"; // if the next str index does not exist:\n                //   change the mapping table to \"=\"\n                //   check if d has no fractional digits\n                str.charAt(idx | 0) || (map = \"=\", idx % 1); // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n                output += map.charAt(63 & block >> 8 - idx % 1 * 8)){\n                    charCode = str.charCodeAt(idx += 3 / 4);\n                    if (charCode > 0xFF) throw new InvalidCharacterError(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n                    block = block << 8 | charCode;\n                }\n                return output;\n            });\n            // decoder\n            // [https://gist.github.com/1020396] by [https://github.com/atk]\n            object.atob || (object.atob = function(input) {\n                var str = String(input).replace(/=+$/, \"\");\n                if (str.length % 4 == 1) throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n                for(// initialize result and counters\n                var bc = 0, bs, buffer, idx = 0, output = \"\"; // get next character\n                // eslint-disable-next-line no-cond-assign\n                buffer = str.charAt(idx++); // character found in table? initialize bit storage and add its ascii value;\n                ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,\n                // convert the first 8 bits to one ascii character\n                bc++ % 4) && (output += String.fromCharCode(255 & bs >> (-2 * bc & 6))))// try to find character in table (0-63, not found => -1)\n                buffer = chars.indexOf(buffer);\n                return output;\n            });\n        })();\n    });\n    // `Number.isNaN` method\n    // https://tc39.es/ecma262/#sec-number.isnan\n    _export({\n        target: \"Number\",\n        stat: true\n    }, {\n        isNaN: function isNaN1(number) {\n            // eslint-disable-next-line no-self-compare\n            return number != number;\n        }\n    });\n    var es_number_isNan = {};\n    var isNan = path.Number.isNaN;\n    var isNan$1 = isNan;\n    var globalIsFinite = global_1.isFinite;\n    // `Number.isFinite` method\n    // https://tc39.es/ecma262/#sec-number.isfinite\n    var numberIsFinite = Number.isFinite || function isFinite1(it) {\n        return typeof it == \"number\" && globalIsFinite(it);\n    };\n    // `Number.isFinite` method\n    // https://tc39.es/ecma262/#sec-number.isfinite\n    _export({\n        target: \"Number\",\n        stat: true\n    }, {\n        isFinite: numberIsFinite\n    });\n    var es_number_isFinite = {};\n    var _isFinite = path.Number.isFinite;\n    var _isFinite$1 = _isFinite;\n    var MATCH = wellKnownSymbol(\"match\");\n    // `IsRegExp` abstract operation\n    // https://tc39.es/ecma262/#sec-isregexp\n    var isRegexp = function(it) {\n        var isRegExp;\n        return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == \"RegExp\");\n    };\n    var notARegexp = function(it) {\n        if (isRegexp(it)) throw TypeError(\"The method doesn't accept regular expressions\");\n        return it;\n    };\n    var MATCH$1 = wellKnownSymbol(\"match\");\n    var correctIsRegexpLogic = function(METHOD_NAME) {\n        var regexp = /./;\n        try {\n            \"/./\"[METHOD_NAME](regexp);\n        } catch (error1) {\n            try {\n                regexp[MATCH$1] = false;\n                return \"/./\"[METHOD_NAME](regexp);\n            } catch (error2) {}\n        }\n        return false;\n    };\n    \"use strict\";\n    // `String.prototype.includes` method\n    // https://tc39.es/ecma262/#sec-string.prototype.includes\n    _export({\n        target: \"String\",\n        proto: true,\n        forced: !correctIsRegexpLogic(\"includes\")\n    }, {\n        includes: function includes(searchString /* , position = 0 */ ) {\n            return !!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);\n        }\n    });\n    var es_string_includes = {};\n    var includes$2 = entryUnbind(\"String\", \"includes\");\n    var includes$3 = includes$2;\n    \"use strict\";\n    var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;\n    var nativeStartsWith = \"\".startsWith;\n    var min$2 = Math.min;\n    var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic(\"startsWith\");\n    // https://github.com/zloirock/core-js/pull/702\n    var MDN_POLYFILL_BUG = !isPure && !CORRECT_IS_REGEXP_LOGIC && !!function() {\n        var descriptor = getOwnPropertyDescriptor$2(String.prototype, \"startsWith\");\n        return descriptor && !descriptor.writable;\n    }();\n    // `String.prototype.startsWith` method\n    // https://tc39.es/ecma262/#sec-string.prototype.startswith\n    _export({\n        target: \"String\",\n        proto: true,\n        forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC\n    }, {\n        startsWith: function startsWith(searchString /* , position = 0 */ ) {\n            var that = String(requireObjectCoercible(this));\n            notARegexp(searchString);\n            var index = toLength(min$2(arguments.length > 1 ? arguments[1] : undefined, that.length));\n            var search = String(searchString);\n            return nativeStartsWith ? nativeStartsWith.call(that, search, index) : that.slice(index, index + search.length) === search;\n        }\n    });\n    var es_string_startsWith = {};\n    var startsWith = entryUnbind(\"String\", \"startsWith\");\n    var startsWith$1 = startsWith;\n    (function() {\n        if (typeof Uint8Array !== \"undefined\" || typeof window === \"undefined\") return;\n        function subarray(start, end) {\n            return this.slice(start, end);\n        }\n        function set_(array, offset) {\n            if (arguments.length < 2) offset = 0;\n            for(var i = 0, n = array.length; i < n; ++i, ++offset)this[offset] = array[i] & 0xFF;\n        }\n        // we need typed arrays\n        function TypedArray(arg1) {\n            var result;\n            if (typeof arg1 === \"number\") {\n                result = new Array(arg1);\n                for(var i = 0; i < arg1; ++i)result[i] = 0;\n            } else result = arg1.slice(0);\n            result.subarray = subarray;\n            result.buffer = result;\n            result.byteLength = result.length;\n            result.set = set_;\n            if (typeof arg1 === \"object\" && arg1.buffer) result.buffer = arg1.buffer;\n            return result;\n        }\n        window.Uint8Array = TypedArray;\n        window.Uint32Array = TypedArray;\n        window.Int32Array = TypedArray;\n    })();\n    var props = {\n        x: \"x\",\n        y: \"y\",\n        width: \"w\",\n        height: \"h\",\n        minimum: \"s\",\n        maximum: \"l\",\n        diagonal: \"d\"\n    };\n    var propsList = Object.keys(props).map(function(key) {\n        return props[key];\n    }).join(\"\");\n    var numberPattern = \"[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?\";\n    var findSpacesRegex = /\\s/g;\n    var parseExpressionRegExp = new RegExp(\"^(\" + numberPattern + \"\\\\*)?([\" + propsList + \"])(/\" + numberPattern + \")?([-+]{1,2}\" + numberPattern + \")?$\", \"g\");\n    function throwInvalid(expression) {\n        throw new Error(\"Invalid calc() expression: \" + expression);\n    }\n    function evalCalcExpression(expression, bbox) {\n        var match = parseExpressionRegExp.exec(expression.replace(findSpacesRegex, \"\"));\n        if (!match) throwInvalid(expression);\n        parseExpressionRegExp.lastIndex = 0; // reset regex results for the next run\n        var multiply = match[1];\n        var property = match[2];\n        var divide = match[3];\n        var add = match[4];\n        var x = bbox.x;\n        var y = bbox.y;\n        var width = bbox.width;\n        var height = bbox.height;\n        var value = 0;\n        switch(property){\n            case props.width:\n                value = width;\n                break;\n            case props.height:\n                value = height;\n                break;\n            case props.x:\n                value = x;\n                break;\n            case props.y:\n                value = y;\n                break;\n            case props.minimum:\n                value = Math.min(height, width);\n                break;\n            case props.maximum:\n                value = Math.max(height, width);\n                break;\n            case props.diagonal:\n                value = Math.sqrt(height * height + width * width);\n                break;\n        }\n        if (multiply) // e.g \"2*\"\n        value *= parseFloat(multiply);\n        if (divide) // e.g \"/2\"\n        value /= parseFloat(divide.slice(1));\n        if (add) value += evalAddExpression(add);\n        return value;\n    }\n    function evalAddExpression(addExpression) {\n        if (!addExpression) return 0;\n        var sign = addExpression[0];\n        switch(sign){\n            case \"+\":\n                return parseFloat(addExpression.substr(1));\n            case \"-\":\n                return -parseFloat(addExpression.substr(1));\n        }\n        return parseFloat(addExpression);\n    }\n    function isCalcAttribute(value) {\n        return typeof value === \"string\" && value.includes(\"calc\");\n    }\n    var calcStart = \"calc(\";\n    var calcStartOffset = calcStart.length;\n    function evalCalcAttribute(attributeValue, refBBox) {\n        var value = attributeValue;\n        var startSearchIndex = 0;\n        do {\n            var calcIndex = value.indexOf(calcStart, startSearchIndex);\n            if (calcIndex === -1) return value;\n            var calcEndIndex = calcIndex + calcStartOffset;\n            var brackets = 1;\n            findClosingBracket: do {\n                switch(value[calcEndIndex]){\n                    case \"(\":\n                        brackets++;\n                        break;\n                    case \")\":\n                        brackets--;\n                        if (brackets === 0) break findClosingBracket;\n                        break;\n                    case undefined:\n                        // Could not find the closing bracket.\n                        throwInvalid(value);\n                }\n                calcEndIndex++;\n            }while (true);\n            // Get the calc() expression without nested calcs (recursion)\n            var expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);\n            if (isCalcAttribute(expression)) expression = evalCalcAttribute(expression, refBBox);\n            // Eval the calc() expression without nested calcs.\n            var calcValue = String(evalCalcExpression(expression, refBBox));\n            // Replace the calc() expression and continue search\n            value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);\n            startSearchIndex = calcIndex + calcValue.length;\n        }while (true);\n    }\n    // Declare shorthands to the most used math functions.\n    var round = Math.round;\n    var floor$1 = Math.floor;\n    var PI = Math.PI;\n    var scale = {\n        // Return the `value` from the `domain` interval scaled to the `range` interval.\n        linear: function(domain, range, value) {\n            var domainSpan = domain[1] - domain[0];\n            var rangeSpan = range[1] - range[0];\n            return (value - domain[0]) / domainSpan * rangeSpan + range[0] || 0;\n        }\n    };\n    var normalizeAngle = function(angle) {\n        return angle % 360 + (angle < 0 ? 360 : 0);\n    };\n    var snapToGrid = function(value, gridSize) {\n        return gridSize * round(value / gridSize);\n    };\n    var toDeg = function(rad) {\n        return 180 * rad / PI % 360;\n    };\n    var toRad = function(deg, over360) {\n        over360 = over360 || false;\n        deg = over360 ? deg : deg % 360;\n        return deg * PI / 180;\n    };\n    // Return a random integer from the interval [min,max], inclusive.\n    var random = function(min, max) {\n        if (max === undefined) {\n            // use first argument as max, min is 0\n            max = min === undefined ? 1 : min;\n            min = 0;\n        } else if (max < min) {\n            // switch max and min\n            var temp = min;\n            min = max;\n            max = temp;\n        }\n        return floor$1(Math.random() * (max - min + 1) + min);\n    };\n    // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n    var cos = Math.cos;\n    var sin = Math.sin;\n    var atan2 = Math.atan2;\n    var bearing = function(p, q) {\n        var lat1 = toRad(p.y);\n        var lat2 = toRad(q.y);\n        var lon1 = p.x;\n        var lon2 = q.x;\n        var dLon = toRad(lon2 - lon1);\n        var y = sin(dLon) * cos(lat2);\n        var x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);\n        var brng = toDeg(atan2(y, x));\n        var bearings = [\n            \"NE\",\n            \"E\",\n            \"SE\",\n            \"S\",\n            \"SW\",\n            \"W\",\n            \"NW\",\n            \"N\"\n        ];\n        var index = brng - 22.5;\n        if (index < 0) index += 360;\n        index = parseInt(index / 45);\n        return bearings[index];\n    };\n    // @return {integer} length without sqrt\n    // @note for applications where the exact length is not necessary (e.g. compare only)\n    var squaredLength = function(start, end) {\n        var x0 = start.x;\n        var y0 = start.y;\n        var x1 = end.x;\n        var y1 = end.y;\n        return (x0 -= x1) * x0 + (y0 -= y1) * y0;\n    };\n    var length = function(start, end) {\n        return Math.sqrt(squaredLength(start, end));\n    };\n    var types = {\n        Point: 1,\n        Line: 2,\n        Ellipse: 3,\n        Rect: 4,\n        Polyline: 5,\n        Polygon: 6,\n        Curve: 7,\n        Path: 8\n    };\n    /*\n\t    Point is the most basic object consisting of x/y coordinate.\n\n\t    Possible instantiations are:\n\t    * `Point(10, 20)`\n\t    * `new Point(10, 20)`\n\t    * `Point('10 20')`\n\t    * `Point(Point(10, 20))`\n\t*/ var abs = Math.abs;\n    var cos$1 = Math.cos;\n    var sin$1 = Math.sin;\n    var sqrt = Math.sqrt;\n    var min$3 = Math.min;\n    var max$1 = Math.max;\n    var atan2$1 = Math.atan2;\n    var round$1 = Math.round;\n    var pow = Math.pow;\n    var PI$1 = Math.PI;\n    var Point = function(x, y) {\n        if (!(this instanceof Point)) return new Point(x, y);\n        if (typeof x === \"string\") {\n            var xy = x.split(x.indexOf(\"@\") === -1 ? \" \" : \"@\");\n            x = parseFloat(xy[0]);\n            y = parseFloat(xy[1]);\n        } else if (Object(x) === x) {\n            y = x.y;\n            x = x.x;\n        }\n        this.x = x === undefined ? 0 : x;\n        this.y = y === undefined ? 0 : y;\n    };\n    // Alternative constructor, from polar coordinates.\n    // @param {number} Distance.\n    // @param {number} Angle in radians.\n    // @param {point} [optional] Origin.\n    Point.fromPolar = function(distance, angle, origin) {\n        origin = new Point(origin);\n        var x = abs(distance * cos$1(angle));\n        var y = abs(distance * sin$1(angle));\n        var deg = normalizeAngle(toDeg(angle));\n        if (deg < 90) y = -y;\n        else if (deg < 180) {\n            x = -x;\n            y = -y;\n        } else if (deg < 270) x = -x;\n        return new Point(origin.x + x, origin.y + y);\n    };\n    // Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\n    Point.random = function(x1, x2, y1, y2) {\n        return new Point(random(x1, x2), random(y1, y2));\n    };\n    Point.prototype = {\n        type: types.Point,\n        chooseClosest: function(points) {\n            var n = points.length;\n            if (n === 1) return new Point(points[0]);\n            var closest = null;\n            var minSqrDistance = Infinity;\n            for(var i = 0; i < n; i++){\n                var p = new Point(points[i]);\n                var sqrDistance = this.squaredDistance(p);\n                if (sqrDistance < minSqrDistance) {\n                    closest = p;\n                    minSqrDistance = sqrDistance;\n                }\n            }\n            return closest;\n        },\n        // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n        // otherwise return point itself.\n        // (see Squeak Smalltalk, Point>>adhereTo:)\n        adhereToRect: function(r) {\n            if (r.containsPoint(this)) return this;\n            this.x = min$3(max$1(this.x, r.x), r.x + r.width);\n            this.y = min$3(max$1(this.y, r.y), r.y + r.height);\n            return this;\n        },\n        // Compute the angle between vector from me to p1 and the vector from me to p2.\n        // ordering of points p1 and p2 is important!\n        // theta function's angle convention:\n        // returns angles between 0 and 180 when the angle is counterclockwise\n        // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n        // returns NaN if any of the points p1, p2 is coincident with this point\n        angleBetween: function(p1, p2) {\n            var angleBetween = this.equals(p1) || this.equals(p2) ? NaN : this.theta(p2) - this.theta(p1);\n            if (angleBetween < 0) angleBetween += 360; // correction to keep angleBetween between 0 and 360\n            return angleBetween;\n        },\n        // Return the bearing between me and the given point.\n        bearing: function(point) {\n            return bearing(this, point);\n        },\n        // Returns change in angle from my previous position (-dx, -dy) to my new position\n        // relative to ref point.\n        changeInAngle: function(dx, dy, ref) {\n            // Revert the translation and measure the change in angle around x-axis.\n            return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n        },\n        clone: function() {\n            return new Point(this);\n        },\n        // Returns the cross product of this point relative to two other points\n        // this point is the common point\n        // point p1 lies on the first vector, point p2 lies on the second vector\n        // watch out for the ordering of points p1 and p2!\n        // positive result indicates a clockwise (\"right\") turn from first to second vector\n        // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n        // zero indicates that the first and second vector are collinear\n        // note that the above directions are reversed from the usual answer on the Internet\n        // that is because we are in a left-handed coord system (because the y-axis points downward)\n        cross: function(p1, p2) {\n            return p1 && p2 ? (p2.x - this.x) * (p1.y - this.y) - (p2.y - this.y) * (p1.x - this.x) : NaN;\n        },\n        difference: function(dx, dy) {\n            if (Object(dx) === dx) {\n                dy = dx.y;\n                dx = dx.x;\n            }\n            return new Point(this.x - (dx || 0), this.y - (dy || 0));\n        },\n        // Returns distance between me and point `p`.\n        distance: function(p) {\n            return length(this, p);\n        },\n        // Returns the dot product of this point with given other point\n        dot: function(p) {\n            return p ? this.x * p.x + this.y * p.y : NaN;\n        },\n        equals: function(p) {\n            return !!p && this.x === p.x && this.y === p.y;\n        },\n        // Linear interpolation\n        lerp: function(p, t) {\n            var x = this.x;\n            var y = this.y;\n            return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n        },\n        magnitude: function() {\n            return sqrt(this.x * this.x + this.y * this.y) || 0.01;\n        },\n        // Returns a manhattan (taxi-cab) distance between me and point `p`.\n        manhattanDistance: function(p) {\n            return abs(p.x - this.x) + abs(p.y - this.y);\n        },\n        // Move point on line starting from ref ending at me by\n        // distance distance.\n        move: function(ref, distance) {\n            var theta = toRad(new Point(ref).theta(this));\n            var offset = this.offset(cos$1(theta) * distance, -sin$1(theta) * distance);\n            return offset;\n        },\n        // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n        normalize: function(length) {\n            var scale = (length || 1) / this.magnitude();\n            return this.scale(scale, scale);\n        },\n        // Offset me by the specified amount.\n        offset: function(dx, dy) {\n            if (Object(dx) === dx) {\n                dy = dx.y;\n                dx = dx.x;\n            }\n            this.x += dx || 0;\n            this.y += dy || 0;\n            return this;\n        },\n        // Returns a point that is the reflection of me with\n        // the center of inversion in ref point.\n        reflection: function(ref) {\n            return new Point(ref).move(this, this.distance(ref));\n        },\n        // Rotate point by angle around origin.\n        // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n        rotate: function(origin, angle) {\n            if (angle === 0) return this;\n            origin = origin || new Point(0, 0);\n            angle = toRad(normalizeAngle(-angle));\n            var cosAngle = cos$1(angle);\n            var sinAngle = sin$1(angle);\n            var x = cosAngle * (this.x - origin.x) - sinAngle * (this.y - origin.y) + origin.x;\n            var y = sinAngle * (this.x - origin.x) + cosAngle * (this.y - origin.y) + origin.y;\n            this.x = x;\n            this.y = y;\n            return this;\n        },\n        round: function(precision) {\n            var f = 1; // case 0\n            if (precision) switch(precision){\n                case 1:\n                    f = 10;\n                    break;\n                case 2:\n                    f = 100;\n                    break;\n                case 3:\n                    f = 1000;\n                    break;\n                default:\n                    f = pow(10, precision);\n                    break;\n            }\n            this.x = round$1(this.x * f) / f;\n            this.y = round$1(this.y * f) / f;\n            return this;\n        },\n        // Scale point with origin.\n        scale: function(sx, sy, origin) {\n            origin = origin && new Point(origin) || new Point(0, 0);\n            this.x = origin.x + sx * (this.x - origin.x);\n            this.y = origin.y + sy * (this.y - origin.y);\n            return this;\n        },\n        snapToGrid: function(gx, gy) {\n            this.x = snapToGrid(this.x, gx);\n            this.y = snapToGrid(this.y, gy || gx);\n            return this;\n        },\n        squaredDistance: function(p) {\n            return squaredLength(this, p);\n        },\n        // Compute the angle between me and `p` and the x axis.\n        // (cartesian-to-polar coordinates conversion)\n        // Return theta angle in degrees.\n        theta: function(p) {\n            p = new Point(p);\n            // Invert the y-axis.\n            var y = -(p.y - this.y);\n            var x = p.x - this.x;\n            var rad = atan2$1(y, x); // defined for all 0 corner cases\n            // Correction for III. and IV. quadrant.\n            if (rad < 0) rad = 2 * PI$1 + rad;\n            return 180 * rad / PI$1;\n        },\n        toJSON: function() {\n            return {\n                x: this.x,\n                y: this.y\n            };\n        },\n        // Converts rectangular to polar coordinates.\n        // An origin can be specified, otherwise it's 0@0.\n        toPolar: function(o) {\n            o = o && new Point(o) || new Point(0, 0);\n            var x = this.x;\n            var y = this.y;\n            this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n            this.y = toRad(o.theta(new Point(x, y)));\n            return this;\n        },\n        toString: function() {\n            return this.x + \"@\" + this.y;\n        },\n        serialize: function() {\n            return this.x + \",\" + this.y;\n        },\n        update: function(x, y) {\n            if (Object(x) === x) {\n                y = x.y;\n                x = x.x;\n            }\n            this.x = x || 0;\n            this.y = y || 0;\n            return this;\n        },\n        // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n        // Returns NaN if p is at 0,0.\n        vectorAngle: function(p) {\n            var zero = new Point(0, 0);\n            return zero.angleBetween(this, p);\n        }\n    };\n    Point.prototype.translate = Point.prototype.offset;\n    // For backwards compatibility:\n    var point = Point;\n    var max$2 = Math.max;\n    var min$4 = Math.min;\n    var Line = function(p1, p2) {\n        if (!(this instanceof Line)) return new Line(p1, p2);\n        if (p1 instanceof Line) return new Line(p1.start, p1.end);\n        this.start = new Point(p1);\n        this.end = new Point(p2);\n    };\n    Line.prototype = {\n        type: types.Line,\n        // @returns the angle of incline of the line.\n        angle: function() {\n            var horizontalPoint = new Point(this.start.x + 1, this.start.y);\n            return this.start.angleBetween(this.end, horizontalPoint);\n        },\n        bbox: function() {\n            var left = min$4(this.start.x, this.end.x);\n            var top = min$4(this.start.y, this.end.y);\n            var right = max$2(this.start.x, this.end.x);\n            var bottom = max$2(this.start.y, this.end.y);\n            return new Rect(left, top, right - left, bottom - top);\n        },\n        // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n        // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n        bearing: function() {\n            return bearing(this.start, this.end);\n        },\n        clone: function() {\n            return new Line(this.start, this.end);\n        },\n        // @return {point} the closest point on the line to point `p`\n        closestPoint: function(p) {\n            return this.pointAt(this.closestPointNormalizedLength(p));\n        },\n        closestPointLength: function(p) {\n            return this.closestPointNormalizedLength(p) * this.length();\n        },\n        // @return {number} the normalized length of the closest point on the line to point `p`\n        closestPointNormalizedLength: function(p) {\n            var product = this.vector().dot(new Line(this.start, p).vector());\n            var cpNormalizedLength = min$4(1, max$2(0, product / this.squaredLength()));\n            // cpNormalizedLength returns `NaN` if this line has zero length\n            // we can work with that - if `NaN`, return 0\n            if (cpNormalizedLength !== cpNormalizedLength) return 0;\n             // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n            // (`NaN` is the only value that is not equal to itself)\n            return cpNormalizedLength;\n        },\n        closestPointTangent: function(p) {\n            return this.tangentAt(this.closestPointNormalizedLength(p));\n        },\n        // Returns `true` if the point lies on the line.\n        containsPoint: function(p) {\n            var start = this.start;\n            var end = this.end;\n            if (start.cross(p, end) !== 0) return false;\n            // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n            var length = this.length();\n            if (new Line(start, p).length() > length) return false;\n            if (new Line(p, end).length() > length) return false;\n            // else: `p` lies between start and end of the line\n            return true;\n        },\n        // Divides the line into two at requested `ratio` between 0 and 1.\n        divideAt: function(ratio) {\n            var dividerPoint = this.pointAt(ratio);\n            // return array with two lines\n            return [\n                new Line(this.start, dividerPoint),\n                new Line(dividerPoint, this.end)\n            ];\n        },\n        // Divides the line into two at requested `length`.\n        divideAtLength: function(length) {\n            var dividerPoint = this.pointAtLength(length);\n            // return array with two new lines\n            return [\n                new Line(this.start, dividerPoint),\n                new Line(dividerPoint, this.end)\n            ];\n        },\n        equals: function(l) {\n            return !!l && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;\n        },\n        // @return {point} Point where I'm intersecting a line.\n        // @return [point] Points where I'm intersecting a rectangle.\n        // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n        intersect: function(shape, opt) {\n            if (shape && shape.intersectionWithLine) {\n                var intersection = shape.intersectionWithLine(this, opt);\n                // Backwards compatibility\n                if (intersection && shape instanceof Line) intersection = intersection[0];\n                return intersection;\n            }\n            return null;\n        },\n        intersectionWithLine: function(line) {\n            var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n            var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n            var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;\n            var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n            var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;\n            var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;\n            if (det === 0 || alpha * det < 0 || beta * det < 0) // No intersection found.\n            return null;\n            if (det > 0) {\n                if (alpha > det || beta > det) return null;\n            } else {\n                if (alpha < det || beta < det) return null;\n            }\n            return [\n                new Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det)\n            ];\n        },\n        isDifferentiable: function() {\n            return !this.start.equals(this.end);\n        },\n        // @return {double} length of the line\n        length: function() {\n            return length(this.start, this.end);\n        },\n        // @return {point} my midpoint\n        midpoint: function() {\n            return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n        },\n        parallel: function(distance) {\n            var l = this.clone();\n            if (!this.isDifferentiable()) return l;\n            var start = l.start;\n            var end = l.end;\n            var eRef = start.clone().rotate(end, 270);\n            var sRef = end.clone().rotate(start, 90);\n            start.move(sRef, distance);\n            end.move(eRef, distance);\n            return l;\n        },\n        // @return {point} my point at 't' <0,1>\n        pointAt: function(t) {\n            var start = this.start;\n            var end = this.end;\n            if (t <= 0) return start.clone();\n            if (t >= 1) return end.clone();\n            return start.lerp(end, t);\n        },\n        pointAtLength: function(length) {\n            var start = this.start;\n            var end = this.end;\n            var fromStart = true;\n            if (length < 0) {\n                fromStart = false; // negative lengths mean start calculation from end point\n                length = -length; // absolute value\n            }\n            var lineLength = this.length();\n            if (length >= lineLength) return fromStart ? end.clone() : start.clone();\n            return this.pointAt((fromStart ? length : lineLength - length) / lineLength);\n        },\n        // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n        pointOffset: function(p) {\n            // Find the sign of the determinant of vectors (start,end), where p is the query point.\n            p = new Point(p);\n            var start = this.start;\n            var end = this.end;\n            var determinant = (end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x);\n            return determinant / this.length();\n        },\n        rotate: function(origin, angle) {\n            this.start.rotate(origin, angle);\n            this.end.rotate(origin, angle);\n            return this;\n        },\n        round: function(precision) {\n            this.start.round(precision);\n            this.end.round(precision);\n            return this;\n        },\n        scale: function(sx, sy, origin) {\n            this.start.scale(sx, sy, origin);\n            this.end.scale(sx, sy, origin);\n            return this;\n        },\n        // @return {number} scale the line so that it has the requested length\n        setLength: function(length) {\n            var currentLength = this.length();\n            if (!currentLength) return this;\n            var scaleFactor = length / currentLength;\n            return this.scale(scaleFactor, scaleFactor, this.start);\n        },\n        // @return {integer} length without sqrt\n        // @note for applications where the exact length is not necessary (e.g. compare only)\n        squaredLength: function() {\n            return squaredLength(this.start, this.end);\n        },\n        tangentAt: function(t) {\n            if (!this.isDifferentiable()) return null;\n            var start = this.start;\n            var end = this.end;\n            var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n            var tangentLine = new Line(start, end);\n            tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n            return tangentLine;\n        },\n        tangentAtLength: function(length) {\n            if (!this.isDifferentiable()) return null;\n            var start = this.start;\n            var end = this.end;\n            var tangentStart = this.pointAtLength(length);\n            var tangentLine = new Line(start, end);\n            tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n            return tangentLine;\n        },\n        toString: function() {\n            return this.start.toString() + \" \" + this.end.toString();\n        },\n        serialize: function() {\n            return this.start.serialize() + \" \" + this.end.serialize();\n        },\n        translate: function(tx, ty) {\n            this.start.translate(tx, ty);\n            this.end.translate(tx, ty);\n            return this;\n        },\n        // @return vector {point} of the line\n        vector: function() {\n            return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n        }\n    };\n    // For backwards compatibility:\n    Line.prototype.intersection = Line.prototype.intersect;\n    // For backwards compatibility:\n    var line = Line;\n    var sqrt$1 = Math.sqrt;\n    var round$2 = Math.round;\n    var pow$1 = Math.pow;\n    var Ellipse = function(c, a, b) {\n        if (!(this instanceof Ellipse)) return new Ellipse(c, a, b);\n        if (c instanceof Ellipse) return new Ellipse(new Point(c.x, c.y), c.a, c.b);\n        c = new Point(c);\n        this.x = c.x;\n        this.y = c.y;\n        this.a = a;\n        this.b = b;\n    };\n    Ellipse.fromRect = function(rect) {\n        rect = new Rect(rect);\n        return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n    };\n    Ellipse.prototype = {\n        type: types.Ellipse,\n        bbox: function() {\n            return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n        },\n        /**\n\t     * @returns {g.Point}\n\t     */ center: function() {\n            return new Point(this.x, this.y);\n        },\n        clone: function() {\n            return new Ellipse(this);\n        },\n        /**\n\t     * @param {g.Point} p\n\t     * @returns {boolean}\n\t     */ containsPoint: function(p) {\n            return this.normalizedDistance(p) <= 1;\n        },\n        equals: function(ellipse) {\n            return !!ellipse && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;\n        },\n        // inflate by dx and dy\n        // @param dx {delta_x} representing additional size to x\n        // @param dy {delta_y} representing additional size to y -\n        // dy param is not required -> in that case y is sized by dx\n        inflate: function(dx, dy) {\n            if (dx === undefined) dx = 0;\n            if (dy === undefined) dy = dx;\n            this.a += 2 * dx;\n            this.b += 2 * dy;\n            return this;\n        },\n        intersectionWithLine: function(line) {\n            var intersections = [];\n            var a1 = line.start;\n            var a2 = line.end;\n            var rx = this.a;\n            var ry = this.b;\n            var dir = line.vector();\n            var diff = a1.difference(new Point(this));\n            var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n            var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n            var a = dir.dot(mDir);\n            var b = dir.dot(mDiff);\n            var c = diff.dot(mDiff) - 1.0;\n            var d = b * b - a * c;\n            if (d < 0) return null;\n            else if (d > 0) {\n                var root = sqrt$1(d);\n                var ta = (-b - root) / a;\n                var tb = (-b + root) / a;\n                if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n                return null;\n                else {\n                    if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n                    if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n                }\n            } else {\n                var t = -b / a;\n                if (0 <= t && t <= 1) intersections.push(a1.lerp(a2, t));\n                else // outside\n                return null;\n            }\n            return intersections;\n        },\n        // Find point on me where line from my center to\n        // point p intersects my boundary.\n        // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n        intersectionWithLineFromCenterToPoint: function(p, angle) {\n            p = new Point(p);\n            if (angle) p.rotate(new Point(this.x, this.y), angle);\n            var dx = p.x - this.x;\n            var dy = p.y - this.y;\n            var result;\n            if (dx === 0) {\n                result = this.bbox().pointNearestToPoint(p);\n                if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n                return result;\n            }\n            var m = dy / dx;\n            var mSquared = m * m;\n            var aSquared = this.a * this.a;\n            var bSquared = this.b * this.b;\n            var x = sqrt$1(1 / (1 / aSquared + mSquared / bSquared));\n            x = dx < 0 ? -x : x;\n            var y = m * x;\n            result = new Point(this.x + x, this.y + y);\n            if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n            return result;\n        },\n        /**\n\t     * @param {g.Point} point\n\t     * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n\t     */ normalizedDistance: function(point) {\n            var x0 = point.x;\n            var y0 = point.y;\n            var a = this.a;\n            var b = this.b;\n            var x = this.x;\n            var y = this.y;\n            return (x0 - x) * (x0 - x) / (a * a) + (y0 - y) * (y0 - y) / (b * b);\n        },\n        round: function(precision) {\n            var f = 1; // case 0\n            if (precision) switch(precision){\n                case 1:\n                    f = 10;\n                    break;\n                case 2:\n                    f = 100;\n                    break;\n                case 3:\n                    f = 1000;\n                    break;\n                default:\n                    f = pow$1(10, precision);\n                    break;\n            }\n            this.x = round$2(this.x * f) / f;\n            this.y = round$2(this.y * f) / f;\n            this.a = round$2(this.a * f) / f;\n            this.b = round$2(this.b * f) / f;\n            return this;\n        },\n        /** Compute angle between tangent and x axis\n\t     * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n\t     * @returns {number} angle between tangent and x axis\n\t     */ tangentTheta: function(p) {\n            var refPointDelta = 30;\n            var x0 = p.x;\n            var y0 = p.y;\n            var a = this.a;\n            var b = this.b;\n            var center = this.bbox().center();\n            var m = center.x;\n            var n = center.y;\n            var q1 = x0 > center.x + a / 2;\n            var q3 = x0 < center.x - a / 2;\n            var y, x;\n            if (q1 || q3) {\n                y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n                x = a * a / (x0 - m) - a * a * (y0 - n) * (y - n) / (b * b * (x0 - m)) + m;\n            } else {\n                x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n                y = b * b / (y0 - n) - b * b * (x0 - m) * (x - m) / (a * a * (y0 - n)) + n;\n            }\n            return new Point(x, y).theta(p);\n        },\n        toString: function() {\n            return new Point(this.x, this.y).toString() + \" \" + this.a + \" \" + this.b;\n        }\n    };\n    // For backwards compatibility:\n    var ellipse = Ellipse;\n    var abs$1 = Math.abs;\n    var cos$2 = Math.cos;\n    var sin$2 = Math.sin;\n    var min$5 = Math.min;\n    var max$3 = Math.max;\n    var round$3 = Math.round;\n    var pow$2 = Math.pow;\n    var Rect = function(x, y, w, h) {\n        if (!(this instanceof Rect)) return new Rect(x, y, w, h);\n        if (Object(x) === x) {\n            y = x.y;\n            w = x.width;\n            h = x.height;\n            x = x.x;\n        }\n        this.x = x === undefined ? 0 : x;\n        this.y = y === undefined ? 0 : y;\n        this.width = w === undefined ? 0 : w;\n        this.height = h === undefined ? 0 : h;\n    };\n    Rect.fromEllipse = function(e) {\n        e = new Ellipse(e);\n        return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n    };\n    Rect.fromPointUnion = function() {\n        var points = [], len = arguments.length;\n        while(len--)points[len] = arguments[len];\n        if (points.length === 0) return null;\n        var p = new Point();\n        var minX, minY, maxX, maxY;\n        minX = minY = Infinity;\n        maxX = maxY = -Infinity;\n        for(var i = 0; i < points.length; i++){\n            p.update(points[i]);\n            var x = p.x;\n            var y = p.y;\n            if (x < minX) minX = x;\n            if (x > maxX) maxX = x;\n            if (y < minY) minY = y;\n            if (y > maxY) maxY = y;\n        }\n        return new Rect(minX, minY, maxX - minX, maxY - minY);\n    };\n    Rect.fromRectUnion = function() {\n        var rects = [], len = arguments.length;\n        while(len--)rects[len] = arguments[len];\n        if (rects.length === 0) return null;\n        var r = new Rect();\n        var minX, minY, maxX, maxY;\n        minX = minY = Infinity;\n        maxX = maxY = -Infinity;\n        for(var i = 0; i < rects.length; i++){\n            r.update(rects[i]);\n            var x = r.x;\n            var y = r.y;\n            var mX = x + r.width;\n            var mY = y + r.height;\n            if (x < minX) minX = x;\n            if (mX > maxX) maxX = mX;\n            if (y < minY) minY = y;\n            if (mY > maxY) maxY = mY;\n        }\n        return new Rect(minX, minY, maxX - minX, maxY - minY);\n    };\n    Rect.prototype = {\n        type: types.Rect,\n        // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n        // @return r {rectangle} representing a bounding box\n        bbox: function(angle) {\n            return this.clone().rotateAroundCenter(angle);\n        },\n        rotateAroundCenter: function(angle) {\n            if (!angle) return this;\n            var ref = this;\n            var width = ref.width;\n            var height = ref.height;\n            var theta = toRad(angle);\n            var st = abs$1(sin$2(theta));\n            var ct = abs$1(cos$2(theta));\n            var w = width * ct + height * st;\n            var h = width * st + height * ct;\n            this.x += (width - w) / 2;\n            this.y += (height - h) / 2;\n            this.width = w;\n            this.height = h;\n            return this;\n        },\n        bottomLeft: function() {\n            return new Point(this.x, this.y + this.height);\n        },\n        bottomLine: function() {\n            return new Line(this.bottomLeft(), this.bottomRight());\n        },\n        bottomMiddle: function() {\n            return new Point(this.x + this.width / 2, this.y + this.height);\n        },\n        center: function() {\n            return new Point(this.x + this.width / 2, this.y + this.height / 2);\n        },\n        clone: function() {\n            return new Rect(this);\n        },\n        // @return {bool} true if point p is inside me.\n        containsPoint: function(p) {\n            p = new Point(p);\n            return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;\n        },\n        // @return {bool} true if rectangle `r` is inside me.\n        containsRect: function(r) {\n            var r0 = new Rect(this).normalize();\n            var r1 = new Rect(r).normalize();\n            var w0 = r0.width;\n            var h0 = r0.height;\n            var w1 = r1.width;\n            var h1 = r1.height;\n            if (!w0 || !h0 || !w1 || !h1) // At least one of the dimensions is 0\n            return false;\n            var x0 = r0.x;\n            var y0 = r0.y;\n            var x1 = r1.x;\n            var y1 = r1.y;\n            w1 += x1;\n            w0 += x0;\n            h1 += y1;\n            h0 += y0;\n            return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n        },\n        corner: function() {\n            return new Point(this.x + this.width, this.y + this.height);\n        },\n        // @return {boolean} true if rectangles are equal.\n        equals: function(r) {\n            var mr = new Rect(this).normalize();\n            var nr = new Rect(r).normalize();\n            return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n        },\n        // inflate by dx and dy, recompute origin [x, y]\n        // @param dx {delta_x} representing additional size to x\n        // @param dy {delta_y} representing additional size to y -\n        // dy param is not required -> in that case y is sized by dx\n        inflate: function(dx, dy) {\n            if (dx === undefined) dx = 0;\n            if (dy === undefined) dy = dx;\n            this.x -= dx;\n            this.y -= dy;\n            this.width += 2 * dx;\n            this.height += 2 * dy;\n            return this;\n        },\n        // @return {rect} if rectangles intersect, {null} if not.\n        intersect: function(r) {\n            var myOrigin = this.origin();\n            var myCorner = this.corner();\n            var rOrigin = r.origin();\n            var rCorner = r.corner();\n            // No intersection found\n            if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) return null;\n            var x = max$3(myOrigin.x, rOrigin.x);\n            var y = max$3(myOrigin.y, rOrigin.y);\n            return new Rect(x, y, min$5(myCorner.x, rCorner.x) - x, min$5(myCorner.y, rCorner.y) - y);\n        },\n        intersectionWithLine: function(line) {\n            var r = this;\n            var rectLines = [\n                r.topLine(),\n                r.rightLine(),\n                r.bottomLine(),\n                r.leftLine()\n            ];\n            var points = [];\n            var dedupeArr = [];\n            var pt, i;\n            var n = rectLines.length;\n            for(i = 0; i < n; i++){\n                pt = line.intersect(rectLines[i]);\n                if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n                    points.push(pt);\n                    dedupeArr.push(pt.toString());\n                }\n            }\n            return points.length > 0 ? points : null;\n        },\n        // Find point on my boundary where line starting\n        // from my center ending in point p intersects me.\n        // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n        intersectionWithLineFromCenterToPoint: function(p, angle) {\n            p = new Point(p);\n            var center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n            var result;\n            if (angle) p.rotate(center, angle);\n            // (clockwise, starting from the top side)\n            var sides = [\n                this.topLine(),\n                this.rightLine(),\n                this.bottomLine(),\n                this.leftLine()\n            ];\n            var connector = new Line(center, p);\n            for(var i = sides.length - 1; i >= 0; --i){\n                var intersection = sides[i].intersection(connector);\n                if (intersection !== null) {\n                    result = intersection;\n                    break;\n                }\n            }\n            if (result && angle) result.rotate(center, -angle);\n            return result;\n        },\n        leftLine: function() {\n            return new Line(this.topLeft(), this.bottomLeft());\n        },\n        leftMiddle: function() {\n            return new Point(this.x, this.y + this.height / 2);\n        },\n        maxRectScaleToFit: function(rect, origin) {\n            rect = new Rect(rect);\n            origin || (origin = rect.center());\n            var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n            var ox = origin.x;\n            var oy = origin.y;\n            // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n            // so when the scale is applied the point is still inside the rectangle.\n            sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n            // Top Left\n            var p1 = rect.topLeft();\n            if (p1.x < ox) sx1 = (this.x - ox) / (p1.x - ox);\n            if (p1.y < oy) sy1 = (this.y - oy) / (p1.y - oy);\n            // Bottom Right\n            var p2 = rect.bottomRight();\n            if (p2.x > ox) sx2 = (this.x + this.width - ox) / (p2.x - ox);\n            if (p2.y > oy) sy2 = (this.y + this.height - oy) / (p2.y - oy);\n            // Top Right\n            var p3 = rect.topRight();\n            if (p3.x > ox) sx3 = (this.x + this.width - ox) / (p3.x - ox);\n            if (p3.y < oy) sy3 = (this.y - oy) / (p3.y - oy);\n            // Bottom Left\n            var p4 = rect.bottomLeft();\n            if (p4.x < ox) sx4 = (this.x - ox) / (p4.x - ox);\n            if (p4.y > oy) sy4 = (this.y + this.height - oy) / (p4.y - oy);\n            return {\n                sx: min$5(sx1, sx2, sx3, sx4),\n                sy: min$5(sy1, sy2, sy3, sy4)\n            };\n        },\n        maxRectUniformScaleToFit: function(rect, origin) {\n            var scale = this.maxRectScaleToFit(rect, origin);\n            return min$5(scale.sx, scale.sy);\n        },\n        // Move and expand me.\n        // @param r {rectangle} representing deltas\n        moveAndExpand: function(r) {\n            this.x += r.x || 0;\n            this.y += r.y || 0;\n            this.width += r.width || 0;\n            this.height += r.height || 0;\n            return this;\n        },\n        // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n        // If width < 0 the function swaps the left and right corners,\n        // and it swaps the top and bottom corners if height < 0\n        // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n        normalize: function() {\n            var newx = this.x;\n            var newy = this.y;\n            var newwidth = this.width;\n            var newheight = this.height;\n            if (this.width < 0) {\n                newx = this.x + this.width;\n                newwidth = -this.width;\n            }\n            if (this.height < 0) {\n                newy = this.y + this.height;\n                newheight = -this.height;\n            }\n            this.x = newx;\n            this.y = newy;\n            this.width = newwidth;\n            this.height = newheight;\n            return this;\n        },\n        // Offset me by the specified amount.\n        offset: function(dx, dy) {\n            // pretend that this is a point and call offset()\n            // rewrites x and y according to dx and dy\n            return Point.prototype.offset.call(this, dx, dy);\n        },\n        origin: function() {\n            return new Point(this.x, this.y);\n        },\n        // @return {point} a point on my boundary nearest to the given point.\n        // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n        pointNearestToPoint: function(point) {\n            point = new Point(point);\n            if (this.containsPoint(point)) {\n                var side = this.sideNearestToPoint(point);\n                switch(side){\n                    case \"right\":\n                        return new Point(this.x + this.width, point.y);\n                    case \"left\":\n                        return new Point(this.x, point.y);\n                    case \"bottom\":\n                        return new Point(point.x, this.y + this.height);\n                    case \"top\":\n                        return new Point(point.x, this.y);\n                }\n            }\n            return point.adhereToRect(this);\n        },\n        rightLine: function() {\n            return new Line(this.topRight(), this.bottomRight());\n        },\n        rightMiddle: function() {\n            return new Point(this.x + this.width, this.y + this.height / 2);\n        },\n        round: function(precision) {\n            var f = 1; // case 0\n            if (precision) switch(precision){\n                case 1:\n                    f = 10;\n                    break;\n                case 2:\n                    f = 100;\n                    break;\n                case 3:\n                    f = 1000;\n                    break;\n                default:\n                    f = pow$2(10, precision);\n                    break;\n            }\n            this.x = round$3(this.x * f) / f;\n            this.y = round$3(this.y * f) / f;\n            this.width = round$3(this.width * f) / f;\n            this.height = round$3(this.height * f) / f;\n            return this;\n        },\n        // Scale rectangle with origin.\n        scale: function(sx, sy, origin) {\n            origin = this.origin().scale(sx, sy, origin);\n            this.x = origin.x;\n            this.y = origin.y;\n            this.width *= sx;\n            this.height *= sy;\n            return this;\n        },\n        // @return {string} (left|right|top|bottom) side which is nearest to point\n        // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n        sideNearestToPoint: function(point) {\n            point = new Point(point);\n            var distToLeft = point.x - this.x;\n            var distToRight = this.x + this.width - point.x;\n            var distToTop = point.y - this.y;\n            var distToBottom = this.y + this.height - point.y;\n            var closest = distToLeft;\n            var side = \"left\";\n            if (distToRight < closest) {\n                closest = distToRight;\n                side = \"right\";\n            }\n            if (distToTop < closest) {\n                closest = distToTop;\n                side = \"top\";\n            }\n            if (distToBottom < closest) // closest = distToBottom;\n            side = \"bottom\";\n            return side;\n        },\n        snapToGrid: function(gx, gy) {\n            var origin = this.origin().snapToGrid(gx, gy);\n            var corner = this.corner().snapToGrid(gx, gy);\n            this.x = origin.x;\n            this.y = origin.y;\n            this.width = corner.x - origin.x;\n            this.height = corner.y - origin.y;\n            return this;\n        },\n        toJSON: function() {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        },\n        topLine: function() {\n            return new Line(this.topLeft(), this.topRight());\n        },\n        topMiddle: function() {\n            return new Point(this.x + this.width / 2, this.y);\n        },\n        topRight: function() {\n            return new Point(this.x + this.width, this.y);\n        },\n        toString: function() {\n            return this.origin().toString() + \" \" + this.corner().toString();\n        },\n        // @return {rect} representing the union of both rectangles.\n        union: function(rect) {\n            return Rect.fromRectUnion(this, rect);\n        },\n        update: function(x, y, w, h) {\n            if (Object(x) === x) {\n                y = x.y;\n                w = x.width;\n                h = x.height;\n                x = x.x;\n            }\n            this.x = x || 0;\n            this.y = y || 0;\n            this.width = w || 0;\n            this.height = h || 0;\n            return this;\n        }\n    };\n    Rect.prototype.bottomRight = Rect.prototype.corner;\n    Rect.prototype.topLeft = Rect.prototype.origin;\n    Rect.prototype.translate = Rect.prototype.offset;\n    // For backwards compatibility:\n    var rect = Rect;\n    function parsePoints(svgString) {\n        // Step 1: Discard surrounding spaces\n        var trimmedString = svgString.trim();\n        if (trimmedString === \"\") return [];\n        var points = [];\n        // Step 2: Split at commas (+ their surrounding spaces) or at multiple spaces\n        // ReDoS mitigation: Have an anchor at the beginning of each alternation\n        // Note: This doesn't simplify double (or more) commas - causes empty coords\n        // This regex is used by `split()`, so it doesn't need to use /g\n        var coords = trimmedString.split(/\\b\\s*,\\s*|,\\s*|\\s+/);\n        var numCoords = coords.length;\n        for(var i = 0; i < numCoords; i += 2)// Step 3: Convert each coord to number\n        // Note: If the coord cannot be converted to a number, it will be `NaN`\n        // Note: If the coord is empty (\"\", e.g. from \",,\" input), it will be `0`\n        // Note: If we end up with an odd number of coords, the last point's second coord will be `NaN`\n        points.push({\n            x: +coords[i],\n            y: +coords[i + 1]\n        });\n        return points;\n    }\n    function clonePoints(points) {\n        var numPoints = points.length;\n        if (numPoints === 0) return [];\n        var newPoints = [];\n        for(var i = 0; i < numPoints; i++){\n            var point = points[i].clone();\n            newPoints.push(point);\n        }\n        return newPoints;\n    }\n    // Returns a convex-hull polyline from this polyline.\n    // Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n    // Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n    // Minimal polyline is found (only vertices of the hull are reported, no collinear points).\n    function convexHull(points) {\n        var abs = Math.abs;\n        var i;\n        var n;\n        var numPoints = points.length;\n        if (numPoints === 0) return [];\n         // if points array is empty\n        // step 1: find the starting point - point with the lowest y (if equality, highest x)\n        var startPoint;\n        for(i = 0; i < numPoints; i++){\n            if (startPoint === undefined) // if this is the first point we see, set it as start point\n            startPoint = points[i];\n            else if (points[i].y < startPoint.y) // start point should have lowest y from all points\n            startPoint = points[i];\n            else if (points[i].y === startPoint.y && points[i].x > startPoint.x) // if two points have the lowest y, choose the one that has highest x\n            // there are no points to the right of startPoint - no ambiguity about theta 0\n            // if there are several coincident start point candidates, first one is reported\n            startPoint = points[i];\n        }\n        // step 2: sort the list of points\n        // sorting by angle between line from startPoint to point and the x-axis (theta)\n        // step 2a: create the point records = [point, originalIndex, angle]\n        var sortedPointRecords = [];\n        for(i = 0; i < numPoints; i++){\n            var angle = startPoint.theta(points[i]);\n            if (angle === 0) angle = 360; // give highest angle to start point\n            var entry = [\n                points[i],\n                i,\n                angle\n            ];\n            sortedPointRecords.push(entry);\n        }\n        // step 2b: sort the list in place\n        sortedPointRecords.sort(function(record1, record2) {\n            // returning a negative number here sorts record1 before record2\n            // if first angle is smaller than second, first angle should come before second\n            var sortOutput = record1[2] - record2[2]; // negative if first angle smaller\n            if (sortOutput === 0) // if the two angles are equal, sort by originalIndex\n            sortOutput = record2[1] - record1[1]; // negative if first index larger\n            return sortOutput;\n        });\n        // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n        if (sortedPointRecords.length > 2) {\n            var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n            sortedPointRecords.unshift(startPointRecord);\n        }\n        // step 3a: go through sorted points in order and find those with right turns\n        // we want to get our results in clockwise order\n        var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n        var hullPointRecords = []; // stack of records with right turns - hull point candidates\n        var currentPointRecord;\n        var currentPoint;\n        var lastHullPointRecord;\n        var lastHullPoint;\n        var secondLastHullPointRecord;\n        var secondLastHullPoint;\n        while(sortedPointRecords.length !== 0){\n            currentPointRecord = sortedPointRecords.pop();\n            currentPoint = currentPointRecord[0];\n            // check if point has already been discarded\n            // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n            if (insidePoints.hasOwnProperty(currentPointRecord[0] + \"@@\" + currentPointRecord[1])) continue;\n            var correctTurnFound = false;\n            while(!correctTurnFound)if (hullPointRecords.length < 2) {\n                // not enough points for comparison, just add current point\n                hullPointRecords.push(currentPointRecord);\n                correctTurnFound = true;\n            } else {\n                lastHullPointRecord = hullPointRecords.pop();\n                lastHullPoint = lastHullPointRecord[0];\n                secondLastHullPointRecord = hullPointRecords.pop();\n                secondLastHullPoint = secondLastHullPointRecord[0];\n                var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n                if (crossProduct < 0) {\n                    // found a right turn\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    hullPointRecords.push(lastHullPointRecord);\n                    hullPointRecords.push(currentPointRecord);\n                    correctTurnFound = true;\n                } else if (crossProduct === 0) {\n                    // the three points are collinear\n                    // three options:\n                    // there may be a 180 or 0 degree angle at lastHullPoint\n                    // or two of the three points are coincident\n                    var THRESHOLD = 1e-10; // we have to take rounding errors into account\n                    var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n                    if (abs(angleBetween - 180) < THRESHOLD) {\n                        // if the cross product is 0 because the angle is 180 degrees\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + \"@@\" + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                    // do not do anything with current point\n                    // correct turn not found\n                    } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n                        // if the cross product is 0 because two points are the same\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + \"@@\" + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                    // do not do anything with current point\n                    // correct turn not found\n                    } else if (abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {\n                        // if the cross product is 0 because the angle is 0 degrees\n                        // remove last hull point from hull BUT do not discard it\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // put last hull point back into the sorted point records list\n                        sortedPointRecords.push(lastHullPointRecord);\n                    // we are switching the order of the 0deg and 180deg points\n                    // correct turn not found\n                    }\n                } else {\n                    // found a left turn\n                    // discard last hull point (add to insidePoints)\n                    //insidePoints.unshift(lastHullPoint);\n                    insidePoints[lastHullPointRecord[0] + \"@@\" + lastHullPointRecord[1]] = lastHullPoint;\n                    // reenter second-to-last hull point (will be last at next iter of loop)\n                    hullPointRecords.push(secondLastHullPointRecord);\n                // do not do anything with current point\n                // correct turn not found\n                }\n            }\n        }\n        // at this point, hullPointRecords contains the output points in clockwise order\n        // the points start with lowest-y,highest-x startPoint, and end at the same point\n        // step 3b: remove duplicated startPointRecord from the end of the array\n        if (hullPointRecords.length > 2) hullPointRecords.pop();\n        // step 4: find the lowest originalIndex record and put it at the beginning of hull\n        var lowestHullIndex; // the lowest originalIndex on the hull\n        var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n        n = hullPointRecords.length;\n        for(i = 0; i < n; i++){\n            var currentHullIndex = hullPointRecords[i][1];\n            if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n                lowestHullIndex = currentHullIndex;\n                indexOfLowestHullIndexRecord = i;\n            }\n        }\n        var hullPointRecordsReordered = [];\n        if (indexOfLowestHullIndexRecord > 0) {\n            var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n            var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n            hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n        } else hullPointRecordsReordered = hullPointRecords;\n        var hullPoints = [];\n        n = hullPointRecordsReordered.length;\n        for(i = 0; i < n; i++)hullPoints.push(hullPointRecordsReordered[i][0]);\n        return hullPoints;\n    }\n    var Polyline = function(points) {\n        if (!(this instanceof Polyline)) return new Polyline(points);\n        if (typeof points === \"string\") return new Polyline.parse(points);\n        this.points = Array.isArray(points) ? points.map(Point) : [];\n    };\n    Polyline.parse = function(svgString) {\n        return new Polyline(parsePoints(svgString));\n    };\n    Polyline.fromRect = function(rect) {\n        return new Polyline([\n            rect.topLeft(),\n            rect.topRight(),\n            rect.bottomRight(),\n            rect.bottomLeft(),\n            rect.topLeft()\n        ]);\n    };\n    Polyline.prototype = {\n        type: types.Polyline,\n        bbox: function() {\n            var x1 = Infinity;\n            var x2 = -Infinity;\n            var y1 = Infinity;\n            var y2 = -Infinity;\n            var points = this.points;\n            var numPoints = points.length;\n            if (numPoints === 0) return null;\n             // if points array is empty\n            for(var i = 0; i < numPoints; i++){\n                var point = points[i];\n                var x = point.x;\n                var y = point.y;\n                if (x < x1) x1 = x;\n                if (x > x2) x2 = x;\n                if (y < y1) y1 = y;\n                if (y > y2) y2 = y;\n            }\n            return new Rect(x1, y1, x2 - x1, y2 - y1);\n        },\n        clone: function() {\n            return new Polyline(clonePoints(this.points));\n        },\n        closestPoint: function(p) {\n            var cpLength = this.closestPointLength(p);\n            return this.pointAtLength(cpLength);\n        },\n        closestPointLength: function(p) {\n            var points = this.lengthPoints();\n            var numPoints = points.length;\n            if (numPoints === 0) return 0;\n             // if points array is empty\n            if (numPoints === 1) return 0;\n             // if there is only one point\n            var cpLength;\n            var minSqrDistance = Infinity;\n            var length = 0;\n            var n = numPoints - 1;\n            for(var i = 0; i < n; i++){\n                var line = new Line(points[i], points[i + 1]);\n                var lineLength = line.length();\n                var cpNormalizedLength = line.closestPointNormalizedLength(p);\n                var cp = line.pointAt(cpNormalizedLength);\n                var sqrDistance = cp.squaredDistance(p);\n                if (sqrDistance < minSqrDistance) {\n                    minSqrDistance = sqrDistance;\n                    cpLength = length + cpNormalizedLength * lineLength;\n                }\n                length += lineLength;\n            }\n            return cpLength;\n        },\n        closestPointNormalizedLength: function(p) {\n            var cpLength = this.closestPointLength(p);\n            if (cpLength === 0) return 0;\n             // shortcut\n            var length = this.length();\n            if (length === 0) return 0;\n             // prevents division by zero\n            return cpLength / length;\n        },\n        closestPointTangent: function(p) {\n            var cpLength = this.closestPointLength(p);\n            return this.tangentAtLength(cpLength);\n        },\n        // Returns `true` if the area surrounded by the polyline contains the point `p`.\n        // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n        // (Uses horizontal rays to the right of `p` to look for intersections.)\n        // Closes open polylines (always imagines a final closing segment).\n        containsPoint: function(p) {\n            var points = this.points;\n            var numPoints = points.length;\n            if (numPoints === 0) return false;\n             // shortcut (this polyline has no points)\n            var x = p.x;\n            var y = p.y;\n            // initialize a final closing segment by creating one from last-first points on polyline\n            var startIndex = numPoints - 1; // start of current polyline segment\n            var endIndex = 0; // end of current polyline segment\n            var numIntersections = 0;\n            var segment = new Line();\n            var ray = new Line();\n            var rayEnd = new Point();\n            for(; endIndex < numPoints; endIndex++){\n                var start = points[startIndex];\n                var end = points[endIndex];\n                if (p.equals(start)) return true;\n                 // shortcut (`p` is a point on polyline)\n                // current polyline segment\n                segment.start = start;\n                segment.end = end;\n                if (segment.containsPoint(p)) return true;\n                 // shortcut (`p` lies on a polyline segment)\n                // do we have an intersection?\n                if (y <= start.y && y > end.y || y > start.y && y <= end.y) {\n                    // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n                    // (when `y === start.y === end.y`)\n                    // this conditional branch IS entered when `segment` touches `ray` at only one point\n                    // (e.g. when `y === start.y !== end.y`)\n                    // since this branch is entered again for the following segment, the two touches cancel out\n                    var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n                    if (xDifference >= 0) {\n                        // segment lies at least partially to the right of `p`\n                        rayEnd.x = x + xDifference;\n                        rayEnd.y = y; // right\n                        ray.start = p;\n                        ray.end = rayEnd;\n                        if (segment.intersect(ray)) // an intersection was detected to the right of `p`\n                        numIntersections++;\n                    } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n                }\n                // move to check the next polyline segment\n                startIndex = endIndex;\n            }\n            // returns `true` for odd numbers of intersections (even-odd algorithm)\n            return numIntersections % 2 === 1;\n        },\n        close: function() {\n            var ref = this;\n            var start = ref.start;\n            var end = ref.end;\n            var points = ref.points;\n            if (start && end && !start.equals(end)) points.push(start.clone());\n            return this;\n        },\n        lengthPoints: function() {\n            return this.points;\n        },\n        convexHull: function() {\n            return new Polyline(convexHull(this.points));\n        },\n        // Checks whether two polylines are exactly the same.\n        // If `p` is undefined or null, returns false.\n        equals: function(p) {\n            if (!p) return false;\n            var points = this.points;\n            var otherPoints = p.points;\n            var numPoints = points.length;\n            if (otherPoints.length !== numPoints) return false;\n             // if the two polylines have different number of points, they cannot be equal\n            for(var i = 0; i < numPoints; i++){\n                var point = points[i];\n                var otherPoint = p.points[i];\n                // as soon as an inequality is found in points, return false\n                if (!point.equals(otherPoint)) return false;\n            }\n            // if no inequality found in points, return true\n            return true;\n        },\n        intersectionWithLine: function(l) {\n            var line = new Line(l);\n            var intersections = [];\n            var points = this.lengthPoints();\n            var l2 = new Line();\n            for(var i = 0, n = points.length - 1; i < n; i++){\n                l2.start = points[i];\n                l2.end = points[i + 1];\n                var int = line.intersectionWithLine(l2);\n                if (int) intersections.push(int[0]);\n            }\n            return intersections.length > 0 ? intersections : null;\n        },\n        isDifferentiable: function() {\n            var points = this.points;\n            var numPoints = points.length;\n            if (numPoints === 0) return false;\n            var line = new Line();\n            var n = numPoints - 1;\n            for(var i = 0; i < n; i++){\n                line.start = points[i];\n                line.end = points[i + 1];\n                // as soon as a differentiable line is found between two points, return true\n                if (line.isDifferentiable()) return true;\n            }\n            // if no differentiable line is found between pairs of points, return false\n            return false;\n        },\n        length: function() {\n            var points = this.lengthPoints();\n            var numPoints = points.length;\n            if (numPoints === 0) return 0;\n             // if points array is empty\n            var length = 0;\n            var n = numPoints - 1;\n            for(var i = 0; i < n; i++)length += points[i].distance(points[i + 1]);\n            return length;\n        },\n        pointAt: function(ratio) {\n            var points = this.lengthPoints();\n            var numPoints = points.length;\n            if (numPoints === 0) return null;\n             // if points array is empty\n            if (numPoints === 1) return points[0].clone();\n             // if there is only one point\n            if (ratio <= 0) return points[0].clone();\n            if (ratio >= 1) return points[numPoints - 1].clone();\n            var polylineLength = this.length();\n            var length = polylineLength * ratio;\n            return this.pointAtLength(length);\n        },\n        pointAtLength: function(length) {\n            var points = this.lengthPoints();\n            var numPoints = points.length;\n            if (numPoints === 0) return null;\n             // if points array is empty\n            if (numPoints === 1) return points[0].clone();\n             // if there is only one point\n            var fromStart = true;\n            if (length < 0) {\n                fromStart = false; // negative lengths mean start calculation from end point\n                length = -length; // absolute value\n            }\n            var l = 0;\n            var n = numPoints - 1;\n            for(var i = 0; i < n; i++){\n                var index = fromStart ? i : n - 1 - i;\n                var a = points[index];\n                var b = points[index + 1];\n                var line = new Line(a, b);\n                var d = a.distance(b);\n                if (length <= l + d) return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n                l += d;\n            }\n            // if length requested is higher than the length of the polyline, return last endpoint\n            var lastPoint = fromStart ? points[numPoints - 1] : points[0];\n            return lastPoint.clone();\n        },\n        round: function(precision) {\n            var points = this.points;\n            var numPoints = points.length;\n            for(var i = 0; i < numPoints; i++)points[i].round(precision);\n            return this;\n        },\n        scale: function(sx, sy, origin) {\n            var points = this.points;\n            var numPoints = points.length;\n            for(var i = 0; i < numPoints; i++)points[i].scale(sx, sy, origin);\n            return this;\n        },\n        simplify: function(opt) {\n            if (opt === void 0) opt = {};\n            var points = this.points;\n            if (points.length < 3) return this;\n             // we need at least 3 points\n            // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n            var threshold = opt.threshold || 0; // = max distance of middle point from chord to be simplified\n            // start at the beginning of the polyline and go forward\n            var currentIndex = 0;\n            // we need at least one intermediate point (3 points) in every iteration\n            // as soon as that stops being true, we know we reached the end of the polyline\n            while(points[currentIndex + 2]){\n                var firstIndex = currentIndex;\n                var middleIndex = currentIndex + 1;\n                var lastIndex = currentIndex + 2;\n                var firstPoint = points[firstIndex];\n                var middlePoint = points[middleIndex];\n                var lastPoint = points[lastIndex];\n                var chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n                var closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n                var closestPointDistance = closestPoint.distance(middlePoint);\n                if (closestPointDistance <= threshold) // middle point is close enough to the chord = simplify\n                // 1) remove middle point:\n                points.splice(middleIndex, 1);\n                else // middle point is far from the chord\n                // 1) preserve middle point\n                // 2) in next iteration, move `currentIndex` by one step:\n                currentIndex += 1;\n            }\n            // `points` array was modified in-place\n            return this;\n        },\n        tangentAt: function(ratio) {\n            var points = this.lengthPoints();\n            var numPoints = points.length;\n            if (numPoints === 0) return null;\n             // if points array is empty\n            if (numPoints === 1) return null;\n             // if there is only one point\n            if (ratio < 0) ratio = 0;\n            if (ratio > 1) ratio = 1;\n            var polylineLength = this.length();\n            var length = polylineLength * ratio;\n            return this.tangentAtLength(length);\n        },\n        tangentAtLength: function(length) {\n            var points = this.lengthPoints();\n            var numPoints = points.length;\n            if (numPoints === 0) return null;\n             // if points array is empty\n            if (numPoints === 1) return null;\n             // if there is only one point\n            var fromStart = true;\n            if (length < 0) {\n                fromStart = false; // negative lengths mean start calculation from end point\n                length = -length; // absolute value\n            }\n            var lastValidLine; // differentiable (with a tangent)\n            var l = 0; // length so far\n            var n = numPoints - 1;\n            for(var i = 0; i < n; i++){\n                var index = fromStart ? i : n - 1 - i;\n                var a = points[index];\n                var b = points[index + 1];\n                var line = new Line(a, b);\n                var d = a.distance(b);\n                if (line.isDifferentiable()) {\n                    if (length <= l + d) return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n                    lastValidLine = line;\n                }\n                l += d;\n            }\n            // if length requested is higher than the length of the polyline, return last valid endpoint\n            if (lastValidLine) {\n                var ratio = fromStart ? 1 : 0;\n                return lastValidLine.tangentAt(ratio);\n            }\n            // if no valid line, return null\n            return null;\n        },\n        toString: function() {\n            return this.points + \"\";\n        },\n        translate: function(tx, ty) {\n            var points = this.points;\n            var numPoints = points.length;\n            for(var i = 0; i < numPoints; i++)points[i].translate(tx, ty);\n            return this;\n        },\n        // Return svgString that can be used to recreate this line.\n        serialize: function() {\n            var points = this.points;\n            var numPoints = points.length;\n            if (numPoints === 0) return \"\";\n             // if points array is empty\n            var output = \"\";\n            for(var i = 0; i < numPoints; i++){\n                var point = points[i];\n                output += point.x + \",\" + point.y + \" \";\n            }\n            return output.trim();\n        }\n    };\n    Object.defineProperty(Polyline.prototype, \"start\", {\n        // Getter for the first point of the polyline.\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            var points = this.points;\n            var numPoints = points.length;\n            if (numPoints === 0) return null;\n             // if points array is empty\n            return this.points[0];\n        }\n    });\n    Object.defineProperty(Polyline.prototype, \"end\", {\n        // Getter for the last point of the polyline.\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            var points = this.points;\n            var numPoints = points.length;\n            if (numPoints === 0) return null;\n             // if points array is empty\n            return this.points[numPoints - 1];\n        }\n    });\n    var abs$2 = Math.abs;\n    var sqrt$2 = Math.sqrt;\n    var min$6 = Math.min;\n    var max$4 = Math.max;\n    var pow$3 = Math.pow;\n    var Curve = function(p1, p2, p3, p4) {\n        if (!(this instanceof Curve)) return new Curve(p1, p2, p3, p4);\n        if (p1 instanceof Curve) return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n        this.start = new Point(p1);\n        this.controlPoint1 = new Point(p2);\n        this.controlPoint2 = new Point(p3);\n        this.end = new Point(p4);\n    };\n    // Curve passing through points.\n    // Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n    // @param {array} points Array of points through which the smooth line will go.\n    // @return {array} curves.\n    Curve.throughPoints = function() {\n        // Get open-ended Bezier Spline Control Points.\n        // @param knots Input Knot Bezier spline points (At least two points!).\n        // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n        // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n        function getCurveControlPoints(knots) {\n            var firstControlPoints = [];\n            var secondControlPoints = [];\n            var n = knots.length - 1;\n            var i;\n            // Special case: Bezier curve should be a straight line.\n            if (n == 1) {\n                // 3P1 = 2P0 + P3\n                firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);\n                // P2 = 2P1  P0\n                secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n                return [\n                    firstControlPoints,\n                    secondControlPoints\n                ];\n            }\n            // Calculate first Bezier control points.\n            // Right hand side vector.\n            var rhs = [];\n            // Set right hand side X values.\n            for(i = 1; i < n - 1; i++)rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n            rhs[0] = knots[0].x + 2 * knots[1].x;\n            rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n            // Get first control points X-values.\n            var x = getFirstControlPoints(rhs);\n            // Set right hand side Y values.\n            for(i = 1; i < n - 1; ++i)rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n            rhs[0] = knots[0].y + 2 * knots[1].y;\n            rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n            // Get first control points Y-values.\n            var y = getFirstControlPoints(rhs);\n            // Fill output arrays.\n            for(i = 0; i < n; i++){\n                // First control point.\n                firstControlPoints.push(new Point(x[i], y[i]));\n                // Second control point.\n                if (i < n - 1) secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n                else secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n            }\n            return [\n                firstControlPoints,\n                secondControlPoints\n            ];\n        }\n        // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n        // @param rhs Right hand side vector.\n        // @return Solution vector.\n        function getFirstControlPoints(rhs) {\n            var n = rhs.length;\n            // `x` is a solution vector.\n            var x = [];\n            var tmp = [];\n            var b = 2.0;\n            x[0] = rhs[0] / b;\n            // Decomposition and forward substitution.\n            for(var i = 1; i < n; i++){\n                tmp[i] = 1 / b;\n                b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n                x[i] = (rhs[i] - x[i - 1]) / b;\n            }\n            for(i = 1; i < n; i++)// Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n            return x;\n        }\n        return function(points) {\n            if (!points || Array.isArray(points) && points.length < 2) throw new Error(\"At least 2 points are required\");\n            var controlPoints = getCurveControlPoints(points);\n            var curves = [];\n            var n = controlPoints[0].length;\n            for(var i = 0; i < n; i++){\n                var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n                var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n                curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n            }\n            return curves;\n        };\n    }();\n    Curve.prototype = {\n        type: types.Curve,\n        // Returns a bbox that tightly envelops the curve.\n        bbox: function() {\n            var start = this.start;\n            var controlPoint1 = this.controlPoint1;\n            var controlPoint2 = this.controlPoint2;\n            var end = this.end;\n            var x0 = start.x;\n            var y0 = start.y;\n            var x1 = controlPoint1.x;\n            var y1 = controlPoint1.y;\n            var x2 = controlPoint2.x;\n            var y2 = controlPoint2.y;\n            var x3 = end.x;\n            var y3 = end.y;\n            var points = new Array(); // local extremes\n            var tvalues = new Array(); // t values of local extremes\n            var bounds = [\n                new Array(),\n                new Array()\n            ];\n            var a, b, c, t;\n            var t1, t2;\n            var b2ac, sqrtb2ac;\n            for(var i = 0; i < 2; ++i){\n                if (i === 0) {\n                    b = 6 * x0 - 12 * x1 + 6 * x2;\n                    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                    c = 3 * x1 - 3 * x0;\n                } else {\n                    b = 6 * y0 - 12 * y1 + 6 * y2;\n                    a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                    c = 3 * y1 - 3 * y0;\n                }\n                if (abs$2(a) < 1e-12) {\n                    if (abs$2(b) < 1e-12) continue;\n                    t = -c / b;\n                    if (0 < t && t < 1) tvalues.push(t);\n                    continue;\n                }\n                b2ac = b * b - 4 * c * a;\n                sqrtb2ac = sqrt$2(b2ac);\n                if (b2ac < 0) continue;\n                t1 = (-b + sqrtb2ac) / (2 * a);\n                if (0 < t1 && t1 < 1) tvalues.push(t1);\n                t2 = (-b - sqrtb2ac) / (2 * a);\n                if (0 < t2 && t2 < 1) tvalues.push(t2);\n            }\n            var j = tvalues.length;\n            var jlen = j;\n            var mt;\n            var x, y;\n            while(j--){\n                t = tvalues[j];\n                mt = 1 - t;\n                x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n                bounds[0][j] = x;\n                y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n                bounds[1][j] = y;\n                points[j] = {\n                    X: x,\n                    Y: y\n                };\n            }\n            tvalues[jlen] = 0;\n            tvalues[jlen + 1] = 1;\n            points[jlen] = {\n                X: x0,\n                Y: y0\n            };\n            points[jlen + 1] = {\n                X: x3,\n                Y: y3\n            };\n            bounds[0][jlen] = x0;\n            bounds[1][jlen] = y0;\n            bounds[0][jlen + 1] = x3;\n            bounds[1][jlen + 1] = y3;\n            tvalues.length = jlen + 2;\n            bounds[0].length = jlen + 2;\n            bounds[1].length = jlen + 2;\n            points.length = jlen + 2;\n            var left = min$6.apply(null, bounds[0]);\n            var top = min$6.apply(null, bounds[1]);\n            var right = max$4.apply(null, bounds[0]);\n            var bottom = max$4.apply(null, bounds[1]);\n            return new Rect(left, top, right - left, bottom - top);\n        },\n        clone: function() {\n            return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        },\n        // Returns the point on the curve closest to point `p`\n        closestPoint: function(p, opt) {\n            return this.pointAtT(this.closestPointT(p, opt));\n        },\n        closestPointLength: function(p, opt) {\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n                precision: precision\n            }) : opt.subdivisions;\n            var localOpt = {\n                precision: precision,\n                subdivisions: subdivisions\n            };\n            return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n        },\n        closestPointNormalizedLength: function(p, opt) {\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n                precision: precision\n            }) : opt.subdivisions;\n            var localOpt = {\n                precision: precision,\n                subdivisions: subdivisions\n            };\n            var cpLength = this.closestPointLength(p, localOpt);\n            if (!cpLength) return 0;\n            var length = this.length(localOpt);\n            if (length === 0) return 0;\n            return cpLength / length;\n        },\n        // Returns `t` of the point on the curve closest to point `p`\n        closestPointT: function(p, opt) {\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n                precision: precision\n            }) : opt.subdivisions;\n            // does not use localOpt\n            // identify the subdivision that contains the point:\n            var investigatedSubdivision;\n            var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n            var investigatedSubdivisionEndT;\n            var distFromStart; // distance of point from start of baseline\n            var distFromEnd; // distance of point from end of baseline\n            var chordLength; // distance between start and end of the subdivision\n            var minSumDist; // lowest observed sum of the two distances\n            var n = subdivisions.length;\n            var subdivisionSize = n ? 1 / n : 0;\n            for(var i = 0; i < n; i++){\n                var currentSubdivision = subdivisions[i];\n                var startDist = currentSubdivision.start.distance(p);\n                var endDist = currentSubdivision.end.distance(p);\n                var sumDist = startDist + endDist;\n                // check that the point is closest to current subdivision and not any other\n                if (!minSumDist || sumDist < minSumDist) {\n                    investigatedSubdivision = currentSubdivision;\n                    investigatedSubdivisionStartT = i * subdivisionSize;\n                    investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n                    distFromStart = startDist;\n                    distFromEnd = endDist;\n                    chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n                    minSumDist = sumDist;\n                }\n            }\n            var precisionRatio = pow$3(10, -precision);\n            // recursively divide investigated subdivision:\n            // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n            // then return the closest endpoint of that final subdivision\n            while(true){\n                // check if we have reached at least one required observed precision\n                // - calculated as: the difference in distances from point to start and end divided by the distance\n                // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n                // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n                // - this criterion works well for points lying far away from the curve\n                var startPrecisionRatio = distFromStart ? abs$2(distFromStart - distFromEnd) / distFromStart : 0;\n                var endPrecisionRatio = distFromEnd ? abs$2(distFromStart - distFromEnd) / distFromEnd : 0;\n                var hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio;\n                // check if we have reached at least one required minimal distance\n                // - calculated as: the subdivision chord length multiplied by precisionRatio\n                // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n                // - this is a backup criterion that works well for points lying \"almost at\" the curve\n                var hasMinimalStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;\n                var hasMinimalEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;\n                var hasMinimalDistance = hasMinimalStartDistance || hasMinimalEndDistance;\n                // do we stop now?\n                if (hasRequiredPrecision || hasMinimalDistance) return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;\n                // otherwise, set up for next iteration\n                var divided = investigatedSubdivision.divide(0.5);\n                subdivisionSize /= 2;\n                var startDist1 = divided[0].start.distance(p);\n                var endDist1 = divided[0].end.distance(p);\n                var sumDist1 = startDist1 + endDist1;\n                var startDist2 = divided[1].start.distance(p);\n                var endDist2 = divided[1].end.distance(p);\n                var sumDist2 = startDist2 + endDist2;\n                if (sumDist1 <= sumDist2) {\n                    investigatedSubdivision = divided[0];\n                    investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n                    distFromStart = startDist1;\n                    distFromEnd = endDist1;\n                } else {\n                    investigatedSubdivision = divided[1];\n                    investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n                    distFromStart = startDist2;\n                    distFromEnd = endDist2;\n                }\n            }\n        },\n        closestPointTangent: function(p, opt) {\n            return this.tangentAtT(this.closestPointT(p, opt));\n        },\n        // Returns `true` if the area surrounded by the curve contains the point `p`.\n        // Implements the even-odd algorithm (self-intersections are \"outside\").\n        // Closes open curves (always imagines a closing segment).\n        // Precision may be adjusted by passing an `opt` object.\n        containsPoint: function(p, opt) {\n            var polyline = this.toPolyline(opt);\n            return polyline.containsPoint(p);\n        },\n        // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n        // For a function that uses `t`, use Curve.divideAtT().\n        divideAt: function(ratio, opt) {\n            if (ratio <= 0) return this.divideAtT(0);\n            if (ratio >= 1) return this.divideAtT(1);\n            var t = this.tAt(ratio, opt);\n            return this.divideAtT(t);\n        },\n        // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n        divideAtLength: function(length, opt) {\n            var t = this.tAtLength(length, opt);\n            return this.divideAtT(t);\n        },\n        // Divides the curve into two at point defined by `t` between 0 and 1.\n        // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n        // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n        divideAtT: function(t) {\n            var start = this.start;\n            var controlPoint1 = this.controlPoint1;\n            var controlPoint2 = this.controlPoint2;\n            var end = this.end;\n            // shortcuts for `t` values that are out of range\n            if (t <= 0) return [\n                new Curve(start, start, start, start),\n                new Curve(start, controlPoint1, controlPoint2, end)\n            ];\n            if (t >= 1) return [\n                new Curve(start, controlPoint1, controlPoint2, end),\n                new Curve(end, end, end, end)\n            ];\n            var dividerPoints = this.getSkeletonPoints(t);\n            var startControl1 = dividerPoints.startControlPoint1;\n            var startControl2 = dividerPoints.startControlPoint2;\n            var divider = dividerPoints.divider;\n            var dividerControl1 = dividerPoints.dividerControlPoint1;\n            var dividerControl2 = dividerPoints.dividerControlPoint2;\n            // return array with two new curves\n            return [\n                new Curve(start, startControl1, startControl2, divider),\n                new Curve(divider, dividerControl1, dividerControl2, end)\n            ];\n        },\n        // Returns the distance between the curve's start and end points.\n        endpointDistance: function() {\n            return this.start.distance(this.end);\n        },\n        // Checks whether two curves are exactly the same.\n        equals: function(c) {\n            return !!c && this.start.x === c.start.x && this.start.y === c.start.y && this.controlPoint1.x === c.controlPoint1.x && this.controlPoint1.y === c.controlPoint1.y && this.controlPoint2.x === c.controlPoint2.x && this.controlPoint2.y === c.controlPoint2.y && this.end.x === c.end.x && this.end.y === c.end.y;\n        },\n        // Returns five helper points necessary for curve division.\n        getSkeletonPoints: function(t) {\n            var start = this.start;\n            var control1 = this.controlPoint1;\n            var control2 = this.controlPoint2;\n            var end = this.end;\n            // shortcuts for `t` values that are out of range\n            if (t <= 0) return {\n                startControlPoint1: start.clone(),\n                startControlPoint2: start.clone(),\n                divider: start.clone(),\n                dividerControlPoint1: control1.clone(),\n                dividerControlPoint2: control2.clone()\n            };\n            if (t >= 1) return {\n                startControlPoint1: control1.clone(),\n                startControlPoint2: control2.clone(),\n                divider: end.clone(),\n                dividerControlPoint1: end.clone(),\n                dividerControlPoint2: end.clone()\n            };\n            var midpoint1 = new Line(start, control1).pointAt(t);\n            var midpoint2 = new Line(control1, control2).pointAt(t);\n            var midpoint3 = new Line(control2, end).pointAt(t);\n            var subControl1 = new Line(midpoint1, midpoint2).pointAt(t);\n            var subControl2 = new Line(midpoint2, midpoint3).pointAt(t);\n            var divider = new Line(subControl1, subControl2).pointAt(t);\n            var output = {\n                startControlPoint1: midpoint1,\n                startControlPoint2: subControl1,\n                divider: divider,\n                dividerControlPoint1: subControl2,\n                dividerControlPoint2: midpoint3\n            };\n            return output;\n        },\n        // Returns a list of curves whose flattened length is better than `opt.precision`.\n        // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n        // (Observed difference is not real precision, but close enough as long as special cases are covered)\n        // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)\n        // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)\n        // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)\n        // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n        // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n        // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n        // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n        getSubdivisions: function(opt) {\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            // not using opt.subdivisions\n            // not using localOpt\n            var start = this.start;\n            var control1 = this.controlPoint1;\n            var control2 = this.controlPoint2;\n            var end = this.end;\n            var subdivisions = [\n                new Curve(start, control1, control2, end)\n            ];\n            if (precision === 0) return subdivisions;\n            // special case #1: point-like curves\n            // - no need to calculate subdivisions, they would all be identical\n            var isPoint = !this.isDifferentiable();\n            if (isPoint) return subdivisions;\n            var previousLength = this.endpointDistance();\n            var precisionRatio = pow$3(10, -precision);\n            // special case #2: sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n            // - not a problem for further iterations because cubic curves cannot have more than two local extrema\n            // - (i.e. cubic curves cannot intersect the baseline more than once)\n            // - therefore starting from iteration = 2 ensures that subsequent iterations do not produce sampling with equal length\n            // - (unless it's a straight-line curve, see below)\n            var minIterations = 2; // = 2*1\n            // special case #3: straight-line curves have the same observed length in all iterations\n            // - this causes observed precision ratio to always be 0 (= lower than `precisionRatio`, which is our exit condition)\n            // - we enforce the expected number of iterations = 2 * precision\n            var isLine = control1.cross(start, end) === 0 && control2.cross(start, end) === 0;\n            if (isLine) minIterations = 2 * precision;\n            // recursively divide curve at `t = 0.5`\n            // until we reach `minIterations`\n            // and until the difference between observed length at subsequent iterations is lower than `precision`\n            var iteration = 0;\n            while(true){\n                iteration += 1;\n                // divide all subdivisions\n                var newSubdivisions = [];\n                var numSubdivisions = subdivisions.length;\n                for(var i = 0; i < numSubdivisions; i++){\n                    var currentSubdivision = subdivisions[i];\n                    var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n                    newSubdivisions.push(divided[0], divided[1]);\n                }\n                // measure new length\n                var length = 0;\n                var numNewSubdivisions = newSubdivisions.length;\n                for(var j = 0; j < numNewSubdivisions; j++){\n                    var currentNewSubdivision = newSubdivisions[j];\n                    length += currentNewSubdivision.endpointDistance();\n                }\n                // check if we have reached minimum number of iterations\n                if (iteration >= minIterations) {\n                    // check if we have reached required observed precision\n                    var observedPrecisionRatio = length !== 0 ? (length - previousLength) / length : 0;\n                    if (observedPrecisionRatio < precisionRatio) return newSubdivisions;\n                }\n                // otherwise, set up for next iteration\n                subdivisions = newSubdivisions;\n                previousLength = length;\n            }\n        },\n        isDifferentiable: function() {\n            var start = this.start;\n            var control1 = this.controlPoint1;\n            var control2 = this.controlPoint2;\n            var end = this.end;\n            return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n        },\n        // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n        length: function(opt) {\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n            var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n                precision: precision\n            }) : opt.subdivisions;\n            // not using localOpt\n            var length = 0;\n            var n = subdivisions.length;\n            for(var i = 0; i < n; i++){\n                var currentSubdivision = subdivisions[i];\n                length += currentSubdivision.endpointDistance();\n            }\n            return length;\n        },\n        // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n        lengthAtT: function(t, opt) {\n            if (t <= 0) return 0;\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            // not using opt.subdivisions\n            // not using localOpt\n            var subCurve = this.divide(t)[0];\n            var subCurveLength = subCurve.length({\n                precision: precision\n            });\n            return subCurveLength;\n        },\n        // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n        // Mirrors Line.pointAt() function.\n        // For a function that tracks `t`, use Curve.pointAtT().\n        pointAt: function(ratio, opt) {\n            if (ratio <= 0) return this.start.clone();\n            if (ratio >= 1) return this.end.clone();\n            var t = this.tAt(ratio, opt);\n            return this.pointAtT(t);\n        },\n        // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n        pointAtLength: function(length, opt) {\n            var t = this.tAtLength(length, opt);\n            return this.pointAtT(t);\n        },\n        // Returns the point at provided `t` between 0 and 1.\n        // `t` does not track distance along curve as it does in Line objects.\n        // Non-linear relationship, speeds up and slows down as curve warps!\n        // For linear length-based solution, use Curve.pointAt().\n        pointAtT: function(t) {\n            if (t <= 0) return this.start.clone();\n            if (t >= 1) return this.end.clone();\n            return this.getSkeletonPoints(t).divider;\n        },\n        // Default precision\n        PRECISION: 3,\n        round: function(precision) {\n            this.start.round(precision);\n            this.controlPoint1.round(precision);\n            this.controlPoint2.round(precision);\n            this.end.round(precision);\n            return this;\n        },\n        scale: function(sx, sy, origin) {\n            this.start.scale(sx, sy, origin);\n            this.controlPoint1.scale(sx, sy, origin);\n            this.controlPoint2.scale(sx, sy, origin);\n            this.end.scale(sx, sy, origin);\n            return this;\n        },\n        // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n        tangentAt: function(ratio, opt) {\n            if (!this.isDifferentiable()) return null;\n            if (ratio < 0) ratio = 0;\n            else if (ratio > 1) ratio = 1;\n            var t = this.tAt(ratio, opt);\n            return this.tangentAtT(t);\n        },\n        // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n        tangentAtLength: function(length, opt) {\n            if (!this.isDifferentiable()) return null;\n            var t = this.tAtLength(length, opt);\n            return this.tangentAtT(t);\n        },\n        // Returns a tangent line at requested `t`.\n        tangentAtT: function(t) {\n            if (!this.isDifferentiable()) return null;\n            if (t < 0) t = 0;\n            else if (t > 1) t = 1;\n            var skeletonPoints = this.getSkeletonPoints(t);\n            var p1 = skeletonPoints.startControlPoint2;\n            var p2 = skeletonPoints.dividerControlPoint1;\n            var tangentStart = skeletonPoints.divider;\n            var tangentLine = new Line(p1, p2);\n            tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n            return tangentLine;\n        },\n        // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n        tAt: function(ratio, opt) {\n            if (ratio <= 0) return 0;\n            if (ratio >= 1) return 1;\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n                precision: precision\n            }) : opt.subdivisions;\n            var localOpt = {\n                precision: precision,\n                subdivisions: subdivisions\n            };\n            var curveLength = this.length(localOpt);\n            var length = curveLength * ratio;\n            return this.tAtLength(length, localOpt);\n        },\n        // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n        // Uses `precision` to approximate length within `precision` (always underestimates)\n        // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n        // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n        // - Precision 0 (chooses one of the two endpoints) - 0 levels\n        // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n        // - Precision 2 (<1% error) - 3 levels\n        // - Precision 3 (<0.1% error) - 7 levels\n        // - Precision 4 (<0.01% error) - 15 levels\n        tAtLength: function(length, opt) {\n            var fromStart = true;\n            if (length < 0) {\n                fromStart = false; // negative lengths mean start calculation from end point\n                length = -length; // absolute value\n            }\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n                precision: precision\n            }) : opt.subdivisions;\n            var localOpt = {\n                precision: precision,\n                subdivisions: subdivisions\n            };\n            // identify the subdivision that contains the point at requested `length`:\n            var investigatedSubdivision;\n            var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n            var investigatedSubdivisionEndT;\n            //var baseline; // straightened version of subdivision to investigate\n            //var baselinePoint; // point on the baseline that is the requested distance away from start\n            var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n            var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n            var l = 0; // length so far\n            var n = subdivisions.length;\n            var subdivisionSize = 1 / n;\n            for(var i = 0; i < n; i++){\n                var index = fromStart ? i : n - 1 - i;\n                var currentSubdivision = subdivisions[i];\n                var d = currentSubdivision.endpointDistance(); // length of current subdivision\n                if (length <= l + d) {\n                    investigatedSubdivision = currentSubdivision;\n                    investigatedSubdivisionStartT = index * subdivisionSize;\n                    investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n                    baselinePointDistFromStart = fromStart ? length - l : d + l - length;\n                    baselinePointDistFromEnd = fromStart ? d + l - length : length - l;\n                    break;\n                }\n                l += d;\n            }\n            if (!investigatedSubdivision) return fromStart ? 1 : 0;\n             // length requested is out of range - return maximum t\n            // note that precision affects what length is recorded\n            // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n            // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n            var curveLength = this.length(localOpt);\n            var precisionRatio = pow$3(10, -precision);\n            // recursively divide investigated subdivision:\n            // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n            // then return the closest endpoint of that final subdivision\n            while(true){\n                // check if we have reached required observed precision\n                var observedPrecisionRatio;\n                observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromStart / curveLength : 0;\n                if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n                observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromEnd / curveLength : 0;\n                if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;\n                // otherwise, set up for next iteration\n                var newBaselinePointDistFromStart;\n                var newBaselinePointDistFromEnd;\n                var divided = investigatedSubdivision.divide(0.5);\n                subdivisionSize /= 2;\n                var baseline1Length = divided[0].endpointDistance();\n                var baseline2Length = divided[1].endpointDistance();\n                if (baselinePointDistFromStart <= baseline1Length) {\n                    investigatedSubdivision = divided[0];\n                    investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n                    newBaselinePointDistFromStart = baselinePointDistFromStart;\n                    newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n                } else {\n                    investigatedSubdivision = divided[1];\n                    investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n                    newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n                    newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n                }\n                baselinePointDistFromStart = newBaselinePointDistFromStart;\n                baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n            }\n        },\n        // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n        // Flattened length is no more than 10^(-precision) away from real curve length.\n        toPoints: function(opt) {\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n            var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n                precision: precision\n            }) : opt.subdivisions;\n            // not using localOpt\n            var points = [\n                subdivisions[0].start.clone()\n            ];\n            var n = subdivisions.length;\n            for(var i = 0; i < n; i++){\n                var currentSubdivision = subdivisions[i];\n                points.push(currentSubdivision.end.clone());\n            }\n            return points;\n        },\n        // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n        // Flattened length is no more than 10^(-precision) away from real curve length.\n        toPolyline: function(opt) {\n            return new Polyline(this.toPoints(opt));\n        },\n        toString: function() {\n            return this.start + \" \" + this.controlPoint1 + \" \" + this.controlPoint2 + \" \" + this.end;\n        },\n        translate: function(tx, ty) {\n            this.start.translate(tx, ty);\n            this.controlPoint1.translate(tx, ty);\n            this.controlPoint2.translate(tx, ty);\n            this.end.translate(tx, ty);\n            return this;\n        }\n    };\n    Curve.prototype.divide = Curve.prototype.divideAtT;\n    // Local helper function.\n    // Add properties from arguments on top of properties from `obj`.\n    // This allows for rudimentary inheritance.\n    // - The `obj` argument acts as parent.\n    // - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n    // - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\n    function extend(obj) {\n        var arguments$1 = arguments;\n        // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n        // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n        // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n        // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n        // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n        // - This method provides a way to do exactly that.\n        // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n        // - Therefore, to continue with the example above:\n        //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n        //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n        //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n        //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n        // - Multiple inheritance is also possible, if multiple arguments are provided.\n        // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n        //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n        //   - The ancestors are applied in order of appearance.\n        //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n        //   - Any number of ancestors may be provided.\n        // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n        // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n        //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n        //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n        // - Therefore, both of the following are valid:\n        //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n        //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n        var i;\n        var n;\n        var args = [];\n        n = arguments.length;\n        for(i = 1; i < n; i++)args.push(arguments$1[i]);\n        if (!obj) throw new Error(\"Missing a parent object.\");\n        var child = Object.create(obj);\n        n = args.length;\n        for(i = 0; i < n; i++){\n            var src = args[i];\n            var inheritedProperty;\n            var key;\n            for(key in src)if (src.hasOwnProperty(key)) {\n                delete child[key]; // delete property inherited from parent\n                inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n                Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n            }\n        }\n        return child;\n    }\n    // Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n    var Path = function(arg) {\n        if (!(this instanceof Path)) return new Path(arg);\n        if (typeof arg === \"string\") return new Path.parse(arg);\n        this.segments = [];\n        var i;\n        var n;\n        if (!arg) ;\n        else if (Array.isArray(arg) && arg.length !== 0) {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n            n = arg.length;\n            if (arg[0].isSegment) for(i = 0; i < n; i++){\n                var segment = arg[i];\n                this.appendSegment(segment);\n            }\n            else {\n                var previousObj = null;\n                for(i = 0; i < n; i++){\n                    var obj = arg[i];\n                    if (!(obj instanceof Line || obj instanceof Curve)) throw new Error(\"Cannot construct a path segment from the provided object.\");\n                    if (i === 0) this.appendSegment(Path.createSegment(\"M\", obj.start));\n                    // if objects do not link up, moveto segments are inserted to cover the gaps\n                    if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path.createSegment(\"M\", obj.start));\n                    if (obj instanceof Line) this.appendSegment(Path.createSegment(\"L\", obj.end));\n                    else if (obj instanceof Curve) this.appendSegment(Path.createSegment(\"C\", obj.controlPoint1, obj.controlPoint2, obj.end));\n                    previousObj = obj;\n                }\n            }\n        } else if (arg.isSegment) this.appendSegment(arg);\n        else if (arg instanceof Line) {\n            this.appendSegment(Path.createSegment(\"M\", arg.start));\n            this.appendSegment(Path.createSegment(\"L\", arg.end));\n        } else if (arg instanceof Curve) {\n            this.appendSegment(Path.createSegment(\"M\", arg.start));\n            this.appendSegment(Path.createSegment(\"C\", arg.controlPoint1, arg.controlPoint2, arg.end));\n        } else if (arg instanceof Polyline) {\n            if (!(arg.points && arg.points.length !== 0)) return;\n             // if Polyline has no points, leave Path empty\n            n = arg.points.length;\n            for(i = 0; i < n; i++){\n                var point = arg.points[i];\n                if (i === 0) this.appendSegment(Path.createSegment(\"M\", point));\n                else this.appendSegment(Path.createSegment(\"L\", point));\n            }\n        } else throw new Error(\"Cannot construct a path from the provided object.\");\n    };\n    // More permissive than V.normalizePathData and Path.prototype.serialize.\n    // Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n    // Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n    // Allows for command argument chaining.\n    // Throws an error if wrong number of arguments is provided with a command.\n    // Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\n    Path.parse = function(pathData) {\n        if (!pathData) return new Path();\n        var path = new Path();\n        var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n        var commands = pathData.match(commandRe);\n        var numCommands = commands.length;\n        for(var i = 0; i < numCommands; i++){\n            var command = commands[i];\n            var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n            var args = command.match(argRe);\n            var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n            path.appendSegment(segment);\n        }\n        return path;\n    };\n    // Create a segment or an array of segments.\n    // Accepts unlimited points/coords arguments after `type`.\n    Path.createSegment = function(type) {\n        var arguments$1 = arguments;\n        if (!type) throw new Error(\"Type must be provided.\");\n        var segmentConstructor = Path.segmentTypes[type];\n        if (!segmentConstructor) throw new Error(type + \" is not a recognized path segment type.\");\n        var args = [];\n        var n = arguments.length;\n        for(var i = 1; i < n; i++)args.push(arguments$1[i]);\n        return applyToNew(segmentConstructor, args);\n    };\n    Path.prototype = {\n        type: types.Path,\n        // Accepts one segment or an array of segments as argument.\n        // Throws an error if argument is not a segment or an array of segments.\n        appendSegment: function(arg) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            // works even if path has no segments\n            var currentSegment;\n            var previousSegment = numSegments !== 0 ? segments[numSegments - 1] : null; // if we are appending to an empty path, previousSegment is null\n            var nextSegment = null;\n            if (!Array.isArray(arg)) {\n                if (!arg || !arg.isSegment) throw new Error(\"Segment required.\");\n                currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n                segments.push(currentSegment);\n            } else {\n                // flatten one level deep\n                // so we can chain arbitrary Path.createSegment results\n                arg = arg.reduce(function(acc, val) {\n                    return acc.concat(val);\n                }, []);\n                if (!arg[0].isSegment) throw new Error(\"Segments required.\");\n                var n = arg.length;\n                for(var i = 0; i < n; i++){\n                    var currentArg = arg[i];\n                    currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                    segments.push(currentSegment);\n                    previousSegment = currentSegment;\n                }\n            }\n        },\n        // Returns the bbox of the path.\n        // If path has no segments, returns null.\n        // If path has only invisible segments, returns bbox of the end point of last segment.\n        bbox: function() {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            var bbox;\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                if (segment.isVisible) {\n                    var segmentBBox = segment.bbox();\n                    bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n                }\n            }\n            if (bbox) return bbox;\n            // if the path has only invisible elements, return end point of last segment\n            var lastSegment = segments[numSegments - 1];\n            return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n        },\n        // Returns a new path that is a clone of this path.\n        clone: function() {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            // works even if path has no segments\n            var path = new Path();\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i].clone();\n                path.appendSegment(segment);\n            }\n            return path;\n        },\n        closestPoint: function(p, opt) {\n            var t = this.closestPointT(p, opt);\n            if (!t) return null;\n            return this.pointAtT(t);\n        },\n        closestPointLength: function(p, opt) {\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            var localOpt = {\n                precision: precision,\n                segmentSubdivisions: segmentSubdivisions\n            };\n            var t = this.closestPointT(p, localOpt);\n            if (!t) return 0;\n            return this.lengthAtT(t, localOpt);\n        },\n        closestPointNormalizedLength: function(p, opt) {\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            var localOpt = {\n                precision: precision,\n                segmentSubdivisions: segmentSubdivisions\n            };\n            var cpLength = this.closestPointLength(p, localOpt);\n            if (cpLength === 0) return 0;\n             // shortcut\n            var length = this.length(localOpt);\n            if (length === 0) return 0;\n             // prevents division by zero\n            return cpLength / length;\n        },\n        // Private function.\n        closestPointT: function(p, opt) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            // not using localOpt\n            var closestPointT;\n            var minSquaredDistance = Infinity;\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                var subdivisions = segmentSubdivisions[i];\n                if (segment.isVisible) {\n                    var segmentClosestPointT = segment.closestPointT(p, {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                    var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                    var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();\n                    if (squaredDistance < minSquaredDistance) {\n                        closestPointT = {\n                            segmentIndex: i,\n                            value: segmentClosestPointT\n                        };\n                        minSquaredDistance = squaredDistance;\n                    }\n                }\n            }\n            if (closestPointT) return closestPointT;\n            // if no visible segment, return end of last segment\n            return {\n                segmentIndex: numSegments - 1,\n                value: 1\n            };\n        },\n        closestPointTangent: function(p, opt) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            // not using localOpt\n            var closestPointTangent;\n            var minSquaredDistance = Infinity;\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                var subdivisions = segmentSubdivisions[i];\n                if (segment.isDifferentiable()) {\n                    var segmentClosestPointT = segment.closestPointT(p, {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                    var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                    var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();\n                    if (squaredDistance < minSquaredDistance) {\n                        closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n                        minSquaredDistance = squaredDistance;\n                    }\n                }\n            }\n            if (closestPointTangent) return closestPointTangent;\n            // if no valid segment, return null\n            return null;\n        },\n        // Returns `true` if the area surrounded by the path contains the point `p`.\n        // Implements the even-odd algorithm (self-intersections are \"outside\").\n        // Closes open paths (always imagines a final closing segment).\n        // Precision may be adjusted by passing an `opt` object.\n        containsPoint: function(p, opt) {\n            var polylines = this.toPolylines(opt);\n            if (!polylines) return false;\n             // shortcut (this path has no polylines)\n            var numPolylines = polylines.length;\n            // how many component polylines does `p` lie within?\n            var numIntersections = 0;\n            for(var i = 0; i < numPolylines; i++){\n                var polyline = polylines[i];\n                if (polyline.containsPoint(p)) // `p` lies within this polyline\n                numIntersections++;\n            }\n            // returns `true` for odd numbers of intersections (even-odd algorithm)\n            return numIntersections % 2 === 1;\n        },\n        // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n        divideAt: function(ratio, opt) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            if (ratio < 0) ratio = 0;\n            if (ratio > 1) ratio = 1;\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            var localOpt = {\n                precision: precision,\n                segmentSubdivisions: segmentSubdivisions\n            };\n            var pathLength = this.length(localOpt);\n            var length = pathLength * ratio;\n            return this.divideAtLength(length, localOpt);\n        },\n        // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n        divideAtLength: function(length, opt) {\n            var numSegments = this.segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            var fromStart = true;\n            if (length < 0) {\n                fromStart = false; // negative lengths mean start calculation from end point\n                length = -length; // absolute value\n            }\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            // not using localOpt\n            var i;\n            var segment;\n            // identify the segment to divide:\n            var l = 0; // length so far\n            var divided;\n            var dividedSegmentIndex;\n            var lastValidSegment; // visible AND differentiable\n            var lastValidSegmentIndex;\n            var t;\n            for(i = 0; i < numSegments; i++){\n                var index = fromStart ? i : numSegments - 1 - i;\n                segment = this.getSegment(index);\n                var subdivisions = segmentSubdivisions[index];\n                var d = segment.length({\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                if (segment.isDifferentiable()) {\n                    lastValidSegment = segment;\n                    lastValidSegmentIndex = index;\n                    if (length <= l + d) {\n                        dividedSegmentIndex = index;\n                        divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - l), {\n                            precision: precision,\n                            subdivisions: subdivisions\n                        });\n                        break;\n                    }\n                }\n                l += d;\n            }\n            if (!lastValidSegment) return null;\n            // else: the path contains at least one valid segment\n            if (!divided) {\n                dividedSegmentIndex = lastValidSegmentIndex;\n                t = fromStart ? 1 : 0;\n                divided = lastValidSegment.divideAtT(t);\n            }\n            // create a copy of this path and replace the identified segment with its two divided parts:\n            var pathCopy = this.clone();\n            pathCopy.replaceSegment(dividedSegmentIndex, divided);\n            var divisionStartIndex = dividedSegmentIndex;\n            var divisionMidIndex = dividedSegmentIndex + 1;\n            var divisionEndIndex = dividedSegmentIndex + 2;\n            // do not insert the part if it looks like a point\n            if (!divided[0].isDifferentiable()) {\n                pathCopy.removeSegment(divisionStartIndex);\n                divisionMidIndex -= 1;\n                divisionEndIndex -= 1;\n            }\n            // insert a Moveto segment to ensure secondPath will be valid:\n            var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n            pathCopy.insertSegment(divisionMidIndex, Path.createSegment(\"M\", movetoEnd));\n            divisionEndIndex += 1;\n            // do not insert the part if it looks like a point\n            if (!divided[1].isDifferentiable()) {\n                pathCopy.removeSegment(divisionEndIndex - 1);\n                divisionEndIndex -= 1;\n            }\n            // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n            var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n            for(i = divisionEndIndex; i < pathCopy.segments.length; i++){\n                var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n                segment = pathCopy.getSegment(i);\n                if (segment.type === \"Z\" && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n                    // pathCopy segment's subpathStartSegment is different from original segment's one\n                    // convert this Closepath segment to a Lineto and replace it in pathCopy\n                    var convertedSegment = Path.createSegment(\"L\", originalSegment.end);\n                    pathCopy.replaceSegment(i, convertedSegment);\n                }\n            }\n            // distribute pathCopy segments into two paths and return those:\n            var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n            var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n            return [\n                firstPath,\n                secondPath\n            ];\n        },\n        // Checks whether two paths are exactly the same.\n        // If `p` is undefined or null, returns false.\n        equals: function(p) {\n            if (!p) return false;\n            var segments = this.segments;\n            var otherSegments = p.segments;\n            var numSegments = segments.length;\n            if (otherSegments.length !== numSegments) return false;\n             // if the two paths have different number of segments, they cannot be equal\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                var otherSegment = otherSegments[i];\n                // as soon as an inequality is found in segments, return false\n                if (segment.type !== otherSegment.type || !segment.equals(otherSegment)) return false;\n            }\n            // if no inequality found in segments, return true\n            return true;\n        },\n        // Accepts negative indices.\n        // Throws an error if path has no segments.\n        // Throws an error if index is out of range.\n        getSegment: function(index) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) throw new Error(\"Path has no segments.\");\n            if (index < 0) index = numSegments + index;\n             // convert negative indices to positive\n            if (index >= numSegments || index < 0) throw new Error(\"Index out of range.\");\n            return segments[index];\n        },\n        // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n        getSegmentSubdivisions: function(opt) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            // works even if path has no segments\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            // not using opt.segmentSubdivisions\n            // not using localOpt\n            var segmentSubdivisions = [];\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                var subdivisions = segment.getSubdivisions({\n                    precision: precision\n                });\n                segmentSubdivisions.push(subdivisions);\n            }\n            return segmentSubdivisions;\n        },\n        // Returns an array of subpaths of this path.\n        // Invalid paths are validated first.\n        // Returns `[]` if path has no segments.\n        getSubpaths: function() {\n            var validatedPath = this.clone().validate();\n            var segments = validatedPath.segments;\n            var numSegments = segments.length;\n            var subpaths = [];\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                if (segment.isSubpathStart) // we encountered a subpath start segment\n                // create a new path for segment, and push it to list of subpaths\n                subpaths.push(new Path(segment));\n                else // append current segment to the last subpath\n                subpaths[subpaths.length - 1].appendSegment(segment);\n            }\n            return subpaths;\n        },\n        // Insert `arg` at given `index`.\n        // `index = 0` means insert at the beginning.\n        // `index = segments.length` means insert at the end.\n        // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n        // Accepts one segment or an array of segments as argument.\n        // Throws an error if index is out of range.\n        // Throws an error if argument is not a segment or an array of segments.\n        insertSegment: function(index, arg) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            // works even if path has no segments\n            // note that these are incremented compared to getSegments()\n            // we can insert after last element (note that this changes the meaning of index -1)\n            if (index < 0) index = numSegments + index + 1;\n             // convert negative indices to positive\n            if (index > numSegments || index < 0) throw new Error(\"Index out of range.\");\n            var currentSegment;\n            var previousSegment = null;\n            var nextSegment = null;\n            if (numSegments !== 0) {\n                if (index >= 1) {\n                    previousSegment = segments[index - 1];\n                    nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n                } else // previousSegment is null\n                nextSegment = segments[0];\n            }\n            if (!Array.isArray(arg)) {\n                if (!arg || !arg.isSegment) throw new Error(\"Segment required.\");\n                currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n                segments.splice(index, 0, currentSegment);\n            } else {\n                // flatten one level deep\n                // so we can chain arbitrary Path.createSegment results\n                arg = arg.reduce(function(acc, val) {\n                    return acc.concat(val);\n                }, []);\n                if (!arg[0].isSegment) throw new Error(\"Segments required.\");\n                var n = arg.length;\n                for(var i = 0; i < n; i++){\n                    var currentArg = arg[i];\n                    currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                    segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                    previousSegment = currentSegment;\n                }\n            }\n        },\n        intersectionWithLine: function(line, opt) {\n            var intersection = null;\n            var polylines = this.toPolylines(opt);\n            if (!polylines) return null;\n            for(var i = 0, n = polylines.length; i < n; i++){\n                var polyline = polylines[i];\n                var polylineIntersection = line.intersect(polyline);\n                if (polylineIntersection) {\n                    intersection || (intersection = []);\n                    if (Array.isArray(polylineIntersection)) Array.prototype.push.apply(intersection, polylineIntersection);\n                    else intersection.push(polylineIntersection);\n                }\n            }\n            return intersection;\n        },\n        isDifferentiable: function() {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                // as soon as a differentiable segment is found in segments, return true\n                if (segment.isDifferentiable()) return true;\n            }\n            // if no differentiable segment is found in segments, return false\n            return false;\n        },\n        // Checks whether current path segments are valid.\n        // Note that d is allowed to be empty - should disable rendering of the path.\n        isValid: function() {\n            var segments = this.segments;\n            var isValid = segments.length === 0 || segments[0].type === \"M\"; // either empty or first segment is a Moveto\n            return isValid;\n        },\n        // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n        // If path has no segments, returns 0.\n        length: function(opt) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return 0;\n             // if segments is an empty array\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            // not using localOpt\n            var length = 0;\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                var subdivisions = segmentSubdivisions[i];\n                length += segment.length({\n                    subdivisions: subdivisions\n                });\n            }\n            return length;\n        },\n        // Private function.\n        lengthAtT: function(t, opt) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return 0;\n             // if segments is an empty array\n            var segmentIndex = t.segmentIndex;\n            if (segmentIndex < 0) return 0;\n             // regardless of t.value\n            var tValue = t.value;\n            if (segmentIndex >= numSegments) {\n                segmentIndex = numSegments - 1;\n                tValue = 1;\n            } else if (tValue < 0) tValue = 0;\n            else if (tValue > 1) tValue = 1;\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            // not using localOpt\n            var subdivisions;\n            var length = 0;\n            for(var i = 0; i < segmentIndex; i++){\n                var segment = segments[i];\n                subdivisions = segmentSubdivisions[i];\n                length += segment.length({\n                    precisison: precision,\n                    subdivisions: subdivisions\n                });\n            }\n            segment = segments[segmentIndex];\n            subdivisions = segmentSubdivisions[segmentIndex];\n            length += segment.lengthAtT(tValue, {\n                precisison: precision,\n                subdivisions: subdivisions\n            });\n            return length;\n        },\n        // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n        pointAt: function(ratio, opt) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            if (ratio <= 0) return this.start.clone();\n            if (ratio >= 1) return this.end.clone();\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            var localOpt = {\n                precision: precision,\n                segmentSubdivisions: segmentSubdivisions\n            };\n            var pathLength = this.length(localOpt);\n            var length = pathLength * ratio;\n            return this.pointAtLength(length, localOpt);\n        },\n        // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n        // Accepts negative length.\n        pointAtLength: function(length, opt) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            if (length === 0) return this.start.clone();\n            var fromStart = true;\n            if (length < 0) {\n                fromStart = false; // negative lengths mean start calculation from end point\n                length = -length; // absolute value\n            }\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            // not using localOpt\n            var lastVisibleSegment;\n            var l = 0; // length so far\n            for(var i = 0; i < numSegments; i++){\n                var index = fromStart ? i : numSegments - 1 - i;\n                var segment = segments[index];\n                var subdivisions = segmentSubdivisions[index];\n                var d = segment.length({\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                if (segment.isVisible) {\n                    if (length <= l + d) return segment.pointAtLength((fromStart ? 1 : -1) * (length - l), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                    lastVisibleSegment = segment;\n                }\n                l += d;\n            }\n            // if length requested is higher than the length of the path, return last visible segment endpoint\n            if (lastVisibleSegment) return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n            // if no visible segment, return last segment end point (no matter if fromStart or no)\n            var lastSegment = segments[numSegments - 1];\n            return lastSegment.end.clone();\n        },\n        // Private function.\n        pointAtT: function(t) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            var segmentIndex = t.segmentIndex;\n            if (segmentIndex < 0) return segments[0].pointAtT(0);\n            if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n            var tValue = t.value;\n            if (tValue < 0) tValue = 0;\n            else if (tValue > 1) tValue = 1;\n            return segments[segmentIndex].pointAtT(tValue);\n        },\n        // Default precision\n        PRECISION: 3,\n        // Helper method for adding segments.\n        prepareSegment: function(segment, previousSegment, nextSegment) {\n            // insert after previous segment and before previous segment's next segment\n            segment.previousSegment = previousSegment;\n            segment.nextSegment = nextSegment;\n            if (previousSegment) previousSegment.nextSegment = segment;\n            if (nextSegment) nextSegment.previousSegment = segment;\n            var updateSubpathStart = segment;\n            if (segment.isSubpathStart) {\n                segment.subpathStartSegment = segment; // assign self as subpath start segment\n                updateSubpathStart = nextSegment; // start updating from next segment\n            }\n            // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n            if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n            return segment;\n        },\n        // Remove the segment at `index`.\n        // Accepts negative indices, from `-1` to `-segments.length`.\n        // Throws an error if path has no segments.\n        // Throws an error if index is out of range.\n        removeSegment: function(index) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) throw new Error(\"Path has no segments.\");\n            if (index < 0) index = numSegments + index;\n             // convert negative indices to positive\n            if (index >= numSegments || index < 0) throw new Error(\"Index out of range.\");\n            var removedSegment = segments.splice(index, 1)[0];\n            var previousSegment = removedSegment.previousSegment;\n            var nextSegment = removedSegment.nextSegment;\n            // link the previous and next segments together (if present)\n            if (previousSegment) previousSegment.nextSegment = nextSegment;\n             // may be null\n            if (nextSegment) nextSegment.previousSegment = previousSegment;\n             // may be null\n            // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n            if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n        },\n        // Replace the segment at `index` with `arg`.\n        // Accepts negative indices, from `-1` to `-segments.length`.\n        // Accepts one segment or an array of segments as argument.\n        // Throws an error if path has no segments.\n        // Throws an error if index is out of range.\n        // Throws an error if argument is not a segment or an array of segments.\n        replaceSegment: function(index, arg) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) throw new Error(\"Path has no segments.\");\n            if (index < 0) index = numSegments + index;\n             // convert negative indices to positive\n            if (index >= numSegments || index < 0) throw new Error(\"Index out of range.\");\n            var currentSegment;\n            var replacedSegment = segments[index];\n            var previousSegment = replacedSegment.previousSegment;\n            var nextSegment = replacedSegment.nextSegment;\n            var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n            if (!Array.isArray(arg)) {\n                if (!arg || !arg.isSegment) throw new Error(\"Segment required.\");\n                currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n                segments.splice(index, 1, currentSegment); // directly replace\n                if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false;\n                 // already updated by `prepareSegment`\n            } else {\n                // flatten one level deep\n                // so we can chain arbitrary Path.createSegment results\n                arg = arg.reduce(function(acc, val) {\n                    return acc.concat(val);\n                }, []);\n                if (!arg[0].isSegment) throw new Error(\"Segments required.\");\n                segments.splice(index, 1);\n                var n = arg.length;\n                for(var i = 0; i < n; i++){\n                    var currentArg = arg[i];\n                    currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                    segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                    previousSegment = currentSegment;\n                    if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false;\n                     // already updated by `prepareSegment`\n                }\n            }\n            // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n            if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n        },\n        round: function(precision) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                segment.round(precision);\n            }\n            return this;\n        },\n        scale: function(sx, sy, origin) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                segment.scale(sx, sy, origin);\n            }\n            return this;\n        },\n        segmentAt: function(ratio, opt) {\n            var index = this.segmentIndexAt(ratio, opt);\n            if (!index) return null;\n            return this.getSegment(index);\n        },\n        // Accepts negative length.\n        segmentAtLength: function(length, opt) {\n            var index = this.segmentIndexAtLength(length, opt);\n            if (!index) return null;\n            return this.getSegment(index);\n        },\n        segmentIndexAt: function(ratio, opt) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            if (ratio < 0) ratio = 0;\n            if (ratio > 1) ratio = 1;\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            var localOpt = {\n                precision: precision,\n                segmentSubdivisions: segmentSubdivisions\n            };\n            var pathLength = this.length(localOpt);\n            var length = pathLength * ratio;\n            return this.segmentIndexAtLength(length, localOpt);\n        },\n        // Accepts negative length.\n        segmentIndexAtLength: function(length, opt) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            var fromStart = true;\n            if (length < 0) {\n                fromStart = false; // negative lengths mean start calculation from end point\n                length = -length; // absolute value\n            }\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            // not using localOpt\n            var lastVisibleSegmentIndex = null;\n            var l = 0; // length so far\n            for(var i = 0; i < numSegments; i++){\n                var index = fromStart ? i : numSegments - 1 - i;\n                var segment = segments[index];\n                var subdivisions = segmentSubdivisions[index];\n                var d = segment.length({\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                if (segment.isVisible) {\n                    if (length <= l + d) return index;\n                    lastVisibleSegmentIndex = index;\n                }\n                l += d;\n            }\n            // if length requested is higher than the length of the path, return last visible segment index\n            // if no visible segment, return null\n            return lastVisibleSegmentIndex;\n        },\n        // Returns a string that can be used to reconstruct the path.\n        // Additional error checking compared to toString (must start with M segment).\n        serialize: function() {\n            if (!this.isValid()) throw new Error(\"Invalid path segments.\");\n            return this.toString();\n        },\n        // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n        tangentAt: function(ratio, opt) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            if (ratio < 0) ratio = 0;\n            if (ratio > 1) ratio = 1;\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            var localOpt = {\n                precision: precision,\n                segmentSubdivisions: segmentSubdivisions\n            };\n            var pathLength = this.length(localOpt);\n            var length = pathLength * ratio;\n            return this.tangentAtLength(length, localOpt);\n        },\n        // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n        // Accepts negative length.\n        tangentAtLength: function(length, opt) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            var fromStart = true;\n            if (length < 0) {\n                fromStart = false; // negative lengths mean start calculation from end point\n                length = -length; // absolute value\n            }\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            // not using localOpt\n            var lastValidSegment; // visible AND differentiable (with a tangent)\n            var l = 0; // length so far\n            for(var i = 0; i < numSegments; i++){\n                var index = fromStart ? i : numSegments - 1 - i;\n                var segment = segments[index];\n                var subdivisions = segmentSubdivisions[index];\n                var d = segment.length({\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                if (segment.isDifferentiable()) {\n                    if (length <= l + d) return segment.tangentAtLength((fromStart ? 1 : -1) * (length - l), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                    lastValidSegment = segment;\n                }\n                l += d;\n            }\n            // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n            if (lastValidSegment) {\n                var t = fromStart ? 1 : 0;\n                return lastValidSegment.tangentAtT(t);\n            }\n            // if no valid segment, return null\n            return null;\n        },\n        // Private function.\n        tangentAtT: function(t) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            var segmentIndex = t.segmentIndex;\n            if (segmentIndex < 0) return segments[0].tangentAtT(0);\n            if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n            var tValue = t.value;\n            if (tValue < 0) tValue = 0;\n            else if (tValue > 1) tValue = 1;\n            return segments[segmentIndex].tangentAtT(tValue);\n        },\n        toPoints: function(opt) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n             // if segments is an empty array\n            opt = opt || {};\n            var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n                precision: precision\n            }) : opt.segmentSubdivisions;\n            var points = [];\n            var partialPoints = [];\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                if (segment.isVisible) {\n                    var currentSegmentSubdivisions = segmentSubdivisions[i];\n                    if (currentSegmentSubdivisions.length > 0) {\n                        var subdivisionPoints = currentSegmentSubdivisions.map(function(curve) {\n                            return curve.start;\n                        });\n                        Array.prototype.push.apply(partialPoints, subdivisionPoints);\n                    } else partialPoints.push(segment.start);\n                } else if (partialPoints.length > 0) {\n                    partialPoints.push(segments[i - 1].end);\n                    points.push(partialPoints);\n                    partialPoints = [];\n                }\n            }\n            if (partialPoints.length > 0) {\n                partialPoints.push(this.end);\n                points.push(partialPoints);\n            }\n            return points;\n        },\n        toPolylines: function(opt) {\n            var polylines = [];\n            var points = this.toPoints(opt);\n            if (!points) return null;\n            for(var i = 0, n = points.length; i < n; i++)polylines.push(new Polyline(points[i]));\n            return polylines;\n        },\n        toString: function() {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            var pathData = \"\";\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                pathData += segment.serialize() + \" \";\n            }\n            return pathData.trim();\n        },\n        translate: function(tx, ty) {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                segment.translate(tx, ty);\n            }\n            return this;\n        },\n        // Helper method for updating subpath start of segments, starting with the one provided.\n        updateSubpathStartSegment: function(segment) {\n            var previousSegment = segment.previousSegment; // may be null\n            while(segment && !segment.isSubpathStart){\n                // assign previous segment's subpath start segment to this segment\n                if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment;\n                else segment.subpathStartSegment = null;\n                 // if segment had no previous segment, assign null - creates an invalid path!\n                previousSegment = segment;\n                segment = segment.nextSegment; // move on to the segment after etc.\n            }\n        },\n        // If the path is not valid, insert M 0 0 at the beginning.\n        // Path with no segments is considered valid, so nothing is inserted.\n        validate: function() {\n            if (!this.isValid()) this.insertSegment(0, Path.createSegment(\"M\", 0, 0));\n            return this;\n        }\n    };\n    Object.defineProperty(Path.prototype, \"start\", {\n        // Getter for the first visible endpoint of the path.\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n            for(var i = 0; i < numSegments; i++){\n                var segment = segments[i];\n                if (segment.isVisible) return segment.start;\n            }\n            // if no visible segment, return last segment end point\n            return segments[numSegments - 1].end;\n        }\n    });\n    Object.defineProperty(Path.prototype, \"end\", {\n        // Getter for the last visible endpoint of the path.\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            var segments = this.segments;\n            var numSegments = segments.length;\n            if (numSegments === 0) return null;\n            for(var i = numSegments - 1; i >= 0; i--){\n                var segment = segments[i];\n                if (segment.isVisible) return segment.end;\n            }\n            // if no visible segment, return last segment end point\n            return segments[numSegments - 1].end;\n        }\n    });\n    // Local helper function.\n    // Use an array of arguments to call a constructor (function called with `new`).\n    // Adapted from https://stackoverflow.com/a/8843181/2263595\n    // It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n    // - If that is the case, use `new constructor(arg1, arg2)`, for example.\n    // It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n    // - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\n    function applyToNew(constructor, argsArray) {\n        // The `new` keyword can only be applied to functions that take a limited number of arguments.\n        // - We can fake that with .bind().\n        // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n        // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n        // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n        // We need to pass in a variable number of arguments to the bind() call.\n        // - We can use .apply().\n        // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n        // - `thisArg` can still be anything because `new` overwrites it.\n        // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n        // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n        // The function expects `argsArray[0]` to be `thisArg`.\n        // - This means that whatever is sent as the first element will be ignored.\n        // - The constructor will only see arguments starting from argsArray[1].\n        // - So, a new dummy element is inserted at the start of the array.\n        argsArray.unshift(null);\n        return new (Function.prototype.bind.apply(constructor, argsArray));\n    }\n    // Path segment interface:\n    var segmentPrototype = {\n        // virtual\n        bbox: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // virtual\n        clone: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // virtual\n        closestPoint: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // virtual\n        closestPointLength: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // virtual\n        closestPointNormalizedLength: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n        closestPointT: function(p) {\n            if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n            throw new Error(\"Neither closestPointT() nor closestPointNormalizedLength() function is implemented.\");\n        },\n        // virtual\n        closestPointTangent: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // virtual\n        divideAt: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // virtual\n        divideAtLength: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n        divideAtT: function(t) {\n            if (this.divideAt) return this.divideAt(t);\n            throw new Error(\"Neither divideAtT() nor divideAt() function is implemented.\");\n        },\n        // virtual\n        equals: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // virtual\n        getSubdivisions: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // virtual\n        isDifferentiable: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        isSegment: true,\n        isSubpathStart: false,\n        isVisible: true,\n        // virtual\n        length: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n        lengthAtT: function(t) {\n            if (t <= 0) return 0;\n            var length = this.length();\n            if (t >= 1) return length;\n            return length * t;\n        },\n        nextSegment: null,\n        // virtual\n        pointAt: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // virtual\n        pointAtLength: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n        pointAtT: function(t) {\n            if (this.pointAt) return this.pointAt(t);\n            throw new Error(\"Neither pointAtT() nor pointAt() function is implemented.\");\n        },\n        previousSegment: null,\n        // virtual\n        round: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        subpathStartSegment: null,\n        // virtual\n        scale: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // virtual\n        serialize: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // virtual\n        tangentAt: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // virtual\n        tangentAtLength: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n        tangentAtT: function(t) {\n            if (this.tangentAt) return this.tangentAt(t);\n            throw new Error(\"Neither tangentAtT() nor tangentAt() function is implemented.\");\n        },\n        // virtual\n        toString: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        },\n        // virtual\n        translate: function() {\n            throw new Error(\"Declaration missing for virtual function.\");\n        }\n    };\n    // usually directly assigned\n    // getter for Closepath\n    Object.defineProperty(segmentPrototype, \"end\", {\n        configurable: true,\n        enumerable: true,\n        writable: true\n    });\n    // always a getter\n    // always throws error for Moveto\n    Object.defineProperty(segmentPrototype, \"start\", {\n        // get a reference to the end point of previous segment\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            if (!this.previousSegment) throw new Error(\"Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)\");\n            return this.previousSegment.end;\n        }\n    });\n    // virtual\n    Object.defineProperty(segmentPrototype, \"type\", {\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            throw new Error(\"Bad segment declaration. No type specified.\");\n        }\n    });\n    // Path segment implementations:\n    var Lineto = function() {\n        var arguments$1 = arguments;\n        var args = [];\n        var n = arguments.length;\n        for(var i = 0; i < n; i++)args.push(arguments$1[i]);\n        if (!(this instanceof Lineto)) return applyToNew(Lineto, args);\n        if (n === 0) throw new Error(\"Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).\");\n        var outputArray;\n        if (args[0] instanceof Line) {\n            if (n === 1) {\n                this.end = args[0].end.clone();\n                return this;\n            } else throw new Error(\"Lineto constructor expects a line, 1 point, or 2 coordinates (\" + n + \" lines provided).\");\n        } else if (typeof args[0] === \"string\" || typeof args[0] === \"number\") {\n            if (n === 2) {\n                this.end = new Point(+args[0], +args[1]);\n                return this;\n            } else if (n < 2) throw new Error(\"Lineto constructor expects a line, 1 point, or 2 coordinates (\" + n + \" coordinates provided).\");\n            else {\n                var segmentCoords;\n                outputArray = [];\n                for(i = 0; i < n; i += 2){\n                    segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                    outputArray.push(applyToNew(Lineto, segmentCoords));\n                }\n                return outputArray;\n            }\n        } else if (n === 1) {\n            this.end = new Point(args[0]);\n            return this;\n        } else {\n            var segmentPoint;\n            outputArray = [];\n            for(i = 0; i < n; i += 1){\n                segmentPoint = args[i];\n                outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    };\n    var linetoPrototype = {\n        clone: function() {\n            return new Lineto(this.end);\n        },\n        divideAt: function(ratio) {\n            var line = new Line(this.start, this.end);\n            var divided = line.divideAt(ratio);\n            return [\n                new Lineto(divided[0]),\n                new Lineto(divided[1])\n            ];\n        },\n        divideAtLength: function(length) {\n            var line = new Line(this.start, this.end);\n            var divided = line.divideAtLength(length);\n            return [\n                new Lineto(divided[0]),\n                new Lineto(divided[1])\n            ];\n        },\n        getSubdivisions: function() {\n            return [];\n        },\n        isDifferentiable: function() {\n            if (!this.previousSegment) return false;\n            return !this.start.equals(this.end);\n        },\n        round: function(precision) {\n            this.end.round(precision);\n            return this;\n        },\n        scale: function(sx, sy, origin) {\n            this.end.scale(sx, sy, origin);\n            return this;\n        },\n        serialize: function() {\n            var end = this.end;\n            return this.type + \" \" + end.x + \" \" + end.y;\n        },\n        toString: function() {\n            return this.type + \" \" + this.start + \" \" + this.end;\n        },\n        translate: function(tx, ty) {\n            this.end.translate(tx, ty);\n            return this;\n        }\n    };\n    Object.defineProperty(linetoPrototype, \"type\", {\n        configurable: true,\n        enumerable: true,\n        value: \"L\"\n    });\n    Lineto.prototype = extend(segmentPrototype, Line.prototype, linetoPrototype);\n    var Curveto = function() {\n        var arguments$1 = arguments;\n        var args = [];\n        var n = arguments.length;\n        for(var i = 0; i < n; i++)args.push(arguments$1[i]);\n        if (!(this instanceof Curveto)) return applyToNew(Curveto, args);\n        if (n === 0) throw new Error(\"Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).\");\n        var outputArray;\n        if (args[0] instanceof Curve) {\n            if (n === 1) {\n                this.controlPoint1 = args[0].controlPoint1.clone();\n                this.controlPoint2 = args[0].controlPoint2.clone();\n                this.end = args[0].end.clone();\n                return this;\n            } else throw new Error(\"Curveto constructor expects a curve, 3 points, or 6 coordinates (\" + n + \" curves provided).\");\n        } else if (typeof args[0] === \"string\" || typeof args[0] === \"number\") {\n            if (n === 6) {\n                this.controlPoint1 = new Point(+args[0], +args[1]);\n                this.controlPoint2 = new Point(+args[2], +args[3]);\n                this.end = new Point(+args[4], +args[5]);\n                return this;\n            } else if (n < 6) throw new Error(\"Curveto constructor expects a curve, 3 points, or 6 coordinates (\" + n + \" coordinates provided).\");\n            else {\n                var segmentCoords;\n                outputArray = [];\n                for(i = 0; i < n; i += 6){\n                    segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n                    outputArray.push(applyToNew(Curveto, segmentCoords));\n                }\n                return outputArray;\n            }\n        } else {\n            if (n === 3) {\n                this.controlPoint1 = new Point(args[0]);\n                this.controlPoint2 = new Point(args[1]);\n                this.end = new Point(args[2]);\n                return this;\n            } else if (n < 3) throw new Error(\"Curveto constructor expects a curve, 3 points, or 6 coordinates (\" + n + \" points provided).\");\n            else {\n                var segmentPoints;\n                outputArray = [];\n                for(i = 0; i < n; i += 3){\n                    segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n                    outputArray.push(applyToNew(Curveto, segmentPoints));\n                }\n                return outputArray;\n            }\n        }\n    };\n    var curvetoPrototype = {\n        clone: function() {\n            return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n        },\n        divideAt: function(ratio, opt) {\n            var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n            var divided = curve.divideAt(ratio, opt);\n            return [\n                new Curveto(divided[0]),\n                new Curveto(divided[1])\n            ];\n        },\n        divideAtLength: function(length, opt) {\n            var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n            var divided = curve.divideAtLength(length, opt);\n            return [\n                new Curveto(divided[0]),\n                new Curveto(divided[1])\n            ];\n        },\n        divideAtT: function(t) {\n            var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n            var divided = curve.divideAtT(t);\n            return [\n                new Curveto(divided[0]),\n                new Curveto(divided[1])\n            ];\n        },\n        isDifferentiable: function() {\n            if (!this.previousSegment) return false;\n            var start = this.start;\n            var control1 = this.controlPoint1;\n            var control2 = this.controlPoint2;\n            var end = this.end;\n            return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n        },\n        round: function(precision) {\n            this.controlPoint1.round(precision);\n            this.controlPoint2.round(precision);\n            this.end.round(precision);\n            return this;\n        },\n        scale: function(sx, sy, origin) {\n            this.controlPoint1.scale(sx, sy, origin);\n            this.controlPoint2.scale(sx, sy, origin);\n            this.end.scale(sx, sy, origin);\n            return this;\n        },\n        serialize: function() {\n            var c1 = this.controlPoint1;\n            var c2 = this.controlPoint2;\n            var end = this.end;\n            return this.type + \" \" + c1.x + \" \" + c1.y + \" \" + c2.x + \" \" + c2.y + \" \" + end.x + \" \" + end.y;\n        },\n        toString: function() {\n            return this.type + \" \" + this.start + \" \" + this.controlPoint1 + \" \" + this.controlPoint2 + \" \" + this.end;\n        },\n        translate: function(tx, ty) {\n            this.controlPoint1.translate(tx, ty);\n            this.controlPoint2.translate(tx, ty);\n            this.end.translate(tx, ty);\n            return this;\n        }\n    };\n    Object.defineProperty(curvetoPrototype, \"type\", {\n        configurable: true,\n        enumerable: true,\n        value: \"C\"\n    });\n    Curveto.prototype = extend(segmentPrototype, Curve.prototype, curvetoPrototype);\n    var Moveto = function() {\n        var arguments$1 = arguments;\n        var args = [];\n        var n = arguments.length;\n        for(var i = 0; i < n; i++)args.push(arguments$1[i]);\n        if (!(this instanceof Moveto)) return applyToNew(Moveto, args);\n        if (n === 0) throw new Error(\"Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).\");\n        var outputArray;\n        if (args[0] instanceof Line) {\n            if (n === 1) {\n                this.end = args[0].end.clone();\n                return this;\n            } else throw new Error(\"Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (\" + n + \" lines provided).\");\n        } else if (args[0] instanceof Curve) {\n            if (n === 1) {\n                this.end = args[0].end.clone();\n                return this;\n            } else throw new Error(\"Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (\" + n + \" curves provided).\");\n        } else if (typeof args[0] === \"string\" || typeof args[0] === \"number\") {\n            if (n === 2) {\n                this.end = new Point(+args[0], +args[1]);\n                return this;\n            } else if (n < 2) throw new Error(\"Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (\" + n + \" coordinates provided).\");\n            else {\n                var segmentCoords;\n                outputArray = [];\n                for(i = 0; i < n; i += 2){\n                    segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                    if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));\n                    else outputArray.push(applyToNew(Lineto, segmentCoords));\n                }\n                return outputArray;\n            }\n        } else if (n === 1) {\n            this.end = new Point(args[0]);\n            return this;\n        } else {\n            var segmentPoint;\n            outputArray = [];\n            for(i = 0; i < n; i += 1){\n                segmentPoint = args[i];\n                if (i === 0) outputArray.push(new Moveto(segmentPoint));\n                else outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    };\n    var movetoPrototype = {\n        bbox: function() {\n            return null;\n        },\n        clone: function() {\n            return new Moveto(this.end);\n        },\n        closestPoint: function() {\n            return this.end.clone();\n        },\n        closestPointNormalizedLength: function() {\n            return 0;\n        },\n        closestPointLength: function() {\n            return 0;\n        },\n        closestPointT: function() {\n            return 1;\n        },\n        closestPointTangent: function() {\n            return null;\n        },\n        divideAt: function() {\n            return [\n                this.clone(),\n                this.clone()\n            ];\n        },\n        divideAtLength: function() {\n            return [\n                this.clone(),\n                this.clone()\n            ];\n        },\n        equals: function(m) {\n            return this.end.equals(m.end);\n        },\n        getSubdivisions: function() {\n            return [];\n        },\n        isDifferentiable: function() {\n            return false;\n        },\n        isSubpathStart: true,\n        isVisible: false,\n        length: function() {\n            return 0;\n        },\n        lengthAtT: function() {\n            return 0;\n        },\n        pointAt: function() {\n            return this.end.clone();\n        },\n        pointAtLength: function() {\n            return this.end.clone();\n        },\n        pointAtT: function() {\n            return this.end.clone();\n        },\n        round: function(precision) {\n            this.end.round(precision);\n            return this;\n        },\n        scale: function(sx, sy, origin) {\n            this.end.scale(sx, sy, origin);\n            return this;\n        },\n        serialize: function() {\n            var end = this.end;\n            return this.type + \" \" + end.x + \" \" + end.y;\n        },\n        tangentAt: function() {\n            return null;\n        },\n        tangentAtLength: function() {\n            return null;\n        },\n        tangentAtT: function() {\n            return null;\n        },\n        toString: function() {\n            return this.type + \" \" + this.end;\n        },\n        translate: function(tx, ty) {\n            this.end.translate(tx, ty);\n            return this;\n        }\n    };\n    Object.defineProperty(movetoPrototype, \"start\", {\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            throw new Error(\"Illegal access. Moveto segments should not need a start property.\");\n        }\n    });\n    Object.defineProperty(movetoPrototype, \"type\", {\n        configurable: true,\n        enumerable: true,\n        value: \"M\"\n    });\n    Moveto.prototype = extend(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n    var Closepath = function() {\n        var arguments$1 = arguments;\n        var args = [];\n        var n = arguments.length;\n        for(var i = 0; i < n; i++)args.push(arguments$1[i]);\n        if (!(this instanceof Closepath)) return applyToNew(Closepath, args);\n        if (n > 0) throw new Error(\"Closepath constructor expects no arguments.\");\n        return this;\n    };\n    var closepathPrototype = {\n        clone: function() {\n            return new Closepath();\n        },\n        divideAt: function(ratio) {\n            var line = new Line(this.start, this.end);\n            var divided = line.divideAt(ratio);\n            return [\n                // if we didn't actually cut into the segment, first divided part can stay as Z\n                divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(),\n                new Lineto(divided[1])\n            ];\n        },\n        divideAtLength: function(length) {\n            var line = new Line(this.start, this.end);\n            var divided = line.divideAtLength(length);\n            return [\n                // if we didn't actually cut into the segment, first divided part can stay as Z\n                divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(),\n                new Lineto(divided[1])\n            ];\n        },\n        getSubdivisions: function() {\n            return [];\n        },\n        isDifferentiable: function() {\n            if (!this.previousSegment || !this.subpathStartSegment) return false;\n            return !this.start.equals(this.end);\n        },\n        round: function() {\n            return this;\n        },\n        scale: function() {\n            return this;\n        },\n        serialize: function() {\n            return this.type;\n        },\n        toString: function() {\n            return this.type + \" \" + this.start + \" \" + this.end;\n        },\n        translate: function() {\n            return this;\n        }\n    };\n    Object.defineProperty(closepathPrototype, \"end\", {\n        // get a reference to the end point of subpath start segment\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            if (!this.subpathStartSegment) throw new Error(\"Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)\");\n            return this.subpathStartSegment.end;\n        }\n    });\n    Object.defineProperty(closepathPrototype, \"type\", {\n        configurable: true,\n        enumerable: true,\n        value: \"Z\"\n    });\n    Closepath.prototype = extend(segmentPrototype, Line.prototype, closepathPrototype);\n    var segmentTypes = Path.segmentTypes = {\n        L: Lineto,\n        C: Curveto,\n        M: Moveto,\n        Z: Closepath,\n        z: Closepath\n    };\n    Path.regexSupportedData = new RegExp(\"^[\\\\s\\\\d\" + Object.keys(segmentTypes).join(\"\") + \",.]*$\");\n    Path.isDataSupported = function(data) {\n        if (typeof data !== \"string\") return false;\n        return this.regexSupportedData.test(data);\n    };\n    var bezier = {\n        // Cubic Bezier curve path through points.\n        // @deprecated\n        // @param {array} points Array of points through which the smooth line will go.\n        // @return {array} SVG Path commands as an array\n        curveThroughPoints: function(points) {\n            console.warn(\"deprecated\");\n            return new Path(Curve.throughPoints(points)).serialize();\n        },\n        // Get open-ended Bezier Spline Control Points.\n        // @deprecated\n        // @param knots Input Knot Bezier spline points (At least two points!).\n        // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n        // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n        getCurveControlPoints: function(knots) {\n            console.warn(\"deprecated\");\n            var firstControlPoints = [];\n            var secondControlPoints = [];\n            var n = knots.length - 1;\n            var i;\n            // Special case: Bezier curve should be a straight line.\n            if (n == 1) {\n                // 3P1 = 2P0 + P3\n                firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);\n                // P2 = 2P1  P0\n                secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n                return [\n                    firstControlPoints,\n                    secondControlPoints\n                ];\n            }\n            // Calculate first Bezier control points.\n            // Right hand side vector.\n            var rhs = [];\n            // Set right hand side X values.\n            for(i = 1; i < n - 1; i++)rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n            rhs[0] = knots[0].x + 2 * knots[1].x;\n            rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n            // Get first control points X-values.\n            var x = this.getFirstControlPoints(rhs);\n            // Set right hand side Y values.\n            for(i = 1; i < n - 1; ++i)rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n            rhs[0] = knots[0].y + 2 * knots[1].y;\n            rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n            // Get first control points Y-values.\n            var y = this.getFirstControlPoints(rhs);\n            // Fill output arrays.\n            for(i = 0; i < n; i++){\n                // First control point.\n                firstControlPoints.push(new Point(x[i], y[i]));\n                // Second control point.\n                if (i < n - 1) secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n                else secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n            }\n            return [\n                firstControlPoints,\n                secondControlPoints\n            ];\n        },\n        // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n        // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n        // @deprecated\n        // @param control points (start, control start, control end, end)\n        // @return a function that accepts t and returns 2 curves.\n        getCurveDivider: function(p0, p1, p2, p3) {\n            console.warn(\"deprecated\");\n            var curve = new Curve(p0, p1, p2, p3);\n            return function divideCurve(t) {\n                var divided = curve.divide(t);\n                return [\n                    {\n                        p0: divided[0].start,\n                        p1: divided[0].controlPoint1,\n                        p2: divided[0].controlPoint2,\n                        p3: divided[0].end\n                    },\n                    {\n                        p0: divided[1].start,\n                        p1: divided[1].controlPoint1,\n                        p2: divided[1].controlPoint2,\n                        p3: divided[1].end\n                    }\n                ];\n            };\n        },\n        // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n        // @deprecated\n        // @param rhs Right hand side vector.\n        // @return Solution vector.\n        getFirstControlPoints: function(rhs) {\n            console.warn(\"deprecated\");\n            var n = rhs.length;\n            // `x` is a solution vector.\n            var x = [];\n            var tmp = [];\n            var b = 2.0;\n            x[0] = rhs[0] / b;\n            // Decomposition and forward substitution.\n            for(var i = 1; i < n; i++){\n                tmp[i] = 1 / b;\n                b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n                x[i] = (rhs[i] - x[i - 1]) / b;\n            }\n            for(i = 1; i < n; i++)// Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n            return x;\n        },\n        // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n        // a parametric curve x = x(t)/w(t), y = y(t)/w(t), nd the parameter value t\n        // which corresponds to that point.\n        // @deprecated\n        // @param control points (start, control start, control end, end)\n        // @return a function that accepts a point and returns t.\n        getInversionSolver: function(p0, p1, p2, p3) {\n            console.warn(\"deprecated\");\n            var curve = new Curve(p0, p1, p2, p3);\n            return function solveInversion(p) {\n                return curve.closestPointT(p);\n            };\n        }\n    };\n    var Polygon = function(points) {\n        if (!(this instanceof Polygon)) return new Polygon(points);\n        if (typeof points === \"string\") return new Polygon.parse(points);\n        this.points = Array.isArray(points) ? points.map(Point) : [];\n    };\n    Polygon.parse = function(svgString) {\n        return new Polygon(parsePoints(svgString));\n    };\n    Polygon.fromRect = function(rect) {\n        return new Polygon([\n            rect.topLeft(),\n            rect.topRight(),\n            rect.bottomRight(),\n            rect.bottomLeft()\n        ]);\n    };\n    Polygon.prototype = extend(Polyline.prototype, {\n        type: types.Polygon,\n        clone: function() {\n            return new Polygon(clonePoints(this.points));\n        },\n        convexHull: function() {\n            return new Polygon(convexHull(this.points));\n        },\n        lengthPoints: function() {\n            var ref = this;\n            var start = ref.start;\n            var end = ref.end;\n            var points = ref.points;\n            if (points.length <= 1 || start.equals(end)) return points;\n            return points.concat([\n                start.clone()\n            ]);\n        }\n    });\n    function exists(shape1, shape2, shape1opt, shape2opt) {\n        switch(shape1.type){\n            case types.Line:\n                switch(shape2.type){\n                    case types.Line:\n                        return lineWithLine(shape1, shape2);\n                }\n                break;\n            case types.Ellipse:\n                switch(shape2.type){\n                    case types.Line:\n                        return ellipseWithLine(shape1, shape2);\n                    case types.Ellipse:\n                        return ellipseWithEllipse(shape1, shape2);\n                }\n                break;\n            case types.Rect:\n                switch(shape2.type){\n                    case types.Line:\n                        return rectWithLine(shape1, shape2);\n                    case types.Ellipse:\n                        return rectWithEllipse(shape1, shape2);\n                    case types.Rect:\n                        return rectWithRect(shape1, shape2);\n                }\n                break;\n            case types.Polyline:\n                switch(shape2.type){\n                    case types.Line:\n                        return polylineWithLine(shape1, shape2);\n                    case types.Ellipse:\n                        return polylineWithEllipse(shape1, shape2);\n                    case types.Rect:\n                        return polylineWithRect(shape1, shape2);\n                    case types.Polyline:\n                        return polylineWithPolyline(shape1, shape2);\n                }\n                break;\n            case types.Polygon:\n                switch(shape2.type){\n                    case types.Line:\n                        return polygonWithLine(shape1, shape2);\n                    case types.Ellipse:\n                        return polygonWithEllipse(shape1, shape2);\n                    case types.Rect:\n                        return polygonWithRect(shape1, shape2);\n                    case types.Polyline:\n                        return polygonWithPolyline(shape1, shape2);\n                    case types.Polygon:\n                        return polygonWithPolygon(shape1, shape2);\n                }\n                break;\n            case types.Path:\n                switch(shape2.type){\n                    case types.Line:\n                        return pathWithLine(shape1, shape2, shape1opt);\n                    case types.Ellipse:\n                        return pathWithEllipse(shape1, shape2, shape1opt);\n                    case types.Rect:\n                        return pathWithRect(shape1, shape2, shape1opt);\n                    case types.Polyline:\n                        return pathWithPolyline(shape1, shape2, shape1opt);\n                    case types.Polygon:\n                        return pathWithPolygon(shape1, shape2, shape1opt);\n                    case types.Path:\n                        return pathWithPath(shape1, shape2, shape1opt, shape2opt);\n                }\n                break;\n        }\n        // None of the cases above\n        switch(shape2.type){\n            case types.Ellipse:\n            case types.Rect:\n            case types.Polyline:\n            case types.Polygon:\n            case types.Path:\n                return exists(shape2, shape1, shape2opt, shape1opt);\n            default:\n                throw Error(\"The intersection for \" + shape1 + \" and \" + shape2 + \" could not be found.\");\n        }\n    }\n    /* Line */ function lineWithLine(line1, line2) {\n        var x1 = line1.start.x;\n        var y1 = line1.start.y;\n        var x2 = line1.end.x;\n        var y2 = line1.end.y;\n        var x3 = line2.start.x;\n        var y3 = line2.start.y;\n        var x4 = line2.end.x;\n        var y4 = line2.end.y;\n        var s1x = x2 - x1;\n        var s1y = y2 - y1;\n        var s2x = x4 - x3;\n        var s2y = y4 - y3;\n        var s3x = x1 - x3;\n        var s3y = y1 - y3;\n        var p = s1x * s2y - s2x * s1y;\n        var s = (s1x * s3y - s1y * s3x) / p;\n        var t = (s2x * s3y - s2y * s3x) / p;\n        return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n    }\n    /* Ellipse */ function ellipseWithLine(ellipse, line) {\n        var rex = ellipse.a;\n        var rey = ellipse.b;\n        var xe = ellipse.x;\n        var ye = ellipse.y;\n        var x1 = line.start.x - xe;\n        var x2 = line.end.x - xe;\n        var y1 = line.start.y - ye;\n        var y2 = line.end.y - ye;\n        var rex_2 = rex * rex;\n        var rey_2 = rey * rey;\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        var A = dx * dx / rex_2 + dy * dy / rey_2;\n        var B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;\n        var C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;\n        var D = B * B - 4 * A * C;\n        if (D === 0) {\n            var t = -B / 2 / A;\n            return t >= 0 && t <= 1;\n        } else if (D > 0) {\n            var sqrt = Math.sqrt(D);\n            var t1 = (-B + sqrt) / 2 / A;\n            var t2 = (-B - sqrt) / 2 / A;\n            return t1 >= 0 && t1 <= 1 || t2 >= 0 && t2 <= 1;\n        }\n        return false;\n    }\n    function ellipseWithEllipse(ellipse1, ellipse2) {\n        return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);\n    }\n    /* Rect */ function rectWithLine(rect, line) {\n        var start = line.start;\n        var end = line.end;\n        var x = rect.x;\n        var y = rect.y;\n        var width = rect.width;\n        var height = rect.height;\n        if (start.x > x + width && end.x > x + width || start.x < x && end.x < x || start.y > y + height && end.y > y + height || start.y < y && end.y < y) return false;\n        if (rect.containsPoint(line.start) || rect.containsPoint(line.end)) return true;\n        return lineWithLine(rect.topLine(), line) || lineWithLine(rect.rightLine(), line) || lineWithLine(rect.bottomLine(), line) || lineWithLine(rect.leftLine(), line);\n    }\n    function rectWithEllipse(rect, ellipse) {\n        if (!rectWithRect(rect, Rect.fromEllipse(ellipse))) return false;\n        return polygonWithEllipse(Polygon.fromRect(rect), ellipse);\n    }\n    function rectWithRect(rect1, rect2) {\n        return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;\n    }\n    /* Polyline */ function polylineWithLine(polyline, line) {\n        return _polylineWithLine(polyline, line, {\n            interior: false\n        });\n    }\n    function polylineWithEllipse(polyline, ellipse) {\n        return _polylineWithEllipse(polyline, ellipse, {\n            interior: false\n        });\n    }\n    function polylineWithRect(polyline, rect) {\n        return _polylineWithRect(polyline, rect, {\n            interior: false\n        });\n    }\n    function polylineWithPolyline(polyline1, polyline2) {\n        return _polylineWithPolyline(polyline1, polyline2, {\n            interior: false\n        });\n    }\n    /* Polygon */ function polygonWithLine(polygon, line) {\n        return _polylineWithLine(polygon, line, {\n            interior: true\n        });\n    }\n    function polygonWithEllipse(polygon, ellipse) {\n        return _polylineWithEllipse(polygon, ellipse, {\n            interior: true\n        });\n    }\n    function polygonWithRect(polygon, rect) {\n        return _polylineWithRect(polygon, rect, {\n            interior: true\n        });\n    }\n    function polygonWithPolyline(polygon, polyline) {\n        return _polylineWithPolyline(polygon, polyline, {\n            interior: true\n        });\n    }\n    function polygonWithPolygon(polygon1, polygon2) {\n        return _polylineWithPolygon(polygon1, polygon2, {\n            interior: true\n        });\n    }\n    /* Path */ function pathWithLine(path, line, pathOpt) {\n        return path.getSubpaths().some(function(subpath) {\n            var ref = subpath.toPolylines(pathOpt);\n            var polyline = ref[0];\n            var ref$1 = subpath.getSegment(-1);\n            var type = ref$1.type;\n            if (type === \"Z\") return polygonWithLine(polyline, line);\n            else return polylineWithLine(polyline, line);\n        });\n    }\n    function pathWithEllipse(path, ellipse, pathOpt) {\n        return path.getSubpaths().some(function(subpath) {\n            var ref = subpath.toPolylines(pathOpt);\n            var polyline = ref[0];\n            var ref$1 = subpath.getSegment(-1);\n            var type = ref$1.type;\n            if (type === \"Z\") return polygonWithEllipse(polyline, ellipse);\n            else return polylineWithEllipse(polyline, ellipse);\n        });\n    }\n    function pathWithRect(path, rect, pathOpt) {\n        return pathWithPolygon(path, Polygon.fromRect(rect), pathOpt);\n    }\n    function pathWithPolyline(path, polyline, pathOpt) {\n        return _pathWithPolyline(path, polyline, pathOpt, {\n            interior: false\n        });\n    }\n    function pathWithPolygon(path, polygon, pathOpt) {\n        return _pathWithPolyline(path, polygon, pathOpt, {\n            interior: true\n        });\n    }\n    function pathWithPath(path1, path2, pathOpt1, pathOpt2) {\n        return path1.getSubpaths().some(function(subpath) {\n            var ref = subpath.toPolylines(pathOpt1);\n            var polyline1 = ref[0];\n            var ref$1 = subpath.getSegment(-1);\n            var type = ref$1.type;\n            if (type === \"Z\") return pathWithPolygon(path2, polyline1, pathOpt2);\n            else return pathWithPolyline(path2, polyline1, pathOpt2);\n        });\n    }\n    function _polylineWithLine(polyline, line, opt) {\n        if (opt === void 0) opt = {};\n        var interior = opt.interior;\n        if (interior === void 0) interior = false;\n        var thisPoints;\n        if (interior) {\n            if (polyline.containsPoint(line.start)) // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n            var start = polyline.start;\n            var end = polyline.end;\n            var points = polyline.points;\n            thisPoints = end.equals(start) ? points : points.concat([\n                start\n            ]);\n        } else thisPoints = polyline.points;\n        var length = thisPoints.length;\n        var segment = new Line();\n        for(var i = 0; i < length - 1; i++){\n            segment.start = thisPoints[i];\n            segment.end = thisPoints[i + 1];\n            if (lineWithLine(line, segment)) return true;\n        }\n        return false;\n    }\n    function _polylineWithEllipse(polyline, ellipse, opt) {\n        if (opt === void 0) opt = {};\n        var start = polyline.start;\n        var end = polyline.end;\n        var points = polyline.points;\n        if (ellipse.containsPoint(start)) return true;\n        var thisPoints;\n        var interior = opt.interior;\n        if (interior === void 0) interior = false;\n        if (interior) {\n            if (polyline.containsPoint(ellipse.center())) // If any point of the ellipse lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the center point)\n            return true;\n            thisPoints = end.equals(start) ? points : points.concat([\n                start\n            ]);\n        } else thisPoints = points;\n        var length = thisPoints.length;\n        var segment = new Line();\n        for(var i = 0; i < length - 1; i++){\n            segment.start = thisPoints[i];\n            segment.end = thisPoints[i + 1];\n            if (ellipseWithLine(ellipse, segment)) return true;\n        }\n        return false;\n    }\n    function _polylineWithRect(polyline, rect, opt) {\n        var polygon = Polygon.fromRect(rect);\n        return _polylineWithPolygon(polyline, polygon, opt);\n    }\n    function _pathWithPolyline(path, polyline1, pathOpt, opt) {\n        return path.getSubpaths().some(function(subpath) {\n            var ref = subpath.toPolylines(pathOpt);\n            var polyline2 = ref[0];\n            var ref$1 = subpath.getSegment(-1);\n            var type = ref$1.type;\n            if (type === \"Z\") return _polylineWithPolygon(polyline1, polyline2, opt);\n            else return _polylineWithPolyline(polyline1, polyline2, opt);\n        });\n    }\n    function _polylineWithPolyline(polyline1, polyline2, opt) {\n        if (opt === void 0) opt = {};\n        var interior = opt.interior;\n        if (interior === void 0) interior = false;\n        var thisPolyline;\n        if (interior) {\n            var start = polyline2.start;\n            if (polyline1.containsPoint(start)) // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n            thisPolyline = polyline1.clone().close();\n        } else thisPolyline = polyline1;\n        var otherPoints = polyline2.points;\n        var length = otherPoints.length;\n        var segment = new Line();\n        for(var i = 0; i < length - 1; i++){\n            segment.start = otherPoints[i];\n            segment.end = otherPoints[i + 1];\n            if (polylineWithLine(thisPolyline, segment)) return true;\n        }\n        return false;\n    }\n    function _polylineWithPolygon(polyline, polygon, opt) {\n        return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);\n    }\n    function _ellipsesIntersection(e1, w1, e2, w2) {\n        var cos = Math.cos;\n        var sin = Math.sin;\n        var sinW1 = sin(w1);\n        var cosW1 = cos(w1);\n        var sinW2 = sin(w2);\n        var cosW2 = cos(w2);\n        var sinW1s = sinW1 * sinW1;\n        var cosW1s = cosW1 * cosW1;\n        var sinCos1 = sinW1 * cosW1;\n        var sinW2s = sinW2 * sinW2;\n        var cosW2s = cosW2 * cosW2;\n        var sinCos2 = sinW2 * cosW2;\n        var a1s = e1.a * e1.a;\n        var b1s = e1.b * e1.b;\n        var a2s = e2.a * e2.a;\n        var b2s = e2.b * e2.b;\n        var A1 = a1s * sinW1s + b1s * cosW1s;\n        var A2 = a2s * sinW2s + b2s * cosW2s;\n        var B1 = a1s * cosW1s + b1s * sinW1s;\n        var B2 = a2s * cosW2s + b2s * sinW2s;\n        var C1 = 2 * (b1s - a1s) * sinCos1;\n        var C2 = 2 * (b2s - a2s) * sinCos2;\n        var D1 = -2 * A1 * e1.x - C1 * e1.y;\n        var D2 = -2 * A2 * e2.x - C2 * e2.y;\n        var E1 = -C1 * e1.x - 2 * B1 * e1.y;\n        var E2 = -C2 * e2.x - 2 * B2 * e2.y;\n        var F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;\n        var F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;\n        C1 = C1 / 2;\n        C2 = C2 / 2;\n        D1 = D1 / 2;\n        D2 = D2 / 2;\n        E1 = E1 / 2;\n        E2 = E2 / 2;\n        var l3 = det3([\n            [\n                A1,\n                C1,\n                D1\n            ],\n            [\n                C1,\n                B1,\n                E1\n            ],\n            [\n                D1,\n                E1,\n                F1\n            ]\n        ]);\n        var l0 = det3([\n            [\n                A2,\n                C2,\n                D2\n            ],\n            [\n                C2,\n                B2,\n                E2\n            ],\n            [\n                D2,\n                E2,\n                F2\n            ]\n        ]);\n        var l2 = 0.33333333 * (det3([\n            [\n                A2,\n                C1,\n                D1\n            ],\n            [\n                C2,\n                B1,\n                E1\n            ],\n            [\n                D2,\n                E1,\n                F1\n            ]\n        ]) + det3([\n            [\n                A1,\n                C2,\n                D1\n            ],\n            [\n                C1,\n                B2,\n                E1\n            ],\n            [\n                D1,\n                E2,\n                F1\n            ]\n        ]) + det3([\n            [\n                A1,\n                C1,\n                D2\n            ],\n            [\n                C1,\n                B1,\n                E2\n            ],\n            [\n                D1,\n                E1,\n                F2\n            ]\n        ]));\n        var l1 = 0.33333333 * (det3([\n            [\n                A1,\n                C2,\n                D2\n            ],\n            [\n                C1,\n                B2,\n                E2\n            ],\n            [\n                D1,\n                E2,\n                F2\n            ]\n        ]) + det3([\n            [\n                A2,\n                C1,\n                D2\n            ],\n            [\n                C2,\n                B1,\n                E2\n            ],\n            [\n                D2,\n                E1,\n                F2\n            ]\n        ]) + det3([\n            [\n                A2,\n                C2,\n                D1\n            ],\n            [\n                C2,\n                B2,\n                E1\n            ],\n            [\n                D2,\n                E2,\n                F1\n            ]\n        ]));\n        var delta1 = det2([\n            [\n                l3,\n                l2\n            ],\n            [\n                l2,\n                l1\n            ]\n        ]);\n        var delta2 = det2([\n            [\n                l3,\n                l1\n            ],\n            [\n                l2,\n                l0\n            ]\n        ]);\n        var delta3 = det2([\n            [\n                l2,\n                l1\n            ],\n            [\n                l1,\n                l0\n            ]\n        ]);\n        var dP = det2([\n            [\n                2 * delta1,\n                delta2\n            ],\n            [\n                delta2,\n                2 * delta3\n            ]\n        ]);\n        if (dP > 0 && (l1 > 0 || l2 > 0)) return false;\n        return true;\n    }\n    function det2(m) {\n        return m[0][0] * m[1][1] - m[0][1] * m[1][0];\n    }\n    function det3(m) {\n        return m[0][0] * m[1][1] * m[2][2] - m[0][0] * m[1][2] * m[2][1] - m[0][1] * m[1][0] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[1][0] * m[2][1] - m[0][2] * m[1][1] * m[2][0];\n    }\n    var _intersection = {\n        exists: exists,\n        lineWithLine: lineWithLine,\n        ellipseWithLine: ellipseWithLine,\n        ellipseWithEllipse: ellipseWithEllipse,\n        rectWithLine: rectWithLine,\n        rectWithEllipse: rectWithEllipse,\n        rectWithRect: rectWithRect,\n        polylineWithLine: polylineWithLine,\n        polylineWithEllipse: polylineWithEllipse,\n        polylineWithRect: polylineWithRect,\n        polylineWithPolyline: polylineWithPolyline,\n        polygonWithLine: polygonWithLine,\n        polygonWithEllipse: polygonWithEllipse,\n        polygonWithRect: polygonWithRect,\n        polygonWithPolyline: polygonWithPolyline,\n        polygonWithPolygon: polygonWithPolygon,\n        pathWithLine: pathWithLine,\n        pathWithEllipse: pathWithEllipse,\n        pathWithRect: pathWithRect,\n        pathWithPolyline: pathWithPolyline,\n        pathWithPolygon: pathWithPolygon,\n        pathWithPath: pathWithPath\n    };\n    // Geometry library.\n    var intersection = _intersection;\n    var g = {\n        intersection: intersection,\n        scale: scale,\n        normalizeAngle: normalizeAngle,\n        snapToGrid: snapToGrid,\n        toDeg: toDeg,\n        toRad: toRad,\n        random: random,\n        bezier: bezier,\n        Curve: Curve,\n        Ellipse: Ellipse,\n        ellipse: ellipse,\n        Line: Line,\n        line: line,\n        Path: Path,\n        Point: Point,\n        point: point,\n        Polyline: Polyline,\n        Polygon: Polygon,\n        Rect: Rect,\n        rect: rect,\n        types: types\n    };\n    // Vectorizer.\n    var V = function() {\n        var hasSvg = typeof window === \"object\" && !!window.SVGAngle;\n        // SVG support is required.\n        if (!hasSvg) // Return a function that throws an error when it is used.\n        return function() {\n            throw new Error(\"SVG is required to use Vectorizer.\");\n        };\n        // XML namespaces.\n        var ns = {\n            svg: \"http://www.w3.org/2000/svg\",\n            xmlns: \"http://www.w3.org/2000/xmlns/\",\n            xml: \"http://www.w3.org/XML/1998/namespace\",\n            xlink: \"http://www.w3.org/1999/xlink\",\n            xhtml: \"http://www.w3.org/1999/xhtml\"\n        };\n        var SVGVersion = \"1.1\";\n        // Declare shorthands to the most used math functions.\n        var math = Math;\n        var PI = math.PI;\n        var atan2 = math.atan2;\n        var sqrt = math.sqrt;\n        var min = math.min;\n        var max = math.max;\n        var cos = math.cos;\n        var sin = math.sin;\n        var V = function(el, attrs, children) {\n            // This allows using V() without the new keyword.\n            if (!(this instanceof V)) return V.apply(Object.create(V.prototype), arguments);\n            if (!el) return;\n            if (V.isV(el)) el = el.node;\n            attrs = attrs || {};\n            if (V.isString(el)) {\n                el = el.trim();\n                if (el.toLowerCase() === \"svg\") // Create a new SVG canvas.\n                el = V.createSvgDocument();\n                else if (el[0] === \"<\") {\n                    // Create element from an SVG string.\n                    // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n                    var svgDoc = V.createSvgDocument(el);\n                    // Note that `V()` might also return an array should the SVG string passed as\n                    // the first argument contain more than one root element.\n                    if (svgDoc.childNodes.length > 1) {\n                        // Map child nodes to `V`s.\n                        var arrayOfVels = [];\n                        var i, len;\n                        for(i = 0, len = svgDoc.childNodes.length; i < len; i++){\n                            var childNode = svgDoc.childNodes[i];\n                            arrayOfVels.push(new V(document.importNode(childNode, true)));\n                        }\n                        return arrayOfVels;\n                    }\n                    el = document.importNode(svgDoc.firstChild, true);\n                } else el = document.createElementNS(ns.svg, el);\n                V.ensureId(el);\n            }\n            this.node = el;\n            this.setAttributes(attrs);\n            if (children) this.append(children);\n            return this;\n        };\n        var VPrototype = V.prototype;\n        Object.defineProperty(VPrototype, \"id\", {\n            enumerable: true,\n            get: function() {\n                return this.node.id;\n            },\n            set: function(id) {\n                this.node.id = id;\n            }\n        });\n        /**\n\t     * @param {SVGGElement} toElem\n\t     * @returns {SVGMatrix}\n\t     */ VPrototype.getTransformToElement = function(target) {\n            var node = this.node;\n            if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {\n                var targetCTM = V.toNode(target).getScreenCTM();\n                var nodeCTM = node.getScreenCTM();\n                if (targetCTM && nodeCTM) return targetCTM.inverse().multiply(nodeCTM);\n            }\n            // Could not get actual transformation matrix\n            return V.createSVGMatrix();\n        };\n        /**\n\t     * @param {SVGMatrix} matrix\n\t     * @param {Object=} opt\n\t     * @returns {Vectorizer|SVGMatrix} Setter / Getter\n\t     */ VPrototype.transform = function(matrix, opt) {\n            var node = this.node;\n            if (V.isUndefined(matrix)) return V.transformStringToMatrix(this.attr(\"transform\"));\n            if (opt && opt.absolute) return this.attr(\"transform\", V.matrixToTransformString(matrix));\n            var svgTransform = V.createSVGTransform(matrix);\n            node.transform.baseVal.appendItem(svgTransform);\n            return this;\n        };\n        VPrototype.translate = function(tx, ty, opt) {\n            opt = opt || {};\n            ty = ty || 0;\n            var transformAttr = this.attr(\"transform\") || \"\";\n            var transform = V.parseTransformString(transformAttr);\n            transformAttr = transform.value;\n            // Is it a getter?\n            if (V.isUndefined(tx)) return transform.translate;\n            transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, \"\").trim();\n            var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n            var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n            var newTranslate = \"translate(\" + newTx + \",\" + newTy + \")\";\n            // Note that `translate()` is always the first transformation. This is\n            // usually the desired case.\n            this.attr(\"transform\", (newTranslate + \" \" + transformAttr).trim());\n            return this;\n        };\n        VPrototype.rotate = function(angle, cx, cy, opt) {\n            opt = opt || {};\n            var transformAttr = this.attr(\"transform\") || \"\";\n            var transform = V.parseTransformString(transformAttr);\n            transformAttr = transform.value;\n            // Is it a getter?\n            if (V.isUndefined(angle)) return transform.rotate;\n            transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, \"\").trim();\n            angle %= 360;\n            var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n            var newOrigin = cx !== undefined && cy !== undefined ? \",\" + cx + \",\" + cy : \"\";\n            var newRotate = \"rotate(\" + newAngle + newOrigin + \")\";\n            this.attr(\"transform\", (transformAttr + \" \" + newRotate).trim());\n            return this;\n        };\n        // Note that `scale` as the only transformation does not combine with previous values.\n        VPrototype.scale = function(sx, sy) {\n            sy = V.isUndefined(sy) ? sx : sy;\n            var transformAttr = this.attr(\"transform\") || \"\";\n            var transform = V.parseTransformString(transformAttr);\n            transformAttr = transform.value;\n            // Is it a getter?\n            if (V.isUndefined(sx)) return transform.scale;\n            transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, \"\").trim();\n            var newScale = \"scale(\" + sx + \",\" + sy + \")\";\n            this.attr(\"transform\", (transformAttr + \" \" + newScale).trim());\n            return this;\n        };\n        // Get SVGRect that contains coordinates and dimension of the real bounding box,\n        // i.e. after transformations are applied.\n        // If `target` is specified, bounding box will be computed relatively to `target` element.\n        VPrototype.bbox = function(withoutTransformations, target) {\n            var box;\n            var node = this.node;\n            var ownerSVGElement = node.ownerSVGElement;\n            // If the element is not in the live DOM, it does not have a bounding box defined and\n            // so fall back to 'zero' dimension element.\n            if (!ownerSVGElement) return new Rect(0, 0, 0, 0);\n            try {\n                box = node.getBBox();\n            } catch (e) {\n                // Fallback for IE.\n                box = {\n                    x: node.clientLeft,\n                    y: node.clientTop,\n                    width: node.clientWidth,\n                    height: node.clientHeight\n                };\n            }\n            if (withoutTransformations) return new Rect(box);\n            var matrix = this.getTransformToElement(target || ownerSVGElement);\n            return V.transformRect(box, matrix);\n        };\n        // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n        // i.e. after transformations are applied.\n        // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n        // Takes an (Object) `opt` argument (optional) with the following attributes:\n        // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n        // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n        VPrototype.getBBox = function(opt) {\n            var options = {};\n            var outputBBox;\n            var node = this.node;\n            var ownerSVGElement = node.ownerSVGElement;\n            // If the element is not in the live DOM, it does not have a bounding box defined and\n            // so fall back to 'zero' dimension element.\n            // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n            if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) return new Rect(0, 0, 0, 0);\n            if (opt) {\n                if (opt.target) options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n                if (opt.recursive) options.recursive = opt.recursive;\n            }\n            if (!options.recursive) {\n                try {\n                    outputBBox = node.getBBox();\n                } catch (e) {\n                    // Fallback for IE.\n                    outputBBox = {\n                        x: node.clientLeft,\n                        y: node.clientTop,\n                        width: node.clientWidth,\n                        height: node.clientHeight\n                    };\n                }\n                if (!options.target) // transform like this (that is, not at all)\n                return new Rect(outputBBox);\n                else {\n                    // transform like target\n                    var matrix = this.getTransformToElement(options.target);\n                    return V.transformRect(outputBBox, matrix);\n                }\n            } else {\n                // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n                // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n                // this happens even if we wrap a single svg element into a group!\n                // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n                var children = this.children();\n                var n = children.length;\n                if (n === 0) return this.getBBox({\n                    target: options.target,\n                    recursive: false\n                });\n                // recursion's initial pass-through setting:\n                // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n                if (!options.target) // transform children/descendants like this (their parent/ancestor)\n                options.target = this;\n                 // else transform children/descendants like target\n                for(var i = 0; i < n; i++){\n                    var currentChild = children[i];\n                    var childBBox;\n                    // if currentChild is not a group element, get its bbox with a nonrecursive call\n                    if (currentChild.children().length === 0) childBBox = currentChild.getBBox({\n                        target: options.target,\n                        recursive: false\n                    });\n                    else // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n                    childBBox = currentChild.getBBox({\n                        target: options.target,\n                        recursive: true\n                    });\n                    if (!outputBBox) // if this is the first iteration\n                    outputBBox = childBBox;\n                    else // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n                    outputBBox = outputBBox.union(childBBox);\n                }\n                return outputBBox;\n            }\n        };\n        // Text() helpers\n        function createTextPathNode(attrs, vel) {\n            attrs || (attrs = {});\n            var textPathElement = V(\"textPath\");\n            var d = attrs.d;\n            if (d && attrs[\"xlink:href\"] === undefined) {\n                // If `opt.attrs` is a plain string, consider it to be directly the\n                // SVG path data for the text to go along (this is a shortcut).\n                // Otherwise if it is an object and contains the `d` property, then this is our path.\n                // Wrap the text in the SVG <textPath> element that points\n                // to a path defined by `opt.attrs` inside the `<defs>` element.\n                var linkedPath = V(\"path\").attr(\"d\", d).appendTo(vel.defs());\n                textPathElement.attr(\"xlink:href\", \"#\" + linkedPath.id);\n            }\n            if (V.isObject(attrs)) // Set attributes on the `<textPath>`. The most important one\n            // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n            // Note that we also allow the following construct:\n            // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n            // In other words, one can completely skip the auto-creation of the path\n            // and use any other arbitrary path that is in the document.\n            textPathElement.attr(attrs);\n            return textPathElement.node;\n        }\n        function annotateTextLine(lineNode, lineAnnotations, opt) {\n            opt || (opt = {});\n            var includeAnnotationIndices = opt.includeAnnotationIndices;\n            var eol = opt.eol;\n            var lineHeight = opt.lineHeight;\n            var baseSize = opt.baseSize;\n            var maxFontSize = 0;\n            var fontMetrics = {};\n            var lastJ = lineAnnotations.length - 1;\n            for(var j = 0; j <= lastJ; j++){\n                var annotation = lineAnnotations[j];\n                var fontSize = null;\n                if (V.isObject(annotation)) {\n                    var annotationAttrs = annotation.attrs;\n                    var vTSpan = V(\"tspan\", annotationAttrs);\n                    var tspanNode = vTSpan.node;\n                    var t = annotation.t;\n                    if (eol && j === lastJ) t += eol;\n                    tspanNode.textContent = t;\n                    // Per annotation className\n                    var annotationClass = annotationAttrs[\"class\"];\n                    if (annotationClass) vTSpan.addClass(annotationClass);\n                    // If `opt.includeAnnotationIndices` is `true`,\n                    // set the list of indices of all the applied annotations\n                    // in the `annotations` attribute. This list is a comma\n                    // separated list of indices.\n                    if (includeAnnotationIndices) vTSpan.attr(\"annotations\", annotation.annotations);\n                    // Check for max font size\n                    fontSize = parseFloat(annotationAttrs[\"font-size\"]);\n                    if (!isFinite(fontSize)) fontSize = baseSize;\n                    if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n                } else {\n                    if (eol && j === lastJ) annotation += eol;\n                    tspanNode = document.createTextNode(annotation || \" \");\n                    if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;\n                }\n                lineNode.appendChild(tspanNode);\n            }\n            if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;\n            if (lineHeight) fontMetrics.lineHeight = lineHeight;\n            else if (maxFontSize) fontMetrics.lineHeight = maxFontSize * 1.2;\n            return fontMetrics;\n        }\n        var emRegex = /em$/;\n        function convertEmToPx(em, fontSize) {\n            var numerical = parseFloat(em);\n            if (emRegex.test(em)) return numerical * fontSize;\n            return numerical;\n        }\n        function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n            if (!Array.isArray(linesMetrics)) return 0;\n            var n = linesMetrics.length;\n            if (!n) return 0;\n            var lineMetrics = linesMetrics[0];\n            var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n            var rLineHeights = 0;\n            var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n            for(var i = 1; i < n; i++){\n                lineMetrics = linesMetrics[i];\n                var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n                rLineHeights += iLineHeight;\n            }\n            var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n            var dy;\n            switch(alignment){\n                case \"middle\":\n                    dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;\n                    break;\n                case \"bottom\":\n                    dy = -(0.25 * llMaxFont) - rLineHeights;\n                    break;\n                default:\n                case \"top\":\n                    dy = 0.8 * flMaxFont;\n                    break;\n            }\n            return dy;\n        }\n        VPrototype.text = function(content, opt) {\n            if (content && typeof content !== \"string\") throw new Error(\"Vectorizer: text() expects the first argument to be a string.\");\n            // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n            // IE would otherwise collapse all spaces into one.\n            content = V.sanitizeText(content);\n            opt || (opt = {});\n            // Should we allow the text to be selected?\n            var displayEmpty = opt.displayEmpty;\n            // End of Line character\n            var eol = opt.eol;\n            // Text along path\n            var textPath = opt.textPath;\n            // Vertical shift\n            var verticalAnchor = opt.textVerticalAnchor;\n            var namedVerticalAnchor = verticalAnchor === \"middle\" || verticalAnchor === \"bottom\" || verticalAnchor === \"top\";\n            // Horizontal shift applied to all the lines but the first.\n            var x = opt.x;\n            if (x === undefined) x = this.attr(\"x\") || 0;\n            // Annotations\n            var iai = opt.includeAnnotationIndices;\n            var annotations = opt.annotations;\n            if (annotations && !V.isArray(annotations)) annotations = [\n                annotations\n            ];\n            // Shift all the <tspan> but first by one line (`1em`)\n            var defaultLineHeight = opt.lineHeight;\n            var autoLineHeight = defaultLineHeight === \"auto\";\n            var lineHeight = autoLineHeight ? \"1.5em\" : defaultLineHeight || \"1em\";\n            // Clearing the element\n            this.empty();\n            this.attr({\n                // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n                \"xml:space\": \"preserve\",\n                // An empty text gets rendered into the DOM in webkit-based browsers.\n                // In order to unify this behaviour across all browsers\n                // we rather hide the text element when it's empty.\n                \"display\": content || displayEmpty ? null : \"none\"\n            });\n            // Set default font-size if none\n            var fontSize = parseFloat(this.attr(\"font-size\"));\n            if (!fontSize) {\n                fontSize = 16;\n                if (namedVerticalAnchor || annotations) this.attr(\"font-size\", fontSize);\n            }\n            var doc = document;\n            var containerNode;\n            if (textPath) {\n                // Now all the `<tspan>`s will be inside the `<textPath>`.\n                if (typeof textPath === \"string\") textPath = {\n                    d: textPath\n                };\n                containerNode = createTextPathNode(textPath, this);\n            } else containerNode = doc.createDocumentFragment();\n            var offset = 0;\n            var lines = content.split(\"\\n\");\n            var linesMetrics = [];\n            var annotatedY;\n            for(var i = 0, lastI = lines.length - 1; i <= lastI; i++){\n                var dy = lineHeight;\n                var lineClassName = \"v-line\";\n                var lineNode = doc.createElementNS(ns.svg, \"tspan\");\n                var line = lines[i];\n                var lineMetrics;\n                if (line) {\n                    if (annotations) {\n                        // Find the *compacted* annotations for this line.\n                        var lineAnnotations = V.annotateString(line, annotations, {\n                            offset: -offset,\n                            includeAnnotationIndices: iai\n                        });\n                        lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n                            includeAnnotationIndices: iai,\n                            eol: i !== lastI && eol,\n                            lineHeight: autoLineHeight ? null : lineHeight,\n                            baseSize: fontSize\n                        });\n                        // Get the line height based on the biggest font size in the annotations for this line.\n                        var iLineHeight = lineMetrics.lineHeight;\n                        if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;\n                        if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;\n                    } else {\n                        if (eol && i !== lastI) line += eol;\n                        lineNode.textContent = line;\n                    }\n                } else {\n                    // Make sure the textContent is never empty. If it is, add a dummy\n                    // character and make it invisible, making the following lines correctly\n                    // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n                    lineNode.textContent = \"-\";\n                    lineClassName += \" v-empty-line\";\n                    // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n                    // is not applied in Firefox\n                    var lineNodeStyle = lineNode.style;\n                    lineNodeStyle.fillOpacity = 0;\n                    lineNodeStyle.strokeOpacity = 0;\n                    if (annotations) {\n                        // Empty line with annotations.\n                        lineMetrics = {};\n                        lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);\n                        var lineFontSize = fontSize;\n                        // Check if any of the annotations overrides the font size.\n                        for(var j = lineAnnotations.length; j > 0; j--){\n                            var attrs = lineAnnotations[j - 1].attrs;\n                            if (!attrs || !(\"font-size\" in attrs)) continue;\n                            var fs = parseFloat(attrs[\"font-size\"]);\n                            if (isFinite(fs)) {\n                                lineFontSize = fs;\n                                break;\n                            }\n                        }\n                        if (autoLineHeight) {\n                            if (i > 0) dy = lineFontSize * 1.2;\n                            else annotatedY = lineFontSize * 0.8;\n                        }\n                        // The font size is important for the native selection box height.\n                        lineNode.setAttribute(\"font-size\", lineFontSize);\n                        lineMetrics.maxFontSize = lineFontSize;\n                    }\n                }\n                if (lineMetrics) linesMetrics.push(lineMetrics);\n                if (i > 0) lineNode.setAttribute(\"dy\", dy);\n                // Firefox requires 'x' to be set on the first line when inside a text path\n                if (i > 0 || textPath) lineNode.setAttribute(\"x\", x);\n                lineNode.className.baseVal = lineClassName;\n                containerNode.appendChild(lineNode);\n                offset += line.length + 1; // + 1 = newline character.\n            }\n            // Y Alignment calculation\n            if (namedVerticalAnchor) {\n                if (annotations) dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n                else if (verticalAnchor === \"top\") // A shortcut for top alignment. It does not depend on font-size nor line-height\n                dy = \"0.8em\";\n                else {\n                    var rh; // remaining height\n                    if (lastI > 0) {\n                        rh = parseFloat(lineHeight) || 1;\n                        rh *= lastI;\n                        if (!emRegex.test(lineHeight)) rh /= fontSize;\n                    } else // Single-line text\n                    rh = 0;\n                    switch(verticalAnchor){\n                        case \"middle\":\n                            dy = 0.3 - rh / 2 + \"em\";\n                            break;\n                        case \"bottom\":\n                            dy = -rh - 0.3 + \"em\";\n                            break;\n                    }\n                }\n            } else {\n                if (verticalAnchor === 0) dy = \"0em\";\n                else if (verticalAnchor) dy = verticalAnchor;\n                else {\n                    // No vertical anchor is defined\n                    dy = 0;\n                    // Backwards compatibility - we change the `y` attribute instead of `dy`.\n                    if (this.attr(\"y\") === null) this.attr(\"y\", annotatedY || \"0.8em\");\n                }\n            }\n            containerNode.firstChild.setAttribute(\"dy\", dy);\n            // Appending lines to the element.\n            this.append(containerNode);\n            return this;\n        };\n        /**\n\t     * @public\n\t     * @param {string} name\n\t     * @returns {Vectorizer}\n\t     */ VPrototype.removeAttr = function(name) {\n            var qualifiedName = V.qualifyAttr(name);\n            var el = this.node;\n            if (qualifiedName.ns) {\n                if (el.hasAttributeNS(qualifiedName.ns, qualifiedName.local)) el.removeAttributeNS(qualifiedName.ns, qualifiedName.local);\n            } else if (el.hasAttribute(name)) el.removeAttribute(name);\n            return this;\n        };\n        VPrototype.attr = function(name, value) {\n            if (V.isUndefined(name)) {\n                // Return all attributes.\n                var attributes = this.node.attributes;\n                var attrs = {};\n                for(var i = 0; i < attributes.length; i++)attrs[attributes[i].name] = attributes[i].value;\n                return attrs;\n            }\n            if (V.isString(name) && V.isUndefined(value)) return this.node.getAttribute(name);\n            if (typeof name === \"object\") {\n                for(var attrName in name)if (name.hasOwnProperty(attrName)) this.setAttribute(attrName, name[attrName]);\n            } else this.setAttribute(name, value);\n            return this;\n        };\n        VPrototype.normalizePath = function() {\n            var tagName = this.tagName();\n            if (tagName === \"PATH\") this.attr(\"d\", V.normalizePathData(this.attr(\"d\")));\n            return this;\n        };\n        VPrototype.remove = function() {\n            if (this.node.parentNode) this.node.parentNode.removeChild(this.node);\n            return this;\n        };\n        VPrototype.empty = function() {\n            while(this.node.firstChild)this.node.removeChild(this.node.firstChild);\n            return this;\n        };\n        /**\n\t     * @private\n\t     * @param {object} attrs\n\t     * @returns {Vectorizer}\n\t     */ VPrototype.setAttributes = function(attrs) {\n            for(var key in attrs)if (attrs.hasOwnProperty(key)) this.setAttribute(key, attrs[key]);\n            return this;\n        };\n        VPrototype.append = function(els) {\n            if (!V.isArray(els)) els = [\n                els\n            ];\n            for(var i = 0, len = els.length; i < len; i++)this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n            return this;\n        };\n        VPrototype.prepend = function(els) {\n            var child = this.node.firstChild;\n            return child ? V(child).before(els) : this.append(els);\n        };\n        VPrototype.before = function(els) {\n            var node = this.node;\n            var parent = node.parentNode;\n            if (parent) {\n                if (!V.isArray(els)) els = [\n                    els\n                ];\n                for(var i = 0, len = els.length; i < len; i++)parent.insertBefore(V.toNode(els[i]), node);\n            }\n            return this;\n        };\n        VPrototype.appendTo = function(node) {\n            V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n            return this;\n        };\n        VPrototype.svg = function() {\n            return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n        };\n        VPrototype.tagName = function() {\n            return this.node.tagName.toUpperCase();\n        };\n        VPrototype.defs = function() {\n            var context = this.svg() || this;\n            var defsNode = context.node.getElementsByTagName(\"defs\")[0];\n            if (defsNode) return V(defsNode);\n            return V(\"defs\").appendTo(context);\n        };\n        VPrototype.clone = function() {\n            var clone = V(this.node.cloneNode(true));\n            // Note that clone inherits also ID. Therefore, we need to change it here.\n            clone.node.id = V.uniqueId();\n            return clone;\n        };\n        VPrototype.findOne = function(selector) {\n            var found = this.node.querySelector(selector);\n            return found ? V(found) : undefined;\n        };\n        VPrototype.find = function(selector) {\n            var vels = [];\n            var nodes = this.node.querySelectorAll(selector);\n            if (nodes) // Map DOM elements to `V`s.\n            for(var i = 0; i < nodes.length; i++)vels.push(V(nodes[i]));\n            return vels;\n        };\n        // Returns an array of V elements made from children of this.node.\n        VPrototype.children = function() {\n            var children = this.node.childNodes;\n            var outputArray = [];\n            for(var i = 0; i < children.length; i++){\n                var currentChild = children[i];\n                if (currentChild.nodeType === 1) outputArray.push(V(children[i]));\n            }\n            return outputArray;\n        };\n        // Returns the V element from parentNode of this.node.\n        VPrototype.parent = function() {\n            return V(this.node.parentNode) || null;\n        }, // Find an index of an element inside its container.\n        VPrototype.index = function() {\n            var index = 0;\n            var node = this.node.previousSibling;\n            while(node){\n                // nodeType 1 for ELEMENT_NODE\n                if (node.nodeType === 1) index++;\n                node = node.previousSibling;\n            }\n            return index;\n        };\n        VPrototype.findParentByClass = function(className, terminator) {\n            var ownerSVGElement = this.node.ownerSVGElement;\n            var node = this.node.parentNode;\n            while(node && node !== terminator && node !== ownerSVGElement){\n                var vel = V(node);\n                if (vel.hasClass(className)) return vel;\n                node = node.parentNode;\n            }\n            return null;\n        };\n        // https://jsperf.com/get-common-parent\n        VPrototype.contains = function(el) {\n            var a = this.node;\n            var b = V.toNode(el);\n            var bup = b && b.parentNode;\n            return a === bup || !!(bup && bup.nodeType === 1 && a.compareDocumentPosition(bup) & 16);\n        };\n        // Convert global point into the coordinate space of this element.\n        VPrototype.toLocalPoint = function(x, y) {\n            var svg = this.svg().node;\n            var p = svg.createSVGPoint();\n            p.x = x;\n            p.y = y;\n            try {\n                var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n                var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n            } catch (e) {\n                // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n                // We have to make do with the original coordianates.\n                return p;\n            }\n            return globalPoint.matrixTransform(globalToLocalMatrix);\n        };\n        VPrototype.translateCenterToPoint = function(p) {\n            var bbox = this.getBBox({\n                target: this.svg()\n            });\n            var center = bbox.center();\n            this.translate(p.x - center.x, p.y - center.y);\n            return this;\n        };\n        // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n        // of markers. The easiest way of understanding on what this does is to imagine the element is an\n        // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n        // being auto-oriented (properly rotated) towards the `reference` point.\n        // `target` is the element relative to which the transformations are applied. Usually a viewport.\n        VPrototype.translateAndAutoOrient = function(position, reference, target) {\n            position = new Point(position);\n            reference = new Point(reference);\n            target || (target = this.svg());\n            // Clean-up previously set transformations except the scale. If we didn't clean up the\n            // previous transformations then they'd add up with the old ones. Scale is an exception as\n            // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n            // element is scaled by the factor 2, not 8.\n            var scale = this.scale();\n            this.attr(\"transform\", \"\");\n            var bbox = this.getBBox({\n                target: target\n            }).scale(scale.sx, scale.sy);\n            // 1. Translate to origin.\n            var translateToOrigin = V.createSVGTransform();\n            translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n            // 2. Rotate around origin.\n            var rotateAroundOrigin = V.createSVGTransform();\n            var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n            if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);\n            // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n            var translateFromOrigin = V.createSVGTransform();\n            var finalPosition = position.clone().move(reference, bbox.width / 2);\n            translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);\n            // 4. Get the current transformation matrix of this node\n            var ctm = this.getTransformToElement(target);\n            // 5. Apply transformations and the scale\n            var transform = V.createSVGTransform();\n            transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(scale.sx, scale.sy)))));\n            this.attr(\"transform\", V.matrixToTransformString(transform.matrix));\n            return this;\n        };\n        VPrototype.animateAlongPath = function(attrs, path) {\n            path = V.toNode(path);\n            var id = V.ensureId(path);\n            var animateMotion = V(\"animateMotion\", attrs);\n            var mpath = V(\"mpath\", {\n                \"xlink:href\": \"#\" + id\n            });\n            animateMotion.append(mpath);\n            this.append(animateMotion);\n            try {\n                animateMotion.node.beginElement();\n            } catch (e) {\n                // Fallback for IE 9.\n                // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n                if (document.documentElement.getAttribute(\"smiling\") === \"fake\") {\n                    /* global getTargets:true, Animator:true, animators:true id2anim:true */ // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n                    var animation = animateMotion.node;\n                    animation.animators = [];\n                    var animationID = animation.getAttribute(\"id\");\n                    if (animationID) id2anim[animationID] = animation;\n                    var targets = getTargets(animation);\n                    for(var i = 0, len = targets.length; i < len; i++){\n                        var target = targets[i];\n                        var animator = new Animator(animation, target, i);\n                        animators.push(animator);\n                        animation.animators[i] = animator;\n                        animator.register();\n                    }\n                }\n            }\n            return this;\n        };\n        // Split a string into an array of tokens.\n        // https://infra.spec.whatwg.org/#ascii-whitespace\n        var noHTMLWhitespaceRegex = /[^\\x20\\t\\r\\n\\f]+/g;\n        function getTokenList(str) {\n            if (!V.isString(str)) return [];\n            return str.trim().match(noHTMLWhitespaceRegex) || [];\n        }\n        VPrototype.hasClass = function(className) {\n            if (!V.isString(className)) return false;\n            return this.node.classList.contains(className.trim());\n        };\n        VPrototype.addClass = function(className) {\n            var ref;\n            (ref = this.node.classList).add.apply(ref, getTokenList(className));\n            return this;\n        };\n        VPrototype.removeClass = function(className) {\n            var ref;\n            (ref = this.node.classList).remove.apply(ref, getTokenList(className));\n            return this;\n        };\n        VPrototype.toggleClass = function(className, toAdd) {\n            var tokens = getTokenList(className);\n            for(var i = 0; i < tokens.length; i++)this.node.classList.toggle(tokens[i], toAdd);\n            return this;\n        };\n        // Interpolate path by discrete points. The precision of the sampling\n        // is controlled by `interval`. In other words, `sample()` will generate\n        // a point on the path starting at the beginning of the path going to the end\n        // every `interval` pixels.\n        // The sampler can be very useful for e.g. finding intersection between two\n        // paths (finding the two closest points from two samples).\n        VPrototype.sample = function(interval) {\n            interval = interval || 1;\n            var node = this.node;\n            var length = node.getTotalLength();\n            var samples = [];\n            var distance = 0;\n            var sample;\n            while(distance < length){\n                sample = node.getPointAtLength(distance);\n                samples.push({\n                    x: sample.x,\n                    y: sample.y,\n                    distance: distance\n                });\n                distance += interval;\n            }\n            return samples;\n        };\n        VPrototype.convertToPath = function() {\n            var path = V(\"path\");\n            path.attr(this.attr());\n            var d = this.convertToPathData();\n            if (d) path.attr(\"d\", d);\n            return path;\n        };\n        VPrototype.convertToPathData = function() {\n            var tagName = this.tagName();\n            switch(tagName){\n                case \"PATH\":\n                    return this.attr(\"d\");\n                case \"LINE\":\n                    return V.convertLineToPathData(this.node);\n                case \"POLYGON\":\n                    return V.convertPolygonToPathData(this.node);\n                case \"POLYLINE\":\n                    return V.convertPolylineToPathData(this.node);\n                case \"ELLIPSE\":\n                    return V.convertEllipseToPathData(this.node);\n                case \"CIRCLE\":\n                    return V.convertCircleToPathData(this.node);\n                case \"RECT\":\n                    return V.convertRectToPathData(this.node);\n            }\n            throw new Error(tagName + \" cannot be converted to PATH.\");\n        };\n        V.prototype.toGeometryShape = function() {\n            var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n            switch(this.tagName()){\n                case \"RECT\":\n                    x = parseFloat(this.attr(\"x\")) || 0;\n                    y = parseFloat(this.attr(\"y\")) || 0;\n                    width = parseFloat(this.attr(\"width\")) || 0;\n                    height = parseFloat(this.attr(\"height\")) || 0;\n                    return new Rect(x, y, width, height);\n                case \"CIRCLE\":\n                    cx = parseFloat(this.attr(\"cx\")) || 0;\n                    cy = parseFloat(this.attr(\"cy\")) || 0;\n                    r = parseFloat(this.attr(\"r\")) || 0;\n                    return new Ellipse({\n                        x: cx,\n                        y: cy\n                    }, r, r);\n                case \"ELLIPSE\":\n                    cx = parseFloat(this.attr(\"cx\")) || 0;\n                    cy = parseFloat(this.attr(\"cy\")) || 0;\n                    rx = parseFloat(this.attr(\"rx\")) || 0;\n                    ry = parseFloat(this.attr(\"ry\")) || 0;\n                    return new Ellipse({\n                        x: cx,\n                        y: cy\n                    }, rx, ry);\n                case \"POLYLINE\":\n                    points = V.getPointsFromSvgNode(this);\n                    return new Polyline(points);\n                case \"POLYGON\":\n                    points = V.getPointsFromSvgNode(this);\n                    if (points.length > 1) points.push(points[0]);\n                    return new Polyline(points);\n                case \"PATH\":\n                    d = this.attr(\"d\");\n                    if (!Path.isDataSupported(d)) d = V.normalizePathData(d);\n                    return new Path(d);\n                case \"LINE\":\n                    x1 = parseFloat(this.attr(\"x1\")) || 0;\n                    y1 = parseFloat(this.attr(\"y1\")) || 0;\n                    x2 = parseFloat(this.attr(\"x2\")) || 0;\n                    y2 = parseFloat(this.attr(\"y2\")) || 0;\n                    return new Line({\n                        x: x1,\n                        y: y1\n                    }, {\n                        x: x2,\n                        y: y2\n                    });\n            }\n            // Anything else is a rectangle\n            return this.getBBox();\n        };\n        // Find the intersection of a line starting in the center\n        // of the SVG `node` ending in the point `ref`.\n        // `target` is an SVG element to which `node`s transformations are relative to.\n        // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n        // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n        // an intersection is found. Returns `undefined` otherwise.\n        VPrototype.findIntersection = function(ref, target) {\n            var svg = this.svg().node;\n            target = target || svg;\n            var bbox = this.getBBox({\n                target: target\n            });\n            var center = bbox.center();\n            if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;\n            var spot;\n            var tagName = this.tagName();\n            // Little speed up optimization for `<rect>` element. We do not do conversion\n            // to path element and sampling but directly calculate the intersection through\n            // a transformed geometrical rectangle.\n            if (tagName === \"RECT\") {\n                var gRect = new Rect(parseFloat(this.attr(\"x\") || 0), parseFloat(this.attr(\"y\") || 0), parseFloat(this.attr(\"width\")), parseFloat(this.attr(\"height\")));\n                // Get the rect transformation matrix with regards to the SVG document.\n                var rectMatrix = this.getTransformToElement(target);\n                // Decompose the matrix to find the rotation angle.\n                var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\n                // Now we want to rotate the rectangle back so that we\n                // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n                var resetRotation = svg.createSVGTransform();\n                resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n                var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n                spot = new Rect(rect).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n            } else if (tagName === \"PATH\" || tagName === \"POLYGON\" || tagName === \"POLYLINE\" || tagName === \"CIRCLE\" || tagName === \"ELLIPSE\") {\n                var pathNode = tagName === \"PATH\" ? this : this.convertToPath();\n                var samples = pathNode.sample();\n                var minDistance = Infinity;\n                var closestSamples = [];\n                var i, sample, gp, centerDistance, refDistance, distance;\n                for(i = 0; i < samples.length; i++){\n                    sample = samples[i];\n                    // Convert the sample point in the local coordinate system to the global coordinate system.\n                    gp = V.createSVGPoint(sample.x, sample.y);\n                    gp = gp.matrixTransform(this.getTransformToElement(target));\n                    sample = new Point(gp);\n                    centerDistance = sample.distance(center);\n                    // Penalize a higher distance to the reference point by 10%.\n                    // This gives better results. This is due to\n                    // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n                    refDistance = sample.distance(ref) * 1.1;\n                    distance = centerDistance + refDistance;\n                    if (distance < minDistance) {\n                        minDistance = distance;\n                        closestSamples = [\n                            {\n                                sample: sample,\n                                refDistance: refDistance\n                            }\n                        ];\n                    } else if (distance < minDistance + 1) closestSamples.push({\n                        sample: sample,\n                        refDistance: refDistance\n                    });\n                }\n                closestSamples.sort(function(a, b) {\n                    return a.refDistance - b.refDistance;\n                });\n                if (closestSamples[0]) spot = closestSamples[0].sample;\n            }\n            return spot;\n        };\n        /**\n\t     * @private\n\t     * @param {string} name\n\t     * @param {string} value\n\t     * @returns {Vectorizer}\n\t     */ VPrototype.setAttribute = function(name, value) {\n            var el = this.node;\n            if (value === null) {\n                this.removeAttr(name);\n                return this;\n            }\n            var qualifiedName = V.qualifyAttr(name);\n            if (qualifiedName.ns) // Attribute names can be namespaced. E.g. `image` elements\n            // have a `xlink:href` attribute to set the source of the image.\n            el.setAttributeNS(qualifiedName.ns, name, value);\n            else if (name === \"id\") el.id = value;\n            else el.setAttribute(name, value);\n            return this;\n        };\n        // Create an SVG document element.\n        // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n        V.createSvgDocument = function(content) {\n            if (content) {\n                var XMLString = '<svg xmlns=\"' + ns.svg + '\" xmlns:xlink=\"' + ns.xlink + '\" version=\"' + SVGVersion + '\">' + content + \"</svg>\";\n                var ref = V.parseXML(XMLString, {\n                    async: false\n                });\n                var documentElement = ref.documentElement;\n                return documentElement;\n            }\n            var svg = document.createElementNS(ns.svg, \"svg\");\n            svg.setAttributeNS(ns.xmlns, \"xmlns:xlink\", ns.xlink);\n            svg.setAttribute(\"version\", SVGVersion);\n            return svg;\n        };\n        V.createSVGStyle = function(stylesheet) {\n            var ref = V(\"style\", {\n                type: \"text/css\"\n            }, [\n                V.createCDATASection(stylesheet)\n            ]);\n            var node = ref.node;\n            return node;\n        }, V.createCDATASection = function(data) {\n            if (data === void 0) data = \"\";\n            var xml = document.implementation.createDocument(null, \"xml\", null);\n            return xml.createCDATASection(data);\n        };\n        V.idCounter = 0;\n        // A function returning a unique identifier for this client session with every call.\n        V.uniqueId = function() {\n            return \"v-\" + ++V.idCounter;\n        };\n        V.toNode = function(el) {\n            return V.isV(el) ? el.node : el.nodeName && el || el[0];\n        };\n        V.ensureId = function(node) {\n            node = V.toNode(node);\n            return node.id || (node.id = V.uniqueId());\n        };\n        // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n        // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n        // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n        // when you want to compare the actual DOM text content without having to add the unicode character in\n        // the place of all spaces.\n        V.sanitizeText = function(text) {\n            return (text || \"\").replace(/ /g, \"\\xa0\");\n        };\n        V.isUndefined = function(value) {\n            return typeof value === \"undefined\";\n        };\n        V.isString = function(value) {\n            return typeof value === \"string\";\n        };\n        V.isObject = function(value) {\n            return value && typeof value === \"object\";\n        };\n        V.isArray = Array.isArray;\n        V.parseXML = function(data, opt) {\n            opt = opt || {};\n            var xml;\n            try {\n                var parser = new DOMParser();\n                if (!V.isUndefined(opt.async)) parser.async = opt.async;\n                xml = parser.parseFromString(data, \"text/xml\");\n            } catch (error) {\n                xml = undefined;\n            }\n            if (!xml || xml.getElementsByTagName(\"parsererror\").length) throw new Error(\"Invalid XML: \" + data);\n            return xml;\n        };\n        /**\n\t     * @param {string} name\n\t     * @returns {{ns: string|null, local: string}} namespace and attribute name\n\t     */ V.qualifyAttr = function(name) {\n            if (name.indexOf(\":\") !== -1) {\n                var combinedKey = name.split(\":\");\n                return {\n                    ns: ns[combinedKey[0]],\n                    local: combinedKey[1]\n                };\n            }\n            return {\n                ns: null,\n                local: name\n            };\n        };\n        // Note: This regex allows multiple commas as separator which is incorrect in SVG\n        // This regex is used by `split()`, so it doesn't need to use /g\n        V.transformSeparatorRegex = /[ ,]+/;\n        // Note: All following regexes are more restrictive than SVG specification\n        // ReDoS mitigation: Use an anchor at the beginning of the match\n        // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)\n        // ReDoS mitigation: Don't match initial `(` inside repeated part\n        // The following regex needs to use /g (= cannot use capturing groups)\n        V.transformRegex = /\\b\\w+\\([^()]+\\)/g;\n        // The following regexes need to use capturing groups (= cannot use /g)\n        V.transformFunctionRegex = /\\b(\\w+)\\(([^()]+)\\)/;\n        V.transformTranslateRegex = /\\btranslate\\(([^()]+)\\)/;\n        V.transformRotateRegex = /\\brotate\\(([^()]+)\\)/;\n        V.transformScaleRegex = /\\bscale\\(([^()]+)\\)/;\n        V.transformStringToMatrix = function(transform) {\n            // Initialize result matrix as identity matrix\n            var transformationMatrix = V.createSVGMatrix();\n            // Note: Multiple transform functions are allowed in `transform` string\n            // `match()` returns `null` if none found\n            var transformMatches = transform && transform.match(V.transformRegex);\n            if (!transformMatches) // Return identity matrix\n            return transformationMatrix;\n            var numMatches = transformMatches.length;\n            for(var i = 0; i < numMatches; i++){\n                var transformMatch = transformMatches[i];\n                // Use same regex as above, but with capturing groups\n                // `match()` returns values of capturing groups as `[1]`, `[2]`\n                var transformFunctionMatch = transformMatch.match(V.transformFunctionRegex);\n                if (transformFunctionMatch) {\n                    var sx = void 0, sy = void 0, tx = void 0, ty = void 0, angle = void 0;\n                    var ctm = V.createSVGMatrix();\n                    var transformFunction = transformFunctionMatch[1].toLowerCase();\n                    var args = transformFunctionMatch[2].split(V.transformSeparatorRegex);\n                    switch(transformFunction){\n                        case \"scale\":\n                            sx = parseFloat(args[0]);\n                            sy = args[1] === undefined ? sx : parseFloat(args[1]);\n                            ctm = ctm.scaleNonUniform(sx, sy);\n                            break;\n                        case \"translate\":\n                            tx = parseFloat(args[0]);\n                            ty = parseFloat(args[1]);\n                            ctm = ctm.translate(tx, ty);\n                            break;\n                        case \"rotate\":\n                            angle = parseFloat(args[0]);\n                            tx = parseFloat(args[1]) || 0;\n                            ty = parseFloat(args[2]) || 0;\n                            if (tx !== 0 || ty !== 0) ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n                            else ctm = ctm.rotate(angle);\n                            break;\n                        case \"skewx\":\n                            angle = parseFloat(args[0]);\n                            ctm = ctm.skewX(angle);\n                            break;\n                        case \"skewy\":\n                            angle = parseFloat(args[0]);\n                            ctm = ctm.skewY(angle);\n                            break;\n                        case \"matrix\":\n                            ctm.a = parseFloat(args[0]);\n                            ctm.b = parseFloat(args[1]);\n                            ctm.c = parseFloat(args[2]);\n                            ctm.d = parseFloat(args[3]);\n                            ctm.e = parseFloat(args[4]);\n                            ctm.f = parseFloat(args[5]);\n                            break;\n                        default:\n                            continue;\n                    }\n                    // Multiply current transformation into result matrix\n                    transformationMatrix = transformationMatrix.multiply(ctm);\n                }\n            }\n            return transformationMatrix;\n        };\n        V.matrixToTransformString = function(matrix) {\n            matrix || (matrix = true);\n            return \"matrix(\" + (matrix.a !== undefined ? matrix.a : 1) + \",\" + (matrix.b !== undefined ? matrix.b : 0) + \",\" + (matrix.c !== undefined ? matrix.c : 0) + \",\" + (matrix.d !== undefined ? matrix.d : 1) + \",\" + (matrix.e !== undefined ? matrix.e : 0) + \",\" + (matrix.f !== undefined ? matrix.f : 0) + \")\";\n        };\n        V.parseTransformString = function(transform) {\n            var translate, rotate, scale;\n            if (transform) {\n                var separator = V.transformSeparatorRegex;\n                // Special handling for `transform` with one or more matrix functions\n                if (transform.trim().indexOf(\"matrix\") >= 0) {\n                    // Convert EVERYTHING in `transform` string to a matrix\n                    // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates\n                    // Note: In non-matrix case, we only take first one of each (if any)\n                    var matrix = V.transformStringToMatrix(transform);\n                    var decomposedMatrix = V.decomposeMatrix(matrix);\n                    // Extract `translate`, `scale`, `rotate` from matrix\n                    translate = [\n                        decomposedMatrix.translateX,\n                        decomposedMatrix.translateY\n                    ];\n                    scale = [\n                        decomposedMatrix.scaleX,\n                        decomposedMatrix.scaleY\n                    ];\n                    rotate = [\n                        decomposedMatrix.rotation\n                    ];\n                    // Rewrite `transform` string in `translate scale rotate` format\n                    var transformations = [];\n                    if (translate[0] !== 0 || translate[1] !== 0) transformations.push(\"translate(\" + translate + \")\");\n                    if (scale[0] !== 1 || scale[1] !== 1) transformations.push(\"scale(\" + scale + \")\");\n                    if (rotate[0] !== 0) transformations.push(\"rotate(\" + rotate + \")\");\n                    transform = transformations.join(\" \");\n                } else {\n                    // Extract `translate`, `rotate`, `scale` functions from `transform` string\n                    // Note: We only detect the first match of each (if any)\n                    // `match()` returns value of capturing group as `[1]`\n                    var translateMatch = transform.match(V.transformTranslateRegex);\n                    if (translateMatch) translate = translateMatch[1].split(separator);\n                    var rotateMatch = transform.match(V.transformRotateRegex);\n                    if (rotateMatch) rotate = rotateMatch[1].split(separator);\n                    var scaleMatch = transform.match(V.transformScaleRegex);\n                    if (scaleMatch) scale = scaleMatch[1].split(separator);\n                }\n            }\n            var sx = scale && scale[0] ? parseFloat(scale[0]) : 1;\n            return {\n                value: transform,\n                translate: {\n                    tx: translate && translate[0] ? parseInt(translate[0], 10) : 0,\n                    ty: translate && translate[1] ? parseInt(translate[1], 10) : 0\n                },\n                rotate: {\n                    angle: rotate && rotate[0] ? parseInt(rotate[0], 10) : 0,\n                    cx: rotate && rotate[1] ? parseInt(rotate[1], 10) : undefined,\n                    cy: rotate && rotate[2] ? parseInt(rotate[2], 10) : undefined\n                },\n                scale: {\n                    sx: sx,\n                    sy: scale && scale[1] ? parseFloat(scale[1]) : sx\n                }\n            };\n        };\n        V.deltaTransformPoint = function(matrix, point) {\n            var dx = point.x * matrix.a + point.y * matrix.c + 0;\n            var dy = point.x * matrix.b + point.y * matrix.d + 0;\n            return {\n                x: dx,\n                y: dy\n            };\n        };\n        V.decomposeMatrix = function(matrix) {\n            // @see https://gist.github.com/2052247\n            // calculate delta transform point\n            var px = V.deltaTransformPoint(matrix, {\n                x: 0,\n                y: 1\n            });\n            var py = V.deltaTransformPoint(matrix, {\n                x: 1,\n                y: 0\n            });\n            // calculate skew\n            var skewX = 180 / PI * atan2(px.y, px.x) - 90;\n            var skewY = 180 / PI * atan2(py.y, py.x);\n            return {\n                translateX: matrix.e,\n                translateY: matrix.f,\n                scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n                scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n                skewX: skewX,\n                skewY: skewY,\n                rotation: skewX // rotation is the same as skew x\n            };\n        };\n        // Return the `scale` transformation from the following equation:\n        // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n        V.matrixToScale = function(matrix) {\n            var a, b, c, d;\n            if (matrix) {\n                a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n                d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n                b = matrix.b;\n                c = matrix.c;\n            } else a = d = 1;\n            return {\n                sx: b ? sqrt(a * a + b * b) : a,\n                sy: c ? sqrt(c * c + d * d) : d\n            };\n        };\n        // Return the `rotate` transformation from the following equation:\n        // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n        V.matrixToRotate = function(matrix) {\n            var p = {\n                x: 0,\n                y: 1\n            };\n            if (matrix) p = V.deltaTransformPoint(matrix, p);\n            return {\n                angle: normalizeAngle(toDeg(atan2(p.y, p.x)) - 90)\n            };\n        };\n        // Return the `translate` transformation from the following equation:\n        // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n        V.matrixToTranslate = function(matrix) {\n            return {\n                tx: matrix && matrix.e || 0,\n                ty: matrix && matrix.f || 0\n            };\n        };\n        V.isV = function(object) {\n            return object instanceof V;\n        };\n        // For backwards compatibility:\n        V.isVElement = V.isV;\n        // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n        // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n        V.isSVGGraphicsElement = function(node) {\n            if (!node) return false;\n            node = V.toNode(node);\n            // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n            return node instanceof SVGElement && typeof node.getScreenCTM === \"function\";\n        };\n        var svgDocument = V(\"svg\").node;\n        V.createSVGMatrix = function(matrix) {\n            var svgMatrix = svgDocument.createSVGMatrix();\n            for(var component in matrix)svgMatrix[component] = matrix[component];\n            return svgMatrix;\n        };\n        V.createSVGTransform = function(matrix) {\n            if (!V.isUndefined(matrix)) {\n                if (!(matrix instanceof SVGMatrix)) matrix = V.createSVGMatrix(matrix);\n                return svgDocument.createSVGTransformFromMatrix(matrix);\n            }\n            return svgDocument.createSVGTransform();\n        };\n        V.createSVGPoint = function(x, y) {\n            var p = svgDocument.createSVGPoint();\n            p.x = x;\n            p.y = y;\n            return p;\n        };\n        V.transformRect = function(r, matrix) {\n            var p = svgDocument.createSVGPoint();\n            p.x = r.x;\n            p.y = r.y;\n            var corner1 = p.matrixTransform(matrix);\n            p.x = r.x + r.width;\n            p.y = r.y;\n            var corner2 = p.matrixTransform(matrix);\n            p.x = r.x + r.width;\n            p.y = r.y + r.height;\n            var corner3 = p.matrixTransform(matrix);\n            p.x = r.x;\n            p.y = r.y + r.height;\n            var corner4 = p.matrixTransform(matrix);\n            var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n            var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n            var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n            var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n            return new Rect(minX, minY, maxX - minX, maxY - minY);\n        };\n        V.transformPoint = function(p, matrix) {\n            return new Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n        };\n        V.transformLine = function(l, matrix) {\n            return new Line(V.transformPoint(l.start, matrix), V.transformPoint(l.end, matrix));\n        };\n        V.transformPolyline = function(p, matrix) {\n            var inPoints = p instanceof Polyline ? p.points : p;\n            if (!V.isArray(inPoints)) inPoints = [];\n            var outPoints = [];\n            for(var i = 0, n = inPoints.length; i < n; i++)outPoints[i] = V.transformPoint(inPoints[i], matrix);\n            return new Polyline(outPoints);\n        };\n        // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n        // an object (`{ fill: 'blue', stroke: 'red' }`).\n        V.styleToObject = function(styleString) {\n            var ret = {};\n            var styles = styleString.split(\";\");\n            for(var i = 0; i < styles.length; i++){\n                var style = styles[i];\n                var pair = style.split(\"=\");\n                ret[pair[0].trim()] = pair[1].trim();\n            }\n            return ret;\n        };\n        // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n        V.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {\n            var svgArcMax = 2 * PI - 1e-6;\n            var r0 = innerRadius;\n            var r1 = outerRadius;\n            var a0 = startAngle;\n            var a1 = endAngle;\n            var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n            var df = da < PI ? \"0\" : \"1\";\n            var c0 = cos(a0);\n            var s0 = sin(a0);\n            var c1 = cos(a1);\n            var s1 = sin(a1);\n            return da >= svgArcMax ? r0 ? \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1 + \"M0,\" + r0 + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + -r0 + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + r0 + \"Z\" : \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1 + \"Z\" : r0 ? \"M\" + r1 * c0 + \",\" + r1 * s0 + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1 + \"L\" + r0 * c1 + \",\" + r0 * s1 + \"A\" + r0 + \",\" + r0 + \" 0 \" + df + \",0 \" + r0 * c0 + \",\" + r0 * s0 + \"Z\" : \"M\" + r1 * c0 + \",\" + r1 * s0 + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1 + \"L0,0\" + \"Z\";\n        };\n        // Merge attributes from object `b` with attributes in object `a`.\n        // Note that this modifies the object `a`.\n        // Also important to note that attributes are merged but CSS classes are concatenated.\n        V.mergeAttrs = function(a, b) {\n            for(var attr in b){\n                if (attr === \"class\") // Concatenate classes.\n                a[attr] = a[attr] ? a[attr] + \" \" + b[attr] : b[attr];\n                else if (attr === \"style\") {\n                    // `style` attribute can be an object.\n                    if (V.isObject(a[attr]) && V.isObject(b[attr])) // `style` stored in `a` is an object.\n                    a[attr] = V.mergeAttrs(a[attr], b[attr]);\n                    else if (V.isObject(a[attr])) // `style` in `a` is an object but it's a string in `b`.\n                    // Convert the style represented as a string to an object in `b`.\n                    a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n                    else if (V.isObject(b[attr])) // `style` in `a` is a string, in `b` it's an object.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n                    else // Both styles are strings.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n                } else a[attr] = b[attr];\n            }\n            return a;\n        };\n        V.annotateString = function(t, annotations, opt) {\n            annotations = annotations || [];\n            opt = opt || {};\n            var offset = opt.offset || 0;\n            var compacted = [];\n            var batch;\n            var ret = [];\n            var item;\n            var prev;\n            for(var i = 0; i < t.length; i++){\n                item = ret[i] = t[i];\n                for(var j = 0; j < annotations.length; j++){\n                    var annotation = annotations[j];\n                    var start = annotation.start + offset;\n                    var end = annotation.end + offset;\n                    if (i >= start && i < end) {\n                        // Annotation applies.\n                        if (V.isObject(item)) // There is more than one annotation to be applied => Merge attributes.\n                        item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n                        else item = ret[i] = {\n                            t: t[i],\n                            attrs: annotation.attrs\n                        };\n                        if (opt.includeAnnotationIndices) (item.annotations || (item.annotations = [])).push(j);\n                    }\n                }\n                prev = ret[i - 1];\n                if (!prev) batch = item;\n                else if (V.isObject(item) && V.isObject(prev)) {\n                    // Both previous item and the current one are annotations. If the attributes\n                    // didn't change, merge the text.\n                    if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) batch.t += item.t;\n                    else {\n                        compacted.push(batch);\n                        batch = item;\n                    }\n                } else if (V.isObject(item)) {\n                    // Previous item was a string, current item is an annotation.\n                    compacted.push(batch);\n                    batch = item;\n                } else if (V.isObject(prev)) {\n                    // Previous item was an annotation, current item is a string.\n                    compacted.push(batch);\n                    batch = item;\n                } else // Both previous and current item are strings.\n                batch = (batch || \"\") + item;\n            }\n            if (batch) compacted.push(batch);\n            return compacted;\n        };\n        V.findAnnotationsAtIndex = function(annotations, index) {\n            var found = [];\n            if (annotations) annotations.forEach(function(annotation) {\n                if (annotation.start < index && index <= annotation.end) found.push(annotation);\n            });\n            return found;\n        };\n        V.findAnnotationsBetweenIndexes = function(annotations, start, end) {\n            var found = [];\n            if (annotations) annotations.forEach(function(annotation) {\n                if (start >= annotation.start && start < annotation.end || end > annotation.start && end <= annotation.end || annotation.start >= start && annotation.end < end) found.push(annotation);\n            });\n            return found;\n        };\n        // Shift all the text annotations after character `index` by `offset` positions.\n        V.shiftAnnotations = function(annotations, index, offset) {\n            if (annotations) annotations.forEach(function(annotation) {\n                if (annotation.start < index && annotation.end >= index) annotation.end += offset;\n                else if (annotation.start >= index) {\n                    annotation.start += offset;\n                    annotation.end += offset;\n                }\n            });\n            return annotations;\n        };\n        V.convertLineToPathData = function(line) {\n            line = V(line);\n            var d = [\n                \"M\",\n                line.attr(\"x1\"),\n                line.attr(\"y1\"),\n                \"L\",\n                line.attr(\"x2\"),\n                line.attr(\"y2\")\n            ].join(\" \");\n            return d;\n        };\n        V.convertPolygonToPathData = function(polygon) {\n            var points = V.getPointsFromSvgNode(polygon);\n            if (points.length === 0) return null;\n            return V.svgPointsToPath(points) + \" Z\";\n        };\n        V.convertPolylineToPathData = function(polyline) {\n            var points = V.getPointsFromSvgNode(polyline);\n            if (points.length === 0) return null;\n            return V.svgPointsToPath(points);\n        };\n        V.svgPointsToPath = function(points) {\n            for(var i = 0, n = points.length; i < n; i++)points[i] = points[i].x + \" \" + points[i].y;\n            return \"M \" + points.join(\" L\");\n        };\n        V.getPointsFromSvgNode = function(node) {\n            node = V.toNode(node);\n            var points = [];\n            var nodePoints = node.points;\n            if (nodePoints) for(var i = 0, n = nodePoints.numberOfItems; i < n; i++)points.push(nodePoints.getItem(i));\n            return points;\n        };\n        V.KAPPA = 0.551784;\n        V.convertCircleToPathData = function(circle) {\n            circle = V(circle);\n            var cx = parseFloat(circle.attr(\"cx\")) || 0;\n            var cy = parseFloat(circle.attr(\"cy\")) || 0;\n            var r = parseFloat(circle.attr(\"r\"));\n            var cd = r * V.KAPPA; // Control distance.\n            var d = [\n                \"M\",\n                cx,\n                cy - r,\n                \"C\",\n                cx + cd,\n                cy - r,\n                cx + r,\n                cy - cd,\n                cx + r,\n                cy,\n                \"C\",\n                cx + r,\n                cy + cd,\n                cx + cd,\n                cy + r,\n                cx,\n                cy + r,\n                \"C\",\n                cx - cd,\n                cy + r,\n                cx - r,\n                cy + cd,\n                cx - r,\n                cy,\n                \"C\",\n                cx - r,\n                cy - cd,\n                cx - cd,\n                cy - r,\n                cx,\n                cy - r,\n                \"Z\"\n            ].join(\" \");\n            return d;\n        };\n        V.convertEllipseToPathData = function(ellipse) {\n            ellipse = V(ellipse);\n            var cx = parseFloat(ellipse.attr(\"cx\")) || 0;\n            var cy = parseFloat(ellipse.attr(\"cy\")) || 0;\n            var rx = parseFloat(ellipse.attr(\"rx\"));\n            var ry = parseFloat(ellipse.attr(\"ry\")) || rx;\n            var cdx = rx * V.KAPPA; // Control distance x.\n            var cdy = ry * V.KAPPA; // Control distance y.\n            var d = [\n                \"M\",\n                cx,\n                cy - ry,\n                \"C\",\n                cx + cdx,\n                cy - ry,\n                cx + rx,\n                cy - cdy,\n                cx + rx,\n                cy,\n                \"C\",\n                cx + rx,\n                cy + cdy,\n                cx + cdx,\n                cy + ry,\n                cx,\n                cy + ry,\n                \"C\",\n                cx - cdx,\n                cy + ry,\n                cx - rx,\n                cy + cdy,\n                cx - rx,\n                cy,\n                \"C\",\n                cx - rx,\n                cy - cdy,\n                cx - cdx,\n                cy - ry,\n                cx,\n                cy - ry,\n                \"Z\"\n            ].join(\" \");\n            return d;\n        };\n        V.convertRectToPathData = function(rect) {\n            rect = V(rect);\n            return V.rectToPath({\n                x: parseFloat(rect.attr(\"x\")) || 0,\n                y: parseFloat(rect.attr(\"y\")) || 0,\n                width: parseFloat(rect.attr(\"width\")) || 0,\n                height: parseFloat(rect.attr(\"height\")) || 0,\n                rx: parseFloat(rect.attr(\"rx\")) || 0,\n                ry: parseFloat(rect.attr(\"ry\")) || 0\n            });\n        };\n        // Convert a rectangle to SVG path commands. `r` is an object of the form:\n        // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n        // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n        // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n        // that has only `rx` and `ry` attributes).\n        V.rectToPath = function(r) {\n            var d;\n            var x = r.x;\n            var y = r.y;\n            var width = r.width;\n            var height = r.height;\n            var topRx = min(r.rx || r[\"top-rx\"] || 0, width / 2);\n            var bottomRx = min(r.rx || r[\"bottom-rx\"] || 0, width / 2);\n            var topRy = min(r.ry || r[\"top-ry\"] || 0, height / 2);\n            var bottomRy = min(r.ry || r[\"bottom-ry\"] || 0, height / 2);\n            if (topRx || bottomRx || topRy || bottomRy) d = [\n                \"M\",\n                x,\n                y + topRy,\n                \"v\",\n                height - topRy - bottomRy,\n                \"a\",\n                bottomRx,\n                bottomRy,\n                0,\n                0,\n                0,\n                bottomRx,\n                bottomRy,\n                \"h\",\n                width - 2 * bottomRx,\n                \"a\",\n                bottomRx,\n                bottomRy,\n                0,\n                0,\n                0,\n                bottomRx,\n                -bottomRy,\n                \"v\",\n                -(height - bottomRy - topRy),\n                \"a\",\n                topRx,\n                topRy,\n                0,\n                0,\n                0,\n                -topRx,\n                -topRy,\n                \"h\",\n                -(width - 2 * topRx),\n                \"a\",\n                topRx,\n                topRy,\n                0,\n                0,\n                0,\n                -topRx,\n                topRy,\n                \"Z\"\n            ];\n            else d = [\n                \"M\",\n                x,\n                y,\n                \"H\",\n                x + width,\n                \"V\",\n                y + height,\n                \"H\",\n                x,\n                \"V\",\n                y,\n                \"Z\"\n            ];\n            return d.join(\" \");\n        };\n        // Take a path data string\n        // Return a normalized path data string\n        // If data cannot be parsed, return 'M 0 0'\n        // Adapted from Rappid normalizePath polyfill\n        // Highly inspired by Raphael Library (www.raphael.com)\n        V.normalizePathData = function() {\n            var spaces = \"\t\\n\\v\\f\\r \\xa0\\u2028\\u2029\";\n            var pathCommand = new RegExp(\"([a-z])[\" + spaces + \",]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[\" + spaces + \"]*,?[\" + spaces + \"]*)+)\", \"ig\");\n            var pathValues = new RegExp(\"(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[\" + spaces + \"]*,?[\" + spaces + \"]*\", \"ig\");\n            var math = Math;\n            var PI = math.PI;\n            var sin = math.sin;\n            var cos = math.cos;\n            var tan = math.tan;\n            var asin = math.asin;\n            var sqrt = math.sqrt;\n            var abs = math.abs;\n            function q2c(x1, y1, ax, ay, x2, y2) {\n                var _13 = 1 / 3;\n                var _23 = 2 / 3;\n                return [\n                    _13 * x1 + _23 * ax,\n                    _13 * y1 + _23 * ay,\n                    _13 * x2 + _23 * ax,\n                    _13 * y2 + _23 * ay,\n                    x2,\n                    y2\n                ];\n            }\n            function rotate(x, y, rad) {\n                var X = x * cos(rad) - y * sin(rad);\n                var Y = x * sin(rad) + y * cos(rad);\n                return {\n                    x: X,\n                    y: Y\n                };\n            }\n            function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n                // for more information of where this math came from visit:\n                // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n                var _120 = PI * 120 / 180;\n                var rad = PI / 180 * (+angle || 0);\n                var res = [];\n                var xy;\n                if (!recursive) {\n                    xy = rotate(x1, y1, -rad);\n                    x1 = xy.x;\n                    y1 = xy.y;\n                    xy = rotate(x2, y2, -rad);\n                    x2 = xy.x;\n                    y2 = xy.y;\n                    var x = (x1 - x2) / 2;\n                    var y = (y1 - y2) / 2;\n                    var h = x * x / (rx * rx) + y * y / (ry * ry);\n                    if (h > 1) {\n                        h = sqrt(h);\n                        rx = h * rx;\n                        ry = h * ry;\n                    }\n                    var rx2 = rx * rx;\n                    var ry2 = ry * ry;\n                    var k = (large_arc_flag == sweep_flag ? -1 : 1) * sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n                    var cx = k * rx * y / ry + (x1 + x2) / 2;\n                    var cy = k * -ry * x / rx + (y1 + y2) / 2;\n                    var f1 = asin(((y1 - cy) / ry).toFixed(9));\n                    var f2 = asin(((y2 - cy) / ry).toFixed(9));\n                    f1 = x1 < cx ? PI - f1 : f1;\n                    f2 = x2 < cx ? PI - f2 : f2;\n                    if (f1 < 0) f1 = PI * 2 + f1;\n                    if (f2 < 0) f2 = PI * 2 + f2;\n                    if (sweep_flag && f1 > f2) f1 = f1 - PI * 2;\n                    if (!sweep_flag && f2 > f1) f2 = f2 - PI * 2;\n                } else {\n                    f1 = recursive[0];\n                    f2 = recursive[1];\n                    cx = recursive[2];\n                    cy = recursive[3];\n                }\n                var df = f2 - f1;\n                if (abs(df) > _120) {\n                    var f2old = f2;\n                    var x2old = x2;\n                    var y2old = y2;\n                    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n                    x2 = cx + rx * cos(f2);\n                    y2 = cy + ry * sin(f2);\n                    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [\n                        f2,\n                        f2old,\n                        cx,\n                        cy\n                    ]);\n                }\n                df = f2 - f1;\n                var c1 = cos(f1);\n                var s1 = sin(f1);\n                var c2 = cos(f2);\n                var s2 = sin(f2);\n                var t = tan(df / 4);\n                var hx = 4 / 3 * (rx * t);\n                var hy = 4 / 3 * (ry * t);\n                var m1 = [\n                    x1,\n                    y1\n                ];\n                var m2 = [\n                    x1 + hx * s1,\n                    y1 - hy * c1\n                ];\n                var m3 = [\n                    x2 + hx * s2,\n                    y2 - hy * c2\n                ];\n                var m4 = [\n                    x2,\n                    y2\n                ];\n                m2[0] = 2 * m1[0] - m2[0];\n                m2[1] = 2 * m1[1] - m2[1];\n                if (recursive) return [\n                    m2,\n                    m3,\n                    m4\n                ].concat(res);\n                else {\n                    res = [\n                        m2,\n                        m3,\n                        m4\n                    ].concat(res).join().split(\",\");\n                    var newres = [];\n                    var ii = res.length;\n                    for(var i = 0; i < ii; i++)newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n                    return newres;\n                }\n            }\n            function parsePathString(pathString) {\n                if (!pathString) return null;\n                var paramCounts = {\n                    a: 7,\n                    c: 6,\n                    h: 1,\n                    l: 2,\n                    m: 2,\n                    q: 4,\n                    s: 4,\n                    t: 2,\n                    v: 1,\n                    z: 0\n                };\n                var data = [];\n                String(pathString).replace(pathCommand, function(a, b, c) {\n                    var params = [];\n                    var name = b.toLowerCase();\n                    c.replace(pathValues, function(a, b) {\n                        if (b) params.push(+b);\n                    });\n                    if (name === \"m\" && params.length > 2) {\n                        data.push([\n                            b\n                        ].concat(params.splice(0, 2)));\n                        name = \"l\";\n                        b = b === \"m\" ? \"l\" : \"L\";\n                    }\n                    while(params.length >= paramCounts[name]){\n                        data.push([\n                            b\n                        ].concat(params.splice(0, paramCounts[name])));\n                        if (!paramCounts[name]) break;\n                    }\n                });\n                return data;\n            }\n            function pathToAbsolute(pathArray) {\n                if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) pathArray = parsePathString(pathArray);\n                // if invalid string, return 'M 0 0'\n                if (!pathArray || !pathArray.length) return [\n                    [\n                        \"M\",\n                        0,\n                        0\n                    ]\n                ];\n                var res = [];\n                var x = 0;\n                var y = 0;\n                var mx = 0;\n                var my = 0;\n                var start = 0;\n                var pa0;\n                var ii = pathArray.length;\n                for(var i = start; i < ii; i++){\n                    var r = [];\n                    res.push(r);\n                    var pa = pathArray[i];\n                    pa0 = pa[0];\n                    if (pa0 != pa0.toUpperCase()) {\n                        r[0] = pa0.toUpperCase();\n                        var jj;\n                        var j;\n                        switch(r[0]){\n                            case \"A\":\n                                r[1] = pa[1];\n                                r[2] = pa[2];\n                                r[3] = pa[3];\n                                r[4] = pa[4];\n                                r[5] = pa[5];\n                                r[6] = +pa[6] + x;\n                                r[7] = +pa[7] + y;\n                                break;\n                            case \"V\":\n                                r[1] = +pa[1] + y;\n                                break;\n                            case \"H\":\n                                r[1] = +pa[1] + x;\n                                break;\n                            case \"M\":\n                                mx = +pa[1] + x;\n                                my = +pa[2] + y;\n                                jj = pa.length;\n                                for(j = 1; j < jj; j++)r[j] = +pa[j] + (j % 2 ? x : y);\n                                break;\n                            default:\n                                jj = pa.length;\n                                for(j = 1; j < jj; j++)r[j] = +pa[j] + (j % 2 ? x : y);\n                                break;\n                        }\n                    } else {\n                        var kk = pa.length;\n                        for(var k = 0; k < kk; k++)r[k] = pa[k];\n                    }\n                    switch(r[0]){\n                        case \"Z\":\n                            x = +mx;\n                            y = +my;\n                            break;\n                        case \"H\":\n                            x = r[1];\n                            break;\n                        case \"V\":\n                            y = r[1];\n                            break;\n                        case \"M\":\n                            mx = r[r.length - 2];\n                            my = r[r.length - 1];\n                            x = r[r.length - 2];\n                            y = r[r.length - 1];\n                            break;\n                        default:\n                            x = r[r.length - 2];\n                            y = r[r.length - 1];\n                            break;\n                    }\n                }\n                return res;\n            }\n            function normalize(path) {\n                var p = pathToAbsolute(path);\n                var attrs = {\n                    x: 0,\n                    y: 0,\n                    bx: 0,\n                    by: 0,\n                    X: 0,\n                    Y: 0,\n                    qx: null,\n                    qy: null\n                };\n                function processPath(path, d, pcom) {\n                    var nx, ny;\n                    if (!path) return [\n                        \"C\",\n                        d.x,\n                        d.y,\n                        d.x,\n                        d.y,\n                        d.x,\n                        d.y\n                    ];\n                    if (!(path[0] in {\n                        T: 1,\n                        Q: 1\n                    })) {\n                        d.qx = null;\n                        d.qy = null;\n                    }\n                    switch(path[0]){\n                        case \"M\":\n                            d.X = path[1];\n                            d.Y = path[2];\n                            break;\n                        case \"A\":\n                            if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n                            // \"If either rx or ry is 0, then this arc is treated as a\n                            // straight line segment (a \"lineto\") joining the endpoints.\"\n                            path = [\n                                \"L\",\n                                path[6],\n                                path[7]\n                            ];\n                            else path = [\n                                \"C\"\n                            ].concat(a2c.apply(0, [\n                                d.x,\n                                d.y\n                            ].concat(path.slice(1))));\n                            break;\n                        case \"S\":\n                            if (pcom === \"C\" || pcom === \"S\") {\n                                nx = d.x * 2 - d.bx; // And reflect the previous\n                                ny = d.y * 2 - d.by; // command's control point relative to the current point.\n                            } else {\n                                nx = d.x;\n                                ny = d.y;\n                            }\n                            path = [\n                                \"C\",\n                                nx,\n                                ny\n                            ].concat(path.slice(1));\n                            break;\n                        case \"T\":\n                            if (pcom === \"Q\" || pcom === \"T\") {\n                                d.qx = d.x * 2 - d.qx; // And make a reflection similar\n                                d.qy = d.y * 2 - d.qy; // to case 'S'.\n                            } else {\n                                d.qx = d.x;\n                                d.qy = d.y;\n                            }\n                            path = [\n                                \"C\"\n                            ].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                            break;\n                        case \"Q\":\n                            d.qx = path[1];\n                            d.qy = path[2];\n                            path = [\n                                \"C\"\n                            ].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                            break;\n                        case \"H\":\n                            path = [\n                                \"L\"\n                            ].concat(path[1], d.y);\n                            break;\n                        case \"V\":\n                            path = [\n                                \"L\"\n                            ].concat(d.x, path[1]);\n                            break;\n                        case \"L\":\n                            break;\n                        case \"Z\":\n                            break;\n                    }\n                    return path;\n                }\n                function fixArc(pp, i) {\n                    if (pp[i].length > 7) {\n                        pp[i].shift();\n                        var pi = pp[i];\n                        while(pi.length){\n                            pcoms[i] = \"A\"; // if created multiple 'C's, their original seg is saved\n                            pp.splice(i++, 0, [\n                                \"C\"\n                            ].concat(pi.splice(0, 6)));\n                        }\n                        pp.splice(i, 1);\n                        ii = p.length;\n                    }\n                }\n                var pcoms = []; // path commands of original path p\n                var pfirst = \"\"; // temporary holder for original path command\n                var pcom = \"\"; // holder for previous path command of original path\n                var ii = p.length;\n                for(var i = 0; i < ii; i++){\n                    if (p[i]) pfirst = p[i][0];\n                     // save current path command\n                    if (pfirst !== \"C\") {\n                        pcoms[i] = pfirst; // Save current path command\n                        if (i > 0) pcom = pcoms[i - 1];\n                         // Get previous path command pcom\n                    }\n                    p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n                    if (pcoms[i] !== \"A\" && pfirst === \"C\") pcoms[i] = \"C\";\n                     // 'A' is the only command\n                    // which may produce multiple 'C's\n                    // so we have to make sure that 'C' is also 'C' in original path\n                    fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n                    var seg = p[i];\n                    var seglen = seg.length;\n                    attrs.x = seg[seglen - 2];\n                    attrs.y = seg[seglen - 1];\n                    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n                    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n                }\n                // make sure normalized path data string starts with an M segment\n                if (!p[0][0] || p[0][0] !== \"M\") p.unshift([\n                    \"M\",\n                    0,\n                    0\n                ]);\n                return p;\n            }\n            return function(pathData) {\n                return normalize(pathData).join(\",\").split(\",\").join(\" \");\n            };\n        }();\n        V.namespace = ns;\n        V.g = g;\n        return V;\n    }();\n    var config = {\n        // When set to `true` the cell selectors could be defined as CSS selectors.\n        // If not, only JSON Markup selectors are taken into account.\n        // export let useCSSSelectors = true;\n        useCSSSelectors: true,\n        // The class name prefix config is for advanced use only.\n        // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.\n        // export let classNamePrefix = 'joint-';\n        // export let defaultTheme = 'default';\n        classNamePrefix: \"joint-\",\n        defaultTheme: \"default\",\n        // The maximum delay required for two consecutive touchend events to be interpreted\n        // as a double-tap.\n        doubleTapInterval: 300\n    };\n    // code is inspired by https://github.com/lodash/lodash\n    /* eslint-disable no-case-declarations */ // -- helper constants\n    var argsTag = \"[object Arguments]\";\n    var arrayTag = \"[object Array]\";\n    var boolTag = \"[object Boolean]\";\n    var dateTag = \"[object Date]\";\n    var errorTag = \"[object Error]\";\n    var funcTag = \"[object Function]\";\n    var mapTag = \"[object Map]\";\n    var numberTag = \"[object Number]\";\n    var nullTag = \"[object Null]\";\n    var objectTag = \"[object Object]\";\n    var regexpTag = \"[object RegExp]\";\n    var setTag = \"[object Set]\";\n    var stringTag = \"[object String]\";\n    var symbolTag = \"[object Symbol]\";\n    var undefinedTag = \"[object Undefined]\";\n    var weakMapTag = \"[object WeakMap]\";\n    var arrayBufferTag = \"[object ArrayBuffer]\";\n    var dataViewTag = \"[object DataView]\";\n    var float32Tag = \"[object Float32Array]\";\n    var float64Tag = \"[object Float64Array]\";\n    var int8Tag = \"[object Int8Array]\";\n    var int16Tag = \"[object Int16Array]\";\n    var int32Tag = \"[object Int32Array]\";\n    var uint8Tag = \"[object Uint8Array]\";\n    var uint8ClampedTag = \"[object Uint8ClampedArray]\";\n    var uint16Tag = \"[object Uint16Array]\";\n    var uint32Tag = \"[object Uint32Array]\";\n    var CLONEABLE_TAGS = {};\n    CLONEABLE_TAGS[argsTag] = true;\n    CLONEABLE_TAGS[arrayTag] = true;\n    CLONEABLE_TAGS[arrayBufferTag] = true;\n    CLONEABLE_TAGS[dataViewTag] = true;\n    CLONEABLE_TAGS[boolTag] = true;\n    CLONEABLE_TAGS[dateTag] = true;\n    CLONEABLE_TAGS[float32Tag] = true;\n    CLONEABLE_TAGS[float64Tag] = true;\n    CLONEABLE_TAGS[int8Tag] = true;\n    CLONEABLE_TAGS[int16Tag] = true;\n    CLONEABLE_TAGS[int32Tag] = true;\n    CLONEABLE_TAGS[mapTag] = true;\n    CLONEABLE_TAGS[numberTag] = true;\n    CLONEABLE_TAGS[objectTag] = true;\n    CLONEABLE_TAGS[regexpTag] = true;\n    CLONEABLE_TAGS[setTag] = true;\n    CLONEABLE_TAGS[stringTag] = true;\n    CLONEABLE_TAGS[symbolTag] = true;\n    CLONEABLE_TAGS[uint8Tag] = true;\n    CLONEABLE_TAGS[uint8ClampedTag] = true;\n    CLONEABLE_TAGS[uint16Tag] = true;\n    CLONEABLE_TAGS[uint32Tag] = true;\n    CLONEABLE_TAGS[errorTag] = false;\n    CLONEABLE_TAGS[funcTag] = false;\n    CLONEABLE_TAGS[weakMapTag] = false;\n    /** Used to compose unicode character classes. */ var rsAstralRange = \"\\ud800-\\udfff\";\n    var rsComboMarksRange = \"\\\\u0300-\\\\u036f\";\n    var reComboHalfMarksRange = \"\\\\ufe20-\\\\ufe2f\";\n    var rsComboSymbolsRange = \"\\\\u20d0-\\\\u20ff\";\n    var rsComboMarksExtendedRange = \"\\\\u1ab0-\\\\u1aff\";\n    var rsComboMarksSupplementRange = \"\\\\u1dc0-\\\\u1dff\";\n    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;\n    var rsDingbatRange = \"\\\\u2700-\\\\u27bf\";\n    var rsLowerRange = \"a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff\";\n    var rsMathOpRange = \"\\\\xac\\\\xb1\\\\xd7\\\\xf7\";\n    var rsNonCharRange = \"\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\";\n    var rsPunctuationRange = \"\\\\u2000-\\\\u206f\";\n    var rsSpaceRange = \" \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\";\n    var rsUpperRange = \"A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde\";\n    var rsVarRange = \"\\\\ufe0e\\\\ufe0f\";\n    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n    /** Used to compose unicode capture groups. */ var rsApos = \"[']\";\n    var rsBreak = \"[\" + rsBreakRange + \"]\";\n    var rsCombo = \"[\" + rsComboRange + \"]\";\n    var rsDigit = \"\\\\d\";\n    var rsDingbat = \"[\" + rsDingbatRange + \"]\";\n    var rsLower = \"[\" + rsLowerRange + \"]\";\n    var rsMisc = \"[^\" + rsAstralRange + (rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange) + \"]\";\n    var rsFitz = \"\\ud83c[\\udffb-\\udfff]\";\n    var rsModifier = \"(?:\" + rsCombo + \"|\" + rsFitz + \")\";\n    var rsNonAstral = \"[^\" + rsAstralRange + \"]\";\n    var rsRegional = \"(?:\\ud83c[\\udde6-\\uddff]){2}\";\n    var rsSurrPair = \"[\\ud800-\\udbff][\\udc00-\\udfff]\";\n    var rsUpper = \"[\" + rsUpperRange + \"]\";\n    var rsZWJ = \"\\\\u200d\";\n    /** Used to compose unicode regexes. */ var rsMiscLower = \"(?:\" + rsLower + \"|\" + rsMisc + \")\";\n    var rsMiscUpper = \"(?:\" + rsUpper + \"|\" + rsMisc + \")\";\n    var rsOptContrLower = \"(?:\" + rsApos + \"(?:d|ll|m|re|s|t|ve))?\";\n    var rsOptContrUpper = \"(?:\" + rsApos + \"(?:D|LL|M|RE|S|T|VE))?\";\n    var reOptMod = rsModifier + \"?\";\n    var rsOptVar = \"[\" + rsVarRange + \"]?\";\n    var rsOptJoin = \"(?:\" + rsZWJ + \"(?:\" + [\n        rsNonAstral,\n        rsRegional,\n        rsSurrPair\n    ].join(\"|\") + \")\" + (rsOptVar + reOptMod) + \")*\";\n    var rsOrdLower = \"\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])\";\n    var rsOrdUpper = \"\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])\";\n    var rsSeq = rsOptVar + reOptMod + rsOptJoin;\n    var rsEmoji = \"(?:\" + [\n        rsDingbat,\n        rsRegional,\n        rsSurrPair\n    ].join(\"|\") + \")\" + rsSeq;\n    var reUnicodeWords = RegExp([\n        rsUpper + \"?\" + rsLower + \"+\" + rsOptContrLower + \"(?=\" + [\n            rsBreak,\n            rsUpper,\n            \"$\"\n        ].join(\"|\") + \")\",\n        rsMiscUpper + \"+\" + rsOptContrUpper + \"(?=\" + [\n            rsBreak,\n            rsUpper + rsMiscLower,\n            \"$\"\n        ].join(\"|\") + \")\",\n        rsUpper + \"?\" + rsMiscLower + \"+\" + rsOptContrLower,\n        rsUpper + \"+\" + rsOptContrUpper,\n        rsOrdUpper,\n        rsOrdLower,\n        rsDigit + \"+\",\n        rsEmoji\n    ].join(\"|\"), \"g\");\n    var LARGE_ARRAY_SIZE = 200;\n    var HASH_UNDEFINED = \"__hash_undefined__\";\n    // Used to match `toStringTag` values of typed arrays\n    var reTypedTag = /^\\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\\]$/;\n    // Used to compose unicode capture groups\n    var rsAstral = \"[\" + rsAstralRange + \"]\";\n    // Used to compose unicode regexes\n    var rsNonAstralCombo = \"\" + rsNonAstral + rsCombo + \"?\";\n    var rsSymbol = \"(?:\" + [\n        rsNonAstralCombo,\n        rsCombo,\n        rsRegional,\n        rsSurrPair,\n        rsAstral\n    ].join(\"|\") + \")\";\n    // Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode)\n    var reUnicode = RegExp(rsFitz + \"(?=\" + rsFitz + \")|\" + (rsSymbol + rsSeq), \"g\");\n    var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\n    var reIsPlainProp = /^\\w*$/;\n    var charCodeOfDot = \".\".charCodeAt(0);\n    var reEscapeChar = /\\\\(\\\\)?/g;\n    var rePropName = RegExp(// Match anything that isn't a dot or bracket.\n    \"[^.[\\\\]]+|\\\\[(?:([^\\\"'][^[]*)|([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2)\\\\]|(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))\", \"g\");\n    var reIsUint = /^(?:0|[1-9]\\d*)$/;\n    var hasUnicodeWord = RegExp.prototype.test.bind(/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/);\n    var MAX_ARRAY_INDEX = 4294967294;\n    /** Used to match words composed of alphanumeric characters. */ // eslint-disable-next-line no-control-regex\n    var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n    // -- helper functions\n    var hasUnicode = function(string) {\n        return reUnicode.test(string);\n    };\n    var unicodeToArray = function(string) {\n        return string.match(reUnicode) || [];\n    };\n    var asciiToArray = function(string) {\n        return string.split(\"\");\n    };\n    var stringToArray = function(string) {\n        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n    };\n    var values = function(object) {\n        if (object == null) return [];\n        return keys$1(object).map(function(key) {\n            return object[key];\n        });\n    };\n    var keys$1 = function(object) {\n        return isArrayLike(object) ? arrayLikeKeys(object) : Object.keys(Object(object));\n    };\n    var baseKeys = function(object) {\n        if (!isPrototype(object)) return Object.keys(object);\n        var result = [];\n        for(var key in Object(object))if (hasOwnProperty.call(object, key) && key != \"constructor\") result.push(key);\n        return result;\n    };\n    var arrayLikeKeys = function(value, inherited) {\n        var isArr = Array.isArray(value);\n        var isArg = !isArr && isObjectLike(value) && getTag(value) === argsTag;\n        var isType = !isArr && !isArg && isTypedArray(value);\n        var skipIndexes = isArr || isArg || isType;\n        var length = value.length;\n        var result = new Array(skipIndexes ? length : 0);\n        var index = skipIndexes ? -1 : length;\n        while(++index < length)result[index] = \"\" + index;\n        for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n        (key === \"length\" || // Skip index properties.\n        isIndex(key, length)))) result.push(key);\n        return result;\n    };\n    var assocIndexOf = function(array, key) {\n        var length = array.length;\n        while(length--){\n            if (eq(array[length][0], key)) return length;\n        }\n        return -1;\n    };\n    var eq = function(value, other) {\n        return value === other || value !== value && other !== other;\n    };\n    var isObjectLike = function(value) {\n        return value != null && typeof value == \"object\";\n    };\n    var isIterateeCall = function(value, index, object) {\n        if (!isObject$1(object)) return false;\n        var type = typeof index;\n        var isPossibleIteratee = type == \"number\" ? isArrayLike(object) && index > -1 && index < object.length : type == \"string\" && index in object;\n        if (isPossibleIteratee) return eq(object[index], value);\n        return false;\n    };\n    var isSet = function(value) {\n        return isObjectLike(value) && getTag(value) == setTag;\n    };\n    var isMap = function(value) {\n        return isObjectLike(value) && getTag(value) == mapTag;\n    };\n    var isPrototype = function(value) {\n        var Ctor = value && value.constructor;\n        var proto = typeof Ctor === \"function\" && Ctor.prototype || Object.prototype;\n        return value === proto;\n    };\n    var assignValue = function(object, key, value) {\n        var objValue = object[key];\n        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) object[key] = value;\n    };\n    var copyObject = function(source, props, object) {\n        var index = -1;\n        var length = props.length;\n        while(++index < length){\n            var key = props[index];\n            assignValue(object, key, source[key]);\n        }\n        return object;\n    };\n    var isArrayLike = function(value) {\n        return value != null && typeof value !== \"function\" && typeof value.length === \"number\" && value.length > -1 && value.length % 1 === 0;\n    };\n    var isSymbol = function(value) {\n        return typeof value == \"symbol\" || isObjectLike(value) && getTag(value) === symbolTag;\n    };\n    var initCloneArray = function(array) {\n        var length = array.length;\n        var result = new array.constructor(length);\n        if (length && typeof array[0] == \"string\" && hasOwnProperty.call(array, \"index\")) {\n            result.index = array.index;\n            result.input = array.input;\n        }\n        return result;\n    };\n    var copyArray = function(source, array) {\n        var index = -1;\n        var length = source.length;\n        array || (array = new Array(length));\n        while(++index < length)array[index] = source[index];\n        return array;\n    };\n    var getTag = function(value) {\n        if (value == null) return value === undefined ? undefinedTag : nullTag;\n        return Object.prototype.toString.call(value);\n    };\n    var cloneArrayBuffer = function(arrayBuffer) {\n        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n        new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n        return result;\n    };\n    var cloneTypedArray = function(typedArray, isDeep) {\n        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    };\n    var cloneRegExp = function(regexp) {\n        var result = new regexp.constructor(regexp.source, /\\w*$/.exec(regexp));\n        result.lastIndex = regexp.lastIndex;\n        return result;\n    };\n    var initCloneObject = function(object) {\n        return typeof object.constructor == \"function\" && !isPrototype(object) ? Object.create(Object.getPrototypeOf(object)) : {};\n    };\n    var getSymbols = function(object) {\n        if (object == null) return [];\n        object = Object(object);\n        var symbols = Object.getOwnPropertySymbols(object);\n        return symbols.filter(function(symbol) {\n            return propertyIsEnumerable.call(object, symbol);\n        });\n    };\n    var copySymbols = function(source, object) {\n        return copyObject(source, getSymbols(source), object);\n    };\n    function cloneDataView(dataView, isDeep) {\n        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n    var initCloneByTag = function(object, tag, isDeep) {\n        var Constructor = object.constructor;\n        switch(tag){\n            case arrayBufferTag:\n                return cloneArrayBuffer(object, isDeep);\n            case boolTag:\n            case dateTag:\n                return new Constructor(+object);\n            case dataViewTag:\n                return cloneDataView(object, isDeep);\n            case float32Tag:\n            case float64Tag:\n            case int8Tag:\n            case int16Tag:\n            case int32Tag:\n            case uint8Tag:\n            case uint8ClampedTag:\n            case uint16Tag:\n            case uint32Tag:\n                return cloneTypedArray(object, isDeep);\n            case mapTag:\n                return new Constructor(object);\n            case numberTag:\n            case stringTag:\n                return new Constructor(object);\n            case regexpTag:\n                return cloneRegExp(object);\n            case setTag:\n                return new Constructor;\n            case symbolTag:\n                return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(object)) : {};\n        }\n    };\n    var isTypedArray = function(value) {\n        return isObjectLike(value) && reTypedTag.test(getTag(value));\n    };\n    var getAllKeys = function(object) {\n        var result = Object.keys(object);\n        if (!Array.isArray(object) && object != null) result.push.apply(result, getSymbols(Object(object)));\n        return result;\n    };\n    var getSymbolsIn = function(object) {\n        var result = [];\n        while(object){\n            result.push.apply(result, getSymbols(object));\n            object = Object.getPrototypeOf(Object(object));\n        }\n        return result;\n    };\n    var getAllKeysIn = function(object) {\n        var result = [];\n        for(var key in object)result.push(key);\n        if (!Array.isArray(object)) result.push.apply(result, getSymbolsIn(object));\n        return result;\n    };\n    var getMapData = function(ref, key) {\n        var __data__ = ref.__data__;\n        var data = __data__;\n        return isKeyable(key) ? data[typeof key === \"string\" ? \"string\" : \"hash\"] : data.map;\n    };\n    var equalObjects = function(object, other, equalFunc, stack) {\n        var objProps = getAllKeys(object);\n        var objLength = objProps.length;\n        var othProps = getAllKeys(other);\n        var othLength = othProps.length;\n        if (objLength != othLength) return false;\n        var key;\n        var index = objLength;\n        while(index--){\n            key = objProps[index];\n            if (!hasOwnProperty.call(other, key)) return false;\n        }\n        var objStacked = stack.get(object);\n        var othStacked = stack.get(other);\n        if (objStacked && othStacked) return objStacked == other && othStacked == object;\n        var result = true;\n        stack.set(object, other);\n        stack.set(other, object);\n        var compared;\n        var skipCtor;\n        while(++index < objLength){\n            key = objProps[index];\n            var objValue = object[key];\n            var othValue = other[key];\n            if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, stack) : compared)) {\n                result = false;\n                break;\n            }\n            skipCtor || (skipCtor = key == \"constructor\");\n        }\n        if (result && !skipCtor) {\n            var objCtor = object.constructor;\n            var othCtor = other.constructor;\n            if (objCtor != othCtor && \"constructor\" in object && \"constructor\" in other && !(typeof objCtor === \"function\" && objCtor instanceof objCtor && typeof othCtor === \"function\" && othCtor instanceof othCtor)) result = false;\n        }\n        stack[\"delete\"](object);\n        stack[\"delete\"](other);\n        return result;\n    };\n    var baseIsEqual = function(value, other, stack) {\n        if (value === other) return true;\n        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) return value !== value && other !== other;\n        return baseIsEqualDeep(value, other, baseIsEqual, stack);\n    };\n    var baseIsEqualDeep = function(object, other, equalFunc, stack) {\n        var objIsArr = Array.isArray(object);\n        var othIsArr = Array.isArray(other);\n        var objTag = objIsArr ? arrayTag : getTag(object);\n        var othTag = othIsArr ? arrayTag : getTag(other);\n        objTag = objTag == argsTag ? objectTag : objTag;\n        othTag = othTag == argsTag ? objectTag : othTag;\n        var objIsObj = objTag == objectTag;\n        var othIsObj = othTag == objectTag;\n        var isSameTag = objTag == othTag;\n        if (isSameTag && !objIsObj) {\n            stack || (stack = new Stack);\n            return objIsArr || isTypedArray(object) ? equalArrays(object, other, false, equalFunc, stack) : equalByTag(object, other, objTag, equalFunc, stack);\n        }\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, \"__wrapped__\");\n        var othIsWrapped = othIsObj && hasOwnProperty.call(other, \"__wrapped__\");\n        if (objIsWrapped || othIsWrapped) {\n            var objUnwrapped = objIsWrapped ? object.value() : object;\n            var othUnwrapped = othIsWrapped ? other.value() : other;\n            stack || (stack = new Stack);\n            return equalFunc(objUnwrapped, othUnwrapped, stack);\n        }\n        if (!isSameTag) return false;\n        stack || (stack = new Stack);\n        return equalObjects(object, other, equalFunc, stack);\n    };\n    var equalArrays = function(array, other, compareUnordered, equalFunc, stack) {\n        var isPartial = false;\n        var arrLength = array.length;\n        var othLength = other.length;\n        if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;\n        // Assume cyclic values are equal.\n        var arrStacked = stack.get(array);\n        var othStacked = stack.get(other);\n        if (arrStacked && othStacked) return arrStacked == other && othStacked == array;\n        var index = -1;\n        var result = true;\n        var seen = compareUnordered ? new SetCache : undefined;\n        stack.set(array, other);\n        stack.set(other, array);\n        var loop = function() {\n            var compared = void 0;\n            var arrValue = array[index];\n            var othValue = other[index];\n            if (compared !== undefined) {\n                if (compared) return;\n                result = false;\n                return \"break\";\n            }\n            if (seen) {\n                if (!some(other, function(othValue, othIndex) {\n                    if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, stack))) return seen.push(othIndex);\n                })) {\n                    result = false;\n                    return \"break\";\n                }\n            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, stack))) {\n                result = false;\n                return \"break\";\n            }\n        };\n        while(++index < arrLength){\n            var returned = loop();\n            if (returned === \"break\") break;\n        }\n        stack[\"delete\"](array);\n        stack[\"delete\"](other);\n        return result;\n    };\n    var some = function(array, predicate) {\n        var index = -1;\n        var length = array == null ? 0 : array.length;\n        while(++index < length){\n            if (predicate(array[index], index, array)) return true;\n        }\n        return false;\n    };\n    var cacheHas = function(cache, key) {\n        return cache.has(key);\n    };\n    var compareArrayBufferTag = function(object, other, equalFunc, stack) {\n        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other), stack)) return false;\n        return true;\n    };\n    var equalByTag = function(object, other, tag, equalFunc, stack) {\n        switch(tag){\n            case dataViewTag:\n                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;\n                object = object.buffer;\n                other = other.buffer;\n                return compareArrayBufferTag(object, other, equalFunc, stack);\n            case arrayBufferTag:\n                return compareArrayBufferTag(object, other, equalFunc, stack);\n            case boolTag:\n            case dateTag:\n            case numberTag:\n                return eq(+object, +other);\n            case errorTag:\n                return object.name == other.name && object.message == other.message;\n            case regexpTag:\n            case stringTag:\n                return object == \"\" + other;\n            case mapTag:\n                var convert = mapToArray;\n            // Intentional fallthrough\n            // eslint-disable-next-line no-fallthrough\n            case setTag:\n                convert || (convert = setToArray);\n                if (object.size != other.size) return false;\n                // Assume cyclic values are equal.\n                var stacked = stack.get(object);\n                if (stacked) return stacked == other;\n                // Recursively compare objects (susceptible to call stack limits).\n                stack.set(object, other);\n                var result = equalArrays(convert(object), convert(other), true, equalFunc, stack);\n                stack[\"delete\"](object);\n                return result;\n            case symbolTag:\n                return Symbol.prototype.valueOf.call(object) == Symbol.prototype.valueOf.call(other);\n        }\n        return false;\n    };\n    var mapToArray = function(map) {\n        var index = -1;\n        var result = Array(map.size);\n        map.forEach(function(value, key) {\n            result[++index] = [\n                key,\n                value\n            ];\n        });\n        return result;\n    };\n    var setToArray = function(set) {\n        var index = -1;\n        var result = new Array(set.size);\n        set.forEach(function(value) {\n            result[++index] = value;\n        });\n        return result;\n    };\n    var isKey = function(value, object) {\n        if (Array.isArray(value)) return false;\n        var type = typeof value;\n        if (type === \"number\" || type === \"boolean\" || value == null || isSymbol(value)) return true;\n        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n    };\n    var stringToPath = function(string) {\n        var result = [];\n        if (string.charCodeAt(0) === charCodeOfDot) result.push(\"\");\n        string.replace(rePropName, function(match, expression, quote, subString) {\n            var key = match;\n            if (quote) key = subString.replace(reEscapeChar, \"$1\");\n            else if (expression) key = expression.trim();\n            result.push(key);\n        });\n        return result;\n    };\n    var castPath = function(path, object) {\n        if (Array.isArray(path)) return path;\n        return isKey(path, object) ? [\n            path\n        ] : stringToPath(\"\" + path);\n    };\n    var get$1 = function(object, path) {\n        path = castPath(path, object);\n        var index = 0;\n        var length = path.length;\n        while(object != null && index < length){\n            object = object[toKey(path[index])];\n            index++;\n        }\n        return index && index == length ? object : undefined;\n    };\n    function compareAscending(value, other) {\n        if (value !== other) {\n            var valIsDefined = value !== undefined;\n            var valIsNull = value === null;\n            var valIsReflexive = value === value;\n            var valIsSymbol = isSymbol(value);\n            var othIsDefined = other !== undefined;\n            var othIsNull = other === null;\n            var othIsReflexive = other === other;\n            var othIsSymbol = isSymbol(other);\n            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;\n            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;\n        }\n        return 0;\n    }\n    function compareMultiple(object, other, orders) {\n        var index = -1;\n        var objCriteria = object.criteria;\n        var othCriteria = other.criteria;\n        var length = objCriteria.length;\n        var ordersLength = orders.length;\n        while(++index < length){\n            var order = index < ordersLength ? orders[index] : null;\n            var cmpFn = order && typeof order === \"function\" ? order : compareAscending;\n            var result = cmpFn(objCriteria[index], othCriteria[index]);\n            if (result) {\n                if (order && typeof order !== \"function\") return result * (order == \"desc\" ? -1 : 1);\n                return result;\n            }\n        }\n        return object.index - other.index;\n    }\n    var diff = function(array, values) {\n        var includes = function(array, value) {\n            var length = array == null ? 0 : array.length;\n            return !!length && array.indexOf(value) > -1;\n        };\n        var isCommon = true;\n        var result = [];\n        var valuesLength = values.length;\n        if (!array.length) return result;\n        if (values.length >= LARGE_ARRAY_SIZE) {\n            includes = function(cache, key) {\n                return cache.has(key);\n            };\n            isCommon = false;\n            values = new SetCache(values);\n        }\n        outer: for(var key in array){\n            var value = array[key];\n            var computed = value;\n            value = value !== 0 ? value : 0;\n            if (isCommon && computed === computed) {\n                var valuesIndex = valuesLength;\n                while(valuesIndex--){\n                    if (values[valuesIndex] === computed) continue outer;\n                }\n                result.push(value);\n            } else if (!includes(values, computed)) result.push(value);\n        }\n        return result;\n    };\n    var intersect = function(arrays) {\n        var includes = function(array, value) {\n            var length = array == null ? 0 : array.length;\n            return !!length && array.indexOf(value) > -1;\n        };\n        var cacheHas = function(cache, key) {\n            return cache.has(key);\n        };\n        var length = arrays[0].length;\n        var othLength = arrays.length;\n        var caches = new Array(othLength);\n        var result = [];\n        var array;\n        var maxLength = Infinity;\n        var othIndex = othLength;\n        while(othIndex--){\n            array = arrays[othIndex];\n            maxLength = Math.min(array.length, maxLength);\n            caches[othIndex] = length >= 120 && array.length >= 120 ? new SetCache(othIndex && array) : undefined;\n        }\n        array = arrays[0];\n        var index = -1;\n        var seen = caches[0];\n        outer: while(++index < length && result.length < maxLength){\n            var value = array[index];\n            var computed = value;\n            value = value !== 0 ? value : 0;\n            if (!(seen ? cacheHas(seen, computed) : includes(result, computed))) {\n                othIndex = othLength;\n                while(--othIndex){\n                    var cache = caches[othIndex];\n                    if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed))) continue outer;\n                }\n                if (seen) seen.push(computed);\n                result.push(value);\n            }\n        }\n        return result;\n    };\n    var toKey = function(value) {\n        if (typeof value === \"string\" || isSymbol(value)) return value;\n        var result = \"\" + value;\n        return result == \"0\" && 1 / value == -Infinity ? \"-0\" : result;\n    };\n    var baseClone = function(value, isDeep, isFlat, isFull, customizer, key, object, stack) {\n        if (isDeep === void 0) isDeep = false;\n        if (isFlat === void 0) isFlat = false;\n        if (isFull === void 0) isFull = true;\n        var result;\n        if (customizer) result = object ? customizer(value, key, object, stack) : customizer(value);\n        if (result !== undefined) return result;\n        if (!isObject$1(value)) return value;\n        var isArr = Array.isArray(value);\n        var tag = getTag(value);\n        if (isArr) {\n            result = initCloneArray(value);\n            if (!isDeep) return copyArray(value, result);\n        } else {\n            var isFunc = typeof value === \"function\";\n            if (tag === objectTag || tag === argsTag || isFunc && !object) {\n                result = isFlat || isFunc ? {} : initCloneObject(value);\n                if (!isDeep) return isFlat ? copySymbolsIn(value, copyObject(value, Object.keys(value), result)) : copySymbols(value, Object.assign(result, value));\n            } else {\n                if (isFunc || !CLONEABLE_TAGS[tag]) return object ? value : {};\n                result = initCloneByTag(value, tag, isDeep);\n            }\n        }\n        stack || (stack = new Stack);\n        var stacked = stack.get(value);\n        if (stacked) return stacked;\n        stack.set(value, result);\n        if (isMap(value)) {\n            value.forEach(function(subValue, key) {\n                result.set(key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n            });\n            return result;\n        }\n        if (isSet(value)) {\n            value.forEach(function(subValue) {\n                result.add(baseClone(subValue, isDeep, isFlat, isFull, customizer, subValue, value, stack));\n            });\n            return result;\n        }\n        if (isTypedArray(value)) return result;\n        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys$1;\n        var props = isArr ? undefined : keysFunc(value);\n        (props || value).forEach(function(subValue, key) {\n            if (props) {\n                key = subValue;\n                subValue = value[key];\n            }\n            assignValue(result, key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n        });\n        return result;\n    };\n    var copySymbolsIn = function(source, object) {\n        return copyObject(source, getSymbolsIn(source), object);\n    };\n    var parent = function(object, path) {\n        return path.length < 2 ? object : get$1(object, path.slice(0, -1));\n    };\n    var set$1 = function(object, path, value) {\n        if (!isObject$1(object)) return object;\n        path = castPath(path, object);\n        var length = path.length;\n        var lastIndex = length - 1;\n        var index = -1;\n        var nested = object;\n        while(nested != null && ++index < length){\n            var key = toKey(path[index]);\n            var newValue = value;\n            if (index != lastIndex) {\n                var objValue = nested[key];\n                newValue = undefined;\n                if (newValue === undefined) newValue = isObject$1(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n            }\n            assignValue(nested, key, newValue);\n            nested = nested[key];\n        }\n        return object;\n    };\n    var isIndex = function(value, length) {\n        var type = typeof value;\n        length = length == null ? Number.MAX_SAFE_INTEGER : length;\n        return !!length && (type === \"number\" || type !== \"symbol\" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n    };\n    var unset = function(object, path) {\n        path = castPath(path, object);\n        object = parent(object, path);\n        var lastSegment = path[path.length - 1];\n        return object == null || delete object[toKey(lastSegment)];\n    };\n    var isKeyable = function(value) {\n        var type = typeof value;\n        return type === \"string\" || type === \"number\" || type === \"symbol\" || type === \"boolean\" ? value !== \"__proto__\" : value === null;\n    };\n    var keysIn = function(object) {\n        var result = [];\n        for(var key in object)result.push(key);\n        return result;\n    };\n    var toPlainObject = function(value) {\n        value = Object(value);\n        var result = {};\n        for(var key in value)result[key] = value[key];\n        return result;\n    };\n    var safeGet = function(object, key) {\n        if (key === \"constructor\" && typeof object[key] === \"function\") return;\n        if (key == \"__proto__\") return;\n        return object[key];\n    };\n    function createAssigner(assigner, isMerge) {\n        if (isMerge === void 0) isMerge = false;\n        return function(object) {\n            var sources = [], len = arguments.length - 1;\n            while(len-- > 0)sources[len] = arguments[len + 1];\n            var index = -1;\n            var length = sources.length;\n            var customizer = length > 1 ? sources[length - 1] : undefined;\n            var guard = length > 2 ? sources[2] : undefined;\n            customizer = assigner.length > 3 && typeof customizer === \"function\" ? (length--, customizer) : isMerge ? function(a, b) {\n                if (Array.isArray(a) && !Array.isArray(b)) return b;\n            } : undefined;\n            if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n                customizer = length < 3 ? undefined : customizer;\n                length = 1;\n            }\n            object = Object(object);\n            while(++index < length){\n                var source = sources[index];\n                if (source) assigner(object, source, index, customizer);\n            }\n            return object;\n        };\n    }\n    var baseMerge = function(object, source, srcIndex, customizer, stack) {\n        if (object === source) return;\n        forIn(source, function(srcValue, key) {\n            if (isObject$1(srcValue)) {\n                stack || (stack = new Stack);\n                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n            } else {\n                var newValue = customizer ? customizer(object[key], srcValue, \"\" + key, object, source, stack) : undefined;\n                if (newValue === undefined) newValue = srcValue;\n                assignMergeValue(object, key, newValue);\n            }\n        }, keysIn);\n    };\n    var baseMergeDeep = function(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n        var objValue = safeGet(object, key);\n        var srcValue = safeGet(source, key);\n        var stacked = stack.get(srcValue);\n        if (stacked) {\n            assignMergeValue(object, key, stacked);\n            return;\n        }\n        var newValue = customizer ? customizer(objValue, srcValue, \"\" + key, object, source, stack) : undefined;\n        var isCommon = newValue === undefined;\n        if (isCommon) {\n            var isArr = Array.isArray(srcValue);\n            var isTyped = !isArr && isTypedArray(srcValue);\n            newValue = srcValue;\n            if (isArr || isTyped) {\n                if (Array.isArray(objValue)) newValue = objValue;\n                else if (isObjectLike(objValue) && isArrayLike(objValue)) newValue = copyArray(objValue);\n                else if (isTyped) {\n                    isCommon = false;\n                    newValue = cloneTypedArray(srcValue, true);\n                } else newValue = [];\n            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n                newValue = objValue;\n                if (isArguments(objValue)) newValue = toPlainObject(objValue);\n                else if (typeof objValue === \"function\" || !isObject$1(objValue)) newValue = initCloneObject(srcValue);\n            } else isCommon = false;\n        }\n        if (isCommon) {\n            // Recursively merge objects and arrays (susceptible to call stack limits).\n            stack.set(srcValue, newValue);\n            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n            stack[\"delete\"](srcValue);\n        }\n        assignMergeValue(object, key, newValue);\n    };\n    var assignMergeValue = function(object, key, value) {\n        if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) assignValue(object, key, value);\n    };\n    function baseFor(object, iteratee, keysFunc) {\n        var iterable = Object(object);\n        var props = keysFunc(object);\n        var length = props.length;\n        var index = -1;\n        while(length--){\n            var key = props[++index];\n            if (iteratee(iterable[key], key, iterable) === false) break;\n        }\n        return object;\n    }\n    var baseForOwn = function(object, iteratee) {\n        return object && baseFor(object, iteratee, keys$1);\n    };\n    var baseEach = function(collection, iteratee) {\n        if (collection == null) return collection;\n        if (!isArrayLike(collection)) return baseForOwn(collection, iteratee);\n        var length = collection.length;\n        var iterable = Object(collection);\n        var index = -1;\n        while(++index < length){\n            if (iteratee(iterable[index], index, iterable) === false) break;\n        }\n        return collection;\n    };\n    function last(array) {\n        var length = array == null ? 0 : array.length;\n        return length ? array[length - 1] : undefined;\n    }\n    var createSet = Set && 1 / setToArray(new Set([\n        undefined,\n        -0\n    ]))[1] == 1 / 0 ? function(values) {\n        return new Set(values);\n    } : function() {};\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n        if (isObject$1(objValue) && isObject$1(srcValue)) {\n            // Recursively merge objects and arrays (susceptible to call stack limits).\n            stack.set(srcValue, objValue);\n            baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n            stack[\"delete\"](srcValue);\n        }\n        return objValue;\n    }\n    function baseOrderBy(collection, iteratees, orders) {\n        if (iteratees.length) iteratees = iteratees.map(function(iteratee) {\n            if (Array.isArray(iteratee)) return function(value) {\n                return get$1(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            };\n            return iteratee;\n        });\n        else iteratees = [\n            function(value) {\n                return value;\n            }\n        ];\n        var criteriaIndex = -1;\n        var eachIndex = -1;\n        var result = isArrayLike(collection) ? new Array(collection.length) : [];\n        baseEach(collection, function(value) {\n            var criteria = iteratees.map(function(iteratee) {\n                return iteratee(value);\n            });\n            result[++eachIndex] = {\n                criteria: criteria,\n                index: ++criteriaIndex,\n                value: value\n            };\n        });\n        return baseSortBy(result, function(object, other) {\n            return compareMultiple(object, other, orders);\n        });\n    }\n    function baseSortBy(array, comparer) {\n        var length = array.length;\n        array.sort(comparer);\n        while(length--)array[length] = array[length].value;\n        return array;\n    }\n    function isStrictComparable(value) {\n        return value === value && !isObject$1(value);\n    }\n    function matchesStrictComparable(key, srcValue) {\n        return function(object) {\n            if (object == null) return false;\n            return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n        };\n    }\n    function hasIn(object, path) {\n        return object != null && hasPath(object, path, baseHasIn);\n    }\n    function baseMatchesProperty(path, srcValue) {\n        if (isKey(path) && isStrictComparable(srcValue)) return matchesStrictComparable(toKey(path), srcValue);\n        return function(object) {\n            var objValue = get$1(object, path);\n            return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue);\n        };\n    }\n    function baseMatches(source) {\n        var matchData = getMatchData(source);\n        if (matchData.length === 1 && matchData[0][2]) return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n        return function(object) {\n            return object === source || baseIsMatch(object, source, matchData);\n        };\n    }\n    function getMatchData(object) {\n        var result = keys$1(object);\n        var length = result.length;\n        while(length--){\n            var key = result[length];\n            var value = object[key];\n            result[length] = [\n                key,\n                value,\n                isStrictComparable(value)\n            ];\n        }\n        return result;\n    }\n    function baseIsMatch(object, source, matchData, customizer) {\n        var index = matchData.length;\n        var length = index;\n        var noCustomizer = !customizer;\n        if (object == null) return !length;\n        var data;\n        var result;\n        object = Object(object);\n        while(index--){\n            data = matchData[index];\n            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;\n        }\n        while(++index < length){\n            data = matchData[index];\n            var key = data[0];\n            var objValue = object[key];\n            var srcValue = data[1];\n            if (noCustomizer && data[2]) {\n                if (objValue === undefined && !(key in object)) return false;\n            } else {\n                var stack = new Stack;\n                if (customizer) result = customizer(objValue, srcValue, key, object, source, stack);\n                if (!(result === undefined ? baseIsEqual(srcValue, objValue, stack) : result)) return false;\n            }\n        }\n        return true;\n    }\n    function property(path) {\n        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n    function baseProperty(key) {\n        return function(object) {\n            return object == null ? undefined : object[key];\n        };\n    }\n    function basePropertyDeep(path) {\n        return function(object) {\n            return get$1(object, path);\n        };\n    }\n    function baseIteratee(value) {\n        if (typeof value == \"function\") return value;\n        if (value == null) return function(val) {\n            return val;\n        };\n        if (typeof value == \"object\") return Array.isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n        return property(value);\n    }\n    function getIteratee() {\n        var result = baseIteratee;\n        return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n    var arrayReduce = function(array, iteratee, accumulator, initAccum) {\n        var index = -1;\n        var length = array == null ? 0 : array.length;\n        if (initAccum && length) accumulator = array[++index];\n        while(++index < length)accumulator = iteratee(accumulator, array[index], index, array);\n        return accumulator;\n    };\n    var baseReduce = function(collection, iteratee, accumulator, initAccum, eachFunc) {\n        eachFunc(collection, function(value, index, collection) {\n            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);\n        });\n        return accumulator;\n    };\n    function reduce(collection, iteratee, accumulator) {\n        var func = Array.isArray(collection) ? arrayReduce : baseReduce;\n        var initAccum = arguments.length < 3;\n        return func(collection, iteratee, accumulator, initAccum, baseEach);\n    }\n    var isFlattenable = function(value) {\n        return Array.isArray(value) || isArguments(value) || !!(value && value[Symbol.isConcatSpreadable]);\n    };\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n        var index = -1;\n        var length = array.length;\n        predicate || (predicate = isFlattenable);\n        result || (result = []);\n        while(++index < length){\n            var value = array[index];\n            if (depth > 0 && predicate(value)) {\n                if (depth > 1) // Recursively flatten arrays (susceptible to call stack limits).\n                baseFlatten(value, depth - 1, predicate, isStrict, result);\n                else result.push.apply(result, value);\n            } else if (!isStrict) result[result.length] = value;\n        }\n        return result;\n    }\n    var isArguments = function(value) {\n        return isObjectLike(value) && getTag(value) == \"[object Arguments]\";\n    };\n    var basePick = function(object, paths) {\n        return basePickBy(object, paths, function(value, path) {\n            return hasIn(object, path);\n        });\n    };\n    var basePickBy = function(object, paths, predicate) {\n        var index = -1;\n        var length = paths.length;\n        var result = {};\n        while(++index < length){\n            var path = paths[index];\n            var value = get$1(object, path);\n            if (predicate(value, path)) set$1(result, castPath(path, object), value);\n        }\n        return result;\n    };\n    var isLength = function(value) {\n        return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;\n    };\n    var baseHasIn = function(object, key) {\n        return object != null && key in Object(object);\n    };\n    var hasPath = function(object, path, hasFunc) {\n        path = castPath(path, object);\n        var index = -1, length = path.length, result = false;\n        while(++index < length){\n            var key = toKey(path[index]);\n            if (!(result = object != null && hasFunc(object, key))) break;\n            object = object[key];\n        }\n        if (result || ++index != length) return result;\n        length = object == null ? 0 : object.length;\n        return !!length && isLength(length) && isIndex(key, length) && (Array.isArray(object) || isArguments(object));\n    };\n    var asciiWords = function(string) {\n        return string.match(reAsciiWord);\n    };\n    var unicodeWords = function(string) {\n        return string.match(reUnicodeWords);\n    };\n    var words = function(string, pattern) {\n        if (pattern === undefined) {\n            var result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n            return result || [];\n        }\n        return string.match(pattern) || [];\n    };\n    var castSlice = function(array, start, end) {\n        var length = array.length;\n        end = end === undefined ? length : end;\n        return !start && end >= length ? array : array.slice(start, end);\n    };\n    var upperFirst = createCaseFirst(\"toUpperCase\");\n    function createCaseFirst(methodName) {\n        return function(string) {\n            if (!string) return \"\";\n            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;\n            var chr = strSymbols ? strSymbols[0] : string[0];\n            var trailing = strSymbols ? castSlice(strSymbols, 1).join(\"\") : string.slice(1);\n            return chr[methodName]() + trailing;\n        };\n    }\n    // -- helper classes\n    var Stack = function Stack(entries) {\n        var data = this.__data__ = new ListCache(entries);\n        this.size = data.size;\n    };\n    Stack.prototype.clear = function clear() {\n        this.__data__ = new ListCache;\n        this.size = 0;\n    };\n    Stack.prototype.delete = function delete$1(key) {\n        var data = this.__data__;\n        var result = data[\"delete\"](key);\n        this.size = data.size;\n        return result;\n    };\n    Stack.prototype.get = function get(key) {\n        return this.__data__.get(key);\n    };\n    Stack.prototype.has = function has(key) {\n        return this.__data__.has(key);\n    };\n    Stack.prototype.set = function set(key, value) {\n        var data = this.__data__;\n        if (data instanceof ListCache) {\n            var pairs = data.__data__;\n            if (pairs.length < LARGE_ARRAY_SIZE - 1) {\n                pairs.push([\n                    key,\n                    value\n                ]);\n                this.size = ++data.size;\n                return this;\n            }\n            data = this.__data__ = new MapCache(pairs);\n        }\n        data.set(key, value);\n        this.size = data.size;\n        return this;\n    };\n    var ListCache = function ListCache(entries) {\n        var index = -1;\n        var length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    };\n    ListCache.prototype.clear = function clear() {\n        this.__data__ = [];\n        this.size = 0;\n    };\n    ListCache.prototype.delete = function delete$2(key) {\n        var data = this.__data__;\n        var index = assocIndexOf(data, key);\n        if (index < 0) return false;\n        var lastIndex = data.length - 1;\n        if (index == lastIndex) data.pop();\n        else data.splice(index, 1);\n        --this.size;\n        return true;\n    };\n    ListCache.prototype.get = function get(key) {\n        var data = this.__data__;\n        var index = assocIndexOf(data, key);\n        return index < 0 ? undefined : data[index][1];\n    };\n    ListCache.prototype.has = function has(key) {\n        return assocIndexOf(this.__data__, key) > -1;\n    };\n    ListCache.prototype.set = function set(key, value) {\n        var data = this.__data__;\n        var index = assocIndexOf(data, key);\n        if (index < 0) {\n            ++this.size;\n            data.push([\n                key,\n                value\n            ]);\n        } else data[index][1] = value;\n        return this;\n    };\n    var MapCache = function MapCache(entries) {\n        var index = -1;\n        var length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    };\n    MapCache.prototype.clear = function clear() {\n        this.size = 0;\n        this.__data__ = {\n            \"hash\": new Hash,\n            \"map\": new Map,\n            \"string\": new Hash\n        };\n    };\n    MapCache.prototype.delete = function delete$3(key) {\n        var result = getMapData(this, key)[\"delete\"](key);\n        this.size -= result ? 1 : 0;\n        return result;\n    };\n    MapCache.prototype.get = function get(key) {\n        return getMapData(this, key).get(key);\n    };\n    MapCache.prototype.has = function has(key) {\n        return getMapData(this, key).has(key);\n    };\n    MapCache.prototype.set = function set(key, value) {\n        var data = getMapData(this, key);\n        var size = data.size;\n        data.set(key, value);\n        this.size += data.size == size ? 0 : 1;\n        return this;\n    };\n    var Hash = function Hash(entries) {\n        var index = -1;\n        var length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    };\n    Hash.prototype.clear = function clear() {\n        this.__data__ = Object.create(null);\n        this.size = 0;\n    };\n    Hash.prototype.delete = function delete$4(key) {\n        var result = this.has(key) && delete this.__data__[key];\n        this.size -= result ? 1 : 0;\n        return result;\n    };\n    Hash.prototype.get = function get(key) {\n        var data = this.__data__;\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n    };\n    Hash.prototype.has = function has(key) {\n        var data = this.__data__;\n        return data[key] !== undefined;\n    };\n    Hash.prototype.set = function set(key, value) {\n        var data = this.__data__;\n        this.size += this.has(key) ? 0 : 1;\n        data[key] = value === undefined ? HASH_UNDEFINED : value;\n        return this;\n    };\n    var SetCache = function SetCache(values) {\n        var index = -1;\n        var length = values == null ? 0 : values.length;\n        this.__data__ = new MapCache;\n        while(++index < length)this.add(values[index]);\n    };\n    SetCache.prototype.add = function add(value) {\n        this.__data__.set(value, HASH_UNDEFINED);\n        return this;\n    };\n    SetCache.prototype.has = function has(value) {\n        return this.__data__.has(value);\n    };\n    SetCache.prototype.push = SetCache.prototype.add;\n    // -- top level functions\n    var isBoolean = function(value) {\n        var toString = Object.prototype.toString;\n        return value === true || value === false || !!value && typeof value === \"object\" && toString.call(value) === boolTag;\n    };\n    var isObject$1 = function(value) {\n        return !!value && (typeof value === \"object\" || typeof value === \"function\");\n    };\n    var isNumber = function(value) {\n        var toString = Object.prototype.toString;\n        return typeof value === \"number\" || !!value && typeof value === \"object\" && toString.call(value) === numberTag;\n    };\n    var isString = function(value) {\n        var toString = Object.prototype.toString;\n        return typeof value === \"string\" || !!value && typeof value === \"object\" && toString.call(value) === stringTag;\n    };\n    var assign = createAssigner(function(object, source) {\n        if (isPrototype(source) || isArrayLike(source)) {\n            copyObject(source, keys$1(source), object);\n            return;\n        }\n        for(var key in source)if (hasOwnProperty.call(source, key)) assignValue(object, key, source[key]);\n    });\n    var mixin = assign;\n    var deepMixin = mixin;\n    var supplement = function(object) {\n        var sources = [], len = arguments.length - 1;\n        while(len-- > 0)sources[len] = arguments[len + 1];\n        var index = -1;\n        var length = sources.length;\n        var guard = length > 2 ? sources[2] : undefined;\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) length = 1;\n        while(++index < length){\n            var source = sources[index];\n            if (source == null) continue;\n            var props = Object.keys(source);\n            var propsLength = props.length;\n            var propsIndex = -1;\n            while(++propsIndex < propsLength){\n                var key = props[propsIndex];\n                var value = object[key];\n                if (value === undefined || eq(value, Object.prototype[key]) && !hasOwnProperty.call(object, key)) object[key] = source[key];\n            }\n        }\n        return object;\n    };\n    var defaults = supplement;\n    var deepSupplement = function defaultsDeep() {\n        var args = [], len = arguments.length;\n        while(len--)args[len] = arguments[len];\n        args.push(undefined, customDefaultsMerge);\n        return merge.apply(undefined, args);\n    };\n    var defaultsDeep = deepSupplement;\n    // _.invokeMap\n    var invoke = function(collection, path) {\n        var args = [], len = arguments.length - 2;\n        while(len-- > 0)args[len] = arguments[len + 2];\n        var index = -1;\n        var isFunc = typeof path === \"function\";\n        var result = isArrayLike(collection) ? new Array(collection.length) : [];\n        baseEach(collection, function(value) {\n            result[++index] = isFunc ? path.apply(value, args) : invokeProperty.apply(void 0, [\n                value,\n                path\n            ].concat(args));\n        });\n        return result;\n    };\n    // _.invoke\n    var invokeProperty = function(object, path) {\n        var args = [], len = arguments.length - 2;\n        while(len-- > 0)args[len] = arguments[len + 2];\n        path = castPath(path, object);\n        object = parent(object, path);\n        var func = object == null ? object : object[toKey(last(path))];\n        return func == null ? undefined : func.apply(object, args);\n    };\n    var sortedIndex = function(array, value, iteratee) {\n        var low = 0;\n        var high = array == null ? 0 : array.length;\n        if (high == 0) return 0;\n        iteratee = getIteratee(iteratee, 2);\n        value = iteratee(value);\n        var valIsNaN = value !== value;\n        var valIsNull = value === null;\n        var valIsSymbol = isSymbol(value);\n        var valIsUndefined = value === undefined;\n        while(low < high){\n            var setLow = void 0;\n            var mid = Math.floor((low + high) / 2);\n            var computed = iteratee(array[mid]);\n            var othIsDefined = computed !== undefined;\n            var othIsNull = computed === null;\n            var othIsReflexive = computed === computed;\n            var othIsSymbol = isSymbol(computed);\n            if (valIsNaN) setLow = othIsReflexive;\n            else if (valIsUndefined) setLow = othIsReflexive && othIsDefined;\n            else if (valIsNull) setLow = othIsReflexive && othIsDefined && !othIsNull;\n            else if (valIsSymbol) setLow = othIsReflexive && othIsDefined && !othIsNull && !othIsSymbol;\n            else if (othIsNull || othIsSymbol) setLow = false;\n            else setLow = computed < value;\n            if (setLow) low = mid + 1;\n            else high = mid;\n        }\n        return Math.min(high, MAX_ARRAY_INDEX);\n    };\n    var uniq = function(array, iteratee) {\n        var index = -1;\n        var includes = function(array, value) {\n            var length = array == null ? 0 : array.length;\n            return !!length && array.indexOf(value) > -1;\n        };\n        iteratee = getIteratee(iteratee, 2);\n        var isCommon = true;\n        var length = array.length;\n        var result = [];\n        var seen = result;\n        if (length >= LARGE_ARRAY_SIZE) {\n            var set = iteratee ? null : createSet(array);\n            if (set) return setToArray(set);\n            isCommon = false;\n            includes = function(cache, key) {\n                return cache.has(key);\n            };\n            seen = new SetCache;\n        } else seen = iteratee ? [] : result;\n        outer: while(++index < length){\n            var value = array[index];\n            var computed = iteratee ? iteratee(value) : value;\n            value = value !== 0 ? value : 0;\n            if (isCommon && computed === computed) {\n                var seenIndex = seen.length;\n                while(seenIndex--){\n                    if (seen[seenIndex] === computed) continue outer;\n                }\n                if (iteratee) seen.push(computed);\n                result.push(value);\n            } else if (!includes(seen, computed)) {\n                if (seen !== result) seen.push(computed);\n                result.push(value);\n            }\n        }\n        return result;\n    };\n    var clone = function(value) {\n        return baseClone(value);\n    };\n    var cloneDeep = function(value) {\n        return baseClone(value, true);\n    };\n    var isEmpty = function(value) {\n        if (value == null) return true;\n        if (isArrayLike(value) && (Array.isArray(value) || typeof value === \"string\" || typeof value.splice === \"function\" || isTypedArray(value) || isArguments(value))) return !value.length;\n        var tag = getTag(value);\n        if (tag == \"[object Map]\" || tag == \"[object Set]\") return !value.size;\n        if (isPrototype(value)) return !baseKeys(value).length;\n        for(var key in value){\n            if (hasOwnProperty.call(value, key)) return false;\n        }\n        return true;\n    };\n    var isEqual = function(object, other) {\n        return baseIsEqual(object, other);\n    };\n    var isFunction = function(value) {\n        return typeof value === \"function\";\n    };\n    var isPlainObject = function(value) {\n        if (!isObjectLike(value) || getTag(value) != \"[object Object]\") return false;\n        if (Object.getPrototypeOf(value) === null) return true;\n        var proto = value;\n        while(Object.getPrototypeOf(proto) !== null)proto = Object.getPrototypeOf(proto);\n        return Object.getPrototypeOf(value) === proto;\n    };\n    var toArray = function(value) {\n        if (!value) return [];\n        if (isArrayLike(value)) return isString(value) ? stringToArray(value) : copyArray(value);\n        if (Symbol.iterator && Symbol.iterator in Object(value)) {\n            var iterator = value[Symbol.iterator]();\n            var data;\n            var result = [];\n            while(!(data = iterator.next()).done)result.push(data.value);\n            return result;\n        }\n        var tag = getTag(value);\n        var func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;\n        return func(value);\n    };\n    function debounce(func, wait, opt) {\n        if (typeof func !== \"function\") throw new TypeError(\"Expected a function\");\n        var lastArgs;\n        var lastThis;\n        var maxWait;\n        var result;\n        var timerId;\n        var lastCallTime;\n        var lastInvokeTime = 0;\n        var leading = false;\n        var maxing = false;\n        var trailing = true;\n        var useRaf = !wait && wait !== 0 && window && typeof window.requestAnimationFrame === \"function\";\n        wait = +wait || 0;\n        if (isObject$1(opt)) {\n            leading = !!opt.leading;\n            maxing = \"maxWait\" in opt;\n            maxWait = maxing ? Math.max(+opt.maxWait || 0, wait) : maxWait;\n            trailing = \"trailing\" in opt ? !!opt.trailing : trailing;\n        }\n        function invokeFunc(time) {\n            var args = lastArgs;\n            var thisArg = lastThis;\n            lastArgs = lastThis = undefined;\n            lastInvokeTime = time;\n            result = func.apply(thisArg, args);\n            return result;\n        }\n        function startTimer(pendingFunc, wait) {\n            if (useRaf) {\n                window.cancelAnimationFrame(timerId);\n                return window.requestAnimationFrame(pendingFunc);\n            }\n            return setTimeout(pendingFunc, wait);\n        }\n        function cancelTimer(id) {\n            if (useRaf) return window.cancelAnimationFrame(id);\n            clearTimeout(id);\n        }\n        function leadingEdge(time) {\n            lastInvokeTime = time;\n            timerId = startTimer(timerExpired, wait);\n            return leading ? invokeFunc(time) : result;\n        }\n        function remainingWait(time) {\n            var timeSinceLastCall = time - lastCallTime;\n            var timeSinceLastInvoke = time - lastInvokeTime;\n            var timeWaiting = wait - timeSinceLastCall;\n            return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n        }\n        function shouldInvoke(time) {\n            var timeSinceLastCall = time - lastCallTime;\n            var timeSinceLastInvoke = time - lastInvokeTime;\n            return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n        }\n        function timerExpired() {\n            var time = Date.now();\n            if (shouldInvoke(time)) return trailingEdge(time);\n            timerId = startTimer(timerExpired, remainingWait(time));\n        }\n        function trailingEdge(time) {\n            timerId = undefined;\n            if (trailing && lastArgs) return invokeFunc(time);\n            lastArgs = lastThis = undefined;\n            return result;\n        }\n        function debounced() {\n            var args = [], len = arguments.length;\n            while(len--)args[len] = arguments[len];\n            var time = Date.now();\n            var isInvoking = shouldInvoke(time);\n            lastArgs = args;\n            lastThis = this;\n            lastCallTime = time;\n            if (isInvoking) {\n                if (timerId === undefined) return leadingEdge(lastCallTime);\n                if (maxing) {\n                    timerId = startTimer(timerExpired, wait);\n                    return invokeFunc(lastCallTime);\n                }\n            }\n            if (timerId === undefined) timerId = startTimer(timerExpired, wait);\n            return result;\n        }\n        debounced.cancel = function() {\n            if (timerId !== undefined) cancelTimer(timerId);\n            lastInvokeTime = 0;\n            lastArgs = lastCallTime = lastThis = timerId = undefined;\n        };\n        debounced.flush = function() {\n            return timerId === undefined ? result : trailingEdge(Date.now());\n        };\n        debounced.pending = function() {\n            return timerId !== undefined;\n        };\n        return debounced;\n    }\n    var groupBy = function(collection, iteratee) {\n        iteratee = getIteratee(iteratee, 2);\n        return reduce(collection, function(result, value, key) {\n            key = iteratee(value);\n            if (hasOwnProperty.call(result, key)) result[key].push(value);\n            else assignValue(result, key, [\n                value\n            ]);\n            return result;\n        }, {});\n    };\n    var sortBy = function(collection, iteratees) {\n        if (iteratees === void 0) iteratees = [];\n        if (collection == null) return [];\n        var length = iteratees.length;\n        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) iteratees = [];\n        else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) iteratees = [\n            iteratees[0]\n        ];\n        if (!Array.isArray(iteratees)) iteratees = [\n            getIteratee(iteratees, 2)\n        ];\n        return baseOrderBy(collection, iteratees.flat(1), []);\n    };\n    var flattenDeep = function(array) {\n        var length = array == null ? 0 : array.length;\n        return length ? baseFlatten(array, Infinity) : [];\n    };\n    var without = function(array) {\n        var values = [], len = arguments.length - 1;\n        while(len-- > 0)values[len] = arguments[len + 1];\n        return isArrayLike(array) ? diff(array, values) : [];\n    };\n    var difference = function(array) {\n        var values = [], len = arguments.length - 1;\n        while(len-- > 0)values[len] = arguments[len + 1];\n        return isObjectLike(array) && isArrayLike(array) ? diff(array, values.flat(1)) : [];\n    };\n    var intersection$1 = function() {\n        var arrays = [], len = arguments.length;\n        while(len--)arrays[len] = arguments[len];\n        var mapped = arrays.map(function(array) {\n            return isObjectLike(array) && isArrayLike(array) ? array : [];\n        });\n        return mapped.length && mapped[0] === arrays[0] ? intersect(mapped) : [];\n    };\n    var union = function() {\n        var arrays = [], len = arguments.length;\n        while(len--)arrays[len] = arguments[len];\n        var array = arrays.flat(1);\n        return uniq(array);\n    };\n    var has$2 = function(object, key) {\n        if (object == null) return false;\n        if (typeof key === \"string\") key = key.split(\".\");\n        var index = -1;\n        var value = object;\n        while(++index < key.length){\n            if (!value || !hasOwnProperty.call(value, key[index])) return false;\n            value = value[key[index]];\n        }\n        return true;\n    };\n    var result = function(object, path, defaultValue) {\n        path = castPath(path, object);\n        var index = -1;\n        var length = path.length;\n        if (!length) {\n            length = 1;\n            object = undefined;\n        }\n        while(++index < length){\n            var value = object == null ? undefined : object[toKey(path[index])];\n            if (value === undefined) {\n                index = length;\n                value = defaultValue;\n            }\n            object = typeof value === \"function\" ? value.call(object) : value;\n        }\n        return object;\n    };\n    var omit = function(object) {\n        var paths = [], len = arguments.length - 1;\n        while(len-- > 0)paths[len] = arguments[len + 1];\n        var result = {};\n        if (object == null) return result;\n        var isDeep = false;\n        paths = paths.flat(1).map(function(path) {\n            path = castPath(path, object);\n            isDeep || (isDeep = path.length > 1);\n            return path;\n        });\n        copyObject(object, getAllKeysIn(object), result);\n        if (isDeep) result = baseClone(result, true, true, true, function(value) {\n            return isPlainObject(value) ? undefined : value;\n        });\n        var length = paths.length;\n        while(length--)unset(result, paths[length]);\n        return result;\n    };\n    var pick = function(object) {\n        var paths = [], len = arguments.length - 1;\n        while(len-- > 0)paths[len] = arguments[len + 1];\n        return object == null ? {} : basePick(object, paths.flat(Infinity));\n    };\n    var bindAll = function(object) {\n        var methodNames = [], len = arguments.length - 1;\n        while(len-- > 0)methodNames[len] = arguments[len + 1];\n        methodNames.flat(1).forEach(function(key) {\n            key = toKey(key);\n            assignValue(object, key, object[key].bind(object));\n        });\n        return object;\n    };\n    var forIn = function(object, iteratee) {\n        if (iteratee === void 0) iteratee = function(value) {\n            return value;\n        };\n        var index = -1;\n        var iterable = Object(object);\n        var props = isArrayLike(object) ? arrayLikeKeys(object, true) : keysIn(object);\n        var length = props.length;\n        while(length--){\n            var key = props[++index];\n            if (iteratee(iterable[key], key, iterable) === false) break;\n        }\n    };\n    var camelCase = function(string) {\n        if (string === void 0) string = \"\";\n        return words((\"\" + string).replace(/['\\u2019]/g, \"\")).reduce(function(result, word, index) {\n            word = word.toLowerCase();\n            return result + (index ? upperFirst(word) : word);\n        }, \"\");\n    };\n    var idCounter = 0;\n    var uniqueId = function(prefix) {\n        if (prefix === void 0) prefix = \"\";\n        var id = ++idCounter;\n        return \"\" + prefix + id;\n    };\n    var merge = createAssigner(function(object, source, srcIndex, customizer) {\n        baseMerge(object, source, srcIndex, customizer);\n    }, true);\n    var addClassNamePrefix = function(className) {\n        if (!className) return className;\n        return className.toString().split(\" \").map(function(_className) {\n            if (_className.substr(0, config.classNamePrefix.length) !== config.classNamePrefix) _className = config.classNamePrefix + _className;\n            return _className;\n        }).join(\" \");\n    };\n    var removeClassNamePrefix = function(className) {\n        if (!className) return className;\n        return className.toString().split(\" \").map(function(_className) {\n            if (_className.substr(0, config.classNamePrefix.length) === config.classNamePrefix) _className = _className.substr(config.classNamePrefix.length);\n            return _className;\n        }).join(\" \");\n    };\n    var parseDOMJSON = function(json, namespace) {\n        var selectors = {};\n        var groupSelectors = {};\n        var svgNamespace = V.namespace.svg;\n        var ns = namespace || svgNamespace;\n        var fragment = document.createDocumentFragment();\n        var parseNode = function(siblingsDef, parentNode, ns) {\n            for(var i = 0; i < siblingsDef.length; i++){\n                var nodeDef = siblingsDef[i];\n                // Text node\n                if (typeof nodeDef === \"string\") {\n                    var textNode = document.createTextNode(nodeDef);\n                    parentNode.appendChild(textNode);\n                    continue;\n                }\n                // TagName\n                if (!nodeDef.hasOwnProperty(\"tagName\")) throw new Error(\"json-dom-parser: missing tagName\");\n                var tagName = nodeDef.tagName;\n                var node = void 0;\n                // Namespace URI\n                if (nodeDef.hasOwnProperty(\"namespaceURI\")) ns = nodeDef.namespaceURI;\n                node = document.createElementNS(ns, tagName);\n                var svg = ns === svgNamespace;\n                var wrapper = svg ? V : $;\n                // Attributes\n                var attributes = nodeDef.attributes;\n                if (attributes) wrapper(node).attr(attributes);\n                // Style\n                var style = nodeDef.style;\n                if (style) $(node).css(style);\n                // ClassName\n                if (nodeDef.hasOwnProperty(\"className\")) {\n                    var className = nodeDef.className;\n                    if (svg) node.className.baseVal = className;\n                    else node.className = className;\n                }\n                // TextContent\n                if (nodeDef.hasOwnProperty(\"textContent\")) node.textContent = nodeDef.textContent;\n                // Selector\n                if (nodeDef.hasOwnProperty(\"selector\")) {\n                    var nodeSelector = nodeDef.selector;\n                    if (selectors[nodeSelector]) throw new Error(\"json-dom-parser: selector must be unique\");\n                    selectors[nodeSelector] = node;\n                    wrapper(node).attr(\"joint-selector\", nodeSelector);\n                }\n                // Groups\n                if (nodeDef.hasOwnProperty(\"groupSelector\")) {\n                    var nodeGroups = nodeDef.groupSelector;\n                    if (!Array.isArray(nodeGroups)) nodeGroups = [\n                        nodeGroups\n                    ];\n                    for(var j = 0; j < nodeGroups.length; j++){\n                        var nodeGroup = nodeGroups[j];\n                        var group = groupSelectors[nodeGroup];\n                        if (!group) group = groupSelectors[nodeGroup] = [];\n                        group.push(node);\n                    }\n                }\n                parentNode.appendChild(node);\n                // Children\n                var childrenDef = nodeDef.children;\n                if (Array.isArray(childrenDef)) parseNode(childrenDef, node, ns);\n            }\n        };\n        parseNode(json, fragment, ns);\n        return {\n            fragment: fragment,\n            selectors: selectors,\n            groupSelectors: groupSelectors\n        };\n    };\n    // Return a simple hash code from a string. See http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/.\n    var hashCode = function(str) {\n        var hash = 0;\n        if (str.length === 0) return hash;\n        for(var i = 0; i < str.length; i++){\n            var c = str.charCodeAt(i);\n            hash = (hash << 5) - hash + c;\n            hash = hash & hash; // Convert to 32bit integer\n        }\n        return hash;\n    };\n    var getByPath = function(obj, path, delimiter) {\n        var keys = Array.isArray(path) ? path : path.split(delimiter || \"/\");\n        var key;\n        var i = 0;\n        var length = keys.length;\n        while(i < length){\n            key = keys[i++];\n            if (Object(obj) === obj && key in obj) obj = obj[key];\n            else return undefined;\n        }\n        return obj;\n    };\n    var isGetSafe = function(obj, key) {\n        // Prevent prototype pollution\n        // https://snyk.io/vuln/SNYK-JS-JSON8MERGEPATCH-1038399\n        if (typeof key !== \"string\" && typeof key !== \"number\") key = String(key);\n        if (key === \"constructor\" && typeof obj[key] === \"function\") return false;\n        if (key === \"__proto__\") return false;\n        return true;\n    };\n    var setByPath = function(obj, path, value, delimiter) {\n        var keys = Array.isArray(path) ? path : path.split(delimiter || \"/\");\n        var last = keys.length - 1;\n        var diver = obj;\n        var i = 0;\n        for(; i < last; i++){\n            var key = keys[i];\n            if (!isGetSafe(diver, key)) return obj;\n            var value$1 = diver[key];\n            // diver creates an empty object if there is no nested object under such a key.\n            // This means that one can populate an empty nested object with setByPath().\n            diver = value$1 || (diver[key] = {});\n        }\n        diver[keys[last]] = value;\n        return obj;\n    };\n    var unsetByPath = function(obj, path, delimiter) {\n        var keys = Array.isArray(path) ? path : path.split(delimiter || \"/\");\n        var last = keys.length - 1;\n        var diver = obj;\n        var i = 0;\n        for(; i < last; i++){\n            var key = keys[i];\n            if (!isGetSafe(diver, key)) return obj;\n            var value = diver[key];\n            if (!value) return obj;\n            diver = value;\n        }\n        delete diver[keys[last]];\n        return obj;\n    };\n    var flattenObject = function(obj, delim, stop) {\n        delim = delim || \"/\";\n        var ret = {};\n        for(var key in obj){\n            if (!obj.hasOwnProperty(key)) continue;\n            var shouldGoDeeper = typeof obj[key] === \"object\";\n            if (shouldGoDeeper && stop && stop(obj[key])) shouldGoDeeper = false;\n            if (shouldGoDeeper) {\n                var flatObject = flattenObject(obj[key], delim, stop);\n                for(var flatKey in flatObject){\n                    if (!flatObject.hasOwnProperty(flatKey)) continue;\n                    ret[key + delim + flatKey] = flatObject[flatKey];\n                }\n            } else ret[key] = obj[key];\n        }\n        return ret;\n    };\n    var uuid = function() {\n        // credit: http://stackoverflow.com/posts/2117523/revisions\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n            var r = Math.random() * 16 | 0;\n            var v = c === \"x\" ? r : r & 0x3 | 0x8;\n            return v.toString(16);\n        });\n    };\n    // Generates global unique id and stores it as a property of the object, if provided.\n    var guid = function(obj) {\n        guid.id = guid.id || 1;\n        if (obj === undefined) return \"j_\" + guid.id++;\n        obj.id = obj.id === undefined ? \"j_\" + guid.id++ : obj.id;\n        return obj.id;\n    };\n    var toKebabCase = function(string) {\n        return string.replace(/[A-Z]/g, \"-$&\").toLowerCase();\n    };\n    var normalizeEvent = function(evt) {\n        if (evt.normalized) return evt;\n        var originalEvent = evt.originalEvent;\n        var target = evt.target;\n        // If the event is a touch event, normalize it to a mouse event.\n        var touch = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];\n        if (touch) {\n            for(var property in touch)// copy all the properties from the first touch that are not\n            // defined on TouchEvent (clientX, clientY, pageX, pageY, screenX, screenY, identifier, ...)\n            if (evt[property] === undefined) evt[property] = touch[property];\n        }\n        // IE: evt.target could be set to SVGElementInstance for SVGUseElement\n        if (target) {\n            var useElement = target.correspondingUseElement;\n            if (useElement) evt.target = useElement;\n        }\n        evt.normalized = true;\n        return evt;\n    };\n    var normalizeWheel = function(evt) {\n        // Sane values derived empirically\n        var PIXEL_STEP = 10;\n        var LINE_HEIGHT = 40;\n        var PAGE_HEIGHT = 800;\n        var sX = 0, sY = 0, pX = 0, pY = 0;\n        // Legacy\n        if (\"detail\" in evt) sY = evt.detail;\n        if (\"wheelDelta\" in evt) sY = -evt.wheelDelta / 120;\n        if (\"wheelDeltaY\" in evt) sY = -evt.wheelDeltaY / 120;\n        if (\"wheelDeltaX\" in evt) sX = -evt.wheelDeltaX / 120;\n        // side scrolling on FF with DOMMouseScroll\n        if (\"axis\" in evt && evt.axis === evt.HORIZONTAL_AXIS) {\n            sX = sY;\n            sY = 0;\n        }\n        pX = \"deltaX\" in evt ? evt.deltaX : sX * PIXEL_STEP;\n        pY = \"deltaY\" in evt ? evt.deltaY : sY * PIXEL_STEP;\n        if ((pX || pY) && evt.deltaMode) {\n            if (evt.deltaMode == 1) {\n                pX *= LINE_HEIGHT;\n                pY *= LINE_HEIGHT;\n            } else {\n                pX *= PAGE_HEIGHT;\n                pY *= PAGE_HEIGHT;\n            }\n        }\n        // macOS switches deltaX and deltaY automatically when scrolling with shift key, so this is needed in other cases\n        if (evt.deltaX === 0 && evt.deltaY !== 0 && evt.shiftKey) {\n            pX = pY;\n            pY = 0;\n            sX = sY;\n            sY = 0;\n        }\n        // Fall-back if spin cannot be determined\n        if (pX && !sX) sX = pX < 1 ? -1 : 1;\n        if (pY && !sY) sY = pY < 1 ? -1 : 1;\n        return {\n            spinX: sX,\n            spinY: sY,\n            deltaX: pX,\n            deltaY: pY\n        };\n    };\n    var cap = function(val, max) {\n        return val > max ? max : val < -max ? -max : val;\n    };\n    var nextFrame = function() {\n        var raf;\n        if (typeof window !== \"undefined\") raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n        if (!raf) {\n            var lastTime = 0;\n            raf = function(callback) {\n                var currTime = new Date().getTime();\n                var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n                var id = setTimeout(function() {\n                    callback(currTime + timeToCall);\n                }, timeToCall);\n                lastTime = currTime + timeToCall;\n                return id;\n            };\n        }\n        return function(callback, context) {\n            var rest = [], len = arguments.length - 2;\n            while(len-- > 0)rest[len] = arguments[len + 2];\n            return context !== undefined ? raf(callback.bind.apply(callback, [\n                context\n            ].concat(rest))) : raf(callback);\n        };\n    }();\n    var cancelFrame = function() {\n        var caf;\n        var client = typeof window != \"undefined\";\n        if (client) caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame;\n        caf = caf || clearTimeout;\n        return client ? caf.bind(window) : caf;\n    }();\n    /**\n\t * @deprecated\n\t */ var shapePerimeterConnectionPoint = function(linkView, view, magnet, reference) {\n        var bbox;\n        var spot;\n        if (!magnet) {\n            // There is no magnet, try to make the best guess what is the\n            // wrapping SVG element. This is because we want this \"smart\"\n            // connection points to work out of the box without the\n            // programmer to put magnet marks to any of the subelements.\n            // For example, we want the function to work on basic.Path elements\n            // without any special treatment of such elements.\n            // The code below guesses the wrapping element based on\n            // one simple assumption. The wrapping elemnet is the\n            // first child of the scalable group if such a group exists\n            // or the first child of the rotatable group if not.\n            // This makese sense because usually the wrapping element\n            // is below any other sub element in the shapes.\n            var scalable = view.$(\".scalable\")[0];\n            var rotatable = view.$(\".rotatable\")[0];\n            if (scalable && scalable.firstChild) magnet = scalable.firstChild;\n            else if (rotatable && rotatable.firstChild) magnet = rotatable.firstChild;\n        }\n        if (magnet) {\n            spot = V(magnet).findIntersection(reference, linkView.paper.cells);\n            if (!spot) bbox = V(magnet).getBBox({\n                target: linkView.paper.cells\n            });\n        } else {\n            bbox = view.model.getBBox();\n            spot = bbox.intersectionWithLineFromCenterToPoint(reference);\n        }\n        return spot || bbox.center();\n    };\n    var isPercentage = function(val) {\n        return isString(val) && val.slice(-1) === \"%\";\n    };\n    var parseCssNumeric = function(val, restrictUnits) {\n        function getUnit(validUnitExp) {\n            // one or more numbers, followed by\n            // any number of (\n            //  `.`, followed by\n            //  one or more numbers\n            // ), followed by\n            // `validUnitExp`, followed by\n            // end of string\n            var matches = new RegExp(\"(?:\\\\d+(?:\\\\.\\\\d+)*)(\" + validUnitExp + \")$\").exec(val);\n            if (!matches) return null;\n            return matches[1];\n        }\n        var number = parseFloat(val);\n        // if `val` cannot be parsed as a number, return `null`\n        if (Number.isNaN(number)) return null;\n        // else: we know `output.value`\n        var output = {};\n        output.value = number;\n        // determine the unit\n        var validUnitExp;\n        if (restrictUnits == null) // no restriction\n        // accept any unit, as well as no unit\n        validUnitExp = \"[A-Za-z]*\";\n        else if (Array.isArray(restrictUnits)) {\n            // if this is an empty array, top restriction - return `null`\n            if (restrictUnits.length === 0) return null;\n            // else: restriction - an array of valid unit strings\n            validUnitExp = restrictUnits.join(\"|\");\n        } else if (isString(restrictUnits)) // restriction - a single valid unit string\n        validUnitExp = restrictUnits;\n        var unit = getUnit(validUnitExp);\n        // if we found no matches for `restrictUnits`, return `null`\n        if (unit === null) return null;\n        // else: we know the unit\n        output.unit = unit;\n        return output;\n    };\n    var NO_SPACE = 0;\n    function splitWordWithEOL(word, eol) {\n        var eolWords = word.split(eol);\n        var n = 1;\n        for(var j = 0, jl = eolWords.length - 1; j < jl; j++){\n            var replacement = [];\n            if (j > 0 || eolWords[0] !== \"\") replacement.push(NO_SPACE);\n            replacement.push(eol);\n            if (j < jl - 1 || eolWords[jl] !== \"\") replacement.push(NO_SPACE);\n            eolWords.splice.apply(eolWords, [\n                n,\n                0\n            ].concat(replacement));\n            n += replacement.length + 1;\n        }\n        return eolWords.filter(function(word) {\n            return word !== \"\";\n        });\n    }\n    function getLineHeight(heightValue, textElement) {\n        if (heightValue === null) // Default 1em lineHeight\n        return textElement.getBBox().height;\n        switch(heightValue.unit){\n            case \"em\":\n                return textElement.getBBox().height * heightValue.value;\n            case \"px\":\n            case \"\":\n                return heightValue.value;\n        }\n    }\n    var breakText = function(text, size, styles, opt) {\n        if (styles === void 0) styles = {};\n        if (opt === void 0) opt = {};\n        var width = size.width;\n        var height = size.height;\n        var svgDocument = opt.svgDocument || V(\"svg\").node;\n        var textSpan = V(\"tspan\").node;\n        var textElement = V(\"text\").attr(styles).append(textSpan).node;\n        var textNode = document.createTextNode(\"\");\n        // Prevent flickering\n        textElement.style.opacity = 0;\n        // Prevent FF from throwing an uncaught exception when `getBBox()`\n        // called on element that is not in the render tree (is not measurable).\n        // <tspan>.getComputedTextLength() returns always 0 in this case.\n        // Note that the `textElement` resp. `textSpan` can become hidden\n        // when it's appended to the DOM and a `display: none` CSS stylesheet\n        // rule gets applied.\n        textElement.style.display = \"block\";\n        textSpan.style.display = \"block\";\n        textSpan.appendChild(textNode);\n        svgDocument.appendChild(textElement); // lgtm [js/xss-through-dom]\n        if (!opt.svgDocument) document.body.appendChild(svgDocument);\n        var preserveSpaces = opt.preserveSpaces;\n        var space = \" \";\n        var separator = opt.separator || space;\n        var eol = opt.eol || \"\\n\";\n        var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\\w\\d]/;\n        var maxLineCount = opt.maxLineCount;\n        if (!isNumber(maxLineCount)) maxLineCount = Infinity;\n        var words = text.split(separator);\n        var full = [];\n        var lines = [];\n        var p, h;\n        var lineHeight;\n        if (preserveSpaces) V(textSpan).attr(\"xml:space\", \"preserve\");\n        for(var i = 0, l = 0, len = words.length; i < len; i++){\n            var word = words[i];\n            if (!word && !preserveSpaces) continue;\n            if (typeof word !== \"string\") continue;\n            var isEol = false;\n            if (eol && word.indexOf(eol) >= 0) {\n                // word contains end-of-line character\n                if (word.length > 1) {\n                    // separate word and continue cycle\n                    var eolWords = splitWordWithEOL(words[i], eol);\n                    words.splice.apply(words, [\n                        i,\n                        1\n                    ].concat(eolWords));\n                    i--;\n                    len = words.length;\n                    continue;\n                } else {\n                    // creates a new line\n                    if (preserveSpaces && typeof words[i - 1] === \"string\") {\n                        words.splice(i, NO_SPACE, \"\", NO_SPACE);\n                        len += 2;\n                        i--;\n                        continue;\n                    }\n                    lines[++l] = !preserveSpaces || typeof words[i + 1] === \"string\" ? \"\" : undefined;\n                    isEol = true;\n                }\n            }\n            if (!isEol) {\n                var data = void 0;\n                if (preserveSpaces) data = lines[l] !== undefined ? lines[l] + space + word : word;\n                else data = lines[l] ? lines[l] + space + word : word;\n                textNode.data = data;\n                if (textSpan.getComputedTextLength() <= width) {\n                    // the current line fits\n                    lines[l] = data;\n                    if (p || h) {\n                        // We were partitioning. Put rest of the word onto next line\n                        full[l++] = true;\n                        // cancel partitioning and splitting by hyphens\n                        p = 0;\n                        h = 0;\n                    }\n                } else {\n                    if (!lines[l] || p) {\n                        var partition = !!p;\n                        p = word.length - 1;\n                        if (partition || !p) {\n                            // word has only one character.\n                            if (!p) {\n                                if (!lines[l]) {\n                                    // we won't fit this text within our rect\n                                    lines = [];\n                                    break;\n                                }\n                                // partitioning didn't help on the non-empty line\n                                // try again, but this time start with a new line\n                                // cancel partitions created\n                                words.splice(i, 2, word + words[i + 1]);\n                                // adjust word length\n                                len--;\n                                full[l++] = true;\n                                i--;\n                                continue;\n                            }\n                            // move last letter to the beginning of the next word\n                            words[i] = word.substring(0, p);\n                            words[i + 1] = word.substring(p) + (words[i + 1] === undefined ? \"\" : words[i + 1]);\n                        } else {\n                            if (h) {\n                                // cancel splitting and put the words together again\n                                words.splice(i, 2, words[i] + words[i + 1]);\n                                h = 0;\n                            } else {\n                                var hyphenIndex = word.search(hyphen);\n                                if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {\n                                    h = hyphenIndex + 1;\n                                    p = 0;\n                                }\n                                // We initiate partitioning or splitting\n                                // split the long word into two words\n                                words.splice(i, 1, word.substring(0, h || p), word.substring(h || p));\n                                // adjust words length\n                                len++;\n                            }\n                            if (l && !full[l - 1]) // if the previous line is not full, try to fit max part of\n                            // the current word there\n                            l--;\n                        }\n                        if (!preserveSpaces || lines[l] !== \"\") i--;\n                        continue;\n                    }\n                    l++;\n                    i--;\n                }\n            }\n            var lastL = null;\n            if (lines.length > maxLineCount) lastL = maxLineCount - 1;\n            else if (height !== undefined) {\n                // if size.height is defined we have to check whether the height of the entire\n                // text exceeds the rect height\n                if (lineHeight === undefined && textNode.data !== \"\") {\n                    // use the same defaults as in V.prototype.text\n                    if (styles.lineHeight === \"auto\") lineHeight = getLineHeight({\n                        value: 1.5,\n                        unit: \"em\"\n                    }, textElement);\n                    else {\n                        var parsed = parseCssNumeric(styles.lineHeight, [\n                            \"em\",\n                            \"px\",\n                            \"\"\n                        ]);\n                        lineHeight = getLineHeight(parsed, textElement);\n                    }\n                }\n                if (lineHeight * lines.length > height) // remove overflowing lines\n                lastL = Math.floor(height / lineHeight) - 1;\n            }\n            if (lastL !== null) {\n                lines.splice(lastL + 1);\n                // add ellipsis\n                var ellipsis = opt.ellipsis;\n                if (!ellipsis || lastL < 0) break;\n                if (typeof ellipsis !== \"string\") ellipsis = \"\";\n                var lastLine = lines[lastL];\n                if (!lastLine && !isEol) break;\n                var k = lastLine.length;\n                var lastLineWithOmission, lastChar, separatorChar;\n                do {\n                    lastChar = lastLine[k];\n                    lastLineWithOmission = lastLine.substring(0, k);\n                    if (!lastChar) {\n                        separatorChar = typeof separator === \"string\" ? separator : \" \";\n                        lastLineWithOmission += separatorChar;\n                    } else if (lastChar.match(separator)) lastLineWithOmission += lastChar;\n                    lastLineWithOmission += ellipsis;\n                    textNode.data = lastLineWithOmission;\n                    if (textSpan.getComputedTextLength() <= width) {\n                        lines[lastL] = lastLineWithOmission;\n                        break;\n                    }\n                    k--;\n                }while (k >= 0);\n                break;\n            }\n        }\n        if (opt.svgDocument) // svg document was provided, remove the text element only\n        svgDocument.removeChild(textElement);\n        else // clean svg document\n        document.body.removeChild(svgDocument);\n        return lines.join(eol);\n    };\n    // Sanitize HTML\n    // Based on https://gist.github.com/ufologist/5a0da51b2b9ef1b861c30254172ac3c9\n    // Parses a string into an array of DOM nodes.\n    // Then outputs it back as a string.\n    var sanitizeHTML = function(html) {\n        // Ignores tags that are invalid inside a <div> tag (e.g. <body>, <head>)\n        // If documentContext (second parameter) is not specified or given as `null` or `undefined`, a new document is used.\n        // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.\n        // If keepScripts (last parameter) is `false`, scripts are not executed.\n        var output = $($.parseHTML(\"<div>\" + html + \"</div>\", null, false));\n        output.find(\"*\").each(function() {\n            var currentNode = this;\n            $.each(currentNode.attributes, function() {\n                var currentAttribute = this;\n                var attrName = currentAttribute.name;\n                var attrValue = currentAttribute.value;\n                // Remove attribute names that start with \"on\" (e.g. onload, onerror...).\n                // Remove attribute values that start with \"javascript:\" pseudo protocol (e.g. `href=\"javascript:alert(1)\"`).\n                if (attrName.startsWith(\"on\") || attrValue.startsWith(\"javascript:\") || attrValue.startsWith(\"data:\") || attrValue.startsWith(\"vbscript:\")) $(currentNode).removeAttr(attrName);\n            });\n        });\n        return output.html();\n    };\n    // Download `blob` as file with `fileName`.\n    // Does not work in IE9.\n    var downloadBlob = function(blob, fileName) {\n        if (window.navigator.msSaveBlob) // pulls up a save dialog\n        window.navigator.msSaveBlob(blob, fileName);\n        else {\n            // downloads directly in Chrome and Safari\n            // presents a save/open dialog in Firefox\n            // Firefox bug: `from` field in save dialog always shows `from:blob:`\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n            var url = window.URL.createObjectURL(blob);\n            var link = document.createElement(\"a\");\n            link.href = url;\n            link.download = fileName;\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n            window.URL.revokeObjectURL(url); // mark the url for garbage collection\n        }\n    };\n    // Download `dataUri` as file with `fileName`.\n    // Does not work in IE9.\n    var downloadDataUri = function(dataUri, fileName) {\n        var blob = dataUriToBlob(dataUri);\n        downloadBlob(blob, fileName);\n    };\n    // Convert an uri-encoded data component (possibly also base64-encoded) to a blob.\n    var dataUriToBlob = function(dataUri) {\n        // first, make sure there are no newlines in the data uri\n        dataUri = dataUri.replace(/\\s/g, \"\");\n        dataUri = decodeURIComponent(dataUri);\n        var firstCommaIndex = dataUri.indexOf(\",\"); // split dataUri as `dataTypeString`,`data`\n        var dataTypeString = dataUri.slice(0, firstCommaIndex); // e.g. 'data:image/jpeg;base64'\n        var mimeString = dataTypeString.split(\":\")[1].split(\";\")[0]; // e.g. 'image/jpeg'\n        var data = dataUri.slice(firstCommaIndex + 1);\n        var decodedString;\n        if (dataTypeString.indexOf(\"base64\") >= 0) decodedString = atob(data); // decode data\n        else // convert the decoded string to UTF-8\n        decodedString = unescape(encodeURIComponent(data));\n        // write the bytes of the string to a typed array\n        var ia = new Uint8Array(decodedString.length);\n        for(var i = 0; i < decodedString.length; i++)ia[i] = decodedString.charCodeAt(i);\n        return new Blob([\n            ia\n        ], {\n            type: mimeString\n        }); // return the typed array as Blob\n    };\n    // Read an image at `url` and return it as base64-encoded data uri.\n    // The mime type of the image is inferred from the `url` file extension.\n    // If data uri is provided as `url`, it is returned back unchanged.\n    // `callback` is a method with `err` as first argument and `dataUri` as second argument.\n    // Works with IE9.\n    var imageToDataUri = function(url, callback) {\n        if (!url || url.substr(0, 5) === \"data:\") // No need to convert to data uri if it is already in data uri.\n        // This not only convenient but desired. For example,\n        // IE throws a security error if data:image/svg+xml is used to render\n        // an image to the canvas and an attempt is made to read out data uri.\n        // Now if our image is already in data uri, there is no need to render it to the canvas\n        // and so we can bypass this error.\n        // Keep the async nature of the function.\n        return setTimeout(function() {\n            callback(null, url);\n        }, 0);\n        // chrome, IE10+\n        var modernHandler = function(xhr, callback) {\n            if (xhr.status === 200) {\n                var reader = new FileReader();\n                reader.onload = function(evt) {\n                    var dataUri = evt.target.result;\n                    callback(null, dataUri);\n                };\n                reader.onerror = function() {\n                    callback(new Error(\"Failed to load image \" + url));\n                };\n                reader.readAsDataURL(xhr.response);\n            } else callback(new Error(\"Failed to load image \" + url));\n        };\n        var legacyHandler = function(xhr, callback) {\n            var Uint8ToString = function(u8a) {\n                var CHUNK_SZ = 0x8000;\n                var c = [];\n                for(var i = 0; i < u8a.length; i += CHUNK_SZ)c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n                return c.join(\"\");\n            };\n            if (xhr.status === 200) {\n                var bytes = new Uint8Array(xhr.response);\n                var suffix = url.split(\".\").pop() || \"png\";\n                var map = {\n                    \"svg\": \"svg+xml\"\n                };\n                var meta = \"data:image/\" + (map[suffix] || suffix) + \";base64,\";\n                var b64encoded = meta + btoa(Uint8ToString(bytes));\n                callback(null, b64encoded);\n            } else callback(new Error(\"Failed to load image \" + url));\n        };\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, true);\n        xhr.addEventListener(\"error\", function() {\n            callback(new Error(\"Failed to load image \" + url));\n        });\n        xhr.responseType = window.FileReader ? \"blob\" : \"arraybuffer\";\n        xhr.addEventListener(\"load\", function() {\n            if (window.FileReader) modernHandler(xhr, callback);\n            else legacyHandler(xhr, callback);\n        });\n        xhr.send();\n    };\n    var getElementBBox = function(el) {\n        var $el = $(el);\n        if ($el.length === 0) throw new Error(\"Element not found\");\n        var element = $el[0];\n        var doc = element.ownerDocument;\n        var clientBBox = element.getBoundingClientRect();\n        var strokeWidthX = 0;\n        var strokeWidthY = 0;\n        // Firefox correction\n        if (element.ownerSVGElement) {\n            var vel = V(element);\n            var bbox = vel.getBBox({\n                target: vel.svg()\n            });\n            // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.\n            // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.\n            strokeWidthX = clientBBox.width - bbox.width;\n            strokeWidthY = clientBBox.height - bbox.height;\n        }\n        return {\n            x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,\n            y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,\n            width: clientBBox.width - strokeWidthX,\n            height: clientBBox.height - strokeWidthY\n        };\n    };\n    // Highly inspired by the jquery.sortElements plugin by Padolsey.\n    // See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\n    var sortElements = function(elements, comparator) {\n        var $elements = $(elements);\n        var placements = $elements.map(function() {\n            var sortElement = this;\n            var parentNode = sortElement.parentNode;\n            // Since the element itself will change position, we have\n            // to have some way of storing it's original position in\n            // the DOM. The easiest way is to have a 'flag' node:\n            var nextSibling = parentNode.insertBefore(document.createTextNode(\"\"), sortElement.nextSibling);\n            return function() {\n                if (parentNode === this) throw new Error(\"You can't sort elements if any one is a descendant of another.\");\n                // Insert before flag:\n                parentNode.insertBefore(this, nextSibling);\n                // Remove flag:\n                parentNode.removeChild(nextSibling);\n            };\n        });\n        return Array.prototype.sort.call($elements, comparator).each(function(i) {\n            placements[i].call(this);\n        });\n    };\n    // Sets attributes on the given element and its descendants based on the selector.\n    // `attrs` object: { [SELECTOR1]: { attrs1 }, [SELECTOR2]: { attrs2}, ... } e.g. { 'input': { color : 'red' }}\n    var setAttributesBySelector = function(element, attrs) {\n        var $element = $(element);\n        forIn(attrs, function(attrs, selector) {\n            var $elements = $element.find(selector).addBack().filter(selector);\n            // Make a special case for setting classes.\n            // We do not want to overwrite any existing class.\n            if (has$2(attrs, \"class\")) {\n                $elements.addClass(attrs[\"class\"]);\n                attrs = omit(attrs, \"class\");\n            }\n            $elements.attr(attrs);\n        });\n    };\n    // Return a new object with all four sides (top, right, bottom, left) in it.\n    // Value of each side is taken from the given argument (either number or object).\n    // Default value for a side is 0.\n    // Examples:\n    // normalizeSides(5) --> { top: 5, right: 5, bottom: 5, left: 5 }\n    // normalizeSides({ horizontal: 5 }) --> { top: 0, right: 5, bottom: 0, left: 5 }\n    // normalizeSides({ left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n    // normalizeSides({ horizontal: 10, left: 5 }) --> { top: 0, right: 10, bottom: 0, left: 5 }\n    // normalizeSides({ horizontal: 0, left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n    var normalizeSides = function(box) {\n        if (Object(box) !== box) {\n            var val = 0; // `val` left as 0 if `box` cannot be understood as finite number\n            if (isFinite(box)) val = +box;\n             // actually also accepts string numbers (e.g. '100')\n            return {\n                top: val,\n                right: val,\n                bottom: val,\n                left: val\n            };\n        }\n        // `box` is an object\n        var top, right, bottom, left;\n        top = right = bottom = left = 0;\n        if (isFinite(box.vertical)) top = bottom = +box.vertical;\n        if (isFinite(box.horizontal)) right = left = +box.horizontal;\n        if (isFinite(box.top)) top = +box.top;\n         // overwrite vertical\n        if (isFinite(box.right)) right = +box.right;\n         // overwrite horizontal\n        if (isFinite(box.bottom)) bottom = +box.bottom;\n         // overwrite vertical\n        if (isFinite(box.left)) left = +box.left;\n         // overwrite horizontal\n        return {\n            top: top,\n            right: right,\n            bottom: bottom,\n            left: left\n        };\n    };\n    var timing = {\n        linear: function(t) {\n            return t;\n        },\n        quad: function(t) {\n            return t * t;\n        },\n        cubic: function(t) {\n            return t * t * t;\n        },\n        inout: function(t) {\n            if (t <= 0) return 0;\n            if (t >= 1) return 1;\n            var t2 = t * t;\n            var t3 = t2 * t;\n            return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n        },\n        exponential: function(t) {\n            return Math.pow(2, 10 * (t - 1));\n        },\n        bounce: function(t) {\n            for(var a = 0, b = 1;; a += b, b /= 2)if (t >= (7 - 4 * a) / 11) {\n                var q = (11 - 6 * a - 11 * t) / 4;\n                return -q * q + b * b;\n            }\n        },\n        reverse: function(f) {\n            return function(t) {\n                return 1 - f(1 - t);\n            };\n        },\n        reflect: function(f) {\n            return function(t) {\n                return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\n            };\n        },\n        clamp: function(f, n, x) {\n            n = n || 0;\n            x = x || 1;\n            return function(t) {\n                var r = f(t);\n                return r < n ? n : r > x ? x : r;\n            };\n        },\n        back: function(s) {\n            if (!s) s = 1.70158;\n            return function(t) {\n                return t * t * ((s + 1) * t - s);\n            };\n        },\n        elastic: function(x) {\n            if (!x) x = 1.5;\n            return function(t) {\n                return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);\n            };\n        }\n    };\n    var interpolate = {\n        number: function(a, b) {\n            var d = b - a;\n            return function(t) {\n                return a + d * t;\n            };\n        },\n        object: function(a, b) {\n            var s = Object.keys(a);\n            return function(t) {\n                var i, p;\n                var r = {};\n                for(i = s.length - 1; i != -1; i--){\n                    p = s[i];\n                    r[p] = a[p] + (b[p] - a[p]) * t;\n                }\n                return r;\n            };\n        },\n        hexColor: function(a, b) {\n            var ca = parseInt(a.slice(1), 16);\n            var cb = parseInt(b.slice(1), 16);\n            var ra = ca & 0x0000ff;\n            var rd = (cb & 0x0000ff) - ra;\n            var ga = ca & 0x00ff00;\n            var gd = (cb & 0x00ff00) - ga;\n            var ba = ca & 0xff0000;\n            var bd = (cb & 0xff0000) - ba;\n            return function(t) {\n                var r = ra + rd * t & 0x000000ff;\n                var g = ga + gd * t & 0x0000ff00;\n                var b = ba + bd * t & 0x00ff0000;\n                return \"#\" + (16777216 | r | g | b).toString(16).slice(1);\n            };\n        },\n        unit: function(a, b) {\n            var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;\n            var ma = r.exec(a);\n            var mb = r.exec(b);\n            var p = mb[1].indexOf(\".\");\n            var f = p > 0 ? mb[1].length - p - 1 : 0;\n            a = +ma[1];\n            var d = +mb[1] - a;\n            var u = ma[2];\n            return function(t) {\n                return (a + d * t).toFixed(f) + u;\n            };\n        }\n    };\n    // SVG filters.\n    // (values in parentheses are default values)\n    var filter = {\n        // `color` ... outline color ('blue')\n        // `width`... outline width (1)\n        // `opacity` ... outline opacity (1)\n        // `margin` ... gap between outline and the element (2)\n        outline: function(args) {\n            var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" /><feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" /><feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/><feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/><feMerge><feMergeNode in=\"outline\"/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n            var margin = Number.isFinite(args.margin) ? args.margin : 2;\n            var width = Number.isFinite(args.width) ? args.width : 1;\n            return template(tpl)({\n                color: args.color || \"blue\",\n                opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n                outerRadius: margin + width,\n                innerRadius: margin\n            });\n        },\n        // `color` ... color ('red')\n        // `width`... width (1)\n        // `blur` ... blur (0)\n        // `opacity` ... opacity (1)\n        highlight: function(args) {\n            var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/><feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/><feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/><feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/></filter>';\n            return template(tpl)({\n                color: args.color || \"red\",\n                width: Number.isFinite(args.width) ? args.width : 1,\n                blur: Number.isFinite(args.blur) ? args.blur : 0,\n                opacity: Number.isFinite(args.opacity) ? args.opacity : 1\n            });\n        },\n        // `x` ... horizontal blur (2)\n        // `y` ... vertical blur (optional)\n        blur: function(args) {\n            var x = Number.isFinite(args.x) ? args.x : 2;\n            return template('<filter><feGaussianBlur stdDeviation=\"${stdDeviation}\"/></filter>')({\n                stdDeviation: Number.isFinite(args.y) ? [\n                    x,\n                    args.y\n                ] : x\n            });\n        },\n        // `dx` ... horizontal shift (0)\n        // `dy` ... vertical shift (0)\n        // `blur` ... blur (4)\n        // `color` ... color ('black')\n        // `opacity` ... opacity (1)\n        dropShadow: function(args) {\n            var tpl = \"SVGFEDropShadowElement\" in window ? '<filter><feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\"/></filter>' : '<filter><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\"/><feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\"/><feFlood flood-color=\"${color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"${opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n            return template(tpl)({\n                dx: args.dx || 0,\n                dy: args.dy || 0,\n                opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n                color: args.color || \"black\",\n                blur: Number.isFinite(args.blur) ? args.blur : 4\n            });\n        },\n        // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.\n        grayscale: function(args) {\n            var amount = Number.isFinite(args.amount) ? args.amount : 1;\n            return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/></filter>')({\n                a: 0.2126 + 0.7874 * (1 - amount),\n                b: 0.7152 - 0.7152 * (1 - amount),\n                c: 0.0722 - 0.0722 * (1 - amount),\n                d: 0.2126 - 0.2126 * (1 - amount),\n                e: 0.7152 + 0.2848 * (1 - amount),\n                f: 0.0722 - 0.0722 * (1 - amount),\n                g: 0.2126 - 0.2126 * (1 - amount),\n                h: 0.0722 + 0.9278 * (1 - amount)\n            });\n        },\n        // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.\n        sepia: function(args) {\n            var amount = Number.isFinite(args.amount) ? args.amount : 1;\n            return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/></filter>')({\n                a: 0.393 + 0.607 * (1 - amount),\n                b: 0.769 - 0.769 * (1 - amount),\n                c: 0.189 - 0.189 * (1 - amount),\n                d: 0.349 - 0.349 * (1 - amount),\n                e: 0.686 + 0.314 * (1 - amount),\n                f: 0.168 - 0.168 * (1 - amount),\n                g: 0.272 - 0.272 * (1 - amount),\n                h: 0.534 - 0.534 * (1 - amount),\n                i: 0.131 + 0.869 * (1 - amount)\n            });\n        },\n        // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.\n        saturate: function(args) {\n            var amount = Number.isFinite(args.amount) ? args.amount : 1;\n            return template('<filter><feColorMatrix type=\"saturate\" values=\"${amount}\"/></filter>')({\n                amount: 1 - amount\n            });\n        },\n        // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).\n        hueRotate: function(args) {\n            return template('<filter><feColorMatrix type=\"hueRotate\" values=\"${angle}\"/></filter>')({\n                angle: args.angle || 0\n            });\n        },\n        // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.\n        invert: function(args) {\n            var amount = Number.isFinite(args.amount) ? args.amount : 1;\n            return template('<filter><feComponentTransfer><feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/></feComponentTransfer></filter>')({\n                amount: amount,\n                amount2: 1 - amount\n            });\n        },\n        // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n        brightness: function(args) {\n            return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\"/><feFuncG type=\"linear\" slope=\"${amount}\"/><feFuncB type=\"linear\" slope=\"${amount}\"/></feComponentTransfer></filter>')({\n                amount: Number.isFinite(args.amount) ? args.amount : 1\n            });\n        },\n        // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n        contrast: function(args) {\n            var amount = Number.isFinite(args.amount) ? args.amount : 1;\n            return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/></feComponentTransfer></filter>')({\n                amount: amount,\n                amount2: .5 - amount / 2\n            });\n        }\n    };\n    var format = {\n        // Formatting numbers via the Python Format Specification Mini-language.\n        // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n        // Heavilly inspired by the D3.js library implementation.\n        number: function(specifier, value, locale) {\n            locale = locale || {\n                currency: [\n                    \"$\",\n                    \"\"\n                ],\n                decimal: \".\",\n                thousands: \",\",\n                grouping: [\n                    3\n                ]\n            };\n            // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n            // [[fill]align][sign][symbol][0][width][,][.precision][type]\n            var re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n            var match = re.exec(specifier);\n            var fill = match[1] || \" \";\n            var align = match[2] || \">\";\n            var sign = match[3] || \"\";\n            var symbol = match[4] || \"\";\n            var zfill = match[5];\n            var width = +match[6];\n            var comma = match[7];\n            var precision = match[8];\n            var type = match[9];\n            var scale = 1;\n            var prefix = \"\";\n            var suffix = \"\";\n            var integer = false;\n            if (precision) precision = +precision.substring(1);\n            if (zfill || fill === \"0\" && align === \"=\") {\n                zfill = fill = \"0\";\n                align = \"=\";\n                if (comma) width -= Math.floor((width - 1) / 4);\n            }\n            switch(type){\n                case \"n\":\n                    comma = true;\n                    type = \"g\";\n                    break;\n                case \"%\":\n                    scale = 100;\n                    suffix = \"%\";\n                    type = \"f\";\n                    break;\n                case \"p\":\n                    scale = 100;\n                    suffix = \"%\";\n                    type = \"r\";\n                    break;\n                case \"b\":\n                case \"o\":\n                case \"x\":\n                case \"X\":\n                    if (symbol === \"#\") prefix = \"0\" + type.toLowerCase();\n                    break;\n                case \"c\":\n                case \"d\":\n                    integer = true;\n                    precision = 0;\n                    break;\n                case \"s\":\n                    scale = -1;\n                    type = \"r\";\n                    break;\n            }\n            if (symbol === \"$\") {\n                prefix = locale.currency[0];\n                suffix = locale.currency[1];\n            }\n            // If no precision is specified for `'r'`, fallback to general notation.\n            if (type == \"r\" && !precision) type = \"g\";\n            // Ensure that the requested precision is in the supported range.\n            if (precision != null) {\n                if (type == \"g\") precision = Math.max(1, Math.min(21, precision));\n                else if (type == \"e\" || type == \"f\") precision = Math.max(0, Math.min(20, precision));\n            }\n            var zcomma = zfill && comma;\n            // Return the empty string for floats formatted as ints.\n            if (integer && value % 1) return \"\";\n            // Convert negative to positive, and record the sign prefix.\n            var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, \"-\") : sign;\n            var fullSuffix = suffix;\n            // Apply the scale, computing it from the value's exponent for si format.\n            // Preserve the existing suffix, if any, such as the currency symbol.\n            if (scale < 0) {\n                var unit = this.prefix(value, precision);\n                value = unit.scale(value);\n                fullSuffix = unit.symbol + suffix;\n            } else value *= scale;\n            // Convert to the desired precision.\n            value = this.convert(type, value, precision);\n            // Break the value into the integer part (before) and decimal part (after).\n            var i = value.lastIndexOf(\".\");\n            var before = i < 0 ? value : value.substring(0, i);\n            var after = i < 0 ? \"\" : locale.decimal + value.substring(i + 1);\n            function formatGroup(value) {\n                var i = value.length;\n                var t = [];\n                var j = 0;\n                var g = locale.grouping[0];\n                while(i > 0 && g > 0){\n                    t.push(value.substring(i -= g, i + g));\n                    g = locale.grouping[j = (j + 1) % locale.grouping.length];\n                }\n                return t.reverse().join(locale.thousands);\n            }\n            // If the fill character is not `'0'`, grouping is applied before padding.\n            if (!zfill && comma && locale.grouping) before = formatGroup(before);\n            var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);\n            var padding = length < width ? new Array(length = width - length + 1).join(fill) : \"\";\n            // If the fill character is `'0'`, grouping is applied after padding.\n            if (zcomma) before = formatGroup(padding + before);\n            // Apply prefix.\n            negative += prefix;\n            // Rejoin integer and decimal parts.\n            value = before + after;\n            return (align === \"<\" ? negative + value + padding : align === \">\" ? padding + negative + value : align === \"^\" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;\n        },\n        // Formatting string via the Python Format string.\n        // See https://docs.python.org/2/library/string.html#format-string-syntax)\n        string: function(formatString, value) {\n            var fieldDelimiterIndex;\n            var fieldDelimiter = \"{\";\n            var endPlaceholder = false;\n            var formattedStringArray = [];\n            while((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1){\n                var pieceFormattedString, formatSpec, fieldName;\n                pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);\n                if (endPlaceholder) {\n                    formatSpec = pieceFormattedString.split(\":\");\n                    fieldName = formatSpec.shift().split(\".\");\n                    pieceFormattedString = value;\n                    for(var i = 0; i < fieldName.length; i++)pieceFormattedString = pieceFormattedString[fieldName[i]];\n                    if (formatSpec.length) pieceFormattedString = this.number(formatSpec, pieceFormattedString);\n                }\n                formattedStringArray.push(pieceFormattedString);\n                formatString = formatString.slice(fieldDelimiterIndex + 1);\n                endPlaceholder = !endPlaceholder;\n                fieldDelimiter = endPlaceholder ? \"}\" : \"{\";\n            }\n            formattedStringArray.push(formatString);\n            return formattedStringArray.join(\"\");\n        },\n        convert: function(type, value, precision) {\n            switch(type){\n                case \"b\":\n                    return value.toString(2);\n                case \"c\":\n                    return String.fromCharCode(value);\n                case \"o\":\n                    return value.toString(8);\n                case \"x\":\n                    return value.toString(16);\n                case \"X\":\n                    return value.toString(16).toUpperCase();\n                case \"g\":\n                    return value.toPrecision(precision);\n                case \"e\":\n                    return value.toExponential(precision);\n                case \"f\":\n                    return value.toFixed(precision);\n                case \"r\":\n                    return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));\n                default:\n                    return value + \"\";\n            }\n        },\n        round: function(value, precision) {\n            return precision ? Math.round(value * (precision = Math.pow(10, precision))) / precision : Math.round(value);\n        },\n        precision: function(value, precision) {\n            return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);\n        },\n        prefix: function(value, precision) {\n            var prefixes = [\n                \"y\",\n                \"z\",\n                \"a\",\n                \"f\",\n                \"p\",\n                \"n\",\n                \"\\xb5\",\n                \"m\",\n                \"\",\n                \"k\",\n                \"M\",\n                \"G\",\n                \"T\",\n                \"P\",\n                \"E\",\n                \"Z\",\n                \"Y\"\n            ].map(function(d, i) {\n                var k = Math.pow(10, Math.abs(8 - i) * 3);\n                return {\n                    scale: i > 8 ? function(d) {\n                        return d / k;\n                    } : function(d) {\n                        return d * k;\n                    },\n                    symbol: d\n                };\n            });\n            var i = 0;\n            if (value) {\n                if (value < 0) value *= -1;\n                if (precision) value = this.round(value, this.precision(value, precision));\n                i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n                i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n            }\n            return prefixes[8 + i / 3];\n        }\n    };\n    /*\n\t    Pre-compile the HTML to be used as a template.\n\t*/ var template = function(html) {\n        /*\n\t        Must support the variation in templating syntax found here:\n\t        https://lodash.com/docs#template\n\t    */ var regex = /<%= ([^ ]+) %>|\\$\\{ ?([^{} ]+) ?\\}|\\{\\{([^{} ]+)\\}\\}/g;\n        return function(data) {\n            data = data || {};\n            return html.replace(regex, function(match) {\n                var args = Array.from(arguments);\n                var attr = args.slice(1, 4).find(function(_attr) {\n                    return !!_attr;\n                });\n                var attrArray = attr.split(\".\");\n                var value = data[attrArray.shift()];\n                while(value !== undefined && attrArray.length)value = value[attrArray.shift()];\n                return value !== undefined ? value : \"\";\n            });\n        };\n    };\n    /**\n\t * @param {Element} el Element, which content is intent to display in full-screen mode, 'window.top.document.body' is default.\n\t */ var toggleFullScreen = function(el) {\n        var topDocument = window.top.document;\n        el = el || topDocument.body;\n        function prefixedResult(el, prop) {\n            var prefixes = [\n                \"webkit\",\n                \"moz\",\n                \"ms\",\n                \"o\",\n                \"\"\n            ];\n            for(var i = 0; i < prefixes.length; i++){\n                var prefix = prefixes[i];\n                var propName = prefix ? prefix + prop : prop.substr(0, 1).toLowerCase() + prop.substr(1);\n                if (el[propName] !== undefined) return isFunction(el[propName]) ? el[propName]() : el[propName];\n            }\n        }\n        if (prefixedResult(topDocument, \"FullscreenElement\") || prefixedResult(topDocument, \"FullScreenElement\")) prefixedResult(topDocument, \"ExitFullscreen\") || // Spec.\n        prefixedResult(topDocument, \"CancelFullScreen\"); // Firefox\n        else prefixedResult(el, \"RequestFullscreen\") || // Spec.\n        prefixedResult(el, \"RequestFullScreen\"); // Firefox\n    };\n    var noop = function() {};\n    // Clone `cells` returning an object that maps the original cell ID to the clone. The number\n    // of clones is exactly the same as the `cells.length`.\n    // This function simply clones all the `cells`. However, it also reconstructs\n    // all the `source/target` and `parent/embed` references within the `cells`.\n    // This is the main difference from the `cell.clone()` method. The\n    // `cell.clone()` method works on one single cell only.\n    // For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n    // returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n    // the source and target of the link `L2` is changed to point to `A2` and `B2`.\n    function cloneCells(cells) {\n        cells = uniq(cells);\n        // A map of the form [original cell ID] -> [clone] helping\n        // us to reconstruct references for source/target and parent/embeds.\n        // This is also the returned value.\n        var cloneMap = toArray(cells).reduce(function(map, cell) {\n            map[cell.id] = cell.clone();\n            return map;\n        }, {});\n        toArray(cells).forEach(function(cell) {\n            var clone = cloneMap[cell.id];\n            // assert(clone exists)\n            if (clone.isLink()) {\n                var source = clone.source();\n                var target = clone.target();\n                if (source.id && cloneMap[source.id]) // Source points to an element and the element is among the clones.\n                // => Update the source of the cloned link.\n                clone.prop(\"source/id\", cloneMap[source.id].id);\n                if (target.id && cloneMap[target.id]) // Target points to an element and the element is among the clones.\n                // => Update the target of the cloned link.\n                clone.prop(\"target/id\", cloneMap[target.id].id);\n            }\n            // Find the parent of the original cell\n            var parent = cell.get(\"parent\");\n            if (parent && cloneMap[parent]) clone.set(\"parent\", cloneMap[parent].id);\n            // Find the embeds of the original cell\n            var embeds = toArray(cell.get(\"embeds\")).reduce(function(newEmbeds, embed) {\n                // Embedded cells that are not being cloned can not be carried\n                // over with other embedded cells.\n                if (cloneMap[embed]) newEmbeds.push(cloneMap[embed].id);\n                return newEmbeds;\n            }, []);\n            if (!isEmpty(embeds)) clone.set(\"embeds\", embeds);\n        });\n        return cloneMap;\n    }\n    var validPropertiesList = [\n        \"checked\",\n        \"selected\",\n        \"disabled\",\n        \"readOnly\",\n        \"contentEditable\",\n        \"value\",\n        \"indeterminate\"\n    ];\n    var validProperties = validPropertiesList.reduce(function(acc, key) {\n        acc[key] = true;\n        return acc;\n    }, {});\n    var props$1 = {\n        qualify: function(properties) {\n            return isPlainObject(properties);\n        },\n        set: function(properties, _, node) {\n            Object.keys(properties).forEach(function(key) {\n                if (validProperties[key] && key in node) {\n                    var value = properties[key];\n                    if (node.tagName === \"SELECT\" && Array.isArray(value)) Array.from(node.options).forEach(function(option, index) {\n                        option.selected = value.includes(option.value);\n                    });\n                    else node[key] = value;\n                }\n            });\n        }\n    };\n    function setWrapper(attrName, dimension) {\n        return function(value, refBBox) {\n            var isValuePercentage = isPercentage(value);\n            value = parseFloat(value);\n            if (isValuePercentage) value /= 100;\n            var attrs = {};\n            if (isFinite(value)) {\n                var attrValue = isValuePercentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);\n                attrs[attrName] = attrValue;\n            }\n            return attrs;\n        };\n    }\n    function positionWrapper(axis, dimension, origin) {\n        return function(value, refBBox) {\n            var valuePercentage = isPercentage(value);\n            value = parseFloat(value);\n            if (valuePercentage) value /= 100;\n            var delta;\n            if (isFinite(value)) {\n                var refOrigin = refBBox[origin]();\n                if (valuePercentage || value > 0 && value < 1) delta = refOrigin[axis] + refBBox[dimension] * value;\n                else delta = refOrigin[axis] + value;\n            }\n            var point = Point();\n            point[axis] = delta || 0;\n            return point;\n        };\n    }\n    function offsetWrapper(axis, dimension, corner) {\n        return function(value, nodeBBox) {\n            var delta;\n            if (value === \"middle\") delta = nodeBBox[dimension] / 2;\n            else if (value === corner) delta = nodeBBox[dimension];\n            else if (isFinite(value)) // TODO: or not to do a breaking change?\n            delta = value > -1 && value < 1 ? -nodeBBox[dimension] * value : -value;\n            else if (isPercentage(value)) delta = nodeBBox[dimension] * parseFloat(value) / 100;\n            else delta = 0;\n            var point = Point();\n            point[axis] = -(nodeBBox[axis] + delta);\n            return point;\n        };\n    }\n    function shapeWrapper(shapeConstructor, opt) {\n        var cacheName = \"joint-shape\";\n        var resetOffset = opt && opt.resetOffset;\n        return function(value, refBBox, node) {\n            var $node = $(node);\n            var cache = $node.data(cacheName);\n            if (!cache || cache.value !== value) {\n                // only recalculate if value has changed\n                var cachedShape = shapeConstructor(value);\n                cache = {\n                    value: value,\n                    shape: cachedShape,\n                    shapeBBox: cachedShape.bbox()\n                };\n                $node.data(cacheName, cache);\n            }\n            var shape = cache.shape.clone();\n            var shapeBBox = cache.shapeBBox.clone();\n            var shapeOrigin = shapeBBox.origin();\n            var refOrigin = refBBox.origin();\n            shapeBBox.x = refOrigin.x;\n            shapeBBox.y = refOrigin.y;\n            var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);\n            // `maxRectScaleToFit` can give Infinity if width or height is 0\n            var sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;\n            var sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;\n            shape.scale(sx, sy, shapeOrigin);\n            if (resetOffset) shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n            return shape;\n        };\n    }\n    // `d` attribute for SVGPaths\n    function dWrapper(opt) {\n        function pathConstructor(value) {\n            return new Path(V.normalizePathData(value));\n        }\n        var shape = shapeWrapper(pathConstructor, opt);\n        return function(value, refBBox, node) {\n            var path = shape(value, refBBox, node);\n            return {\n                d: path.serialize()\n            };\n        };\n    }\n    // `points` attribute for SVGPolylines and SVGPolygons\n    function pointsWrapper(opt) {\n        var shape = shapeWrapper(Polyline, opt);\n        return function(value, refBBox, node) {\n            var polyline = shape(value, refBBox, node);\n            return {\n                points: polyline.serialize()\n            };\n        };\n    }\n    function atConnectionWrapper(method, opt) {\n        var zeroVector = new Point(1, 0);\n        return function(value) {\n            var p, angle;\n            var tangent = this[method](value);\n            if (tangent) {\n                angle = opt.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n                p = tangent.start;\n            } else {\n                p = this.path.start;\n                angle = 0;\n            }\n            if (angle === 0) return {\n                transform: \"translate(\" + p.x + \",\" + p.y + \")\"\n            };\n            return {\n                transform: \"translate(\" + p.x + \",\" + p.y + \") rotate(\" + angle + \")\"\n            };\n        };\n    }\n    function setIfChangedWrapper(attribute) {\n        return function setIfChanged(value, _, node) {\n            var vel = V(node);\n            if (vel.attr(attribute) === value) return;\n            vel.attr(attribute, value);\n        };\n    }\n    function isTextInUse(_value, _node, attrs) {\n        return attrs.text !== undefined;\n    }\n    function isLinkView() {\n        return this.model.isLink();\n    }\n    function contextMarker(context) {\n        var marker = {};\n        // Stroke\n        // The context 'fill' is disregared here. The usual case is to use the marker with a connection\n        // (for which 'fill' attribute is set to 'none').\n        var stroke = context.stroke;\n        if (typeof stroke === \"string\") {\n            marker[\"stroke\"] = stroke;\n            marker[\"fill\"] = stroke;\n        }\n        // Opacity\n        // Again the context 'fill-opacity' is ignored.\n        var strokeOpacity = context.strokeOpacity;\n        if (strokeOpacity === undefined) strokeOpacity = context[\"stroke-opacity\"];\n        if (strokeOpacity === undefined) strokeOpacity = context.opacity;\n        if (strokeOpacity !== undefined) {\n            marker[\"stroke-opacity\"] = strokeOpacity;\n            marker[\"fill-opacity\"] = strokeOpacity;\n        }\n        return marker;\n    }\n    function setPaintURL(def) {\n        var ref = this;\n        var paper = ref.paper;\n        var url = def.type === \"pattern\" ? paper.definePattern(def) : paper.defineGradient(def);\n        return \"url(#\" + url + \")\";\n    }\n    var attributesNS = {\n        xlinkShow: {\n            set: \"xlink:show\"\n        },\n        xlinkRole: {\n            set: \"xlink:role\"\n        },\n        xlinkType: {\n            set: \"xlink:type\"\n        },\n        xlinkArcrole: {\n            set: \"xlink:arcrole\"\n        },\n        xlinkTitle: {\n            set: \"xlink:title\"\n        },\n        xlinkActuate: {\n            set: \"xlink:actuate\"\n        },\n        xmlSpace: {\n            set: \"xml:space\"\n        },\n        xmlBase: {\n            set: \"xml:base\"\n        },\n        xmlLang: {\n            set: \"xml:lang\"\n        },\n        preserveAspectRatio: {\n            set: \"preserveAspectRatio\"\n        },\n        requiredExtension: {\n            set: \"requiredExtension\"\n        },\n        requiredFeatures: {\n            set: \"requiredFeatures\"\n        },\n        systemLanguage: {\n            set: \"systemLanguage\"\n        },\n        externalResourcesRequired: {\n            set: \"externalResourceRequired\"\n        },\n        href: {\n            set: setIfChangedWrapper(\"href\")\n        },\n        xlinkHref: {\n            set: setIfChangedWrapper(\"xlink:href\")\n        },\n        filter: {\n            qualify: isPlainObject,\n            set: function(filter) {\n                return \"url(#\" + this.paper.defineFilter(filter) + \")\";\n            }\n        },\n        fill: {\n            qualify: isPlainObject,\n            set: setPaintURL\n        },\n        stroke: {\n            qualify: isPlainObject,\n            set: setPaintURL\n        },\n        sourceMarker: {\n            qualify: isPlainObject,\n            set: function(marker, refBBox, node, attrs) {\n                marker = assign(contextMarker(attrs), marker);\n                return {\n                    \"marker-start\": \"url(#\" + this.paper.defineMarker(marker) + \")\"\n                };\n            }\n        },\n        targetMarker: {\n            qualify: isPlainObject,\n            set: function(marker, refBBox, node, attrs) {\n                marker = assign(contextMarker(attrs), {\n                    \"transform\": \"rotate(180)\"\n                }, marker);\n                return {\n                    \"marker-end\": \"url(#\" + this.paper.defineMarker(marker) + \")\"\n                };\n            }\n        },\n        vertexMarker: {\n            qualify: isPlainObject,\n            set: function(marker, refBBox, node, attrs) {\n                marker = assign(contextMarker(attrs), marker);\n                return {\n                    \"marker-mid\": \"url(#\" + this.paper.defineMarker(marker) + \")\"\n                };\n            }\n        },\n        text: {\n            qualify: function(_text, _node, attrs) {\n                return !attrs.textWrap || !isPlainObject(attrs.textWrap);\n            },\n            set: function(text, refBBox, node, attrs) {\n                var $node = $(node);\n                var cacheName = \"joint-text\";\n                var cache = $node.data(cacheName);\n                var textAttrs = pick(attrs, \"lineHeight\", \"annotations\", \"textPath\", \"x\", \"textVerticalAnchor\", \"eol\", \"displayEmpty\");\n                // eval `x` if using calc()\n                var x = textAttrs.x;\n                if (isCalcAttribute(x)) textAttrs.x = evalCalcAttribute(x, refBBox);\n                var fontSizeAttr = attrs[\"font-size\"] || attrs[\"fontSize\"];\n                if (isCalcAttribute(fontSizeAttr)) fontSizeAttr = evalCalcAttribute(fontSizeAttr, refBBox);\n                var fontSize = textAttrs.fontSize = fontSizeAttr;\n                var textHash = JSON.stringify([\n                    text,\n                    textAttrs\n                ]);\n                // Update the text only if there was a change in the string\n                // or any of its attributes.\n                if (cache === undefined || cache !== textHash) {\n                    // Chrome bug:\n                    // Tspans positions defined as `em` are not updated\n                    // when container `font-size` change.\n                    if (fontSize) node.setAttribute(\"font-size\", fontSize);\n                    // Text Along Path Selector\n                    var textPath = textAttrs.textPath;\n                    if (isObject$1(textPath)) {\n                        var pathSelector = textPath.selector;\n                        if (typeof pathSelector === \"string\") {\n                            var pathNode = this.findBySelector(pathSelector)[0];\n                            if (pathNode instanceof SVGPathElement) textAttrs.textPath = assign({\n                                \"xlink:href\": \"#\" + pathNode.id\n                            }, textPath);\n                        }\n                    }\n                    V(node).text(\"\" + text, textAttrs);\n                    $node.data(cacheName, textHash);\n                }\n            }\n        },\n        textWrap: {\n            qualify: isPlainObject,\n            set: function(value, refBBox, node, attrs) {\n                var size = {};\n                // option `width`\n                var width = value.width || 0;\n                if (isPercentage(width)) size.width = refBBox.width * parseFloat(width) / 100;\n                else if (isCalcAttribute(width)) size.width = Number(evalCalcAttribute(width, refBBox));\n                else {\n                    if (value.width === null) // breakText() requires width to be specified.\n                    size.width = Infinity;\n                    else if (width <= 0) size.width = refBBox.width + width;\n                    else size.width = width;\n                }\n                // option `height`\n                var height = value.height || 0;\n                if (isPercentage(height)) size.height = refBBox.height * parseFloat(height) / 100;\n                else if (isCalcAttribute(height)) size.height = Number(evalCalcAttribute(height, refBBox));\n                else {\n                    if (value.height === null) ;\n                    else if (height <= 0) size.height = refBBox.height + height;\n                    else size.height = height;\n                }\n                // option `text`\n                var wrappedText;\n                var text = value.text;\n                if (text === undefined) text = attrs.text;\n                if (text !== undefined) {\n                    var breakTextFn = value.breakText || breakText;\n                    var fontSizeAttr = attrs[\"font-size\"] || attrs.fontSize;\n                    wrappedText = breakTextFn(\"\" + text, size, {\n                        \"font-weight\": attrs[\"font-weight\"] || attrs.fontWeight,\n                        \"font-size\": isCalcAttribute(fontSizeAttr) ? evalCalcAttribute(fontSizeAttr, refBBox) : fontSizeAttr,\n                        \"font-family\": attrs[\"font-family\"] || attrs.fontFamily,\n                        \"lineHeight\": attrs.lineHeight,\n                        \"letter-spacing\": \"letter-spacing\" in attrs ? attrs[\"letter-spacing\"] : attrs.letterSpacing\n                    }, {\n                        // Provide an existing SVG Document here\n                        // instead of creating a temporary one over again.\n                        svgDocument: this.paper.svg,\n                        ellipsis: value.ellipsis,\n                        hyphen: value.hyphen,\n                        maxLineCount: value.maxLineCount,\n                        preserveSpaces: value.preserveSpaces\n                    });\n                } else wrappedText = \"\";\n                attributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n            }\n        },\n        title: {\n            qualify: function(title, node) {\n                // HTMLElement title is specified via an attribute (i.e. not an element)\n                return node instanceof SVGElement;\n            },\n            set: function(title, refBBox, node) {\n                var $node = $(node);\n                var cacheName = \"joint-title\";\n                var cache = $node.data(cacheName);\n                if (cache === undefined || cache !== title) {\n                    $node.data(cacheName, title);\n                    if (node.tagName === \"title\") {\n                        // The target node is a <title> element.\n                        node.textContent = title;\n                        return;\n                    }\n                    // Generally <title> element should be the first child element of its parent.\n                    var firstChild = node.firstElementChild;\n                    if (firstChild && firstChild.tagName === \"title\") // Update an existing title\n                    firstChild.textContent = title;\n                    else {\n                        // Create a new title\n                        var titleNode = document.createElementNS(node.namespaceURI, \"title\");\n                        titleNode.textContent = title;\n                        node.insertBefore(titleNode, firstChild);\n                    }\n                }\n            }\n        },\n        lineHeight: {\n            qualify: isTextInUse\n        },\n        textVerticalAnchor: {\n            qualify: isTextInUse\n        },\n        textPath: {\n            qualify: isTextInUse\n        },\n        annotations: {\n            qualify: isTextInUse\n        },\n        eol: {\n            qualify: isTextInUse\n        },\n        displayEmpty: {\n            qualify: isTextInUse\n        },\n        // `port` attribute contains the `id` of the port that the underlying magnet represents.\n        port: {\n            set: function(port) {\n                return port === null || port.id === undefined ? port : port.id;\n            }\n        },\n        // `style` attribute is special in the sense that it sets the CSS style of the subelement.\n        style: {\n            qualify: isPlainObject,\n            set: function(styles, refBBox, node) {\n                $(node).css(styles);\n            }\n        },\n        html: {\n            set: function(html, refBBox, node) {\n                $(node).html(html + \"\");\n            }\n        },\n        // Properties setter (set various properties on the node)\n        props: props$1,\n        ref: {\n        },\n        // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n        // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n        // otherwise, `refX` is the left coordinate of the bounding box\n        refX: {\n            position: positionWrapper(\"x\", \"width\", \"origin\")\n        },\n        refY: {\n            position: positionWrapper(\"y\", \"height\", \"origin\")\n        },\n        // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n        // coordinate of the reference element.\n        refDx: {\n            position: positionWrapper(\"x\", \"width\", \"corner\")\n        },\n        refDy: {\n            position: positionWrapper(\"y\", \"height\", \"corner\")\n        },\n        // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n        // the reference element size\n        // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n        // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n        refWidth: {\n            set: setWrapper(\"width\", \"width\")\n        },\n        refHeight: {\n            set: setWrapper(\"height\", \"height\")\n        },\n        refRx: {\n            set: setWrapper(\"rx\", \"width\")\n        },\n        refRy: {\n            set: setWrapper(\"ry\", \"height\")\n        },\n        refRInscribed: {\n            set: function(attrName) {\n                var widthFn = setWrapper(attrName, \"width\");\n                var heightFn = setWrapper(attrName, \"height\");\n                return function(value, refBBox) {\n                    var fn = refBBox.height > refBBox.width ? widthFn : heightFn;\n                    return fn(value, refBBox);\n                };\n            }(\"r\")\n        },\n        refRCircumscribed: {\n            set: function(value, refBBox) {\n                var isValuePercentage = isPercentage(value);\n                value = parseFloat(value);\n                if (isValuePercentage) value /= 100;\n                var diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);\n                var rValue;\n                if (isFinite(value)) {\n                    if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;\n                    else rValue = Math.max(value + diagonalLength, 0);\n                }\n                return {\n                    r: rValue\n                };\n            }\n        },\n        refCx: {\n            set: setWrapper(\"cx\", \"width\")\n        },\n        refCy: {\n            set: setWrapper(\"cy\", \"height\")\n        },\n        // `x-alignment` when set to `middle` causes centering of the subelement around its new x coordinate.\n        // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n        xAlignment: {\n            offset: offsetWrapper(\"x\", \"width\", \"right\")\n        },\n        // `y-alignment` when set to `middle` causes centering of the subelement around its new y coordinate.\n        // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n        yAlignment: {\n            offset: offsetWrapper(\"y\", \"height\", \"bottom\")\n        },\n        resetOffset: {\n            offset: function(val, nodeBBox) {\n                return val ? {\n                    x: -nodeBBox.x,\n                    y: -nodeBBox.y\n                } : {\n                    x: 0,\n                    y: 0\n                };\n            }\n        },\n        refDResetOffset: {\n            set: dWrapper({\n                resetOffset: true\n            })\n        },\n        refDKeepOffset: {\n            set: dWrapper({\n                resetOffset: false\n            })\n        },\n        refPointsResetOffset: {\n            set: pointsWrapper({\n                resetOffset: true\n            })\n        },\n        refPointsKeepOffset: {\n            set: pointsWrapper({\n                resetOffset: false\n            })\n        },\n        // LinkView Attributes\n        connection: {\n            qualify: isLinkView,\n            set: function(ref) {\n                var stubs = ref.stubs;\n                if (stubs === void 0) stubs = 0;\n                var d;\n                if (isFinite(stubs) && stubs !== 0) {\n                    var offset;\n                    if (stubs < 0) offset = (this.getConnectionLength() + stubs) / 2;\n                    else offset = stubs;\n                    var path = this.getConnection();\n                    var segmentSubdivisions = this.getConnectionSubdivisions();\n                    var sourceParts = path.divideAtLength(offset, {\n                        segmentSubdivisions: segmentSubdivisions\n                    });\n                    var targetParts = path.divideAtLength(-offset, {\n                        segmentSubdivisions: segmentSubdivisions\n                    });\n                    if (sourceParts && targetParts) d = sourceParts[0].serialize() + \" \" + targetParts[1].serialize();\n                }\n                return {\n                    d: d || this.getSerializedConnection()\n                };\n            }\n        },\n        atConnectionLengthKeepGradient: {\n            qualify: isLinkView,\n            set: atConnectionWrapper(\"getTangentAtLength\", {\n                rotate: true\n            })\n        },\n        atConnectionLengthIgnoreGradient: {\n            qualify: isLinkView,\n            set: atConnectionWrapper(\"getTangentAtLength\", {\n                rotate: false\n            })\n        },\n        atConnectionRatioKeepGradient: {\n            qualify: isLinkView,\n            set: atConnectionWrapper(\"getTangentAtRatio\", {\n                rotate: true\n            })\n        },\n        atConnectionRatioIgnoreGradient: {\n            qualify: isLinkView,\n            set: atConnectionWrapper(\"getTangentAtRatio\", {\n                rotate: false\n            })\n        }\n    };\n    attributesNS[\"xlink:href\"] = attributesNS.xlinkHref;\n    // Support `calc()` with the following SVG attributes\n    [\n        \"transform\",\n        \"d\",\n        \"points\",\n        \"cx\",\n        \"cy\",\n        \"x1\",\n        \"x2\",\n        \"y1\",\n        \"y2\",\n        \"x\",\n        \"y\",\n        \"dx\",\n        \"dy\" // text\n    ].forEach(function(attribute) {\n        attributesNS[attribute] = {\n            qualify: isCalcAttribute,\n            set: function setCalcAttribute(value, refBBox) {\n                var obj;\n                return obj = {}, obj[attribute] = evalCalcAttribute(value, refBBox), obj;\n            }\n        };\n    });\n    // Prevent \"A negative value is not valid\" error.\n    [\n        \"width\",\n        \"height\",\n        \"r\",\n        \"rx\",\n        \"ry\",\n        \"font-size\",\n        \"stroke-width\" // elements\n    ].forEach(function(attribute) {\n        attributesNS[attribute] = {\n            qualify: isCalcAttribute,\n            set: function setCalcAttribute(value, refBBox) {\n                var obj;\n                return obj = {}, obj[attribute] = Math.max(0, evalCalcAttribute(value, refBBox)), obj;\n            }\n        };\n    });\n    // Aliases\n    attributesNS.refR = attributesNS.refRInscribed;\n    attributesNS.refD = attributesNS.refDResetOffset;\n    attributesNS.refPoints = attributesNS.refPointsResetOffset;\n    attributesNS.atConnectionLength = attributesNS.atConnectionLengthKeepGradient;\n    attributesNS.atConnectionRatio = attributesNS.atConnectionRatioKeepGradient;\n    attributesNS.fontSize = attributesNS[\"font-size\"];\n    attributesNS.strokeWidth = attributesNS[\"stroke-width\"];\n    // This allows to combine both absolute and relative positioning\n    // refX: 50%, refX2: 20\n    attributesNS.refX2 = attributesNS.refX;\n    attributesNS.refY2 = attributesNS.refY;\n    attributesNS.refWidth2 = attributesNS.refWidth;\n    attributesNS.refHeight2 = attributesNS.refHeight;\n    // Aliases for backwards compatibility\n    attributesNS[\"ref-x\"] = attributesNS.refX;\n    attributesNS[\"ref-y\"] = attributesNS.refY;\n    attributesNS[\"ref-dy\"] = attributesNS.refDy;\n    attributesNS[\"ref-dx\"] = attributesNS.refDx;\n    attributesNS[\"ref-width\"] = attributesNS.refWidth;\n    attributesNS[\"ref-height\"] = attributesNS.refHeight;\n    attributesNS[\"x-alignment\"] = attributesNS.xAlignment;\n    attributesNS[\"y-alignment\"] = attributesNS.yAlignment;\n    var attributes = attributesNS;\n    // Cell base model.\n    // --------------------------\n    var Cell = Backbone.Model.extend({\n        // This is the same as Backbone.Model with the only difference that is uses util.merge\n        // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\n        constructor: function(attributes, options) {\n            var defaults;\n            var attrs = attributes || {};\n            if (typeof this.preinitialize === \"function\") // Check to support an older version of Backbone (prior v1.4)\n            this.preinitialize.apply(this, arguments);\n            this.cid = uniqueId(\"c\");\n            this.attributes = {};\n            if (options && options.collection) this.collection = options.collection;\n            if (options && options.parse) attrs = this.parse(attrs, options) || {};\n            if (defaults = result(this, \"defaults\")) //<custom code>\n            // Replaced the call to _.defaults with util.merge.\n            attrs = merge({}, defaults, attrs);\n            this.set(attrs, options);\n            this.changed = {};\n            this.initialize.apply(this, arguments);\n        },\n        translate: function(dx, dy, opt) {\n            throw new Error(\"Must define a translate() method.\");\n        },\n        toJSON: function() {\n            var defaults = result(this.constructor.prototype, \"defaults\");\n            var defaultAttrs = defaults.attrs || {};\n            var attrs = this.attributes.attrs;\n            var finalAttrs = {};\n            // Loop through all the attributes and\n            // omit the default attributes as they are implicitly reconstructible by the cell 'type'.\n            forIn(attrs, function(attr, selector) {\n                var defaultAttr = defaultAttrs[selector];\n                forIn(attr, function(value, name) {\n                    // attr is mainly flat though it might have one more level (consider the `style` attribute).\n                    // Check if the `value` is object and if yes, go one level deep.\n                    if (isObject$1(value) && !Array.isArray(value)) forIn(value, function(value2, name2) {\n                        if (!defaultAttr || !defaultAttr[name] || !isEqual(defaultAttr[name][name2], value2)) {\n                            finalAttrs[selector] = finalAttrs[selector] || {};\n                            (finalAttrs[selector][name] || (finalAttrs[selector][name] = {}))[name2] = value2;\n                        }\n                    });\n                    else if (!defaultAttr || !isEqual(defaultAttr[name], value)) {\n                        // `value` is not an object, default attribute for such a selector does not exist\n                        // or it is different than the attribute value set on the model.\n                        finalAttrs[selector] = finalAttrs[selector] || {};\n                        finalAttrs[selector][name] = value;\n                    }\n                });\n            });\n            var attributes = cloneDeep(omit(this.attributes, \"attrs\"));\n            attributes.attrs = finalAttrs;\n            return attributes;\n        },\n        initialize: function(options) {\n            var idAttribute = this.getIdAttribute();\n            if (!options || options[idAttribute] === undefined) this.set(idAttribute, this.generateId(), {\n                silent: true\n            });\n            this._transitionIds = {};\n            this._scheduledTransitionIds = {};\n            // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n            this.processPorts();\n            this.on(\"change:attrs\", this.processPorts, this);\n        },\n        getIdAttribute: function() {\n            return this.idAttribute || \"id\";\n        },\n        generateId: function() {\n            return uuid();\n        },\n        /**\n\t     * @deprecated\n\t     */ processPorts: function() {\n            // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n            // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n            // set to that port, we remove those links as well (to follow the same behaviour as\n            // with a removed element).\n            var previousPorts = this.ports;\n            // Collect ports from the `attrs` object.\n            var ports = {};\n            forIn(this.get(\"attrs\"), function(attrs, selector) {\n                if (attrs && attrs.port) {\n                    // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n                    if (attrs.port.id !== undefined) ports[attrs.port.id] = attrs.port;\n                    else ports[attrs.port] = {\n                        id: attrs.port\n                    };\n                }\n            });\n            // Collect ports that have been removed (compared to the previous ports) - if any.\n            // Use hash table for quick lookup.\n            var removedPorts = {};\n            forIn(previousPorts, function(port, id) {\n                if (!ports[id]) removedPorts[id] = true;\n            });\n            // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n            if (this.graph && !isEmpty(removedPorts)) {\n                var inboundLinks = this.graph.getConnectedLinks(this, {\n                    inbound: true\n                });\n                inboundLinks.forEach(function(link) {\n                    if (removedPorts[link.get(\"target\").port]) link.remove();\n                });\n                var outboundLinks = this.graph.getConnectedLinks(this, {\n                    outbound: true\n                });\n                outboundLinks.forEach(function(link) {\n                    if (removedPorts[link.get(\"source\").port]) link.remove();\n                });\n            }\n            // Update the `ports` object.\n            this.ports = ports;\n        },\n        remove: function(opt) {\n            if (opt === void 0) opt = {};\n            // Store the graph in a variable because `this.graph` won't be accessible\n            // after `this.trigger('remove', ...)` down below.\n            var ref = this;\n            var graph = ref.graph;\n            var collection = ref.collection;\n            if (!graph) {\n                // The collection is a common Backbone collection (not the graph collection).\n                if (collection) collection.remove(this, opt);\n                return this;\n            }\n            graph.startBatch(\"remove\");\n            // First, unembed this cell from its parent cell if there is one.\n            var parentCell = this.getParentCell();\n            if (parentCell) parentCell.unembed(this, opt);\n            // Remove also all the cells, which were embedded into this cell\n            var embeddedCells = this.getEmbeddedCells();\n            for(var i = 0, n = embeddedCells.length; i < n; i++){\n                var embed = embeddedCells[i];\n                if (embed) embed.remove(opt);\n            }\n            this.trigger(\"remove\", this, graph.attributes.cells, opt);\n            graph.stopBatch(\"remove\");\n            return this;\n        },\n        toFront: function(opt) {\n            var graph = this.graph;\n            if (graph) {\n                opt = opt || {};\n                var cells;\n                if (opt.deep) {\n                    cells = this.getEmbeddedCells({\n                        deep: true,\n                        breadthFirst: opt.breadthFirst !== false\n                    });\n                    cells.unshift(this);\n                } else cells = [\n                    this\n                ];\n                var sortedCells = sortBy(cells, function(cell) {\n                    return cell.z();\n                });\n                var maxZ = graph.maxZIndex();\n                var z = maxZ - cells.length + 1;\n                var collection = graph.get(\"cells\");\n                var shouldUpdate = collection.indexOf(this) !== collection.length - cells.length;\n                if (!shouldUpdate) shouldUpdate = sortedCells.some(function(cell, index) {\n                    return cell.z() !== z + index;\n                });\n                if (shouldUpdate) {\n                    this.startBatch(\"to-front\");\n                    z = z + cells.length;\n                    sortedCells.forEach(function(cell, index) {\n                        cell.set(\"z\", z + index, opt);\n                    });\n                    this.stopBatch(\"to-front\");\n                }\n            }\n            return this;\n        },\n        toBack: function(opt) {\n            var graph = this.graph;\n            if (graph) {\n                opt = opt || {};\n                var cells;\n                if (opt.deep) {\n                    cells = this.getEmbeddedCells({\n                        deep: true,\n                        breadthFirst: opt.breadthFirst !== false\n                    });\n                    cells.unshift(this);\n                } else cells = [\n                    this\n                ];\n                var sortedCells = sortBy(cells, function(cell) {\n                    return cell.z();\n                });\n                var z = graph.minZIndex();\n                var collection = graph.get(\"cells\");\n                var shouldUpdate = collection.indexOf(this) !== 0;\n                if (!shouldUpdate) shouldUpdate = sortedCells.some(function(cell, index) {\n                    return cell.z() !== z + index;\n                });\n                if (shouldUpdate) {\n                    this.startBatch(\"to-back\");\n                    z -= cells.length;\n                    sortedCells.forEach(function(cell, index) {\n                        cell.set(\"z\", z + index, opt);\n                    });\n                    this.stopBatch(\"to-back\");\n                }\n            }\n            return this;\n        },\n        parent: function(parent, opt) {\n            // getter\n            if (parent === undefined) return this.get(\"parent\");\n            // setter\n            return this.set(\"parent\", parent, opt);\n        },\n        embed: function(cell, opt) {\n            var this$1 = this;\n            var cells = Array.isArray(cell) ? cell : [\n                cell\n            ];\n            if (!this.canEmbed(cells)) throw new Error(\"Recursive embedding not allowed.\");\n            if (cells.some(function(c) {\n                return c.isEmbedded() && this$1.id !== c.parent();\n            })) throw new Error(\"Embedding of already embedded cells is not allowed.\");\n            this._embedCells(cells, opt);\n            return this;\n        },\n        unembed: function(cell, opt) {\n            var cells = Array.isArray(cell) ? cell : [\n                cell\n            ];\n            this._unembedCells(cells, opt);\n            return this;\n        },\n        canEmbed: function(cell) {\n            var this$1 = this;\n            var cells = Array.isArray(cell) ? cell : [\n                cell\n            ];\n            return cells.every(function(c) {\n                return this$1 !== c && !this$1.isEmbeddedIn(c);\n            });\n        },\n        _embedCells: function(cells, opt) {\n            var this$1 = this;\n            var batchName = \"embed\";\n            this.startBatch(batchName);\n            var embeds = assign([], this.get(\"embeds\"));\n            cells.forEach(function(cell) {\n                // We keep all element ids after link ids.\n                embeds[cell.isLink() ? \"unshift\" : \"push\"](cell.id);\n                cell.parent(this$1.id, opt);\n            });\n            this.set(\"embeds\", uniq(embeds), opt);\n            this.stopBatch(batchName);\n        },\n        _unembedCells: function(cells, opt) {\n            var batchName = \"unembed\";\n            this.startBatch(batchName);\n            cells.forEach(function(cell) {\n                return cell.unset(\"parent\", opt);\n            });\n            this.set(\"embeds\", without.apply(void 0, [\n                this.get(\"embeds\")\n            ].concat(cells.map(function(cell) {\n                return cell.id;\n            }))), opt);\n            this.stopBatch(batchName);\n        },\n        getParentCell: function() {\n            // unlike link.source/target, cell.parent stores id directly as a string\n            var parentId = this.parent();\n            var graph = this.graph;\n            return parentId && graph && graph.getCell(parentId) || null;\n        },\n        // Return an array of ancestor cells.\n        // The array is ordered from the parent of the cell\n        // to the most distant ancestor.\n        getAncestors: function() {\n            var ancestors = [];\n            if (!this.graph) return ancestors;\n            var parentCell = this.getParentCell();\n            while(parentCell){\n                ancestors.push(parentCell);\n                parentCell = parentCell.getParentCell();\n            }\n            return ancestors;\n        },\n        getEmbeddedCells: function(opt) {\n            opt = opt || {};\n            // Cell models can only be retrieved when this element is part of a collection.\n            // There is no way this element knows about other cells otherwise.\n            // This also means that calling e.g. `translate()` on an element with embeds before\n            // adding it to a graph does not translate its embeds.\n            if (this.graph) {\n                var cells;\n                if (opt.deep) {\n                    if (opt.breadthFirst) {\n                        // breadthFirst algorithm\n                        cells = [];\n                        var queue = this.getEmbeddedCells();\n                        while(queue.length > 0){\n                            var parent = queue.shift();\n                            cells.push(parent);\n                            queue.push.apply(queue, parent.getEmbeddedCells());\n                        }\n                    } else {\n                        // depthFirst algorithm\n                        cells = this.getEmbeddedCells();\n                        cells.forEach(function(cell) {\n                            cells.push.apply(cells, cell.getEmbeddedCells(opt));\n                        });\n                    }\n                } else cells = toArray(this.get(\"embeds\")).map(this.graph.getCell, this.graph);\n                return cells;\n            }\n            return [];\n        },\n        isEmbeddedIn: function(cell, opt) {\n            var cellId = isString(cell) ? cell : cell.id;\n            var parentId = this.parent();\n            opt = assign({\n                deep: true\n            }, opt);\n            // See getEmbeddedCells().\n            if (this.graph && opt.deep) {\n                while(parentId){\n                    if (parentId === cellId) return true;\n                    parentId = this.graph.getCell(parentId).parent();\n                }\n                return false;\n            } else // When this cell is not part of a collection check\n            // at least whether it's a direct child of given cell.\n            return parentId === cellId;\n        },\n        // Whether or not the cell is embedded in any other cell.\n        isEmbedded: function() {\n            return !!this.parent();\n        },\n        // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n        // Shallow cloning simply clones the cell and returns a new cell with different ID.\n        // Deep cloning clones the cell and all its embedded cells recursively.\n        clone: function(opt) {\n            opt = opt || {};\n            if (!opt.deep) {\n                // Shallow cloning.\n                var clone = Backbone.Model.prototype.clone.apply(this, arguments);\n                // We don't want the clone to have the same ID as the original.\n                clone.set(this.getIdAttribute(), this.generateId());\n                // A shallow cloned element does not carry over the original embeds.\n                clone.unset(\"embeds\");\n                // And can not be embedded in any cell\n                // as the clone is not part of the graph.\n                clone.unset(\"parent\");\n                return clone;\n            } else // Deep cloning.\n            // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\n            return toArray(cloneCells([\n                this\n            ].concat(this.getEmbeddedCells({\n                deep: true\n            }))));\n        },\n        // A convenient way to set nested properties.\n        // This method merges the properties you'd like to set with the ones\n        // stored in the cell and makes sure change events are properly triggered.\n        // You can either set a nested property with one object\n        // or use a property path.\n        // The most simple use case is:\n        // `cell.prop('name/first', 'John')` or\n        // `cell.prop({ name: { first: 'John' } })`.\n        // Nested arrays are supported too:\n        // `cell.prop('series/0/data/0/degree', 50)` or\n        // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n        prop: function(props, value, opt) {\n            var delim = \"/\";\n            var _isString = isString(props);\n            if (_isString || Array.isArray(props)) {\n                // Get/set an attribute by a special path syntax that delimits\n                // nested objects by the colon character.\n                if (arguments.length > 1) {\n                    var path;\n                    var pathArray;\n                    if (_isString) {\n                        path = props;\n                        pathArray = path.split(\"/\");\n                    } else {\n                        path = props.join(delim);\n                        pathArray = props.slice();\n                    }\n                    var property = pathArray[0];\n                    var pathArrayLength = pathArray.length;\n                    var options$1 = opt || {};\n                    options$1.propertyPath = path;\n                    options$1.propertyValue = value;\n                    options$1.propertyPathArray = pathArray;\n                    if (!(\"rewrite\" in options$1)) options$1.rewrite = false;\n                    var update = {};\n                    // Initialize the nested object. Sub-objects are either arrays or objects.\n                    // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n                    // Note that this imposes a limitation on object keys one can use with Inspector.\n                    // Pure integer keys will cause issues and are therefore not allowed.\n                    var initializer = update;\n                    var prevProperty = property;\n                    for(var i = 1; i < pathArrayLength; i++){\n                        var pathItem = pathArray[i];\n                        var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n                        initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n                        prevProperty = pathItem;\n                    }\n                    // Fill update with the `value` on `path`.\n                    update = setByPath(update, pathArray, value, \"/\");\n                    var baseAttributes = merge({}, this.attributes);\n                    // if rewrite mode enabled, we replace value referenced by path with\n                    // the new one (we don't merge).\n                    options$1.rewrite && unsetByPath(baseAttributes, path, \"/\");\n                    // Merge update with the model attributes.\n                    var attributes = merge(baseAttributes, update);\n                    // Finally, set the property to the updated attributes.\n                    return this.set(property, attributes[property], options$1);\n                } else return getByPath(this.attributes, props, delim);\n            }\n            var options = value || {};\n            // Note: '' is not the path to the root. It's a path with an empty string i.e. { '': {}}.\n            options.propertyPath = null;\n            options.propertyValue = props;\n            options.propertyPathArray = [];\n            if (!(\"rewrite\" in options)) options.rewrite = false;\n            return this.set(merge({}, this.attributes, props), options);\n        },\n        // A convenient way to unset nested properties\n        removeProp: function(path, opt) {\n            opt = opt || {};\n            var pathArray = Array.isArray(path) ? path : path.split(\"/\");\n            // Once a property is removed from the `attrs` attribute\n            // the cellView will recognize a `dirty` flag and re-render itself\n            // in order to remove the attribute from SVG element.\n            var property = pathArray[0];\n            if (property === \"attrs\") opt.dirty = true;\n            if (pathArray.length === 1) // A top level property\n            return this.unset(path, opt);\n            // A nested property\n            var nestedPath = pathArray.slice(1);\n            var propertyValue = this.get(property);\n            if (propertyValue === undefined || propertyValue === null) return this;\n            propertyValue = cloneDeep(propertyValue);\n            unsetByPath(propertyValue, nestedPath, \"/\");\n            return this.set(property, propertyValue, opt);\n        },\n        // A convenient way to set nested attributes.\n        attr: function(attrs, value, opt) {\n            var args = Array.from(arguments);\n            if (args.length === 0) return this.get(\"attrs\");\n            if (Array.isArray(attrs)) args[0] = [\n                \"attrs\"\n            ].concat(attrs);\n            else if (isString(attrs)) // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = \"attrs/\" + attrs;\n            else args[0] = {\n                \"attrs\": attrs\n            };\n            return this.prop.apply(this, args);\n        },\n        // A convenient way to unset nested attributes\n        removeAttr: function(path, opt) {\n            if (Array.isArray(path)) return this.removeProp([\n                \"attrs\"\n            ].concat(path));\n            return this.removeProp(\"attrs/\" + path, opt);\n        },\n        transition: function(path, value, opt, delim) {\n            var this$1 = this;\n            delim = delim || \"/\";\n            var defaults = {\n                duration: 100,\n                delay: 10,\n                timingFunction: timing.linear,\n                valueFunction: interpolate.number\n            };\n            opt = assign(defaults, opt);\n            var firstFrameTime = 0;\n            var interpolatingFunction;\n            var setter = (function(runtime) {\n                var id, progress, propertyValue;\n                firstFrameTime = firstFrameTime || runtime;\n                runtime -= firstFrameTime;\n                progress = runtime / opt.duration;\n                if (progress < 1) this._transitionIds[path] = id = nextFrame(setter);\n                else {\n                    progress = 1;\n                    delete this._transitionIds[path];\n                }\n                propertyValue = interpolatingFunction(opt.timingFunction(progress));\n                opt.transitionId = id;\n                this.prop(path, propertyValue, opt);\n                if (!id) this.trigger(\"transition:end\", this, path);\n            }).bind(this);\n            var ref = this;\n            var _scheduledTransitionIds = ref._scheduledTransitionIds;\n            var initialId;\n            var initiator = function(callback) {\n                if (_scheduledTransitionIds[path]) {\n                    _scheduledTransitionIds[path] = without(_scheduledTransitionIds[path], initialId);\n                    if (_scheduledTransitionIds[path].length === 0) delete _scheduledTransitionIds[path];\n                }\n                this$1.stopPendingTransitions(path, delim);\n                interpolatingFunction = opt.valueFunction(getByPath(this$1.attributes, path, delim), value);\n                this$1._transitionIds[path] = nextFrame(callback);\n                this$1.trigger(\"transition:start\", this$1, path);\n            };\n            initialId = setTimeout(initiator, opt.delay, setter);\n            _scheduledTransitionIds[path] || (_scheduledTransitionIds[path] = []);\n            _scheduledTransitionIds[path].push(initialId);\n            return initialId;\n        },\n        getTransitions: function() {\n            return union(Object.keys(this._transitionIds), Object.keys(this._scheduledTransitionIds));\n        },\n        stopScheduledTransitions: function(path, delim) {\n            if (delim === void 0) delim = \"/\";\n            var ref = this;\n            var _scheduledTransitionIds = ref._scheduledTransitionIds;\n            if (_scheduledTransitionIds === void 0) _scheduledTransitionIds = {};\n            var transitions = Object.keys(_scheduledTransitionIds);\n            if (path) {\n                var pathArray = path.split(delim);\n                transitions = transitions.filter(function(key) {\n                    return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n                });\n            }\n            transitions.forEach(function(key) {\n                var transitionIds = _scheduledTransitionIds[key];\n                // stop the initiator\n                transitionIds.forEach(function(transitionId) {\n                    return clearTimeout(transitionId);\n                });\n                delete _scheduledTransitionIds[key];\n            // Note: we could trigger transition:cancel` event here\n            });\n            return this;\n        },\n        stopPendingTransitions: function stopPendingTransitions(path, delim) {\n            var this$1 = this;\n            if (delim === void 0) delim = \"/\";\n            var ref = this;\n            var _transitionIds = ref._transitionIds;\n            if (_transitionIds === void 0) _transitionIds = {};\n            var transitions = Object.keys(_transitionIds);\n            if (path) {\n                var pathArray = path.split(delim);\n                transitions = transitions.filter(function(key) {\n                    return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n                });\n            }\n            transitions.forEach(function(key) {\n                var transitionId = _transitionIds[key];\n                // stop the setter\n                cancelFrame(transitionId);\n                delete _transitionIds[key];\n                this$1.trigger(\"transition:end\", this$1, key);\n            });\n        },\n        stopTransitions: function(path, delim) {\n            if (delim === void 0) delim = \"/\";\n            this.stopScheduledTransitions(path, delim);\n            this.stopPendingTransitions(path, delim);\n            return this;\n        },\n        // A shorcut making it easy to create constructs like the following:\n        // `var el = (new joint.shapes.basic.Rect).addTo(graph)`.\n        addTo: function(graph, opt) {\n            graph.addCell(this, opt);\n            return this;\n        },\n        // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n        // making it easy to create constructs like the following:\n        // `cell.findView(paper).highlight()`\n        findView: function(paper) {\n            return paper.findViewByModel(this);\n        },\n        isElement: function() {\n            return false;\n        },\n        isLink: function() {\n            return false;\n        },\n        startBatch: function(name, opt) {\n            if (this.graph) this.graph.startBatch(name, assign({}, opt, {\n                cell: this\n            }));\n            return this;\n        },\n        stopBatch: function(name, opt) {\n            if (this.graph) this.graph.stopBatch(name, assign({}, opt, {\n                cell: this\n            }));\n            return this;\n        },\n        getChangeFlag: function(attributes) {\n            var flag = 0;\n            if (!attributes) return flag;\n            for(var key in attributes){\n                if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;\n                flag |= attributes[key];\n            }\n            return flag;\n        },\n        angle: function() {\n            // To be overridden.\n            return 0;\n        },\n        position: function() {\n            // To be overridden.\n            return new Point(0, 0);\n        },\n        z: function() {\n            return this.get(\"z\") || 0;\n        },\n        getPointFromConnectedLink: function() {\n            // To be overridden\n            return new Point();\n        },\n        getBBox: function() {\n            // To be overridden\n            return new Rect(0, 0, 0, 0);\n        },\n        getPointRotatedAroundCenter: function getPointRotatedAroundCenter(angle, x, y) {\n            var point = new Point(x, y);\n            if (angle) point.rotate(this.getBBox().center(), angle);\n            return point;\n        },\n        getAbsolutePointFromRelative: function getAbsolutePointFromRelative(x, y) {\n            // Rotate the position to take the model angle into account\n            return this.getPointRotatedAroundCenter(-this.angle(), // Transform the relative position to absolute\n            this.position().offset(x, y));\n        },\n        getRelativePointFromAbsolute: function getRelativePointFromAbsolute(x, y) {\n            return this// Rotate the coordinates to mitigate the element's rotation.\n            .getPointRotatedAroundCenter(this.angle(), x, y)// Transform the absolute position into relative\n            .difference(this.position());\n        }\n    }, {\n        getAttributeDefinition: function(attrName) {\n            var defNS = this.attributes;\n            var globalDefNS = attributes;\n            return defNS && defNS[attrName] || globalDefNS[attrName];\n        },\n        define: function(type, defaults, protoProps, staticProps) {\n            protoProps = assign({\n                defaults: defaultsDeep({\n                    type: type\n                }, defaults, this.prototype.defaults)\n            }, protoProps);\n            var Cell = this.extend(protoProps, staticProps);\n            // es5 backward compatibility\n            /* eslint-disable no-undef */ if (typeof joint !== \"undefined\" && has$2(joint, \"shapes\")) setByPath(joint.shapes, type, Cell, \".\");\n            /* eslint-enable no-undef */ return Cell;\n        }\n    });\n    var wrapWith = function(object, methods, wrapper) {\n        if (isString(wrapper)) {\n            if (!wrappers[wrapper]) throw new Error('Unknown wrapper: \"' + wrapper + '\"');\n            wrapper = wrappers[wrapper];\n        }\n        if (!isFunction(wrapper)) throw new Error(\"Wrapper must be a function.\");\n        toArray(methods).forEach(function(method) {\n            object[method] = wrapper(object[method]);\n        });\n    };\n    var wrappers = {\n        cells: function(fn) {\n            return function() {\n                var args = Array.from(arguments);\n                var n = args.length;\n                var cells = n > 0 && args[0] || [];\n                var opt = n > 1 && args[n - 1] || {};\n                if (!Array.isArray(cells)) {\n                    if (opt instanceof Cell) cells = args;\n                    else if (cells instanceof Cell) {\n                        if (args.length > 1) args.pop();\n                        cells = args;\n                    }\n                }\n                if (opt instanceof Cell) opt = {};\n                return fn.call(this, cells, opt);\n            };\n        }\n    };\n    function svg(strings) {\n        var expressions = [], len = arguments.length - 1;\n        while(len-- > 0)expressions[len] = arguments[len + 1];\n        var svgParts = [];\n        strings.forEach(function(part, index) {\n            svgParts.push(part);\n            if (index in expressions) svgParts.push(expressions[index]);\n        });\n        var markup = parseFromSVGString(svgParts.join(\"\"));\n        return markup;\n    }\n    function parseFromSVGString(str) {\n        var parser = new DOMParser();\n        var markupString = \"<svg>\" + str.trim() + \"</svg>\";\n        var xmldocument = parser.parseFromString(markupString.replace(/@/g, \"\"), \"application/xml\");\n        if (xmldocument.getElementsByTagName(\"parsererror\")[0]) throw new Error(\"Invalid SVG markup\");\n        var document1 = parser.parseFromString(markupString, \"text/html\");\n        var svg = document1.querySelector(\"svg\");\n        return build(svg);\n    }\n    function buildNode(node) {\n        var markupNode = {};\n        var tagName = node.tagName;\n        var attributes = node.attributes;\n        var namespaceURI = node.namespaceURI;\n        var style = node.style;\n        var childNodes = node.childNodes;\n        markupNode.namespaceURI = namespaceURI;\n        markupNode.tagName = namespaceURI === V.namespace.xhtml ? tagName.toLowerCase() : tagName;\n        var stylesObject = {};\n        for(var i = style.length; i--;){\n            var nameString = style[i];\n            stylesObject[nameString] = style.getPropertyValue(nameString);\n        }\n        markupNode.style = stylesObject;\n        // selector fallbacks to tagName\n        var selectorAttribute = attributes.getNamedItem(\"@selector\");\n        if (selectorAttribute) {\n            markupNode.selector = selectorAttribute.value;\n            attributes.removeNamedItem(\"@selector\");\n        }\n        var groupSelectorAttribute = attributes.getNamedItem(\"@group-selector\");\n        if (groupSelectorAttribute) {\n            var groupSelectors = groupSelectorAttribute.value.split(\",\");\n            markupNode.groupSelector = groupSelectors.map(function(s) {\n                return s.trim();\n            });\n            attributes.removeNamedItem(\"@group-selector\");\n        }\n        var className = attributes.getNamedItem(\"class\");\n        if (className) markupNode.className = className.value;\n        var children = [];\n        childNodes.forEach(function(node) {\n            switch(node.nodeType){\n                case Node.TEXT_NODE:\n                    var trimmedText = node.data.replace(/\\s\\s+/g, \" \");\n                    if (trimmedText.trim()) children.push(trimmedText);\n                    break;\n                case Node.ELEMENT_NODE:\n                    children.push(buildNode(node));\n                    break;\n                default:\n                    break;\n            }\n        });\n        if (children.length) markupNode.children = children;\n        var nodeAttrs = {};\n        Array.from(attributes).forEach(function(nodeAttribute) {\n            var name = nodeAttribute.name;\n            var value = nodeAttribute.value;\n            nodeAttrs[name] = value;\n        });\n        if (Object.keys(nodeAttrs).length > 0) markupNode.attributes = nodeAttrs;\n        return markupNode;\n    }\n    function build(root) {\n        var markup = [];\n        Array.from(root.children).forEach(function(node) {\n            markup.push(buildNode(node));\n        });\n        return markup;\n    }\n    var Positions = {\n        TOP: \"top\",\n        RIGHT: \"right\",\n        BOTTOM: \"bottom\",\n        LEFT: \"left\",\n        TOP_LEFT: \"top-left\",\n        TOP_RIGHT: \"top-right\",\n        BOTTOM_LEFT: \"bottom-left\",\n        BOTTOM_RIGHT: \"bottom-right\",\n        CENTER: \"center\"\n    };\n    function getRectPoint(rect, position) {\n        var r = new Rect(rect);\n        switch(position){\n            case undefined:\n                throw new Error(\"Position required\");\n            // Middle Points\n            case Positions.LEFT:\n            case \"leftMiddle\":\n                return r.leftMiddle();\n            case Positions.RIGHT:\n            case \"rightMiddle\":\n                return r.rightMiddle();\n            case Positions.TOP:\n            case \"topMiddle\":\n                return r.topMiddle();\n            case Positions.BOTTOM:\n            case \"bottomMiddle\":\n                return r.bottomMiddle();\n            // Corners\n            case Positions.TOP_LEFT:\n            case \"topLeft\":\n            case \"origin\":\n                return r.topLeft();\n            case Positions.TOP_RIGHT:\n            case \"topRight\":\n                return r.topRight();\n            case Positions.BOTTOM_LEFT:\n            case \"bottomLeft\":\n                return r.bottomLeft();\n            case Positions.BOTTOM_RIGHT:\n            case \"bottomRight\":\n            case \"corner\":\n                return r.bottomRight();\n            // Center\n            case Positions.CENTER:\n                return r.center();\n            // TODO: calc(), percentage etc.\n            default:\n                throw new Error(\"Unknown position: \" + position);\n        }\n    }\n    var index = {\n        getRectPoint: getRectPoint,\n        wrapWith: wrapWith,\n        wrappers: wrappers,\n        addClassNamePrefix: addClassNamePrefix,\n        removeClassNamePrefix: removeClassNamePrefix,\n        parseDOMJSON: parseDOMJSON,\n        hashCode: hashCode,\n        getByPath: getByPath,\n        setByPath: setByPath,\n        unsetByPath: unsetByPath,\n        flattenObject: flattenObject,\n        uuid: uuid,\n        guid: guid,\n        toKebabCase: toKebabCase,\n        normalizeEvent: normalizeEvent,\n        normalizeWheel: normalizeWheel,\n        cap: cap,\n        nextFrame: nextFrame,\n        cancelFrame: cancelFrame,\n        shapePerimeterConnectionPoint: shapePerimeterConnectionPoint,\n        isPercentage: isPercentage,\n        parseCssNumeric: parseCssNumeric,\n        breakText: breakText,\n        sanitizeHTML: sanitizeHTML,\n        downloadBlob: downloadBlob,\n        downloadDataUri: downloadDataUri,\n        dataUriToBlob: dataUriToBlob,\n        imageToDataUri: imageToDataUri,\n        getElementBBox: getElementBBox,\n        sortElements: sortElements,\n        setAttributesBySelector: setAttributesBySelector,\n        normalizeSides: normalizeSides,\n        timing: timing,\n        interpolate: interpolate,\n        filter: filter,\n        format: format,\n        template: template,\n        toggleFullScreen: toggleFullScreen,\n        isBoolean: isBoolean,\n        isObject: isObject$1,\n        isNumber: isNumber,\n        isString: isString,\n        mixin: mixin,\n        deepMixin: deepMixin,\n        supplement: supplement,\n        defaults: defaults,\n        deepSupplement: deepSupplement,\n        defaultsDeep: defaultsDeep,\n        assign: assign,\n        invoke: invoke,\n        invokeProperty: invokeProperty,\n        sortedIndex: sortedIndex,\n        uniq: uniq,\n        clone: clone,\n        cloneDeep: cloneDeep,\n        isEmpty: isEmpty,\n        isEqual: isEqual,\n        isFunction: isFunction,\n        isPlainObject: isPlainObject,\n        toArray: toArray,\n        debounce: debounce,\n        groupBy: groupBy,\n        sortBy: sortBy,\n        flattenDeep: flattenDeep,\n        without: without,\n        difference: difference,\n        intersection: intersection$1,\n        union: union,\n        has: has$2,\n        result: result,\n        omit: omit,\n        pick: pick,\n        bindAll: bindAll,\n        forIn: forIn,\n        camelCase: camelCase,\n        uniqueId: uniqueId,\n        merge: merge,\n        noop: noop,\n        cloneCells: cloneCells,\n        svg: svg\n    };\n    function portTransformAttrs(point, angle, opt) {\n        var trans = point.toJSON();\n        trans.angle = angle || 0;\n        return defaults({}, opt, trans);\n    }\n    function lineLayout(ports, p1, p2, elBBox) {\n        return ports.map(function(port, index, ports) {\n            var p = this.pointAt((index + 0.5) / ports.length);\n            // `dx`,`dy` per port offset option\n            if (port.dx || port.dy) p.offset(port.dx || 0, port.dy || 0);\n            return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));\n        }, line(p1, p2));\n    }\n    function ellipseLayout(ports, elBBox, startAngle, stepFn) {\n        var center = elBBox.center();\n        var ratio = elBBox.width / elBBox.height;\n        var p1 = elBBox.topMiddle();\n        var ellipse = Ellipse.fromRect(elBBox);\n        return ports.map(function(port, index, ports) {\n            var angle = startAngle + stepFn(index, ports.length);\n            var p2 = p1.clone().rotate(center, -angle).scale(ratio, 1, center);\n            var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;\n            // `dx`,`dy` per port offset option\n            if (port.dx || port.dy) p2.offset(port.dx || 0, port.dy || 0);\n            // `dr` delta radius option\n            if (port.dr) p2.move(center, port.dr);\n            return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));\n        });\n    }\n    function argTransform(bbox, args) {\n        var x = args.x;\n        var y = args.y;\n        var angle = args.angle;\n        if (isPercentage(x)) x = parseFloat(x) / 100 * bbox.width;\n        else if (isCalcAttribute(x)) x = Number(evalCalcAttribute(x, bbox));\n        if (isPercentage(y)) y = parseFloat(y) / 100 * bbox.height;\n        else if (isCalcAttribute(y)) y = Number(evalCalcAttribute(y, bbox));\n        return {\n            x: x,\n            y: y,\n            angle: angle\n        };\n    }\n    // Creates a point stored in arguments\n    function argPoint(bbox, args) {\n        var ref = argTransform(bbox, args);\n        var x = ref.x;\n        var y = ref.y;\n        return new Point(x || 0, y || 0);\n    }\n    /**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */ var absolute = function(ports, elBBox) {\n        return ports.map(function(port) {\n            var transformation = argPoint(elBBox, port).round().toJSON();\n            transformation.angle = port.angle || 0;\n            return transformation;\n        });\n    };\n    /**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */ var fn = function(ports, elBBox, opt) {\n        return opt.fn(ports, elBBox, opt);\n    };\n    /**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */ var line$1 = function(ports, elBBox, opt) {\n        var start = argPoint(elBBox, opt.start || elBBox.origin());\n        var end = argPoint(elBBox, opt.end || elBBox.corner());\n        return lineLayout(ports, start, end, elBBox);\n    };\n    /**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */ var left = function(ports, elBBox, opt) {\n        return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);\n    };\n    /**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */ var right = function(ports, elBBox, opt) {\n        return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);\n    };\n    /**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */ var top = function(ports, elBBox, opt) {\n        return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);\n    };\n    /**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */ var bottom = function(ports, elBBox, opt) {\n        return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);\n    };\n    /**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt Group options\n\t * @returns {Array<g.Point>}\n\t */ var ellipseSpread = function(ports, elBBox, opt) {\n        var startAngle = opt.startAngle || 0;\n        var stepAngle = opt.step || 360 / ports.length;\n        return ellipseLayout(ports, elBBox, startAngle, function(index) {\n            return index * stepAngle;\n        });\n    };\n    /**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt Group options\n\t * @returns {Array<g.Point>}\n\t */ var ellipse$1 = function(ports, elBBox, opt) {\n        var startAngle = opt.startAngle || 0;\n        var stepAngle = opt.step || 20;\n        return ellipseLayout(ports, elBBox, startAngle, function(index, count) {\n            return (index + 0.5 - count / 2) * stepAngle;\n        });\n    };\n    var Port = {\n        absolute: absolute,\n        fn: fn,\n        line: line$1,\n        left: left,\n        right: right,\n        top: top,\n        bottom: bottom,\n        ellipseSpread: ellipseSpread,\n        ellipse: ellipse$1\n    };\n    function labelAttributes(opt1, opt2) {\n        return defaultsDeep({}, opt1, opt2, {\n            x: 0,\n            y: 0,\n            angle: 0,\n            attrs: {}\n        });\n    }\n    function outsideLayout(portPosition, elBBox, autoOrient, opt) {\n        opt = defaults({}, opt, {\n            offset: 15\n        });\n        var angle = elBBox.center().theta(portPosition);\n        var x = getBBoxAngles(elBBox);\n        var tx, ty, y, textAnchor;\n        var offset = opt.offset;\n        var orientAngle = 0;\n        if (angle < x[1] || angle > x[2]) {\n            y = \".3em\";\n            tx = offset;\n            ty = 0;\n            textAnchor = \"start\";\n        } else if (angle < x[0]) {\n            tx = 0;\n            ty = -offset;\n            if (autoOrient) {\n                orientAngle = -90;\n                textAnchor = \"start\";\n                y = \".3em\";\n            } else {\n                textAnchor = \"middle\";\n                y = \"0\";\n            }\n        } else if (angle < x[3]) {\n            y = \".3em\";\n            tx = -offset;\n            ty = 0;\n            textAnchor = \"end\";\n        } else {\n            tx = 0;\n            ty = offset;\n            if (autoOrient) {\n                orientAngle = 90;\n                textAnchor = \"start\";\n                y = \".3em\";\n            } else {\n                textAnchor = \"middle\";\n                y = \".6em\";\n            }\n        }\n        var round = Math.round;\n        return labelAttributes({\n            x: round(tx),\n            y: round(ty),\n            angle: orientAngle,\n            attrs: {\n                labelText: {\n                    y: y,\n                    textAnchor: textAnchor\n                }\n            }\n        });\n    }\n    function getBBoxAngles(elBBox) {\n        var center = elBBox.center();\n        var tl = center.theta(elBBox.origin());\n        var bl = center.theta(elBBox.bottomLeft());\n        var br = center.theta(elBBox.corner());\n        var tr = center.theta(elBBox.topRight());\n        return [\n            tl,\n            tr,\n            br,\n            bl\n        ];\n    }\n    function insideLayout(portPosition, elBBox, autoOrient, opt) {\n        var angle = elBBox.center().theta(portPosition);\n        opt = defaults({}, opt, {\n            offset: 15\n        });\n        var tx, ty, y, textAnchor;\n        var offset = opt.offset;\n        var orientAngle = 0;\n        var bBoxAngles = getBBoxAngles(elBBox);\n        if (angle < bBoxAngles[1] || angle > bBoxAngles[2]) {\n            y = \".3em\";\n            tx = -offset;\n            ty = 0;\n            textAnchor = \"end\";\n        } else if (angle < bBoxAngles[0]) {\n            tx = 0;\n            ty = offset;\n            if (autoOrient) {\n                orientAngle = 90;\n                textAnchor = \"start\";\n                y = \".3em\";\n            } else {\n                textAnchor = \"middle\";\n                y = \".6em\";\n            }\n        } else if (angle < bBoxAngles[3]) {\n            y = \".3em\";\n            tx = offset;\n            ty = 0;\n            textAnchor = \"start\";\n        } else {\n            tx = 0;\n            ty = -offset;\n            if (autoOrient) {\n                orientAngle = -90;\n                textAnchor = \"start\";\n                y = \".3em\";\n            } else {\n                textAnchor = \"middle\";\n                y = \"0\";\n            }\n        }\n        var round = Math.round;\n        return labelAttributes({\n            x: round(tx),\n            y: round(ty),\n            angle: orientAngle,\n            attrs: {\n                labelText: {\n                    y: y,\n                    textAnchor: textAnchor\n                }\n            }\n        });\n    }\n    function radialLayout(portCenterOffset, autoOrient, opt) {\n        opt = defaults({}, opt, {\n            offset: 20\n        });\n        var origin = point(0, 0);\n        var angle = -portCenterOffset.theta(origin);\n        var orientAngle = angle;\n        var offset = portCenterOffset.clone().move(origin, opt.offset).difference(portCenterOffset).round();\n        var y = \".3em\";\n        var textAnchor;\n        if ((angle + 90) % 180 === 0) {\n            textAnchor = autoOrient ? \"end\" : \"middle\";\n            if (!autoOrient && angle === -270) y = \"0em\";\n        } else if (angle > -270 && angle < -90) {\n            textAnchor = \"start\";\n            orientAngle = angle - 180;\n        } else textAnchor = \"end\";\n        var round = Math.round;\n        return labelAttributes({\n            x: round(offset.x),\n            y: round(offset.y),\n            angle: autoOrient ? orientAngle : 0,\n            attrs: {\n                labelText: {\n                    y: y,\n                    textAnchor: textAnchor\n                }\n            }\n        });\n    }\n    var manual = function(_portPosition, _elBBox, opt) {\n        return labelAttributes(opt);\n    };\n    var left$1 = function(portPosition, elBBox, opt) {\n        return labelAttributes(opt, {\n            x: -15,\n            attrs: {\n                labelText: {\n                    y: \".3em\",\n                    textAnchor: \"end\"\n                }\n            }\n        });\n    };\n    var right$1 = function(portPosition, elBBox, opt) {\n        return labelAttributes(opt, {\n            x: 15,\n            attrs: {\n                labelText: {\n                    y: \".3em\",\n                    textAnchor: \"start\"\n                }\n            }\n        });\n    };\n    var top$1 = function(portPosition, elBBox, opt) {\n        return labelAttributes(opt, {\n            y: -15,\n            attrs: {\n                labelText: {\n                    y: \"0\",\n                    textAnchor: \"middle\"\n                }\n            }\n        });\n    };\n    var bottom$1 = function(portPosition, elBBox, opt) {\n        return labelAttributes(opt, {\n            y: 15,\n            attrs: {\n                labelText: {\n                    y: \".6em\",\n                    textAnchor: \"middle\"\n                }\n            }\n        });\n    };\n    var outsideOriented = function(portPosition, elBBox, opt) {\n        return outsideLayout(portPosition, elBBox, true, opt);\n    };\n    var outside = function(portPosition, elBBox, opt) {\n        return outsideLayout(portPosition, elBBox, false, opt);\n    };\n    var insideOriented = function(portPosition, elBBox, opt) {\n        return insideLayout(portPosition, elBBox, true, opt);\n    };\n    var inside = function(portPosition, elBBox, opt) {\n        return insideLayout(portPosition, elBBox, false, opt);\n    };\n    var radial = function(portPosition, elBBox, opt) {\n        return radialLayout(portPosition.difference(elBBox.center()), false, opt);\n    };\n    var radialOriented = function(portPosition, elBBox, opt) {\n        return radialLayout(portPosition.difference(elBBox.center()), true, opt);\n    };\n    var PortLabel = {\n        manual: manual,\n        left: left$1,\n        right: right$1,\n        top: top$1,\n        bottom: bottom$1,\n        outsideOriented: outsideOriented,\n        outside: outside,\n        insideOriented: insideOriented,\n        inside: inside,\n        radial: radial,\n        radialOriented: radialOriented\n    };\n    // Link base model.\n    // --------------------------\n    var Link = Cell.extend({\n        // The default markup for links.\n        markup: [\n            '<path class=\"connection\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\n            '<path class=\"marker-source\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\n            '<path class=\"marker-target\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\n            '<path class=\"connection-wrap\" d=\"M 0 0 0 0\"/>',\n            '<g class=\"labels\"/>',\n            '<g class=\"marker-vertices\"/>',\n            '<g class=\"marker-arrowheads\"/>',\n            '<g class=\"link-tools\"/>'\n        ].join(\"\"),\n        toolMarkup: [\n            '<g class=\"link-tool\">',\n            '<g class=\"tool-remove\" event=\"remove\">',\n            '<circle r=\"11\" />',\n            '<path transform=\"scale(.8) translate(-16, -16)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\" />',\n            \"<title>Remove link.</title>\",\n            \"</g>\",\n            '<g class=\"tool-options\" event=\"link:options\">',\n            '<circle r=\"11\" transform=\"translate(25)\"/>',\n            '<path fill=\"white\" transform=\"scale(.55) translate(29, -16)\" d=\"M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z\"/>',\n            \"<title>Link options.</title>\",\n            \"</g>\",\n            \"</g>\"\n        ].join(\"\"),\n        doubleToolMarkup: undefined,\n        // The default markup for showing/removing vertices. These elements are the children of the .marker-vertices element (see `this.markup`).\n        // Only .marker-vertex and .marker-vertex-remove element have special meaning. The former is used for\n        // dragging vertices (changing their position). The latter is used for removing vertices.\n        vertexMarkup: [\n            '<g class=\"marker-vertex-group\" transform=\"translate(<%= x %>, <%= y %>)\">',\n            '<circle class=\"marker-vertex\" idx=\"<%= idx %>\" r=\"10\" />',\n            '<path class=\"marker-vertex-remove-area\" idx=\"<%= idx %>\" d=\"M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z\" transform=\"translate(5, -33)\"/>',\n            '<path class=\"marker-vertex-remove\" idx=\"<%= idx %>\" transform=\"scale(.8) translate(9.5, -37)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\">',\n            \"<title>Remove vertex.</title>\",\n            \"</path>\",\n            \"</g>\"\n        ].join(\"\"),\n        arrowheadMarkup: [\n            '<g class=\"marker-arrowhead-group marker-arrowhead-group-<%= end %>\">',\n            '<path class=\"marker-arrowhead\" end=\"<%= end %>\" d=\"M 26 0 L 0 13 L 26 26 z\" />',\n            \"</g>\"\n        ].join(\"\"),\n        // may be overwritten by user to change default label (its markup, size, attrs, position)\n        defaultLabel: undefined,\n        // deprecated\n        // may be overwritten by user to change default label markup\n        // lower priority than defaultLabel.markup\n        labelMarkup: undefined,\n        // private\n        _builtins: {\n            defaultLabel: {\n                // builtin default markup:\n                // used if neither defaultLabel.markup\n                // nor label.markup is set\n                markup: [\n                    {\n                        tagName: \"rect\",\n                        selector: \"rect\" // faster than tagName CSS selector\n                    },\n                    {\n                        tagName: \"text\",\n                        selector: \"text\" // faster than tagName CSS selector\n                    }\n                ],\n                // builtin default attributes:\n                // applied only if builtin default markup is used\n                attrs: {\n                    text: {\n                        fill: \"#000000\",\n                        fontSize: 14,\n                        textAnchor: \"middle\",\n                        yAlignment: \"middle\",\n                        pointerEvents: \"none\"\n                    },\n                    rect: {\n                        ref: \"text\",\n                        fill: \"#ffffff\",\n                        rx: 3,\n                        ry: 3,\n                        refWidth: 1,\n                        refHeight: 1,\n                        refX: 0,\n                        refY: 0\n                    }\n                },\n                // builtin default position:\n                // used if neither defaultLabel.position\n                // nor label.position is set\n                position: {\n                    distance: 0.5\n                }\n            }\n        },\n        defaults: {\n            type: \"link\",\n            source: {},\n            target: {}\n        },\n        isLink: function() {\n            return true;\n        },\n        disconnect: function(opt) {\n            return this.set({\n                source: {\n                    x: 0,\n                    y: 0\n                },\n                target: {\n                    x: 0,\n                    y: 0\n                }\n            }, opt);\n        },\n        source: function(source, args, opt) {\n            // getter\n            if (source === undefined) return clone(this.get(\"source\"));\n            // setter\n            var setSource;\n            var setOpt;\n            // `source` is a cell\n            // take only its `id` and combine with `args`\n            var isCellProvided = source instanceof Cell;\n            if (isCellProvided) {\n                setSource = clone(args) || {};\n                setSource.id = source.id;\n                setOpt = opt;\n                return this.set(\"source\", setSource, setOpt);\n            }\n            // `source` is a point-like object\n            // for example, a g.Point\n            // take only its `x` and `y` and combine with `args`\n            var isPointProvided = !isPlainObject(source);\n            if (isPointProvided) {\n                setSource = clone(args) || {};\n                setSource.x = source.x;\n                setSource.y = source.y;\n                setOpt = opt;\n                return this.set(\"source\", setSource, setOpt);\n            }\n            // `source` is an object\n            // no checking\n            // two arguments\n            setSource = source;\n            setOpt = args;\n            return this.set(\"source\", setSource, setOpt);\n        },\n        target: function(target, args, opt) {\n            // getter\n            if (target === undefined) return clone(this.get(\"target\"));\n            // setter\n            var setTarget;\n            var setOpt;\n            // `target` is a cell\n            // take only its `id` argument and combine with `args`\n            var isCellProvided = target instanceof Cell;\n            if (isCellProvided) {\n                setTarget = clone(args) || {};\n                setTarget.id = target.id;\n                setOpt = opt;\n                return this.set(\"target\", setTarget, setOpt);\n            }\n            // `target` is a point-like object\n            // for example, a g.Point\n            // take only its `x` and `y` and combine with `args`\n            var isPointProvided = !isPlainObject(target);\n            if (isPointProvided) {\n                setTarget = clone(args) || {};\n                setTarget.x = target.x;\n                setTarget.y = target.y;\n                setOpt = opt;\n                return this.set(\"target\", setTarget, setOpt);\n            }\n            // `target` is an object\n            // no checking\n            // two arguments\n            setTarget = target;\n            setOpt = args;\n            return this.set(\"target\", setTarget, setOpt);\n        },\n        router: function(name, args, opt) {\n            // getter\n            if (name === undefined) {\n                var router = this.get(\"router\");\n                if (!router) {\n                    if (this.get(\"manhattan\")) return {\n                        name: \"orthogonal\"\n                    };\n                     // backwards compatibility\n                    return null;\n                }\n                if (typeof router === \"object\") return clone(router);\n                return router; // e.g. a function\n            }\n            // setter\n            var isRouterProvided = typeof name === \"object\" || typeof name === \"function\";\n            var localRouter = isRouterProvided ? name : {\n                name: name,\n                args: args\n            };\n            var localOpt = isRouterProvided ? args : opt;\n            return this.set(\"router\", localRouter, localOpt);\n        },\n        connector: function(name, args, opt) {\n            // getter\n            if (name === undefined) {\n                var connector = this.get(\"connector\");\n                if (!connector) {\n                    if (this.get(\"smooth\")) return {\n                        name: \"smooth\"\n                    };\n                     // backwards compatibility\n                    return null;\n                }\n                if (typeof connector === \"object\") return clone(connector);\n                return connector; // e.g. a function\n            }\n            // setter\n            var isConnectorProvided = typeof name === \"object\" || typeof name === \"function\";\n            var localConnector = isConnectorProvided ? name : {\n                name: name,\n                args: args\n            };\n            var localOpt = isConnectorProvided ? args : opt;\n            return this.set(\"connector\", localConnector, localOpt);\n        },\n        // Labels API\n        // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.\n        label: function(idx, label, opt) {\n            var labels = this.labels();\n            idx = isFinite(idx) && idx !== null ? idx | 0 : 0;\n            if (idx < 0) idx = labels.length + idx;\n            // getter\n            if (arguments.length <= 1) return this.prop([\n                \"labels\",\n                idx\n            ]);\n            // setter\n            return this.prop([\n                \"labels\",\n                idx\n            ], label, opt);\n        },\n        labels: function(labels, opt) {\n            // getter\n            if (arguments.length === 0) {\n                labels = this.get(\"labels\");\n                if (!Array.isArray(labels)) return [];\n                return labels.slice();\n            }\n            // setter\n            if (!Array.isArray(labels)) labels = [];\n            return this.set(\"labels\", labels, opt);\n        },\n        hasLabels: function() {\n            var ref = this.attributes;\n            var labels = ref.labels;\n            return Array.isArray(labels) && labels.length > 0;\n        },\n        insertLabel: function(idx, label, opt) {\n            if (!label) throw new Error(\"dia.Link: no label provided\");\n            var labels = this.labels();\n            var n = labels.length;\n            idx = isFinite(idx) && idx !== null ? idx | 0 : n;\n            if (idx < 0) idx = n + idx + 1;\n            labels.splice(idx, 0, label);\n            return this.labels(labels, opt);\n        },\n        // convenience function\n        // add label to end of labels array\n        appendLabel: function(label, opt) {\n            return this.insertLabel(-1, label, opt);\n        },\n        removeLabel: function(idx, opt) {\n            var labels = this.labels();\n            idx = isFinite(idx) && idx !== null ? idx | 0 : -1;\n            labels.splice(idx, 1);\n            return this.labels(labels, opt);\n        },\n        // Vertices API\n        vertex: function(idx, vertex, opt) {\n            var vertices = this.vertices();\n            idx = isFinite(idx) && idx !== null ? idx | 0 : 0;\n            if (idx < 0) idx = vertices.length + idx;\n            // getter\n            if (arguments.length <= 1) return this.prop([\n                \"vertices\",\n                idx\n            ]);\n            // setter\n            var setVertex = this._normalizeVertex(vertex);\n            return this.prop([\n                \"vertices\",\n                idx\n            ], setVertex, opt);\n        },\n        vertices: function(vertices, opt) {\n            // getter\n            if (arguments.length === 0) {\n                vertices = this.get(\"vertices\");\n                if (!Array.isArray(vertices)) return [];\n                return vertices.slice();\n            }\n            // setter\n            if (!Array.isArray(vertices)) vertices = [];\n            var setVertices = [];\n            for(var i = 0; i < vertices.length; i++){\n                var vertex = vertices[i];\n                var setVertex = this._normalizeVertex(vertex);\n                setVertices.push(setVertex);\n            }\n            return this.set(\"vertices\", setVertices, opt);\n        },\n        insertVertex: function(idx, vertex, opt) {\n            if (!vertex) throw new Error(\"dia.Link: no vertex provided\");\n            var vertices = this.vertices();\n            var n = vertices.length;\n            idx = isFinite(idx) && idx !== null ? idx | 0 : n;\n            if (idx < 0) idx = n + idx + 1;\n            var setVertex = this._normalizeVertex(vertex);\n            vertices.splice(idx, 0, setVertex);\n            return this.vertices(vertices, opt);\n        },\n        removeVertex: function(idx, opt) {\n            var vertices = this.vertices();\n            idx = isFinite(idx) && idx !== null ? idx | 0 : -1;\n            vertices.splice(idx, 1);\n            return this.vertices(vertices, opt);\n        },\n        _normalizeVertex: function(vertex) {\n            // is vertex a point-like object?\n            // for example, a g.Point\n            var isPointProvided = !isPlainObject(vertex);\n            if (isPointProvided) return {\n                x: vertex.x,\n                y: vertex.y\n            };\n            // else: return vertex unchanged\n            return vertex;\n        },\n        // Transformations\n        translate: function(tx, ty, opt) {\n            // enrich the option object\n            opt = opt || {};\n            opt.translateBy = opt.translateBy || this.id;\n            opt.tx = tx;\n            opt.ty = ty;\n            return this.applyToPoints(function(p) {\n                return {\n                    x: (p.x || 0) + tx,\n                    y: (p.y || 0) + ty\n                };\n            }, opt);\n        },\n        scale: function(sx, sy, origin, opt) {\n            return this.applyToPoints(function(p) {\n                return Point(p).scale(sx, sy, origin).toJSON();\n            }, opt);\n        },\n        applyToPoints: function(fn, opt) {\n            if (!isFunction(fn)) throw new TypeError(\"dia.Link: applyToPoints expects its first parameter to be a function.\");\n            var attrs = {};\n            var ref = this.attributes;\n            var source = ref.source;\n            var target = ref.target;\n            if (!source.id) attrs.source = fn(source);\n            if (!target.id) attrs.target = fn(target);\n            var vertices = this.vertices();\n            if (vertices.length > 0) attrs.vertices = vertices.map(fn);\n            return this.set(attrs, opt);\n        },\n        getSourcePoint: function() {\n            var sourceCell = this.getSourceCell();\n            if (!sourceCell) return new Point(this.source());\n            return sourceCell.getPointFromConnectedLink(this, \"source\");\n        },\n        getTargetPoint: function() {\n            var targetCell = this.getTargetCell();\n            if (!targetCell) return new Point(this.target());\n            return targetCell.getPointFromConnectedLink(this, \"target\");\n        },\n        getPointFromConnectedLink: function() {\n            return this.getPolyline().pointAt(0.5);\n        },\n        getPolyline: function() {\n            var points = [\n                this.getSourcePoint()\n            ].concat(this.vertices().map(Point), [\n                this.getTargetPoint()\n            ]);\n            return new Polyline(points);\n        },\n        getBBox: function() {\n            return this.getPolyline().bbox();\n        },\n        reparent: function(opt) {\n            var newParent;\n            if (this.graph) {\n                var source = this.getSourceElement();\n                var target = this.getTargetElement();\n                var prevParent = this.getParentCell();\n                if (source && target) {\n                    if (source === target || source.isEmbeddedIn(target)) newParent = target;\n                    else if (target.isEmbeddedIn(source)) newParent = source;\n                    else newParent = this.graph.getCommonAncestor(source, target);\n                }\n                if (prevParent && (!newParent || newParent.id !== prevParent.id)) // Unembed the link if source and target has no common ancestor\n                // or common ancestor changed\n                prevParent.unembed(this, opt);\n                if (newParent) newParent.embed(this, opt);\n            }\n            return newParent;\n        },\n        hasLoop: function(opt) {\n            opt = opt || {};\n            var ref = this.attributes;\n            var source = ref.source;\n            var target = ref.target;\n            var sourceId = source.id;\n            var targetId = target.id;\n            if (!sourceId || !targetId) // Link \"pinned\" to the paper does not have a loop.\n            return false;\n            var loop = sourceId === targetId;\n            // Note that there in the deep mode a link can have a loop,\n            // even if it connects only a parent and its embed.\n            // A loop \"target equals source\" is valid in both shallow and deep mode.\n            if (!loop && opt.deep && this.graph) {\n                var sourceElement = this.getSourceCell();\n                var targetElement = this.getTargetCell();\n                loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);\n            }\n            return loop;\n        },\n        // unlike source(), this method returns null if source is a point\n        getSourceCell: function() {\n            var ref = this;\n            var graph = ref.graph;\n            var attributes = ref.attributes;\n            var source = attributes.source;\n            return source && source.id && graph && graph.getCell(source.id) || null;\n        },\n        getSourceElement: function() {\n            var cell = this;\n            var visited = {};\n            do {\n                if (visited[cell.id]) return null;\n                visited[cell.id] = true;\n                cell = cell.getSourceCell();\n            }while (cell && cell.isLink());\n            return cell;\n        },\n        // unlike target(), this method returns null if target is a point\n        getTargetCell: function() {\n            var ref = this;\n            var graph = ref.graph;\n            var attributes = ref.attributes;\n            var target = attributes.target;\n            return target && target.id && graph && graph.getCell(target.id) || null;\n        },\n        getTargetElement: function() {\n            var cell = this;\n            var visited = {};\n            do {\n                if (visited[cell.id]) return null;\n                visited[cell.id] = true;\n                cell = cell.getTargetCell();\n            }while (cell && cell.isLink());\n            return cell;\n        },\n        // Returns the common ancestor for the source element,\n        // target element and the link itself.\n        getRelationshipAncestor: function() {\n            var connectionAncestor;\n            if (this.graph) {\n                var cells = [\n                    this,\n                    this.getSourceElement(),\n                    this.getTargetElement() // null if target is a point\n                ].filter(function(item) {\n                    return !!item;\n                });\n                connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);\n            }\n            return connectionAncestor || null;\n        },\n        // Is source, target and the link itself embedded in a given cell?\n        isRelationshipEmbeddedIn: function(cell) {\n            var cellId = isString(cell) || isNumber(cell) ? cell : cell.id;\n            var ancestor = this.getRelationshipAncestor();\n            return !!ancestor && (ancestor.id === cellId || ancestor.isEmbeddedIn(cellId));\n        },\n        // Get resolved default label.\n        _getDefaultLabel: function() {\n            var defaultLabel = this.get(\"defaultLabel\") || this.defaultLabel || {};\n            var label = {};\n            label.markup = defaultLabel.markup || this.get(\"labelMarkup\") || this.labelMarkup;\n            label.position = defaultLabel.position;\n            label.attrs = defaultLabel.attrs;\n            label.size = defaultLabel.size;\n            return label;\n        }\n    }, {\n        endsEqual: function(a, b) {\n            var portsEqual = a.port === b.port || !a.port && !b.port;\n            return a.id === b.id && portsEqual;\n        }\n    });\n    var PortData = function(data) {\n        var clonedData = cloneDeep(data) || {};\n        this.ports = [];\n        this.groups = {};\n        this.portLayoutNamespace = Port;\n        this.portLabelLayoutNamespace = PortLabel;\n        this._init(clonedData);\n    };\n    PortData.prototype = {\n        getPorts: function() {\n            return this.ports;\n        },\n        getGroup: function(name) {\n            return this.groups[name] || {};\n        },\n        getPortsByGroup: function(groupName) {\n            return this.ports.filter(function(port) {\n                return port.group === groupName;\n            });\n        },\n        getGroupPortsMetrics: function(groupName, elBBox) {\n            var group = this.getGroup(groupName);\n            var ports = this.getPortsByGroup(groupName);\n            var groupPosition = group.position || {};\n            var groupPositionName = groupPosition.name;\n            var namespace = this.portLayoutNamespace;\n            if (!namespace[groupPositionName]) groupPositionName = \"left\";\n            var groupArgs = groupPosition.args || {};\n            var portsArgs = ports.map(function(port) {\n                return port && port.position && port.position.args;\n            });\n            var groupPortTransformations = namespace[groupPositionName](portsArgs, elBBox, groupArgs);\n            var accumulator = {\n                ports: ports,\n                result: []\n            };\n            toArray(groupPortTransformations).reduce((function(res, portTransformation, index) {\n                var port = res.ports[index];\n                res.result.push({\n                    portId: port.id,\n                    portTransformation: portTransformation,\n                    labelTransformation: this._getPortLabelLayout(port, Point(portTransformation), elBBox),\n                    portAttrs: port.attrs,\n                    portSize: port.size,\n                    labelSize: port.label.size\n                });\n                return res;\n            }).bind(this), accumulator);\n            return accumulator.result;\n        },\n        _getPortLabelLayout: function(port, portPosition, elBBox) {\n            var namespace = this.portLabelLayoutNamespace;\n            var labelPosition = port.label.position.name || \"left\";\n            if (namespace[labelPosition]) return namespace[labelPosition](portPosition, elBBox, port.label.position.args);\n            return null;\n        },\n        _init: function(data) {\n            // prepare groups\n            if (isObject$1(data.groups)) {\n                var groups = Object.keys(data.groups);\n                for(var i = 0, n = groups.length; i < n; i++){\n                    var key = groups[i];\n                    this.groups[key] = this._evaluateGroup(data.groups[key]);\n                }\n            }\n            // prepare ports\n            var ports = toArray(data.items);\n            for(var j = 0, m = ports.length; j < m; j++)this.ports.push(this._evaluatePort(ports[j]));\n        },\n        _evaluateGroup: function(group) {\n            return merge(group, {\n                position: this._getPosition(group.position, true),\n                label: this._getLabel(group, true)\n            });\n        },\n        _evaluatePort: function(port) {\n            var evaluated = assign({}, port);\n            var group = this.getGroup(port.group);\n            evaluated.markup = evaluated.markup || group.markup;\n            evaluated.attrs = merge({}, group.attrs, evaluated.attrs);\n            evaluated.position = this._createPositionNode(group, evaluated);\n            evaluated.label = merge({}, group.label, this._getLabel(evaluated));\n            evaluated.z = this._getZIndex(group, evaluated);\n            evaluated.size = assign({}, group.size, evaluated.size);\n            return evaluated;\n        },\n        _getZIndex: function(group, port) {\n            if (isNumber(port.z)) return port.z;\n            if (isNumber(group.z) || group.z === \"auto\") return group.z;\n            return \"auto\";\n        },\n        _createPositionNode: function(group, port) {\n            return merge({\n                name: \"left\",\n                args: {}\n            }, group.position, {\n                args: port.args\n            });\n        },\n        _getPosition: function(position, setDefault) {\n            var args = {};\n            var positionName;\n            if (isFunction(position)) {\n                positionName = \"fn\";\n                args.fn = position;\n            } else if (isString(position)) positionName = position;\n            else if (position === undefined) positionName = setDefault ? \"left\" : null;\n            else if (Array.isArray(position)) {\n                positionName = \"absolute\";\n                args.x = position[0];\n                args.y = position[1];\n            } else if (isObject$1(position)) {\n                positionName = position.name;\n                assign(args, position.args);\n            }\n            var result = {\n                args: args\n            };\n            if (positionName) result.name = positionName;\n            return result;\n        },\n        _getLabel: function(item, setDefaults) {\n            var label = item.label || {};\n            var ret = label;\n            ret.position = this._getPosition(label.position, setDefaults);\n            return ret;\n        }\n    };\n    var elementPortPrototype = {\n        _initializePorts: function() {\n            this._createPortData();\n            this.on(\"change:ports\", function() {\n                this._processRemovedPort();\n                this._createPortData();\n            }, this);\n        },\n        /**\n\t     * remove links tied wiht just removed element\n\t     * @private\n\t     */ _processRemovedPort: function() {\n            var current = this.get(\"ports\") || {};\n            var currentItemsMap = {};\n            toArray(current.items).forEach(function(item) {\n                currentItemsMap[item.id] = true;\n            });\n            var previous = this.previous(\"ports\") || {};\n            var removed = {};\n            toArray(previous.items).forEach(function(item) {\n                if (!currentItemsMap[item.id]) removed[item.id] = true;\n            });\n            var graph = this.graph;\n            if (graph && !isEmpty(removed)) {\n                var inboundLinks = graph.getConnectedLinks(this, {\n                    inbound: true\n                });\n                inboundLinks.forEach(function(link) {\n                    if (removed[link.get(\"target\").port]) link.remove();\n                });\n                var outboundLinks = graph.getConnectedLinks(this, {\n                    outbound: true\n                });\n                outboundLinks.forEach(function(link) {\n                    if (removed[link.get(\"source\").port]) link.remove();\n                });\n            }\n        },\n        /**\n\t     * @returns {boolean}\n\t     */ hasPorts: function() {\n            var ports = this.prop(\"ports/items\");\n            return Array.isArray(ports) && ports.length > 0;\n        },\n        /**\n\t     * @param {string} id\n\t     * @returns {boolean}\n\t     */ hasPort: function(id) {\n            return this.getPortIndex(id) !== -1;\n        },\n        /**\n\t     * @returns {Array<object>}\n\t     */ getPorts: function() {\n            return cloneDeep(this.prop(\"ports/items\")) || [];\n        },\n        /**\n\t     * @returns {Array<object>}\n\t     */ getGroupPorts: function(groupName) {\n            var groupPorts = toArray(this.prop([\n                \"ports\",\n                \"items\"\n            ])).filter(function(port) {\n                return port.group === groupName;\n            });\n            return cloneDeep(groupPorts);\n        },\n        /**\n\t     * @param {string} id\n\t     * @returns {object}\n\t     */ getPort: function(id) {\n            return cloneDeep(toArray(this.prop(\"ports/items\")).find(function(port) {\n                return port.id && port.id === id;\n            }));\n        },\n        /**\n\t     * @param {string} groupName\n\t     * @returns {Object<portId, {x: number, y: number, angle: number}>}\n\t     */ getPortsPositions: function(groupName) {\n            var portsMetrics = this._portSettingsData.getGroupPortsMetrics(groupName, Rect(this.size()));\n            return portsMetrics.reduce(function(positions, metrics) {\n                var transformation = metrics.portTransformation;\n                positions[metrics.portId] = {\n                    x: transformation.x,\n                    y: transformation.y,\n                    angle: transformation.angle\n                };\n                return positions;\n            }, {});\n        },\n        /**\n\t     * @param {string|Port} port port id or port\n\t     * @returns {number} port index\n\t     */ getPortIndex: function(port) {\n            var id = isObject$1(port) ? port.id : port;\n            if (!this._isValidPortId(id)) return -1;\n            return toArray(this.prop(\"ports/items\")).findIndex(function(item) {\n                return item.id === id;\n            });\n        },\n        /**\n\t     * @param {object} port\n\t     * @param {object} [opt]\n\t     * @returns {joint.dia.Element}\n\t     */ addPort: function(port, opt) {\n            if (!isObject$1(port) || Array.isArray(port)) throw new Error(\"Element: addPort requires an object.\");\n            var ports = assign([], this.prop(\"ports/items\"));\n            ports.push(port);\n            this.prop(\"ports/items\", ports, opt);\n            return this;\n        },\n        /**\n\t     * @param {string|Port|number} before\n\t     * @param {object} port\n\t     * @param {object} [opt]\n\t     * @returns {joint.dia.Element}\n\t     */ insertPort: function(before, port, opt) {\n            var index$1 = typeof before === \"number\" ? before : this.getPortIndex(before);\n            if (!isObject$1(port) || Array.isArray(port)) throw new Error(\"dia.Element: insertPort requires an object.\");\n            var ports = assign([], this.prop(\"ports/items\"));\n            ports.splice(index$1, 0, port);\n            this.prop(\"ports/items\", ports, opt);\n            return this;\n        },\n        /**\n\t     * @param {string} portId\n\t     * @param {string|object=} path\n\t     * @param {*=} value\n\t     * @param {object=} opt\n\t     * @returns {joint.dia.Element}\n\t     */ portProp: function(portId, path, value, opt) {\n            var index$1 = this.getPortIndex(portId);\n            if (index$1 === -1) throw new Error(\"Element: unable to find port with id \" + portId);\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (Array.isArray(path)) args[0] = [\n                \"ports\",\n                \"items\",\n                index$1\n            ].concat(path);\n            else if (isString(path)) // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = [\n                \"ports/items/\",\n                index$1,\n                \"/\",\n                path\n            ].join(\"\");\n            else {\n                args = [\n                    \"ports/items/\" + index$1\n                ];\n                if (isPlainObject(path)) {\n                    args.push(path);\n                    args.push(value);\n                }\n            }\n            return this.prop.apply(this, args);\n        },\n        _validatePorts: function() {\n            var portsAttr = this.get(\"ports\") || {};\n            var errorMessages = [];\n            portsAttr = portsAttr || {};\n            var ports = toArray(portsAttr.items);\n            ports.forEach(function(p) {\n                if (typeof p !== \"object\") errorMessages.push(\"Element: invalid port \", p);\n                if (!this._isValidPortId(p.id)) p.id = this.generatePortId();\n            }, this);\n            if (uniq(ports, \"id\").length !== ports.length) errorMessages.push(\"Element: found id duplicities in ports.\");\n            return errorMessages;\n        },\n        generatePortId: function() {\n            return this.generateId();\n        },\n        /**\n\t     * @param {string} id port id\n\t     * @returns {boolean}\n\t     * @private\n\t     */ _isValidPortId: function(id) {\n            return id !== null && id !== undefined && !isObject$1(id);\n        },\n        addPorts: function(ports, opt) {\n            if (ports.length) this.prop(\"ports/items\", assign([], this.prop(\"ports/items\")).concat(ports), opt);\n            return this;\n        },\n        removePort: function(port, opt) {\n            var options = opt || {};\n            var index$1 = this.getPortIndex(port);\n            if (index$1 !== -1) {\n                var ports = assign([], this.prop([\n                    \"ports\",\n                    \"items\"\n                ]));\n                ports.splice(index$1, 1);\n                options.rewrite = true;\n                this.startBatch(\"port-remove\");\n                this.prop([\n                    \"ports\",\n                    \"items\"\n                ], ports, options);\n                this.stopBatch(\"port-remove\");\n            }\n            return this;\n        },\n        removePorts: function(portsForRemoval, opt) {\n            var options, newPorts;\n            if (Array.isArray(portsForRemoval)) {\n                options = opt || {};\n                if (portsForRemoval.length === 0) return this.this;\n                var currentPorts = assign([], this.prop([\n                    \"ports\",\n                    \"items\"\n                ]));\n                newPorts = currentPorts.filter(function(cp) {\n                    return !portsForRemoval.some(function(rp) {\n                        var rpId = isObject$1(rp) ? rp.id : rp;\n                        return cp.id === rpId;\n                    });\n                });\n            } else {\n                options = portsForRemoval || {};\n                newPorts = [];\n            }\n            this.startBatch(\"port-remove\");\n            options.rewrite = true;\n            this.prop([\n                \"ports\",\n                \"items\"\n            ], newPorts, options);\n            this.stopBatch(\"port-remove\");\n            return this;\n        },\n        /**\n\t     * @private\n\t     */ _createPortData: function() {\n            var err = this._validatePorts();\n            if (err.length > 0) {\n                this.set(\"ports\", this.previous(\"ports\"));\n                throw new Error(err.join(\" \"));\n            }\n            var prevPortData;\n            if (this._portSettingsData) prevPortData = this._portSettingsData.getPorts();\n            this._portSettingsData = new PortData(this.get(\"ports\"));\n            var curPortData = this._portSettingsData.getPorts();\n            if (prevPortData) {\n                var added = curPortData.filter(function(item) {\n                    if (!prevPortData.find(function(prevPort) {\n                        return prevPort.id === item.id;\n                    })) return item;\n                });\n                var removed = prevPortData.filter(function(item) {\n                    if (!curPortData.find(function(curPort) {\n                        return curPort.id === item.id;\n                    })) return item;\n                });\n                if (removed.length > 0) this.trigger(\"ports:remove\", this, removed);\n                if (added.length > 0) this.trigger(\"ports:add\", this, added);\n            }\n        }\n    };\n    var elementViewPortPrototype = {\n        portContainerMarkup: \"g\",\n        portMarkup: [\n            {\n                tagName: \"circle\",\n                selector: \"circle\",\n                attributes: {\n                    \"r\": 10,\n                    \"fill\": \"#FFFFFF\",\n                    \"stroke\": \"#000000\"\n                }\n            }\n        ],\n        portLabelMarkup: [\n            {\n                tagName: \"text\",\n                selector: \"text\",\n                attributes: {\n                    \"fill\": \"#000000\"\n                }\n            }\n        ],\n        /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */ _portElementsCache: null,\n        /**\n\t     * @private\n\t     */ _initializePorts: function() {\n            this._cleanPortsCache();\n        },\n        /**\n\t     * @typedef {Object} Port\n\t     *\n\t     * @property {string} id\n\t     * @property {Object} position\n\t     * @property {Object} label\n\t     * @property {Object} attrs\n\t     * @property {string} markup\n\t     * @property {string} group\n\t     */ /**\n\t     * @private\n\t     */ _refreshPorts: function() {\n            this._removePorts();\n            this._cleanPortsCache();\n            this._renderPorts();\n        },\n        _cleanPortsCache: function() {\n            this._portElementsCache = {};\n        },\n        /**\n\t     * @private\n\t     */ _renderPorts: function() {\n            // references to rendered elements without z-index\n            var elementReferences = [];\n            var elem = this._getContainerElement();\n            for(var i = 0, count = elem.node.childNodes.length; i < count; i++)elementReferences.push(elem.node.childNodes[i]);\n            var portsGropsByZ = groupBy(this.model._portSettingsData.getPorts(), \"z\");\n            var withoutZKey = \"auto\";\n            // render non-z first\n            toArray(portsGropsByZ[withoutZKey]).forEach(function(port) {\n                var portElement = this._getPortElement(port);\n                elem.append(portElement);\n                elementReferences.push(portElement);\n            }, this);\n            var groupNames = Object.keys(portsGropsByZ);\n            for(var k = 0; k < groupNames.length; k++){\n                var groupName = groupNames[k];\n                if (groupName !== withoutZKey) {\n                    var z = parseInt(groupName, 10);\n                    this._appendPorts(portsGropsByZ[groupName], z, elementReferences);\n                }\n            }\n            this._updatePorts();\n        },\n        /**\n\t     * @returns {V}\n\t     * @private\n\t     */ _getContainerElement: function() {\n            return this.rotatableNode || this.vel;\n        },\n        /**\n\t     * @param {Array<Port>}ports\n\t     * @param {number} z\n\t     * @param refs\n\t     * @private\n\t     */ _appendPorts: function(ports, z, refs) {\n            var containerElement = this._getContainerElement();\n            var portElements = toArray(ports).map(this._getPortElement, this);\n            if (refs[z] || z < 0) V(refs[Math.max(z, 0)]).before(portElements);\n            else containerElement.append(portElements);\n        },\n        /**\n\t     * Try to get element from cache,\n\t     * @param port\n\t     * @returns {*}\n\t     * @private\n\t     */ _getPortElement: function(port) {\n            if (this._portElementsCache[port.id]) return this._portElementsCache[port.id].portElement;\n            return this._createPortElement(port);\n        },\n        findPortNode: function(portId, selector) {\n            var portCache = this._portElementsCache[portId];\n            if (!portCache) return null;\n            if (!selector) return portCache.portContentElement.node;\n            var portRoot = portCache.portElement.node;\n            var portSelectors = portCache.portSelectors;\n            var ref = this.findBySelector(selector, portRoot, portSelectors);\n            var node = ref[0];\n            if (node === void 0) node = null;\n            return node;\n        },\n        /**\n\t     * @private\n\t     */ _updatePorts: function() {\n            // layout ports without group\n            this._updatePortGroup(undefined);\n            // layout ports with explicit group\n            var groupsNames = Object.keys(this.model._portSettingsData.groups);\n            groupsNames.forEach(this._updatePortGroup, this);\n        },\n        /**\n\t     * @private\n\t     */ _removePorts: function() {\n            invoke(this._portElementsCache, \"portElement.remove\");\n        },\n        /**\n\t     * @param {Port} port\n\t     * @returns {V}\n\t     * @private\n\t     */ _createPortElement: function(port) {\n            var portElement;\n            var labelElement;\n            var labelSelectors;\n            var portSelectors;\n            var portContainerElement = V(this.portContainerMarkup).addClass(\"joint-port\");\n            var portMarkup = this._getPortMarkup(port);\n            if (Array.isArray(portMarkup)) {\n                var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);\n                var portFragment = portDoc.fragment;\n                if (portFragment.childNodes.length > 1) portElement = V(\"g\").append(portFragment);\n                else portElement = V(portFragment.firstChild);\n                portSelectors = portDoc.selectors;\n            } else {\n                portElement = V(portMarkup);\n                if (Array.isArray(portElement)) portElement = V(\"g\").append(portElement);\n            }\n            if (!portElement) throw new Error(\"ElementView: Invalid port markup.\");\n            portElement.attr({\n                \"port\": port.id,\n                \"port-group\": port.group\n            });\n            var labelMarkupDef = this._getPortLabelMarkup(port.label);\n            if (Array.isArray(labelMarkupDef)) {\n                // JSON Markup\n                var ref = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);\n                var fragment = ref.fragment;\n                var selectors = ref.selectors;\n                var childCount = fragment.childNodes.length;\n                if (childCount > 0) {\n                    labelSelectors = selectors;\n                    labelElement = childCount === 1 ? V(fragment.firstChild) : V(\"g\").append(fragment);\n                }\n            } else {\n                // String Markup\n                labelElement = V(labelMarkupDef);\n                if (Array.isArray(labelElement)) labelElement = V(\"g\").append(labelElement);\n            }\n            var portContainerSelectors;\n            if (portSelectors && labelSelectors) {\n                for(var key in labelSelectors){\n                    if (portSelectors[key] && key !== this.selector) throw new Error(\"ElementView: selectors within port must be unique.\");\n                }\n                portContainerSelectors = assign({}, portSelectors, labelSelectors);\n            } else portContainerSelectors = portSelectors || labelSelectors || {};\n            // The `portRootSelector` points to the root SVGNode of the port.\n            // Either the implicit wrapping group <g/> in case the port consist of multiple SVGNodes.\n            // Or the single SVGNode of the port.\n            var portRootSelector = \"portRoot\";\n            // The `labelRootSelector` points to the root SVGNode of the label.\n            var labelRootSelector = \"labelRoot\";\n            // The `labelTextSelector` points to all text SVGNodes of the label.\n            var labelTextSelector = \"labelText\";\n            if (!(portRootSelector in portContainerSelectors)) portContainerSelectors[portRootSelector] = portElement.node;\n            if (labelElement) {\n                var labelNode = labelElement.node;\n                if (!(labelRootSelector in portContainerSelectors)) portContainerSelectors[labelRootSelector] = labelNode;\n                if (!(labelTextSelector in portContainerSelectors)) {\n                    // If the label is a <text> element, we can use it directly.\n                    // Otherwise, we need to find the <text> element within the label.\n                    var labelTextNode = labelElement.tagName() === \"TEXT\" ? labelNode : Array.from(labelNode.querySelectorAll(\"text\"));\n                    portContainerSelectors[labelTextSelector] = labelTextNode;\n                    if (!labelSelectors) labelSelectors = {};\n                    labelSelectors[labelTextSelector] = labelTextNode;\n                }\n            }\n            portContainerElement.append(portElement.addClass(\"joint-port-body\"));\n            if (labelElement) portContainerElement.append(labelElement.addClass(\"joint-port-label\"));\n            this._portElementsCache[port.id] = {\n                portElement: portContainerElement,\n                portLabelElement: labelElement,\n                portSelectors: portContainerSelectors,\n                portLabelSelectors: labelSelectors,\n                portContentElement: portElement,\n                portContentSelectors: portSelectors\n            };\n            return portContainerElement;\n        },\n        /**\n\t     * @param {string=} groupName\n\t     * @private\n\t     */ _updatePortGroup: function(groupName) {\n            var elementBBox = Rect(this.model.size());\n            var portsMetrics = this.model._portSettingsData.getGroupPortsMetrics(groupName, elementBBox);\n            for(var i = 0, n = portsMetrics.length; i < n; i++){\n                var metrics = portsMetrics[i];\n                var portId = metrics.portId;\n                var cached = this._portElementsCache[portId] || {};\n                var portTransformation = metrics.portTransformation;\n                var labelTransformation = metrics.labelTransformation;\n                if (labelTransformation && cached.portLabelElement) {\n                    this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {\n                        rootBBox: new Rect(metrics.labelSize),\n                        selectors: cached.portLabelSelectors\n                    });\n                    this.applyPortTransform(cached.portLabelElement, labelTransformation, -portTransformation.angle || 0);\n                }\n                this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {\n                    rootBBox: new Rect(metrics.portSize),\n                    selectors: cached.portSelectors\n                });\n                this.applyPortTransform(cached.portElement, portTransformation);\n            }\n        },\n        /**\n\t     * @param {Vectorizer} element\n\t     * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData\n\t     * @param {number=} initialAngle\n\t     * @constructor\n\t     */ applyPortTransform: function(element, transformData, initialAngle) {\n            var matrix = V.createSVGMatrix().rotate(initialAngle || 0).translate(transformData.x || 0, transformData.y || 0).rotate(transformData.angle || 0);\n            element.transform(matrix, {\n                absolute: true\n            });\n        },\n        /**\n\t     * @param {Port} port\n\t     * @returns {string}\n\t     * @private\n\t     */ _getPortMarkup: function(port) {\n            return port.markup || this.model.get(\"portMarkup\") || this.model.portMarkup || this.portMarkup;\n        },\n        /**\n\t     * @param {Object} label\n\t     * @returns {string}\n\t     * @private\n\t     */ _getPortLabelMarkup: function(label) {\n            return label.markup || this.model.get(\"portLabelMarkup\") || this.model.portLabelMarkup || this.portLabelMarkup;\n        }\n    };\n    // Element base model.\n    // -----------------------------\n    var Element$1 = Cell.extend({\n        defaults: {\n            position: {\n                x: 0,\n                y: 0\n            },\n            size: {\n                width: 1,\n                height: 1\n            },\n            angle: 0\n        },\n        initialize: function() {\n            this._initializePorts();\n            Cell.prototype.initialize.apply(this, arguments);\n        },\n        /**\n\t     * @abstract\n\t     */ _initializePorts: function() {\n        // implemented in ports.js\n        },\n        _refreshPorts: function() {\n        // implemented in ports.js\n        },\n        isElement: function() {\n            return true;\n        },\n        position: function(x, y, opt) {\n            var isSetter = isNumber(y);\n            opt = (isSetter ? opt : x) || {};\n            var parentRelative = opt.parentRelative;\n            var deep = opt.deep;\n            var restrictedArea = opt.restrictedArea;\n            // option `parentRelative` for setting the position relative to the element's parent.\n            var parentPosition;\n            if (parentRelative) {\n                // Getting the parent's position requires the collection.\n                // Cell.parent() holds cell id only.\n                if (!this.graph) throw new Error(\"Element must be part of a graph.\");\n                var parent = this.getParentCell();\n                if (parent && !parent.isLink()) parentPosition = parent.get(\"position\");\n            }\n            if (isSetter) {\n                if (parentPosition) {\n                    x += parentPosition.x;\n                    y += parentPosition.y;\n                }\n                if (deep || restrictedArea) {\n                    var ref = this.get(\"position\");\n                    var x0 = ref.x;\n                    var y0 = ref.y;\n                    this.translate(x - x0, y - y0, opt);\n                } else this.set(\"position\", {\n                    x: x,\n                    y: y\n                }, opt);\n                return this;\n            } else {\n                var elementPosition = Point(this.get(\"position\"));\n                return parentRelative ? elementPosition.difference(parentPosition) : elementPosition;\n            }\n        },\n        translate: function(tx, ty, opt) {\n            tx = tx || 0;\n            ty = ty || 0;\n            if (tx === 0 && ty === 0) // Like nothing has happened.\n            return this;\n            opt = opt || {};\n            // Pass the initiator of the translation.\n            opt.translateBy = opt.translateBy || this.id;\n            var position = this.get(\"position\") || {\n                x: 0,\n                y: 0\n            };\n            var ra = opt.restrictedArea;\n            if (ra && opt.translateBy === this.id) {\n                if (typeof ra === \"function\") {\n                    var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n                    tx = newPosition.x - position.x;\n                    ty = newPosition.y - position.y;\n                } else {\n                    // We are restricting the translation for the element itself only. We get\n                    // the bounding box of the element including all its embeds.\n                    // All embeds have to be translated the exact same way as the element.\n                    var bbox = this.getBBox({\n                        deep: true\n                    });\n                    //- - - - - - - - - - - - -> ra.x + ra.width\n                    // - - - -> position.x      |\n                    // -> bbox.x\n                    //                   |\n                    //         \n                    //                 |\n                    //   \n                    //                  |\n                    //   <-dx->                     | restricted area right border\n                    //         <-width->        |    translated element\n                    //   <- - bbox.width - ->        embedded element\n                    var dx = position.x - bbox.x;\n                    var dy = position.y - bbox.y;\n                    // Find the maximal/minimal coordinates that the element can be translated\n                    // while complies the restrictions.\n                    var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n                    var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n                    // recalculate the translation taking the restrictions into account.\n                    tx = x - position.x;\n                    ty = y - position.y;\n                }\n            }\n            var translatedPosition = {\n                x: position.x + tx,\n                y: position.y + ty\n            };\n            // To find out by how much an element was translated in event 'change:position' handlers.\n            opt.tx = tx;\n            opt.ty = ty;\n            if (opt.transition) {\n                if (!isObject$1(opt.transition)) opt.transition = {};\n                this.transition(\"position\", translatedPosition, assign({}, opt.transition, {\n                    valueFunction: interpolate.object\n                }));\n                // Recursively call `translate()` on all the embeds cells.\n                invoke(this.getEmbeddedCells(), \"translate\", tx, ty, opt);\n            } else {\n                this.startBatch(\"translate\", opt);\n                this.set(\"position\", translatedPosition, opt);\n                invoke(this.getEmbeddedCells(), \"translate\", tx, ty, opt);\n                this.stopBatch(\"translate\", opt);\n            }\n            return this;\n        },\n        size: function(width, height, opt) {\n            var currentSize = this.get(\"size\");\n            // Getter\n            // () signature\n            if (width === undefined) return {\n                width: currentSize.width,\n                height: currentSize.height\n            };\n            // Setter\n            // (size, opt) signature\n            if (isObject$1(width)) {\n                opt = height;\n                height = isNumber(width.height) ? width.height : currentSize.height;\n                width = isNumber(width.width) ? width.width : currentSize.width;\n            }\n            return this.resize(width, height, opt);\n        },\n        resize: function(width, height, opt) {\n            opt = opt || {};\n            this.startBatch(\"resize\", opt);\n            if (opt.direction) {\n                var currentSize = this.get(\"size\");\n                switch(opt.direction){\n                    case \"left\":\n                    case \"right\":\n                        // Don't change height when resizing horizontally.\n                        height = currentSize.height;\n                        break;\n                    case \"top\":\n                    case \"bottom\":\n                        // Don't change width when resizing vertically.\n                        width = currentSize.width;\n                        break;\n                }\n                // Get the angle and clamp its value between 0 and 360 degrees.\n                var angle = normalizeAngle(this.get(\"angle\") || 0);\n                // This is a rectangle in size of the un-rotated element.\n                var bbox = this.getBBox();\n                var origin;\n                if (angle) {\n                    var quadrant = {\n                        \"top-right\": 0,\n                        \"right\": 0,\n                        \"top-left\": 1,\n                        \"top\": 1,\n                        \"bottom-left\": 2,\n                        \"left\": 2,\n                        \"bottom-right\": 3,\n                        \"bottom\": 3\n                    }[opt.direction];\n                    if (opt.absolute) {\n                        // We are taking the element's rotation into account\n                        quadrant += Math.floor((angle + 45) / 90);\n                        quadrant %= 4;\n                    }\n                    // Pick the corner point on the element, which meant to stay on its place before and\n                    // after the rotation.\n                    var fixedPoint = bbox[[\n                        \"bottomLeft\",\n                        \"corner\",\n                        \"topRight\",\n                        \"origin\"\n                    ][quadrant]]();\n                    // Find  an image of the previous indent point. This is the position, where is the\n                    // point actually located on the screen.\n                    var imageFixedPoint = Point(fixedPoint).rotate(bbox.center(), -angle);\n                    // Every point on the element rotates around a circle with the centre of rotation\n                    // in the middle of the element while the whole element is being rotated. That means\n                    // that the distance from a point in the corner of the element (supposed its always rect) to\n                    // the center of the element doesn't change during the rotation and therefore it equals\n                    // to a distance on un-rotated element.\n                    // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n                    var radius = Math.sqrt(width * width + height * height) / 2;\n                    // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n                    // and ending at the center of the element. We call this angle `alpha`.\n                    // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n                    // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n                    //\n                    // 3 | 2\n                    // --c-- Quadrant positions around the element's center `c`\n                    // 0 | 1\n                    //\n                    var alpha = quadrant * Math.PI / 2;\n                    // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n                    // going through the center of the element) and line crossing the indent of the fixed point and the center\n                    // of the element. This is the angle we need but on the un-rotated element.\n                    alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\n                    // Lastly we have to deduct the original angle the element was rotated by and that's it.\n                    alpha -= toRad(angle);\n                    // With this angle and distance we can easily calculate the centre of the un-rotated element.\n                    // Note that fromPolar constructor accepts an angle in radians.\n                    var center = Point.fromPolar(radius, alpha, imageFixedPoint);\n                    // The top left corner on the un-rotated element has to be half a width on the left\n                    // and half a height to the top from the center. This will be the origin of rectangle\n                    // we were looking for.\n                    origin = Point(center).offset(width / -2, height / -2);\n                } else {\n                    // calculation for the origin Point when there is no rotation of the element\n                    origin = bbox.topLeft();\n                    switch(opt.direction){\n                        case \"top\":\n                        case \"top-right\":\n                            origin.offset(0, bbox.height - height);\n                            break;\n                        case \"left\":\n                        case \"bottom-left\":\n                            origin.offset(bbox.width - width, 0);\n                            break;\n                        case \"top-left\":\n                            origin.offset(bbox.width - width, bbox.height - height);\n                            break;\n                    }\n                }\n                // Resize the element (before re-positioning it).\n                this.set(\"size\", {\n                    width: width,\n                    height: height\n                }, opt);\n                // Finally, re-position the element.\n                this.position(origin.x, origin.y, opt);\n            } else // Resize the element.\n            this.set(\"size\", {\n                width: width,\n                height: height\n            }, opt);\n            this.stopBatch(\"resize\", opt);\n            return this;\n        },\n        scale: function(sx, sy, origin, opt) {\n            var scaledBBox = this.getBBox().scale(sx, sy, origin);\n            this.startBatch(\"scale\", opt);\n            this.position(scaledBBox.x, scaledBBox.y, opt);\n            this.resize(scaledBBox.width, scaledBBox.height, opt);\n            this.stopBatch(\"scale\");\n            return this;\n        },\n        fitEmbeds: function(opt) {\n            return this.fitToChildren(opt);\n        },\n        fitToChildren: function(opt) {\n            if (opt === void 0) opt = {};\n            // Getting the children's size and position requires the collection.\n            // Cell.get('embeds') holds an array of cell ids only.\n            var ref = this;\n            var graph = ref.graph;\n            if (!graph) throw new Error(\"Element must be part of a graph.\");\n            var childElements = this.getEmbeddedCells().filter(function(cell) {\n                return cell.isElement();\n            });\n            if (childElements.length === 0) return this;\n            this.startBatch(\"fit-embeds\", opt);\n            if (opt.deep) // `opt.deep = true` means \"fit to all descendants\".\n            // As the first action of the fitting algorithm, recursively apply `fitToChildren()` on all descendants.\n            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant, then go up (= this element).\n            invoke(childElements, \"fitToChildren\", opt);\n            // Set new size and position of this element, based on:\n            // - union of bboxes of all children\n            // - inflated by given `opt.padding`\n            this._fitToElements(Object.assign({\n                elements: childElements\n            }, opt));\n            this.stopBatch(\"fit-embeds\");\n            return this;\n        },\n        fitParent: function(opt) {\n            if (opt === void 0) opt = {};\n            var ref = this;\n            var graph = ref.graph;\n            if (!graph) throw new Error(\"Element must be part of a graph.\");\n            // When `opt.deep = true`, we want `opt.terminator` to be the last ancestor processed.\n            // If the current element is `opt.terminator`, it means that this element has already been processed as parent so we can exit now.\n            if (opt.deep && opt.terminator && (opt.terminator === this || opt.terminator === this.id)) return this;\n            var parentElement = this.getParentCell();\n            if (!parentElement || !parentElement.isElement()) return this;\n            // Get all children of parent element (i.e. this element + any sibling elements).\n            var siblingElements = parentElement.getEmbeddedCells().filter(function(cell) {\n                return cell.isElement();\n            });\n            if (siblingElements.length === 0) return this;\n            this.startBatch(\"fit-parent\", opt);\n            // Set new size and position of parent element, based on:\n            // - union of bboxes of all children of parent element (i.e. this element + any sibling elements)\n            // - inflated by given `opt.padding`\n            parentElement._fitToElements(Object.assign({\n                elements: siblingElements\n            }, opt));\n            if (opt.deep) // `opt.deep = true` means \"fit all ancestors to their respective children\".\n            // As the last action of the fitting algorithm, recursively apply `fitParent()` on all ancestors.\n            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant (= this element), then go up.\n            parentElement.fitParent(opt);\n            this.stopBatch(\"fit-parent\");\n            return this;\n        },\n        // Assumption: This element is part of a graph.\n        _fitToElements: function(opt) {\n            if (opt === void 0) opt = {};\n            var elementsBBox = this.graph.getCellsBBox(opt.elements);\n            // If no `opt.elements` were provided, do nothing.\n            if (!elementsBBox) return;\n            var expandOnly = opt.expandOnly;\n            var shrinkOnly = opt.shrinkOnly;\n            // This combination is meaningless, do nothing.\n            if (expandOnly && shrinkOnly) return;\n            // Calculate new size and position of this element based on:\n            // - union of bboxes of `opt.elements`\n            // - inflated by `opt.padding` (if not provided, all four properties = 0)\n            var x = elementsBBox.x;\n            var y = elementsBBox.y;\n            var width = elementsBBox.width;\n            var height = elementsBBox.height;\n            var ref = normalizeSides(opt.padding);\n            var left = ref.left;\n            var right = ref.right;\n            var top = ref.top;\n            var bottom = ref.bottom;\n            x -= left;\n            y -= top;\n            width += left + right;\n            height += bottom + top;\n            var resultBBox = new Rect(x, y, width, height);\n            if (expandOnly) // Non-shrinking is enforced by taking union of this element's current bbox with bbox calculated from `opt.elements`.\n            resultBBox = this.getBBox().union(resultBBox);\n            else if (shrinkOnly) {\n                // Non-expansion is enforced by taking intersection of this element's current bbox with bbox calculated from `opt.elements`.\n                var intersectionBBox = this.getBBox().intersect(resultBBox);\n                // If all children are outside this element's current bbox, then `intersectionBBox` is `null` - does not make sense, do nothing.\n                if (!intersectionBBox) return;\n                resultBBox = intersectionBBox;\n            }\n            // Set the new size and position of this element.\n            this.set({\n                position: {\n                    x: resultBBox.x,\n                    y: resultBBox.y\n                },\n                size: {\n                    width: resultBBox.width,\n                    height: resultBBox.height\n                }\n            }, opt);\n        },\n        // Rotate element by `angle` degrees, optionally around `origin` point.\n        // If `origin` is not provided, it is considered to be the center of the element.\n        // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n        // the difference from the previous angle.\n        rotate: function(angle, absolute, origin, opt) {\n            if (origin) {\n                var center = this.getBBox().center();\n                var size = this.get(\"size\");\n                var position = this.get(\"position\");\n                center.rotate(origin, this.get(\"angle\") - angle);\n                var dx = center.x - size.width / 2 - position.x;\n                var dy = center.y - size.height / 2 - position.y;\n                this.startBatch(\"rotate\", {\n                    angle: angle,\n                    absolute: absolute,\n                    origin: origin\n                });\n                this.position(position.x + dx, position.y + dy, opt);\n                this.rotate(angle, absolute, null, opt);\n                this.stopBatch(\"rotate\");\n            } else this.set(\"angle\", absolute ? angle : (this.get(\"angle\") + angle) % 360, opt);\n            return this;\n        },\n        angle: function() {\n            return normalizeAngle(this.get(\"angle\") || 0);\n        },\n        getBBox: function(opt) {\n            if (opt === void 0) opt = {};\n            var ref = this;\n            var graph = ref.graph;\n            var attributes = ref.attributes;\n            var deep = opt.deep;\n            var rotate = opt.rotate;\n            if (deep && graph) {\n                // Get all the embedded elements using breadth first algorithm.\n                var elements = this.getEmbeddedCells({\n                    deep: true,\n                    breadthFirst: true\n                });\n                // Add the model itself.\n                elements.push(this);\n                // Note: the default of getCellsBBox() is rotate=true and can't be\n                // changed without a breaking change\n                return graph.getCellsBBox(elements, opt);\n            }\n            var angle = attributes.angle;\n            if (angle === void 0) angle = 0;\n            var attributes_position = attributes.position;\n            var x = attributes_position.x;\n            var y = attributes_position.y;\n            var attributes_size = attributes.size;\n            var width = attributes_size.width;\n            var height = attributes_size.height;\n            var bbox = new Rect(x, y, width, height);\n            if (rotate) bbox.rotateAroundCenter(angle);\n            return bbox;\n        },\n        getPointFromConnectedLink: function(link, endType) {\n            // Center of the model\n            var bbox = this.getBBox();\n            var center = bbox.center();\n            // Center of a port\n            var endDef = link.get(endType);\n            if (!endDef) return center;\n            var portId = endDef.port;\n            if (!portId || !this.hasPort(portId)) return center;\n            var portGroup = this.portProp(portId, [\n                \"group\"\n            ]);\n            var portsPositions = this.getPortsPositions(portGroup);\n            var portCenter = new Point(portsPositions[portId]).offset(bbox.origin());\n            var angle = this.angle();\n            if (angle) portCenter.rotate(center, -angle);\n            return portCenter;\n        }\n    });\n    assign(Element$1.prototype, elementPortPrototype);\n    var GraphCells = Backbone.Collection.extend({\n        initialize: function(models, opt) {\n            // Set the optional namespace where all model classes are defined.\n            if (opt.cellNamespace) this.cellNamespace = opt.cellNamespace;\n            else /* eslint-disable no-undef */ this.cellNamespace = typeof joint !== \"undefined\" && has$2(joint, \"shapes\") ? joint.shapes : null;\n            this.graph = opt.graph;\n        },\n        model: function(attrs, opt) {\n            var collection = opt.collection;\n            var namespace = collection.cellNamespace;\n            // Find the model class in the namespace or use the default one.\n            var ModelClass = attrs.type === \"link\" ? Link : getByPath(namespace, attrs.type, \".\") || Element$1;\n            var cell = new ModelClass(attrs, opt);\n            // Add a reference to the graph. It is necessary to do this here because this is the earliest place\n            // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.\n            if (!opt.dry) cell.graph = collection.graph;\n            return cell;\n        },\n        // `comparator` makes it easy to sort cells based on their `z` index.\n        comparator: function(model) {\n            return model.get(\"z\") || 0;\n        }\n    });\n    var Graph = Backbone.Model.extend({\n        initialize: function(attrs, opt) {\n            opt = opt || {};\n            // Passing `cellModel` function in the options object to graph allows for\n            // setting models based on attribute objects. This is especially handy\n            // when processing JSON graphs that are in a different than JointJS format.\n            var cells = new GraphCells([], {\n                model: opt.cellModel,\n                cellNamespace: opt.cellNamespace,\n                graph: this\n            });\n            Backbone.Model.prototype.set.call(this, \"cells\", cells);\n            // Make all the events fired in the `cells` collection available.\n            // to the outside world.\n            cells.on(\"all\", this.trigger, this);\n            // Backbone automatically doesn't trigger re-sort if models attributes are changed later when\n            // they're already in the collection. Therefore, we're triggering sort manually here.\n            this.on(\"change:z\", this._sortOnChangeZ, this);\n            // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n            // for fast graph queries. All changes that affect the structure of the graph\n            // must be reflected in the `al` object. This object provides fast answers to\n            // questions such as \"what are the neighbours of this node\" or \"what\n            // are the sibling links of this link\".\n            // Outgoing edges per node. Note that we use a hash-table for the list\n            // of outgoing edges for a faster lookup.\n            // [nodeId] -> Object [edgeId] -> true\n            this._out = {};\n            // Ingoing edges per node.\n            // [nodeId] -> Object [edgeId] -> true\n            this._in = {};\n            // `_nodes` is useful for quick lookup of all the elements in the graph, without\n            // having to go through the whole cells array.\n            // [node ID] -> true\n            this._nodes = {};\n            // `_edges` is useful for quick lookup of all the links in the graph, without\n            // having to go through the whole cells array.\n            // [edgeId] -> true\n            this._edges = {};\n            this._batches = {};\n            cells.on(\"add\", this._restructureOnAdd, this);\n            cells.on(\"remove\", this._restructureOnRemove, this);\n            cells.on(\"reset\", this._restructureOnReset, this);\n            cells.on(\"change:source\", this._restructureOnChangeSource, this);\n            cells.on(\"change:target\", this._restructureOnChangeTarget, this);\n            cells.on(\"remove\", this._removeCell, this);\n        },\n        _sortOnChangeZ: function() {\n            this.get(\"cells\").sort();\n        },\n        _restructureOnAdd: function(cell) {\n            if (cell.isLink()) {\n                this._edges[cell.id] = true;\n                var ref = cell.attributes;\n                var source = ref.source;\n                var target = ref.target;\n                if (source.id) (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n                if (target.id) (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n            } else this._nodes[cell.id] = true;\n        },\n        _restructureOnRemove: function(cell) {\n            if (cell.isLink()) {\n                delete this._edges[cell.id];\n                var ref = cell.attributes;\n                var source = ref.source;\n                var target = ref.target;\n                if (source.id && this._out[source.id] && this._out[source.id][cell.id]) delete this._out[source.id][cell.id];\n                if (target.id && this._in[target.id] && this._in[target.id][cell.id]) delete this._in[target.id][cell.id];\n            } else delete this._nodes[cell.id];\n        },\n        _restructureOnReset: function(cells) {\n            // Normalize into an array of cells. The original `cells` is GraphCells Backbone collection.\n            cells = cells.models;\n            this._out = {};\n            this._in = {};\n            this._nodes = {};\n            this._edges = {};\n            cells.forEach(this._restructureOnAdd, this);\n        },\n        _restructureOnChangeSource: function(link) {\n            var prevSource = link.previous(\"source\");\n            if (prevSource.id && this._out[prevSource.id]) delete this._out[prevSource.id][link.id];\n            var source = link.attributes.source;\n            if (source.id) (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n        },\n        _restructureOnChangeTarget: function(link) {\n            var prevTarget = link.previous(\"target\");\n            if (prevTarget.id && this._in[prevTarget.id]) delete this._in[prevTarget.id][link.id];\n            var target = link.get(\"target\");\n            if (target.id) (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n        },\n        // Return all outbound edges for the node. Return value is an object\n        // of the form: [edgeId] -> true\n        getOutboundEdges: function(node) {\n            return this._out && this._out[node] || {};\n        },\n        // Return all inbound edges for the node. Return value is an object\n        // of the form: [edgeId] -> true\n        getInboundEdges: function(node) {\n            return this._in && this._in[node] || {};\n        },\n        toJSON: function() {\n            // Backbone does not recursively call `toJSON()` on attributes that are themselves models/collections.\n            // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n            var json = Backbone.Model.prototype.toJSON.apply(this, arguments);\n            json.cells = this.get(\"cells\").toJSON();\n            return json;\n        },\n        fromJSON: function(json, opt) {\n            if (!json.cells) throw new Error(\"Graph JSON must contain cells array.\");\n            return this.set(json, opt);\n        },\n        set: function(key, val, opt) {\n            var attrs;\n            // Handle both `key`, value and {key: value} style arguments.\n            if (typeof key === \"object\") {\n                attrs = key;\n                opt = val;\n            } else (attrs = {})[key] = val;\n            // Make sure that `cells` attribute is handled separately via resetCells().\n            if (attrs.hasOwnProperty(\"cells\")) {\n                this.resetCells(attrs.cells, opt);\n                attrs = omit(attrs, \"cells\");\n            }\n            // The rest of the attributes are applied via original set method.\n            return Backbone.Model.prototype.set.call(this, attrs, opt);\n        },\n        clear: function(opt) {\n            opt = assign({}, opt, {\n                clear: true\n            });\n            var collection = this.get(\"cells\");\n            if (collection.length === 0) return this;\n            this.startBatch(\"clear\", opt);\n            // The elements come after the links.\n            var cells = collection.sortBy(function(cell) {\n                return cell.isLink() ? 1 : 2;\n            });\n            do // Remove all the cells one by one.\n            // Note that all the links are removed first, so it's\n            // safe to remove the elements without removing the connected\n            // links first.\n            cells.shift().remove(opt);\n            while (cells.length > 0);\n            this.stopBatch(\"clear\");\n            return this;\n        },\n        _prepareCell: function(cell, opt) {\n            var attrs;\n            if (cell instanceof Backbone.Model) {\n                attrs = cell.attributes;\n                if (!cell.graph && (!opt || !opt.dry)) // An element can not be member of more than one graph.\n                // A cell stops being the member of the graph after it's explicitly removed.\n                cell.graph = this;\n            } else // In case we're dealing with a plain JS object, we have to set the reference\n            // to the `graph` right after the actual model is created. This happens in the `model()` function\n            // of `joint.dia.GraphCells`.\n            attrs = cell;\n            if (!isString(attrs.type)) throw new TypeError(\"dia.Graph: cell type must be a string.\");\n            return cell;\n        },\n        minZIndex: function() {\n            var firstCell = this.get(\"cells\").first();\n            return firstCell ? firstCell.get(\"z\") || 0 : 0;\n        },\n        maxZIndex: function() {\n            var lastCell = this.get(\"cells\").last();\n            return lastCell ? lastCell.get(\"z\") || 0 : 0;\n        },\n        addCell: function(cell, opt) {\n            if (Array.isArray(cell)) return this.addCells(cell, opt);\n            if (cell instanceof Backbone.Model) {\n                if (!cell.has(\"z\")) cell.set(\"z\", this.maxZIndex() + 1);\n            } else if (cell.z === undefined) cell.z = this.maxZIndex() + 1;\n            this.get(\"cells\").add(this._prepareCell(cell, opt), opt || {});\n            return this;\n        },\n        addCells: function(cells, opt) {\n            if (cells.length === 0) return this;\n            cells = flattenDeep(cells);\n            opt.maxPosition = opt.position = cells.length - 1;\n            this.startBatch(\"add\", opt);\n            cells.forEach(function(cell) {\n                this.addCell(cell, opt);\n                opt.position--;\n            }, this);\n            this.stopBatch(\"add\", opt);\n            return this;\n        },\n        // When adding a lot of cells, it is much more efficient to\n        // reset the entire cells collection in one go.\n        // Useful for bulk operations and optimizations.\n        resetCells: function(cells, opt) {\n            var preparedCells = toArray(cells).map(function(cell) {\n                return this._prepareCell(cell, opt);\n            }, this);\n            this.get(\"cells\").reset(preparedCells, opt);\n            return this;\n        },\n        removeCells: function(cells, opt) {\n            if (cells.length) {\n                this.startBatch(\"remove\");\n                invoke(cells, \"remove\", opt);\n                this.stopBatch(\"remove\");\n            }\n            return this;\n        },\n        _removeCell: function(cell, collection, options) {\n            options = options || {};\n            if (!options.clear) {\n                // Applications might provide a `disconnectLinks` option set to `true` in order to\n                // disconnect links when a cell is removed rather then removing them. The default\n                // is to remove all the associated links.\n                if (options.disconnectLinks) this.disconnectLinks(cell, options);\n                else this.removeLinks(cell, options);\n            }\n            // Silently remove the cell from the cells collection. Silently, because\n            // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n            // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n            // would be triggered on the graph model.\n            this.get(\"cells\").remove(cell, {\n                silent: true\n            });\n            if (cell.graph === this) // Remove the element graph reference only if the cell is the member of this graph.\n            cell.graph = null;\n        },\n        // Get a cell by `id`.\n        getCell: function(id) {\n            return this.get(\"cells\").get(id);\n        },\n        getCells: function() {\n            return this.get(\"cells\").toArray();\n        },\n        getElements: function() {\n            return this.get(\"cells\").filter(function(cell) {\n                return cell.isElement();\n            });\n        },\n        getLinks: function() {\n            return this.get(\"cells\").filter(function(cell) {\n                return cell.isLink();\n            });\n        },\n        getFirstCell: function() {\n            return this.get(\"cells\").first();\n        },\n        getLastCell: function() {\n            return this.get(\"cells\").last();\n        },\n        // Get all inbound and outbound links connected to the cell `model`.\n        getConnectedLinks: function(model, opt) {\n            opt = opt || {};\n            var indirect = opt.indirect;\n            var inbound = opt.inbound;\n            var outbound = opt.outbound;\n            if (inbound === undefined && outbound === undefined) inbound = outbound = true;\n            // the final array of connected link models\n            var links = [];\n            // a hash table of connected edges of the form: [edgeId] -> true\n            // used for quick lookups to check if we already added a link\n            var edges = {};\n            if (outbound) addOutbounds(this, model);\n            if (inbound) addInbounds(this, model);\n            function addOutbounds(graph, model) {\n                forIn(graph.getOutboundEdges(model.id), (function(_, edge) {\n                    // skip links that were already added\n                    // (those must be self-loop links)\n                    // (because they are inbound and outbound edges of the same two elements)\n                    if (edges[edge]) return;\n                    var link = graph.getCell(edge);\n                    links.push(link);\n                    edges[edge] = true;\n                    if (indirect) {\n                        if (inbound) addInbounds(graph, link);\n                        if (outbound) addOutbounds(graph, link);\n                    }\n                }).bind(graph));\n                if (indirect && model.isLink()) {\n                    var outCell = model.getTargetCell();\n                    if (outCell && outCell.isLink()) {\n                        if (!edges[outCell.id]) {\n                            links.push(outCell);\n                            addOutbounds(graph, outCell);\n                        }\n                    }\n                }\n            }\n            function addInbounds(graph, model) {\n                forIn(graph.getInboundEdges(model.id), (function(_, edge) {\n                    // skip links that were already added\n                    // (those must be self-loop links)\n                    // (because they are inbound and outbound edges of the same two elements)\n                    if (edges[edge]) return;\n                    var link = graph.getCell(edge);\n                    links.push(link);\n                    edges[edge] = true;\n                    if (indirect) {\n                        if (inbound) addInbounds(graph, link);\n                        if (outbound) addOutbounds(graph, link);\n                    }\n                }).bind(graph));\n                if (indirect && model.isLink()) {\n                    var inCell = model.getSourceCell();\n                    if (inCell && inCell.isLink()) {\n                        if (!edges[inCell.id]) {\n                            links.push(inCell);\n                            addInbounds(graph, inCell);\n                        }\n                    }\n                }\n            }\n            // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n            if (opt.deep) {\n                var embeddedCells = model.getEmbeddedCells({\n                    deep: true\n                });\n                // in the first round, we collect all the embedded elements\n                var embeddedElements = {};\n                embeddedCells.forEach(function(cell) {\n                    if (cell.isElement()) embeddedElements[cell.id] = true;\n                });\n                embeddedCells.forEach(function(cell) {\n                    if (cell.isLink()) return;\n                    if (outbound) forIn(this.getOutboundEdges(cell.id), (function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var ref = edgeCell.attributes;\n                            var source = ref.source;\n                            var target = ref.target;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) return;\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }).bind(this));\n                    if (inbound) forIn(this.getInboundEdges(cell.id), (function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var ref = edgeCell.attributes;\n                            var source = ref.source;\n                            var target = ref.target;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) return;\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }).bind(this));\n                }, this);\n            }\n            return links;\n        },\n        getNeighbors: function(model, opt) {\n            opt || (opt = {});\n            var inbound = opt.inbound;\n            var outbound = opt.outbound;\n            if (inbound === undefined && outbound === undefined) inbound = outbound = true;\n            var neighbors = this.getConnectedLinks(model, opt).reduce((function(res, link) {\n                var ref = link.attributes;\n                var source = ref.source;\n                var target = ref.target;\n                var loop = link.hasLoop(opt);\n                // Discard if it is a point, or if the neighbor was already added.\n                if (inbound && has$2(source, \"id\") && !res[source.id]) {\n                    var sourceElement = this.getCell(source.id);\n                    if (sourceElement.isElement()) {\n                        if (loop || sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model))) res[source.id] = sourceElement;\n                    }\n                }\n                // Discard if it is a point, or if the neighbor was already added.\n                if (outbound && has$2(target, \"id\") && !res[target.id]) {\n                    var targetElement = this.getCell(target.id);\n                    if (targetElement.isElement()) {\n                        if (loop || targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model))) res[target.id] = targetElement;\n                    }\n                }\n                return res;\n            }).bind(this), {});\n            if (model.isLink()) {\n                if (inbound) {\n                    var sourceCell = model.getSourceCell();\n                    if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) neighbors[sourceCell.id] = sourceCell;\n                }\n                if (outbound) {\n                    var targetCell = model.getTargetCell();\n                    if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) neighbors[targetCell.id] = targetCell;\n                }\n            }\n            return toArray(neighbors);\n        },\n        getCommonAncestor: function() {\n            var cellsAncestors = Array.from(arguments).map(function(cell) {\n                var ancestors = [];\n                var parentId = cell.get(\"parent\");\n                while(parentId){\n                    ancestors.push(parentId);\n                    parentId = this.getCell(parentId).get(\"parent\");\n                }\n                return ancestors;\n            }, this);\n            cellsAncestors = cellsAncestors.sort(function(a, b) {\n                return a.length - b.length;\n            });\n            var commonAncestor = toArray(cellsAncestors.shift()).find(function(ancestor) {\n                return cellsAncestors.every(function(cellAncestors) {\n                    return cellAncestors.includes(ancestor);\n                });\n            });\n            return this.getCell(commonAncestor);\n        },\n        // Find the whole branch starting at `element`.\n        // If `opt.deep` is `true`, take into account embedded elements too.\n        // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n        getSuccessors: function(element, opt) {\n            opt = opt || {};\n            var res = [];\n            // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n            this.search(element, function(el) {\n                if (el !== element) res.push(el);\n            }, assign({}, opt, {\n                outbound: true\n            }));\n            return res;\n        },\n        cloneCells: cloneCells,\n        // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n        // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n        // Return a map of the form: [original cell ID] -> [clone].\n        cloneSubgraph: function(cells, opt) {\n            var subgraph = this.getSubgraph(cells, opt);\n            return this.cloneCells(subgraph);\n        },\n        // Return `cells` and all the connected links that connect cells in the `cells` array.\n        // If `opt.deep` is `true`, return all the cells including all their embedded cells\n        // and all the links that connect any of the returned cells.\n        // For example, for a single shallow element, the result is that very same element.\n        // For two elements connected with a link: `A --- L ---> B`, the result for\n        // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n        getSubgraph: function(cells, opt) {\n            opt = opt || {};\n            var subgraph = [];\n            // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n            var cellMap = {};\n            var elements = [];\n            var links = [];\n            toArray(cells).forEach(function(cell) {\n                if (!cellMap[cell.id]) {\n                    subgraph.push(cell);\n                    cellMap[cell.id] = cell;\n                    if (cell.isLink()) links.push(cell);\n                    else elements.push(cell);\n                }\n                if (opt.deep) {\n                    var embeds = cell.getEmbeddedCells({\n                        deep: true\n                    });\n                    embeds.forEach(function(embed) {\n                        if (!cellMap[embed.id]) {\n                            subgraph.push(embed);\n                            cellMap[embed.id] = embed;\n                            if (embed.isLink()) links.push(embed);\n                            else elements.push(embed);\n                        }\n                    });\n                }\n            });\n            links.forEach(function(link) {\n                // For links, return their source & target (if they are elements - not points).\n                var ref = link.attributes;\n                var source = ref.source;\n                var target = ref.target;\n                if (source.id && !cellMap[source.id]) {\n                    var sourceElement = this.getCell(source.id);\n                    subgraph.push(sourceElement);\n                    cellMap[sourceElement.id] = sourceElement;\n                    elements.push(sourceElement);\n                }\n                if (target.id && !cellMap[target.id]) {\n                    var targetElement = this.getCell(target.id);\n                    subgraph.push(this.getCell(target.id));\n                    cellMap[targetElement.id] = targetElement;\n                    elements.push(targetElement);\n                }\n            }, this);\n            elements.forEach(function(element) {\n                // For elements, include their connected links if their source/target is in the subgraph;\n                var links = this.getConnectedLinks(element, opt);\n                links.forEach(function(link) {\n                    var ref = link.attributes;\n                    var source = ref.source;\n                    var target = ref.target;\n                    if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n                        subgraph.push(link);\n                        cellMap[link.id] = link;\n                    }\n                });\n            }, this);\n            return subgraph;\n        },\n        // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n        // If `opt.deep` is `true`, take into account embedded elements too.\n        // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n        getPredecessors: function(element, opt) {\n            opt = opt || {};\n            var res = [];\n            // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n            this.search(element, function(el) {\n                if (el !== element) res.push(el);\n            }, assign({}, opt, {\n                inbound: true\n            }));\n            return res;\n        },\n        // Perform search on the graph.\n        // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n        // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n        // If `opt.deep` is `true`, take into account embedded elements too.\n        // `iteratee` is a function of the form `function(element) {}`.\n        // If `iteratee` explicitly returns `false`, the searching stops.\n        search: function(element, iteratee, opt) {\n            opt = opt || {};\n            if (opt.breadthFirst) this.bfs(element, iteratee, opt);\n            else this.dfs(element, iteratee, opt);\n        },\n        // Breadth-first search.\n        // If `opt.deep` is `true`, take into account embedded elements too.\n        // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n        // `iteratee` is a function of the form `function(element, distance) {}`.\n        // where `element` is the currently visited element and `distance` is the distance of that element\n        // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n        // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n        // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n        // If `iteratee` explicitly returns `false`, the searching stops.\n        bfs: function(element, iteratee, opt) {\n            if (opt === void 0) opt = {};\n            var visited = {};\n            var distance = {};\n            var queue = [];\n            queue.push(element);\n            distance[element.id] = 0;\n            while(queue.length > 0){\n                var next = queue.shift();\n                if (visited[next.id]) continue;\n                visited[next.id] = true;\n                if (iteratee.call(this, next, distance[next.id]) === false) continue;\n                var neighbors = this.getNeighbors(next, opt);\n                for(var i = 0, n = neighbors.length; i < n; i++){\n                    var neighbor = neighbors[i];\n                    distance[neighbor.id] = distance[next.id] + 1;\n                    queue.push(neighbor);\n                }\n            }\n        },\n        // Depth-first search.\n        // If `opt.deep` is `true`, take into account embedded elements too.\n        // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n        // `iteratee` is a function of the form `function(element, distance) {}`.\n        // If `iteratee` explicitly returns `false`, the search stops.\n        dfs: function(element, iteratee, opt) {\n            if (opt === void 0) opt = {};\n            var visited = {};\n            var distance = {};\n            var queue = [];\n            queue.push(element);\n            distance[element.id] = 0;\n            while(queue.length > 0){\n                var next = queue.pop();\n                if (visited[next.id]) continue;\n                visited[next.id] = true;\n                if (iteratee.call(this, next, distance[next.id]) === false) continue;\n                var neighbors = this.getNeighbors(next, opt);\n                var lastIndex = queue.length;\n                for(var i = 0, n = neighbors.length; i < n; i++){\n                    var neighbor = neighbors[i];\n                    distance[neighbor.id] = distance[next.id] + 1;\n                    queue.splice(lastIndex, 0, neighbor);\n                }\n            }\n        },\n        // Get all the roots of the graph. Time complexity: O(|V|).\n        getSources: function() {\n            var sources = [];\n            forIn(this._nodes, (function(exists, node) {\n                if (!this._in[node] || isEmpty(this._in[node])) sources.push(this.getCell(node));\n            }).bind(this));\n            return sources;\n        },\n        // Get all the leafs of the graph. Time complexity: O(|V|).\n        getSinks: function() {\n            var sinks = [];\n            forIn(this._nodes, (function(exists, node) {\n                if (!this._out[node] || isEmpty(this._out[node])) sinks.push(this.getCell(node));\n            }).bind(this));\n            return sinks;\n        },\n        // Return `true` if `element` is a root. Time complexity: O(1).\n        isSource: function(element) {\n            return !this._in[element.id] || isEmpty(this._in[element.id]);\n        },\n        // Return `true` if `element` is a leaf. Time complexity: O(1).\n        isSink: function(element) {\n            return !this._out[element.id] || isEmpty(this._out[element.id]);\n        },\n        // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n        isSuccessor: function(elementA, elementB) {\n            var isSuccessor = false;\n            this.search(elementA, function(element) {\n                if (element === elementB && element !== elementA) {\n                    isSuccessor = true;\n                    return false;\n                }\n            }, {\n                outbound: true\n            });\n            return isSuccessor;\n        },\n        // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n        isPredecessor: function(elementA, elementB) {\n            var isPredecessor = false;\n            this.search(elementA, function(element) {\n                if (element === elementB && element !== elementA) {\n                    isPredecessor = true;\n                    return false;\n                }\n            }, {\n                inbound: true\n            });\n            return isPredecessor;\n        },\n        // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n        // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n        // for more details.\n        // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n        // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n        isNeighbor: function(elementA, elementB, opt) {\n            opt = opt || {};\n            var inbound = opt.inbound;\n            var outbound = opt.outbound;\n            if (inbound === undefined && outbound === undefined) inbound = outbound = true;\n            var isNeighbor = false;\n            this.getConnectedLinks(elementA, opt).forEach(function(link) {\n                var ref = link.attributes;\n                var source = ref.source;\n                var target = ref.target;\n                // Discard if it is a point.\n                if (inbound && has$2(source, \"id\") && source.id === elementB.id) {\n                    isNeighbor = true;\n                    return false;\n                }\n                // Discard if it is a point, or if the neighbor was already added.\n                if (outbound && has$2(target, \"id\") && target.id === elementB.id) {\n                    isNeighbor = true;\n                    return false;\n                }\n            });\n            return isNeighbor;\n        },\n        // Disconnect links connected to the cell `model`.\n        disconnectLinks: function(model, opt) {\n            this.getConnectedLinks(model).forEach(function(link) {\n                link.set(link.attributes.source.id === model.id ? \"source\" : \"target\", {\n                    x: 0,\n                    y: 0\n                }, opt);\n            });\n        },\n        // Remove links connected to the cell `model` completely.\n        removeLinks: function(model, opt) {\n            invoke(this.getConnectedLinks(model), \"remove\", opt);\n        },\n        // Find all elements at given point\n        findModelsFromPoint: function(p) {\n            return this.getElements().filter(function(el) {\n                return el.getBBox({\n                    rotate: true\n                }).containsPoint(p);\n            });\n        },\n        // Find all elements in given area\n        findModelsInArea: function(rect, opt) {\n            if (opt === void 0) opt = {};\n            var r = new Rect(rect);\n            var strict = opt.strict;\n            if (strict === void 0) strict = false;\n            var method = strict ? \"containsRect\" : \"intersect\";\n            return this.getElements().filter(function(el) {\n                return r[method](el.getBBox({\n                    rotate: true\n                }));\n            });\n        },\n        // Find all elements under the given element.\n        findModelsUnderElement: function(element, opt) {\n            if (opt === void 0) opt = {};\n            var searchBy = opt.searchBy;\n            if (searchBy === void 0) searchBy = \"bbox\";\n            var bbox = element.getBBox().rotateAroundCenter(element.angle());\n            var elements = searchBy === \"bbox\" ? this.findModelsInArea(bbox) : this.findModelsFromPoint(getRectPoint(bbox, searchBy));\n            // don't account element itself or any of its descendants\n            return elements.filter(function(el) {\n                return element.id !== el.id && !el.isEmbeddedIn(element);\n            });\n        },\n        // Return bounding box of all elements.\n        getBBox: function() {\n            return this.getCellsBBox(this.getCells());\n        },\n        // Return the bounding box of all cells in array provided.\n        getCellsBBox: function(cells, opt) {\n            if (opt === void 0) opt = {};\n            var rotate = opt.rotate;\n            if (rotate === void 0) rotate = true;\n            return toArray(cells).reduce(function(memo, cell) {\n                var rect = cell.getBBox({\n                    rotate: rotate\n                });\n                if (!rect) return memo;\n                if (memo) return memo.union(rect);\n                return rect;\n            }, null);\n        },\n        translate: function(dx, dy, opt) {\n            // Don't translate cells that are embedded in any other cell.\n            var cells = this.getCells().filter(function(cell) {\n                return !cell.isEmbedded();\n            });\n            invoke(cells, \"translate\", dx, dy, opt);\n            return this;\n        },\n        resize: function(width, height, opt) {\n            return this.resizeCells(width, height, this.getCells(), opt);\n        },\n        resizeCells: function(width, height, cells, opt) {\n            // `getBBox` method returns `null` if no elements provided.\n            // i.e. cells can be an array of links\n            var bbox = this.getCellsBBox(cells);\n            if (bbox) {\n                var sx = Math.max(width / bbox.width, 0);\n                var sy = Math.max(height / bbox.height, 0);\n                invoke(cells, \"scale\", sx, sy, bbox.origin(), opt);\n            }\n            return this;\n        },\n        startBatch: function(name, data) {\n            data = data || {};\n            this._batches[name] = (this._batches[name] || 0) + 1;\n            return this.trigger(\"batch:start\", assign({}, data, {\n                batchName: name\n            }));\n        },\n        stopBatch: function(name, data) {\n            data = data || {};\n            this._batches[name] = (this._batches[name] || 0) - 1;\n            return this.trigger(\"batch:stop\", assign({}, data, {\n                batchName: name\n            }));\n        },\n        hasActiveBatch: function(name) {\n            var batches = this._batches;\n            var names;\n            if (arguments.length === 0) names = Object.keys(batches);\n            else if (Array.isArray(name)) names = name;\n            else names = [\n                name\n            ];\n            return names.some(function(batch) {\n                return batches[batch] > 0;\n            });\n        }\n    }, {\n        validations: {\n            multiLinks: function(graph, link) {\n                // Do not allow multiple links to have the same source and target.\n                var ref = link.attributes;\n                var source = ref.source;\n                var target = ref.target;\n                if (source.id && target.id) {\n                    var sourceModel = link.getSourceCell();\n                    if (sourceModel) {\n                        var connectedLinks = graph.getConnectedLinks(sourceModel, {\n                            outbound: true\n                        });\n                        var sameLinks = connectedLinks.filter(function(_link) {\n                            var ref = _link.attributes;\n                            var _source = ref.source;\n                            var _target = ref.target;\n                            return _source && _source.id === source.id && (!_source.port || _source.port === source.port) && _target && _target.id === target.id && (!_target.port || _target.port === target.port);\n                        });\n                        if (sameLinks.length > 1) return false;\n                    }\n                }\n                return true;\n            },\n            linkPinning: function(_graph, link) {\n                var ref = link.attributes;\n                var source = ref.source;\n                var target = ref.target;\n                return source.id && target.id;\n            }\n        }\n    });\n    wrapWith(Graph.prototype, [\n        \"resetCells\",\n        \"addCells\",\n        \"removeCells\"\n    ], wrappers.cells);\n    var views = {};\n    var View = Backbone.View.extend({\n        options: {},\n        theme: null,\n        themeClassNamePrefix: addClassNamePrefix(\"theme-\"),\n        requireSetThemeOverride: false,\n        defaultTheme: config.defaultTheme,\n        children: null,\n        childNodes: null,\n        DETACHABLE: true,\n        UPDATE_PRIORITY: 2,\n        FLAG_INSERT: 1073741824,\n        FLAG_REMOVE: 536870912,\n        FLAG_INIT: 268435456,\n        constructor: function(options) {\n            this.requireSetThemeOverride = options && !!options.theme;\n            this.options = assign({}, this.options, options);\n            Backbone.View.call(this, options);\n        },\n        initialize: function() {\n            views[this.cid] = this;\n            this.setTheme(this.options.theme || this.defaultTheme);\n            this.init();\n        },\n        unmount: function() {\n            if (this.svgElement) this.vel.remove();\n            else this.$el.remove();\n        },\n        isMounted: function() {\n            return this.el.parentNode !== null;\n        },\n        renderChildren: function(children) {\n            children || (children = result(this, \"children\"));\n            if (children) {\n                var isSVG = this.svgElement;\n                var namespace = V.namespace[isSVG ? \"svg\" : \"xhtml\"];\n                var doc = parseDOMJSON(children, namespace);\n                (isSVG ? this.vel : this.$el).empty().append(doc.fragment);\n                this.childNodes = doc.selectors;\n            }\n            return this;\n        },\n        findAttribute: function(attributeName, node) {\n            var currentNode = node;\n            while(currentNode && currentNode.nodeType === 1){\n                var attributeValue = currentNode.getAttribute(attributeName);\n                // attribute found\n                if (attributeValue) return attributeValue;\n                // do not climb up the DOM\n                if (currentNode === this.el) return null;\n                // try parent node\n                currentNode = currentNode.parentNode;\n            }\n            return null;\n        },\n        // Override the Backbone `_ensureElement()` method in order to create an\n        // svg element (e.g., `<g>`) node that wraps all the nodes of the Cell view.\n        // Expose class name setter as a separate method.\n        _ensureElement: function() {\n            if (!this.el) {\n                var tagName = result(this, \"tagName\");\n                var attrs = assign({}, result(this, \"attributes\"));\n                var style = assign({}, result(this, \"style\"));\n                if (this.id) attrs.id = result(this, \"id\");\n                this.setElement(this._createElement(tagName));\n                this._setAttributes(attrs);\n                this._setStyle(style);\n            } else this.setElement(result(this, \"el\"));\n            this._ensureElClassName();\n        },\n        _setAttributes: function(attrs) {\n            if (this.svgElement) this.vel.attr(attrs);\n            else this.$el.attr(attrs);\n        },\n        _setStyle: function(style) {\n            this.$el.css(style);\n        },\n        _createElement: function(tagName) {\n            if (this.svgElement) return document.createElementNS(V.namespace.svg, tagName);\n            else return document.createElement(tagName);\n        },\n        // Utilize an alternative DOM manipulation API by\n        // adding an element reference wrapped in Vectorizer.\n        _setElement: function(el) {\n            this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);\n            this.el = this.$el[0];\n            if (this.svgElement) this.vel = V(this.el);\n        },\n        _ensureElClassName: function() {\n            var className = result(this, \"className\");\n            if (!className) return;\n            var prefixedClassName = addClassNamePrefix(className);\n            // Note: className removal here kept for backwards compatibility only\n            if (this.svgElement) this.vel.removeClass(className).addClass(prefixedClassName);\n            else this.$el.removeClass(className).addClass(prefixedClassName);\n        },\n        init: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n        },\n        onRender: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n        },\n        confirmUpdate: function() {\n            // Intentionally empty.\n            // This method is meant to be overridden.\n            return 0;\n        },\n        setTheme: function(theme, opt) {\n            opt = opt || {};\n            // Theme is already set, override is required, and override has not been set.\n            // Don't set the theme.\n            if (this.theme && this.requireSetThemeOverride && !opt.override) return this;\n            this.removeThemeClassName();\n            this.addThemeClassName(theme);\n            this.onSetTheme(this.theme /* oldTheme */ , theme /* newTheme */ );\n            this.theme = theme;\n            return this;\n        },\n        addThemeClassName: function(theme) {\n            theme = theme || this.theme;\n            if (!theme) return this;\n            var className = this.themeClassNamePrefix + theme;\n            if (this.svgElement) this.vel.addClass(className);\n            else this.$el.addClass(className);\n            return this;\n        },\n        removeThemeClassName: function(theme) {\n            theme = theme || this.theme;\n            var className = this.themeClassNamePrefix + theme;\n            if (this.svgElement) this.vel.removeClass(className);\n            else this.$el.removeClass(className);\n            return this;\n        },\n        onSetTheme: function(oldTheme, newTheme) {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n        },\n        remove: function() {\n            this.onRemove();\n            this.undelegateDocumentEvents();\n            views[this.cid] = null;\n            Backbone.View.prototype.remove.apply(this, arguments);\n            return this;\n        },\n        onRemove: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n        },\n        getEventNamespace: function() {\n            // Returns a per-session unique namespace\n            return \".joint-event-ns-\" + this.cid;\n        },\n        delegateElementEvents: function(element, events, data) {\n            if (!events) return this;\n            data || (data = {});\n            var eventNS = this.getEventNamespace();\n            for(var eventName in events){\n                var method = events[eventName];\n                if (typeof method !== \"function\") method = this[method];\n                if (!method) continue;\n                $(element).on(eventName + eventNS, data, method.bind(this));\n            }\n            return this;\n        },\n        undelegateElementEvents: function(element) {\n            $(element).off(this.getEventNamespace());\n            return this;\n        },\n        delegateDocumentEvents: function(events, data) {\n            events || (events = result(this, \"documentEvents\"));\n            return this.delegateElementEvents(document, events, data);\n        },\n        undelegateDocumentEvents: function() {\n            return this.undelegateElementEvents(document);\n        },\n        eventData: function(evt, data) {\n            if (!evt) throw new Error(\"eventData(): event object required.\");\n            var currentData = evt.data;\n            var key = \"__\" + this.cid + \"__\";\n            if (data === undefined) {\n                if (!currentData) return {};\n                return currentData[key] || {};\n            }\n            currentData || (currentData = evt.data = {});\n            currentData[key] || (currentData[key] = {});\n            assign(currentData[key], data);\n            return this;\n        },\n        stopPropagation: function(evt) {\n            this.eventData(evt, {\n                propagationStopped: true\n            });\n            return this;\n        },\n        isPropagationStopped: function(evt) {\n            return !!this.eventData(evt).propagationStopped;\n        }\n    }, {\n        extend: function() {\n            var args = Array.from(arguments);\n            // Deep clone the prototype and static properties objects.\n            // This prevents unexpected behavior where some properties are overwritten outside of this function.\n            var protoProps = args[0] && assign({}, args[0]) || {};\n            var staticProps = args[1] && assign({}, args[1]) || {};\n            // Need the real render method so that we can wrap it and call it later.\n            var renderFn = protoProps.render || this.prototype && this.prototype.render || null;\n            /*\n\t            Wrap the real render method so that:\n\t                .. `onRender` is always called.\n\t                .. `this` is always returned.\n\t        */ protoProps.render = function() {\n                if (typeof renderFn === \"function\") // Call the original render method.\n                renderFn.apply(this, arguments);\n                if (this.render.__render__ === renderFn) // Should always call onRender() method.\n                // Should call it only once when renderFn is actual prototype method i.e. not the wrapper\n                this.onRender();\n                // Should always return itself.\n                return this;\n            };\n            protoProps.render.__render__ = renderFn;\n            return Backbone.View.extend.call(this, protoProps, staticProps);\n        }\n    });\n    var DoubleTapEventName = \"dbltap\";\n    if ($.event && !(DoubleTapEventName in $.event.special)) {\n        var maxDelay = config.doubleTapInterval;\n        var minDelay = 30;\n        $.event.special[DoubleTapEventName] = {\n            bindType: \"touchend\",\n            delegateType: \"touchend\",\n            handle: function(event) {\n                var ref;\n                var args = [], len = arguments.length - 1;\n                while(len-- > 0)args[len] = arguments[len + 1];\n                var handleObj = event.handleObj;\n                var target = event.target;\n                var targetData = $.data(target);\n                var now = new Date().getTime();\n                var delta = \"lastTouch\" in targetData ? now - targetData.lastTouch : 0;\n                if (delta < maxDelay && delta > minDelay) {\n                    targetData.lastTouch = null;\n                    event.type = handleObj.origType;\n                    // let jQuery handle the triggering of \"dbltap\" event handlers\n                    (ref = handleObj.handler).call.apply(ref, [\n                        this,\n                        event\n                    ].concat(args));\n                } else targetData.lastTouch = now;\n            }\n        };\n    }\n    var Listener = function Listener() {\n        var callbackArguments = [], len = arguments.length;\n        while(len--)callbackArguments[len] = arguments[len];\n        this.callbackArguments = callbackArguments;\n    };\n    Listener.prototype.listenTo = function listenTo(object, evt) {\n        var this$1 = this;\n        var args = [], len = arguments.length - 2;\n        while(len-- > 0)args[len] = arguments[len + 2];\n        var ref = this;\n        var callbackArguments = ref.callbackArguments;\n        // signature 1 - (object, eventHashMap, context)\n        if (V.isObject(evt)) {\n            var context = args[0];\n            if (context === void 0) context = null;\n            Object.entries(evt).forEach(function(ref) {\n                var eventName = ref[0];\n                var cb = ref[1];\n                if (typeof cb !== \"function\") return;\n                // Invoke the callback with callbackArguments passed first\n                if (context || callbackArguments.length > 0) cb = cb.bind.apply(cb, [\n                    context\n                ].concat(callbackArguments));\n                Backbone.Events.listenTo.call(this$1, object, eventName, cb);\n            });\n        } else if (typeof evt === \"string\" && typeof args[0] === \"function\") {\n            var cb = args[0];\n            var context$1 = args[1];\n            if (context$1 === void 0) context$1 = null;\n            // Invoke the callback with callbackArguments passed first\n            if (context$1 || callbackArguments.length > 0) cb = cb.bind.apply(cb, [\n                context$1\n            ].concat(callbackArguments));\n            Backbone.Events.listenTo.call(this, object, evt, cb);\n        }\n    };\n    Listener.prototype.stopListening = function stopListening() {\n        Backbone.Events.stopListening.call(this);\n    };\n    var index$1 = {\n        views: views,\n        View: View,\n        Listener: Listener\n    };\n    var LayersNames = {\n        CELLS: \"cells\",\n        BACK: \"back\",\n        FRONT: \"front\",\n        TOOLS: \"tools\",\n        LABELS: \"labels\"\n    };\n    var PaperLayer = View.extend({\n        tagName: \"g\",\n        svgElement: true,\n        pivotNodes: null,\n        defaultTheme: null,\n        options: {\n            name: \"\"\n        },\n        className: function() {\n            return addClassNamePrefix(this.options.name + \"-layer\");\n        },\n        init: function() {\n            this.pivotNodes = {};\n        },\n        insertSortedNode: function(node, z) {\n            this.el.insertBefore(node, this.insertPivot(z));\n        },\n        insertNode: function(node) {\n            var ref = this;\n            var el = ref.el;\n            if (node.parentNode !== el) el.appendChild(node);\n        },\n        insertPivot: function(z) {\n            var ref = this;\n            var el = ref.el;\n            var pivotNodes = ref.pivotNodes;\n            z = +z;\n            z || (z = 0);\n            var pivotNode = pivotNodes[z];\n            if (pivotNode) return pivotNode;\n            pivotNode = pivotNodes[z] = document.createComment(\"z-index:\" + (z + 1));\n            var neighborZ = -Infinity;\n            for(var currentZ in pivotNodes){\n                currentZ = +currentZ;\n                if (currentZ < z && currentZ > neighborZ) {\n                    neighborZ = currentZ;\n                    if (neighborZ === z - 1) continue;\n                }\n            }\n            if (neighborZ !== -Infinity) {\n                var neighborPivot = pivotNodes[neighborZ];\n                // Insert After\n                el.insertBefore(pivotNode, neighborPivot.nextSibling);\n            } else // First Child\n            el.insertBefore(pivotNode, el.firstChild);\n            return pivotNode;\n        },\n        removePivots: function() {\n            var ref = this;\n            var el = ref.el;\n            var pivotNodes = ref.pivotNodes;\n            for(var z in pivotNodes)el.removeChild(pivotNodes[z]);\n            this.pivotNodes = {};\n        }\n    });\n    function toArray$1(obj) {\n        if (!obj) return [];\n        if (Array.isArray(obj)) return obj;\n        return [\n            obj\n        ];\n    }\n    var HighlighterView = View.extend({\n        tagName: \"g\",\n        svgElement: true,\n        className: \"highlight\",\n        HIGHLIGHT_FLAG: 1,\n        UPDATE_PRIORITY: 3,\n        DETACHABLE: false,\n        UPDATABLE: true,\n        MOUNTABLE: true,\n        cellView: null,\n        nodeSelector: null,\n        node: null,\n        updateRequested: false,\n        transformGroup: null,\n        detachedTransformGroup: null,\n        requestUpdate: function requestUpdate(cellView, nodeSelector) {\n            var paper = cellView.paper;\n            this.cellView = cellView;\n            this.nodeSelector = nodeSelector;\n            if (paper) {\n                this.updateRequested = true;\n                paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n            }\n        },\n        confirmUpdate: function confirmUpdate() {\n            // The cellView is now rendered/updated since it has a higher update priority.\n            this.updateRequested = false;\n            var ref = this;\n            var cellView = ref.cellView;\n            var nodeSelector = ref.nodeSelector;\n            this.update(cellView, nodeSelector);\n            this.mount();\n            this.transform();\n            return 0;\n        },\n        findNode: function findNode(cellView, nodeSelector) {\n            var assign, assign$1;\n            if (nodeSelector === void 0) nodeSelector = null;\n            var el;\n            if (typeof nodeSelector === \"string\") assign = cellView.findBySelector(nodeSelector), el = assign[0];\n            else if (isPlainObject(nodeSelector)) {\n                var isLink = cellView.model.isLink();\n                var label = nodeSelector.label;\n                if (label === void 0) label = null;\n                var port = nodeSelector.port;\n                var selector = nodeSelector.selector;\n                if (isLink && label !== null) // Link Label Selector\n                el = cellView.findLabelNode(label, selector);\n                else if (!isLink && port) // Element Port Selector\n                el = cellView.findPortNode(port, selector);\n                else // Cell Selector\n                assign$1 = cellView.findBySelector(selector), el = assign$1[0];\n            } else if (nodeSelector) {\n                el = V.toNode(nodeSelector);\n                if (!(el instanceof SVGElement)) el = null;\n            }\n            return el ? el : null;\n        },\n        getNodeMatrix: function getNodeMatrix(cellView, node) {\n            var ref = this;\n            var options = ref.options;\n            var layer = options.layer;\n            var rotatableNode = cellView.rotatableNode;\n            var nodeMatrix = cellView.getNodeMatrix(node);\n            if (rotatableNode) {\n                if (layer) {\n                    if (rotatableNode.contains(node)) return nodeMatrix;\n                    // The node is outside of the rotatable group.\n                    // Compensate the rotation set by transformGroup.\n                    return cellView.getRootRotateMatrix().inverse().multiply(nodeMatrix);\n                } else return cellView.getNodeRotateMatrix(node).multiply(nodeMatrix);\n            }\n            return nodeMatrix;\n        },\n        mount: function mount() {\n            var ref = this;\n            var MOUNTABLE = ref.MOUNTABLE;\n            var cellView = ref.cellView;\n            var el = ref.el;\n            var options = ref.options;\n            var transformGroup = ref.transformGroup;\n            var detachedTransformGroup = ref.detachedTransformGroup;\n            if (!MOUNTABLE || transformGroup) return;\n            var cellViewRoot = cellView.vel;\n            var paper = cellView.paper;\n            var layerName = options.layer;\n            if (layerName) {\n                var vGroup;\n                if (detachedTransformGroup) {\n                    vGroup = detachedTransformGroup;\n                    this.detachedTransformGroup = null;\n                } else vGroup = V(\"g\").addClass(\"highlight-transform\").append(el);\n                this.transformGroup = vGroup;\n                paper.getLayerView(layerName).insertSortedNode(vGroup.node, options.z);\n            } else // TODO: prepend vs append\n            if (!el.parentNode || el.nextSibling) // Not appended yet or not the last child\n            cellViewRoot.append(el);\n        },\n        unmount: function unmount() {\n            var ref = this;\n            var MOUNTABLE = ref.MOUNTABLE;\n            var transformGroup = ref.transformGroup;\n            var vel = ref.vel;\n            if (!MOUNTABLE) return;\n            if (transformGroup) {\n                this.transformGroup = null;\n                this.detachedTransformGroup = transformGroup;\n                transformGroup.remove();\n            } else vel.remove();\n        },\n        transform: function transform() {\n            var ref = this;\n            var transformGroup = ref.transformGroup;\n            var cellView = ref.cellView;\n            var updateRequested = ref.updateRequested;\n            if (!transformGroup || cellView.model.isLink() || updateRequested) return;\n            var translateMatrix = cellView.getRootTranslateMatrix();\n            var rotateMatrix = cellView.getRootRotateMatrix();\n            var transformMatrix = translateMatrix.multiply(rotateMatrix);\n            transformGroup.attr(\"transform\", V.matrixToTransformString(transformMatrix));\n        },\n        update: function update() {\n            var ref = this;\n            var prevNode = ref.node;\n            var cellView = ref.cellView;\n            var nodeSelector = ref.nodeSelector;\n            var updateRequested = ref.updateRequested;\n            var id = ref.id;\n            if (updateRequested) return;\n            var node = this.node = this.findNode(cellView, nodeSelector);\n            if (prevNode) this.unhighlight(cellView, prevNode);\n            if (node) {\n                this.highlight(cellView, node);\n                this.mount();\n            } else {\n                this.unmount();\n                cellView.notify(\"cell:highlight:invalid\", id, this);\n            }\n        },\n        onRemove: function onRemove() {\n            var ref = this;\n            var node = ref.node;\n            var cellView = ref.cellView;\n            var id = ref.id;\n            var constructor = ref.constructor;\n            if (node) this.unhighlight(cellView, node);\n            this.unmount();\n            constructor._removeRef(cellView, id);\n        },\n        highlight: function highlight(_cellView, _node) {\n        // to be overridden\n        },\n        unhighlight: function unhighlight(_cellView, _node) {\n        // to be overridden\n        },\n        // Update Attributes\n        listenToUpdateAttributes: function listenToUpdateAttributes(cellView) {\n            var attributes = result(this, \"UPDATE_ATTRIBUTES\");\n            if (!Array.isArray(attributes) || attributes.length === 0) return;\n            this.listenTo(cellView.model, \"change\", this.onCellAttributeChange);\n        },\n        onCellAttributeChange: function onCellAttributeChange() {\n            var ref = this;\n            var cellView = ref.cellView;\n            if (!cellView) return;\n            var model = cellView.model;\n            var paper = cellView.paper;\n            var attributes = result(this, \"UPDATE_ATTRIBUTES\");\n            if (!attributes.some(function(attribute) {\n                return model.hasChanged(attribute);\n            })) return;\n            paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n        }\n    }, {\n        _views: {},\n        // Used internally by CellView highlight()\n        highlight: function(cellView, node, opt) {\n            var id = this.uniqueId(node, opt);\n            this.add(cellView, node, id, opt);\n        },\n        // Used internally by CellView unhighlight()\n        unhighlight: function(cellView, node, opt) {\n            var id = this.uniqueId(node, opt);\n            this.remove(cellView, id);\n        },\n        get: function get(cellView, id) {\n            if (id === void 0) id = null;\n            var cid = cellView.cid;\n            var ref$2 = this;\n            var _views = ref$2._views;\n            var refs = _views[cid];\n            if (id === null) {\n                // all highlighters\n                var views = [];\n                if (!refs) return views;\n                for(var hid in refs){\n                    var ref = refs[hid];\n                    if (ref instanceof this) views.push(ref);\n                }\n                return views;\n            } else {\n                // single highlighter\n                if (!refs) return null;\n                if (id in refs) {\n                    var ref$1 = refs[id];\n                    if (ref$1 instanceof this) return ref$1;\n                }\n                return null;\n            }\n        },\n        add: function add(cellView, nodeSelector, id, opt) {\n            if (opt === void 0) opt = {};\n            if (!id) throw new Error(\"dia.HighlighterView: An ID required.\");\n            // Search the existing view amongst all the highlighters\n            var previousView = HighlighterView.get(cellView, id);\n            if (previousView) previousView.remove();\n            var view = new this(opt);\n            view.id = id;\n            this._addRef(cellView, id, view);\n            view.requestUpdate(cellView, nodeSelector);\n            view.listenToUpdateAttributes(cellView);\n            return view;\n        },\n        _addRef: function _addRef(cellView, id, view) {\n            var cid = cellView.cid;\n            var ref = this;\n            var _views = ref._views;\n            var refs = _views[cid];\n            if (!refs) refs = _views[cid] = {};\n            refs[id] = view;\n        },\n        _removeRef: function _removeRef(cellView, id) {\n            var cid = cellView.cid;\n            var ref = this;\n            var _views = ref._views;\n            var refs = _views[cid];\n            if (!refs) return;\n            if (id) delete refs[id];\n            for(var _ in refs)return;\n            delete _views[cid];\n        },\n        remove: function remove(cellView, id) {\n            if (id === void 0) id = null;\n            toArray$1(this.get(cellView, id)).forEach(function(view) {\n                view.remove();\n            });\n        },\n        removeAll: function removeAll(paper, id) {\n            if (id === void 0) id = null;\n            var ref = this;\n            var _views = ref._views;\n            for(var cid in _views)for(var hid in _views[cid]){\n                var view = _views[cid][hid];\n                if (view.cellView.paper === paper && view instanceof this && (id === null || hid === id)) view.remove();\n            }\n        },\n        update: function update(cellView, id, dirty) {\n            if (id === void 0) id = null;\n            if (dirty === void 0) dirty = false;\n            toArray$1(this.get(cellView, id)).forEach(function(view) {\n                if (dirty || view.UPDATABLE) view.update();\n            });\n        },\n        transform: function transform(cellView, id) {\n            if (id === void 0) id = null;\n            toArray$1(this.get(cellView, id)).forEach(function(view) {\n                if (view.UPDATABLE) view.transform();\n            });\n        },\n        unmount: function unmount(cellView, id) {\n            if (id === void 0) id = null;\n            toArray$1(this.get(cellView, id)).forEach(function(view) {\n                return view.unmount();\n            });\n        },\n        mount: function mount(cellView, id) {\n            if (id === void 0) id = null;\n            toArray$1(this.get(cellView, id)).forEach(function(view) {\n                return view.mount();\n            });\n        },\n        uniqueId: function uniqueId(node, opt) {\n            if (opt === void 0) opt = \"\";\n            return V.ensureId(node) + JSON.stringify(opt);\n        }\n    });\n    var HighlightingTypes = {\n        DEFAULT: \"default\",\n        EMBEDDING: \"embedding\",\n        CONNECTING: \"connecting\",\n        MAGNET_AVAILABILITY: \"magnetAvailability\",\n        ELEMENT_AVAILABILITY: \"elementAvailability\"\n    };\n    var Flags = {\n        TOOLS: \"TOOLS\"\n    };\n    // CellView base view and controller.\n    // --------------------------------------------\n    // This is the base view and controller for `ElementView` and `LinkView`.\n    var CellView = View.extend({\n        tagName: \"g\",\n        svgElement: true,\n        selector: \"root\",\n        metrics: null,\n        className: function() {\n            var classNames = [\n                \"cell\"\n            ];\n            var type = this.model.get(\"type\");\n            if (type) type.toLowerCase().split(\".\").forEach(function(value, index, list) {\n                classNames.push(\"type-\" + list.slice(0, index + 1).join(\"-\"));\n            });\n            return classNames.join(\" \");\n        },\n        _presentationAttributes: null,\n        _flags: null,\n        setFlags: function() {\n            var flags = {};\n            var attributes = {};\n            var shift = 0;\n            var i, n, label;\n            var presentationAttributes = result(this, \"presentationAttributes\");\n            for(var attribute in presentationAttributes){\n                if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n                var labels = presentationAttributes[attribute];\n                if (!Array.isArray(labels)) labels = [\n                    labels\n                ];\n                for(i = 0, n = labels.length; i < n; i++){\n                    label = labels[i];\n                    var flag = flags[label];\n                    if (!flag) flag = flags[label] = 1 << shift++;\n                    attributes[attribute] |= flag;\n                }\n            }\n            var initFlag = result(this, \"initFlag\");\n            if (!Array.isArray(initFlag)) initFlag = [\n                initFlag\n            ];\n            for(i = 0, n = initFlag.length; i < n; i++){\n                label = initFlag[i];\n                if (!flags[label]) flags[label] = 1 << shift++;\n            }\n            // 26 - 30 are reserved for paper flags\n            // 31+ overflows maximal number\n            if (shift > 25) throw new Error(\"dia.CellView: Maximum number of flags exceeded.\");\n            this._flags = flags;\n            this._presentationAttributes = attributes;\n        },\n        hasFlag: function(flag, label) {\n            return flag & this.getFlag(label);\n        },\n        removeFlag: function(flag, label) {\n            return flag ^ flag & this.getFlag(label);\n        },\n        getFlag: function(label) {\n            var flags = this._flags;\n            if (!flags) return 0;\n            var flag = 0;\n            if (Array.isArray(label)) for(var i = 0, n = label.length; i < n; i++)flag |= flags[label[i]];\n            else flag |= flags[label];\n            return flag;\n        },\n        attributes: function() {\n            var cell = this.model;\n            return {\n                \"model-id\": cell.id,\n                \"data-type\": cell.attributes.type\n            };\n        },\n        constructor: function(options) {\n            // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n            // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n            // still be associated to the same object among all those clients. This is necessary for real-time\n            // collaboration mechanism.\n            options.id = options.id || guid(this);\n            View.call(this, options);\n        },\n        initialize: function() {\n            this.setFlags();\n            View.prototype.initialize.apply(this, arguments);\n            this.cleanNodesCache();\n            // Store reference to this to the <g> DOM element so that the view is accessible through the DOM tree.\n            this.$el.data(\"view\", this);\n            this.startListening();\n        },\n        startListening: function() {\n            this.listenTo(this.model, \"change\", this.onAttributesChange);\n        },\n        onAttributesChange: function(model, opt) {\n            var flag = model.getChangeFlag(this._presentationAttributes);\n            if (opt.updateHandled || !flag) return;\n            if (opt.dirty && this.hasFlag(flag, \"UPDATE\")) flag |= this.getFlag(\"RENDER\");\n            // TODO: tool changes does not need to be sync\n            // Fix Segments tools\n            if (opt.tool) opt.async = false;\n            this.requestUpdate(flag, opt);\n        },\n        requestUpdate: function(flags, opt) {\n            var ref = this;\n            var paper = ref.paper;\n            if (paper && flags > 0) paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n        },\n        parseDOMJSON: function(markup, root) {\n            var doc = parseDOMJSON(markup);\n            var selectors = doc.selectors;\n            var groups = doc.groupSelectors;\n            for(var group in groups){\n                if (selectors[group]) throw new Error(\"dia.CellView: ambiguous group selector\");\n                selectors[group] = groups[group];\n            }\n            if (root) {\n                var rootSelector = this.selector;\n                if (selectors[rootSelector]) throw new Error(\"dia.CellView: ambiguous root selector.\");\n                selectors[rootSelector] = root;\n            }\n            return {\n                fragment: doc.fragment,\n                selectors: selectors\n            };\n        },\n        // Return `true` if cell link is allowed to perform a certain UI `feature`.\n        // Example: `can('vertexMove')`, `can('labelMove')`.\n        can: function(feature) {\n            var interactive = isFunction(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;\n            return isObject$1(interactive) && interactive[feature] !== false || isBoolean(interactive) && interactive !== false;\n        },\n        findBySelector: function(selector, root, selectors) {\n            root || (root = this.el);\n            selectors || (selectors = this.selectors);\n            // These are either descendants of `this.$el` of `this.$el` itself.\n            // `.` is a special selector used to select the wrapping `<g>` element.\n            if (!selector || selector === \".\") return [\n                root\n            ];\n            if (selectors) {\n                var nodes = selectors[selector];\n                if (nodes) {\n                    if (Array.isArray(nodes)) return nodes;\n                    return [\n                        nodes\n                    ];\n                }\n            }\n            // Maintaining backwards compatibility\n            // e.g. `circle:first` would fail with querySelector() call\n            if (config.useCSSSelectors) return $(root).find(selector).toArray();\n            return [];\n        },\n        notify: function(eventName) {\n            if (this.paper) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                // Trigger the event on both the element itself and also on the paper.\n                this.trigger.apply(this, [\n                    eventName\n                ].concat(args));\n                // Paper event handlers receive the view object as the first argument.\n                this.paper.trigger.apply(this.paper, [\n                    eventName,\n                    this\n                ].concat(args));\n            }\n        },\n        getBBox: function(opt) {\n            var bbox;\n            if (opt && opt.useModelGeometry) {\n                var model = this.model;\n                bbox = model.getBBox().bbox(model.angle());\n            } else bbox = this.getNodeBBox(this.el);\n            return this.paper.localToPaperRect(bbox);\n        },\n        getNodeBBox: function(magnet) {\n            var rect = this.getNodeBoundingRect(magnet);\n            var transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));\n            var magnetMatrix = this.getNodeMatrix(magnet);\n            return V.transformRect(rect, transformMatrix.multiply(magnetMatrix));\n        },\n        getNodeRotateMatrix: function getNodeRotateMatrix(node) {\n            if (!this.rotatableNode || this.rotatableNode.contains(node)) // Rotate transformation is applied to all nodes when no rotatableGroup\n            // is present or to nodes inside the rotatableGroup only.\n            return this.getRootRotateMatrix();\n            // Nodes outside the rotatable group\n            return V.createSVGMatrix();\n        },\n        getNodeUnrotatedBBox: function(magnet) {\n            var rect = this.getNodeBoundingRect(magnet);\n            var magnetMatrix = this.getNodeMatrix(magnet);\n            var translateMatrix = this.getRootTranslateMatrix();\n            return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n        },\n        getRootTranslateMatrix: function() {\n            var model = this.model;\n            var position = model.position();\n            var mt = V.createSVGMatrix().translate(position.x, position.y);\n            return mt;\n        },\n        getRootRotateMatrix: function() {\n            var mr = V.createSVGMatrix();\n            var model = this.model;\n            var angle = model.angle();\n            if (angle) {\n                var bbox = model.getBBox();\n                var cx = bbox.width / 2;\n                var cy = bbox.height / 2;\n                mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n            }\n            return mr;\n        },\n        _notifyHighlight: function(eventName, el, opt) {\n            var assign, assign$1;\n            if (opt === void 0) opt = {};\n            var ref = this;\n            var rootNode = ref.el;\n            var node;\n            if (typeof el === \"string\") assign = this.findBySelector(el), node = assign[0], node = node === void 0 ? rootNode : node;\n            else assign$1 = this.$(el), node = assign$1[0], node = node === void 0 ? rootNode : node;\n            // set partial flag if the highlighted element is not the entire view.\n            opt.partial = node !== rootNode;\n            // translate type flag into a type string\n            if (opt.type === undefined) {\n                var type;\n                switch(true){\n                    case opt.embedding:\n                        type = HighlightingTypes.EMBEDDING;\n                        break;\n                    case opt.connecting:\n                        type = HighlightingTypes.CONNECTING;\n                        break;\n                    case opt.magnetAvailability:\n                        type = HighlightingTypes.MAGNET_AVAILABILITY;\n                        break;\n                    case opt.elementAvailability:\n                        type = HighlightingTypes.ELEMENT_AVAILABILITY;\n                        break;\n                    default:\n                        type = HighlightingTypes.DEFAULT;\n                        break;\n                }\n                opt.type = type;\n            }\n            this.notify(eventName, node, opt);\n            return this;\n        },\n        highlight: function(el, opt) {\n            return this._notifyHighlight(\"cell:highlight\", el, opt);\n        },\n        unhighlight: function(el, opt) {\n            if (opt === void 0) opt = {};\n            return this._notifyHighlight(\"cell:unhighlight\", el, opt);\n        },\n        // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n        // an element found, return the root element of the cell view.\n        findMagnet: function(el) {\n            var root = this.el;\n            var magnet = this.$(el)[0];\n            if (!magnet) magnet = root;\n            do {\n                var magnetAttribute = magnet.getAttribute(\"magnet\");\n                var isMagnetRoot = magnet === root;\n                if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== \"false\") return magnet;\n                if (isMagnetRoot) // If the overall cell has set `magnet === false`, then return `undefined` to\n                // announce there is no magnet found for this cell.\n                // This is especially useful to set on cells that have 'ports'. In this case,\n                // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n                return undefined;\n                magnet = magnet.parentNode;\n            }while (magnet);\n            return undefined;\n        },\n        findProxyNode: function(el, type) {\n            el || (el = this.el);\n            var nodeSelector = el.getAttribute(type + \"-selector\");\n            if (nodeSelector) {\n                var ref = this.findBySelector(nodeSelector);\n                var proxyNode = ref[0];\n                if (proxyNode) return proxyNode;\n            }\n            return el;\n        },\n        // Construct a unique selector for the `el` element within this view.\n        // `prevSelector` is being collected through the recursive call.\n        // No value for `prevSelector` is expected when using this method.\n        getSelector: function(el, prevSelector) {\n            var selector;\n            if (el === this.el) {\n                if (typeof prevSelector === \"string\") selector = \"> \" + prevSelector;\n                return selector;\n            }\n            if (el) {\n                var nthChild = V(el).index() + 1;\n                selector = el.tagName + \":nth-child(\" + nthChild + \")\";\n                if (prevSelector) selector += \" > \" + prevSelector;\n                selector = this.getSelector(el.parentNode, selector);\n            }\n            return selector;\n        },\n        addLinkFromMagnet: function(magnet, x, y) {\n            var paper = this.paper;\n            var graph = paper.model;\n            var link = paper.getDefaultLink(this, magnet);\n            link.set({\n                source: this.getLinkEnd(magnet, x, y, link, \"source\"),\n                target: {\n                    x: x,\n                    y: y\n                }\n            }).addTo(graph, {\n                async: false,\n                ui: true\n            });\n            return link.findView(paper);\n        },\n        getLinkEnd: function(magnet) {\n            var ref;\n            var args = [], len = arguments.length - 1;\n            while(len-- > 0)args[len] = arguments[len + 1];\n            var model = this.model;\n            var id = model.id;\n            var port = this.findAttribute(\"port\", magnet);\n            // Find a unique `selector` of the element under pointer that is a magnet.\n            var selector = magnet.getAttribute(\"joint-selector\");\n            var end = {\n                id: id\n            };\n            if (selector != null) end.magnet = selector;\n            if (port != null) {\n                end.port = port;\n                if (!model.hasPort(port) && !selector) // port created via the `port` attribute (not API)\n                end.selector = this.getSelector(magnet);\n            } else if (selector == null && this.el !== magnet) end.selector = this.getSelector(magnet);\n            return (ref = this).customizeLinkEnd.apply(ref, [\n                end,\n                magnet\n            ].concat(args));\n        },\n        customizeLinkEnd: function(end, magnet, x, y, link, endType) {\n            var ref = this;\n            var paper = ref.paper;\n            var ref$1 = paper.options;\n            var connectionStrategy = ref$1.connectionStrategy;\n            if (typeof connectionStrategy === \"function\") {\n                var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n                if (strategy) return strategy;\n            }\n            return end;\n        },\n        getMagnetFromLinkEnd: function(end) {\n            var root = this.el;\n            var port = end.port;\n            var selector = end.magnet;\n            var model = this.model;\n            var magnet;\n            if (port != null && model.isElement() && model.hasPort(port)) magnet = this.findPortNode(port, selector) || root;\n            else {\n                if (!selector) selector = end.selector;\n                if (!selector && port != null) // link end has only `id` and `port` property referencing\n                // a port created via the `port` attribute (not API).\n                selector = '[port=\"' + port + '\"]';\n                magnet = this.findBySelector(selector, root, this.selectors)[0];\n            }\n            return this.findProxyNode(magnet, \"magnet\");\n        },\n        dragLinkStart: function(evt, magnet, x, y) {\n            this.model.startBatch(\"add-link\");\n            var linkView = this.addLinkFromMagnet(magnet, x, y);\n            // backwards compatibility events\n            linkView.notifyPointerdown(evt, x, y);\n            linkView.eventData(evt, linkView.startArrowheadMove(\"target\", {\n                whenNotAllowed: \"remove\"\n            }));\n            this.eventData(evt, {\n                linkView: linkView\n            });\n        },\n        dragLink: function(evt, x, y) {\n            var data = this.eventData(evt);\n            var linkView = data.linkView;\n            if (linkView) linkView.pointermove(evt, x, y);\n            else {\n                var paper = this.paper;\n                var magnetThreshold = paper.options.magnetThreshold;\n                var currentTarget = this.getEventTarget(evt);\n                var targetMagnet = data.targetMagnet;\n                if (magnetThreshold === \"onleave\") {\n                    // magnetThreshold when the pointer leaves the magnet\n                    if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) return;\n                } else {\n                    // magnetThreshold defined as a number of movements\n                    if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n                }\n                this.dragLinkStart(evt, targetMagnet, x, y);\n            }\n        },\n        dragLinkEnd: function(evt, x, y) {\n            var data = this.eventData(evt);\n            var linkView = data.linkView;\n            if (!linkView) return;\n            linkView.pointerup(evt, x, y);\n            this.model.stopBatch(\"add-link\");\n        },\n        getAttributeDefinition: function(attrName) {\n            return this.model.constructor.getAttributeDefinition(attrName);\n        },\n        setNodeAttributes: function(node, attrs) {\n            if (!isEmpty(attrs)) {\n                if (node instanceof SVGElement) V(node).attr(attrs);\n                else $(node).attr(attrs);\n            }\n        },\n        processNodeAttributes: function(node, attrs) {\n            var attrName, attrVal, def, i, n;\n            var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n            var relatives = [];\n            // divide the attributes between normal and special\n            for(attrName in attrs){\n                if (!attrs.hasOwnProperty(attrName)) continue;\n                attrVal = attrs[attrName];\n                def = this.getAttributeDefinition(attrName);\n                if (def && (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, attrs, this))) {\n                    if (isString(def.set)) {\n                        normalAttrs || (normalAttrs = {});\n                        normalAttrs[def.set] = attrVal;\n                    }\n                    if (attrVal !== null) relatives.push(attrName, def);\n                } else {\n                    normalAttrs || (normalAttrs = {});\n                    normalAttrs[toKebabCase(attrName)] = attrVal;\n                }\n            }\n            // handle the rest of attributes via related method\n            // from the special attributes namespace.\n            for(i = 0, n = relatives.length; i < n; i += 2){\n                attrName = relatives[i];\n                def = relatives[i + 1];\n                attrVal = attrs[attrName];\n                if (isFunction(def.set)) {\n                    setAttrs || (setAttrs = {});\n                    setAttrs[attrName] = attrVal;\n                }\n                if (isFunction(def.position)) {\n                    positionAttrs || (positionAttrs = {});\n                    positionAttrs[attrName] = attrVal;\n                }\n                if (isFunction(def.offset)) {\n                    offsetAttrs || (offsetAttrs = {});\n                    offsetAttrs[attrName] = attrVal;\n                }\n            }\n            return {\n                raw: attrs,\n                normal: normalAttrs,\n                set: setAttrs,\n                position: positionAttrs,\n                offset: offsetAttrs\n            };\n        },\n        updateRelativeAttributes: function(node, attrs, refBBox, opt) {\n            opt || (opt = {});\n            var attrName, attrVal, def;\n            var rawAttrs = attrs.raw || {};\n            var nodeAttrs = attrs.normal || {};\n            var setAttrs = attrs.set;\n            var positionAttrs = attrs.position;\n            var offsetAttrs = attrs.offset;\n            for(attrName in setAttrs){\n                attrVal = setAttrs[attrName];\n                def = this.getAttributeDefinition(attrName);\n                // SET - set function should return attributes to be set on the node,\n                // which will affect the node dimensions based on the reference bounding\n                // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n                var setResult = def.set.call(this, attrVal, refBBox.clone(), node, rawAttrs, this);\n                if (isObject$1(setResult)) assign(nodeAttrs, setResult);\n                else if (setResult !== undefined) nodeAttrs[attrName] = setResult;\n            }\n            if (node instanceof HTMLElement) {\n                // TODO: setting the `transform` attribute on HTMLElements\n                // via `node.style.transform = 'matrix(...)';` would introduce\n                // a breaking change (e.g. basic.TextBlock).\n                this.setNodeAttributes(node, nodeAttrs);\n                return;\n            }\n            // The final translation of the subelement.\n            var nodeTransform = nodeAttrs.transform;\n            var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n            var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n            if (nodeTransform) {\n                nodeAttrs = omit(nodeAttrs, \"transform\");\n                nodeMatrix.e = nodeMatrix.f = 0;\n            }\n            // Calculate node scale determined by the scalable group\n            // only if later needed.\n            var sx, sy, translation;\n            if (positionAttrs || offsetAttrs) {\n                var nodeScale = this.getNodeScale(node, opt.scalableNode);\n                sx = nodeScale.sx;\n                sy = nodeScale.sy;\n            }\n            var positioned = false;\n            for(attrName in positionAttrs){\n                attrVal = positionAttrs[attrName];\n                def = this.getAttributeDefinition(attrName);\n                // POSITION - position function should return a point from the\n                // reference bounding box. The default position of the node is x:0, y:0 of\n                // the reference bounding box or could be further specify by some\n                // SVG attributes e.g. `x`, `y`\n                translation = def.position.call(this, attrVal, refBBox.clone(), node, rawAttrs, this);\n                if (translation) {\n                    nodePosition.offset(Point(translation).scale(sx, sy));\n                    positioned || (positioned = true);\n                }\n            }\n            // The node bounding box could depend on the `size` set from the previous loop.\n            // Here we know, that all the size attributes have been already set.\n            this.setNodeAttributes(node, nodeAttrs);\n            var offseted = false;\n            if (offsetAttrs) {\n                // Check if the node is visible\n                var nodeBoundingRect = this.getNodeBoundingRect(node);\n                if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n                    var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n                    for(attrName in offsetAttrs){\n                        attrVal = offsetAttrs[attrName];\n                        def = this.getAttributeDefinition(attrName);\n                        // OFFSET - offset function should return a point from the element\n                        // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n                        // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n                        translation = def.offset.call(this, attrVal, nodeBBox, node, rawAttrs, this);\n                        if (translation) {\n                            nodePosition.offset(Point(translation).scale(sx, sy));\n                            offseted || (offseted = true);\n                        }\n                    }\n                }\n            }\n            // Do not touch node's transform attribute if there is no transformation applied.\n            if (nodeTransform !== undefined || positioned || offseted) {\n                // Round the coordinates to 1 decimal point.\n                nodePosition.round(1);\n                nodeMatrix.e = nodePosition.x;\n                nodeMatrix.f = nodePosition.y;\n                node.setAttribute(\"transform\", V.matrixToTransformString(nodeMatrix));\n            // TODO: store nodeMatrix metrics?\n            }\n        },\n        getNodeScale: function(node, scalableNode) {\n            // Check if the node is a descendant of the scalable group.\n            var sx, sy;\n            if (scalableNode && scalableNode.contains(node)) {\n                var scale = scalableNode.scale();\n                sx = 1 / scale.sx;\n                sy = 1 / scale.sy;\n            } else {\n                sx = 1;\n                sy = 1;\n            }\n            return {\n                sx: sx,\n                sy: sy\n            };\n        },\n        cleanNodesCache: function() {\n            this.metrics = {};\n        },\n        nodeCache: function(magnet) {\n            var metrics = this.metrics;\n            // Don't use cache? It most likely a custom view with overridden update.\n            if (!metrics) return {};\n            var id = V.ensureId(magnet);\n            var value = metrics[id];\n            if (!value) value = metrics[id] = {};\n            return value;\n        },\n        getNodeData: function(magnet) {\n            var metrics = this.nodeCache(magnet);\n            if (!metrics.data) metrics.data = {};\n            return metrics.data;\n        },\n        getNodeBoundingRect: function(magnet) {\n            var metrics = this.nodeCache(magnet);\n            if (metrics.boundingRect === undefined) metrics.boundingRect = V(magnet).getBBox();\n            return new Rect(metrics.boundingRect);\n        },\n        getNodeMatrix: function(magnet) {\n            var metrics = this.nodeCache(magnet);\n            if (metrics.magnetMatrix === undefined) {\n                var ref = this;\n                var rotatableNode = ref.rotatableNode;\n                var el = ref.el;\n                var target;\n                if (rotatableNode && rotatableNode.contains(magnet)) target = rotatableNode;\n                else target = el;\n                metrics.magnetMatrix = V(magnet).getTransformToElement(target);\n            }\n            return V.createSVGMatrix(metrics.magnetMatrix);\n        },\n        getNodeShape: function(magnet) {\n            var metrics = this.nodeCache(magnet);\n            if (metrics.geometryShape === undefined) metrics.geometryShape = V(magnet).toGeometryShape();\n            return metrics.geometryShape.clone();\n        },\n        isNodeConnection: function(node) {\n            return this.model.isLink() && (!node || node === this.el);\n        },\n        findNodesAttributes: function(attrs, root, selectorCache, selectors) {\n            var i, n, nodeAttrs, nodeId;\n            var nodesAttrs = {};\n            var mergeIds = [];\n            for(var selector in attrs){\n                if (!attrs.hasOwnProperty(selector)) continue;\n                nodeAttrs = attrs[selector];\n                if (!isPlainObject(nodeAttrs)) continue;\n                 // Not a valid selector-attributes pair\n                var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n                for(i = 0, n = selected.length; i < n; i++){\n                    var node = selected[i];\n                    nodeId = V.ensureId(node);\n                    // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n                    // groupSelector referencing a single node is not \"unique\"\n                    var unique = selectors && selectors[selector] === node;\n                    var prevNodeAttrs = nodesAttrs[nodeId];\n                    if (prevNodeAttrs) {\n                        // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n                        // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n                        if (!prevNodeAttrs.array) {\n                            mergeIds.push(nodeId);\n                            prevNodeAttrs.array = true;\n                            prevNodeAttrs.attributes = [\n                                prevNodeAttrs.attributes\n                            ];\n                            prevNodeAttrs.selectedLength = [\n                                prevNodeAttrs.selectedLength\n                            ];\n                        }\n                        var attributes = prevNodeAttrs.attributes;\n                        var selectedLength = prevNodeAttrs.selectedLength;\n                        if (unique) {\n                            // node referenced by `selector`\n                            attributes.unshift(nodeAttrs);\n                            selectedLength.unshift(-1);\n                        } else {\n                            // node referenced by `groupSelector`\n                            var sortIndex = sortedIndex(selectedLength, n);\n                            attributes.splice(sortIndex, 0, nodeAttrs);\n                            selectedLength.splice(sortIndex, 0, n);\n                        }\n                    } else nodesAttrs[nodeId] = {\n                        attributes: nodeAttrs,\n                        selectedLength: unique ? -1 : n,\n                        node: node,\n                        array: false\n                    };\n                }\n            }\n            for(i = 0, n = mergeIds.length; i < n; i++){\n                nodeId = mergeIds[i];\n                nodeAttrs = nodesAttrs[nodeId];\n                nodeAttrs.attributes = merge.apply(void 0, [\n                    {}\n                ].concat(nodeAttrs.attributes.reverse()));\n            }\n            return nodesAttrs;\n        },\n        getEventTarget: function(evt, opt) {\n            if (opt === void 0) opt = {};\n            var target = evt.target;\n            var type = evt.type;\n            var clientX = evt.clientX;\n            if (clientX === void 0) clientX = 0;\n            var clientY = evt.clientY;\n            if (clientY === void 0) clientY = 0;\n            if (// Explicitly defined `fromPoint` option\n            opt.fromPoint || // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n            // It holds the element when a touchstart triggered.\n            type === \"touchmove\" || type === \"touchend\" || // Pointermove/Pointerup event with the pointer captured\n            \"pointerId\" in evt && target.hasPointerCapture(evt.pointerId)) return document.elementFromPoint(clientX, clientY);\n            return target;\n        },\n        // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n        // unless `attrs` parameter was passed.\n        updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {\n            opt || (opt = {});\n            opt.rootBBox || (opt.rootBBox = Rect());\n            opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n            // Cache table for query results and bounding box calculation.\n            // Note that `selectorCache` needs to be invalidated for all\n            // `updateAttributes` calls, as the selectors might pointing\n            // to nodes designated by an attribute or elements dynamically\n            // created.\n            var selectorCache = {};\n            var bboxCache = {};\n            var relativeItems = [];\n            var relativeRefItems = [];\n            var item, node, nodeAttrs, nodeData, processedAttrs;\n            var roAttrs = opt.roAttributes;\n            var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n            // `nodesAttrs` are different from all attributes, when\n            // rendering only  attributes sent to this method.\n            var nodesAllAttrs = roAttrs ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors) : nodesAttrs;\n            for(var nodeId in nodesAttrs){\n                nodeData = nodesAttrs[nodeId];\n                nodeAttrs = nodeData.attributes;\n                node = nodeData.node;\n                processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n                if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset) // Set all the normal attributes right on the SVG/HTML element.\n                this.setNodeAttributes(node, processedAttrs.normal);\n                else {\n                    var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n                    var refSelector = nodeAllAttrs && nodeAttrs.ref === undefined ? nodeAllAttrs.ref : nodeAttrs.ref;\n                    var refNode;\n                    if (refSelector) {\n                        refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n                        if (!refNode) throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n                    } else refNode = null;\n                    item = {\n                        node: node,\n                        refNode: refNode,\n                        processedAttributes: processedAttrs,\n                        allAttributes: nodeAllAttrs\n                    };\n                    if (refNode) {\n                        // If an element in the list is positioned relative to this one, then\n                        // we want to insert this one before it in the list.\n                        var itemIndex = relativeRefItems.findIndex(function(item) {\n                            return item.refNode === node;\n                        });\n                        if (itemIndex > -1) relativeRefItems.splice(itemIndex, 0, item);\n                        else relativeRefItems.push(item);\n                    } else // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n                    // The order of no-ref-items is not specified/important.\n                    relativeItems.push(item);\n                }\n            }\n            relativeItems.push.apply(relativeItems, relativeRefItems);\n            var rotatableMatrix;\n            for(var i = 0, n = relativeItems.length; i < n; i++){\n                item = relativeItems[i];\n                node = item.node;\n                refNode = item.refNode;\n                // Find the reference element bounding box. If no reference was provided, we\n                // use the optional bounding box.\n                var vRotatable = V(opt.rotatableNode);\n                var refNodeId = refNode ? V.ensureId(refNode) : \"\";\n                var isRefNodeRotatable = !!vRotatable && !!refNode && vRotatable.contains(refNode);\n                var unrotatedRefBBox = bboxCache[refNodeId];\n                if (!unrotatedRefBBox) {\n                    // Get the bounding box of the reference element relative to the `rotatable` `<g>` (without rotation)\n                    // or to the root `<g>` element if no rotatable group present if reference node present.\n                    // Uses the bounding box provided.\n                    var transformationTarget = isRefNodeRotatable ? vRotatable : rootNode;\n                    unrotatedRefBBox = bboxCache[refNodeId] = refNode ? V(refNode).getBBox({\n                        target: transformationTarget\n                    }) : opt.rootBBox;\n                }\n                if (roAttrs) {\n                    // if there was a special attribute affecting the position amongst passed-in attributes\n                    // we have to merge it with the rest of the element's attributes as they are necessary\n                    // to update the position relatively (i.e `ref-x` && 'ref-dx')\n                    processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n                    this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n                } else processedAttrs = item.processedAttributes;\n                var refBBox = unrotatedRefBBox;\n                if (isRefNodeRotatable && !vRotatable.contains(node)) {\n                    // if the referenced node is inside the rotatable group while the updated node is outside,\n                    // we need to take the rotatable node transformation into account\n                    if (!rotatableMatrix) rotatableMatrix = V.transformStringToMatrix(vRotatable.attr(\"transform\"));\n                    refBBox = V.transformRect(unrotatedRefBBox, rotatableMatrix);\n                }\n                this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n            }\n        },\n        mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {\n            processedAttrs.set || (processedAttrs.set = {});\n            processedAttrs.position || (processedAttrs.position = {});\n            processedAttrs.offset || (processedAttrs.offset = {});\n            assign(processedAttrs.set, roProcessedAttrs.set);\n            assign(processedAttrs.position, roProcessedAttrs.position);\n            assign(processedAttrs.offset, roProcessedAttrs.offset);\n            // Handle also the special transform property.\n            var transform = processedAttrs.normal && processedAttrs.normal.transform;\n            if (transform !== undefined && roProcessedAttrs.normal) roProcessedAttrs.normal.transform = transform;\n            processedAttrs.normal = roProcessedAttrs.normal;\n        },\n        // Lifecycle methods\n        // Called when the view is attached to the DOM,\n        // as result of `cell.addTo(graph)` being called (isInitialMount === true)\n        // or `paper.options.viewport` returning `true` (isInitialMount === false).\n        onMount: function onMount(isInitialMount) {\n            if (isInitialMount) return;\n            this.mountTools();\n            HighlighterView.mount(this);\n        },\n        // Called when the view is detached from the DOM,\n        // as result of `paper.options.viewport` returning `false`.\n        onDetach: function onDetach() {\n            this.unmountTools();\n            HighlighterView.unmount(this);\n        },\n        // Called when the view is removed from the DOM\n        // as result of `cell.remove()`.\n        onRemove: function() {\n            this.removeTools();\n            this.removeHighlighters();\n        },\n        _toolsView: null,\n        hasTools: function(name) {\n            var toolsView = this._toolsView;\n            if (!toolsView) return false;\n            if (!name) return true;\n            return toolsView.getName() === name;\n        },\n        addTools: function(toolsView) {\n            this.removeTools();\n            if (toolsView) {\n                this._toolsView = toolsView;\n                toolsView.configure({\n                    relatedView: this\n                });\n                toolsView.listenTo(this.paper, \"tools:event\", this.onToolEvent.bind(this));\n            }\n            return this;\n        },\n        unmountTools: function unmountTools() {\n            var toolsView = this._toolsView;\n            if (toolsView) toolsView.unmount();\n            return this;\n        },\n        mountTools: function mountTools() {\n            var toolsView = this._toolsView;\n            // Prevent unnecessary re-appending of the tools.\n            if (toolsView && !toolsView.isMounted()) toolsView.mount();\n            return this;\n        },\n        updateTools: function(opt) {\n            var toolsView = this._toolsView;\n            if (toolsView) toolsView.update(opt);\n            return this;\n        },\n        removeTools: function() {\n            var toolsView = this._toolsView;\n            if (toolsView) {\n                toolsView.remove();\n                this._toolsView = null;\n            }\n            return this;\n        },\n        hideTools: function() {\n            var toolsView = this._toolsView;\n            if (toolsView) toolsView.hide();\n            return this;\n        },\n        showTools: function() {\n            var toolsView = this._toolsView;\n            if (toolsView) toolsView.show();\n            return this;\n        },\n        onToolEvent: function(event) {\n            switch(event){\n                case \"remove\":\n                    this.removeTools();\n                    break;\n                case \"hide\":\n                    this.hideTools();\n                    break;\n                case \"show\":\n                    this.showTools();\n                    break;\n            }\n        },\n        removeHighlighters: function() {\n            HighlighterView.remove(this);\n        },\n        updateHighlighters: function(dirty) {\n            if (dirty === void 0) dirty = false;\n            HighlighterView.update(this, null, dirty);\n        },\n        transformHighlighters: function() {\n            HighlighterView.transform(this);\n        },\n        // Interaction. The controller part.\n        // ---------------------------------\n        preventDefaultInteraction: function preventDefaultInteraction(evt) {\n            this.eventData(evt, {\n                defaultInteractionPrevented: true\n            });\n        },\n        isDefaultInteractionPrevented: function isDefaultInteractionPrevented(evt) {\n            var ref = this.eventData(evt);\n            var defaultInteractionPrevented = ref.defaultInteractionPrevented;\n            if (defaultInteractionPrevented === void 0) defaultInteractionPrevented = false;\n            return defaultInteractionPrevented;\n        },\n        // Interaction is handled by the paper and delegated to the view in interest.\n        // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n        // If necessary, real coordinates can be obtained from the `evt` event object.\n        // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,\n        // i.e. `joint.dia.Element` and `joint.dia.Link`.\n        pointerdblclick: function(evt, x, y) {\n            this.notify(\"cell:pointerdblclick\", evt, x, y);\n        },\n        pointerclick: function(evt, x, y) {\n            this.notify(\"cell:pointerclick\", evt, x, y);\n        },\n        contextmenu: function(evt, x, y) {\n            this.notify(\"cell:contextmenu\", evt, x, y);\n        },\n        pointerdown: function(evt, x, y) {\n            var ref = this;\n            var model = ref.model;\n            var graph = model.graph;\n            if (graph) {\n                model.startBatch(\"pointer\");\n                this.eventData(evt, {\n                    graph: graph\n                });\n            }\n            this.notify(\"cell:pointerdown\", evt, x, y);\n        },\n        pointermove: function(evt, x, y) {\n            this.notify(\"cell:pointermove\", evt, x, y);\n        },\n        pointerup: function(evt, x, y) {\n            var ref = this.eventData(evt);\n            var graph = ref.graph;\n            this.notify(\"cell:pointerup\", evt, x, y);\n            if (graph) // we don't want to trigger event on model as model doesn't\n            // need to be member of collection anymore (remove)\n            graph.stopBatch(\"pointer\", {\n                cell: this.model\n            });\n        },\n        mouseover: function(evt) {\n            this.notify(\"cell:mouseover\", evt);\n        },\n        mouseout: function(evt) {\n            this.notify(\"cell:mouseout\", evt);\n        },\n        mouseenter: function(evt) {\n            this.notify(\"cell:mouseenter\", evt);\n        },\n        mouseleave: function(evt) {\n            this.notify(\"cell:mouseleave\", evt);\n        },\n        mousewheel: function(evt, x, y, delta) {\n            this.notify(\"cell:mousewheel\", evt, x, y, delta);\n        },\n        onevent: function(evt, eventName, x, y) {\n            this.notify(eventName, evt, x, y);\n        },\n        onmagnet: function() {\n        // noop\n        },\n        magnetpointerdblclick: function() {\n        // noop\n        },\n        magnetcontextmenu: function() {\n        // noop\n        },\n        checkMouseleave: function checkMouseleave(evt) {\n            var ref = this;\n            var paper = ref.paper;\n            var model = ref.model;\n            if (paper.isAsync()) {\n                // Make sure the source/target views are updated before this view.\n                // It's not 100% bulletproof (see below) but it's a good enough solution for now.\n                // The connected cells could be links as well. In that case, we would\n                // need to recursively go through all the connected links and update\n                // their source/target views as well.\n                if (model.isLink()) {\n                    // The `this.sourceView` and `this.targetView` might not be updated yet.\n                    // We need to find the view by the model.\n                    var sourceElement = model.getSourceElement();\n                    if (sourceElement) {\n                        var sourceView = paper.findViewByModel(sourceElement);\n                        if (sourceView) paper.dumpView(sourceView);\n                    }\n                    var targetElement = model.getTargetElement();\n                    if (targetElement) {\n                        var targetView = paper.findViewByModel(targetElement);\n                        if (targetView) paper.dumpView(targetView);\n                    }\n                }\n                // Do the updates of the current view synchronously now\n                paper.dumpView(this);\n            }\n            var target = this.getEventTarget(evt, {\n                fromPoint: true\n            });\n            var view = paper.findView(target);\n            if (view === this) return;\n            // Leaving the current view\n            this.mouseleave(evt);\n            if (!view) return;\n            // Entering another view\n            view.mouseenter(evt);\n        },\n        setInteractivity: function(value) {\n            this.options.interactive = value;\n        }\n    }, {\n        Flags: Flags,\n        Highlighting: HighlightingTypes,\n        addPresentationAttributes: function(presentationAttributes) {\n            return merge({}, result(this.prototype, \"presentationAttributes\"), presentationAttributes, function(a, b) {\n                if (!a || !b) return;\n                if (typeof a === \"string\") a = [\n                    a\n                ];\n                if (typeof b === \"string\") b = [\n                    b\n                ];\n                if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));\n            });\n        }\n    });\n    var Flags$1 = {\n        TOOLS: CellView.Flags.TOOLS,\n        UPDATE: \"UPDATE\",\n        TRANSLATE: \"TRANSLATE\",\n        RESIZE: \"RESIZE\",\n        PORTS: \"PORTS\",\n        ROTATE: \"ROTATE\",\n        RENDER: \"RENDER\"\n    };\n    var DragActions = {\n        MOVE: \"move\",\n        MAGNET: \"magnet\"\n    };\n    // Element base view and controller.\n    // -------------------------------------------\n    var ElementView = CellView.extend({\n        /**\n\t     * @abstract\n\t     */ _removePorts: function() {\n        // implemented in ports.js\n        },\n        /**\n\t     *\n\t     * @abstract\n\t     */ _renderPorts: function() {\n        // implemented in ports.js\n        },\n        className: function() {\n            var classNames = CellView.prototype.className.apply(this).split(\" \");\n            classNames.push(\"element\");\n            return classNames.join(\" \");\n        },\n        initialize: function() {\n            CellView.prototype.initialize.apply(this, arguments);\n            this._initializePorts();\n        },\n        presentationAttributes: {\n            \"attrs\": [\n                Flags$1.UPDATE\n            ],\n            \"position\": [\n                Flags$1.TRANSLATE,\n                Flags$1.TOOLS\n            ],\n            \"size\": [\n                Flags$1.RESIZE,\n                Flags$1.PORTS,\n                Flags$1.TOOLS\n            ],\n            \"angle\": [\n                Flags$1.ROTATE,\n                Flags$1.TOOLS\n            ],\n            \"markup\": [\n                Flags$1.RENDER\n            ],\n            \"ports\": [\n                Flags$1.PORTS\n            ]\n        },\n        initFlag: [\n            Flags$1.RENDER\n        ],\n        UPDATE_PRIORITY: 0,\n        confirmUpdate: function(flag, opt) {\n            var useCSSSelectors = config.useCSSSelectors;\n            if (this.hasFlag(flag, Flags$1.PORTS)) {\n                this._removePorts();\n                this._cleanPortsCache();\n            }\n            var transformHighlighters = false;\n            if (this.hasFlag(flag, Flags$1.RENDER)) {\n                this.render();\n                this.updateTools(opt);\n                this.updateHighlighters(true);\n                transformHighlighters = true;\n                flag = this.removeFlag(flag, [\n                    Flags$1.RENDER,\n                    Flags$1.UPDATE,\n                    Flags$1.RESIZE,\n                    Flags$1.TRANSLATE,\n                    Flags$1.ROTATE,\n                    Flags$1.PORTS,\n                    Flags$1.TOOLS\n                ]);\n            } else {\n                var updateHighlighters = false;\n                // Skip this branch if render is required\n                if (this.hasFlag(flag, Flags$1.RESIZE)) {\n                    this.resize(opt);\n                    updateHighlighters = true;\n                    // Resize method is calling `update()` internally\n                    flag = this.removeFlag(flag, [\n                        Flags$1.RESIZE,\n                        Flags$1.UPDATE\n                    ]);\n                    if (useCSSSelectors) // `resize()` rendered the ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, Flags$1.PORTS);\n                }\n                if (this.hasFlag(flag, Flags$1.UPDATE)) {\n                    this.update(this.model, null, opt);\n                    flag = this.removeFlag(flag, Flags$1.UPDATE);\n                    updateHighlighters = true;\n                    if (useCSSSelectors) // `update()` will render ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, Flags$1.PORTS);\n                }\n                if (this.hasFlag(flag, Flags$1.TRANSLATE)) {\n                    this.translate();\n                    flag = this.removeFlag(flag, Flags$1.TRANSLATE);\n                    transformHighlighters = true;\n                }\n                if (this.hasFlag(flag, Flags$1.ROTATE)) {\n                    this.rotate();\n                    flag = this.removeFlag(flag, Flags$1.ROTATE);\n                    transformHighlighters = true;\n                }\n                if (this.hasFlag(flag, Flags$1.PORTS)) {\n                    this._renderPorts();\n                    updateHighlighters = true;\n                    flag = this.removeFlag(flag, Flags$1.PORTS);\n                }\n                if (updateHighlighters) this.updateHighlighters(false);\n            }\n            if (transformHighlighters) this.transformHighlighters();\n            if (this.hasFlag(flag, Flags$1.TOOLS)) {\n                this.updateTools(opt);\n                flag = this.removeFlag(flag, Flags$1.TOOLS);\n            }\n            return flag;\n        },\n        /**\n\t     * @abstract\n\t     */ _initializePorts: function() {},\n        update: function(_, renderingOnlyAttrs) {\n            this.cleanNodesCache();\n            // When CSS selector strings are used, make sure no rule matches port nodes.\n            var useCSSSelectors = config.useCSSSelectors;\n            if (useCSSSelectors) this._removePorts();\n            var model = this.model;\n            var modelAttrs = model.attr();\n            this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n                rootBBox: new Rect(model.size()),\n                selectors: this.selectors,\n                scalableNode: this.scalableNode,\n                rotatableNode: this.rotatableNode,\n                // Use rendering only attributes if they differs from the model attributes\n                roAttributes: renderingOnlyAttrs === modelAttrs ? null : renderingOnlyAttrs\n            });\n            if (useCSSSelectors) this._renderPorts();\n        },\n        rotatableSelector: \"rotatable\",\n        scalableSelector: \"scalable\",\n        scalableNode: null,\n        rotatableNode: null,\n        // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n        // default markup is not desirable.\n        renderMarkup: function() {\n            var element = this.model;\n            var markup = element.get(\"markup\") || element.markup;\n            if (!markup) throw new Error(\"dia.ElementView: markup required\");\n            if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n            if (typeof markup === \"string\") return this.renderStringMarkup(markup);\n            throw new Error(\"dia.ElementView: invalid markup\");\n        },\n        renderJSONMarkup: function(markup) {\n            var doc = this.parseDOMJSON(markup, this.el);\n            var selectors = this.selectors = doc.selectors;\n            this.rotatableNode = V(selectors[this.rotatableSelector]) || null;\n            this.scalableNode = V(selectors[this.scalableSelector]) || null;\n            // Fragment\n            this.vel.append(doc.fragment);\n        },\n        renderStringMarkup: function(markup) {\n            var vel = this.vel;\n            vel.append(V(markup));\n            // Cache transformation groups\n            this.rotatableNode = vel.findOne(\".rotatable\");\n            this.scalableNode = vel.findOne(\".scalable\");\n            var selectors = this.selectors = {};\n            selectors[this.selector] = this.el;\n        },\n        render: function() {\n            this.vel.empty();\n            this.renderMarkup();\n            if (this.scalableNode) // Double update is necessary for elements with the scalable group only\n            // Note the resize() triggers the other `update`.\n            this.update();\n            this.resize();\n            if (this.rotatableNode) {\n                // Translate transformation is applied on `this.el` while the rotation transformation\n                // on `this.rotatableNode`\n                this.rotate();\n                this.translate();\n            } else this.updateTransformation();\n            if (!config.useCSSSelectors) this._renderPorts();\n            return this;\n        },\n        resize: function(opt) {\n            if (this.scalableNode) return this.sgResize(opt);\n            if (this.model.attributes.angle) this.rotate();\n            this.update();\n        },\n        translate: function() {\n            if (this.rotatableNode) return this.rgTranslate();\n            this.updateTransformation();\n        },\n        rotate: function() {\n            if (this.rotatableNode) {\n                this.rgRotate();\n                // It's necessary to call the update for the nodes outside\n                // the rotatable group referencing nodes inside the group\n                this.update();\n                return;\n            }\n            this.updateTransformation();\n        },\n        updateTransformation: function() {\n            var transformation = this.getTranslateString();\n            var rotateString = this.getRotateString();\n            if (rotateString) transformation += \" \" + rotateString;\n            this.vel.attr(\"transform\", transformation);\n        },\n        getTranslateString: function() {\n            var position = this.model.attributes.position;\n            return \"translate(\" + position.x + \",\" + position.y + \")\";\n        },\n        getRotateString: function() {\n            var attributes = this.model.attributes;\n            var angle = attributes.angle;\n            if (!angle) return null;\n            var size = attributes.size;\n            return \"rotate(\" + angle + \",\" + size.width / 2 + \",\" + size.height / 2 + \")\";\n        },\n        // Rotatable & Scalable Group\n        // always slower, kept mainly for backwards compatibility\n        rgRotate: function() {\n            this.rotatableNode.attr(\"transform\", this.getRotateString());\n        },\n        rgTranslate: function() {\n            this.vel.attr(\"transform\", this.getTranslateString());\n        },\n        sgResize: function(opt) {\n            var model = this.model;\n            var angle = model.angle();\n            var size = model.size();\n            var scalable = this.scalableNode;\n            // Getting scalable group's bbox.\n            // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n            // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n            var recursive = false;\n            if (scalable.node.getElementsByTagName(\"path\").length > 0) // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n            // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n            recursive = true;\n            var scalableBBox = scalable.getBBox({\n                recursive: recursive\n            });\n            // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n            // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n            var sx = size.width / (scalableBBox.width || 1);\n            var sy = size.height / (scalableBBox.height || 1);\n            scalable.attr(\"transform\", \"scale(\" + sx + \",\" + sy + \")\");\n            // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n            // Order of transformations is significant but we want to reconstruct the object always in the order:\n            // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n            // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n            // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n            // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n            // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n            // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n            var rotatable = this.rotatableNode;\n            var rotation = rotatable && rotatable.attr(\"transform\");\n            if (rotation) {\n                rotatable.attr(\"transform\", rotation + \" rotate(\" + -angle + \",\" + size.width / 2 + \",\" + size.height / 2 + \")\");\n                var rotatableBBox = scalable.getBBox({\n                    target: this.paper.cells\n                });\n                // Store new x, y and perform rotate() again against the new rotation origin.\n                model.set(\"position\", {\n                    x: rotatableBBox.x,\n                    y: rotatableBBox.y\n                }, assign({\n                    updateHandled: true\n                }, opt));\n                this.translate();\n                this.rotate();\n            }\n            // Update must always be called on non-rotated element. Otherwise, relative positioning\n            // would work with wrong (rotated) bounding boxes.\n            this.update();\n        },\n        // Embedding mode methods.\n        // -----------------------\n        prepareEmbedding: function(data) {\n            if (data === void 0) data = {};\n            var element = data.model || this.model;\n            var paper = data.paper || this.paper;\n            var graph = paper.model;\n            var initialZIndices = data.initialZIndices = {};\n            var embeddedCells = element.getEmbeddedCells({\n                deep: true\n            });\n            var connectedLinks = graph.getConnectedLinks(element, {\n                deep: true,\n                includeEnclosed: true\n            });\n            // Note: an embedded cell can be a connect link, but it's fine\n            // to iterate over the cell twice.\n            [\n                element\n            ].concat(embeddedCells, connectedLinks).forEach(function(cell) {\n                return initialZIndices[cell.id] = cell.attributes.z;\n            });\n            element.startBatch(\"to-front\");\n            // Bring the model to the front with all his embeds.\n            element.toFront({\n                deep: true,\n                ui: true\n            });\n            // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n            // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n            var maxZ = graph.getElements().reduce(function(max, cell) {\n                return Math.max(max, cell.attributes.z || 0);\n            }, 0);\n            // Move to front also all the inbound and outbound links that are connected\n            // to any of the element descendant. If we bring to front only embedded elements,\n            // links connected to them would stay in the background.\n            connectedLinks.forEach(function(link) {\n                if (link.attributes.z <= maxZ) link.set(\"z\", maxZ + 1, {\n                    ui: true\n                });\n            });\n            element.stopBatch(\"to-front\");\n            // Before we start looking for suitable parent we remove the current one.\n            var parentId = element.parent();\n            if (parentId) {\n                var parent = graph.getCell(parentId);\n                parent.unembed(element, {\n                    ui: true\n                });\n                data.initialParentId = parentId;\n            } else data.initialParentId = null;\n        },\n        processEmbedding: function(data, evt, x, y) {\n            if (data === void 0) data = {};\n            var model = data.model || this.model;\n            var paper = data.paper || this.paper;\n            var graph = paper.model;\n            var ref = paper.options;\n            var findParentBy = ref.findParentBy;\n            var frontParentOnly = ref.frontParentOnly;\n            var validateEmbedding = ref.validateEmbedding;\n            var candidates;\n            if (isFunction(findParentBy)) candidates = toArray(findParentBy.call(graph, this, evt, x, y));\n            else if (findParentBy === \"pointer\") candidates = toArray(graph.findModelsFromPoint({\n                x: x,\n                y: y\n            }));\n            else candidates = graph.findModelsUnderElement(model, {\n                searchBy: findParentBy\n            });\n            candidates = candidates.filter(function(el) {\n                return el instanceof Cell && model.id !== el.id && !el.isEmbeddedIn(model);\n            });\n            if (frontParentOnly) // pick the element with the highest `z` index\n            candidates = candidates.slice(-1);\n            var newCandidateView = null;\n            var prevCandidateView = data.candidateEmbedView;\n            // iterate over all candidates starting from the last one (has the highest z-index).\n            for(var i = candidates.length - 1; i >= 0; i--){\n                var candidate = candidates[i];\n                if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n                    // candidate remains the same\n                    newCandidateView = prevCandidateView;\n                    break;\n                } else {\n                    var view = candidate.findView(paper);\n                    if (!isFunction(validateEmbedding) || validateEmbedding.call(paper, this, view)) {\n                        // flip to the new candidate\n                        newCandidateView = view;\n                        break;\n                    }\n                }\n            }\n            if (newCandidateView && newCandidateView != prevCandidateView) {\n                // A new candidate view found. Highlight the new one.\n                this.clearEmbedding(data);\n                data.candidateEmbedView = newCandidateView.highlight(newCandidateView.findProxyNode(null, \"container\"), {\n                    embedding: true\n                });\n            }\n            if (!newCandidateView && prevCandidateView) // No candidate view found. Unhighlight the previous candidate.\n            this.clearEmbedding(data);\n        },\n        clearEmbedding: function(data) {\n            data || (data = {});\n            var candidateView = data.candidateEmbedView;\n            if (candidateView) {\n                // No candidate view found. Unhighlight the previous candidate.\n                candidateView.unhighlight(candidateView.findProxyNode(null, \"container\"), {\n                    embedding: true\n                });\n                data.candidateEmbedView = null;\n            }\n        },\n        finalizeEmbedding: function(data) {\n            if (data === void 0) data = {};\n            var candidateView = data.candidateEmbedView;\n            var element = data.model || this.model;\n            var paper = data.paper || this.paper;\n            if (candidateView) {\n                // We finished embedding. Candidate view is chosen to become the parent of the model.\n                candidateView.model.embed(element, {\n                    ui: true\n                });\n                candidateView.unhighlight(candidateView.findProxyNode(null, \"container\"), {\n                    embedding: true\n                });\n                data.candidateEmbedView = null;\n            } else {\n                var ref = paper.options;\n                var validateUnembedding = ref.validateUnembedding;\n                var initialParentId = data.initialParentId;\n                // The element was originally embedded into another element.\n                // The interaction would unembed the element. Let's validate\n                // if the element can be unembedded.\n                if (initialParentId && typeof validateUnembedding === \"function\" && !validateUnembedding.call(paper, this)) {\n                    this._disallowUnembed(data);\n                    return;\n                }\n            }\n            paper.model.getConnectedLinks(element, {\n                deep: true\n            }).forEach(function(link) {\n                link.reparent({\n                    ui: true\n                });\n            });\n        },\n        _disallowUnembed: function(data) {\n            var model = data.model;\n            var whenNotAllowed = data.whenNotAllowed;\n            if (whenNotAllowed === void 0) whenNotAllowed = \"revert\";\n            var element = model || this.model;\n            var paper = data.paper || this.paper;\n            var graph = paper.model;\n            switch(whenNotAllowed){\n                case \"remove\":\n                    element.remove({\n                        ui: true\n                    });\n                    break;\n                case \"revert\":\n                    var initialParentId = data.initialParentId;\n                    var initialPosition = data.initialPosition;\n                    var initialZIndices = data.initialZIndices;\n                    // Revert the element's position (and the position of its embedded cells if any)\n                    if (initialPosition) {\n                        var x = initialPosition.x;\n                        var y = initialPosition.y;\n                        element.position(x, y, {\n                            deep: true,\n                            ui: true\n                        });\n                    }\n                    // Revert all the z-indices changed during the embedding\n                    if (initialZIndices) Object.keys(initialZIndices).forEach(function(id) {\n                        var cell = graph.getCell(id);\n                        if (cell) cell.set(\"z\", initialZIndices[id], {\n                            ui: true\n                        });\n                    });\n                    // Revert the original parent\n                    var parent = graph.getCell(initialParentId);\n                    if (parent) parent.embed(element, {\n                        ui: true\n                    });\n                    break;\n            }\n        },\n        getDelegatedView: function() {\n            var view = this;\n            var model = view.model;\n            var paper = view.paper;\n            while(view){\n                if (model.isLink()) break;\n                if (!model.isEmbedded() || view.can(\"stopDelegation\")) return view;\n                model = model.getParentCell();\n                view = paper.findViewByModel(model);\n            }\n            return null;\n        },\n        findProxyNode: function(el, type) {\n            el || (el = this.el);\n            var nodeSelector = el.getAttribute(type + \"-selector\");\n            if (nodeSelector) {\n                var port = this.findAttribute(\"port\", el);\n                if (port) {\n                    var proxyPortNode = this.findPortNode(port, nodeSelector);\n                    if (proxyPortNode) return proxyPortNode;\n                } else {\n                    var ref = this.findBySelector(nodeSelector);\n                    var proxyNode = ref[0];\n                    if (proxyNode) return proxyNode;\n                }\n            }\n            return el;\n        },\n        // Interaction. The controller part.\n        // ---------------------------------\n        notifyPointerdown: function notifyPointerdown(evt, x, y) {\n            CellView.prototype.pointerdown.call(this, evt, x, y);\n            this.notify(\"element:pointerdown\", evt, x, y);\n        },\n        notifyPointermove: function notifyPointermove(evt, x, y) {\n            CellView.prototype.pointermove.call(this, evt, x, y);\n            this.notify(\"element:pointermove\", evt, x, y);\n        },\n        notifyPointerup: function notifyPointerup(evt, x, y) {\n            this.notify(\"element:pointerup\", evt, x, y);\n            CellView.prototype.pointerup.call(this, evt, x, y);\n        },\n        pointerdblclick: function(evt, x, y) {\n            CellView.prototype.pointerdblclick.apply(this, arguments);\n            this.notify(\"element:pointerdblclick\", evt, x, y);\n        },\n        pointerclick: function(evt, x, y) {\n            CellView.prototype.pointerclick.apply(this, arguments);\n            this.notify(\"element:pointerclick\", evt, x, y);\n        },\n        contextmenu: function(evt, x, y) {\n            CellView.prototype.contextmenu.apply(this, arguments);\n            this.notify(\"element:contextmenu\", evt, x, y);\n        },\n        pointerdown: function(evt, x, y) {\n            this.notifyPointerdown(evt, x, y);\n            this.dragStart(evt, x, y);\n        },\n        pointermove: function(evt, x, y) {\n            var data = this.eventData(evt);\n            var targetMagnet = data.targetMagnet;\n            var action = data.action;\n            var delegatedView = data.delegatedView;\n            if (targetMagnet) this.magnetpointermove(evt, targetMagnet, x, y);\n            switch(action){\n                case DragActions.MAGNET:\n                    this.dragMagnet(evt, x, y);\n                    break;\n                case DragActions.MOVE:\n                    (delegatedView || this).drag(evt, x, y);\n                // eslint: no-fallthrough=false\n                default:\n                    if (data.preventPointerEvents) break;\n                    this.notifyPointermove(evt, x, y);\n                    break;\n            }\n            // Make sure the element view data is passed along.\n            // It could have been wiped out in the handlers above.\n            this.eventData(evt, data);\n        },\n        pointerup: function(evt, x, y) {\n            var data = this.eventData(evt);\n            var targetMagnet = data.targetMagnet;\n            var action = data.action;\n            var delegatedView = data.delegatedView;\n            if (targetMagnet) this.magnetpointerup(evt, targetMagnet, x, y);\n            switch(action){\n                case DragActions.MAGNET:\n                    this.dragMagnetEnd(evt, x, y);\n                    break;\n                case DragActions.MOVE:\n                    (delegatedView || this).dragEnd(evt, x, y);\n                // eslint: no-fallthrough=false\n                default:\n                    if (data.preventPointerEvents) break;\n                    this.notifyPointerup(evt, x, y);\n            }\n            if (targetMagnet) this.magnetpointerclick(evt, targetMagnet, x, y);\n            this.checkMouseleave(evt);\n        },\n        mouseover: function(evt) {\n            CellView.prototype.mouseover.apply(this, arguments);\n            this.notify(\"element:mouseover\", evt);\n        },\n        mouseout: function(evt) {\n            CellView.prototype.mouseout.apply(this, arguments);\n            this.notify(\"element:mouseout\", evt);\n        },\n        mouseenter: function(evt) {\n            CellView.prototype.mouseenter.apply(this, arguments);\n            this.notify(\"element:mouseenter\", evt);\n        },\n        mouseleave: function(evt) {\n            CellView.prototype.mouseleave.apply(this, arguments);\n            this.notify(\"element:mouseleave\", evt);\n        },\n        mousewheel: function(evt, x, y, delta) {\n            CellView.prototype.mousewheel.apply(this, arguments);\n            this.notify(\"element:mousewheel\", evt, x, y, delta);\n        },\n        onmagnet: function(evt, x, y) {\n            var targetMagnet = evt.currentTarget;\n            this.magnetpointerdown(evt, targetMagnet, x, y);\n            this.eventData(evt, {\n                targetMagnet: targetMagnet\n            });\n            this.dragMagnetStart(evt, x, y);\n        },\n        magnetpointerdown: function(evt, magnet, x, y) {\n            this.notify(\"element:magnet:pointerdown\", evt, magnet, x, y);\n        },\n        magnetpointermove: function(evt, magnet, x, y) {\n            this.notify(\"element:magnet:pointermove\", evt, magnet, x, y);\n        },\n        magnetpointerup: function(evt, magnet, x, y) {\n            this.notify(\"element:magnet:pointerup\", evt, magnet, x, y);\n        },\n        magnetpointerdblclick: function(evt, magnet, x, y) {\n            this.notify(\"element:magnet:pointerdblclick\", evt, magnet, x, y);\n        },\n        magnetcontextmenu: function(evt, magnet, x, y) {\n            this.notify(\"element:magnet:contextmenu\", evt, magnet, x, y);\n        },\n        // Drag Start Handlers\n        dragStart: function(evt, x, y) {\n            if (this.isDefaultInteractionPrevented(evt)) return;\n            var view = this.getDelegatedView();\n            if (!view || !view.can(\"elementMove\")) return;\n            this.eventData(evt, {\n                action: DragActions.MOVE,\n                delegatedView: view\n            });\n            var position = view.model.position();\n            view.eventData(evt, {\n                initialPosition: position,\n                pointerOffset: position.difference(x, y),\n                restrictedArea: this.paper.getRestrictedArea(view, x, y)\n            });\n        },\n        dragMagnetStart: function(evt, x, y) {\n            var ref = this;\n            var paper = ref.paper;\n            var isPropagationAlreadyStopped = evt.isPropagationStopped();\n            if (isPropagationAlreadyStopped) // Special case when the propagation was already stopped\n            // on the `element:magnet:pointerdown` event.\n            // Do not trigger any `element:pointer*` events\n            // but still start the magnet dragging.\n            this.eventData(evt, {\n                preventPointerEvents: true\n            });\n            if (this.isDefaultInteractionPrevented(evt) || !this.can(\"addLinkFromMagnet\")) // Stop the default action, which is to start dragging a link.\n            return;\n            var ref$1 = this.eventData(evt);\n            var targetMagnet = ref$1.targetMagnet;\n            if (targetMagnet === void 0) targetMagnet = evt.currentTarget;\n            evt.stopPropagation();\n            // Invalid (Passive) magnet. Start dragging the element.\n            if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {\n                if (isPropagationAlreadyStopped) // Do not trigger `element:pointerdown` and start element dragging\n                // if the propagation was stopped.\n                this.dragStart(evt, x, y);\n                else // We need to reset the action\n                // to `MOVE` so that the element is dragged.\n                this.pointerdown(evt, x, y);\n                return;\n            }\n            // Valid magnet. Start dragging a link.\n            if (paper.options.magnetThreshold <= 0) this.dragLinkStart(evt, targetMagnet, x, y);\n            this.eventData(evt, {\n                action: DragActions.MAGNET\n            });\n        },\n        // Drag Handlers\n        drag: function(evt, x, y) {\n            var paper = this.paper;\n            var grid = paper.options.gridSize;\n            var element = this.model;\n            var data = this.eventData(evt);\n            var pointerOffset = data.pointerOffset;\n            var restrictedArea = data.restrictedArea;\n            var embedding = data.embedding;\n            // Make sure the new element's position always snaps to the current grid\n            var elX = snapToGrid(x + pointerOffset.x, grid);\n            var elY = snapToGrid(y + pointerOffset.y, grid);\n            element.position(elX, elY, {\n                restrictedArea: restrictedArea,\n                deep: true,\n                ui: true\n            });\n            if (paper.options.embeddingMode) {\n                if (!embedding) {\n                    // Prepare the element for embedding only if the pointer moves.\n                    // We don't want to do unnecessary action with the element\n                    // if an user only clicks/dblclicks on it.\n                    this.prepareEmbedding(data);\n                    embedding = true;\n                }\n                this.processEmbedding(data, evt, x, y);\n            }\n            this.eventData(evt, {\n                embedding: embedding\n            });\n        },\n        dragMagnet: function(evt, x, y) {\n            this.dragLink(evt, x, y);\n        },\n        // Drag End Handlers\n        dragEnd: function(evt, x, y) {\n            var data = this.eventData(evt);\n            if (data.embedding) this.finalizeEmbedding(data);\n        },\n        dragMagnetEnd: function(evt, x, y) {\n            this.dragLinkEnd(evt, x, y);\n        },\n        magnetpointerclick: function(evt, magnet, x, y) {\n            var paper = this.paper;\n            if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;\n            this.notify(\"element:magnet:pointerclick\", evt, magnet, x, y);\n        }\n    }, {\n        Flags: Flags$1\n    });\n    assign(ElementView.prototype, elementViewPortPrototype);\n    // Does not make any changes to vertices.\n    // Returns the arguments that are passed to it, unchanged.\n    var normal = function(vertices, opt, linkView) {\n        return vertices;\n    };\n    // Routes the link always to/from a certain side\n    //\n    // Arguments:\n    //   padding ... gap between the element and the first vertex. :: Default 40.\n    //   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n    //\n    var oneSide = function(vertices, opt, linkView) {\n        var side = opt.side || \"bottom\";\n        var padding = normalizeSides(opt.padding || 40);\n        // LinkView contains cached source an target bboxes.\n        // Note that those are Geometry rectangle objects.\n        var sourceBBox = linkView.sourceBBox;\n        var targetBBox = linkView.targetBBox;\n        var sourcePoint = sourceBBox.center();\n        var targetPoint = targetBBox.center();\n        var coordinate, dimension, direction;\n        switch(side){\n            case \"bottom\":\n                direction = 1;\n                coordinate = \"y\";\n                dimension = \"height\";\n                break;\n            case \"top\":\n                direction = -1;\n                coordinate = \"y\";\n                dimension = \"height\";\n                break;\n            case \"left\":\n                direction = -1;\n                coordinate = \"x\";\n                dimension = \"width\";\n                break;\n            case \"right\":\n                direction = 1;\n                coordinate = \"x\";\n                dimension = \"width\";\n                break;\n            default:\n                throw new Error(\"Router: invalid side\");\n        }\n        // move the points from the center of the element to outside of it.\n        sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n        targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);\n        // make link orthogonal (at least the first and last vertex).\n        if (direction * (sourcePoint[coordinate] - targetPoint[coordinate]) > 0) targetPoint[coordinate] = sourcePoint[coordinate];\n        else sourcePoint[coordinate] = targetPoint[coordinate];\n        return [\n            sourcePoint\n        ].concat(vertices, targetPoint);\n    };\n    // bearing -> opposite bearing\n    var opposites = {\n        N: \"S\",\n        S: \"N\",\n        E: \"W\",\n        W: \"E\"\n    };\n    // bearing -> radians\n    var radians = {\n        N: -Math.PI / 2 * 3,\n        S: -Math.PI / 2,\n        E: 0,\n        W: Math.PI\n    };\n    // HELPERS //\n    // returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n    // in the given box\n    function freeJoin(p1, p2, bbox) {\n        var p = new Point(p1.x, p2.y);\n        if (bbox.containsPoint(p)) p = new Point(p2.x, p1.y);\n        // kept for reference\n        // if (bbox.containsPoint(p)) p = null;\n        return p;\n    }\n    // returns either width or height of a bbox based on the given bearing\n    function getBBoxSize(bbox, bearing) {\n        return bbox[bearing === \"W\" || bearing === \"E\" ? \"width\" : \"height\"];\n    }\n    // simple bearing method (calculates only orthogonal cardinals)\n    function getBearing(from, to) {\n        if (from.x === to.x) return from.y > to.y ? \"N\" : \"S\";\n        if (from.y === to.y) return from.x > to.x ? \"W\" : \"E\";\n        return null;\n    }\n    // transform point to a rect\n    function getPointBox(p) {\n        return new Rect(p.x, p.y, 0, 0);\n    }\n    function getPaddingBox(opt) {\n        // if both provided, opt.padding wins over opt.elementPadding\n        var sides = normalizeSides(opt.padding || opt.elementPadding || 20);\n        return {\n            x: -sides.left,\n            y: -sides.top,\n            width: sides.left + sides.right,\n            height: sides.top + sides.bottom\n        };\n    }\n    // return source bbox\n    function getSourceBBox(linkView, opt) {\n        return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n    }\n    // return target bbox\n    function getTargetBBox(linkView, opt) {\n        return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n    }\n    // return source anchor\n    function getSourceAnchor(linkView, opt) {\n        if (linkView.sourceAnchor) return linkView.sourceAnchor;\n        // fallback: center of bbox\n        var sourceBBox = getSourceBBox(linkView, opt);\n        return sourceBBox.center();\n    }\n    // return target anchor\n    function getTargetAnchor(linkView, opt) {\n        if (linkView.targetAnchor) return linkView.targetAnchor;\n        // fallback: center of bbox\n        var targetBBox = getTargetBBox(linkView, opt);\n        return targetBBox.center(); // default\n    }\n    // PARTIAL ROUTERS //\n    function vertexVertex(from, to, bearing) {\n        var p1 = new Point(from.x, to.y);\n        var p2 = new Point(to.x, from.y);\n        var d1 = getBearing(from, p1);\n        var d2 = getBearing(from, p2);\n        var opposite = opposites[bearing];\n        var p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;\n        return {\n            points: [\n                p\n            ],\n            direction: getBearing(p, to)\n        };\n    }\n    function elementVertex(from, to, fromBBox) {\n        var p = freeJoin(from, to, fromBBox);\n        return {\n            points: [\n                p\n            ],\n            direction: getBearing(p, to)\n        };\n    }\n    function vertexElement(from, to, toBBox, bearing) {\n        var route = {};\n        var points = [\n            new Point(from.x, to.y),\n            new Point(to.x, from.y)\n        ];\n        var freePoints = points.filter(function(pt) {\n            return !toBBox.containsPoint(pt);\n        });\n        var freeBearingPoints = freePoints.filter(function(pt) {\n            return getBearing(pt, from) !== bearing;\n        });\n        var p;\n        if (freeBearingPoints.length > 0) {\n            // Try to pick a point which bears the same direction as the previous segment.\n            p = freeBearingPoints.filter(function(pt) {\n                return getBearing(from, pt) === bearing;\n            }).pop();\n            p = p || freeBearingPoints[0];\n            route.points = [\n                p\n            ];\n            route.direction = getBearing(p, to);\n        } else {\n            // Here we found only points which are either contained in the element or they would create\n            // a link segment going in opposite direction from the previous one.\n            // We take the point inside element and move it outside the element in the direction the\n            // route is going. Now we can join this point with the current end (using freeJoin).\n            p = difference(points, freePoints)[0];\n            var p2 = new Point(to).move(p, -getBBoxSize(toBBox, bearing) / 2);\n            var p1 = freeJoin(p2, from, toBBox);\n            route.points = [\n                p1,\n                p2\n            ];\n            route.direction = getBearing(p2, to);\n        }\n        return route;\n    }\n    function elementElement(from, to, fromBBox, toBBox) {\n        var route = elementVertex(to, from, toBBox);\n        var p1 = route.points[0];\n        if (fromBBox.containsPoint(p1)) {\n            route = elementVertex(from, to, fromBBox);\n            var p2 = route.points[0];\n            if (toBBox.containsPoint(p2)) {\n                var fromBorder = new Point(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n                var toBorder = new Point(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n                var mid = new Line(fromBorder, toBorder).midpoint();\n                var startRoute = elementVertex(from, mid, fromBBox);\n                var endRoute = vertexVertex(mid, to, startRoute.direction);\n                route.points = [\n                    startRoute.points[0],\n                    endRoute.points[0]\n                ];\n                route.direction = endRoute.direction;\n            }\n        }\n        return route;\n    }\n    // Finds route for situations where one element is inside the other.\n    // Typically the route is directed outside the outer element first and\n    // then back towards the inner element.\n    function insideElement(from, to, fromBBox, toBBox, bearing) {\n        var route = {};\n        var boundary = fromBBox.union(toBBox).inflate(1);\n        // start from the point which is closer to the boundary\n        var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n        var start = reversed ? to : from;\n        var end = reversed ? from : to;\n        var p1, p2, p3;\n        if (bearing) {\n            // Points on circle with radius equals 'W + H` are always outside the rectangle\n            // with width W and height H if the center of that circle is the center of that rectangle.\n            p1 = Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n            p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n        } else p1 = boundary.pointNearestToPoint(start).move(start, 1);\n        p2 = freeJoin(p1, end, boundary);\n        if (p1.round().equals(p2.round())) {\n            p2 = Point.fromPolar(boundary.width + boundary.height, toRad(p1.theta(start)) + Math.PI / 2, end);\n            p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n            p3 = freeJoin(p1, p2, boundary);\n            route.points = reversed ? [\n                p2,\n                p3,\n                p1\n            ] : [\n                p1,\n                p3,\n                p2\n            ];\n        } else route.points = reversed ? [\n            p2,\n            p1\n        ] : [\n            p1,\n            p2\n        ];\n        route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n        return route;\n    }\n    // MAIN ROUTER //\n    // Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n    // routing from source to target going through `vertices`.\n    function orthogonal(vertices, opt, linkView) {\n        var sourceBBox = getSourceBBox(linkView, opt);\n        var targetBBox = getTargetBBox(linkView, opt);\n        var sourceAnchor = getSourceAnchor(linkView, opt);\n        var targetAnchor = getTargetAnchor(linkView, opt);\n        // if anchor lies outside of bbox, the bbox expands to include it\n        sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n        targetBBox = targetBBox.union(getPointBox(targetAnchor));\n        vertices = toArray(vertices).map(Point);\n        vertices.unshift(sourceAnchor);\n        vertices.push(targetAnchor);\n        var bearing; // bearing of previous route segment\n        var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n        for(var i = 0, max = vertices.length - 1; i < max; i++){\n            var route = null;\n            var from = vertices[i];\n            var to = vertices[i + 1];\n            var isOrthogonal = !!getBearing(from, to);\n            if (i === 0) {\n                if (i + 1 === max) {\n                    // Expand one of the elements by 1px to detect situations when the two\n                    // elements are positioned next to each other with no gap in between.\n                    if (sourceBBox.intersect(targetBBox.clone().inflate(1))) route = insideElement(from, to, sourceBBox, targetBBox);\n                    else if (!isOrthogonal) route = elementElement(from, to, sourceBBox, targetBBox);\n                } else {\n                    if (sourceBBox.containsPoint(to)) route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n                    else if (!isOrthogonal) route = elementVertex(from, to, sourceBBox);\n                }\n            } else if (i + 1 === max) {\n                // prevent overlaps with previous line segment\n                var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n                if (targetBBox.containsPoint(from) || isOrthogonalLoop) route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n                else if (!isOrthogonal) route = vertexElement(from, to, targetBBox, bearing);\n            } else if (!isOrthogonal) route = vertexVertex(from, to, bearing);\n            // applicable to all routes:\n            // set bearing for next iteration\n            if (route) {\n                Array.prototype.push.apply(orthogonalVertices, route.points);\n                bearing = route.direction;\n            } else // orthogonal route and not looped\n            bearing = getBearing(from, to);\n            // push `to` point to identified orthogonal vertices array\n            if (i + 1 < max) orthogonalVertices.push(to);\n        }\n        return orthogonalVertices;\n    }\n    var config$1 = {\n        // size of the step to find a route (the grid of the manhattan pathfinder)\n        step: 10,\n        // the number of route finding loops that cause the router to abort\n        // returns fallback route instead\n        maximumLoops: 2000,\n        // the number of decimal places to round floating point coordinates\n        precision: 1,\n        // maximum change of direction\n        maxAllowedDirectionChange: 90,\n        // should the router use perpendicular linkView option?\n        // does not connect anchor of element but rather a point close-by that is orthogonal\n        // this looks much better\n        perpendicular: true,\n        // should the source and/or target not be considered as obstacles?\n        excludeEnds: [],\n        // should certain types of elements not be considered as obstacles?\n        excludeTypes: [\n            \"basic.Text\"\n        ],\n        // possible starting directions from an element\n        startDirections: [\n            \"top\",\n            \"right\",\n            \"bottom\",\n            \"left\"\n        ],\n        // possible ending directions to an element\n        endDirections: [\n            \"top\",\n            \"right\",\n            \"bottom\",\n            \"left\"\n        ],\n        // specify the directions used above and what they mean\n        directionMap: {\n            top: {\n                x: 0,\n                y: -1\n            },\n            right: {\n                x: 1,\n                y: 0\n            },\n            bottom: {\n                x: 0,\n                y: 1\n            },\n            left: {\n                x: -1,\n                y: 0\n            }\n        },\n        // cost of an orthogonal step\n        cost: function() {\n            return this.step;\n        },\n        // an array of directions to find next points on the route\n        // different from start/end directions\n        directions: function() {\n            var step = this.step;\n            var cost = this.cost();\n            return [\n                {\n                    offsetX: step,\n                    offsetY: 0,\n                    cost: cost\n                },\n                {\n                    offsetX: -step,\n                    offsetY: 0,\n                    cost: cost\n                },\n                {\n                    offsetX: 0,\n                    offsetY: step,\n                    cost: cost\n                },\n                {\n                    offsetX: 0,\n                    offsetY: -step,\n                    cost: cost\n                }\n            ];\n        },\n        // a penalty received for direction change\n        penalties: function() {\n            return {\n                0: 0,\n                45: this.step / 2,\n                90: this.step / 2\n            };\n        },\n        // padding applied on the element bounding boxes\n        paddingBox: function() {\n            var step = this.step;\n            return {\n                x: -step,\n                y: -step,\n                width: 2 * step,\n                height: 2 * step\n            };\n        },\n        // A function that determines whether a given point is an obstacle or not.\n        // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.\n        // (point: dia.Point) => boolean;\n        isPointObstacle: null,\n        // a router to use when the manhattan router fails\n        // (one of the partial routes returns null)\n        fallbackRouter: function(vertices, opt, linkView) {\n            if (!isFunction(orthogonal)) throw new Error(\"Manhattan requires the orthogonal router as default fallback.\");\n            return orthogonal(vertices, assign({}, config$1, opt), linkView);\n        },\n        /* Deprecated */ // a simple route used in situations when main routing method fails\n        // (exceed max number of loop iterations, inaccessible)\n        fallbackRoute: function(from, to, opt) {\n            return null; // null result will trigger the fallbackRouter\n        // left for reference:\n        /*// Find an orthogonal route ignoring obstacles.\n\n\t        var point = ((opt.previousDirAngle || 0) % 180 === 0)\n\t                ? new g.Point(from.x, to.y)\n\t                : new g.Point(to.x, from.y);\n\n\t        return [point];*/ },\n        // if a function is provided, it's used to route the link while dragging an end\n        // i.e. function(from, to, opt) { return []; }\n        draggingRoute: null\n    };\n    // HELPER CLASSES //\n    // Map of obstacles\n    // Helper structure to identify whether a point lies inside an obstacle.\n    function ObstacleMap(opt) {\n        this.map = {};\n        this.options = opt;\n        // tells how to divide the paper when creating the elements map\n        this.mapGridSize = 100;\n    }\n    ObstacleMap.prototype.build = function(graph, link) {\n        var opt = this.options;\n        // source or target element could be excluded from set of obstacles\n        var excludedEnds = toArray(opt.excludeEnds).reduce(function(res, item) {\n            var end = link.get(item);\n            if (end) {\n                var cell = graph.getCell(end.id);\n                if (cell) res.push(cell);\n            }\n            return res;\n        }, []);\n        // Exclude any embedded elements from the source and the target element.\n        var excludedAncestors = [];\n        var source = graph.getCell(link.get(\"source\").id);\n        if (source) excludedAncestors = union(excludedAncestors, source.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n        var target = graph.getCell(link.get(\"target\").id);\n        if (target) excludedAncestors = union(excludedAncestors, target.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n        // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n        // in any obstacle?) (a simplified grid search).\n        // The paper is divided into smaller cells, where each holds information about which\n        // elements belong to it. When we query whether a point lies inside an obstacle we\n        // don't need to go through all obstacles, we check only those in a particular cell.\n        var mapGridSize = this.mapGridSize;\n        graph.getElements().reduce(function(map, element) {\n            var isExcludedType = toArray(opt.excludeTypes).includes(element.get(\"type\"));\n            var isExcludedEnd = excludedEnds.find(function(excluded) {\n                return excluded.id === element.id;\n            });\n            var isExcludedAncestor = excludedAncestors.includes(element.id);\n            var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n            if (!isExcluded) {\n                var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n                var origin = bbox.origin().snapToGrid(mapGridSize);\n                var corner = bbox.corner().snapToGrid(mapGridSize);\n                for(var x = origin.x; x <= corner.x; x += mapGridSize)for(var y = origin.y; y <= corner.y; y += mapGridSize){\n                    var gridKey = x + \"@\" + y;\n                    map[gridKey] = map[gridKey] || [];\n                    map[gridKey].push(bbox);\n                }\n            }\n            return map;\n        }, this.map);\n        return this;\n    };\n    ObstacleMap.prototype.isPointAccessible = function(point) {\n        var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n        return toArray(this.map[mapKey]).every(function(obstacle) {\n            return !obstacle.containsPoint(point);\n        });\n    };\n    // Sorted Set\n    // Set of items sorted by given value.\n    function SortedSet() {\n        this.items = [];\n        this.hash = {};\n        this.values = {};\n        this.OPEN = 1;\n        this.CLOSE = 2;\n    }\n    SortedSet.prototype.add = function(item, value) {\n        if (this.hash[item]) // item removal\n        this.items.splice(this.items.indexOf(item), 1);\n        else this.hash[item] = this.OPEN;\n        this.values[item] = value;\n        var index$1 = sortedIndex(this.items, item, (function(i) {\n            return this.values[i];\n        }).bind(this));\n        this.items.splice(index$1, 0, item);\n    };\n    SortedSet.prototype.remove = function(item) {\n        this.hash[item] = this.CLOSE;\n    };\n    SortedSet.prototype.isOpen = function(item) {\n        return this.hash[item] === this.OPEN;\n    };\n    SortedSet.prototype.isClose = function(item) {\n        return this.hash[item] === this.CLOSE;\n    };\n    SortedSet.prototype.isEmpty = function() {\n        return this.items.length === 0;\n    };\n    SortedSet.prototype.pop = function() {\n        var item = this.items.shift();\n        this.remove(item);\n        return item;\n    };\n    // HELPERS //\n    // return source bbox\n    function getSourceBBox$1(linkView, opt) {\n        // expand by padding box\n        if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n        return linkView.sourceBBox.clone();\n    }\n    // return target bbox\n    function getTargetBBox$1(linkView, opt) {\n        // expand by padding box\n        if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n        return linkView.targetBBox.clone();\n    }\n    // return source anchor\n    function getSourceAnchor$1(linkView, opt) {\n        if (linkView.sourceAnchor) return linkView.sourceAnchor;\n        // fallback: center of bbox\n        var sourceBBox = getSourceBBox$1(linkView, opt);\n        return sourceBBox.center();\n    }\n    // return target anchor\n    function getTargetAnchor$1(linkView, opt) {\n        if (linkView.targetAnchor) return linkView.targetAnchor;\n        // fallback: center of bbox\n        var targetBBox = getTargetBBox$1(linkView, opt);\n        return targetBBox.center(); // default\n    }\n    // returns a direction index from start point to end point\n    // corrects for grid deformation between start and end\n    function getDirectionAngle(start, end, numDirections, grid, opt) {\n        var quadrant = 360 / numDirections;\n        var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n        var normalizedAngle = normalizeAngle(angleTheta + quadrant / 2);\n        return quadrant * Math.floor(normalizedAngle / quadrant);\n    }\n    // helper function for getDirectionAngle()\n    // corrects for grid deformation\n    // (if a point is one grid steps away from another in both dimensions,\n    // it is considered to be 45 degrees away, even if the real angle is different)\n    // this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\n    function fixAngleEnd(start, end, grid, opt) {\n        var step = opt.step;\n        var diffX = end.x - start.x;\n        var diffY = end.y - start.y;\n        var gridStepsX = diffX / grid.x;\n        var gridStepsY = diffY / grid.y;\n        var distanceX = gridStepsX * step;\n        var distanceY = gridStepsY * step;\n        return new Point(start.x + distanceX, start.y + distanceY);\n    }\n    // return the change in direction between two direction angles\n    function getDirectionChange(angle1, angle2) {\n        var directionChange = Math.abs(angle1 - angle2);\n        return directionChange > 180 ? 360 - directionChange : directionChange;\n    }\n    // fix direction offsets according to current grid\n    function getGridOffsets(directions, grid, opt) {\n        var step = opt.step;\n        toArray(opt.directions).forEach(function(direction) {\n            direction.gridOffsetX = direction.offsetX / step * grid.x;\n            direction.gridOffsetY = direction.offsetY / step * grid.y;\n        });\n    }\n    // get grid size in x and y dimensions, adapted to source and target positions\n    function getGrid(step, source, target) {\n        return {\n            source: source.clone(),\n            x: getGridDimension(target.x - source.x, step),\n            y: getGridDimension(target.y - source.y, step)\n        };\n    }\n    // helper function for getGrid()\n    function getGridDimension(diff, step) {\n        // return step if diff = 0\n        if (!diff) return step;\n        var absDiff = Math.abs(diff);\n        var numSteps = Math.round(absDiff / step);\n        // return absDiff if less than one step apart\n        if (!numSteps) return absDiff;\n        // otherwise, return corrected step\n        var roundedDiff = numSteps * step;\n        var remainder = absDiff - roundedDiff;\n        var stepCorrection = remainder / numSteps;\n        return step + stepCorrection;\n    }\n    // return a clone of point snapped to grid\n    function snapToGrid$1(point, grid) {\n        var source = grid.source;\n        var snappedX = snapToGrid(point.x - source.x, grid.x) + source.x;\n        var snappedY = snapToGrid(point.y - source.y, grid.y) + source.y;\n        return new Point(snappedX, snappedY);\n    }\n    // round the point to opt.precision\n    function round$4(point, precision) {\n        return point.round(precision);\n    }\n    // snap to grid and then round the point\n    function align(point, grid, precision) {\n        return round$4(snapToGrid$1(point.clone(), grid), precision);\n    }\n    // return a string representing the point\n    // string is rounded in both dimensions\n    function getKey(point) {\n        return point.clone().toString();\n    }\n    // return a normalized vector from given point\n    // used to determine the direction of a difference of two points\n    function normalizePoint(point) {\n        return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);\n    }\n    // PATHFINDING //\n    // reconstructs a route by concatenating points with their parents\n    function reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n        var route = [];\n        var prevDiff = normalizePoint(to.difference(tailPoint));\n        // tailPoint is assumed to be aligned already\n        var currentKey = getKey(tailPoint);\n        var parent = parents[currentKey];\n        var point;\n        while(parent){\n            // point is assumed to be aligned already\n            point = points[currentKey];\n            var diff = normalizePoint(point.difference(parent));\n            if (!diff.equals(prevDiff)) {\n                route.unshift(point);\n                prevDiff = diff;\n            }\n            // parent is assumed to be aligned already\n            currentKey = getKey(parent);\n            parent = parents[currentKey];\n        }\n        // leadPoint is assumed to be aligned already\n        var leadPoint = points[currentKey];\n        var fromDiff = normalizePoint(leadPoint.difference(from));\n        if (!fromDiff.equals(prevDiff)) route.unshift(leadPoint);\n        return route;\n    }\n    // heuristic method to determine the distance between two points\n    function estimateCost(from, endPoints) {\n        var min = Infinity;\n        for(var i = 0, len = endPoints.length; i < len; i++){\n            var cost = from.manhattanDistance(endPoints[i]);\n            if (cost < min) min = cost;\n        }\n        return min;\n    }\n    // find points around the bbox taking given directions into account\n    // lines are drawn from anchor in given directions, intersections recorded\n    // if anchor is outside bbox, only those directions that intersect get a rect point\n    // the anchor itself is returned as rect point (representing some directions)\n    // (since those directions are unobstructed by the bbox)\n    function getRectPoints(anchor, bbox, directionList, grid, opt) {\n        var precision = opt.precision;\n        var directionMap = opt.directionMap;\n        var anchorCenterVector = anchor.difference(bbox.center());\n        var keys = isObject$1(directionMap) ? Object.keys(directionMap) : [];\n        var dirList = toArray(directionList);\n        var rectPoints = keys.reduce(function(res, key) {\n            if (dirList.includes(key)) {\n                var direction = directionMap[key];\n                // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n                // even if anchor lies outside of bbox\n                var endpoint = new Point(anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height));\n                var intersectionLine = new Line(anchor, endpoint);\n                // get the farther intersection, in case there are two\n                // (that happens if anchor lies next to bbox)\n                var intersections = intersectionLine.intersect(bbox) || [];\n                var numIntersections = intersections.length;\n                var farthestIntersectionDistance;\n                var farthestIntersection = null;\n                for(var i = 0; i < numIntersections; i++){\n                    var currentIntersection = intersections[i];\n                    var distance = anchor.squaredDistance(currentIntersection);\n                    if (farthestIntersectionDistance === undefined || distance > farthestIntersectionDistance) {\n                        farthestIntersectionDistance = distance;\n                        farthestIntersection = currentIntersection;\n                    }\n                }\n                // if an intersection was found in this direction, it is our rectPoint\n                if (farthestIntersection) {\n                    var point = align(farthestIntersection, grid, precision);\n                    // if the rectPoint lies inside the bbox, offset it by one more step\n                    if (bbox.containsPoint(point)) point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n                    // then add the point to the result array\n                    // aligned\n                    res.push(point);\n                }\n            }\n            return res;\n        }, []);\n        // if anchor lies outside of bbox, add it to the array of points\n        if (!bbox.containsPoint(anchor)) // aligned\n        rectPoints.push(align(anchor, grid, precision));\n        return rectPoints;\n    }\n    // finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n    // rectangles get rect points assigned by getRectPoints()\n    function findRoute(from, to, isPointObstacle, opt) {\n        var precision = opt.precision;\n        // Get grid for this route.\n        var sourceAnchor, targetAnchor;\n        if (from instanceof Rect) sourceAnchor = round$4(getSourceAnchor$1(this, opt).clone(), precision);\n        else sourceAnchor = round$4(from.clone(), precision);\n        if (to instanceof Rect) targetAnchor = round$4(getTargetAnchor$1(this, opt).clone(), precision);\n        else targetAnchor = round$4(to.clone(), precision);\n        var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n        // Get pathfinding points.\n        var start, end; // aligned with grid by definition\n        var startPoints, endPoints; // assumed to be aligned with grid already\n        // set of points we start pathfinding from\n        if (from instanceof Rect) {\n            start = sourceAnchor;\n            startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n        } else {\n            start = sourceAnchor;\n            startPoints = [\n                start\n            ];\n        }\n        // set of points we want the pathfinding to finish at\n        if (to instanceof Rect) {\n            end = targetAnchor;\n            endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n        } else {\n            end = targetAnchor;\n            endPoints = [\n                end\n            ];\n        }\n        // take into account only accessible rect points (those not under obstacles)\n        startPoints = startPoints.filter(function(p) {\n            return !isPointObstacle(p);\n        });\n        endPoints = endPoints.filter(function(p) {\n            return !isPointObstacle(p);\n        });\n        // Check that there is an accessible route point on both sides.\n        // Otherwise, use fallbackRoute().\n        if (startPoints.length > 0 && endPoints.length > 0) {\n            // The set of tentative points to be evaluated, initially containing the start points.\n            // Rounded to nearest integer for simplicity.\n            var openSet = new SortedSet();\n            // Keeps reference to actual points for given elements of the open set.\n            var points = {};\n            // Keeps reference to a point that is immediate predecessor of given element.\n            var parents = {};\n            // Cost from start to a point along best known path.\n            var costs = {};\n            for(var i = 0, n = startPoints.length; i < n; i++){\n                // startPoint is assumed to be aligned already\n                var startPoint = startPoints[i];\n                var key = getKey(startPoint);\n                openSet.add(key, estimateCost(startPoint, endPoints));\n                points[key] = startPoint;\n                costs[key] = 0;\n            }\n            var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n            var isPathBeginning = previousRouteDirectionAngle === undefined;\n            // directions\n            var direction, directionChange;\n            var directions = opt.directions;\n            getGridOffsets(directions, grid, opt);\n            var numDirections = directions.length;\n            var endPointsKeys = toArray(endPoints).reduce(function(res, endPoint) {\n                // endPoint is assumed to be aligned already\n                var key = getKey(endPoint);\n                res.push(key);\n                return res;\n            }, []);\n            // main route finding loop\n            var loopsRemaining = opt.maximumLoops;\n            while(!openSet.isEmpty() && loopsRemaining > 0){\n                // remove current from the open list\n                var currentKey = openSet.pop();\n                var currentPoint = points[currentKey];\n                var currentParent = parents[currentKey];\n                var currentCost = costs[currentKey];\n                var isRouteBeginning = currentParent === undefined; // undefined for route starts\n                var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n                var previousDirectionAngle;\n                if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt);\n                else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle;\n                else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt);\n                else previousDirectionAngle = null;\n                 // beginning of path, source anchor or `from` point\n                // check if we reached any endpoint\n                var samePoints = startPoints.length === endPoints.length;\n                if (samePoints) {\n                    for(var j = 0; j < startPoints.length; j++)if (!startPoints[j].equals(endPoints[j])) {\n                        samePoints = false;\n                        break;\n                    }\n                }\n                var skipEndCheck = isRouteBeginning && samePoints;\n                if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n                    opt.previousDirectionAngle = previousDirectionAngle;\n                    return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n                }\n                // go over all possible directions and find neighbors\n                for(i = 0; i < numDirections; i++){\n                    direction = directions[i];\n                    var directionAngle = direction.angle;\n                    directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n                    // if the direction changed rapidly, don't use this point\n                    // any direction is allowed for starting points\n                    if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n                    var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n                    var neighborKey = getKey(neighborPoint);\n                    // Closed points from the openSet were already evaluated.\n                    if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;\n                    // We can only enter end points at an acceptable angle.\n                    if (endPointsKeys.indexOf(neighborKey) >= 0) {\n                        var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n                        if (!isNeighborEnd) {\n                            var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n                            var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n                            if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n                        }\n                    }\n                    // The current direction is ok.\n                    var neighborCost = direction.cost;\n                    var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n                    var costFromStart = currentCost + neighborCost + neighborPenalty;\n                    if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n                        // neighbor point has not been processed yet\n                        // or the cost of the path from start is lower than previously calculated\n                        points[neighborKey] = neighborPoint;\n                        parents[neighborKey] = currentPoint;\n                        costs[neighborKey] = costFromStart;\n                        openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n                    }\n                }\n                loopsRemaining--;\n            }\n        }\n        // no route found (`to` point either wasn't accessible or finding route took\n        // way too much calculation)\n        return opt.fallbackRoute.call(this, start, end, opt);\n    }\n    // resolve some of the options\n    function resolveOptions(opt) {\n        opt.directions = result(opt, \"directions\");\n        opt.penalties = result(opt, \"penalties\");\n        opt.paddingBox = result(opt, \"paddingBox\");\n        opt.padding = result(opt, \"padding\");\n        if (opt.padding) {\n            // if both provided, opt.padding wins over opt.paddingBox\n            var sides = normalizeSides(opt.padding);\n            opt.paddingBox = {\n                x: -sides.left,\n                y: -sides.top,\n                width: sides.left + sides.right,\n                height: sides.top + sides.bottom\n            };\n        }\n        toArray(opt.directions).forEach(function(direction) {\n            var point1 = new Point(0, 0);\n            var point2 = new Point(direction.offsetX, direction.offsetY);\n            direction.angle = normalizeAngle(point1.theta(point2));\n        });\n    }\n    // initialization of the route finding\n    function router(vertices, opt, linkView) {\n        resolveOptions(opt);\n        // enable/disable linkView perpendicular option\n        linkView.options.perpendicular = !!opt.perpendicular;\n        var sourceBBox = getSourceBBox$1(linkView, opt);\n        var targetBBox = getTargetBBox$1(linkView, opt);\n        var sourceAnchor = getSourceAnchor$1(linkView, opt);\n        //var targetAnchor = getTargetAnchor(linkView, opt);\n        // pathfinding\n        var isPointObstacle;\n        if (typeof opt.isPointObstacle === \"function\") isPointObstacle = opt.isPointObstacle;\n        else {\n            var map = new ObstacleMap(opt);\n            map.build(linkView.paper.model, linkView.model);\n            isPointObstacle = function(point) {\n                return !map.isPointAccessible(point);\n            };\n        }\n        var oldVertices = toArray(vertices).map(Point);\n        var newVertices = [];\n        var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n        // find a route by concatenating all partial routes (routes need to pass through vertices)\n        // source -> vertex[1] -> ... -> vertex[n] -> target\n        var to, from;\n        for(var i = 0, len = oldVertices.length; i <= len; i++){\n            var partialRoute = null;\n            from = to || sourceBBox;\n            to = oldVertices[i];\n            if (!to) {\n                // this is the last iteration\n                // we ran through all vertices in oldVertices\n                // 'to' is not a vertex.\n                to = targetBBox;\n                // If the target is a point (i.e. it's not an element), we\n                // should use dragging route instead of main routing method if it has been provided.\n                var isEndingAtPoint = !linkView.model.get(\"source\").id || !linkView.model.get(\"target\").id;\n                if (isEndingAtPoint && isFunction(opt.draggingRoute)) {\n                    // Make sure we are passing points only (not rects).\n                    var dragFrom = from === sourceBBox ? sourceAnchor : from;\n                    var dragTo = to.origin();\n                    partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n                }\n            }\n            // if partial route has not been calculated yet use the main routing method to find one\n            partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);\n            if (partialRoute === null) return opt.fallbackRouter(vertices, opt, linkView);\n            var leadPoint = partialRoute[0];\n            // remove the first point if the previous partial route had the same point as last\n            if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();\n            // save tailPoint for next iteration\n            tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n            Array.prototype.push.apply(newVertices, partialRoute);\n        }\n        return newVertices;\n    }\n    // public function\n    var manhattan = function(vertices, opt, linkView) {\n        return router(vertices, assign({}, config$1, opt), linkView);\n    };\n    var config$2 = {\n        maxAllowedDirectionChange: 45,\n        // cost of a diagonal step\n        diagonalCost: function() {\n            var step = this.step;\n            return Math.ceil(Math.sqrt(step * step << 1));\n        },\n        // an array of directions to find next points on the route\n        // different from start/end directions\n        directions: function() {\n            var step = this.step;\n            var cost = this.cost();\n            var diagonalCost = this.diagonalCost();\n            return [\n                {\n                    offsetX: step,\n                    offsetY: 0,\n                    cost: cost\n                },\n                {\n                    offsetX: step,\n                    offsetY: step,\n                    cost: diagonalCost\n                },\n                {\n                    offsetX: 0,\n                    offsetY: step,\n                    cost: cost\n                },\n                {\n                    offsetX: -step,\n                    offsetY: step,\n                    cost: diagonalCost\n                },\n                {\n                    offsetX: -step,\n                    offsetY: 0,\n                    cost: cost\n                },\n                {\n                    offsetX: -step,\n                    offsetY: -step,\n                    cost: diagonalCost\n                },\n                {\n                    offsetX: 0,\n                    offsetY: -step,\n                    cost: cost\n                },\n                {\n                    offsetX: step,\n                    offsetY: -step,\n                    cost: diagonalCost\n                }\n            ];\n        },\n        // a simple route used in situations when main routing method fails\n        // (exceed max number of loop iterations, inaccessible)\n        fallbackRoute: function(from, to, opt) {\n            // Find a route which breaks by 45 degrees ignoring all obstacles.\n            var theta = from.theta(to);\n            var route = [];\n            var a = {\n                x: to.x,\n                y: from.y\n            };\n            var b = {\n                x: from.x,\n                y: to.y\n            };\n            if (theta % 180 > 90) {\n                var t = a;\n                a = b;\n                b = t;\n            }\n            var p1 = theta % 90 < 45 ? a : b;\n            var l1 = new Line(from, p1);\n            var alpha = 90 * Math.ceil(theta / 90);\n            var p2 = Point.fromPolar(l1.squaredLength(), toRad(alpha + 135), p1);\n            var l2 = new Line(to, p2);\n            var intersectionPoint = l1.intersection(l2);\n            var point = intersectionPoint ? intersectionPoint : to;\n            var directionFrom = intersectionPoint ? point : from;\n            var quadrant = 360 / opt.directions.length;\n            var angleTheta = directionFrom.theta(to);\n            var normalizedAngle = normalizeAngle(angleTheta + quadrant / 2);\n            var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n            opt.previousDirectionAngle = directionAngle;\n            if (point) route.push(point.round());\n            route.push(to);\n            return route;\n        }\n    };\n    // public function\n    var metro = function(vertices, opt, linkView) {\n        if (!isFunction(manhattan)) throw new Error(\"Metro requires the manhattan router.\");\n        return manhattan(vertices, assign({}, config$2, opt), linkView);\n    };\n    var Directions = {\n        AUTO: \"auto\",\n        LEFT: \"left\",\n        RIGHT: \"right\",\n        TOP: \"top\",\n        BOTTOM: \"bottom\",\n        ANCHOR_SIDE: \"anchor-side\",\n        MAGNET_SIDE: \"magnet-side\"\n    };\n    var DEFINED_DIRECTIONS = [\n        Directions.LEFT,\n        Directions.RIGHT,\n        Directions.TOP,\n        Directions.BOTTOM\n    ];\n    function getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {\n        var tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));\n        var roundedAngle = Math.round(tangent.angle() / 90) * 90;\n        switch(roundedAngle){\n            case 0:\n            case 360:\n                return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n            case 90:\n                return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n            case 180:\n                return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n            case 270:\n                return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n        }\n    }\n    function rightAngleRouter(_vertices, opt, linkView) {\n        var margin = opt.margin || 20;\n        var sourceDirection = opt.sourceDirection;\n        if (sourceDirection === void 0) sourceDirection = Directions.AUTO;\n        var targetDirection = opt.targetDirection;\n        if (targetDirection === void 0) targetDirection = Directions.AUTO;\n        var sourceView = linkView.sourceView;\n        var targetView = linkView.targetView;\n        var isSourcePort = !!linkView.model.source().port;\n        var isTargetPort = !!linkView.model.target().port;\n        if (sourceDirection === Directions.AUTO) sourceDirection = isSourcePort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n        if (targetDirection === Directions.AUTO) targetDirection = isTargetPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n        var sourceBBox = linkView.sourceBBox;\n        var targetBBox = linkView.targetBBox;\n        var sourcePoint = linkView.sourceAnchor;\n        var targetPoint = linkView.targetAnchor;\n        var ref = sourceView && sourceView.model.isElement() ? Rect.fromRectUnion(sourceBBox, sourceView.model.getBBox()) : linkView.sourceAnchor;\n        var sx0 = ref.x;\n        var sy0 = ref.y;\n        var sourceWidth = ref.width;\n        if (sourceWidth === void 0) sourceWidth = 0;\n        var sourceHeight = ref.height;\n        if (sourceHeight === void 0) sourceHeight = 0;\n        var ref$1 = targetView && targetView.model.isElement() ? Rect.fromRectUnion(targetBBox, targetView.model.getBBox()) : linkView.targetAnchor;\n        var tx0 = ref$1.x;\n        var ty0 = ref$1.y;\n        var targetWidth = ref$1.width;\n        if (targetWidth === void 0) targetWidth = 0;\n        var targetHeight = ref$1.height;\n        if (targetHeight === void 0) targetHeight = 0;\n        var tx1 = tx0 + targetWidth;\n        var ty1 = ty0 + targetHeight;\n        var sx1 = sx0 + sourceWidth;\n        var sy1 = sy0 + sourceHeight;\n        // Key coordinates including the margin\n        var smx0 = sx0 - margin;\n        var smx1 = sx1 + margin;\n        var smy0 = sy0 - margin;\n        var smy1 = sy1 + margin;\n        var tmx0 = tx0 - margin;\n        var tmx1 = tx1 + margin;\n        var tmy0 = ty0 - margin;\n        var tmy1 = ty1 + margin;\n        var sourceOutsidePoint = sourcePoint.clone();\n        var sourceSide;\n        if (!sourceView) {\n            var sourceLinkAnchorBBox = new Rect(sx0, sy0, 0, 0);\n            sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);\n        } else if (sourceView.model.isLink()) sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);\n        else if (sourceDirection === Directions.ANCHOR_SIDE) sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);\n        else if (sourceDirection === Directions.MAGNET_SIDE) sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);\n        else sourceSide = sourceDirection;\n        switch(sourceSide){\n            case \"left\":\n                sourceOutsidePoint.x = smx0;\n                break;\n            case \"right\":\n                sourceOutsidePoint.x = smx1;\n                break;\n            case \"top\":\n                sourceOutsidePoint.y = smy0;\n                break;\n            case \"bottom\":\n                sourceOutsidePoint.y = smy1;\n                break;\n        }\n        var targetOutsidePoint = targetPoint.clone();\n        var targetSide;\n        if (!targetView) {\n            var targetLinkAnchorBBox = new Rect(tx0, ty0, 0, 0);\n            targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);\n        } else if (targetView.model.isLink()) targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);\n        else if (targetDirection === Directions.ANCHOR_SIDE) targetSide = targetBBox.sideNearestToPoint(targetPoint);\n        else if (targetDirection === Directions.MAGNET_SIDE) targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);\n        else targetSide = targetDirection;\n        switch(targetSide){\n            case \"left\":\n                targetOutsidePoint.x = tmx0;\n                break;\n            case \"right\":\n                targetOutsidePoint.x = tmx1;\n                break;\n            case \"top\":\n                targetOutsidePoint.y = tmy0;\n                break;\n            case \"bottom\":\n                targetOutsidePoint.y = tmy1;\n                break;\n        }\n        var sox = sourceOutsidePoint.x;\n        var soy = sourceOutsidePoint.y;\n        var tox = targetOutsidePoint.x;\n        var toy = targetOutsidePoint.y;\n        var tcx = (tx0 + tx1) / 2;\n        var tcy = (ty0 + ty1) / 2;\n        var scx = (sx0 + sx1) / 2;\n        var scy = (sy0 + sy1) / 2;\n        var middleOfVerticalSides = (scx < tcx ? sx1 + tx0 : tx1 + sx0) / 2;\n        var middleOfHorizontalSides = (scy < tcy ? sy1 + ty0 : ty1 + sy0) / 2;\n        if (sourceSide === \"left\" && targetSide === \"right\") {\n            if (smx0 <= tx1) {\n                var y = middleOfHorizontalSides;\n                if (sx1 <= tx0) {\n                    if (ty1 >= smy0 && toy < soy) y = Math.min(tmy0, smy0);\n                    else if (ty0 <= smy1 && toy >= soy) y = Math.max(tmy1, smy1);\n                }\n                return [\n                    {\n                        x: sox,\n                        y: soy\n                    },\n                    {\n                        x: sox,\n                        y: y\n                    },\n                    {\n                        x: tox,\n                        y: y\n                    },\n                    {\n                        x: tox,\n                        y: toy\n                    }\n                ];\n            }\n            var x = (sox + tox) / 2;\n            return [\n                {\n                    x: x,\n                    y: soy\n                },\n                {\n                    x: x,\n                    y: toy\n                }\n            ];\n        } else if (sourceSide === \"right\" && targetSide === \"left\") {\n            if (smx1 >= tx0) {\n                var y$1 = middleOfHorizontalSides;\n                if (sox > tx1) {\n                    if (ty1 >= smy0 && toy < soy) y$1 = Math.min(tmy0, smy0);\n                    else if (ty0 <= smy1 && toy >= soy) y$1 = Math.max(tmy1, smy1);\n                }\n                return [\n                    {\n                        x: sox,\n                        y: soy\n                    },\n                    {\n                        x: sox,\n                        y: y$1\n                    },\n                    {\n                        x: tox,\n                        y: y$1\n                    },\n                    {\n                        x: tox,\n                        y: toy\n                    }\n                ];\n            }\n            var x$1 = (sox + tox) / 2;\n            return [\n                {\n                    x: x$1,\n                    y: soy\n                },\n                {\n                    x: x$1,\n                    y: toy\n                }\n            ];\n        } else if (sourceSide === \"top\" && targetSide === \"bottom\") {\n            if (soy < toy) {\n                var x$2 = middleOfVerticalSides;\n                var y$2 = soy;\n                if (soy < ty0) {\n                    if (tx1 >= smx0 && tox < sox) x$2 = Math.min(tmx0, smx0);\n                    else if (tx0 <= smx1 && tox >= sox) x$2 = Math.max(tmx1, smx1);\n                }\n                return [\n                    {\n                        x: sox,\n                        y: y$2\n                    },\n                    {\n                        x: x$2,\n                        y: y$2\n                    },\n                    {\n                        x: x$2,\n                        y: toy\n                    },\n                    {\n                        x: tox,\n                        y: toy\n                    }\n                ];\n            }\n            var y$3 = (soy + toy) / 2;\n            return [\n                {\n                    x: sox,\n                    y: y$3\n                },\n                {\n                    x: tox,\n                    y: y$3\n                }\n            ];\n        } else if (sourceSide === \"bottom\" && targetSide === \"top\") {\n            if (soy - margin > toy) {\n                var x$3 = middleOfVerticalSides;\n                var y$4 = soy;\n                if (soy > ty1) {\n                    if (tx1 >= smx0 && tox < sox) x$3 = Math.min(tmx0, smx0);\n                    else if (tx0 <= smx1 && tox >= sox) x$3 = Math.max(tmx1, smx1);\n                }\n                return [\n                    {\n                        x: sox,\n                        y: y$4\n                    },\n                    {\n                        x: x$3,\n                        y: y$4\n                    },\n                    {\n                        x: x$3,\n                        y: toy\n                    },\n                    {\n                        x: tox,\n                        y: toy\n                    }\n                ];\n            }\n            var y$5 = (soy + toy) / 2;\n            return [\n                {\n                    x: sox,\n                    y: y$5\n                },\n                {\n                    x: tox,\n                    y: y$5\n                }\n            ];\n        } else if (sourceSide === \"top\" && targetSide === \"top\") {\n            var x$4;\n            var y1 = Math.min((sy1 + ty0) / 2, toy);\n            var y2 = Math.min((sy0 + ty1) / 2, soy);\n            if (toy < soy) {\n                if (sox >= tmx1 || sox <= tmx0) return [\n                    {\n                        x: sox,\n                        y: Math.min(soy, toy)\n                    },\n                    {\n                        x: tox,\n                        y: Math.min(soy, toy)\n                    }\n                ];\n                else if (tox > sox) x$4 = Math.min(sox, tmx0);\n                else x$4 = Math.max(sox, tmx1);\n            } else {\n                if (tox >= smx1 || tox <= smx0) return [\n                    {\n                        x: sox,\n                        y: Math.min(soy, toy)\n                    },\n                    {\n                        x: tox,\n                        y: Math.min(soy, toy)\n                    }\n                ];\n                else if (tox >= sox) x$4 = Math.max(tox, smx1);\n                else x$4 = Math.min(tox, smx0);\n            }\n            return [\n                {\n                    x: sox,\n                    y: y2\n                },\n                {\n                    x: x$4,\n                    y: y2\n                },\n                {\n                    x: x$4,\n                    y: y1\n                },\n                {\n                    x: tox,\n                    y: y1\n                }\n            ];\n        } else if (sourceSide === \"bottom\" && targetSide === \"bottom\") {\n            if (tx0 >= sox + margin || tx1 <= sox - margin) return [\n                {\n                    x: sox,\n                    y: Math.max(soy, toy)\n                },\n                {\n                    x: tox,\n                    y: Math.max(soy, toy)\n                }\n            ];\n            var x$5;\n            var y1$1;\n            var y2$1;\n            if (toy > soy) {\n                y1$1 = Math.max((sy1 + ty0) / 2, toy);\n                y2$1 = Math.max((sy1 + ty0) / 2, soy);\n                if (tox > sox) x$5 = Math.min(sox, tmx0);\n                else x$5 = Math.max(sox, tmx1);\n            } else {\n                y1$1 = Math.max((sy0 + ty1) / 2, toy);\n                y2$1 = Math.max((sy0 + ty1) / 2, soy);\n                if (tox > sox) x$5 = Math.min(tox, smx0);\n                else x$5 = Math.max(tox, smx1);\n            }\n            return [\n                {\n                    x: sox,\n                    y: y2$1\n                },\n                {\n                    x: x$5,\n                    y: y2$1\n                },\n                {\n                    x: x$5,\n                    y: y1$1\n                },\n                {\n                    x: tox,\n                    y: y1$1\n                }\n            ];\n        } else if (sourceSide === \"left\" && targetSide === \"left\") {\n            var y$6;\n            var x1 = Math.min((sx1 + tx0) / 2, tox);\n            var x2 = Math.min((sx0 + tx1) / 2, sox);\n            if (tox > sox) {\n                if (toy <= soy) y$6 = Math.min(smy0, toy);\n                else y$6 = Math.max(smy1, toy);\n            } else if (toy >= soy) y$6 = Math.min(tmy0, soy);\n            else y$6 = Math.max(tmy1, soy);\n            return [\n                {\n                    x: x2,\n                    y: soy\n                },\n                {\n                    x: x2,\n                    y: y$6\n                },\n                {\n                    x: x1,\n                    y: y$6\n                },\n                {\n                    x: x1,\n                    y: toy\n                }\n            ];\n        } else if (sourceSide === \"right\" && targetSide === \"right\") {\n            var y$7;\n            var x1$1 = Math.max((sx0 + tx1) / 2, tox);\n            var x2$1 = Math.max((sx1 + tx0) / 2, sox);\n            if (tox < sox) {\n                if (toy <= soy) y$7 = Math.min(smy0, toy);\n                else y$7 = Math.max(smy1, toy);\n            } else if (toy >= soy) y$7 = Math.min(tmy0, soy);\n            else y$7 = Math.max(tmy1, soy);\n            return [\n                {\n                    x: x2$1,\n                    y: soy\n                },\n                {\n                    x: x2$1,\n                    y: y$7\n                },\n                {\n                    x: x1$1,\n                    y: y$7\n                },\n                {\n                    x: x1$1,\n                    y: toy\n                }\n            ];\n        } else if (sourceSide === \"top\" && targetSide === \"right\") {\n            if (soy > toy) {\n                if (sox < tox) {\n                    var y$8 = (sy0 + ty1) / 2;\n                    if (y$8 > tcy && y$8 < tmy1 && sox < tmx0) y$8 = tmy0;\n                    return [\n                        {\n                            x: sox,\n                            y: y$8\n                        },\n                        {\n                            x: tox,\n                            y: y$8\n                        },\n                        {\n                            x: tox,\n                            y: toy\n                        }\n                    ];\n                }\n                return [\n                    {\n                        x: sox,\n                        y: toy\n                    }\n                ];\n            }\n            var x$6 = (sx0 + tx1) / 2;\n            if (sox > tox && sy1 >= toy) return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x: x$6,\n                    y: soy\n                },\n                {\n                    x: x$6,\n                    y: toy\n                }\n            ];\n            if (x$6 > smx0 && soy < ty1) {\n                var y$9 = Math.min(sy0, ty0) - margin;\n                var x$7 = Math.max(sx1, tx1) + margin;\n                return [\n                    {\n                        x: sox,\n                        y: y$9\n                    },\n                    {\n                        x: x$7,\n                        y: y$9\n                    },\n                    {\n                        x: x$7,\n                        y: toy\n                    }\n                ];\n            }\n            return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x: x$6,\n                    y: soy\n                },\n                {\n                    x: x$6,\n                    y: toy\n                }\n            ];\n        } else if (sourceSide === \"top\" && targetSide === \"left\") {\n            if (soy > toy) {\n                if (sox > tox) {\n                    var y$10 = (sy0 + ty1) / 2;\n                    if (y$10 > tcy && y$10 < tmy1 && sox > tmx1) y$10 = tmy0;\n                    return [\n                        {\n                            x: sox,\n                            y: y$10\n                        },\n                        {\n                            x: tox,\n                            y: y$10\n                        },\n                        {\n                            x: tox,\n                            y: toy\n                        }\n                    ];\n                }\n                return [\n                    {\n                        x: sox,\n                        y: toy\n                    }\n                ];\n            }\n            var x$8 = (sx1 + tx0) / 2;\n            if (sox < tox && sy1 >= toy) return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x: x$8,\n                    y: soy\n                },\n                {\n                    x: x$8,\n                    y: toy\n                }\n            ];\n            if (x$8 < smx1 && soy < ty1) {\n                var y$11 = Math.min(sy0, ty0) - margin;\n                var x$9 = Math.min(sx0, tx0) - margin;\n                return [\n                    {\n                        x: sox,\n                        y: y$11\n                    },\n                    {\n                        x: x$9,\n                        y: y$11\n                    },\n                    {\n                        x: x$9,\n                        y: toy\n                    }\n                ];\n            }\n            return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x: x$8,\n                    y: soy\n                },\n                {\n                    x: x$8,\n                    y: toy\n                }\n            ];\n        } else if (sourceSide === \"bottom\" && targetSide === \"right\") {\n            if (soy < toy) {\n                if (sox < tox) {\n                    var y$12 = (sy1 + ty0) / 2;\n                    if (y$12 < tcy && y$12 > tmy0 && sox < tmx0) y$12 = tmy1;\n                    return [\n                        {\n                            x: sox,\n                            y: y$12\n                        },\n                        {\n                            x: tox,\n                            y: y$12\n                        },\n                        {\n                            x: tox,\n                            y: toy\n                        }\n                    ];\n                }\n                return [\n                    {\n                        x: sox,\n                        y: toy\n                    }\n                ];\n            } else if (sx0 < tox) {\n                var y$13 = Math.max(sy1, ty1) + margin;\n                var x$10 = Math.max(sx1, tx1) + margin;\n                return [\n                    {\n                        x: sox,\n                        y: y$13\n                    },\n                    {\n                        x: x$10,\n                        y: y$13\n                    },\n                    {\n                        x: x$10,\n                        y: toy\n                    }\n                ];\n            }\n            var x$11 = middleOfVerticalSides;\n            return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x: x$11,\n                    y: soy\n                },\n                {\n                    x: x$11,\n                    y: toy\n                }\n            ];\n        } else if (sourceSide === \"bottom\" && targetSide === \"left\") {\n            if (soy < toy) {\n                if (sox > tox) {\n                    var y$14 = (sy1 + ty0) / 2;\n                    if (y$14 < tcy && y$14 > tmy0 && sox > tmx1) y$14 = tmy1;\n                    return [\n                        {\n                            x: sox,\n                            y: y$14\n                        },\n                        {\n                            x: tox,\n                            y: y$14\n                        },\n                        {\n                            x: tox,\n                            y: toy\n                        }\n                    ];\n                }\n                return [\n                    {\n                        x: sox,\n                        y: toy\n                    }\n                ];\n            } else if (sx1 > tox) {\n                var y$15 = Math.max(sy1, ty1) + margin;\n                var x$12 = Math.min(sx0, tx0) - margin;\n                return [\n                    {\n                        x: sox,\n                        y: y$15\n                    },\n                    {\n                        x: x$12,\n                        y: y$15\n                    },\n                    {\n                        x: x$12,\n                        y: toy\n                    }\n                ];\n            }\n            var x$13 = middleOfVerticalSides;\n            return [\n                {\n                    x: sox,\n                    y: soy\n                },\n                {\n                    x: x$13,\n                    y: soy\n                },\n                {\n                    x: x$13,\n                    y: toy\n                }\n            ];\n        } else if (sourceSide === \"left\" && targetSide === \"bottom\") {\n            if (sox > tox && soy >= tmy1) return [\n                {\n                    x: tox,\n                    y: soy\n                }\n            ];\n            if (sox >= tx1 && soy < toy) {\n                var x$14 = (sx1 + tx0) / 2;\n                return [\n                    {\n                        x: x$14,\n                        y: soy\n                    },\n                    {\n                        x: x$14,\n                        y: toy\n                    },\n                    {\n                        x: tox,\n                        y: toy\n                    }\n                ];\n            }\n            if (tox < sx1 && ty1 <= sy0) {\n                var y$16 = (sy0 + ty1) / 2;\n                return [\n                    {\n                        x: sox,\n                        y: soy\n                    },\n                    {\n                        x: sox,\n                        y: y$16\n                    },\n                    {\n                        x: tox,\n                        y: y$16\n                    }\n                ];\n            }\n            var x$15 = Math.min(tmx0, sox);\n            var y$17 = Math.max(sy1, ty1) + margin;\n            return [\n                {\n                    x: x$15,\n                    y: soy\n                },\n                {\n                    x: x$15,\n                    y: y$17\n                },\n                {\n                    x: tox,\n                    y: y$17\n                }\n            ];\n        } else if (sourceSide === \"left\" && targetSide === \"top\") {\n            if (sox > tox && soy < tmy0) return [\n                {\n                    x: tox,\n                    y: soy\n                }\n            ];\n            if (sox >= tx1) {\n                if (soy > toy) {\n                    var x$16 = (sx0 + tx1) / 2;\n                    return [\n                        {\n                            x: x$16,\n                            y: soy\n                        },\n                        {\n                            x: x$16,\n                            y: toy\n                        },\n                        {\n                            x: tox,\n                            y: toy\n                        }\n                    ];\n                }\n            }\n            if (tox <= sx1 && toy > soy) {\n                var y$18 = (ty0 + sy1) / 2;\n                return [\n                    {\n                        x: sox,\n                        y: soy\n                    },\n                    {\n                        x: sox,\n                        y: y$18\n                    },\n                    {\n                        x: tox,\n                        y: y$18\n                    }\n                ];\n            }\n            var x$17 = toy < soy ? Math.min(sx0, tx0) - margin : smx0;\n            var y$19 = Math.min(sy0, ty0) - margin;\n            return [\n                {\n                    x: x$17,\n                    y: soy\n                },\n                {\n                    x: x$17,\n                    y: y$19\n                },\n                {\n                    x: tox,\n                    y: y$19\n                }\n            ];\n        } else if (sourceSide === \"right\" && targetSide === \"top\") {\n            if (sox < tox && soy < tmy0) return [\n                {\n                    x: tox,\n                    y: soy\n                }\n            ];\n            if (sx1 < tx0 && soy > toy) {\n                var x$18 = (sx1 + tx0) / 2;\n                return [\n                    {\n                        x: x$18,\n                        y: soy\n                    },\n                    {\n                        x: x$18,\n                        y: toy\n                    },\n                    {\n                        x: tox,\n                        y: toy\n                    }\n                ];\n            }\n            if (tox < sox && ty0 > sy1) {\n                var y$20 = (sy1 + ty0) / 2;\n                return [\n                    {\n                        x: sox,\n                        y: soy\n                    },\n                    {\n                        x: sox,\n                        y: y$20\n                    },\n                    {\n                        x: tox,\n                        y: y$20\n                    }\n                ];\n            }\n            var x$19 = Math.max(sx1, tx1) + margin;\n            var y$21 = Math.min(sy0, ty0) - margin;\n            return [\n                {\n                    x: x$19,\n                    y: soy\n                },\n                {\n                    x: x$19,\n                    y: y$21\n                },\n                {\n                    x: tox,\n                    y: y$21\n                }\n            ];\n        } else if (sourceSide === \"right\" && targetSide === \"bottom\") {\n            if (sox < tox && soy >= tmy1) return [\n                {\n                    x: tox,\n                    y: soy\n                }\n            ];\n            if (sox <= tx0 && soy < toy) {\n                var x$20 = (sx1 + tx0) / 2;\n                return [\n                    {\n                        x: x$20,\n                        y: soy\n                    },\n                    {\n                        x: x$20,\n                        y: toy\n                    },\n                    {\n                        x: tox,\n                        y: toy\n                    }\n                ];\n            }\n            if (tox > sx0 && ty1 < sy0) {\n                var y$22 = (sy0 + ty1) / 2;\n                return [\n                    {\n                        x: sox,\n                        y: soy\n                    },\n                    {\n                        x: sox,\n                        y: y$22\n                    },\n                    {\n                        x: tox,\n                        y: y$22\n                    }\n                ];\n            }\n            var x$21 = Math.max(tmx1, sox);\n            var y$23 = Math.max(sy1, ty1) + margin;\n            return [\n                {\n                    x: x$21,\n                    y: soy\n                },\n                {\n                    x: x$21,\n                    y: y$23\n                },\n                {\n                    x: tox,\n                    y: y$23\n                }\n            ];\n        }\n    }\n    rightAngleRouter.Directions = Directions;\n    var rightAngle = rightAngleRouter;\n    var routers = {\n        normal: normal,\n        oneSide: oneSide,\n        orthogonal: orthogonal,\n        manhattan: manhattan,\n        metro: metro,\n        rightAngle: rightAngle\n    };\n    var CornerTypes = {\n        POINT: \"point\",\n        CUBIC: \"cubic\",\n        LINE: \"line\",\n        GAP: \"gap\"\n    };\n    var DEFINED_CORNER_TYPES = Object.values(CornerTypes);\n    var CORNER_RADIUS = 10;\n    var PRECISION = 1;\n    var straight = function(sourcePoint, targetPoint, routePoints, opt) {\n        if (routePoints === void 0) routePoints = [];\n        if (opt === void 0) opt = {};\n        var cornerType = opt.cornerType;\n        if (cornerType === void 0) cornerType = CornerTypes.POINT;\n        var cornerRadius = opt.cornerRadius;\n        if (cornerRadius === void 0) cornerRadius = CORNER_RADIUS;\n        var cornerPreserveAspectRatio = opt.cornerPreserveAspectRatio;\n        if (cornerPreserveAspectRatio === void 0) cornerPreserveAspectRatio = false;\n        var precision = opt.precision;\n        if (precision === void 0) precision = PRECISION;\n        var raw = opt.raw;\n        if (raw === void 0) raw = false;\n        if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) // unknown `cornerType` provided => error\n        throw new Error(\"Invalid `cornerType` provided to `straight` connector.\");\n        var path;\n        if (cornerType === CornerTypes.POINT || !cornerRadius) {\n            // default option => normal connector\n            // simply connect all points with straight lines\n            var points = [\n                sourcePoint\n            ].concat(routePoints).concat([\n                targetPoint\n            ]);\n            var polyline = new Polyline(points);\n            path = new Path(polyline);\n        } else {\n            // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types\n            path = new Path();\n            // add initial gap segment = to source point\n            path.appendSegment(Path.createSegment(\"M\", sourcePoint));\n            var nextDistance;\n            var routePointsLength = routePoints.length;\n            for(var i = 0; i < routePointsLength; i++){\n                var curr = new Point(routePoints[i]);\n                var prev = routePoints[i - 1] || sourcePoint;\n                var next = routePoints[i + 1] || targetPoint;\n                var prevDistance = nextDistance || curr.distance(prev) / 2; // try to re-use previously-computed `nextDistance`\n                nextDistance = curr.distance(next) / 2;\n                var startMove = void 0, endMove = void 0;\n                if (!cornerPreserveAspectRatio) {\n                    // `startMove` and `endMove` may be different\n                    // (this happens when next or previous path point is closer than `2 * cornerRadius`)\n                    startMove = -Math.min(cornerRadius, prevDistance);\n                    endMove = -Math.min(cornerRadius, nextDistance);\n                } else // force `startMove` and `endMove` to be the same\n                startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);\n                // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):\n                // - find a point lying on the line `prev - startMove` such that...\n                // - ...the point lies `abs(startMove)` distance away from `curr`...\n                // - ...and its coordinates are rounded to whole numbers\n                var cornerStart = curr.clone().move(prev, startMove).round(precision);\n                var cornerEnd = curr.clone().move(next, endMove).round(precision);\n                // add in-between straight segment = from previous route point to corner start point\n                // (may have zero length)\n                path.appendSegment(Path.createSegment(\"L\", cornerStart));\n                // add corner segment = from corner start point to corner end point\n                switch(cornerType){\n                    case CornerTypes.CUBIC:\n                        // corner is rounded\n                        var _13 = 1 / 3;\n                        var _23 = 2 / 3;\n                        var control1 = new Point(_13 * cornerStart.x + _23 * curr.x, _23 * curr.y + _13 * cornerStart.y);\n                        var control2 = new Point(_13 * cornerEnd.x + _23 * curr.x, _23 * curr.y + _13 * cornerEnd.y);\n                        path.appendSegment(Path.createSegment(\"C\", control1, control2, cornerEnd));\n                        break;\n                    case CornerTypes.LINE:\n                        // corner has bevel\n                        path.appendSegment(Path.createSegment(\"L\", cornerEnd));\n                        break;\n                    case CornerTypes.GAP:\n                        // corner has empty space\n                        path.appendSegment(Path.createSegment(\"M\", cornerEnd));\n                        break;\n                }\n            }\n            // add final straight segment = from last corner end point to target point\n            // (= or from start point to end point, if there are no route points)\n            // (may have zero length)\n            path.appendSegment(Path.createSegment(\"L\", targetPoint));\n        }\n        return raw ? path : path.serialize();\n    };\n    // default size of jump if not specified in options\n    var JUMP_SIZE = 5;\n    // available jump types\n    // first one taken as default\n    var JUMP_TYPES = [\n        \"arc\",\n        \"gap\",\n        \"cubic\"\n    ];\n    // default radius\n    var RADIUS = 0;\n    // takes care of math. error for case when jump is too close to end of line\n    var CLOSE_PROXIMITY_PADDING = 1;\n    // list of connector types not to jump over.\n    var IGNORED_CONNECTORS = [\n        \"smooth\"\n    ];\n    // internal constants for round segment\n    var _13 = 1 / 3;\n    var _23 = 2 / 3;\n    /**\n\t * Transform start/end and route into series of lines\n\t * @param {g.point} sourcePoint start point\n\t * @param {g.point} targetPoint end point\n\t * @param {g.point[]} route optional list of route\n\t * @return {g.line[]} [description]\n\t */ function createLines(sourcePoint, targetPoint, route) {\n        // make a flattened array of all points\n        var points = [].concat(sourcePoint, route, targetPoint);\n        return points.reduce(function(resultLines, point, idx) {\n            // if there is a next point, make a line with it\n            var nextPoint = points[idx + 1];\n            if (nextPoint != null) resultLines[idx] = line(point, nextPoint);\n            return resultLines;\n        }, []);\n    }\n    function setupUpdating(jumpOverLinkView) {\n        var paper = jumpOverLinkView.paper;\n        var updateList = paper._jumpOverUpdateList;\n        // first time setup for this paper\n        if (updateList == null) {\n            updateList = paper._jumpOverUpdateList = [];\n            var graph = paper.model;\n            graph.on(\"batch:stop\", function() {\n                if (this.hasActiveBatch()) return;\n                updateJumpOver(paper);\n            });\n            graph.on(\"reset\", function() {\n                updateList = paper._jumpOverUpdateList = [];\n            });\n        }\n        // add this link to a list so it can be updated when some other link is updated\n        if (updateList.indexOf(jumpOverLinkView) < 0) {\n            updateList.push(jumpOverLinkView);\n            // watch for change of connector type or removal of link itself\n            // to remove the link from a list of jump over connectors\n            jumpOverLinkView.listenToOnce(jumpOverLinkView.model, \"change:connector remove\", function() {\n                updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n            });\n        }\n    }\n    /**\n\t * Handler for a batch:stop event to force\n\t * update of all registered links with jump over connector\n\t * @param {object} batchEvent optional object with info about batch\n\t */ function updateJumpOver(paper) {\n        var updateList = paper._jumpOverUpdateList;\n        for(var i = 0; i < updateList.length; i++){\n            var linkView = updateList[i];\n            var updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n            linkView.requestUpdate(updateFlag);\n        }\n    }\n    /**\n\t * Utility function to collect all intersection points of a single\n\t * line against group of other lines.\n\t * @param {g.line} line where to find points\n\t * @param {g.line[]} crossCheckLines lines to cross\n\t * @return {g.point[]} list of intersection points\n\t */ function findLineIntersections(line, crossCheckLines) {\n        return toArray(crossCheckLines).reduce(function(res, crossCheckLine) {\n            var intersection = line.intersection(crossCheckLine);\n            if (intersection) res.push(intersection);\n            return res;\n        }, []);\n    }\n    /**\n\t * Sorting function for list of points by their distance.\n\t * @param {g.point} p1 first point\n\t * @param {g.point} p2 second point\n\t * @return {number} squared distance between points\n\t */ function sortPoints(p1, p2) {\n        return line(p1, p2).squaredLength();\n    }\n    /**\n\t * Split input line into multiple based on intersection points.\n\t * @param {g.line} line input line to split\n\t * @param {g.point[]} intersections points where to split the line\n\t * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n\t * @return {g.line[]} list of lines being split\n\t */ function createJumps(line$1, intersections, jumpSize) {\n        return intersections.reduce(function(resultLines, point$1, idx) {\n            // skipping points that were merged with the previous line\n            // to make bigger arc over multiple lines that are close to each other\n            if (point$1.skip === true) return resultLines;\n            // always grab the last line from buffer and modify it\n            var lastLine = resultLines.pop() || line$1;\n            // calculate start and end of jump by moving by a given size of jump\n            var jumpStart = point(point$1).move(lastLine.start, -jumpSize);\n            var jumpEnd = point(point$1).move(lastLine.start, +jumpSize);\n            // now try to look at the next intersection point\n            var nextPoint = intersections[idx + 1];\n            if (nextPoint != null) {\n                var distance = jumpEnd.distance(nextPoint);\n                if (distance <= jumpSize) {\n                    // next point is close enough, move the jump end by this\n                    // difference and mark the next point to be skipped\n                    jumpEnd = nextPoint.move(lastLine.start, distance);\n                    nextPoint.skip = true;\n                }\n            } else {\n                // this block is inside of `else` as an optimization so the distance is\n                // not calculated when we know there are no other intersection points\n                var endDistance = jumpStart.distance(lastLine.end);\n                // if the end is too close to possible jump, draw remaining line instead of a jump\n                if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n                    resultLines.push(lastLine);\n                    return resultLines;\n                }\n            }\n            var startDistance = jumpEnd.distance(lastLine.start);\n            if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n                // if the start of line is too close to jump, draw that line instead of a jump\n                resultLines.push(lastLine);\n                return resultLines;\n            }\n            // finally create a jump line\n            var jumpLine = line(jumpStart, jumpEnd);\n            // it's just simple line but with a `isJump` property\n            jumpLine.isJump = true;\n            resultLines.push(line(lastLine.start, jumpStart), jumpLine, line(jumpEnd, lastLine.end));\n            return resultLines;\n        }, []);\n    }\n    /**\n\t * Assemble `D` attribute of a SVG path by iterating given lines.\n\t * @param {g.line[]} lines source lines to use\n\t * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n\t * @param {number} radius the radius\n\t * @return {string}\n\t */ function buildPath(lines, jumpSize, jumpType, radius) {\n        var path = new Path();\n        var segment;\n        // first move to the start of a first line\n        segment = Path.createSegment(\"M\", lines[0].start);\n        path.appendSegment(segment);\n        // make a paths from lines\n        toArray(lines).forEach(function(line, index) {\n            if (line.isJump) {\n                var angle, diff;\n                var control1, control2;\n                if (jumpType === \"arc\") {\n                    angle = -90;\n                    // determine rotation of arc based on difference between points\n                    diff = line.start.difference(line.end);\n                    // make sure the arc always points up (or right)\n                    var xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n                    if (xAxisRotate) angle += 180;\n                    var midpoint = line.midpoint();\n                    var centerLine = new Line(midpoint, line.end).rotate(midpoint, angle);\n                    var halfLine;\n                    // first half\n                    halfLine = new Line(line.start, midpoint);\n                    control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n                    control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n                    segment = Path.createSegment(\"C\", control1, control2, centerLine.end);\n                    path.appendSegment(segment);\n                    // second half\n                    halfLine = new Line(midpoint, line.end);\n                    control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n                    control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n                    segment = Path.createSegment(\"C\", control1, control2, line.end);\n                    path.appendSegment(segment);\n                } else if (jumpType === \"gap\") {\n                    segment = Path.createSegment(\"M\", line.end);\n                    path.appendSegment(segment);\n                } else if (jumpType === \"cubic\") {\n                    angle = line.start.theta(line.end);\n                    var xOffset = jumpSize * 0.6;\n                    var yOffset = jumpSize * 1.35;\n                    // determine rotation of arc based on difference between points\n                    diff = line.start.difference(line.end);\n                    // make sure the arc always points up (or right)\n                    xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n                    if (xAxisRotate) yOffset *= -1;\n                    control1 = Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n                    control2 = Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n                    segment = Path.createSegment(\"C\", control1, control2, line.end);\n                    path.appendSegment(segment);\n                }\n            } else {\n                var nextLine = lines[index + 1];\n                if (radius == 0 || !nextLine || nextLine.isJump) {\n                    segment = Path.createSegment(\"L\", line.end);\n                    path.appendSegment(segment);\n                } else buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n            }\n        });\n        return path;\n    }\n    function buildRoundedSegment(offset, path, curr, prev, next) {\n        var prevDistance = curr.distance(prev) / 2;\n        var nextDistance = curr.distance(next) / 2;\n        var startMove = -Math.min(offset, prevDistance);\n        var endMove = -Math.min(offset, nextDistance);\n        var roundedStart = curr.clone().move(prev, startMove).round();\n        var roundedEnd = curr.clone().move(next, endMove).round();\n        var control1 = new Point(_13 * roundedStart.x + _23 * curr.x, _23 * curr.y + _13 * roundedStart.y);\n        var control2 = new Point(_13 * roundedEnd.x + _23 * curr.x, _23 * curr.y + _13 * roundedEnd.y);\n        var segment;\n        segment = Path.createSegment(\"L\", roundedStart);\n        path.appendSegment(segment);\n        segment = Path.createSegment(\"C\", control1, control2, roundedEnd);\n        path.appendSegment(segment);\n    }\n    /**\n\t * Actual connector function that will be run on every update.\n\t * @param {g.point} sourcePoint start point of this link\n\t * @param {g.point} targetPoint end point of this link\n\t * @param {g.point[]} route of this link\n\t * @param {object} opt options\n\t * @property {number} size optional size of a jump arc\n\t * @return {string} created `D` attribute of SVG path\n\t */ var jumpover = function(sourcePoint, targetPoint, route, opt) {\n        setupUpdating(this);\n        var raw = opt.raw;\n        var jumpSize = opt.size || JUMP_SIZE;\n        var jumpType = opt.jump && (\"\" + opt.jump).toLowerCase();\n        var radius = opt.radius || RADIUS;\n        var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n        // grab the first jump type as a default if specified one is invalid\n        if (JUMP_TYPES.indexOf(jumpType) === -1) jumpType = JUMP_TYPES[0];\n        var paper = this.paper;\n        var graph = paper.model;\n        var allLinks = graph.getLinks();\n        // there is just one link, draw it directly\n        if (allLinks.length === 1) return buildPath(createLines(sourcePoint, targetPoint, route), jumpSize, jumpType, radius);\n        var thisModel = this.model;\n        var thisIndex = allLinks.indexOf(thisModel);\n        var defaultConnector = paper.options.defaultConnector || {};\n        // not all links are meant to be jumped over.\n        var links = allLinks.filter(function(link, idx) {\n            var connector = link.get(\"connector\") || defaultConnector;\n            // avoid jumping over links with connector type listed in `ignored connectors`.\n            if (toArray(ignoreConnectors).includes(connector.name)) return false;\n            // filter out links that are above this one and  have the same connector type\n            // otherwise there would double hoops for each intersection\n            if (idx > thisIndex) return connector.name !== \"jumpover\";\n            return true;\n        });\n        // find views for all links\n        var linkViews = links.map(function(link) {\n            return paper.findViewByModel(link);\n        });\n        // create lines for this link\n        var thisLines = createLines(sourcePoint, targetPoint, route);\n        // create lines for all other links\n        var linkLines = linkViews.map(function(linkView) {\n            if (linkView == null) return [];\n            if (linkView === this) return thisLines;\n            return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.route);\n        }, this);\n        // transform lines for this link by splitting with jump lines at\n        // points of intersection with other links\n        var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {\n            // iterate all links and grab the intersections with this line\n            // these are then sorted by distance so the line can be split more easily\n            var intersections = links.reduce(function(res, link, i) {\n                // don't intersection with itself\n                if (link !== thisModel) {\n                    var lineIntersections = findLineIntersections(thisLine, linkLines[i]);\n                    res.push.apply(res, lineIntersections);\n                }\n                return res;\n            }, []).sort(function(a, b) {\n                return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n            });\n            if (intersections.length > 0) // split the line based on found intersection points\n            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n            else // without any intersection the line goes uninterrupted\n            resultLines.push(thisLine);\n            return resultLines;\n        }, []);\n        var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n        return raw ? path : path.serialize();\n    };\n    var normal$1 = function(sourcePoint, targetPoint, route, opt) {\n        if (route === void 0) route = [];\n        if (opt === void 0) opt = {};\n        var raw = opt.raw;\n        var localOpt = {\n            cornerType: \"point\",\n            raw: raw\n        };\n        return straight(sourcePoint, targetPoint, route, localOpt);\n    };\n    var CORNER_RADIUS$1 = 10;\n    var PRECISION$1 = 0;\n    var rounded = function(sourcePoint, targetPoint, route, opt) {\n        if (route === void 0) route = [];\n        if (opt === void 0) opt = {};\n        var radius = opt.radius;\n        if (radius === void 0) radius = CORNER_RADIUS$1;\n        var raw = opt.raw;\n        var localOpt = {\n            cornerType: \"cubic\",\n            cornerRadius: radius,\n            precision: PRECISION$1,\n            raw: raw\n        };\n        return straight(sourcePoint, targetPoint, route, localOpt);\n    };\n    var smooth = function(sourcePoint, targetPoint, route, opt) {\n        var raw = opt && opt.raw;\n        var path;\n        if (route && route.length !== 0) {\n            var points = [\n                sourcePoint\n            ].concat(route).concat([\n                targetPoint\n            ]);\n            var curves = Curve.throughPoints(points);\n            path = new Path(curves);\n        } else {\n            // if we have no route, use a default cubic bezier curve\n            // cubic bezier requires two control points\n            // the control points have `x` midway between source and target\n            // this produces an S-like curve\n            path = new Path();\n            var segment;\n            segment = Path.createSegment(\"M\", sourcePoint);\n            path.appendSegment(segment);\n            if (Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y)) {\n                var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n                segment = Path.createSegment(\"C\", controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);\n                path.appendSegment(segment);\n            } else {\n                var controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n                segment = Path.createSegment(\"C\", sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);\n                path.appendSegment(segment);\n            }\n        }\n        return raw ? path : path.serialize();\n    };\n    var Directions$1 = {\n        AUTO: \"auto\",\n        HORIZONTAL: \"horizontal\",\n        VERTICAL: \"vertical\",\n        CLOSEST_POINT: \"closest-point\",\n        OUTWARDS: \"outwards\"\n    };\n    var TangentDirections = {\n        UP: \"up\",\n        DOWN: \"down\",\n        LEFT: \"left\",\n        RIGHT: \"right\",\n        AUTO: \"auto\",\n        CLOSEST_POINT: \"closest-point\",\n        OUTWARDS: \"outwards\"\n    };\n    var curve = function(sourcePoint, targetPoint, route, opt, linkView) {\n        if (route === void 0) route = [];\n        if (opt === void 0) opt = {};\n        var raw = Boolean(opt.raw);\n        // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.\n        // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.\n        // tension - a Catmull-Rom curve tension parameter.\n        // sourceTangent - a tangent vector along the curve at the sourcePoint.\n        // sourceDirection - a unit direction vector along the curve at the sourcePoint.\n        // targetTangent - a tangent vector along the curve at the targetPoint.\n        // targetDirection - a unit direction vector along the curve at the targetPoint.\n        // precision - a rounding precision for path values.\n        var direction = opt.direction;\n        if (direction === void 0) direction = Directions$1.AUTO;\n        var precision = opt.precision;\n        if (precision === void 0) precision = 3;\n        var options = {\n            coeff: opt.distanceCoefficient || 0.6,\n            angleTangentCoefficient: opt.angleTangentCoefficient || 80,\n            tau: opt.tension || 0.5,\n            sourceTangent: opt.sourceTangent ? new Point(opt.sourceTangent) : null,\n            targetTangent: opt.targetTangent ? new Point(opt.targetTangent) : null,\n            rotate: Boolean(opt.rotate)\n        };\n        if (typeof opt.sourceDirection === \"string\") options.sourceDirection = opt.sourceDirection;\n        else if (typeof opt.sourceDirection === \"number\") options.sourceDirection = new Point(1, 0).rotate(null, opt.sourceDirection);\n        else options.sourceDirection = opt.sourceDirection ? new Point(opt.sourceDirection).normalize() : null;\n        if (typeof opt.targetDirection === \"string\") options.targetDirection = opt.targetDirection;\n        else if (typeof opt.targetDirection === \"number\") options.targetDirection = new Point(1, 0).rotate(null, opt.targetDirection);\n        else options.targetDirection = opt.targetDirection ? new Point(opt.targetDirection).normalize() : null;\n        var completeRoute = [\n            sourcePoint\n        ].concat(route, [\n            targetPoint\n        ]).map(function(p) {\n            return new Point(p);\n        });\n        // The calculation of a sourceTangent\n        var sourceTangent;\n        if (options.sourceTangent) sourceTangent = options.sourceTangent;\n        else {\n            var sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);\n            var tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;\n            var pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();\n            var angle = angleBetweenVectors(sourceDirection, pointsVector);\n            if (angle > Math.PI / 4) {\n                var updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n                sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);\n            } else sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);\n        }\n        // The calculation of a targetTangent\n        var targetTangent;\n        if (options.targetTangent) targetTangent = options.targetTangent;\n        else {\n            var targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);\n            var last = completeRoute.length - 1;\n            var tangentLength$1 = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;\n            var pointsVector$1 = completeRoute[last - 1].difference(completeRoute[last]).normalize();\n            var angle$1 = angleBetweenVectors(targetDirection, pointsVector$1);\n            if (angle$1 > Math.PI / 4) {\n                var updatedLength$1 = tangentLength$1 + (angle$1 - Math.PI / 4) * options.angleTangentCoefficient;\n                targetTangent = targetDirection.clone().scale(updatedLength$1, updatedLength$1);\n            } else targetTangent = targetDirection.clone().scale(tangentLength$1, tangentLength$1);\n        }\n        var catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);\n        var bezierCurves = catmullRomCurves.map(function(curve) {\n            return catmullRomToBezier(curve, options);\n        });\n        var path = new Path(bezierCurves).round(precision);\n        return raw ? path : path.serialize();\n    };\n    curve.Directions = Directions$1;\n    curve.TangentDirections = TangentDirections;\n    function getHorizontalSourceDirection(linkView, route, options) {\n        var sourceBBox = linkView.sourceBBox;\n        var sourceSide;\n        var rotation;\n        if (!linkView.sourceView) {\n            if (sourceBBox.x > route[1].x) sourceSide = \"right\";\n            else sourceSide = \"left\";\n        } else {\n            rotation = linkView.sourceView.model.angle();\n            if (options.rotate && rotation) {\n                var unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n                var sourcePoint = route[0].clone();\n                sourcePoint.rotate(sourceBBox.center(), rotation);\n                sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n            } else sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n        var direction;\n        switch(sourceSide){\n            case \"left\":\n                direction = new Point(-1, 0);\n                break;\n            case \"right\":\n            default:\n                direction = new Point(1, 0);\n                break;\n        }\n        if (options.rotate && rotation) direction.rotate(null, -rotation);\n        return direction;\n    }\n    function getHorizontalTargetDirection(linkView, route, options) {\n        var targetBBox = linkView.targetBBox;\n        var targetSide;\n        var rotation;\n        if (!linkView.targetView) {\n            if (targetBBox.x > route[route.length - 2].x) targetSide = \"left\";\n            else targetSide = \"right\";\n        } else {\n            rotation = linkView.targetView.model.angle();\n            if (options.rotate && rotation) {\n                var unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n                var targetPoint = route[route.length - 1].clone();\n                targetPoint.rotate(targetBBox.center(), rotation);\n                targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n            } else targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n        var direction;\n        switch(targetSide){\n            case \"left\":\n                direction = new Point(-1, 0);\n                break;\n            case \"right\":\n            default:\n                direction = new Point(1, 0);\n                break;\n        }\n        if (options.rotate && rotation) direction.rotate(null, -rotation);\n        return direction;\n    }\n    function getVerticalSourceDirection(linkView, route, options) {\n        var sourceBBox = linkView.sourceBBox;\n        var sourceSide;\n        var rotation;\n        if (!linkView.sourceView) {\n            if (sourceBBox.y > route[1].y) sourceSide = \"bottom\";\n            else sourceSide = \"top\";\n        } else {\n            rotation = linkView.sourceView.model.angle();\n            if (options.rotate && rotation) {\n                var unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n                var sourcePoint = route[0].clone();\n                sourcePoint.rotate(sourceBBox.center(), rotation);\n                sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n            } else sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n        var direction;\n        switch(sourceSide){\n            case \"top\":\n                direction = new Point(0, -1);\n                break;\n            case \"bottom\":\n            default:\n                direction = new Point(0, 1);\n                break;\n        }\n        if (options.rotate && rotation) direction.rotate(null, -rotation);\n        return direction;\n    }\n    function getVerticalTargetDirection(linkView, route, options) {\n        var targetBBox = linkView.targetBBox;\n        var targetSide;\n        var rotation;\n        if (!linkView.targetView) {\n            if (targetBBox.y > route[route.length - 2].y) targetSide = \"top\";\n            else targetSide = \"bottom\";\n        } else {\n            rotation = linkView.targetView.model.angle();\n            if (options.rotate && rotation) {\n                var unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n                var targetPoint = route[route.length - 1].clone();\n                targetPoint.rotate(targetBBox.center(), rotation);\n                targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n            } else targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n        var direction;\n        switch(targetSide){\n            case \"top\":\n                direction = new Point(0, -1);\n                break;\n            case \"bottom\":\n            default:\n                direction = new Point(0, 1);\n                break;\n        }\n        if (options.rotate && rotation) direction.rotate(null, -rotation);\n        return direction;\n    }\n    function getAutoSourceDirection(linkView, route, options) {\n        var sourceBBox = linkView.sourceBBox;\n        var sourceSide;\n        var rotation;\n        if (!linkView.sourceView) sourceSide = sourceBBox.sideNearestToPoint(route[1]);\n        else {\n            rotation = linkView.sourceView.model.angle();\n            if (options.rotate && rotation) {\n                var unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n                var sourcePoint = route[0].clone();\n                sourcePoint.rotate(sourceBBox.center(), rotation);\n                sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n            } else sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n        var direction;\n        switch(sourceSide){\n            case \"top\":\n                direction = new Point(0, -1);\n                break;\n            case \"bottom\":\n                direction = new Point(0, 1);\n                break;\n            case \"right\":\n                direction = new Point(1, 0);\n                break;\n            case \"left\":\n                direction = new Point(-1, 0);\n                break;\n        }\n        if (options.rotate && rotation) direction.rotate(null, -rotation);\n        return direction;\n    }\n    function getAutoTargetDirection(linkView, route, options) {\n        var targetBBox = linkView.targetBBox;\n        var targetSide;\n        var rotation;\n        if (!linkView.targetView) targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);\n        else {\n            rotation = linkView.targetView.model.angle();\n            if (options.rotate && rotation) {\n                var unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n                var targetPoint = route[route.length - 1].clone();\n                targetPoint.rotate(targetBBox.center(), rotation);\n                targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n            } else targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n        var direction;\n        switch(targetSide){\n            case \"top\":\n                direction = new Point(0, -1);\n                break;\n            case \"bottom\":\n                direction = new Point(0, 1);\n                break;\n            case \"right\":\n                direction = new Point(1, 0);\n                break;\n            case \"left\":\n                direction = new Point(-1, 0);\n                break;\n        }\n        if (options.rotate && rotation) direction.rotate(null, -rotation);\n        return direction;\n    }\n    function getClosestPointSourceDirection(linkView, route, options) {\n        return route[1].difference(route[0]).normalize();\n    }\n    function getClosestPointTargetDirection(linkView, route, options) {\n        var last = route.length - 1;\n        return route[last - 1].difference(route[last]).normalize();\n    }\n    function getOutwardsSourceDirection(linkView, route, options) {\n        var sourceBBox = linkView.sourceBBox;\n        var sourceCenter = sourceBBox.center();\n        return route[0].difference(sourceCenter).normalize();\n    }\n    function getOutwardsTargetDirection(linkView, route, options) {\n        var targetBBox = linkView.targetBBox;\n        var targetCenter = targetBBox.center();\n        return route[route.length - 1].difference(targetCenter).normalize();\n    }\n    function getSourceTangentDirection(linkView, route, direction, options) {\n        if (options.sourceDirection) switch(options.sourceDirection){\n            case TangentDirections.UP:\n                return new Point(0, -1);\n            case TangentDirections.DOWN:\n                return new Point(0, 1);\n            case TangentDirections.LEFT:\n                return new Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoSourceDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointSourceDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsSourceDirection(linkView, route, options);\n            default:\n                return options.sourceDirection;\n        }\n        switch(direction){\n            case Directions$1.HORIZONTAL:\n                return getHorizontalSourceDirection(linkView, route, options);\n            case Directions$1.VERTICAL:\n                return getVerticalSourceDirection(linkView, route, options);\n            case Directions$1.CLOSEST_POINT:\n                return getClosestPointSourceDirection(linkView, route, options);\n            case Directions$1.OUTWARDS:\n                return getOutwardsSourceDirection(linkView, route, options);\n            case Directions$1.AUTO:\n            default:\n                return getAutoSourceDirection(linkView, route, options);\n        }\n    }\n    function getTargetTangentDirection(linkView, route, direction, options) {\n        if (options.targetDirection) switch(options.targetDirection){\n            case TangentDirections.UP:\n                return new Point(0, -1);\n            case TangentDirections.DOWN:\n                return new Point(0, 1);\n            case TangentDirections.LEFT:\n                return new Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new Point(0, 1);\n            case TangentDirections.AUTO:\n                return getAutoTargetDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointTargetDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsTargetDirection(linkView, route, options);\n            default:\n                return options.targetDirection;\n        }\n        switch(direction){\n            case Directions$1.HORIZONTAL:\n                return getHorizontalTargetDirection(linkView, route, options);\n            case Directions$1.VERTICAL:\n                return getVerticalTargetDirection(linkView, route, options);\n            case Directions$1.CLOSEST_POINT:\n                return getClosestPointTargetDirection(linkView, route, options);\n            case Directions$1.OUTWARDS:\n                return getOutwardsTargetDirection(linkView, route, options);\n            case Directions$1.AUTO:\n            default:\n                return getAutoTargetDirection(linkView, route, options);\n        }\n    }\n    function rotateVector(vector, angle) {\n        var cos = Math.cos(angle);\n        var sin = Math.sin(angle);\n        var x = cos * vector.x - sin * vector.y;\n        var y = sin * vector.x + cos * vector.y;\n        vector.x = x;\n        vector.y = y;\n    }\n    function angleBetweenVectors(v1, v2) {\n        var cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n        if (cos < -1) cos = -1;\n        if (cos > 1) cos = 1;\n        return Math.acos(cos);\n    }\n    function determinant(v1, v2) {\n        return v1.x * v2.y - v1.y * v2.x;\n    }\n    function createCatmullRomCurves(points, sourceTangent, targetTangent, options) {\n        var tau = options.tau;\n        var coeff = options.coeff;\n        var distances = [];\n        var tangents = [];\n        var catmullRomCurves = [];\n        var n = points.length - 1;\n        for(var i = 0; i < n; i++)distances[i] = points[i].distance(points[i + 1]);\n        tangents[0] = sourceTangent;\n        tangents[n] = targetTangent;\n        // The calculation of tangents of vertices\n        for(var i$1 = 1; i$1 < n; i$1++){\n            var tpPrev = void 0;\n            var tpNext = void 0;\n            if (i$1 === 1) tpPrev = points[i$1 - 1].clone().offset(tangents[i$1 - 1].x, tangents[i$1 - 1].y);\n            else tpPrev = points[i$1 - 1].clone();\n            if (i$1 === n - 1) tpNext = points[i$1 + 1].clone().offset(tangents[i$1 + 1].x, tangents[i$1 + 1].y);\n            else tpNext = points[i$1 + 1].clone();\n            var v1 = tpPrev.difference(points[i$1]).normalize();\n            var v2 = tpNext.difference(points[i$1]).normalize();\n            var vAngle = angleBetweenVectors(v1, v2);\n            var rot = (Math.PI - vAngle) / 2;\n            var t = void 0;\n            var vectorDeterminant = determinant(v1, v2);\n            var pointsDeterminant = void 0;\n            pointsDeterminant = determinant(points[i$1].difference(points[i$1 + 1]), points[i$1].difference(points[i$1 - 1]));\n            if (vectorDeterminant < 0) rot = -rot;\n            if (vAngle < Math.PI / 2 && (rot < 0 && pointsDeterminant < 0 || rot > 0 && pointsDeterminant > 0)) rot = rot - Math.PI;\n            t = v2.clone();\n            rotateVector(t, rot);\n            var t1 = t.clone();\n            var t2 = t.clone();\n            var scaleFactor1 = distances[i$1 - 1] * coeff;\n            var scaleFactor2 = distances[i$1] * coeff;\n            t1.scale(scaleFactor1, scaleFactor1);\n            t2.scale(scaleFactor2, scaleFactor2);\n            tangents[i$1] = [\n                t1,\n                t2\n            ];\n        }\n        // The building of a Catmull-Rom curve based of tangents of points\n        for(var i$2 = 0; i$2 < n; i$2++){\n            var p0 = void 0;\n            var p3 = void 0;\n            if (i$2 === 0) p0 = points[i$2 + 1].difference(tangents[i$2].x / tau, tangents[i$2].y / tau);\n            else p0 = points[i$2 + 1].difference(tangents[i$2][1].x / tau, tangents[i$2][1].y / tau);\n            if (i$2 === n - 1) p3 = points[i$2].clone().offset(tangents[i$2 + 1].x / tau, tangents[i$2 + 1].y / tau);\n            else p3 = points[i$2].difference(tangents[i$2 + 1][0].x / tau, tangents[i$2 + 1][0].y / tau);\n            catmullRomCurves[i$2] = [\n                p0,\n                points[i$2],\n                points[i$2 + 1],\n                p3\n            ];\n        }\n        return catmullRomCurves;\n    }\n    // The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)\n    function catmullRomToBezier(points, options) {\n        var tau = options.tau;\n        var bcp1 = new Point();\n        bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);\n        bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);\n        var bcp2 = new Point();\n        bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);\n        bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);\n        return new Curve(points[1], bcp1, bcp2, points[2]);\n    }\n    var connectors = {\n        straight: straight,\n        jumpover: jumpover,\n        normal: normal$1,\n        rounded: rounded,\n        smooth: smooth,\n        curve: curve\n    };\n    var Flags$2 = {\n        TOOLS: CellView.Flags.TOOLS,\n        RENDER: \"RENDER\",\n        UPDATE: \"UPDATE\",\n        LEGACY_TOOLS: \"LEGACY_TOOLS\",\n        LABELS: \"LABELS\",\n        VERTICES: \"VERTICES\",\n        SOURCE: \"SOURCE\",\n        TARGET: \"TARGET\",\n        CONNECTOR: \"CONNECTOR\"\n    };\n    // Link base view and controller.\n    // ----------------------------------------\n    var LinkView = CellView.extend({\n        className: function() {\n            var classNames = CellView.prototype.className.apply(this).split(\" \");\n            classNames.push(\"link\");\n            return classNames.join(\" \");\n        },\n        options: {\n            shortLinkLength: 105,\n            doubleLinkTools: false,\n            longLinkLength: 155,\n            linkToolsOffset: 40,\n            doubleLinkToolsOffset: 65,\n            sampleInterval: 50\n        },\n        _labelCache: null,\n        _labelSelectors: null,\n        _markerCache: null,\n        _V: null,\n        _dragData: null,\n        metrics: null,\n        decimalsRounding: 2,\n        initialize: function() {\n            CellView.prototype.initialize.apply(this, arguments);\n            // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n            // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n            // nodes in `updateLabelPosition()` in order to update the label positions.\n            this._labelCache = {};\n            // a cache of label selectors\n            this._labelSelectors = {};\n            // keeps markers bboxes and positions again for quicker access\n            this._markerCache = {};\n            // cache of default markup nodes\n            this._V = {};\n            // connection path metrics\n            this.cleanNodesCache();\n        },\n        presentationAttributes: {\n            markup: [\n                Flags$2.RENDER\n            ],\n            attrs: [\n                Flags$2.UPDATE\n            ],\n            router: [\n                Flags$2.UPDATE\n            ],\n            connector: [\n                Flags$2.CONNECTOR\n            ],\n            smooth: [\n                Flags$2.UPDATE\n            ],\n            manhattan: [\n                Flags$2.UPDATE\n            ],\n            toolMarkup: [\n                Flags$2.LEGACY_TOOLS\n            ],\n            labels: [\n                Flags$2.LABELS\n            ],\n            labelMarkup: [\n                Flags$2.LABELS\n            ],\n            vertices: [\n                Flags$2.VERTICES,\n                Flags$2.UPDATE\n            ],\n            vertexMarkup: [\n                Flags$2.VERTICES\n            ],\n            source: [\n                Flags$2.SOURCE,\n                Flags$2.UPDATE\n            ],\n            target: [\n                Flags$2.TARGET,\n                Flags$2.UPDATE\n            ]\n        },\n        initFlag: [\n            Flags$2.RENDER,\n            Flags$2.SOURCE,\n            Flags$2.TARGET,\n            Flags$2.TOOLS\n        ],\n        UPDATE_PRIORITY: 1,\n        confirmUpdate: function(flags, opt) {\n            opt || (opt = {});\n            if (this.hasFlag(flags, Flags$2.SOURCE)) {\n                if (!this.updateEndProperties(\"source\")) return flags;\n                flags = this.removeFlag(flags, Flags$2.SOURCE);\n            }\n            if (this.hasFlag(flags, Flags$2.TARGET)) {\n                if (!this.updateEndProperties(\"target\")) return flags;\n                flags = this.removeFlag(flags, Flags$2.TARGET);\n            }\n            var ref = this;\n            var paper = ref.paper;\n            var sourceView = ref.sourceView;\n            var targetView = ref.targetView;\n            if (paper && (sourceView && !paper.isViewMounted(sourceView) || targetView && !paper.isViewMounted(targetView))) // Wait for the sourceView and targetView to be rendered\n            return flags;\n            if (this.hasFlag(flags, Flags$2.RENDER)) {\n                this.render();\n                this.updateHighlighters(true);\n                this.updateTools(opt);\n                flags = this.removeFlag(flags, [\n                    Flags$2.RENDER,\n                    Flags$2.UPDATE,\n                    Flags$2.VERTICES,\n                    Flags$2.LABELS,\n                    Flags$2.TOOLS,\n                    Flags$2.LEGACY_TOOLS,\n                    Flags$2.CONNECTOR\n                ]);\n                return flags;\n            }\n            var updateHighlighters = false;\n            if (this.hasFlag(flags, Flags$2.VERTICES)) {\n                this.renderVertexMarkers();\n                flags = this.removeFlag(flags, Flags$2.VERTICES);\n            }\n            var ref$1 = this;\n            var model = ref$1.model;\n            var attributes = model.attributes;\n            var updateLabels = this.hasFlag(flags, Flags$2.LABELS);\n            var updateLegacyTools = this.hasFlag(flags, Flags$2.LEGACY_TOOLS);\n            if (updateLabels) {\n                this.onLabelsChange(model, attributes.labels, opt);\n                flags = this.removeFlag(flags, Flags$2.LABELS);\n                updateHighlighters = true;\n            }\n            if (updateLegacyTools) {\n                this.renderTools();\n                flags = this.removeFlag(flags, Flags$2.LEGACY_TOOLS);\n            }\n            var updateAll = this.hasFlag(flags, Flags$2.UPDATE);\n            var updateConnector = this.hasFlag(flags, Flags$2.CONNECTOR);\n            if (updateAll || updateConnector) {\n                if (!updateAll) {\n                    // Keep the current route and update the geometry\n                    this.updatePath();\n                    this.updateDOM();\n                } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) // The link is being translated by an ancestor that will\n                // shift source point, target point and all vertices\n                // by an equal distance.\n                this.translate(opt.tx, opt.ty);\n                else this.update();\n                this.updateTools(opt);\n                flags = this.removeFlag(flags, [\n                    Flags$2.UPDATE,\n                    Flags$2.TOOLS,\n                    Flags$2.CONNECTOR\n                ]);\n                updateLabels = false;\n                updateLegacyTools = false;\n                updateHighlighters = true;\n            }\n            if (updateLabels) this.updateLabelPositions();\n            if (updateLegacyTools) this.updateToolsPosition();\n            if (updateHighlighters) this.updateHighlighters();\n            if (this.hasFlag(flags, Flags$2.TOOLS)) {\n                this.updateTools(opt);\n                flags = this.removeFlag(flags, Flags$2.TOOLS);\n            }\n            return flags;\n        },\n        requestConnectionUpdate: function(opt) {\n            this.requestUpdate(this.getFlag(Flags$2.UPDATE), opt);\n        },\n        isLabelsRenderRequired: function(opt) {\n            if (opt === void 0) opt = {};\n            var previousLabels = this.model.previous(\"labels\");\n            if (!previousLabels) return true;\n            // Here is an optimization for cases when we know, that change does\n            // not require re-rendering of all labels.\n            if (\"propertyPathArray\" in opt && \"propertyValue\" in opt) {\n                // The label is setting by `prop()` method\n                var pathArray = opt.propertyPathArray || [];\n                var pathLength = pathArray.length;\n                if (pathLength > 1) {\n                    // We are changing a single label here e.g. 'labels/0/position'\n                    var labelExists = !!previousLabels[pathArray[1]];\n                    if (labelExists) {\n                        if (pathLength === 2) // We are changing the entire label. Need to check if the\n                        // markup is also being changed.\n                        return \"markup\" in Object(opt.propertyValue);\n                        else if (pathArray[2] !== \"markup\") // We are changing a label property but not the markup\n                        return false;\n                    }\n                }\n            }\n            return true;\n        },\n        onLabelsChange: function(_link, _labels, opt) {\n            // Note: this optimization works in async=false mode only\n            if (this.isLabelsRenderRequired(opt)) this.renderLabels();\n            else this.updateLabels();\n        },\n        // Rendering.\n        // ----------\n        render: function() {\n            this.vel.empty();\n            this.unmountLabels();\n            this._V = {};\n            this.renderMarkup();\n            // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n            // returns zero values)\n            this.renderLabels();\n            this.update();\n            return this;\n        },\n        renderMarkup: function() {\n            var link = this.model;\n            var markup = link.get(\"markup\") || link.markup;\n            if (!markup) throw new Error(\"dia.LinkView: markup required\");\n            if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n            if (typeof markup === \"string\") return this.renderStringMarkup(markup);\n            throw new Error(\"dia.LinkView: invalid markup\");\n        },\n        renderJSONMarkup: function(markup) {\n            var doc = this.parseDOMJSON(markup, this.el);\n            // Selectors\n            this.selectors = doc.selectors;\n            // Fragment\n            this.vel.append(doc.fragment);\n        },\n        renderStringMarkup: function(markup) {\n            // A special markup can be given in the `properties.markup` property. This might be handy\n            // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n            // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n            // of elements with special meaning though. Therefore, those classes should be preserved in any\n            // special markup passed in `properties.markup`.\n            var children = V(markup);\n            // custom markup may contain only one children\n            if (!Array.isArray(children)) children = [\n                children\n            ];\n            // Cache all children elements for quicker access.\n            var cache = this._V; // vectorized markup;\n            for(var i = 0, n = children.length; i < n; i++){\n                var child = children[i];\n                var className = child.attr(\"class\");\n                if (className) {\n                    // Strip the joint class name prefix, if there is one.\n                    className = removeClassNamePrefix(className);\n                    cache[$.camelCase(className)] = child;\n                }\n            }\n            // partial rendering\n            this.renderTools();\n            this.renderVertexMarkers();\n            this.renderArrowheadMarkers();\n            this.vel.append(children);\n        },\n        _getLabelMarkup: function(labelMarkup) {\n            if (!labelMarkup) return undefined;\n            if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n            if (typeof labelMarkup === \"string\") return this._getLabelStringMarkup(labelMarkup);\n            throw new Error(\"dia.linkView: invalid label markup\");\n        },\n        _getLabelStringMarkup: function(labelMarkup) {\n            var children = V(labelMarkup);\n            var fragment = document.createDocumentFragment();\n            if (!Array.isArray(children)) fragment.appendChild(children.node);\n            else for(var i = 0, n = children.length; i < n; i++){\n                var currentChild = children[i].node;\n                fragment.appendChild(currentChild);\n            }\n            return {\n                fragment: fragment,\n                selectors: {}\n            }; // no selectors\n        },\n        // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n        // If it doesn't, add the <g /> container here.\n        _normalizeLabelMarkup: function(markup) {\n            if (!markup) return undefined;\n            var fragment = markup.fragment;\n            if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error(\"dia.LinkView: invalid label markup.\");\n            var vNode;\n            var childNodes = fragment.childNodes;\n            if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== \"G\") // default markup fragment is not wrapped in <g />\n            // add a <g /> container\n            vNode = V(\"g\").append(fragment);\n            else vNode = V(childNodes[0]);\n            vNode.addClass(\"label\");\n            return {\n                node: vNode.node,\n                selectors: markup.selectors\n            };\n        },\n        renderLabels: function() {\n            var cache = this._V;\n            var vLabels = cache.labels;\n            var labelCache = this._labelCache = {};\n            var labelSelectors = this._labelSelectors = {};\n            var model = this.model;\n            var labels = model.attributes.labels || [];\n            var labelsCount = labels.length;\n            if (labelsCount === 0) {\n                if (vLabels) vLabels.remove();\n                return this;\n            }\n            if (vLabels) vLabels.empty();\n            else {\n                // there is no label container in the markup but some labels are defined\n                // add a <g class=\"labels\" /> container\n                vLabels = cache.labels = V(\"g\").addClass(\"labels\");\n                if (this.options.labelsLayer) {\n                    vLabels.addClass(addClassNamePrefix(result(this, \"className\")));\n                    vLabels.attr(\"model-id\", model.id);\n                }\n            }\n            for(var i = 0; i < labelsCount; i++){\n                var label = labels[i];\n                var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n                var labelNode;\n                var selectors;\n                if (labelMarkup) {\n                    labelNode = labelMarkup.node;\n                    selectors = labelMarkup.selectors;\n                } else {\n                    var builtinDefaultLabel = model._builtins.defaultLabel;\n                    var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n                    var defaultLabel = model._getDefaultLabel();\n                    var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n                    var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n                    labelNode = defaultMarkup.node;\n                    selectors = defaultMarkup.selectors;\n                }\n                labelNode.setAttribute(\"label-idx\", i); // assign label-idx\n                vLabels.append(labelNode);\n                labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n                var rootSelector = this.selector;\n                if (selectors[rootSelector]) throw new Error(\"dia.LinkView: ambiguous label root selector.\");\n                selectors[rootSelector] = labelNode;\n                labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n            }\n            if (!vLabels.parent()) this.mountLabels();\n            this.updateLabels();\n            return this;\n        },\n        mountLabels: function() {\n            var ref = this;\n            var el = ref.el;\n            var paper = ref.paper;\n            var model = ref.model;\n            var _V = ref._V;\n            var options = ref.options;\n            var vLabels = _V.labels;\n            if (!vLabels || !model.hasLabels()) return;\n            var node = vLabels.node;\n            if (options.labelsLayer) paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get(\"z\"));\n            else if (node.parentNode !== el) el.appendChild(node);\n        },\n        unmountLabels: function() {\n            var ref = this;\n            var options = ref.options;\n            var _V = ref._V;\n            if (!_V) return;\n            var vLabels = _V.labels;\n            if (vLabels && options.labelsLayer) vLabels.remove();\n        },\n        findLabelNode: function(labelIndex, selector) {\n            var labelRoot = this._labelCache[labelIndex];\n            if (!labelRoot) return null;\n            var labelSelectors = this._labelSelectors[labelIndex];\n            var ref = this.findBySelector(selector, labelRoot, labelSelectors);\n            var node = ref[0];\n            if (node === void 0) node = null;\n            return node;\n        },\n        // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)\n        // keep `undefined` or `null` because `{}` means something else\n        _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n            if (labelAttrs === null) return null;\n            if (labelAttrs === undefined) {\n                if (defaultLabelAttrs === null) return null;\n                if (defaultLabelAttrs === undefined) {\n                    if (hasCustomMarkup) return undefined;\n                    return builtinDefaultLabelAttrs;\n                }\n                if (hasCustomMarkup) return defaultLabelAttrs;\n                return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n            }\n            if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);\n            return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n        },\n        // merge default label size into label size (no built-in default)\n        // keep `undefined` or `null` because `{}` means something else\n        _mergeLabelSize: function(labelSize, defaultLabelSize) {\n            if (labelSize === null) return null;\n            if (labelSize === undefined) {\n                if (defaultLabelSize === null) return null;\n                if (defaultLabelSize === undefined) return undefined;\n                return defaultLabelSize;\n            }\n            return merge({}, defaultLabelSize, labelSize);\n        },\n        updateLabels: function() {\n            if (!this._V.labels) return this;\n            var model = this.model;\n            var labels = model.get(\"labels\") || [];\n            var canLabelMove = this.can(\"labelMove\");\n            var builtinDefaultLabel = model._builtins.defaultLabel;\n            var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n            var defaultLabel = model._getDefaultLabel();\n            var defaultLabelMarkup = defaultLabel.markup;\n            var defaultLabelAttrs = defaultLabel.attrs;\n            var defaultLabelSize = defaultLabel.size;\n            for(var i = 0, n = labels.length; i < n; i++){\n                var labelNode = this._labelCache[i];\n                labelNode.setAttribute(\"cursor\", canLabelMove ? \"move\" : \"default\");\n                var selectors = this._labelSelectors[i];\n                var label = labels[i];\n                var labelMarkup = label.markup;\n                var labelAttrs = label.attrs;\n                var labelSize = label.size;\n                var attrs = this._mergeLabelAttrs(labelMarkup || defaultLabelMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs);\n                var size = this._mergeLabelSize(labelSize, defaultLabelSize);\n                this.updateDOMSubtreeAttributes(labelNode, attrs, {\n                    rootBBox: new Rect(size),\n                    selectors: selectors\n                });\n            }\n            return this;\n        },\n        renderTools: function() {\n            if (!this._V.linkTools) return this;\n            // Tools are a group of clickable elements that manipulate the whole link.\n            // A good example of this is the remove tool that removes the whole link.\n            // Tools appear after hovering the link close to the `source` element/point of the link\n            // but are offset a bit so that they don't cover the `marker-arrowhead`.\n            var $tools = $(this._V.linkTools.node).empty();\n            var toolTemplate = template(this.model.get(\"toolMarkup\") || this.model.toolMarkup);\n            var tool = V(toolTemplate());\n            $tools.append(tool.node);\n            // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.\n            this._toolCache = tool;\n            // If `doubleLinkTools` is enabled, we render copy of the tools on the other side of the\n            // link as well but only if the link is longer than `longLinkLength`.\n            if (this.options.doubleLinkTools) {\n                var tool2;\n                if (this.model.get(\"doubleToolMarkup\") || this.model.doubleToolMarkup) {\n                    toolTemplate = template(this.model.get(\"doubleToolMarkup\") || this.model.doubleToolMarkup);\n                    tool2 = V(toolTemplate());\n                } else tool2 = tool.clone();\n                $tools.append(tool2.node);\n                this._tool2Cache = tool2;\n            }\n            return this;\n        },\n        renderVertexMarkers: function() {\n            if (!this._V.markerVertices) return this;\n            var $markerVertices = $(this._V.markerVertices.node).empty();\n            // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n            // if default styling (elements) are not desired. This makes it possible to use any\n            // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n            var markupTemplate = template(this.model.get(\"vertexMarkup\") || this.model.vertexMarkup);\n            this.model.vertices().forEach(function(vertex, idx) {\n                $markerVertices.append(V(markupTemplate(assign({\n                    idx: idx\n                }, vertex))).node);\n            });\n            return this;\n        },\n        renderArrowheadMarkers: function() {\n            // Custom markups might not have arrowhead markers. Therefore, jump of this function immediately if that's the case.\n            if (!this._V.markerArrowheads) return this;\n            var $markerArrowheads = $(this._V.markerArrowheads.node);\n            $markerArrowheads.empty();\n            // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n            // if default styling (elements) are not desired. This makes it possible to use any\n            // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n            var markupTemplate = template(this.model.get(\"arrowheadMarkup\") || this.model.arrowheadMarkup);\n            this._V.sourceArrowhead = V(markupTemplate({\n                end: \"source\"\n            }));\n            this._V.targetArrowhead = V(markupTemplate({\n                end: \"target\"\n            }));\n            $markerArrowheads.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node);\n            return this;\n        },\n        // remove vertices that lie on (or nearly on) straight lines within the link\n        // return the number of removed points\n        removeRedundantLinearVertices: function(opt) {\n            var SIMPLIFY_THRESHOLD = 0.001;\n            var link = this.model;\n            var vertices = link.vertices();\n            var routePoints = [\n                this.sourceAnchor\n            ].concat(vertices, [\n                this.targetAnchor\n            ]);\n            var numRoutePoints = routePoints.length;\n            // put routePoints into a polyline and try to simplify\n            var polyline = new Polyline(routePoints);\n            polyline.simplify({\n                threshold: SIMPLIFY_THRESHOLD\n            });\n            var polylinePoints = polyline.points.map(function(point) {\n                return point.toJSON();\n            }); // JSON of points after simplification\n            var numPolylinePoints = polylinePoints.length; // number of points after simplification\n            // shortcut if simplification did not remove any redundant vertices:\n            if (numRoutePoints === numPolylinePoints) return 0;\n            // else: set simplified polyline points as link vertices\n            // remove first and last polyline points again (= source/target anchors)\n            link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n            return numRoutePoints - numPolylinePoints;\n        },\n        updateDefaultConnectionPath: function() {\n            var cache = this._V;\n            if (cache.connection) cache.connection.attr(\"d\", this.getSerializedConnection());\n            if (cache.connectionWrap) cache.connectionWrap.attr(\"d\", this.getSerializedConnection());\n            if (cache.markerSource && cache.markerTarget) this._translateAndAutoOrientArrows(cache.markerSource, cache.markerTarget);\n        },\n        getEndView: function(type) {\n            switch(type){\n                case \"source\":\n                    return this.sourceView || null;\n                case \"target\":\n                    return this.targetView || null;\n                default:\n                    throw new Error(\"dia.LinkView: type parameter required.\");\n            }\n        },\n        getEndAnchor: function(type) {\n            switch(type){\n                case \"source\":\n                    return new Point(this.sourceAnchor);\n                case \"target\":\n                    return new Point(this.targetAnchor);\n                default:\n                    throw new Error(\"dia.LinkView: type parameter required.\");\n            }\n        },\n        getEndConnectionPoint: function(type) {\n            switch(type){\n                case \"source\":\n                    return new Point(this.sourcePoint);\n                case \"target\":\n                    return new Point(this.targetPoint);\n                default:\n                    throw new Error(\"dia.LinkView: type parameter required.\");\n            }\n        },\n        getEndMagnet: function(type) {\n            switch(type){\n                case \"source\":\n                    var sourceView = this.sourceView;\n                    if (!sourceView) break;\n                    return this.sourceMagnet || sourceView.el;\n                case \"target\":\n                    var targetView = this.targetView;\n                    if (!targetView) break;\n                    return this.targetMagnet || targetView.el;\n                default:\n                    throw new Error(\"dia.LinkView: type parameter required.\");\n            }\n            return null;\n        },\n        // Updating.\n        // ---------\n        update: function() {\n            this.updateRoute();\n            this.updatePath();\n            this.updateDOM();\n            return this;\n        },\n        translate: function(tx, ty) {\n            if (tx === void 0) tx = 0;\n            if (ty === void 0) ty = 0;\n            var ref = this;\n            var route = ref.route;\n            var path = ref.path;\n            if (!route || !path) return;\n            // translate the route\n            var polyline = new Polyline(route);\n            polyline.translate(tx, ty);\n            this.route = polyline.points;\n            // translate source and target connection and marker points.\n            this._translateConnectionPoints(tx, ty);\n            // translate the geometry path\n            path.translate(tx, ty);\n            this.updateDOM();\n        },\n        updateDOM: function updateDOM() {\n            var ref = this;\n            var el = ref.el;\n            var model = ref.model;\n            var selectors = ref.selectors;\n            this.cleanNodesCache();\n            // update SVG attributes defined by 'attrs/'.\n            this.updateDOMSubtreeAttributes(el, model.attr(), {\n                selectors: selectors\n            });\n            // legacy link path update\n            this.updateDefaultConnectionPath();\n            // update the label position etc.\n            this.updateLabelPositions();\n            this.updateToolsPosition();\n            this.updateArrowheadMarkers();\n            // *Deprecated*\n            // Local perpendicular flag (as opposed to one defined on paper).\n            // Could be enabled inside a connector/router. It's valid only\n            // during the update execution.\n            this.options.perpendicular = null;\n        },\n        updateRoute: function() {\n            var ref = this;\n            var model = ref.model;\n            var vertices = model.vertices();\n            // 1. Find Anchors\n            var anchors = this.findAnchors(vertices);\n            var sourceAnchor = this.sourceAnchor = anchors.source;\n            var targetAnchor = this.targetAnchor = anchors.target;\n            // 2. Find Route\n            var route = this.findRoute(vertices);\n            this.route = route;\n            // 3. Find Connection Points\n            var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n            this.sourcePoint = connectionPoints.source;\n            this.targetPoint = connectionPoints.target;\n        },\n        updatePath: function() {\n            var ref = this;\n            var route = ref.route;\n            var sourcePoint = ref.sourcePoint;\n            var targetPoint = ref.targetPoint;\n            // 3b. Find Marker Connection Point - Backwards Compatibility\n            var markerPoints = this.findMarkerPoints(route, sourcePoint, targetPoint);\n            // 4. Find Connection\n            var path = this.findPath(route, markerPoints.source || sourcePoint, markerPoints.target || targetPoint);\n            this.path = path;\n        },\n        findMarkerPoints: function(route, sourcePoint, targetPoint) {\n            var firstWaypoint = route[0];\n            var lastWaypoint = route[route.length - 1];\n            // Move the source point by the width of the marker taking into account\n            // its scale around x-axis. Note that scale is the only transform that\n            // makes sense to be set in `.marker-source` attributes object\n            // as all other transforms (translate/rotate) will be replaced\n            // by the `translateAndAutoOrient()` function.\n            var cache = this._markerCache;\n            // cache source and target points\n            var sourceMarkerPoint, targetMarkerPoint;\n            if (this._V.markerSource) {\n                cache.sourceBBox = cache.sourceBBox || this._V.markerSource.getBBox();\n                sourceMarkerPoint = Point(sourcePoint).move(firstWaypoint || targetPoint, cache.sourceBBox.width * this._V.markerSource.scale().sx * -1).round();\n            }\n            if (this._V.markerTarget) {\n                cache.targetBBox = cache.targetBBox || this._V.markerTarget.getBBox();\n                targetMarkerPoint = Point(targetPoint).move(lastWaypoint || sourcePoint, cache.targetBBox.width * this._V.markerTarget.scale().sx * -1).round();\n            }\n            // if there was no markup for the marker, use the connection point.\n            cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n            cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n            return {\n                source: sourceMarkerPoint,\n                target: targetMarkerPoint\n            };\n        },\n        findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {\n            var firstAnchor, secondAnchor;\n            var firstAnchorRef, secondAnchorRef;\n            var model = this.model;\n            var firstDef = model.get(firstEndType);\n            var secondDef = model.get(secondEndType);\n            var firstView = this.getEndView(firstEndType);\n            var secondView = this.getEndView(secondEndType);\n            var firstMagnet = this.getEndMagnet(firstEndType);\n            var secondMagnet = this.getEndMagnet(secondEndType);\n            // Anchor first\n            if (firstView) {\n                if (firstRef) firstAnchorRef = new Point(firstRef);\n                else if (secondView) firstAnchorRef = secondMagnet;\n                else firstAnchorRef = new Point(secondDef);\n                firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n            } else firstAnchor = new Point(firstDef);\n            // Anchor second\n            if (secondView) {\n                secondAnchorRef = new Point(secondRef || firstAnchor);\n                secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n            } else secondAnchor = new Point(secondDef);\n            var res = {};\n            res[firstEndType] = firstAnchor;\n            res[secondEndType] = secondAnchor;\n            return res;\n        },\n        findAnchors: function(vertices) {\n            var model = this.model;\n            var firstVertex = vertices[0];\n            var lastVertex = vertices[vertices.length - 1];\n            if (model.target().priority && !model.source().priority) // Reversed order\n            return this.findAnchorsOrdered(\"target\", lastVertex, \"source\", firstVertex);\n            // Usual order\n            return this.findAnchorsOrdered(\"source\", firstVertex, \"target\", lastVertex);\n        },\n        findConnectionPoints: function(route, sourceAnchor, targetAnchor) {\n            var firstWaypoint = route[0];\n            var lastWaypoint = route[route.length - 1];\n            var model = this.model;\n            var sourceDef = model.get(\"source\");\n            var targetDef = model.get(\"target\");\n            var sourceView = this.sourceView;\n            var targetView = this.targetView;\n            var paperOptions = this.paper.options;\n            var sourceMagnet, targetMagnet;\n            // Connection Point Source\n            var sourcePoint;\n            if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n                sourceMagnet = this.sourceMagnet || sourceView.el;\n                var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n                var sourcePointRef = firstWaypoint || targetAnchor;\n                var sourceLine = new Line(sourcePointRef, sourceAnchor);\n                sourcePoint = this.getConnectionPoint(sourceConnectionPointDef, sourceView, sourceMagnet, sourceLine, \"source\");\n            } else sourcePoint = sourceAnchor;\n            // Connection Point Target\n            var targetPoint;\n            if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n                targetMagnet = this.targetMagnet || targetView.el;\n                var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n                var targetPointRef = lastWaypoint || sourceAnchor;\n                var targetLine = new Line(targetPointRef, targetAnchor);\n                targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, \"target\");\n            } else targetPoint = targetAnchor;\n            return {\n                source: sourcePoint,\n                target: targetPoint\n            };\n        },\n        getAnchor: function(anchorDef, cellView, magnet, ref, endType) {\n            var isConnection = cellView.isNodeConnection(magnet);\n            var paperOptions = this.paper.options;\n            if (!anchorDef) {\n                if (isConnection) anchorDef = paperOptions.defaultLinkAnchor;\n                else if (paperOptions.perpendicularLinks || this.options.perpendicular) // Backwards compatibility\n                // If `perpendicularLinks` flag is set on the paper and there are vertices\n                // on the link, then try to find a connection point that makes the link perpendicular\n                // even though the link won't point to the center of the targeted object.\n                anchorDef = {\n                    name: \"perpendicular\"\n                };\n                else anchorDef = paperOptions.defaultAnchor;\n            }\n            if (!anchorDef) throw new Error(\"Anchor required.\");\n            var anchorFn;\n            if (typeof anchorDef === \"function\") anchorFn = anchorDef;\n            else {\n                var anchorName = anchorDef.name;\n                var anchorNamespace = isConnection ? \"linkAnchorNamespace\" : \"anchorNamespace\";\n                anchorFn = paperOptions[anchorNamespace][anchorName];\n                if (typeof anchorFn !== \"function\") throw new Error(\"Unknown anchor: \" + anchorName);\n            }\n            var anchor = anchorFn.call(this, cellView, magnet, ref, anchorDef.args || {}, endType, this);\n            if (!anchor) return new Point();\n            return anchor.round(this.decimalsRounding);\n        },\n        getConnectionPoint: function(connectionPointDef, view, magnet, line, endType) {\n            var connectionPoint;\n            var anchor = line.end;\n            var paperOptions = this.paper.options;\n            // Backwards compatibility\n            if (typeof paperOptions.linkConnectionPoint === \"function\") {\n                var linkConnectionMagnet = magnet === view.el ? undefined : magnet;\n                connectionPoint = paperOptions.linkConnectionPoint(this, view, linkConnectionMagnet, line.start, endType);\n                if (connectionPoint) return connectionPoint;\n            }\n            if (!connectionPointDef) return anchor;\n            var connectionPointFn;\n            if (typeof connectionPointDef === \"function\") connectionPointFn = connectionPointDef;\n            else {\n                var connectionPointName = connectionPointDef.name;\n                connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n                if (typeof connectionPointFn !== \"function\") throw new Error(\"Unknown connection point: \" + connectionPointName);\n            }\n            connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n            if (!connectionPoint) return anchor;\n            return connectionPoint.round(this.decimalsRounding);\n        },\n        _translateConnectionPoints: function(tx, ty) {\n            var cache = this._markerCache;\n            cache.sourcePoint.offset(tx, ty);\n            cache.targetPoint.offset(tx, ty);\n            this.sourcePoint.offset(tx, ty);\n            this.targetPoint.offset(tx, ty);\n            this.sourceAnchor.offset(tx, ty);\n            this.targetAnchor.offset(tx, ty);\n        },\n        // combine default label position with built-in default label position\n        _getDefaultLabelPositionProperty: function() {\n            var model = this.model;\n            var builtinDefaultLabel = model._builtins.defaultLabel;\n            var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n            var defaultLabel = model._getDefaultLabel();\n            var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n            return merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n        },\n        // if label position is a number, normalize it to a position object\n        // this makes sure that label positions can be merged properly\n        _normalizeLabelPosition: function(labelPosition) {\n            if (typeof labelPosition === \"number\") return {\n                distance: labelPosition,\n                offset: null,\n                angle: 0,\n                args: null\n            };\n            return labelPosition;\n        },\n        // expects normalized position properties\n        // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`\n        _mergeLabelPositionProperty: function(normalizedLabelPosition, normalizedDefaultLabelPosition) {\n            if (normalizedLabelPosition === null) return null;\n            if (normalizedLabelPosition === undefined) {\n                if (normalizedDefaultLabelPosition === null) return null;\n                return normalizedDefaultLabelPosition;\n            }\n            return merge({}, normalizedDefaultLabelPosition, normalizedLabelPosition);\n        },\n        updateLabelPositions: function() {\n            if (!this._V.labels) return this;\n            var path = this.path;\n            if (!path) return this;\n            // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n            // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n            var model = this.model;\n            var labels = model.get(\"labels\") || [];\n            if (!labels.length) return this;\n            var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n            for(var idx = 0, n = labels.length; idx < n; idx++){\n                var labelNode = this._labelCache[idx];\n                if (!labelNode) continue;\n                var label = labels[idx];\n                var labelPosition = this._normalizeLabelPosition(label.position);\n                var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);\n                var transformationMatrix = this._getLabelTransformationMatrix(position);\n                labelNode.setAttribute(\"transform\", V.matrixToTransformString(transformationMatrix));\n                this._cleanLabelMatrices(idx);\n            }\n            return this;\n        },\n        _cleanLabelMatrices: function(index) {\n            // Clean magnetMatrix for all nodes of the label.\n            // Cached BoundingRect does not need to updated when the position changes\n            // TODO: this doesn't work for labels with XML String markups.\n            var ref = this;\n            var metrics = ref.metrics;\n            var _labelSelectors = ref._labelSelectors;\n            var selectors = _labelSelectors[index];\n            if (!selectors) return;\n            for(var selector in selectors){\n                var ref$1 = selectors[selector];\n                var id = ref$1.id;\n                if (id && id in metrics) delete metrics[id].magnetMatrix;\n            }\n        },\n        updateToolsPosition: function() {\n            if (!this._V.linkTools) return this;\n            // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.\n            // Note that the offset is hardcoded here. The offset should be always\n            // more than the `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n            // this up all the time would be slow.\n            var scale = \"\";\n            var offset = this.options.linkToolsOffset;\n            var connectionLength = this.getConnectionLength();\n            // Firefox returns connectionLength=NaN in odd cases (for bezier curves).\n            // In that case we won't update tools position at all.\n            if (!Number.isNaN(connectionLength)) {\n                // If the link is too short, make the tools half the size and the offset twice as low.\n                if (connectionLength < this.options.shortLinkLength) {\n                    scale = \"scale(.5)\";\n                    offset /= 2;\n                }\n                var toolPosition = this.getPointAtLength(offset);\n                this._toolCache.attr(\"transform\", \"translate(\" + toolPosition.x + \", \" + toolPosition.y + \") \" + scale);\n                if (this.options.doubleLinkTools && connectionLength >= this.options.longLinkLength) {\n                    var doubleLinkToolsOffset = this.options.doubleLinkToolsOffset || offset;\n                    toolPosition = this.getPointAtLength(connectionLength - doubleLinkToolsOffset);\n                    this._tool2Cache.attr(\"transform\", \"translate(\" + toolPosition.x + \", \" + toolPosition.y + \") \" + scale);\n                    this._tool2Cache.attr(\"visibility\", \"visible\");\n                } else if (this.options.doubleLinkTools) this._tool2Cache.attr(\"visibility\", \"hidden\");\n            }\n            return this;\n        },\n        updateArrowheadMarkers: function() {\n            if (!this._V.markerArrowheads) return this;\n            // getting bbox of an element with `display=\"none\"` in IE9 ends up with access violation\n            if ($.css(this._V.markerArrowheads.node, \"display\") === \"none\") return this;\n            var sx = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;\n            this._V.sourceArrowhead.scale(sx);\n            this._V.targetArrowhead.scale(sx);\n            this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead);\n            return this;\n        },\n        updateEndProperties: function(endType) {\n            var ref = this;\n            var model = ref.model;\n            var paper = ref.paper;\n            var endViewProperty = endType + \"View\";\n            var endDef = model.get(endType);\n            var endId = endDef && endDef.id;\n            if (!endId) {\n                // the link end is a point ~ rect 0x0\n                this[endViewProperty] = null;\n                this.updateEndMagnet(endType);\n                return true;\n            }\n            var endModel = paper.getModelById(endId);\n            if (!endModel) throw new Error(\"LinkView: invalid \" + endType + \" cell.\");\n            var endView = endModel.findView(paper);\n            if (!endView) // A view for a model should always exist\n            return false;\n            this[endViewProperty] = endView;\n            this.updateEndMagnet(endType);\n            return true;\n        },\n        updateEndMagnet: function(endType) {\n            var endMagnetProperty = endType + \"Magnet\";\n            var endView = this.getEndView(endType);\n            if (endView) {\n                var connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n                if (connectedMagnet === endView.el) connectedMagnet = null;\n                this[endMagnetProperty] = connectedMagnet;\n            } else this[endMagnetProperty] = null;\n        },\n        _translateAndAutoOrientArrows: function(sourceArrow, targetArrow) {\n            // Make the markers \"point\" to their sticky points being auto-oriented towards\n            // `targetPosition`/`sourcePosition`. And do so only if there is a markup for them.\n            var route = toArray(this.route);\n            if (sourceArrow) sourceArrow.translateAndAutoOrient(this.sourcePoint, route[0] || this.targetPoint, this.paper.cells);\n            if (targetArrow) targetArrow.translateAndAutoOrient(this.targetPoint, route[route.length - 1] || this.sourcePoint, this.paper.cells);\n        },\n        _getLabelPositionProperty: function(idx) {\n            return this.model.label(idx).position || {};\n        },\n        _getLabelPositionAngle: function(idx) {\n            var labelPosition = this._getLabelPositionProperty(idx);\n            return labelPosition.angle || 0;\n        },\n        _getLabelPositionArgs: function(idx) {\n            var labelPosition = this._getLabelPositionProperty(idx);\n            return labelPosition.args;\n        },\n        _getDefaultLabelPositionArgs: function() {\n            var defaultLabel = this.model._getDefaultLabel();\n            var defaultLabelPosition = defaultLabel.position || {};\n            return defaultLabelPosition.args;\n        },\n        // merge default label position args into label position args\n        // keep `undefined` or `null` because `{}` means something else\n        _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {\n            if (labelPositionArgs === null) return null;\n            if (labelPositionArgs === undefined) {\n                if (defaultLabelPositionArgs === null) return null;\n                return defaultLabelPositionArgs;\n            }\n            return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n        },\n        // Add default label at given position at end of `labels` array.\n        // Four signatures:\n        // - obj, obj = point, opt\n        // - obj, num, obj = point, angle, opt\n        // - num, num, obj = x, y, opt\n        // - num, num, num, obj = x, y, angle, opt\n        // Assigns relative coordinates by default:\n        // `opt.absoluteDistance` forces absolute coordinates.\n        // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n        // `opt.absoluteOffset` forces absolute coordinates for offset.\n        // Additional args:\n        // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n        // `opt.ensureLegibility` rotates labels so they are never upside-down.\n        addLabel: function(p1, p2, p3, p4) {\n            // normalize data from the four possible signatures\n            var localX;\n            var localY;\n            var localAngle = 0;\n            var localOpt;\n            if (typeof p1 !== \"number\") {\n                // {x, y} object provided as first parameter\n                localX = p1.x;\n                localY = p1.y;\n                if (typeof p2 === \"number\") {\n                    // angle and opt provided as second and third parameters\n                    localAngle = p2;\n                    localOpt = p3;\n                } else // opt provided as second parameter\n                localOpt = p2;\n            } else {\n                // x and y provided as first and second parameters\n                localX = p1;\n                localY = p2;\n                if (typeof p3 === \"number\") {\n                    // angle and opt provided as third and fourth parameters\n                    localAngle = p3;\n                    localOpt = p4;\n                } else // opt provided as third parameter\n                localOpt = p3;\n            }\n            // merge label position arguments\n            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n            var labelPositionArgs = localOpt;\n            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n            // append label to labels array\n            var label = {\n                position: this.getLabelPosition(localX, localY, localAngle, positionArgs)\n            };\n            var idx = -1;\n            this.model.insertLabel(idx, label, localOpt);\n            return idx;\n        },\n        // Add a new vertex at calculated index to the `vertices` array.\n        addVertex: function(x, y, opt) {\n            // accept input in form `{ x, y }, opt` or `x, y, opt`\n            var isPointProvided = typeof x !== \"number\";\n            var localX = isPointProvided ? x.x : x;\n            var localY = isPointProvided ? x.y : y;\n            var localOpt = isPointProvided ? y : opt;\n            var vertex = {\n                x: localX,\n                y: localY\n            };\n            var idx = this.getVertexIndex(localX, localY);\n            this.model.insertVertex(idx, vertex, localOpt);\n            return idx;\n        },\n        // Send a token (an SVG element, usually a circle) along the connection path.\n        // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n        // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n        // `opt.directon` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n        // `opt.connection` is an optional selector to the connection path.\n        // `callback` is optional and is a function to be called once the token reaches the target.\n        sendToken: function(token, opt, callback) {\n            function onAnimationEnd(vToken, callback) {\n                return function() {\n                    vToken.remove();\n                    if (typeof callback === \"function\") callback();\n                };\n            }\n            var duration, isReversed, selector;\n            if (isObject$1(opt)) {\n                duration = opt.duration;\n                isReversed = opt.direction === \"reverse\";\n                selector = opt.connection;\n            } else {\n                // Backwards compatibility\n                duration = opt;\n                isReversed = false;\n                selector = null;\n            }\n            duration = duration || 1000;\n            var animationAttributes = {\n                dur: duration + \"ms\",\n                repeatCount: 1,\n                calcMode: \"linear\",\n                fill: \"freeze\"\n            };\n            if (isReversed) {\n                animationAttributes.keyPoints = \"1;0\";\n                animationAttributes.keyTimes = \"0;1\";\n            }\n            var vToken = V(token);\n            var connection;\n            if (typeof selector === \"string\") // Use custom connection path.\n            connection = this.findBySelector(selector, this.el, this.selectors)[0];\n            else {\n                // Select connection path automatically.\n                var cache = this._V;\n                connection = cache.connection ? cache.connection.node : this.el.querySelector(\"path\");\n            }\n            if (!(connection instanceof SVGPathElement)) throw new Error(\"dia.LinkView: token animation requires a valid connection path.\");\n            vToken.appendTo(this.paper.cells).animateAlongPath(animationAttributes, connection);\n            setTimeout(onAnimationEnd(vToken, callback), duration);\n        },\n        findRoute: function(vertices) {\n            vertices || (vertices = []);\n            var namespace = this.paper.options.routerNamespace || routers;\n            var router = this.model.router();\n            var defaultRouter = this.paper.options.defaultRouter;\n            if (!router) {\n                if (defaultRouter) router = defaultRouter;\n                else return vertices.map(Point);\n                 // no router specified\n            }\n            var routerFn = isFunction(router) ? router : namespace[router.name];\n            if (!isFunction(routerFn)) throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n            var args = router.args || {};\n            var route = routerFn.call(this, vertices, args, this // linkView\n            );\n            if (!route) return vertices.map(Point);\n            return route;\n        },\n        // Return the `d` attribute value of the `<path>` element representing the link\n        // between `source` and `target`.\n        findPath: function(route, sourcePoint, targetPoint) {\n            var namespace = this.paper.options.connectorNamespace || connectors;\n            var connector = this.model.connector();\n            var defaultConnector = this.paper.options.defaultConnector;\n            if (!connector) connector = defaultConnector || {};\n            var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n            if (!isFunction(connectorFn)) throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n            var args = clone(connector.args || {});\n            args.raw = true; // Request raw g.Path as the result.\n            var path = connectorFn.call(this, sourcePoint, targetPoint, route, args, this // linkView\n            );\n            if (typeof path === \"string\") // Backwards compatibility for connectors not supporting `raw` option.\n            path = new Path(V.normalizePathData(path));\n            return path;\n        },\n        // Public API.\n        // -----------\n        getConnection: function() {\n            var path = this.path;\n            if (!path) return null;\n            return path.clone();\n        },\n        getSerializedConnection: function() {\n            var path = this.path;\n            if (!path) return null;\n            var metrics = this.metrics;\n            if (metrics.hasOwnProperty(\"data\")) return metrics.data;\n            var data = path.serialize();\n            metrics.data = data;\n            return data;\n        },\n        getConnectionSubdivisions: function() {\n            var path = this.path;\n            if (!path) return null;\n            var metrics = this.metrics;\n            if (metrics.hasOwnProperty(\"segmentSubdivisions\")) return metrics.segmentSubdivisions;\n            var subdivisions = path.getSegmentSubdivisions();\n            metrics.segmentSubdivisions = subdivisions;\n            return subdivisions;\n        },\n        getConnectionLength: function() {\n            var path = this.path;\n            if (!path) return 0;\n            var metrics = this.metrics;\n            if (metrics.hasOwnProperty(\"length\")) return metrics.length;\n            var length = path.length({\n                segmentSubdivisions: this.getConnectionSubdivisions()\n            });\n            metrics.length = length;\n            return length;\n        },\n        getPointAtLength: function(length) {\n            var path = this.path;\n            if (!path) return null;\n            return path.pointAtLength(length, {\n                segmentSubdivisions: this.getConnectionSubdivisions()\n            });\n        },\n        getPointAtRatio: function(ratio) {\n            var path = this.path;\n            if (!path) return null;\n            if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;\n            return path.pointAt(ratio, {\n                segmentSubdivisions: this.getConnectionSubdivisions()\n            });\n        },\n        getTangentAtLength: function(length) {\n            var path = this.path;\n            if (!path) return null;\n            return path.tangentAtLength(length, {\n                segmentSubdivisions: this.getConnectionSubdivisions()\n            });\n        },\n        getTangentAtRatio: function(ratio) {\n            var path = this.path;\n            if (!path) return null;\n            return path.tangentAt(ratio, {\n                segmentSubdivisions: this.getConnectionSubdivisions()\n            });\n        },\n        getClosestPoint: function(point) {\n            var path = this.path;\n            if (!path) return null;\n            return path.closestPoint(point, {\n                segmentSubdivisions: this.getConnectionSubdivisions()\n            });\n        },\n        getClosestPointLength: function(point) {\n            var path = this.path;\n            if (!path) return null;\n            return path.closestPointLength(point, {\n                segmentSubdivisions: this.getConnectionSubdivisions()\n            });\n        },\n        getClosestPointRatio: function(point) {\n            var path = this.path;\n            if (!path) return null;\n            return path.closestPointNormalizedLength(point, {\n                segmentSubdivisions: this.getConnectionSubdivisions()\n            });\n        },\n        // Get label position object based on two provided coordinates, x and y.\n        // (Used behind the scenes when user moves labels around.)\n        // Two signatures:\n        // - num, num, obj = x, y, options\n        // - num, num, num, obj = x, y, angle, options\n        // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n        // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n        // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n        getLabelPosition: function(x, y, p3, p4) {\n            var position = {};\n            // normalize data from the two possible signatures\n            var localAngle = 0;\n            var localOpt;\n            if (typeof p3 === \"number\") {\n                // angle and opt provided as third and fourth argument\n                localAngle = p3;\n                localOpt = p4;\n            } else // opt provided as third argument\n            localOpt = p3;\n            // save localOpt as `args` of the position object that is passed along\n            if (localOpt) position.args = localOpt;\n            // identify distance/offset settings\n            var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n            var isDistanceAbsoluteReverse = localOpt && localOpt.absoluteDistance && localOpt.reverseDistance; // non-reverse by default\n            var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n            // find closest point t\n            var path = this.path;\n            var pathOpt = {\n                segmentSubdivisions: this.getConnectionSubdivisions()\n            };\n            var labelPoint = new Point(x, y);\n            var t = path.closestPointT(labelPoint, pathOpt);\n            // DISTANCE:\n            var labelDistance = path.lengthAtT(t, pathOpt);\n            if (isDistanceRelative) labelDistance = labelDistance / this.getConnectionLength() || 0;\n             // fix to prevent NaN for 0 length\n            if (isDistanceAbsoluteReverse) labelDistance = -1 * (this.getConnectionLength() - labelDistance) || 1;\n             // fix for end point (-0 => 1)\n            position.distance = labelDistance;\n            // OFFSET:\n            // use absolute offset if:\n            // - opt.absoluteOffset is true,\n            // - opt.absoluteOffset is not true but there is no tangent\n            var tangent;\n            if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n            var labelOffset;\n            if (tangent) labelOffset = tangent.pointOffset(labelPoint);\n            else {\n                var closestPoint = path.pointAtT(t);\n                var labelOffsetDiff = labelPoint.difference(closestPoint);\n                labelOffset = {\n                    x: labelOffsetDiff.x,\n                    y: labelOffsetDiff.y\n                };\n            }\n            position.offset = labelOffset;\n            // ANGLE:\n            position.angle = localAngle;\n            return position;\n        },\n        _getLabelTransformationMatrix: function(labelPosition) {\n            var labelDistance;\n            var labelAngle = 0;\n            var args = {};\n            if (typeof labelPosition === \"number\") labelDistance = labelPosition;\n            else if (typeof labelPosition.distance === \"number\") {\n                args = labelPosition.args || {};\n                labelDistance = labelPosition.distance;\n                labelAngle = labelPosition.angle || 0;\n            } else throw new Error(\"dia.LinkView: invalid label position distance.\");\n            var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n            var labelOffset = 0;\n            var labelOffsetCoordinates = {\n                x: 0,\n                y: 0\n            };\n            if (labelPosition.offset) {\n                var positionOffset = labelPosition.offset;\n                if (typeof positionOffset === \"number\") labelOffset = positionOffset;\n                if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n                if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n            }\n            var isOffsetAbsolute = labelOffsetCoordinates.x !== 0 || labelOffsetCoordinates.y !== 0 || labelOffset === 0;\n            var isKeepGradient = args.keepGradient;\n            var isEnsureLegibility = args.ensureLegibility;\n            var path = this.path;\n            var pathOpt = {\n                segmentSubdivisions: this.getConnectionSubdivisions()\n            };\n            var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n            var tangent = path.tangentAtLength(distance, pathOpt);\n            var translation;\n            var angle = labelAngle;\n            if (tangent) {\n                if (isOffsetAbsolute) {\n                    translation = tangent.start.clone();\n                    translation.offset(labelOffsetCoordinates);\n                } else {\n                    var normal = tangent.clone();\n                    normal.rotate(tangent.start, -90);\n                    normal.setLength(labelOffset);\n                    translation = normal.end;\n                }\n                if (isKeepGradient) {\n                    angle = tangent.angle() + labelAngle;\n                    if (isEnsureLegibility) angle = normalizeAngle((angle + 90) % 180 - 90);\n                }\n            } else {\n                // fallback - the connection has zero length\n                translation = path.start.clone();\n                if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n            }\n            return V.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n        },\n        getLabelCoordinates: function(labelPosition) {\n            var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n            return new Point(transformationMatrix.e, transformationMatrix.f);\n        },\n        getVertexIndex: function(x, y) {\n            var model = this.model;\n            var vertices = model.vertices();\n            var vertexLength = this.getClosestPointLength(new Point(x, y));\n            var idx = 0;\n            for(var n = vertices.length; idx < n; idx++){\n                var currentVertex = vertices[idx];\n                var currentVertexLength = this.getClosestPointLength(currentVertex);\n                if (vertexLength < currentVertexLength) break;\n            }\n            return idx;\n        },\n        // Interaction. The controller part.\n        // ---------------------------------\n        notifyPointerdown: function notifyPointerdown(evt, x, y) {\n            CellView.prototype.pointerdown.call(this, evt, x, y);\n            this.notify(\"link:pointerdown\", evt, x, y);\n        },\n        notifyPointermove: function notifyPointermove(evt, x, y) {\n            CellView.prototype.pointermove.call(this, evt, x, y);\n            this.notify(\"link:pointermove\", evt, x, y);\n        },\n        notifyPointerup: function notifyPointerup(evt, x, y) {\n            this.notify(\"link:pointerup\", evt, x, y);\n            CellView.prototype.pointerup.call(this, evt, x, y);\n        },\n        pointerdblclick: function(evt, x, y) {\n            CellView.prototype.pointerdblclick.apply(this, arguments);\n            this.notify(\"link:pointerdblclick\", evt, x, y);\n        },\n        pointerclick: function(evt, x, y) {\n            CellView.prototype.pointerclick.apply(this, arguments);\n            this.notify(\"link:pointerclick\", evt, x, y);\n        },\n        contextmenu: function(evt, x, y) {\n            CellView.prototype.contextmenu.apply(this, arguments);\n            this.notify(\"link:contextmenu\", evt, x, y);\n        },\n        pointerdown: function(evt, x, y) {\n            this.notifyPointerdown(evt, x, y);\n            // Backwards compatibility for the default markup\n            var className = evt.target.getAttribute(\"class\");\n            switch(className){\n                case \"marker-vertex\":\n                    this.dragVertexStart(evt, x, y);\n                    return;\n                case \"marker-vertex-remove\":\n                case \"marker-vertex-remove-area\":\n                    this.dragVertexRemoveStart(evt, x, y);\n                    return;\n                case \"marker-arrowhead\":\n                    this.dragArrowheadStart(evt, x, y);\n                    return;\n                case \"connection\":\n                case \"connection-wrap\":\n                    this.dragConnectionStart(evt, x, y);\n                    return;\n                case \"marker-source\":\n                case \"marker-target\":\n                    return;\n            }\n            this.dragStart(evt, x, y);\n        },\n        pointermove: function(evt, x, y) {\n            // Backwards compatibility\n            var dragData = this._dragData;\n            if (dragData) this.eventData(evt, dragData);\n            var data = this.eventData(evt);\n            switch(data.action){\n                case \"vertex-move\":\n                    this.dragVertex(evt, x, y);\n                    break;\n                case \"label-move\":\n                    this.dragLabel(evt, x, y);\n                    break;\n                case \"arrowhead-move\":\n                    this.dragArrowhead(evt, x, y);\n                    break;\n                case \"move\":\n                    this.drag(evt, x, y);\n                    break;\n            }\n            // Backwards compatibility\n            if (dragData) assign(dragData, this.eventData(evt));\n            this.notifyPointermove(evt, x, y);\n        },\n        pointerup: function(evt, x, y) {\n            // Backwards compatibility\n            var dragData = this._dragData;\n            if (dragData) {\n                this.eventData(evt, dragData);\n                this._dragData = null;\n            }\n            var data = this.eventData(evt);\n            switch(data.action){\n                case \"vertex-move\":\n                    this.dragVertexEnd(evt, x, y);\n                    break;\n                case \"label-move\":\n                    this.dragLabelEnd(evt, x, y);\n                    break;\n                case \"arrowhead-move\":\n                    this.dragArrowheadEnd(evt, x, y);\n                    break;\n                case \"move\":\n                    this.dragEnd(evt, x, y);\n            }\n            this.notifyPointerup(evt, x, y);\n            this.checkMouseleave(evt);\n        },\n        mouseover: function(evt) {\n            CellView.prototype.mouseover.apply(this, arguments);\n            this.notify(\"link:mouseover\", evt);\n        },\n        mouseout: function(evt) {\n            CellView.prototype.mouseout.apply(this, arguments);\n            this.notify(\"link:mouseout\", evt);\n        },\n        mouseenter: function(evt) {\n            CellView.prototype.mouseenter.apply(this, arguments);\n            this.notify(\"link:mouseenter\", evt);\n        },\n        mouseleave: function(evt) {\n            CellView.prototype.mouseleave.apply(this, arguments);\n            this.notify(\"link:mouseleave\", evt);\n        },\n        mousewheel: function(evt, x, y, delta) {\n            CellView.prototype.mousewheel.apply(this, arguments);\n            this.notify(\"link:mousewheel\", evt, x, y, delta);\n        },\n        onevent: function(evt, eventName, x, y) {\n            // Backwards compatibility\n            var linkTool = V(evt.target).findParentByClass(\"link-tool\", this.el);\n            if (linkTool) {\n                // No further action to be executed\n                evt.stopPropagation();\n                // Allow `interactive.useLinkTools=false`\n                if (this.can(\"useLinkTools\")) {\n                    if (eventName === \"remove\") {\n                        // Built-in remove event\n                        this.model.remove({\n                            ui: true\n                        });\n                        // Do not trigger link pointerdown\n                        return;\n                    } else // link:options and other custom events inside the link tools\n                    this.notify(eventName, evt, x, y);\n                }\n                this.notifyPointerdown(evt, x, y);\n                this.paper.delegateDragEvents(this, evt.data);\n            } else CellView.prototype.onevent.apply(this, arguments);\n        },\n        onlabel: function(evt, x, y) {\n            this.notifyPointerdown(evt, x, y);\n            this.dragLabelStart(evt, x, y);\n            var stopPropagation = this.eventData(evt).stopPropagation;\n            if (stopPropagation) evt.stopPropagation();\n        },\n        // Drag Start Handlers\n        dragConnectionStart: function(evt, x, y) {\n            if (!this.can(\"vertexAdd\")) return;\n            // Store the index at which the new vertex has just been placed.\n            // We'll be update the very same vertex position in `pointermove()`.\n            var vertexIdx = this.addVertex({\n                x: x,\n                y: y\n            }, {\n                ui: true\n            });\n            this.eventData(evt, {\n                action: \"vertex-move\",\n                vertexIdx: vertexIdx\n            });\n        },\n        dragLabelStart: function(evt, x, y) {\n            if (this.can(\"labelMove\")) {\n                if (this.isDefaultInteractionPrevented(evt)) return;\n                var labelNode = evt.currentTarget;\n                var labelIdx = parseInt(labelNode.getAttribute(\"label-idx\"), 10);\n                var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n                var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));\n                var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);\n                var coords = this.getLabelCoordinates(position);\n                var dx = coords.x - x; // how much needs to be added to cursor x to get to label x\n                var dy = coords.y - y; // how much needs to be added to cursor y to get to label y\n                var positionAngle = this._getLabelPositionAngle(labelIdx);\n                var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n                var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n                var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n                this.eventData(evt, {\n                    action: \"label-move\",\n                    labelIdx: labelIdx,\n                    dx: dx,\n                    dy: dy,\n                    positionAngle: positionAngle,\n                    positionArgs: positionArgs,\n                    stopPropagation: true\n                });\n            } else // Backwards compatibility:\n            // If labels can't be dragged no default action is triggered.\n            this.eventData(evt, {\n                stopPropagation: true\n            });\n            this.paper.delegateDragEvents(this, evt.data);\n        },\n        dragVertexStart: function(evt, x, y) {\n            if (!this.can(\"vertexMove\")) return;\n            var vertexNode = evt.target;\n            var vertexIdx = parseInt(vertexNode.getAttribute(\"idx\"), 10);\n            this.eventData(evt, {\n                action: \"vertex-move\",\n                vertexIdx: vertexIdx\n            });\n        },\n        dragVertexRemoveStart: function(evt, x, y) {\n            if (!this.can(\"vertexRemove\")) return;\n            var removeNode = evt.target;\n            var vertexIdx = parseInt(removeNode.getAttribute(\"idx\"), 10);\n            this.model.removeVertex(vertexIdx);\n        },\n        dragArrowheadStart: function(evt, x, y) {\n            if (!this.can(\"arrowheadMove\")) return;\n            var arrowheadNode = evt.target;\n            var arrowheadType = arrowheadNode.getAttribute(\"end\");\n            var data = this.startArrowheadMove(arrowheadType, {\n                ignoreBackwardsCompatibility: true\n            });\n            this.eventData(evt, data);\n        },\n        dragStart: function(evt, x, y) {\n            if (this.isDefaultInteractionPrevented(evt)) return;\n            if (!this.can(\"linkMove\")) return;\n            this.eventData(evt, {\n                action: \"move\",\n                dx: x,\n                dy: y\n            });\n        },\n        // Drag Handlers\n        dragLabel: function(evt, x, y) {\n            var data = this.eventData(evt);\n            var label = {\n                position: this.getLabelPosition(x + data.dx, y + data.dy, data.positionAngle, data.positionArgs)\n            };\n            if (this.paper.options.snapLabels) delete label.position.offset;\n            // The `touchmove' events are not fired\n            // when the original event target is removed from the DOM.\n            // The labels are currently re-rendered completely when only\n            // the position changes. This is why we need to make sure that\n            // the label is updated synchronously.\n            // TODO: replace `touchmove` with `pointermove` (breaking change).\n            var setOptions = {\n                ui: true\n            };\n            if (this.paper.isAsync() && evt.type === \"touchmove\") setOptions.async = false;\n            this.model.label(data.labelIdx, label, setOptions);\n        },\n        dragVertex: function(evt, x, y) {\n            var data = this.eventData(evt);\n            this.model.vertex(data.vertexIdx, {\n                x: x,\n                y: y\n            }, {\n                ui: true\n            });\n        },\n        dragArrowhead: function(evt, x, y) {\n            if (this.paper.options.snapLinks) {\n                var isSnapped = this._snapArrowhead(evt, x, y);\n                if (!isSnapped && this.paper.options.snapLinksSelf) this._snapArrowheadSelf(evt, x, y);\n            } else if (this.paper.options.snapLinksSelf) this._snapArrowheadSelf(evt, x, y);\n            else this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n        },\n        drag: function(evt, x, y) {\n            var data = this.eventData(evt);\n            this.model.translate(x - data.dx, y - data.dy, {\n                ui: true\n            });\n            this.eventData(evt, {\n                dx: x,\n                dy: y\n            });\n        },\n        // Drag End Handlers\n        dragLabelEnd: function() {\n        // noop\n        },\n        dragVertexEnd: function() {\n        // noop\n        },\n        dragArrowheadEnd: function(evt, x, y) {\n            var data = this.eventData(evt);\n            var paper = this.paper;\n            if (paper.options.snapLinks) this._snapArrowheadEnd(data);\n            else this._connectArrowheadEnd(data, x, y);\n            if (!paper.linkAllowed(this)) // If the changed link is not allowed, revert to its previous state.\n            this._disallow(data);\n            else {\n                this._finishEmbedding(data);\n                this._notifyConnectEvent(data, evt);\n            }\n            this._afterArrowheadMove(data);\n        },\n        dragEnd: function() {\n        // noop\n        },\n        _disallow: function(data) {\n            switch(data.whenNotAllowed){\n                case \"remove\":\n                    this.model.remove({\n                        ui: true\n                    });\n                    break;\n                case \"revert\":\n                default:\n                    this.model.set(data.arrowhead, data.initialEnd, {\n                        ui: true\n                    });\n                    break;\n            }\n        },\n        _finishEmbedding: function(data) {\n            // Reparent the link if embedding is enabled\n            if (this.paper.options.embeddingMode && this.model.reparent()) // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n            data.z = null;\n        },\n        _notifyConnectEvent: function(data, evt) {\n            var arrowhead = data.arrowhead;\n            var initialEnd = data.initialEnd;\n            var currentEnd = this.model.prop(arrowhead);\n            var endChanged = currentEnd && !Link.endsEqual(initialEnd, currentEnd);\n            if (endChanged) {\n                var paper = this.paper;\n                if (initialEnd.id) this.notify(\"link:disconnect\", evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n                if (currentEnd.id) this.notify(\"link:connect\", evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n            }\n        },\n        _snapToPoints: function(snapPoint, points, radius) {\n            var closestPointX = null;\n            var closestDistanceX = Infinity;\n            var closestPointY = null;\n            var closestDistanceY = Infinity;\n            var x = snapPoint.x;\n            var y = snapPoint.y;\n            for(var i = 0; i < points.length; i++){\n                var distX = Math.abs(points[i].x - snapPoint.x);\n                if (distX < closestDistanceX) {\n                    closestDistanceX = distX;\n                    closestPointX = points[i];\n                }\n                var distY = Math.abs(points[i].y - snapPoint.y);\n                if (distY < closestDistanceY) {\n                    closestDistanceY = distY;\n                    closestPointY = points[i];\n                }\n            }\n            if (closestDistanceX < radius) x = closestPointX.x;\n            if (closestDistanceY < radius) y = closestPointY.y;\n            return {\n                x: x,\n                y: y\n            };\n        },\n        _snapArrowheadSelf: function(evt, x, y) {\n            var ref = this;\n            var paper = ref.paper;\n            var model = ref.model;\n            var ref$1 = paper.options;\n            var snapLinksSelf = ref$1.snapLinksSelf;\n            var data = this.eventData(evt);\n            var radius = snapLinksSelf.radius || 20;\n            var anchor = this.getEndAnchor(data.arrowhead === \"source\" ? \"target\" : \"source\");\n            var vertices = model.vertices();\n            var points = [\n                anchor\n            ].concat(vertices);\n            var snapPoint = this._snapToPoints({\n                x: x,\n                y: y\n            }, points, radius);\n            this._connectArrowhead(document.elementFromPoint(snapPoint.x, snapPoint.y), snapPoint.x, snapPoint.y, this.eventData(evt));\n        },\n        _snapArrowhead: function(evt, x, y) {\n            var ref = this;\n            var paper = ref.paper;\n            var ref$1 = paper.options;\n            var snapLinks = ref$1.snapLinks;\n            var connectionStrategy = ref$1.connectionStrategy;\n            var data = this.eventData(evt);\n            var isSnapped = false;\n            // checking view in close area of the pointer\n            var r = snapLinks.radius || 50;\n            var viewsInArea = paper.findViewsInArea({\n                x: x - r,\n                y: y - r,\n                width: 2 * r,\n                height: 2 * r\n            });\n            var prevClosestView = data.closestView || null;\n            var prevClosestMagnet = data.closestMagnet || null;\n            var prevMagnetProxy = data.magnetProxy || null;\n            data.closestView = data.closestMagnet = data.magnetProxy = null;\n            var minDistance = Number.MAX_VALUE;\n            var pointer = new Point(x, y);\n            viewsInArea.forEach(function(view) {\n                var candidates = [];\n                // skip connecting to the element in case '.': { magnet: false } attribute present\n                if (view.el.getAttribute(\"magnet\") !== \"false\") candidates.push({\n                    bbox: view.model.getBBox(),\n                    magnet: view.el\n                });\n                view.$(\"[magnet]\").toArray().forEach(function(magnet) {\n                    candidates.push({\n                        bbox: view.getNodeBBox(magnet),\n                        magnet: magnet\n                    });\n                });\n                candidates.forEach(function(candidate) {\n                    var magnet = candidate.magnet;\n                    var bbox = candidate.bbox;\n                    // find distance from the center of the model to pointer coordinates\n                    var distance = bbox.center().squaredDistance(pointer);\n                    // the connection is looked up in a circle area by `distance < r`\n                    if (distance < minDistance) {\n                        var isAlreadyValidated = prevClosestMagnet === magnet;\n                        if (isAlreadyValidated || paper.options.validateConnection.apply(paper, data.validateConnectionArgs(view, view.el === magnet ? null : magnet))) {\n                            minDistance = distance;\n                            data.closestView = view;\n                            data.closestMagnet = magnet;\n                        }\n                    }\n                });\n            }, this);\n            var end;\n            var magnetProxy = null;\n            var closestView = data.closestView;\n            var closestMagnet = data.closestMagnet;\n            if (closestMagnet) magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, \"highlighter\");\n            var endType = data.arrowhead;\n            var newClosestMagnet = prevClosestMagnet !== closestMagnet;\n            if (prevClosestView && newClosestMagnet) prevClosestView.unhighlight(prevMagnetProxy, {\n                connecting: true,\n                snapping: true\n            });\n            if (closestView) {\n                var prevEnd = data.prevEnd;\n                var prevX = data.prevX;\n                var prevY = data.prevY;\n                data.prevX = x;\n                data.prevY = y;\n                isSnapped = true;\n                if (!newClosestMagnet) {\n                    if (typeof connectionStrategy !== \"function\" || prevX === x && prevY === y) // the magnet has not changed and the link's end does not depend on the x and y\n                    return isSnapped;\n                }\n                end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n                if (!newClosestMagnet && isEqual(prevEnd, end)) // the source/target json has not changed\n                return isSnapped;\n                data.prevEnd = end;\n                if (newClosestMagnet) closestView.highlight(magnetProxy, {\n                    connecting: true,\n                    snapping: true\n                });\n            } else end = {\n                x: x,\n                y: y\n            };\n            this.model.set(endType, end || {\n                x: x,\n                y: y\n            }, {\n                ui: true\n            });\n            if (prevClosestView) this.notify(\"link:snap:disconnect\", evt, prevClosestView, prevClosestMagnet, endType);\n            if (closestView) this.notify(\"link:snap:connect\", evt, closestView, closestMagnet, endType);\n            return isSnapped;\n        },\n        _snapArrowheadEnd: function(data) {\n            // Finish off link snapping.\n            // Everything except view unhighlighting was already done on pointermove.\n            var closestView = data.closestView;\n            var closestMagnet = data.closestMagnet;\n            if (closestView && closestMagnet) {\n                closestView.unhighlight(data.magnetProxy, {\n                    connecting: true,\n                    snapping: true\n                });\n                data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n            }\n            data.closestView = data.closestMagnet = null;\n        },\n        _connectArrowhead: function(target, x, y, data) {\n            // checking views right under the pointer\n            var ref = this;\n            var paper = ref.paper;\n            var model = ref.model;\n            if (data.eventTarget !== target) {\n                // Unhighlight the previous view under pointer if there was one.\n                if (data.magnetProxy) data.viewUnderPointer.unhighlight(data.magnetProxy, {\n                    connecting: true\n                });\n                var viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n                if (viewUnderPointer) {\n                    // If we found a view that is under the pointer, we need to find the closest\n                    // magnet based on the real target element of the event.\n                    var magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n                    var magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, \"highlighter\");\n                    if (magnetUnderPointer && this.paper.options.validateConnection.apply(paper, data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer))) // If there was no magnet found, do not highlight anything and assume there\n                    // is no view under pointer we're interested in reconnecting to.\n                    // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n                    {\n                        if (magnetProxy) viewUnderPointer.highlight(magnetProxy, {\n                            connecting: true\n                        });\n                    } else {\n                        // This type of connection is not valid. Disregard this magnet.\n                        data.magnetUnderPointer = null;\n                        data.magnetProxy = null;\n                    }\n                } else {\n                    // Make sure we'll unset previous magnet.\n                    data.magnetUnderPointer = null;\n                    data.magnetProxy = null;\n                }\n            }\n            data.eventTarget = target;\n            model.set(data.arrowhead, {\n                x: x,\n                y: y\n            }, {\n                ui: true\n            });\n        },\n        _connectArrowheadEnd: function(data, x, y) {\n            if (data === void 0) data = {};\n            var ref = this;\n            var model = ref.model;\n            var viewUnderPointer = data.viewUnderPointer;\n            var magnetUnderPointer = data.magnetUnderPointer;\n            var magnetProxy = data.magnetProxy;\n            var arrowhead = data.arrowhead;\n            if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n            viewUnderPointer.unhighlight(magnetProxy, {\n                connecting: true\n            });\n            // The link end is taken from the magnet under the pointer, not the proxy.\n            var end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n            model.set(arrowhead, end, {\n                ui: true\n            });\n        },\n        _beforeArrowheadMove: function(data) {\n            data.z = this.model.get(\"z\");\n            this.model.toFront();\n            // Let the pointer propagate through the link view elements so that\n            // the `evt.target` is another element under the pointer, not the link itself.\n            var style = this.el.style;\n            data.pointerEvents = style.pointerEvents;\n            style.pointerEvents = \"none\";\n            if (this.paper.options.markAvailable) this._markAvailableMagnets(data);\n        },\n        _afterArrowheadMove: function(data) {\n            if (data.z !== null) {\n                this.model.set(\"z\", data.z, {\n                    ui: true\n                });\n                data.z = null;\n            }\n            // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n            this.el.style.pointerEvents = data.pointerEvents;\n            if (this.paper.options.markAvailable) this._unmarkAvailableMagnets(data);\n        },\n        _createValidateConnectionArgs: function(arrowhead) {\n            // It makes sure the arguments for validateConnection have the following form:\n            // (source view, source magnet, target view, target magnet and link view)\n            var args = [];\n            args[4] = arrowhead;\n            args[5] = this;\n            var oppositeArrowhead;\n            var i = 0;\n            var j = 0;\n            if (arrowhead === \"source\") {\n                i = 2;\n                oppositeArrowhead = \"target\";\n            } else {\n                j = 2;\n                oppositeArrowhead = \"source\";\n            }\n            var end = this.model.get(oppositeArrowhead);\n            if (end.id) {\n                var view = args[i] = this.paper.findViewByModel(end.id);\n                var magnet = view.getMagnetFromLinkEnd(end);\n                if (magnet === view.el) magnet = undefined;\n                args[i + 1] = magnet;\n            }\n            function validateConnectionArgs(cellView, magnet) {\n                args[j] = cellView;\n                args[j + 1] = cellView.el === magnet ? undefined : magnet;\n                return args;\n            }\n            return validateConnectionArgs;\n        },\n        _markAvailableMagnets: function(data) {\n            function isMagnetAvailable(view, magnet) {\n                var paper = view.paper;\n                var validate = paper.options.validateConnection;\n                return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n            }\n            var paper = this.paper;\n            var elements = paper.model.getCells();\n            data.marked = {};\n            for(var i = 0, n = elements.length; i < n; i++){\n                var view = elements[i].findView(paper);\n                if (!view) continue;\n                var magnets = Array.prototype.slice.call(view.el.querySelectorAll(\"[magnet]\"));\n                if (view.el.getAttribute(\"magnet\") !== \"false\") // Element wrapping group is also a magnet\n                magnets.push(view.el);\n                var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n                if (availableMagnets.length > 0) {\n                    // highlight all available magnets\n                    for(var j = 0, m = availableMagnets.length; j < m; j++)view.highlight(availableMagnets[j], {\n                        magnetAvailability: true\n                    });\n                    // highlight the entire view\n                    view.highlight(null, {\n                        elementAvailability: true\n                    });\n                    data.marked[view.model.id] = availableMagnets;\n                }\n            }\n        },\n        _unmarkAvailableMagnets: function(data) {\n            var markedKeys = Object.keys(data.marked);\n            var id;\n            var markedMagnets;\n            for(var i = 0, n = markedKeys.length; i < n; i++){\n                id = markedKeys[i];\n                markedMagnets = data.marked[id];\n                var view = this.paper.findViewByModel(id);\n                if (view) {\n                    for(var j = 0, m = markedMagnets.length; j < m; j++)view.unhighlight(markedMagnets[j], {\n                        magnetAvailability: true\n                    });\n                    view.unhighlight(null, {\n                        elementAvailability: true\n                    });\n                }\n            }\n            data.marked = null;\n        },\n        startArrowheadMove: function(end, opt) {\n            opt || (opt = {});\n            // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n            // move without need to click on the actual arrowhead dom element.\n            var data = {\n                action: \"arrowhead-move\",\n                arrowhead: end,\n                whenNotAllowed: opt.whenNotAllowed || \"revert\",\n                initialMagnet: this[end + \"Magnet\"] || (this[end + \"View\"] ? this[end + \"View\"].el : null),\n                initialEnd: clone(this.model.get(end)),\n                validateConnectionArgs: this._createValidateConnectionArgs(end)\n            };\n            this._beforeArrowheadMove(data);\n            if (opt.ignoreBackwardsCompatibility !== true) this._dragData = data;\n            return data;\n        },\n        // Lifecycle methods\n        onMount: function() {\n            CellView.prototype.onMount.apply(this, arguments);\n            this.mountLabels();\n        },\n        onDetach: function() {\n            CellView.prototype.onDetach.apply(this, arguments);\n            this.unmountLabels();\n        },\n        onRemove: function() {\n            CellView.prototype.onRemove.apply(this, arguments);\n            this.unmountLabels();\n        }\n    }, {\n        Flags: Flags$2\n    });\n    Object.defineProperty(LinkView.prototype, \"sourceBBox\", {\n        enumerable: true,\n        get: function() {\n            var sourceView = this.sourceView;\n            if (!sourceView) {\n                var sourceDef = this.model.source();\n                return new Rect(sourceDef.x, sourceDef.y);\n            }\n            var sourceMagnet = this.sourceMagnet;\n            if (sourceView.isNodeConnection(sourceMagnet)) return new Rect(this.sourceAnchor);\n            return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n        }\n    });\n    Object.defineProperty(LinkView.prototype, \"targetBBox\", {\n        enumerable: true,\n        get: function() {\n            var targetView = this.targetView;\n            if (!targetView) {\n                var targetDef = this.model.target();\n                return new Rect(targetDef.x, targetDef.y);\n            }\n            var targetMagnet = this.targetMagnet;\n            if (targetView.isNodeConnection(targetMagnet)) return new Rect(this.targetAnchor);\n            return targetView.getNodeBBox(targetMagnet || targetView.el);\n        }\n    });\n    var stroke = HighlighterView.extend({\n        tagName: \"path\",\n        className: \"highlight-stroke\",\n        attributes: {\n            \"pointer-events\": \"none\",\n            \"vector-effect\": \"non-scaling-stroke\",\n            \"fill\": \"none\"\n        },\n        options: {\n            padding: 3,\n            rx: 0,\n            ry: 0,\n            useFirstSubpath: false,\n            attrs: {\n                \"stroke-width\": 3,\n                \"stroke\": \"#FEB663\"\n            }\n        },\n        getPathData: function getPathData(cellView, node) {\n            var ref = this;\n            var options = ref.options;\n            var useFirstSubpath = options.useFirstSubpath;\n            var d;\n            try {\n                var vNode = V(node);\n                d = vNode.convertToPathData().trim();\n                if (vNode.tagName() === \"PATH\" && useFirstSubpath) {\n                    var secondSubpathIndex = d.search(/.M/i) + 1;\n                    if (secondSubpathIndex > 0) d = d.substr(0, secondSubpathIndex);\n                }\n            } catch (error) {\n                // Failed to get path data from magnet element.\n                // Draw a rectangle around the node instead.\n                var nodeBBox = cellView.getNodeBoundingRect(node);\n                d = V.rectToPath(assign({}, options, nodeBBox.toJSON()));\n            }\n            return d;\n        },\n        highlightConnection: function highlightConnection(cellView) {\n            this.vel.attr(\"d\", cellView.getSerializedConnection());\n        },\n        highlightNode: function highlightNode(cellView, node) {\n            var ref = this;\n            var vel = ref.vel;\n            var options = ref.options;\n            var padding = options.padding;\n            var layer = options.layer;\n            var highlightMatrix = this.getNodeMatrix(cellView, node);\n            // Add padding to the highlight element.\n            if (padding) {\n                if (!layer && node === cellView.el) // If the highlighter is appended to the cellView\n                // and we measure the size of the cellView wrapping group\n                // it's necessary to remove the highlighter first\n                vel.remove();\n                var nodeBBox = cellView.getNodeBoundingRect(node);\n                var cx = nodeBBox.x + nodeBBox.width / 2;\n                var cy = nodeBBox.y + nodeBBox.height / 2;\n                nodeBBox = V.transformRect(nodeBBox, highlightMatrix);\n                var width = Math.max(nodeBBox.width, 1);\n                var height = Math.max(nodeBBox.height, 1);\n                var sx = (width + padding) / width;\n                var sy = (height + padding) / height;\n                var paddingMatrix = V.createSVGMatrix({\n                    a: sx,\n                    b: 0,\n                    c: 0,\n                    d: sy,\n                    e: cx - sx * cx,\n                    f: cy - sy * cy\n                });\n                highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n            }\n            vel.attr({\n                \"d\": this.getPathData(cellView, node),\n                \"transform\": V.matrixToTransformString(highlightMatrix)\n            });\n        },\n        highlight: function highlight(cellView, node) {\n            var ref = this;\n            var vel = ref.vel;\n            var options = ref.options;\n            vel.attr(options.attrs);\n            if (cellView.isNodeConnection(node)) this.highlightConnection(cellView);\n            else this.highlightNode(cellView, node);\n        }\n    });\n    var MASK_CLIP = 20;\n    function forEachDescendant(vel, fn) {\n        var descendants = vel.children();\n        while(descendants.length > 0){\n            var descendant = descendants.shift();\n            if (fn(descendant)) descendants.push.apply(descendants, descendant.children());\n        }\n    }\n    var mask = HighlighterView.extend({\n        tagName: \"rect\",\n        className: \"highlight-mask\",\n        attributes: {\n            \"pointer-events\": \"none\"\n        },\n        options: {\n            padding: 3,\n            maskClip: MASK_CLIP,\n            deep: false,\n            attrs: {\n                \"stroke\": \"#FEB663\",\n                \"stroke-width\": 3,\n                \"stroke-linecap\": \"butt\",\n                \"stroke-linejoin\": \"miter\"\n            }\n        },\n        VISIBLE: \"white\",\n        INVISIBLE: \"black\",\n        MASK_ROOT_ATTRIBUTE_BLACKLIST: [\n            \"marker-start\",\n            \"marker-end\",\n            \"marker-mid\",\n            \"transform\",\n            \"stroke-dasharray\",\n            \"class\"\n        ],\n        MASK_CHILD_ATTRIBUTE_BLACKLIST: [\n            \"stroke\",\n            \"fill\",\n            \"stroke-width\",\n            \"stroke-opacity\",\n            \"stroke-dasharray\",\n            \"fill-opacity\",\n            \"marker-start\",\n            \"marker-end\",\n            \"marker-mid\",\n            \"class\"\n        ],\n        // TODO: change the list to a function callback\n        MASK_REPLACE_TAGS: [\n            \"FOREIGNOBJECT\",\n            \"IMAGE\",\n            \"USE\",\n            \"TEXT\",\n            \"TSPAN\",\n            \"TEXTPATH\"\n        ],\n        // TODO: change the list to a function callback\n        MASK_REMOVE_TAGS: [\n            \"TEXT\",\n            \"TSPAN\",\n            \"TEXTPATH\"\n        ],\n        transformMaskChild: function transformMaskChild(cellView, childEl) {\n            var ref = this;\n            var MASK_CHILD_ATTRIBUTE_BLACKLIST = ref.MASK_CHILD_ATTRIBUTE_BLACKLIST;\n            var MASK_REPLACE_TAGS = ref.MASK_REPLACE_TAGS;\n            var MASK_REMOVE_TAGS = ref.MASK_REMOVE_TAGS;\n            var childTagName = childEl.tagName();\n            // Do not include the element in the mask's image\n            if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n                childEl.remove();\n                return false;\n            }\n            // Replace the element with a rectangle\n            if (MASK_REPLACE_TAGS.includes(childTagName)) {\n                // Note: clone() method does not change the children ids\n                var originalChild = cellView.vel.findOne(\"#\" + childEl.id);\n                if (originalChild) {\n                    var originalNode = originalChild.node;\n                    var childBBox = cellView.getNodeBoundingRect(originalNode);\n                    if (cellView.model.isElement()) childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n                    var replacement = V(\"rect\", childBBox.toJSON());\n                    var ref$1 = childBBox.center();\n                    var ox = ref$1.x;\n                    var oy = ref$1.y;\n                    var ref$2 = originalChild.rotate();\n                    var angle = ref$2.angle;\n                    var cx = ref$2.cx;\n                    if (cx === void 0) cx = ox;\n                    var cy = ref$2.cy;\n                    if (cy === void 0) cy = oy;\n                    if (angle) replacement.rotate(angle, cx, cy);\n                    // Note: it's not important to keep the same sibling index since all subnodes are filled\n                    childEl.parent().append(replacement);\n                }\n                childEl.remove();\n                return false;\n            }\n            // Keep the element, but clean it from certain attributes\n            MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(function(attrName) {\n                if (attrName === \"fill\" && childEl.attr(\"fill\") === \"none\") return;\n                childEl.removeAttr(attrName);\n            });\n            return true;\n        },\n        transformMaskRoot: function transformMaskRoot(_cellView, rootEl) {\n            var ref = this;\n            var MASK_ROOT_ATTRIBUTE_BLACKLIST = ref.MASK_ROOT_ATTRIBUTE_BLACKLIST;\n            MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(function(attrName) {\n                rootEl.removeAttr(attrName);\n            });\n        },\n        getMaskShape: function getMaskShape(cellView, vel) {\n            var this$1 = this;\n            var ref = this;\n            var options = ref.options;\n            var MASK_REPLACE_TAGS = ref.MASK_REPLACE_TAGS;\n            var deep = options.deep;\n            var tagName = vel.tagName();\n            var maskRoot;\n            if (tagName === \"G\") {\n                if (!deep) return null;\n                maskRoot = vel.clone();\n                forEachDescendant(maskRoot, function(maskChild) {\n                    return this$1.transformMaskChild(cellView, maskChild);\n                });\n            } else {\n                if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n                maskRoot = vel.clone();\n            }\n            this.transformMaskRoot(cellView, maskRoot);\n            return maskRoot;\n        },\n        getMaskId: function getMaskId() {\n            return \"highlight-mask-\" + this.cid;\n        },\n        getMask: function getMask(cellView, vNode) {\n            var ref = this;\n            var VISIBLE = ref.VISIBLE;\n            var INVISIBLE = ref.INVISIBLE;\n            var options = ref.options;\n            var padding = options.padding;\n            var attrs = options.attrs;\n            var strokeWidth = \"stroke-width\" in attrs ? attrs[\"stroke-width\"] : 1;\n            var hasNodeFill = vNode.attr(\"fill\") !== \"none\";\n            var magnetStrokeWidth = parseFloat(vNode.attr(\"stroke-width\"));\n            if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;\n            // stroke of the invisible shape\n            var minStrokeWidth = magnetStrokeWidth + padding * 2;\n            // stroke of the visible shape\n            var maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n            var maskEl = this.getMaskShape(cellView, vNode);\n            if (!maskEl) {\n                var nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n                // Make sure the rect is visible\n                nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n                maskEl = V(\"rect\", nodeBBox.toJSON());\n            }\n            maskEl.attr(attrs);\n            return V(\"mask\", {\n                \"id\": this.getMaskId()\n            }).append([\n                maskEl.clone().attr({\n                    \"fill\": hasNodeFill ? VISIBLE : \"none\",\n                    \"stroke\": VISIBLE,\n                    \"stroke-width\": maxStrokeWidth\n                }),\n                maskEl.clone().attr({\n                    \"fill\": hasNodeFill ? INVISIBLE : \"none\",\n                    \"stroke\": INVISIBLE,\n                    \"stroke-width\": minStrokeWidth\n                })\n            ]);\n        },\n        removeMask: function removeMask(paper) {\n            var maskNode = paper.svg.getElementById(this.getMaskId());\n            if (maskNode) paper.defs.removeChild(maskNode);\n        },\n        addMask: function addMask(paper, maskEl) {\n            paper.defs.appendChild(maskEl.node);\n        },\n        highlight: function highlight(cellView, node) {\n            var ref = this;\n            var options = ref.options;\n            var vel = ref.vel;\n            var padding = options.padding;\n            var attrs = options.attrs;\n            var maskClip = options.maskClip;\n            if (maskClip === void 0) maskClip = MASK_CLIP;\n            var layer = options.layer;\n            var color = \"stroke\" in attrs ? attrs[\"stroke\"] : \"#000000\";\n            if (!layer && node === cellView.el) // If the highlighter is appended to the cellView\n            // and we measure the size of the cellView wrapping group\n            // it's necessary to remove the highlighter first\n            vel.remove();\n            var highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n            var highlightMatrix = this.getNodeMatrix(cellView, node);\n            var maskEl = this.getMask(cellView, V(node));\n            this.addMask(cellView.paper, maskEl);\n            vel.attr(highlighterBBox.toJSON());\n            vel.attr({\n                \"transform\": V.matrixToTransformString(highlightMatrix),\n                \"mask\": \"url(#\" + maskEl.id + \")\",\n                \"fill\": color\n            });\n        },\n        unhighlight: function unhighlight(cellView) {\n            this.removeMask(cellView.paper);\n        }\n    });\n    var opacity = HighlighterView.extend({\n        UPDATABLE: false,\n        MOUNTABLE: false,\n        opacityClassName: addClassNamePrefix(\"highlight-opacity\"),\n        highlight: function(_cellView, node) {\n            V(node).addClass(this.opacityClassName);\n        },\n        unhighlight: function(_cellView, node) {\n            V(node).removeClass(this.opacityClassName);\n        }\n    });\n    var className = addClassNamePrefix(\"highlighted\");\n    var addClass = HighlighterView.extend({\n        UPDATABLE: false,\n        MOUNTABLE: false,\n        options: {\n            className: className\n        },\n        highlight: function(_cellView, node) {\n            V(node).addClass(this.options.className);\n        },\n        unhighlight: function(_cellView, node) {\n            V(node).removeClass(this.options.className);\n        }\n    }, {\n        // Backwards Compatibility\n        className: className\n    });\n    var Directions$2 = {\n        ROW: \"row\",\n        COLUMN: \"column\"\n    };\n    var list = HighlighterView.extend({\n        tagName: \"g\",\n        MOUNTABLE: true,\n        UPDATE_ATTRIBUTES: function() {\n            return [\n                this.options.attribute\n            ];\n        },\n        _prevItems: null,\n        highlight: function highlight(elementView, node) {\n            var this$1 = this;\n            var element = elementView.model;\n            var ref = this.options;\n            var attribute = ref.attribute;\n            var size = ref.size;\n            if (size === void 0) size = 20;\n            var gap = ref.gap;\n            if (gap === void 0) gap = 5;\n            var direction = ref.direction;\n            if (direction === void 0) direction = Directions$2.ROW;\n            if (!attribute) throw new Error(\"List: attribute is required\");\n            var normalizedSize = typeof size === \"number\" ? {\n                width: size,\n                height: size\n            } : size;\n            var isRowDirection = direction === Directions$2.ROW;\n            var itemWidth = isRowDirection ? normalizedSize.width : normalizedSize.height;\n            var items = element.get(attribute);\n            if (!Array.isArray(items)) items = [];\n            var prevItems = this._prevItems || [];\n            var comparison = items.map(function(item, index) {\n                return isEqual(prevItems[index], items[index]);\n            });\n            if (prevItems.length !== items.length || comparison.some(function(unchanged) {\n                return !unchanged;\n            })) {\n                var prevEls = this.vel.children();\n                var itemsEls = items.map(function(item, index) {\n                    var prevEl = index in prevEls ? prevEls[index].node : null;\n                    if (comparison[index]) return prevEl;\n                    var itemEl = this$1.createListItem(item, normalizedSize, prevEl);\n                    if (!itemEl) return null;\n                    if (!(itemEl instanceof SVGElement)) throw new Error(\"List: item must be an SVGElement\");\n                    itemEl.dataset.index = index;\n                    itemEl.dataset.attribute = attribute;\n                    var offset = index * (itemWidth + gap);\n                    itemEl.setAttribute(\"transform\", isRowDirection ? \"translate(\" + offset + \", 0)\" : \"translate(0, \" + offset + \")\");\n                    return itemEl;\n                });\n                this.vel.empty().append(itemsEls);\n                this._prevItems = items;\n            }\n            var itemsCount = items.length;\n            var length = itemsCount === 0 ? 0 : itemsCount * itemWidth + (itemsCount - 1) * gap;\n            var listSize = isRowDirection ? {\n                width: length,\n                height: normalizedSize.height\n            } : {\n                width: normalizedSize.width,\n                height: length\n            };\n            this.position(element, listSize);\n        },\n        position: function position(element, listSize) {\n            var ref = this;\n            var vel = ref.vel;\n            var options = ref.options;\n            var margin = options.margin;\n            if (margin === void 0) margin = 5;\n            var position = options.position;\n            if (position === void 0) position = \"top-left\";\n            var ref$1 = element.size();\n            var width = ref$1.width;\n            var height = ref$1.height;\n            var ref$2 = normalizeSides(margin);\n            var left = ref$2.left;\n            var right = ref$2.right;\n            var top = ref$2.top;\n            var bottom = ref$2.bottom;\n            var bbox = new Rect(left, top, width - (left + right), height - (top + bottom));\n            var ref$3 = getRectPoint(bbox, position);\n            var x = ref$3.x;\n            var y = ref$3.y;\n            // x\n            switch(position){\n                case Positions.CENTER:\n                case Positions.TOP:\n                case Positions.BOTTOM:\n                    x -= listSize.width / 2;\n                    break;\n                case Positions.RIGHT:\n                case Positions.BOTTOM_RIGHT:\n                case Positions.TOP_RIGHT:\n                    x -= listSize.width;\n                    break;\n            }\n            // y\n            switch(position){\n                case Positions.CENTER:\n                case Positions.RIGHT:\n                case Positions.LEFT:\n                    y -= listSize.height / 2;\n                    break;\n                case Positions.BOTTOM:\n                case Positions.BOTTOM_RIGHT:\n                case Positions.BOTTOM_LEFT:\n                    y -= listSize.height;\n                    break;\n            }\n            vel.attr(\"transform\", \"translate(\" + x + \", \" + y + \")\");\n        }\n    }, {\n        Directions: Directions$2,\n        Positions: Positions\n    });\n    var highlighters = {\n        stroke: stroke,\n        mask: mask,\n        opacity: opacity,\n        addClass: addClass,\n        list: list\n    };\n    function connectionRatio(view, _magnet, _refPoint, opt) {\n        var ratio = \"ratio\" in opt ? opt.ratio : 0.5;\n        return view.getPointAtRatio(ratio);\n    }\n    function connectionLength(view, _magnet, _refPoint, opt) {\n        var length = \"length\" in opt ? opt.length : 20;\n        return view.getPointAtLength(length);\n    }\n    function _connectionPerpendicular(view, _magnet, refPoint, opt) {\n        var OFFSET = 1e6;\n        var path = view.getConnection();\n        var segmentSubdivisions = view.getConnectionSubdivisions();\n        var verticalLine = new Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n        var horizontalLine = new Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n        var verticalIntersections = verticalLine.intersect(path, {\n            segmentSubdivisions: segmentSubdivisions\n        });\n        var horizontalIntersections = horizontalLine.intersect(path, {\n            segmentSubdivisions: segmentSubdivisions\n        });\n        var intersections = [];\n        if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);\n        if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);\n        if (intersections.length > 0) return refPoint.chooseClosest(intersections);\n        if (\"fallbackAt\" in opt) return getPointAtLink(view, opt.fallbackAt);\n        return connectionClosest(view, _magnet, refPoint, opt);\n    }\n    function _connectionClosest(view, _magnet, refPoint, _opt) {\n        var closestPoint = view.getClosestPoint(refPoint);\n        if (!closestPoint) return new Point();\n        return closestPoint;\n    }\n    function resolveRef(fn) {\n        return function(view, magnet, ref, opt) {\n            if (ref instanceof Element) {\n                var refView = this.paper.findView(ref);\n                var refPoint;\n                if (refView) {\n                    if (refView.isNodeConnection(ref)) {\n                        var distance = \"fixedAt\" in opt ? opt.fixedAt : \"50%\";\n                        refPoint = getPointAtLink(refView, distance);\n                    } else refPoint = refView.getNodeBBox(ref).center();\n                } else // Something went wrong\n                refPoint = new Point();\n                return fn.call(this, view, magnet, refPoint, opt);\n            }\n            return fn.apply(this, arguments);\n        };\n    }\n    function getPointAtLink(view, value) {\n        var parsedValue = parseFloat(value);\n        if (isPercentage(value)) return view.getPointAtRatio(parsedValue / 100);\n        else return view.getPointAtLength(parsedValue);\n    }\n    var connectionPerpendicular = resolveRef(_connectionPerpendicular);\n    var connectionClosest = resolveRef(_connectionClosest);\n    var linkAnchors = {\n        resolveRef: resolveRef,\n        connectionRatio: connectionRatio,\n        connectionLength: connectionLength,\n        connectionPerpendicular: connectionPerpendicular,\n        connectionClosest: connectionClosest\n    };\n    function offsetPoint(p1, p2, offset) {\n        if (isPlainObject(offset)) {\n            var x = offset.x;\n            var y = offset.y;\n            if (isFinite(y)) {\n                var line = new Line(p2, p1);\n                var ref = line.parallel(y);\n                var start = ref.start;\n                var end = ref.end;\n                p2 = start;\n                p1 = end;\n            }\n            offset = x;\n        }\n        if (!isFinite(offset)) return p1;\n        var length = p1.distance(p2);\n        if (offset === 0 && length > 0) return p1;\n        return p1.move(p2, -Math.min(offset, length - 1));\n    }\n    function stroke$1(magnet) {\n        var stroke = magnet.getAttribute(\"stroke-width\");\n        if (stroke === null) return 0;\n        return parseFloat(stroke) || 0;\n    }\n    function alignLine(line, type, offset) {\n        if (offset === void 0) offset = 0;\n        var coordinate, a, b, direction;\n        var start = line.start;\n        var end = line.end;\n        switch(type){\n            case \"left\":\n                coordinate = \"x\";\n                a = end;\n                b = start;\n                direction = -1;\n                break;\n            case \"right\":\n                coordinate = \"x\";\n                a = start;\n                b = end;\n                direction = 1;\n                break;\n            case \"top\":\n                coordinate = \"y\";\n                a = end;\n                b = start;\n                direction = -1;\n                break;\n            case \"bottom\":\n                coordinate = \"y\";\n                a = start;\n                b = end;\n                direction = 1;\n                break;\n            default:\n                return;\n        }\n        if (start[coordinate] < end[coordinate]) a[coordinate] = b[coordinate];\n        else b[coordinate] = a[coordinate];\n        if (isFinite(offset)) {\n            a[coordinate] += direction * offset;\n            b[coordinate] += direction * offset;\n        }\n    }\n    // Connection Points\n    function anchorConnectionPoint(line, _view, _magnet, opt) {\n        var offset = opt.offset;\n        var alignOffset = opt.alignOffset;\n        var align = opt.align;\n        if (align) alignLine(line, align, alignOffset);\n        return offsetPoint(line.end, line.start, offset);\n    }\n    function bboxIntersection(line, view, magnet, opt) {\n        var bbox = view.getNodeBBox(magnet);\n        if (opt.stroke) bbox.inflate(stroke$1(magnet) / 2);\n        var intersections = line.intersect(bbox);\n        var cp = intersections ? line.start.chooseClosest(intersections) : line.end;\n        return offsetPoint(cp, line.start, opt.offset);\n    }\n    function rectangleIntersection(line, view, magnet, opt) {\n        var angle = view.model.angle();\n        if (angle === 0) return bboxIntersection(line, view, magnet, opt);\n        var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n        if (opt.stroke) bboxWORotation.inflate(stroke$1(magnet) / 2);\n        var center = bboxWORotation.center();\n        var lineWORotation = line.clone().rotate(center, angle);\n        var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n        var cp = intersections ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle) : line.end;\n        return offsetPoint(cp, line.start, opt.offset);\n    }\n    function findShapeNode(magnet) {\n        if (!magnet) return null;\n        var node = magnet;\n        do {\n            var tagName = node.tagName;\n            if (typeof tagName !== \"string\") return null;\n            tagName = tagName.toUpperCase();\n            if (tagName === \"G\") node = node.firstElementChild;\n            else if (tagName === \"TITLE\") node = node.nextElementSibling;\n            else break;\n        }while (node);\n        return node;\n    }\n    var BNDR_SUBDIVISIONS = \"segmentSubdivisons\";\n    var BNDR_SHAPE_BBOX = \"shapeBBox\";\n    function boundaryIntersection(line, view, magnet, opt) {\n        var node, intersection;\n        var selector = opt.selector;\n        var anchor = line.end;\n        if (typeof selector === \"string\") node = view.findBySelector(selector)[0];\n        else if (selector === false) node = magnet;\n        else if (Array.isArray(selector)) node = getByPath(magnet, selector);\n        else node = findShapeNode(magnet);\n        if (!V.isSVGGraphicsElement(node)) {\n            if (node === magnet || !V.isSVGGraphicsElement(magnet)) return anchor;\n            node = magnet;\n        }\n        var localShape = view.getNodeShape(node);\n        var magnetMatrix = view.getNodeMatrix(node);\n        var translateMatrix = view.getRootTranslateMatrix();\n        var rotateMatrix = view.getRootRotateMatrix();\n        var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n        var localMatrix = targetMatrix.inverse();\n        var localLine = V.transformLine(line, localMatrix);\n        var localRef = localLine.start.clone();\n        var data = view.getNodeData(node);\n        if (opt.insideout === false) {\n            if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n            var localBBox = data[BNDR_SHAPE_BBOX];\n            if (localBBox.containsPoint(localRef)) return anchor;\n        }\n        // Caching segment subdivisions for paths\n        var pathOpt;\n        if (localShape instanceof Path) {\n            var precision = opt.precision || 2;\n            if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({\n                precision: precision\n            });\n            pathOpt = {\n                precision: precision,\n                segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n            };\n        }\n        if (opt.extrapolate === true) localLine.setLength(1e6);\n        intersection = localLine.intersect(localShape, pathOpt);\n        if (intersection) // More than one intersection\n        {\n            if (V.isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n        } else if (opt.sticky === true) {\n            // No intersection, find the closest point instead\n            if (localShape instanceof Rect) intersection = localShape.pointNearestToPoint(localRef);\n            else if (localShape instanceof Ellipse) intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n            else intersection = localShape.closestPoint(localRef, pathOpt);\n        }\n        var cp = intersection ? V.transformPoint(intersection, targetMatrix) : anchor;\n        var cpOffset = opt.offset || 0;\n        if (opt.stroke) cpOffset += stroke$1(node) / 2;\n        return offsetPoint(cp, line.start, cpOffset);\n    }\n    var anchor = anchorConnectionPoint;\n    var bbox = bboxIntersection;\n    var rectangle = rectangleIntersection;\n    var boundary = boundaryIntersection;\n    var connectionPoints = {\n        anchor: anchor,\n        bbox: bbox,\n        rectangle: rectangle,\n        boundary: boundary\n    };\n    function bboxWrapper(method) {\n        return function(view, magnet, ref, opt) {\n            var rotate = !!opt.rotate;\n            var bbox = rotate ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n            var anchor = bbox[method]();\n            var dx = opt.dx;\n            if (dx) {\n                var dxPercentage = isPercentage(dx);\n                dx = parseFloat(dx);\n                if (isFinite(dx)) {\n                    if (dxPercentage) {\n                        dx /= 100;\n                        dx *= bbox.width;\n                    }\n                    anchor.x += dx;\n                }\n            }\n            var dy = opt.dy;\n            if (dy) {\n                var dyPercentage = isPercentage(dy);\n                dy = parseFloat(dy);\n                if (isFinite(dy)) {\n                    if (dyPercentage) {\n                        dy /= 100;\n                        dy *= bbox.height;\n                    }\n                    anchor.y += dy;\n                }\n            }\n            return rotate ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;\n        };\n    }\n    function _perpendicular(view, magnet, refPoint, opt) {\n        var angle = view.model.angle();\n        var bbox = view.getNodeBBox(magnet);\n        var anchor = bbox.center();\n        var topLeft = bbox.origin();\n        var bottomRight = bbox.corner();\n        var padding = opt.padding;\n        if (!isFinite(padding)) padding = 0;\n        if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {\n            var dy = refPoint.y - anchor.y;\n            anchor.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(toRad(angle));\n            anchor.y += dy;\n        } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {\n            var dx = refPoint.x - anchor.x;\n            anchor.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(toRad(angle));\n            anchor.x += dx;\n        }\n        return anchor;\n    }\n    function _midSide(view, magnet, refPoint, opt) {\n        var rotate = !!opt.rotate;\n        var bbox, angle, center;\n        if (rotate) {\n            bbox = view.getNodeUnrotatedBBox(magnet);\n            center = view.model.getBBox().center();\n            angle = view.model.angle();\n        } else bbox = view.getNodeBBox(magnet);\n        var padding = opt.padding;\n        if (isFinite(padding)) bbox.inflate(padding);\n        if (rotate) refPoint.rotate(center, angle);\n        var side = bbox.sideNearestToPoint(refPoint);\n        var anchor;\n        switch(side){\n            case \"left\":\n                anchor = bbox.leftMiddle();\n                break;\n            case \"right\":\n                anchor = bbox.rightMiddle();\n                break;\n            case \"top\":\n                anchor = bbox.topMiddle();\n                break;\n            case \"bottom\":\n                anchor = bbox.bottomMiddle();\n                break;\n        }\n        return rotate ? anchor.rotate(center, -angle) : anchor;\n    }\n    // Can find anchor from model, when there is no selector or the link end\n    // is connected to a port\n    function _modelCenter(view, _magnet, _refPoint, opt, endType) {\n        return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n    }\n    //joint.anchors\n    var center = bboxWrapper(\"center\");\n    var top$2 = bboxWrapper(\"topMiddle\");\n    var bottom$2 = bboxWrapper(\"bottomMiddle\");\n    var left$2 = bboxWrapper(\"leftMiddle\");\n    var right$2 = bboxWrapper(\"rightMiddle\");\n    var topLeft = bboxWrapper(\"origin\");\n    var topRight = bboxWrapper(\"topRight\");\n    var bottomLeft = bboxWrapper(\"bottomLeft\");\n    var bottomRight = bboxWrapper(\"corner\");\n    var perpendicular = resolveRef(_perpendicular);\n    var midSide = resolveRef(_midSide);\n    var modelCenter = _modelCenter;\n    var anchors = {\n        center: center,\n        top: top$2,\n        bottom: bottom$2,\n        left: left$2,\n        right: right$2,\n        topLeft: topLeft,\n        topRight: topRight,\n        bottomLeft: bottomLeft,\n        bottomRight: bottomRight,\n        perpendicular: perpendicular,\n        midSide: midSide,\n        modelCenter: modelCenter\n    };\n    var sortingTypes = {\n        NONE: \"sorting-none\",\n        APPROX: \"sorting-approximate\",\n        EXACT: \"sorting-exact\"\n    };\n    var WHEEL_CAP = 50;\n    var WHEEL_WAIT_MS = 20;\n    var MOUNT_BATCH_SIZE = 1000;\n    var UPDATE_BATCH_SIZE = Infinity;\n    var MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER\n    var HighlightingTypes$1 = CellView.Highlighting;\n    var defaultHighlighting = {};\n    defaultHighlighting[HighlightingTypes$1.DEFAULT] = {\n        name: \"stroke\",\n        options: {\n            padding: 3\n        }\n    };\n    defaultHighlighting[HighlightingTypes$1.MAGNET_AVAILABILITY] = {\n        name: \"addClass\",\n        options: {\n            className: \"available-magnet\"\n        }\n    };\n    defaultHighlighting[HighlightingTypes$1.ELEMENT_AVAILABILITY] = {\n        name: \"addClass\",\n        options: {\n            className: \"available-cell\"\n        }\n    };\n    var defaultLayers = [\n        {\n            name: LayersNames.BACK\n        },\n        {\n            name: LayersNames.CELLS\n        },\n        {\n            name: LayersNames.LABELS\n        },\n        {\n            name: LayersNames.FRONT\n        },\n        {\n            name: LayersNames.TOOLS\n        }\n    ];\n    var Paper = View.extend({\n        className: \"paper\",\n        options: {\n            width: 800,\n            height: 600,\n            origin: {\n                x: 0,\n                y: 0\n            },\n            gridSize: 1,\n            // Whether or not to draw the grid lines on the paper's DOM element.\n            // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\n            drawGrid: false,\n            // If not set, the size of the visual grid is the same as the `gridSize`.\n            drawGridSize: null,\n            // Whether or not to draw the background on the paper's DOM element.\n            // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\n            background: false,\n            perpendicularLinks: false,\n            elementView: ElementView,\n            linkView: LinkView,\n            snapLabels: false,\n            snapLinks: false,\n            snapLinksSelf: false,\n            // Should the link labels be rendered into its own layer?\n            // `false` - the labels are part of the links\n            // `true` - the labels are appended to LayersName.LABELS\n            // [LayersName] - the labels are appended to the layer specified\n            labelsLayer: false,\n            // When set to FALSE, an element may not have more than 1 link with the same source and target element.\n            multiLinks: true,\n            // For adding custom guard logic.\n            guard: function(evt, view) {\n                // FALSE means the event isn't guarded.\n                return false;\n            },\n            highlighting: defaultHighlighting,\n            // Prevent the default context menu from being displayed.\n            preventContextMenu: true,\n            // Prevent the default action for blank:pointer<action>.\n            preventDefaultBlankAction: true,\n            // Prevent the default action for cell:pointer<action>.\n            preventDefaultViewAction: true,\n            // Restrict the translation of elements by given bounding box.\n            // Option accepts a boolean:\n            //  true - the translation is restricted to the paper area\n            //  false - no restrictions\n            // A method:\n            // restrictTranslate: function(elementView) {\n            //     var parentId = elementView.model.get('parent');\n            //     return parentId && this.model.getCell(parentId).getBBox();\n            // },\n            // Or a bounding box:\n            // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\n            restrictTranslate: false,\n            // Marks all available magnets with 'available-magnet' class name and all available cells with\n            // 'available-cell' class name. Marks them when dragging a link is started and unmark\n            // when the dragging is stopped.\n            markAvailable: false,\n            // Defines what link model is added to the graph after an user clicks on an active magnet.\n            // Value could be the Backbone.model or a function returning the Backbone.model\n            // defaultLink: function(elementView, magnet) { return condition ? new customLink1() : new customLink2() }\n            defaultLink: new Link,\n            // A connector that is used by links with no connector defined on the model.\n            // e.g. { name: 'rounded', args: { radius: 5 }} or a function\n            defaultConnector: {\n                name: \"normal\"\n            },\n            // A router that is used by links with no router defined on the model.\n            // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\n            defaultRouter: {\n                name: \"normal\"\n            },\n            defaultAnchor: {\n                name: \"center\"\n            },\n            defaultLinkAnchor: {\n                name: \"connectionRatio\"\n            },\n            defaultConnectionPoint: {\n                name: \"bbox\"\n            },\n            /* CONNECTING */ connectionStrategy: null,\n            // Check whether to add a new link to the graph when user clicks on an a magnet.\n            validateMagnet: function(_cellView, magnet, _evt) {\n                return magnet.getAttribute(\"magnet\") !== \"passive\";\n            },\n            // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\n            // being changed.\n            validateConnection: function(cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {\n                return (end === \"target\" ? cellViewT : cellViewS) instanceof ElementView;\n            },\n            /* EMBEDDING */ // Enables embedding. Re-parent the dragged element with elements under it and makes sure that\n            // all links and elements are visible taken the level of embedding into account.\n            embeddingMode: false,\n            // Check whether to allow or disallow the element embedding while an element being translated.\n            validateEmbedding: function(childView, parentView) {\n                // by default all elements can be in relation child-parent\n                return true;\n            },\n            // Check whether to allow or disallow an embedded element to be unembedded / to become a root.\n            validateUnembedding: function(childView) {\n                // by default all elements can become roots\n                return true;\n            },\n            // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\n            // The cell with the highest z-index (visually on the top) will be chosen.\n            findParentBy: \"bbox\",\n            // If enabled only the element on the very front is taken into account for the embedding.\n            // If disabled the elements under the dragged view are tested one by one\n            // (from front to back) until a valid parent found.\n            frontParentOnly: true,\n            // Interactive flags. See online docs for the complete list of interactive flags.\n            interactive: {\n                labelMove: false\n            },\n            // When set to true the links can be pinned to the paper.\n            // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\n            linkPinning: true,\n            // Custom validation after an interaction with a link ends.\n            // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)\n            // (linkView, paper) => boolean\n            allowLink: null,\n            // Allowed number of mousemove events after which the pointerclick event will be still triggered.\n            clickThreshold: 0,\n            // Number of required mousemove events before the first pointermove event will be triggered.\n            moveThreshold: 0,\n            // Number of required mousemove events before a link is created out of the magnet.\n            // Or string `onleave` so the link is created when the pointer leaves the magnet\n            magnetThreshold: 0,\n            // Rendering Options\n            sorting: sortingTypes.EXACT,\n            frozen: false,\n            autoFreeze: false,\n            // no docs yet\n            onViewUpdate: function(view, flag, priority, opt, paper) {\n                // Do not update connected links when:\n                // 1. the view was just inserted (added to the graph and rendered)\n                // 2. the view was just mounted (added back to the paper by viewport function)\n                // 3. the change was marked as `isolate`.\n                // 4. the view model was just removed from the graph\n                if (flag & (view.FLAG_INSERT | view.FLAG_REMOVE) || opt.mounting || opt.isolate) return;\n                paper.requestConnectedLinksUpdate(view, priority, opt);\n            },\n            // no docs yet\n            onViewPostponed: function(view, flag, paper) {\n                return paper.forcePostponedViewUpdate(view, flag);\n            },\n            beforeRender: null,\n            afterRender: null,\n            viewport: null,\n            // Default namespaces\n            cellViewNamespace: null,\n            routerNamespace: null,\n            connectorNamespace: null,\n            highlighterNamespace: highlighters,\n            anchorNamespace: anchors,\n            linkAnchorNamespace: linkAnchors,\n            connectionPointNamespace: connectionPoints,\n            overflow: false\n        },\n        events: {\n            \"dblclick\": \"pointerdblclick\",\n            \"dbltap\": \"pointerdblclick\",\n            \"contextmenu\": \"contextmenu\",\n            \"mousedown\": \"pointerdown\",\n            \"touchstart\": \"pointerdown\",\n            \"mouseover\": \"mouseover\",\n            \"mouseout\": \"mouseout\",\n            \"mouseenter\": \"mouseenter\",\n            \"mouseleave\": \"mouseleave\",\n            \"wheel\": \"mousewheel\",\n            \"mouseenter .joint-cell\": \"mouseenter\",\n            \"mouseleave .joint-cell\": \"mouseleave\",\n            \"mouseenter .joint-tools\": \"mouseenter\",\n            \"mouseleave .joint-tools\": \"mouseleave\",\n            \"dblclick .joint-cell [magnet]\": \"magnetpointerdblclick\",\n            \"contextmenu .joint-cell [magnet]\": \"magnetcontextmenu\",\n            \"mousedown .joint-link .label\": \"onlabel\",\n            \"touchstart .joint-link .label\": \"onlabel\",\n            \"dragstart .joint-cell image\": \"onImageDragStart\" // firefox fix\n        },\n        documentEvents: {\n            \"mousemove\": \"pointermove\",\n            \"touchmove\": \"pointermove\",\n            \"mouseup\": \"pointerup\",\n            \"touchend\": \"pointerup\",\n            \"touchcancel\": \"pointerup\"\n        },\n        svg: null,\n        viewport: null,\n        defs: null,\n        tools: null,\n        $background: null,\n        layers: null,\n        $grid: null,\n        $document: null,\n        // For storing the current transformation matrix (CTM) of the paper's viewport.\n        _viewportMatrix: null,\n        // For verifying whether the CTM is up-to-date. The viewport transform attribute\n        // could have been manipulated directly.\n        _viewportTransformString: null,\n        // Updates data (priorities, unmounted views etc.)\n        _updates: null,\n        // Paper Layers\n        _layers: null,\n        SORT_DELAYING_BATCHES: [\n            \"add\",\n            \"to-front\",\n            \"to-back\"\n        ],\n        UPDATE_DELAYING_BATCHES: [\n            \"translate\"\n        ],\n        // If you interact with these elements,\n        // the default interaction such as `element move` is prevented.\n        FORM_CONTROL_TAG_NAMES: [\n            \"TEXTAREA\",\n            \"INPUT\",\n            \"BUTTON\",\n            \"SELECT\",\n            \"OPTION\"\n        ],\n        // If you interact with these elements, the events are not propagated to the paper\n        // i.e. paper events such as `element:pointerdown` are not triggered.\n        GUARDED_TAG_NAMES: [\n            // Guard <select> for consistency. When you click on it:\n            // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open\n            // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).\n            //          on close. However, if you open and then close by clicking elsewhere on the page,\n            //           no other event is triggered.\n            // Safari: when you open it, it triggers `pointerdown`. That's it.\n            \"SELECT\"\n        ],\n        MIN_SCALE: 1e-6,\n        init: function() {\n            var ref = this;\n            var options = ref.options;\n            var el = ref.el;\n            if (!options.cellViewNamespace) /* eslint-disable no-undef */ options.cellViewNamespace = typeof joint !== \"undefined\" && has$2(joint, \"shapes\") ? joint.shapes : null;\n            var model = this.model = options.model || new Graph;\n            // Layers (SVGGroups)\n            this._layers = {};\n            this.setGrid(options.drawGrid);\n            this.cloneOptions();\n            this.render();\n            this._setDimensions();\n            this.startListening();\n            // Hash of all cell views.\n            this._views = {};\n            // Mouse wheel events buffer\n            this._mw_evt_buffer = {\n                event: null,\n                deltas: []\n            };\n            // Reference to the paper owner document\n            this.$document = $(el.ownerDocument);\n            // Render existing cells in the graph\n            this.resetViews(model.attributes.cells.models);\n            // Start the Rendering Loop\n            if (!this.isFrozen() && this.isAsync()) this.updateViewsAsync();\n        },\n        _resetUpdates: function() {\n            return this._updates = {\n                id: null,\n                priorities: [\n                    {},\n                    {},\n                    {}\n                ],\n                unmountedCids: [],\n                mountedCids: [],\n                unmounted: {},\n                mounted: {},\n                count: 0,\n                keyFrozen: false,\n                freezeKey: null,\n                sort: false,\n                disabled: false,\n                idle: false\n            };\n        },\n        startListening: function() {\n            var model = this.model;\n            this.listenTo(model, \"add\", this.onCellAdded).listenTo(model, \"remove\", this.onCellRemoved).listenTo(model, \"change\", this.onCellChange).listenTo(model, \"reset\", this.onGraphReset).listenTo(model, \"sort\", this.onGraphSort).listenTo(model, \"batch:stop\", this.onGraphBatchStop);\n            this.on(\"cell:highlight\", this.onCellHighlight).on(\"cell:unhighlight\", this.onCellUnhighlight).on(\"scale translate\", this.update);\n        },\n        onCellAdded: function(cell, _, opt) {\n            var position = opt.position;\n            if (this.isAsync() || !isNumber(position)) this.renderView(cell, opt);\n            else {\n                if (opt.maxPosition === position) this.freeze({\n                    key: \"addCells\"\n                });\n                this.renderView(cell, opt);\n                if (position === 0) this.unfreeze({\n                    key: \"addCells\"\n                });\n            }\n        },\n        onCellRemoved: function(cell, _, opt) {\n            var view = this.findViewByModel(cell);\n            if (view) this.requestViewUpdate(view, view.FLAG_REMOVE, view.UPDATE_PRIORITY, opt);\n        },\n        onCellChange: function(cell, opt) {\n            if (cell === this.model.attributes.cells) return;\n            if (cell.hasChanged(\"z\") && this.options.sorting === sortingTypes.APPROX) {\n                var view = this.findViewByModel(cell);\n                if (view) this.requestViewUpdate(view, view.FLAG_INSERT, view.UPDATE_PRIORITY, opt);\n            }\n        },\n        onGraphReset: function(collection, opt) {\n            this.resetLayers();\n            this.resetViews(collection.models, opt);\n        },\n        onGraphSort: function() {\n            if (this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;\n            this.sortViews();\n        },\n        onGraphBatchStop: function(data) {\n            if (this.isFrozen()) return;\n            var name = data && data.batchName;\n            var graph = this.model;\n            if (!this.isAsync()) {\n                var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;\n                if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) this.updateViews(data);\n            }\n            var sortDelayingBatches = this.SORT_DELAYING_BATCHES;\n            if (sortDelayingBatches.includes(name) && !graph.hasActiveBatch(sortDelayingBatches)) this.sortViews();\n        },\n        cloneOptions: function() {\n            var ref = this;\n            var options = ref.options;\n            var defaultConnector = options.defaultConnector;\n            var defaultRouter = options.defaultRouter;\n            var defaultConnectionPoint = options.defaultConnectionPoint;\n            var defaultAnchor = options.defaultAnchor;\n            var defaultLinkAnchor = options.defaultLinkAnchor;\n            var origin = options.origin;\n            var highlighting = options.highlighting;\n            var cellViewNamespace = options.cellViewNamespace;\n            var interactive = options.interactive;\n            // Default cellView namespace for ES5\n            /* eslint-disable no-undef */ if (!cellViewNamespace && typeof joint !== \"undefined\" && has$2(joint, \"shapes\")) options.cellViewNamespace = joint.shapes;\n            /* eslint-enable no-undef */ // Here if a function was provided, we can not clone it, as this would result in loosing the function.\n            // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.\n            if (!isFunction(defaultConnector)) options.defaultConnector = cloneDeep(defaultConnector);\n            if (!isFunction(defaultRouter)) options.defaultRouter = cloneDeep(defaultRouter);\n            if (!isFunction(defaultConnectionPoint)) options.defaultConnectionPoint = cloneDeep(defaultConnectionPoint);\n            if (!isFunction(defaultAnchor)) options.defaultAnchor = cloneDeep(defaultAnchor);\n            if (!isFunction(defaultLinkAnchor)) options.defaultLinkAnchor = cloneDeep(defaultLinkAnchor);\n            if (isPlainObject(interactive)) options.interactive = assign({}, interactive);\n            if (isPlainObject(highlighting)) // Return the default highlighting options into the user specified options.\n            options.highlighting = defaultsDeep({}, highlighting, defaultHighlighting);\n            options.origin = assign({}, origin);\n        },\n        children: function() {\n            var ns = V.namespace;\n            return [\n                {\n                    namespaceURI: ns.xhtml,\n                    tagName: \"div\",\n                    className: addClassNamePrefix(\"paper-background\"),\n                    selector: \"background\"\n                },\n                {\n                    namespaceURI: ns.xhtml,\n                    tagName: \"div\",\n                    className: addClassNamePrefix(\"paper-grid\"),\n                    selector: \"grid\"\n                },\n                {\n                    namespaceURI: ns.svg,\n                    tagName: \"svg\",\n                    attributes: {\n                        \"width\": \"100%\",\n                        \"height\": \"100%\",\n                        \"xmlns:xlink\": ns.xlink\n                    },\n                    selector: \"svg\",\n                    children: [\n                        {\n                            // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\n                            // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).\n                            tagName: \"defs\",\n                            selector: \"defs\"\n                        },\n                        {\n                            tagName: \"g\",\n                            className: addClassNamePrefix(\"layers\"),\n                            selector: \"layers\"\n                        }\n                    ]\n                }\n            ];\n        },\n        hasLayerView: function hasLayerView(layerName) {\n            return layerName in this._layers;\n        },\n        getLayerView: function getLayerView(layerName) {\n            var ref = this;\n            var _layers = ref._layers;\n            if (layerName in _layers) return _layers[layerName];\n            throw new Error('dia.Paper: Unknown layer \"' + layerName + '\"');\n        },\n        getLayerNode: function getLayerNode(layerName) {\n            return this.getLayerView(layerName).el;\n        },\n        render: function() {\n            this.renderChildren();\n            var ref = this;\n            var childNodes = ref.childNodes;\n            var options = ref.options;\n            var svg = childNodes.svg;\n            var defs = childNodes.defs;\n            var layers = childNodes.layers;\n            var background = childNodes.background;\n            var grid = childNodes.grid;\n            svg.style.overflow = options.overflow ? \"visible\" : \"hidden\";\n            this.svg = svg;\n            this.defs = defs;\n            this.layers = layers;\n            this.$background = $(background);\n            this.$grid = $(grid);\n            this.renderLayers();\n            V.ensureId(svg);\n            if (options.background) this.drawBackground(options.background);\n            if (options.drawGrid) this.drawGrid();\n            return this;\n        },\n        renderLayers: function(layers) {\n            var this$1 = this;\n            if (layers === void 0) layers = defaultLayers;\n            this.removeLayers();\n            // TODO: Layers to be read from the graph `layers` attribute\n            layers.forEach(function(ref) {\n                var name = ref.name;\n                var sorted = ref.sorted;\n                var layerView = new PaperLayer({\n                    name: name\n                });\n                this$1.layers.appendChild(layerView.el);\n                this$1._layers[name] = layerView;\n            });\n            // Throws an exception if doesn't exist\n            var cellsLayerView = this.getLayerView(LayersNames.CELLS);\n            var toolsLayerView = this.getLayerView(LayersNames.TOOLS);\n            var labelsLayerView = this.getLayerView(LayersNames.LABELS);\n            // backwards compatibility\n            this.tools = toolsLayerView.el;\n            this.cells = this.viewport = cellsLayerView.el;\n            // user-select: none;\n            cellsLayerView.vel.addClass(addClassNamePrefix(\"viewport\"));\n            labelsLayerView.vel.addClass(addClassNamePrefix(\"viewport\"));\n        },\n        removeLayers: function() {\n            var ref = this;\n            var _layers = ref._layers;\n            Object.keys(_layers).forEach(function(name) {\n                _layers[name].remove();\n                delete _layers[name];\n            });\n        },\n        resetLayers: function() {\n            var ref = this;\n            var _layers = ref._layers;\n            Object.keys(_layers).forEach(function(name) {\n                _layers[name].removePivots();\n            });\n        },\n        update: function() {\n            if (this.options.drawGrid) this.drawGrid();\n            if (this._background) this.updateBackgroundImage(this._background);\n            return this;\n        },\n        matrix: function(ctm) {\n            var viewport = this.layers;\n            // Getter:\n            if (ctm === undefined) {\n                var transformString = viewport.getAttribute(\"transform\");\n                if ((this._viewportTransformString || null) === transformString) // It's ok to return the cached matrix. The transform attribute has not changed since\n                // the matrix was stored.\n                ctm = this._viewportMatrix;\n                else {\n                    // The viewport transform attribute has changed. Measure the matrix and cache again.\n                    ctm = viewport.getCTM();\n                    this._viewportMatrix = ctm;\n                    this._viewportTransformString = transformString;\n                }\n                // Clone the cached current transformation matrix.\n                // If no matrix previously stored the identity matrix is returned.\n                return V.createSVGMatrix(ctm);\n            }\n            // Setter:\n            ctm = V.createSVGMatrix(ctm);\n            var ctmString = V.matrixToTransformString(ctm);\n            viewport.setAttribute(\"transform\", ctmString);\n            this._viewportMatrix = ctm;\n            this._viewportTransformString = viewport.getAttribute(\"transform\");\n            return this;\n        },\n        clientMatrix: function() {\n            return V.createSVGMatrix(this.cells.getScreenCTM());\n        },\n        requestConnectedLinksUpdate: function(view, priority, opt) {\n            if (view instanceof CellView) {\n                var model = view.model;\n                var links = this.model.getConnectedLinks(model);\n                for(var j = 0, n = links.length; j < n; j++){\n                    var link = links[j];\n                    var linkView = this.findViewByModel(link);\n                    if (!linkView) continue;\n                    var flagLabels = [\n                        \"UPDATE\"\n                    ];\n                    if (link.getTargetCell() === model) flagLabels.push(\"TARGET\");\n                    if (link.getSourceCell() === model) flagLabels.push(\"SOURCE\");\n                    var nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);\n                    this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);\n                }\n            }\n        },\n        forcePostponedViewUpdate: function(view, flag) {\n            if (!view || !(view instanceof CellView)) return false;\n            var model = view.model;\n            if (model.isElement()) return false;\n            if ((flag & view.getFlag([\n                \"SOURCE\",\n                \"TARGET\"\n            ])) === 0) {\n                var dumpOptions = {\n                    silent: true\n                };\n                // LinkView is waiting for the target or the source cellView to be rendered\n                // This can happen when the cells are not in the viewport.\n                var sourceFlag = 0;\n                var sourceView = this.findViewByModel(model.getSourceCell());\n                if (sourceView && !this.isViewMounted(sourceView)) {\n                    sourceFlag = this.dumpView(sourceView, dumpOptions);\n                    view.updateEndMagnet(\"source\");\n                }\n                var targetFlag = 0;\n                var targetView = this.findViewByModel(model.getTargetCell());\n                if (targetView && !this.isViewMounted(targetView)) {\n                    targetFlag = this.dumpView(targetView, dumpOptions);\n                    view.updateEndMagnet(\"target\");\n                }\n                if (sourceFlag === 0 && targetFlag === 0) // If leftover flag is 0, all view updates were done.\n                return !this.dumpView(view, dumpOptions);\n            }\n            return false;\n        },\n        requestViewUpdate: function(view, flag, priority, opt) {\n            opt || (opt = {});\n            this.scheduleViewUpdate(view, flag, priority, opt);\n            var isAsync = this.isAsync();\n            if (this.isFrozen() || isAsync && opt.async !== false) return;\n            if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;\n            var stats = this.updateViews(opt);\n            if (isAsync) this.notifyAfterRender(stats, opt);\n        },\n        scheduleViewUpdate: function(view, type, priority, opt) {\n            var ref = this;\n            var updates = ref._updates;\n            var options = ref.options;\n            if (updates.idle) {\n                if (options.autoFreeze) {\n                    updates.idle = false;\n                    this.unfreeze();\n                }\n            }\n            var FLAG_REMOVE = view.FLAG_REMOVE;\n            var FLAG_INSERT = view.FLAG_INSERT;\n            var UPDATE_PRIORITY = view.UPDATE_PRIORITY;\n            var cid = view.cid;\n            var priorityUpdates = updates.priorities[priority];\n            if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};\n            // Move higher priority updates to this priority\n            if (priority > UPDATE_PRIORITY) // Not the default priority for this view. It's most likely a link view\n            // connected to another link view, which triggered the update.\n            // TODO: If there is an update scheduled with a lower priority already, we should\n            // change the requested priority to the lowest one. Does not seem to be critical\n            // right now, as it \"only\" results in multiple updates on the same view.\n            for(var i = priority - 1; i >= UPDATE_PRIORITY; i--){\n                var prevPriorityUpdates = updates.priorities[i];\n                if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;\n                priorityUpdates[cid] |= prevPriorityUpdates[cid];\n                delete prevPriorityUpdates[cid];\n            }\n            var currentType = priorityUpdates[cid] || 0;\n            // Prevent cycling\n            if ((currentType & type) === type) return;\n            if (!currentType) updates.count++;\n            if (type & FLAG_REMOVE && currentType & FLAG_INSERT) // When a view is removed we need to remove the insert flag as this is a reinsert\n            priorityUpdates[cid] ^= FLAG_INSERT;\n            else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) // When a view is added we need to remove the remove flag as this is view was previously removed\n            priorityUpdates[cid] ^= FLAG_REMOVE;\n            priorityUpdates[cid] |= type;\n            var viewUpdateFn = options.onViewUpdate;\n            if (typeof viewUpdateFn === \"function\") viewUpdateFn.call(this, view, type, priority, opt || {}, this);\n        },\n        dumpViewUpdate: function(view) {\n            if (!view) return 0;\n            var updates = this._updates;\n            var cid = view.cid;\n            var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];\n            var flag = this.registerMountedView(view) | priorityUpdates[cid];\n            delete priorityUpdates[cid];\n            return flag;\n        },\n        dumpView: function(view, opt) {\n            if (opt === void 0) opt = {};\n            var flag = this.dumpViewUpdate(view);\n            if (!flag) return 0;\n            var shouldNotify = !opt.silent;\n            if (shouldNotify) this.notifyBeforeRender(opt);\n            var leftover = this.updateView(view, flag, opt);\n            if (shouldNotify) {\n                var stats = {\n                    updated: 1,\n                    priority: view.UPDATE_PRIORITY\n                };\n                this.notifyAfterRender(stats, opt);\n            }\n            return leftover;\n        },\n        updateView: function(view, flag, opt) {\n            if (!view) return 0;\n            var FLAG_REMOVE = view.FLAG_REMOVE;\n            var FLAG_INSERT = view.FLAG_INSERT;\n            var FLAG_INIT = view.FLAG_INIT;\n            var model = view.model;\n            if (view instanceof CellView) {\n                if (flag & FLAG_REMOVE) {\n                    this.removeView(model);\n                    return 0;\n                }\n                if (flag & FLAG_INSERT) {\n                    var isInitialInsert = !!(flag & FLAG_INIT);\n                    if (isInitialInsert) flag ^= FLAG_INIT;\n                    this.insertView(view, isInitialInsert);\n                    flag ^= FLAG_INSERT;\n                }\n            }\n            if (!flag) return 0;\n            return view.confirmUpdate(flag, opt || {});\n        },\n        requireView: function(model, opt) {\n            var view = this.findViewByModel(model);\n            if (!view) return null;\n            this.dumpView(view, opt);\n            return view;\n        },\n        registerUnmountedView: function(view) {\n            var cid = view.cid;\n            var updates = this._updates;\n            if (cid in updates.unmounted) return 0;\n            var flag = updates.unmounted[cid] |= view.FLAG_INSERT;\n            updates.unmountedCids.push(cid);\n            delete updates.mounted[cid];\n            return flag;\n        },\n        registerMountedView: function(view) {\n            var cid = view.cid;\n            var updates = this._updates;\n            if (cid in updates.mounted) return 0;\n            updates.mounted[cid] = true;\n            updates.mountedCids.push(cid);\n            var flag = updates.unmounted[cid] || 0;\n            delete updates.unmounted[cid];\n            return flag;\n        },\n        isViewMounted: function(view) {\n            if (!view) return false;\n            var cid = view.cid;\n            var updates = this._updates;\n            return cid in updates.mounted;\n        },\n        dumpViews: function(opt) {\n            var passingOpt = defaults({}, opt, {\n                viewport: null\n            });\n            this.checkViewport(passingOpt);\n            this.updateViews(passingOpt);\n        },\n        // Synchronous views update\n        updateViews: function(opt) {\n            this.notifyBeforeRender(opt);\n            var batchStats;\n            var updateCount = 0;\n            var batchCount = 0;\n            var priority = MIN_PRIORITY;\n            do {\n                batchCount++;\n                batchStats = this.updateViewsBatch(opt);\n                updateCount += batchStats.updated;\n                priority = Math.min(batchStats.priority, priority);\n            }while (!batchStats.empty);\n            var stats = {\n                updated: updateCount,\n                batches: batchCount,\n                priority: priority\n            };\n            this.notifyAfterRender(stats, opt);\n            return stats;\n        },\n        hasScheduledUpdates: function() {\n            var priorities = this._updates.priorities;\n            var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n            var i = priorityIndexes.length;\n            while(i > 0 && i--){\n                // a faster way how to check if an object is empty\n                for(var _key in priorities[priorityIndexes[i]])return true;\n            }\n            return false;\n        },\n        updateViewsAsync: function(opt, data) {\n            opt || (opt = {});\n            data || (data = {\n                processed: 0,\n                priority: MIN_PRIORITY\n            });\n            var ref = this;\n            var updates = ref._updates;\n            var options = ref.options;\n            var id = updates.id;\n            if (id) {\n                cancelFrame(id);\n                if (data.processed === 0 && this.hasScheduledUpdates()) this.notifyBeforeRender(opt);\n                var stats = this.updateViewsBatch(opt);\n                var passingOpt = defaults({}, opt, {\n                    mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,\n                    unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted\n                });\n                var checkStats = this.checkViewport(passingOpt);\n                var unmountCount = checkStats.unmounted;\n                var mountCount = checkStats.mounted;\n                var processed = data.processed;\n                var total = updates.count;\n                if (stats.updated > 0) {\n                    // Some updates have been just processed\n                    processed += stats.updated + stats.unmounted;\n                    stats.processed = processed;\n                    data.priority = Math.min(stats.priority, data.priority);\n                    if (stats.empty && mountCount === 0) {\n                        stats.unmounted += unmountCount;\n                        stats.mounted += mountCount;\n                        stats.priority = data.priority;\n                        this.notifyAfterRender(stats, opt);\n                        data.processed = 0;\n                        data.priority = MIN_PRIORITY;\n                        updates.count = 0;\n                    } else data.processed = processed;\n                } else {\n                    if (!updates.idle) {\n                        if (options.autoFreeze) {\n                            this.freeze();\n                            updates.idle = true;\n                            this.trigger(\"render:idle\", opt);\n                        }\n                    }\n                }\n                // Progress callback\n                var progressFn = opt.progress;\n                if (total && typeof progressFn === \"function\") progressFn.call(this, stats.empty, processed, total, stats, this);\n                // The current frame could have been canceled in a callback\n                if (updates.id !== id) return;\n            }\n            if (updates.disabled) throw new Error(\"dia.Paper: can not unfreeze the paper after it was removed\");\n            updates.id = nextFrame(this.updateViewsAsync, this, opt, data);\n        },\n        notifyBeforeRender: function(opt) {\n            if (opt === void 0) opt = {};\n            var beforeFn = opt.beforeRender;\n            if (typeof beforeFn !== \"function\") {\n                beforeFn = this.options.beforeRender;\n                if (typeof beforeFn !== \"function\") return;\n            }\n            beforeFn.call(this, opt, this);\n        },\n        notifyAfterRender: function(stats, opt) {\n            if (opt === void 0) opt = {};\n            var afterFn = opt.afterRender;\n            if (typeof afterFn !== \"function\") afterFn = this.options.afterRender;\n            if (typeof afterFn === \"function\") afterFn.call(this, stats, opt, this);\n            this.trigger(\"render:done\", stats, opt);\n        },\n        updateViewsBatch: function(opt) {\n            opt || (opt = {});\n            var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;\n            var updates = this._updates;\n            var updateCount = 0;\n            var postponeCount = 0;\n            var unmountCount = 0;\n            var mountCount = 0;\n            var maxPriority = MIN_PRIORITY;\n            var empty = true;\n            var options = this.options;\n            var priorities = updates.priorities;\n            var viewportFn = \"viewport\" in opt ? opt.viewport : options.viewport;\n            if (typeof viewportFn !== \"function\") viewportFn = null;\n            var postponeViewFn = options.onViewPostponed;\n            if (typeof postponeViewFn !== \"function\") postponeViewFn = null;\n            var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n            main: for(var i = 0, n = priorityIndexes.length; i < n; i++){\n                var priority = +priorityIndexes[i];\n                var priorityUpdates = priorities[priority];\n                for(var cid in priorityUpdates){\n                    if (updateCount >= batchSize) {\n                        empty = false;\n                        break main;\n                    }\n                    var view = views[cid];\n                    if (!view) {\n                        // This should not occur\n                        delete priorityUpdates[cid];\n                        continue;\n                    }\n                    var currentFlag = priorityUpdates[cid];\n                    if ((currentFlag & view.FLAG_REMOVE) === 0) {\n                        // We should never check a view for viewport if we are about to remove the view\n                        var isDetached = cid in updates.unmounted;\n                        if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, !isDetached, this)) {\n                            // Unmount View\n                            if (!isDetached) {\n                                this.registerUnmountedView(view);\n                                this.detachView(view);\n                            }\n                            updates.unmounted[cid] |= currentFlag;\n                            delete priorityUpdates[cid];\n                            unmountCount++;\n                            continue;\n                        }\n                        // Mount View\n                        if (isDetached) {\n                            currentFlag |= view.FLAG_INSERT;\n                            mountCount++;\n                        }\n                        currentFlag |= this.registerMountedView(view);\n                    }\n                    var leftoverFlag = this.updateView(view, currentFlag, opt);\n                    if (leftoverFlag > 0) {\n                        // View update has not finished completely\n                        priorityUpdates[cid] = leftoverFlag;\n                        if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {\n                            postponeCount++;\n                            empty = false;\n                            continue;\n                        }\n                    }\n                    if (maxPriority > priority) maxPriority = priority;\n                    updateCount++;\n                    delete priorityUpdates[cid];\n                }\n            }\n            return {\n                priority: maxPriority,\n                updated: updateCount,\n                postponed: postponeCount,\n                unmounted: unmountCount,\n                mounted: mountCount,\n                empty: empty\n            };\n        },\n        getUnmountedViews: function() {\n            var updates = this._updates;\n            var unmountedCids = Object.keys(updates.unmounted);\n            var n = unmountedCids.length;\n            var unmountedViews = new Array(n);\n            for(var i = 0; i < n; i++)unmountedViews[i] = views[unmountedCids[i]];\n            return unmountedViews;\n        },\n        getMountedViews: function() {\n            var updates = this._updates;\n            var mountedCids = Object.keys(updates.mounted);\n            var n = mountedCids.length;\n            var mountedViews = new Array(n);\n            for(var i = 0; i < n; i++)mountedViews[i] = views[mountedCids[i]];\n            return mountedViews;\n        },\n        checkUnmountedViews: function(viewportFn, opt) {\n            opt || (opt = {});\n            var mountCount = 0;\n            if (typeof viewportFn !== \"function\") viewportFn = null;\n            var batchSize = \"mountBatchSize\" in opt ? opt.mountBatchSize : Infinity;\n            var updates = this._updates;\n            var unmountedCids = updates.unmountedCids;\n            var unmounted = updates.unmounted;\n            for(var i = 0, n = Math.min(unmountedCids.length, batchSize); i < n; i++){\n                var cid = unmountedCids[i];\n                if (!(cid in unmounted)) continue;\n                var view = views[cid];\n                if (!view) continue;\n                if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, false, this)) {\n                    // Push at the end of all unmounted ids, so this can be check later again\n                    unmountedCids.push(cid);\n                    continue;\n                }\n                mountCount++;\n                var flag = this.registerMountedView(view);\n                if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, {\n                    mounting: true\n                });\n            }\n            // Get rid of views, that have been mounted\n            unmountedCids.splice(0, i);\n            return mountCount;\n        },\n        checkMountedViews: function(viewportFn, opt) {\n            opt || (opt = {});\n            var unmountCount = 0;\n            if (typeof viewportFn !== \"function\") return unmountCount;\n            var batchSize = \"unmountBatchSize\" in opt ? opt.unmountBatchSize : Infinity;\n            var updates = this._updates;\n            var mountedCids = updates.mountedCids;\n            var mounted = updates.mounted;\n            for(var i = 0, n = Math.min(mountedCids.length, batchSize); i < n; i++){\n                var cid = mountedCids[i];\n                if (!(cid in mounted)) continue;\n                var view = views[cid];\n                if (!view) continue;\n                if (!view.DETACHABLE || viewportFn.call(this, view, true, this)) {\n                    // Push at the end of all mounted ids, so this can be check later again\n                    mountedCids.push(cid);\n                    continue;\n                }\n                unmountCount++;\n                var flag = this.registerUnmountedView(view);\n                if (flag) this.detachView(view);\n            }\n            // Get rid of views, that have been unmounted\n            mountedCids.splice(0, i);\n            return unmountCount;\n        },\n        checkViewport: function(opt) {\n            var passingOpt = defaults({}, opt, {\n                mountBatchSize: Infinity,\n                unmountBatchSize: Infinity\n            });\n            var viewportFn = \"viewport\" in passingOpt ? passingOpt.viewport : this.options.viewport;\n            var unmountedCount = this.checkMountedViews(viewportFn, passingOpt);\n            if (unmountedCount > 0) {\n                // Do not check views, that have been just unmounted and pushed at the end of the cids array\n                var unmountedCids = this._updates.unmountedCids;\n                passingOpt.mountBatchSize = Math.min(unmountedCids.length - unmountedCount, passingOpt.mountBatchSize);\n            }\n            var mountedCount = this.checkUnmountedViews(viewportFn, passingOpt);\n            return {\n                mounted: mountedCount,\n                unmounted: unmountedCount\n            };\n        },\n        freeze: function(opt) {\n            opt || (opt = {});\n            var updates = this._updates;\n            var key = opt.key;\n            var isFrozen = this.options.frozen;\n            var freezeKey = updates.freezeKey;\n            if (key && key !== freezeKey) {\n                // key passed, but the paper is already freezed with another key\n                if (isFrozen && freezeKey) return;\n                updates.freezeKey = key;\n                updates.keyFrozen = isFrozen;\n            }\n            this.options.frozen = true;\n            var id = updates.id;\n            updates.id = null;\n            if (this.isAsync() && id) cancelFrame(id);\n        },\n        unfreeze: function(opt) {\n            opt || (opt = {});\n            var updates = this._updates;\n            var key = opt.key;\n            var freezeKey = updates.freezeKey;\n            // key passed, but the paper is already freezed with another key\n            if (key && freezeKey && key !== freezeKey) return;\n            updates.freezeKey = null;\n            // key passed, but the paper is already freezed\n            if (key && key === freezeKey && updates.keyFrozen) return;\n            if (this.isAsync()) {\n                this.freeze();\n                this.updateViewsAsync(opt);\n            } else this.updateViews(opt);\n            this.options.frozen = updates.keyFrozen = false;\n            if (updates.sort) {\n                this.sortViews();\n                updates.sort = false;\n            }\n        },\n        isAsync: function() {\n            return !!this.options.async;\n        },\n        isFrozen: function() {\n            return !!this.options.frozen;\n        },\n        isExactSorting: function() {\n            return this.options.sorting === sortingTypes.EXACT;\n        },\n        onRemove: function() {\n            this.freeze();\n            this._updates.disabled = true;\n            //clean up all DOM elements/views to prevent memory leaks\n            this.removeLayers();\n            this.removeViews();\n        },\n        getComputedSize: function() {\n            var options = this.options;\n            var w = options.width;\n            var h = options.height;\n            if (!isNumber(w)) w = this.el.clientWidth;\n            if (!isNumber(h)) h = this.el.clientHeight;\n            return {\n                width: w,\n                height: h\n            };\n        },\n        setDimensions: function(width, height) {\n            var ref = this;\n            var options = ref.options;\n            var currentWidth = options.width;\n            var currentHeight = options.height;\n            var w = width === undefined ? currentWidth : width;\n            var h = height === undefined ? currentHeight : height;\n            if (currentWidth === w && currentHeight === h) return;\n            options.width = w;\n            options.height = h;\n            this._setDimensions();\n            var computedSize = this.getComputedSize();\n            this.trigger(\"resize\", computedSize.width, computedSize.height);\n        },\n        _setDimensions: function() {\n            var ref = this;\n            var options = ref.options;\n            var w = options.width;\n            var h = options.height;\n            if (isNumber(w)) w = Math.round(w);\n            if (isNumber(h)) h = Math.round(h);\n            this.$el.css({\n                width: w === null ? \"\" : w,\n                height: h === null ? \"\" : h\n            });\n        },\n        setOrigin: function(ox, oy) {\n            return this.translate(ox || 0, oy || 0);\n        },\n        // Expand/shrink the paper to fit the content.\n        // Alternatively signature function(opt)\n        fitToContent: function(gridWidth, gridHeight, padding, opt) {\n            if (isObject$1(gridWidth)) // first parameter is an option object\n            opt = gridWidth;\n            else // Support for a deprecated signature\n            opt = assign({\n                gridWidth: gridWidth,\n                gridHeight: gridHeight,\n                padding: padding\n            }, opt);\n            var ref = this.getFitToContentArea(opt);\n            var x = ref.x;\n            var y = ref.y;\n            var width = ref.width;\n            var height = ref.height;\n            var ref$1 = this.scale();\n            var sx = ref$1.sx;\n            var sy = ref$1.sy;\n            this.setOrigin(-x * sx, -y * sy);\n            this.setDimensions(width * sx, height * sy);\n            return new Rect(x, y, width, height);\n        },\n        getFitToContentArea: function(opt) {\n            if (opt === void 0) opt = {};\n            // Calculate the paper size to accommodate all the graph's elements.\n            var gridWidth = opt.gridWidth || 1;\n            var gridHeight = opt.gridHeight || 1;\n            var padding = normalizeSides(opt.padding || 0);\n            var minWidth = Math.max(opt.minWidth || 0, gridWidth);\n            var minHeight = Math.max(opt.minHeight || 0, gridHeight);\n            var maxWidth = opt.maxWidth || Number.MAX_VALUE;\n            var maxHeight = opt.maxHeight || Number.MAX_VALUE;\n            var newOrigin = opt.allowNewOrigin;\n            var area = \"contentArea\" in opt ? new Rect(opt.contentArea) : this.getContentArea(opt);\n            var ref = this.scale();\n            var sx = ref.sx;\n            var sy = ref.sy;\n            area.x *= sx;\n            area.y *= sy;\n            area.width *= sx;\n            area.height *= sy;\n            var calcWidth = Math.ceil((area.width + area.x) / gridWidth);\n            var calcHeight = Math.ceil((area.height + area.y) / gridHeight);\n            if (!opt.allowNegativeBottomRight) {\n                calcWidth = Math.max(calcWidth, 1);\n                calcHeight = Math.max(calcHeight, 1);\n            }\n            calcWidth *= gridWidth;\n            calcHeight *= gridHeight;\n            var tx = 0;\n            if (newOrigin === \"negative\" && area.x < 0 || newOrigin === \"positive\" && area.x >= 0 || newOrigin === \"any\") {\n                tx = Math.ceil(-area.x / gridWidth) * gridWidth;\n                tx += padding.left;\n                calcWidth += tx;\n            }\n            var ty = 0;\n            if (newOrigin === \"negative\" && area.y < 0 || newOrigin === \"positive\" && area.y >= 0 || newOrigin === \"any\") {\n                ty = Math.ceil(-area.y / gridHeight) * gridHeight;\n                ty += padding.top;\n                calcHeight += ty;\n            }\n            calcWidth += padding.right;\n            calcHeight += padding.bottom;\n            // Make sure the resulting width and height are greater than minimum.\n            calcWidth = Math.max(calcWidth, minWidth);\n            calcHeight = Math.max(calcHeight, minHeight);\n            // Make sure the resulting width and height are lesser than maximum.\n            calcWidth = Math.min(calcWidth, maxWidth);\n            calcHeight = Math.min(calcHeight, maxHeight);\n            return new Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);\n        },\n        transformToFitContent: function(opt) {\n            opt || (opt = {});\n            var contentBBox, contentLocalOrigin;\n            if (\"contentArea\" in opt) {\n                var contentArea = opt.contentArea;\n                contentBBox = this.localToPaperRect(contentArea);\n                contentLocalOrigin = new Point(contentArea);\n            } else {\n                contentBBox = this.getContentBBox(opt);\n                contentLocalOrigin = this.paperToLocalPoint(contentBBox);\n            }\n            if (!contentBBox.width || !contentBBox.height) return;\n            defaults(opt, {\n                padding: 0,\n                preserveAspectRatio: true,\n                scaleGrid: null,\n                minScale: 0,\n                maxScale: Number.MAX_VALUE,\n                verticalAlign: \"top\",\n                horizontalAlign: \"left\"\n            });\n            var padding = normalizeSides(opt.padding);\n            var minScaleX = opt.minScaleX || opt.minScale;\n            var maxScaleX = opt.maxScaleX || opt.maxScale;\n            var minScaleY = opt.minScaleY || opt.minScale;\n            var maxScaleY = opt.maxScaleY || opt.maxScale;\n            var fittingBBox;\n            if (opt.fittingBBox) fittingBBox = opt.fittingBBox;\n            else {\n                var currentTranslate = this.translate();\n                var computedSize = this.getComputedSize();\n                fittingBBox = {\n                    x: currentTranslate.tx,\n                    y: currentTranslate.ty,\n                    width: computedSize.width,\n                    height: computedSize.height\n                };\n            }\n            fittingBBox = new Rect(fittingBBox).moveAndExpand({\n                x: padding.left,\n                y: padding.top,\n                width: -padding.left - padding.right,\n                height: -padding.top - padding.bottom\n            });\n            var currentScale = this.scale();\n            var newSx = fittingBBox.width / contentBBox.width * currentScale.sx;\n            var newSy = fittingBBox.height / contentBBox.height * currentScale.sy;\n            if (opt.preserveAspectRatio) newSx = newSy = Math.min(newSx, newSy);\n            // snap scale to a grid\n            if (opt.scaleGrid) {\n                var gridSize = opt.scaleGrid;\n                newSx = gridSize * Math.floor(newSx / gridSize);\n                newSy = gridSize * Math.floor(newSy / gridSize);\n            }\n            // scale min/max boundaries\n            newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\n            newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\n            var scaleDiff = {\n                x: newSx / currentScale.sx,\n                y: newSy / currentScale.sy\n            };\n            var origin = this.options.origin;\n            var newOx = fittingBBox.x - contentLocalOrigin.x * newSx - origin.x;\n            var newOy = fittingBBox.y - contentLocalOrigin.y * newSy - origin.y;\n            switch(opt.verticalAlign){\n                case \"middle\":\n                    newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;\n                    break;\n                case \"bottom\":\n                    newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);\n                    break;\n                case \"top\":\n                default:\n                    break;\n            }\n            switch(opt.horizontalAlign){\n                case \"middle\":\n                    newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;\n                    break;\n                case \"right\":\n                    newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);\n                    break;\n                case \"left\":\n                default:\n                    break;\n            }\n            this.scale(newSx, newSy);\n            this.translate(newOx, newOy);\n        },\n        scaleContentToFit: function(opt) {\n            this.transformToFitContent(opt);\n        },\n        // Return the dimensions of the content area in local units (without transformations).\n        getContentArea: function(opt) {\n            if (opt && opt.useModelGeometry) return this.model.getBBox() || new Rect();\n            return V(this.cells).getBBox();\n        },\n        // Return the dimensions of the content bbox in the paper units (as it appears on screen).\n        getContentBBox: function(opt) {\n            return this.localToPaperRect(this.getContentArea(opt));\n        },\n        // Returns a geometry rectangle representing the entire\n        // paper area (coordinates from the left paper border to the right one\n        // and the top border to the bottom one).\n        getArea: function() {\n            return this.paperToLocalRect(this.getComputedSize());\n        },\n        getRestrictedArea: function() {\n            var args = [], len = arguments.length;\n            while(len--)args[len] = arguments[len];\n            var ref = this.options;\n            var restrictTranslate = ref.restrictTranslate;\n            var restrictedArea;\n            if (isFunction(restrictTranslate)) // A method returning a bounding box\n            restrictedArea = restrictTranslate.apply(this, args);\n            else if (restrictTranslate === true) // The paper area\n            restrictedArea = this.getArea();\n            else if (!restrictTranslate) // falsy value\n            restrictedArea = null;\n            else // any other value\n            restrictedArea = new Rect(restrictTranslate);\n            return restrictedArea;\n        },\n        createViewForModel: function(cell) {\n            var ref = this;\n            var options = ref.options;\n            // A class taken from the paper options.\n            var optionalViewClass;\n            // A default basic class (either dia.ElementView or dia.LinkView)\n            var defaultViewClass;\n            // A special class defined for this model in the corresponding namespace.\n            // e.g. joint.shapes.basic.Rect searches for joint.shapes.basic.RectView\n            var namespace = options.cellViewNamespace;\n            var type = cell.get(\"type\") + \"View\";\n            var namespaceViewClass = getByPath(namespace, type, \".\");\n            if (cell.isLink()) {\n                optionalViewClass = options.linkView;\n                defaultViewClass = LinkView;\n            } else {\n                optionalViewClass = options.elementView;\n                defaultViewClass = ElementView;\n            }\n            // a) the paper options view is a class (deprecated)\n            //  1. search the namespace for a view\n            //  2. if no view was found, use view from the paper options\n            // b) the paper options view is a function\n            //  1. call the function from the paper options\n            //  2. if no view was return, search the namespace for a view\n            //  3. if no view was found, use the default\n            var ViewClass = optionalViewClass.prototype instanceof Backbone.View ? namespaceViewClass || optionalViewClass : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\n            return new ViewClass({\n                model: cell,\n                interactive: options.interactive,\n                labelsLayer: options.labelsLayer === true ? LayersNames.LABELS : options.labelsLayer\n            });\n        },\n        removeView: function(cell) {\n            var id = cell.id;\n            var ref = this;\n            var _views = ref._views;\n            var _updates = ref._updates;\n            var view = _views[id];\n            if (view) {\n                var cid = view.cid;\n                var mounted = _updates.mounted;\n                var unmounted = _updates.unmounted;\n                view.remove();\n                delete _views[id];\n                delete mounted[cid];\n                delete unmounted[cid];\n            }\n            return view;\n        },\n        renderView: function(cell, opt) {\n            var id = cell.id;\n            var views = this._views;\n            var view, flag;\n            var create = true;\n            if (id in views) {\n                view = views[id];\n                if (view.model === cell) {\n                    flag = view.FLAG_INSERT;\n                    create = false;\n                } else // The view for this `id` already exist.\n                // The cell is a new instance of the model with identical id\n                // We simply remove the existing view and create a new one\n                this.removeView(cell);\n            }\n            if (create) {\n                view = views[id] = this.createViewForModel(cell);\n                view.paper = this;\n                flag = this.registerUnmountedView(view) | this.FLAG_INIT | view.getFlag(result(view, \"initFlag\"));\n            }\n            this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);\n            return view;\n        },\n        onImageDragStart: function() {\n            // This is the only way to prevent image dragging in Firefox that works.\n            // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\n            return false;\n        },\n        resetViews: function(cells, opt) {\n            opt || (opt = {});\n            cells || (cells = []);\n            this._resetUpdates();\n            // clearing views removes any event listeners\n            this.removeViews();\n            // Allows to unfreeze normally while in the idle state using autoFreeze option\n            var key = this.options.autoFreeze ? null : \"reset\";\n            this.freeze({\n                key: key\n            });\n            for(var i = 0, n = cells.length; i < n; i++)this.renderView(cells[i], opt);\n            this.unfreeze({\n                key: key\n            });\n            this.sortViews();\n        },\n        removeViews: function() {\n            invoke(this._views, \"remove\");\n            this._views = {};\n        },\n        sortViews: function() {\n            if (!this.isExactSorting()) // noop\n            return;\n            if (this.isFrozen()) {\n                // sort views once unfrozen\n                this._updates.sort = true;\n                return;\n            }\n            this.sortViewsExact();\n        },\n        sortViewsExact: function() {\n            // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\n            // associated model `z` attribute.\n            var $cells = $(this.cells).children(\"[model-id]\");\n            var cells = this.model.get(\"cells\");\n            sortElements($cells, function(a, b) {\n                var cellA = cells.get(a.getAttribute(\"model-id\"));\n                var cellB = cells.get(b.getAttribute(\"model-id\"));\n                var zA = cellA.attributes.z || 0;\n                var zB = cellB.attributes.z || 0;\n                return zA === zB ? 0 : zA < zB ? -1 : 1;\n            });\n        },\n        insertView: function(view, isInitialInsert) {\n            var layerView = this.getLayerView(LayersNames.CELLS);\n            var el = view.el;\n            var model = view.model;\n            switch(this.options.sorting){\n                case sortingTypes.APPROX:\n                    layerView.insertSortedNode(el, model.get(\"z\"));\n                    break;\n                case sortingTypes.EXACT:\n                default:\n                    layerView.insertNode(el);\n                    break;\n            }\n            view.onMount(isInitialInsert);\n        },\n        detachView: function detachView(view) {\n            view.unmount();\n            view.onDetach();\n        },\n        scale: function(sx, sy, ox, oy) {\n            // getter\n            if (sx === undefined) return V.matrixToScale(this.matrix());\n            // setter\n            if (sy === undefined) sy = sx;\n            if (ox === undefined) {\n                ox = 0;\n                oy = 0;\n            }\n            var translate = this.translate();\n            if (ox || oy || translate.tx || translate.ty) {\n                var newTx = translate.tx - ox * (sx - 1);\n                var newTy = translate.ty - oy * (sy - 1);\n                this.translate(newTx, newTy);\n            }\n            sx = Math.max(sx || 0, this.MIN_SCALE);\n            sy = Math.max(sy || 0, this.MIN_SCALE);\n            var ctm = this.matrix();\n            ctm.a = sx;\n            ctm.d = sy;\n            this.matrix(ctm);\n            this.trigger(\"scale\", sx, sy, ox, oy);\n            return this;\n        },\n        // Experimental - do not use in production.\n        rotate: function(angle, cx, cy) {\n            // getter\n            if (angle === undefined) return V.matrixToRotate(this.matrix());\n            // setter\n            // If the origin is not set explicitely, rotate around the center. Note that\n            // we must use the plain bounding box (`this.el.getBBox()` instead of the one that gives us\n            // the real bounding box (`bbox()`) including transformations).\n            if (cx === undefined) {\n                var bbox = this.cells.getBBox();\n                cx = bbox.width / 2;\n                cy = bbox.height / 2;\n            }\n            var ctm = this.matrix().translate(cx, cy).rotate(angle).translate(-cx, -cy);\n            this.matrix(ctm);\n            return this;\n        },\n        translate: function(tx, ty) {\n            // getter\n            if (tx === undefined) return V.matrixToTranslate(this.matrix());\n            var ref = this;\n            var options = ref.options;\n            var origin = options.origin;\n            var drawGrid = options.drawGrid;\n            // setter\n            tx || (tx = 0);\n            ty || (ty = 0);\n            var ctm = this.matrix();\n            if (ctm.e === tx && ctm.f === ty) return this;\n            ctm.e = tx;\n            ctm.f = ty;\n            this.matrix(ctm);\n            var ref$1 = this.translate();\n            var ox = ref$1.tx;\n            var oy = ref$1.ty;\n            origin.x = ox;\n            origin.y = oy;\n            this.trigger(\"translate\", ox, oy);\n            if (drawGrid) this.drawGrid();\n            return this;\n        },\n        // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\n        // be a selector or a jQuery object.\n        findView: function($el) {\n            var el = isString($el) ? this.cells.querySelector($el) : $el instanceof $ ? $el[0] : $el;\n            var id = this.findAttribute(\"model-id\", el);\n            if (id) return this._views[id];\n            return undefined;\n        },\n        // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.\n        findViewByModel: function(cell) {\n            var id = isString(cell) || isNumber(cell) ? cell : cell && cell.id;\n            return this._views[id];\n        },\n        // Find all views at given point\n        findViewsFromPoint: function(p) {\n            p = new Point(p);\n            var views = this.model.getElements().map(this.findViewByModel, this);\n            return views.filter(function(view) {\n                return view && view.vel.getBBox({\n                    target: this.cells\n                }).containsPoint(p);\n            }, this);\n        },\n        // Find all views in given area\n        findViewsInArea: function(rect, opt) {\n            opt = defaults(opt || {}, {\n                strict: false\n            });\n            rect = new Rect(rect);\n            var views = this.model.getElements().map(this.findViewByModel, this);\n            var method = opt.strict ? \"containsRect\" : \"intersect\";\n            return views.filter(function(view) {\n                return view && rect[method](view.vel.getBBox({\n                    target: this.cells\n                }));\n            }, this);\n        },\n        removeTools: function() {\n            this.dispatchToolsEvent(\"remove\");\n            return this;\n        },\n        hideTools: function() {\n            this.dispatchToolsEvent(\"hide\");\n            return this;\n        },\n        showTools: function() {\n            this.dispatchToolsEvent(\"show\");\n            return this;\n        },\n        dispatchToolsEvent: function(event) {\n            var ref;\n            var args = [], len = arguments.length - 1;\n            while(len-- > 0)args[len] = arguments[len + 1];\n            if (typeof event !== \"string\") return;\n            (ref = this).trigger.apply(ref, [\n                \"tools:event\",\n                event\n            ].concat(args));\n        },\n        getModelById: function(id) {\n            return this.model.getCell(id);\n        },\n        snapToGrid: function(x, y) {\n            // Convert global coordinates to the local ones of the `viewport`. Otherwise,\n            // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\n            return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\n        },\n        localToPaperPoint: function(x, y) {\n            // allow `x` to be a point and `y` undefined\n            var localPoint = new Point(x, y);\n            var paperPoint = V.transformPoint(localPoint, this.matrix());\n            return paperPoint;\n        },\n        localToPaperRect: function(x, y, width, height) {\n            // allow `x` to be a rectangle and rest arguments undefined\n            var localRect = new Rect(x, y, width, height);\n            var paperRect = V.transformRect(localRect, this.matrix());\n            return paperRect;\n        },\n        paperToLocalPoint: function(x, y) {\n            // allow `x` to be a point and `y` undefined\n            var paperPoint = new Point(x, y);\n            var localPoint = V.transformPoint(paperPoint, this.matrix().inverse());\n            return localPoint;\n        },\n        paperToLocalRect: function(x, y, width, height) {\n            // allow `x` to be a rectangle and rest arguments undefined\n            var paperRect = new Rect(x, y, width, height);\n            var localRect = V.transformRect(paperRect, this.matrix().inverse());\n            return localRect;\n        },\n        localToClientPoint: function(x, y) {\n            // allow `x` to be a point and `y` undefined\n            var localPoint = new Point(x, y);\n            var clientPoint = V.transformPoint(localPoint, this.clientMatrix());\n            return clientPoint;\n        },\n        localToClientRect: function(x, y, width, height) {\n            // allow `x` to be a point and `y` undefined\n            var localRect = new Rect(x, y, width, height);\n            var clientRect = V.transformRect(localRect, this.clientMatrix());\n            return clientRect;\n        },\n        // Transform client coordinates to the paper local coordinates.\n        // Useful when you have a mouse event object and you'd like to get coordinates\n        // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\n        // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\n        clientToLocalPoint: function(x, y) {\n            // allow `x` to be a point and `y` undefined\n            var clientPoint = new Point(x, y);\n            var localPoint = V.transformPoint(clientPoint, this.clientMatrix().inverse());\n            return localPoint;\n        },\n        clientToLocalRect: function(x, y, width, height) {\n            // allow `x` to be a point and `y` undefined\n            var clientRect = new Rect(x, y, width, height);\n            var localRect = V.transformRect(clientRect, this.clientMatrix().inverse());\n            return localRect;\n        },\n        localToPagePoint: function(x, y) {\n            return this.localToPaperPoint(x, y).offset(this.pageOffset());\n        },\n        localToPageRect: function(x, y, width, height) {\n            return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());\n        },\n        pageToLocalPoint: function(x, y) {\n            var pagePoint = new Point(x, y);\n            var paperPoint = pagePoint.difference(this.pageOffset());\n            return this.paperToLocalPoint(paperPoint);\n        },\n        pageToLocalRect: function(x, y, width, height) {\n            var pageOffset = this.pageOffset();\n            var paperRect = new Rect(x, y, width, height);\n            paperRect.x -= pageOffset.x;\n            paperRect.y -= pageOffset.y;\n            return this.paperToLocalRect(paperRect);\n        },\n        clientOffset: function() {\n            var clientRect = this.svg.getBoundingClientRect();\n            return new Point(clientRect.left, clientRect.top);\n        },\n        pageOffset: function() {\n            return this.clientOffset().offset(window.scrollX, window.scrollY);\n        },\n        linkAllowed: function(linkView) {\n            if (!(linkView instanceof LinkView)) throw new Error(\"Must provide a linkView.\");\n            var link = linkView.model;\n            var paperOptions = this.options;\n            var graph = this.model;\n            var ns = graph.constructor.validations;\n            if (!paperOptions.multiLinks) {\n                if (!ns.multiLinks.call(this, graph, link)) return false;\n            }\n            if (!paperOptions.linkPinning) {\n                // Link pinning is not allowed and the link is not connected to the target.\n                if (!ns.linkPinning.call(this, graph, link)) return false;\n            }\n            if (typeof paperOptions.allowLink === \"function\") {\n                if (!paperOptions.allowLink.call(this, linkView, this)) return false;\n            }\n            return true;\n        },\n        getDefaultLink: function(cellView, magnet) {\n            return isFunction(this.options.defaultLink) ? this.options.defaultLink.call(this, cellView, magnet) : this.options.defaultLink.clone();\n        },\n        // Cell highlighting.\n        // ------------------\n        resolveHighlighter: function(opt) {\n            if (opt === void 0) opt = {};\n            var highlighterDef = opt.highlighter;\n            var type = opt.type;\n            var ref = this.options;\n            var highlighting = ref.highlighting;\n            var highlighterNamespace = ref.highlighterNamespace;\n            /*\n\t            Expecting opt.highlighter to have the following structure:\n\t            {\n\t                name: 'highlighter-name',\n\t                options: {\n\t                    some: 'value'\n\t                }\n\t            }\n\t        */ if (highlighterDef === undefined) {\n                // Is highlighting disabled?\n                if (!highlighting) return false;\n                // check for built-in types\n                if (type) {\n                    highlighterDef = highlighting[type];\n                    // Is a specific type highlight disabled?\n                    if (highlighterDef === false) return false;\n                }\n                if (!highlighterDef) // Type not defined use default highlight\n                highlighterDef = highlighting[\"default\"];\n            }\n            // Do nothing if opt.highlighter is falsy.\n            // This allows the case to not highlight cell(s) in certain cases.\n            // For example, if you want to NOT highlight when embedding elements\n            // or use a custom highlighter.\n            if (!highlighterDef) return false;\n            // Allow specifying a highlighter by name.\n            if (isString(highlighterDef)) highlighterDef = {\n                name: highlighterDef\n            };\n            var name = highlighterDef.name;\n            var highlighter = highlighterNamespace[name];\n            // Highlighter validation\n            if (!highlighter) throw new Error('Unknown highlighter (\"' + name + '\")');\n            if (typeof highlighter.highlight !== \"function\") throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\n            if (typeof highlighter.unhighlight !== \"function\") throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\n            return {\n                highlighter: highlighter,\n                options: highlighterDef.options || {},\n                name: name\n            };\n        },\n        onCellHighlight: function(cellView, magnetEl, opt) {\n            var highlighterDescriptor = this.resolveHighlighter(opt);\n            if (!highlighterDescriptor) return;\n            var highlighter = highlighterDescriptor.highlighter;\n            var options = highlighterDescriptor.options;\n            highlighter.highlight(cellView, magnetEl, options);\n        },\n        onCellUnhighlight: function(cellView, magnetEl, opt) {\n            var highlighterDescriptor = this.resolveHighlighter(opt);\n            if (!highlighterDescriptor) return;\n            var highlighter = highlighterDescriptor.highlighter;\n            var options = highlighterDescriptor.options;\n            highlighter.unhighlight(cellView, magnetEl, options);\n        },\n        // Interaction.\n        // ------------\n        pointerdblclick: function(evt) {\n            evt.preventDefault();\n            // magnetpointerdblclick can stop propagation\n            evt = normalizeEvent(evt);\n            var view = this.findView(evt.target);\n            if (this.guard(evt, view)) return;\n            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n            if (view) view.pointerdblclick(evt, localPoint.x, localPoint.y);\n            else this.trigger(\"blank:pointerdblclick\", evt, localPoint.x, localPoint.y);\n        },\n        pointerclick: function(evt) {\n            // magnetpointerclick can stop propagation\n            var data = this.eventData(evt);\n            // Trigger event only if mouse has not moved.\n            if (data.mousemoved <= this.options.clickThreshold) {\n                evt = normalizeEvent(evt);\n                var view = this.findView(evt.target);\n                if (this.guard(evt, view)) return;\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                if (view) view.pointerclick(evt, localPoint.x, localPoint.y);\n                else this.trigger(\"blank:pointerclick\", evt, localPoint.x, localPoint.y);\n            }\n        },\n        contextmenu: function(evt) {\n            if (this.options.preventContextMenu) evt.preventDefault();\n            if (this.contextMenuFired) {\n                this.contextMenuFired = false;\n                return;\n            }\n            evt = normalizeEvent(evt);\n            this.contextMenuTrigger(evt);\n        },\n        contextMenuTrigger: function(evt) {\n            var view = this.findView(evt.target);\n            if (this.guard(evt, view)) return;\n            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n            if (view) view.contextmenu(evt, localPoint.x, localPoint.y);\n            else this.trigger(\"blank:contextmenu\", evt, localPoint.x, localPoint.y);\n        },\n        pointerdown: function(evt) {\n            evt = normalizeEvent(evt);\n            var target = evt.target;\n            var button = evt.button;\n            var view = this.findView(target);\n            var isContextMenu = button === 2;\n            if (view) {\n                if (!isContextMenu && this.guard(evt, view)) return;\n                var isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);\n                if (this.options.preventDefaultViewAction && !isTargetFormNode) // If the target is a form element, we do not want to prevent the default action.\n                // For example, we want to be able to select text in a text input or\n                // to be able to click on a checkbox.\n                evt.preventDefault();\n                if (isTargetFormNode) // If the target is a form element, we do not want to start dragging the element.\n                // For example, we want to be able to select text by dragging the mouse.\n                view.preventDefaultInteraction(evt);\n                var rootViewEl = view.el;\n                // Custom event\n                var eventNode = target.closest(\"[event]\");\n                if (eventNode && rootViewEl !== eventNode && view.el.contains(eventNode)) {\n                    var eventEvt = normalizeEvent($.Event(evt.originalEvent, {\n                        data: evt.data,\n                        // Originally the event listener was attached to the event element.\n                        currentTarget: eventNode\n                    }));\n                    this.onevent(eventEvt);\n                    if (eventEvt.isDefaultPrevented()) evt.preventDefault();\n                    // `onevent` can stop propagation\n                    if (eventEvt.isPropagationStopped()) return;\n                    evt.data = eventEvt.data;\n                }\n                // Element magnet\n                var magnetNode = target.closest(\"[magnet]\");\n                if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {\n                    var magnetEvt = normalizeEvent($.Event(evt.originalEvent, {\n                        data: evt.data,\n                        // Originally the event listener was attached to the magnet element.\n                        currentTarget: magnetNode\n                    }));\n                    this.onmagnet(magnetEvt);\n                    if (magnetEvt.isDefaultPrevented()) evt.preventDefault();\n                    // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed\n                    if (magnetEvt.isPropagationStopped()) {\n                        // `magnet:pointermove` and `magnet:pointerup` events must be fired\n                        if (isContextMenu) return;\n                        this.delegateDragEvents(view, magnetEvt.data);\n                        return;\n                    }\n                    evt.data = magnetEvt.data;\n                }\n            }\n            if (isContextMenu) {\n                this.contextMenuFired = true;\n                var contextmenuEvt = $.Event(evt.originalEvent, {\n                    type: \"contextmenu\",\n                    data: evt.data\n                });\n                this.contextMenuTrigger(contextmenuEvt);\n            } else {\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                if (view) view.pointerdown(evt, localPoint.x, localPoint.y);\n                else {\n                    if (this.options.preventDefaultBlankAction) evt.preventDefault();\n                    this.trigger(\"blank:pointerdown\", evt, localPoint.x, localPoint.y);\n                }\n                this.delegateDragEvents(view, evt.data);\n            }\n        },\n        pointermove: function(evt) {\n            // mouse moved counter\n            var data = this.eventData(evt);\n            if (!data.mousemoved) {\n                data.mousemoved = 0;\n                // Make sure that events like `mouseenter` and `mouseleave` are\n                // not triggered while the user is dragging a cellView.\n                this.undelegateEvents();\n            // Note: the events are undelegated after the first `pointermove` event.\n            // Not on `pointerdown` to make sure that `dbltap` is recognized.\n            }\n            var mousemoved = ++data.mousemoved;\n            if (mousemoved <= this.options.moveThreshold) return;\n            evt = normalizeEvent(evt);\n            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n            var view = data.sourceView;\n            if (view) view.pointermove(evt, localPoint.x, localPoint.y);\n            else this.trigger(\"blank:pointermove\", evt, localPoint.x, localPoint.y);\n            this.eventData(evt, data);\n        },\n        pointerup: function(evt) {\n            this.undelegateDocumentEvents();\n            var normalizedEvt = normalizeEvent(evt);\n            var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n            var view = this.eventData(evt).sourceView;\n            if (view) view.pointerup(normalizedEvt, localPoint.x, localPoint.y);\n            else this.trigger(\"blank:pointerup\", normalizedEvt, localPoint.x, localPoint.y);\n            if (!normalizedEvt.isPropagationStopped()) this.pointerclick($.Event(evt.originalEvent, {\n                type: \"click\",\n                data: evt.data\n            }));\n            evt.stopImmediatePropagation();\n            this.delegateEvents();\n        },\n        mouseover: function(evt) {\n            evt = normalizeEvent(evt);\n            var view = this.findView(evt.target);\n            if (this.guard(evt, view)) return;\n            if (view) view.mouseover(evt);\n            else {\n                if (this.el === evt.target) return;\n                 // prevent border of paper from triggering this\n                this.trigger(\"blank:mouseover\", evt);\n            }\n        },\n        mouseout: function(evt) {\n            evt = normalizeEvent(evt);\n            var view = this.findView(evt.target);\n            if (this.guard(evt, view)) return;\n            if (view) view.mouseout(evt);\n            else {\n                if (this.el === evt.target) return;\n                 // prevent border of paper from triggering this\n                this.trigger(\"blank:mouseout\", evt);\n            }\n        },\n        mouseenter: function(evt) {\n            evt = normalizeEvent(evt);\n            var target = evt.target;\n            var relatedTarget = evt.relatedTarget;\n            var currentTarget = evt.currentTarget;\n            var view = this.findView(target);\n            if (this.guard(evt, view)) return;\n            var relatedView = this.findView(relatedTarget);\n            if (view) {\n                if (relatedView === view) // Mouse left a cell tool\n                return;\n                view.mouseenter(evt);\n                if (this.el.contains(relatedTarget)) // The pointer remains inside the paper.\n                return;\n            }\n            if (relatedView) return;\n            // prevent double `mouseenter` event if the `relatedTarget` is outside the paper\n            // (mouseenter method would be fired twice)\n            if (currentTarget === this.el) // `paper` (more descriptive), not `blank`\n            this.trigger(\"paper:mouseenter\", evt);\n        },\n        mouseleave: function(evt) {\n            evt = normalizeEvent(evt);\n            var target = evt.target;\n            var relatedTarget = evt.relatedTarget;\n            var currentTarget = evt.currentTarget;\n            var view = this.findView(target);\n            if (this.guard(evt, view)) return;\n            var relatedView = this.findView(relatedTarget);\n            if (view) {\n                if (relatedView === view) // Mouse entered a cell tool\n                return;\n                view.mouseleave(evt);\n                if (this.el.contains(relatedTarget)) // The pointer has exited a cellView. The pointer is still inside of the paper.\n                return;\n            }\n            if (relatedView) // The pointer has entered a new cellView\n            return;\n            // prevent double `mouseleave` event if the `relatedTarget` is outside the paper\n            // (mouseleave method would be fired twice)\n            if (currentTarget === this.el) // There is no cellView under the pointer, nor the blank area of the paper\n            this.trigger(\"paper:mouseleave\", evt);\n        },\n        _processMouseWheelEvtBuf: debounce(function() {\n            var ref = this._mw_evt_buffer;\n            var event = ref.event;\n            var deltas = ref.deltas;\n            var deltaY = deltas.reduce(function(acc, deltaY) {\n                return acc + cap(deltaY, WHEEL_CAP);\n            }, 0);\n            var scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom\n            var ref$1 = this.clientToLocalPoint(event.clientX, event.clientY);\n            var x = ref$1.x;\n            var y = ref$1.y;\n            this.trigger(\"paper:pinch\", event, x, y, scale);\n            this._mw_evt_buffer = {\n                event: null,\n                deltas: []\n            };\n        }, WHEEL_WAIT_MS, {\n            maxWait: WHEEL_WAIT_MS\n        }),\n        mousewheel: function(evt) {\n            evt = normalizeEvent(evt);\n            var view = this.findView(evt.target);\n            if (this.guard(evt, view)) return;\n            var originalEvent = evt.originalEvent;\n            var localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);\n            var ref = normalizeWheel(originalEvent);\n            var deltaX = ref.deltaX;\n            var deltaY = ref.deltaY;\n            var pinchHandlers = this._events[\"paper:pinch\"];\n            // Touchpad devices will send a fake CTRL press when a pinch is performed\n            //\n            // We also check if there are any subscribers to paper:pinch event. If there are none,\n            // just skip the entire block of code (we don't want to blindly call\n            // .preventDefault() if we really don't have to).\n            if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {\n                // This is a pinch gesture, it's safe to assume that we must call .preventDefault()\n                originalEvent.preventDefault();\n                this._mw_evt_buffer.event = originalEvent;\n                this._mw_evt_buffer.deltas.push(deltaY);\n                this._processMouseWheelEvtBuf();\n            } else {\n                var delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));\n                if (view) view.mousewheel(evt, localPoint.x, localPoint.y, delta);\n                else this.trigger(\"blank:mousewheel\", evt, localPoint.x, localPoint.y, delta);\n                this.trigger(\"paper:pan\", evt, deltaX, deltaY);\n            }\n        },\n        onevent: function(evt) {\n            var eventNode = evt.currentTarget;\n            var eventName = eventNode.getAttribute(\"event\");\n            if (eventName) {\n                var view = this.findView(eventNode);\n                if (view) {\n                    evt = normalizeEvent(evt);\n                    if (this.guard(evt, view)) return;\n                    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                    view.onevent(evt, eventName, localPoint.x, localPoint.y);\n                }\n            }\n        },\n        magnetEvent: function(evt, handler) {\n            var magnetNode = evt.currentTarget;\n            var magnetValue = magnetNode.getAttribute(\"magnet\");\n            if (magnetValue) {\n                var view = this.findView(magnetNode);\n                if (view) {\n                    evt = normalizeEvent(evt);\n                    if (this.guard(evt, view)) return;\n                    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                    handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);\n                }\n            }\n        },\n        onmagnet: function(evt) {\n            if (evt.button === 2) {\n                this.contextMenuFired = true;\n                this.magnetContextMenuFired = true;\n                var contextmenuEvt = $.Event(evt.originalEvent, {\n                    type: \"contextmenu\",\n                    data: evt.data,\n                    currentTarget: evt.currentTarget\n                });\n                this.magnetContextMenuTrigger(contextmenuEvt);\n                if (contextmenuEvt.isPropagationStopped()) evt.stopPropagation();\n            } else this.magnetEvent(evt, function(view, evt, _, x, y) {\n                view.onmagnet(evt, x, y);\n            });\n        },\n        magnetpointerdblclick: function(evt) {\n            this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n                view.magnetpointerdblclick(evt, magnet, x, y);\n            });\n        },\n        magnetcontextmenu: function(evt) {\n            if (this.options.preventContextMenu) evt.preventDefault();\n            if (this.magnetContextMenuFired) {\n                this.magnetContextMenuFired = false;\n                return;\n            }\n            this.magnetContextMenuTrigger(evt);\n        },\n        magnetContextMenuTrigger: function(evt) {\n            this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n                view.magnetcontextmenu(evt, magnet, x, y);\n            });\n        },\n        onlabel: function(evt) {\n            var labelNode = evt.currentTarget;\n            var view = this.findView(labelNode);\n            if (view) {\n                evt = normalizeEvent(evt);\n                if (this.guard(evt, view)) return;\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                view.onlabel(evt, localPoint.x, localPoint.y);\n            }\n        },\n        getPointerArgs: function getPointerArgs(evt) {\n            var normalizedEvt = normalizeEvent(evt);\n            var ref = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n            var x = ref.x;\n            var y = ref.y;\n            return [\n                normalizedEvt,\n                x,\n                y\n            ];\n        },\n        delegateDragEvents: function(view, data) {\n            data || (data = {});\n            this.eventData({\n                data: data\n            }, {\n                sourceView: view || null,\n                mousemoved: 0\n            });\n            this.delegateDocumentEvents(null, data);\n        },\n        // Guard the specified event. If the event should be ignored, guard returns `true`.\n        // Otherwise, it returns `false`.\n        guard: function(evt, view) {\n            if (evt.type === \"mousedown\" && evt.button === 2) // handled as `contextmenu` type\n            return true;\n            if (this.options.guard && this.options.guard(evt, view)) return true;\n            if (evt.data && evt.data.guarded !== undefined) return evt.data.guarded;\n            var target = evt.target;\n            if (this.GUARDED_TAG_NAMES.includes(target.tagName)) return true;\n            if (view && view.model && view.model instanceof Cell) return false;\n            if (this.svg === target || this.el === target || $.contains(this.svg, target)) return false;\n            return true; // Event guarded. Paper should not react on it in any way.\n        },\n        setGridSize: function(gridSize) {\n            var ref = this;\n            var options = ref.options;\n            options.gridSize = gridSize;\n            if (options.drawGrid && !options.drawGridSize) // Do not redraw the grid if the `drawGridSize` is set.\n            this.drawGrid();\n            return this;\n        },\n        clearGrid: function() {\n            if (this.$grid) this.$grid.css(\"backgroundImage\", \"none\");\n            return this;\n        },\n        _getGridRefs: function() {\n            if (!this._gridCache) this._gridCache = {\n                root: V(\"svg\", {\n                    width: \"100%\",\n                    height: \"100%\"\n                }, V(\"defs\")),\n                patterns: {},\n                add: function(id, vel) {\n                    V(this.root.node.childNodes[0]).append(vel);\n                    this.patterns[id] = vel;\n                    this.root.append(V(\"rect\", {\n                        width: \"100%\",\n                        height: \"100%\",\n                        fill: \"url(#\" + id + \")\"\n                    }));\n                },\n                get: function(id) {\n                    return this.patterns[id];\n                },\n                exist: function(id) {\n                    return this.patterns[id] !== undefined;\n                }\n            };\n            return this._gridCache;\n        },\n        setGrid: function(drawGrid) {\n            this.clearGrid();\n            this._gridCache = null;\n            this._gridSettings = [];\n            var optionsList = Array.isArray(drawGrid) ? drawGrid : [\n                drawGrid || {}\n            ];\n            optionsList.forEach(function(item) {\n                this._gridSettings.push.apply(this._gridSettings, this._resolveDrawGridOption(item));\n            }, this);\n            return this;\n        },\n        _resolveDrawGridOption: function(opt) {\n            var namespace = this.constructor.gridPatterns;\n            if (isString(opt) && Array.isArray(namespace[opt])) return namespace[opt].map(function(item) {\n                return assign({}, item);\n            });\n            var options = opt || {\n                args: [\n                    {}\n                ]\n            };\n            var isArray = Array.isArray(options);\n            var name = options.name;\n            if (!isArray && !name && !options.markup) name = \"dot\";\n            if (name && Array.isArray(namespace[name])) {\n                var pattern = namespace[name].map(function(item) {\n                    return assign({}, item);\n                });\n                var args = Array.isArray(options.args) ? options.args : [\n                    options.args || {}\n                ];\n                defaults(args[0], omit(opt, \"args\"));\n                for(var i = 0; i < args.length; i++)if (pattern[i]) assign(pattern[i], args[i]);\n                return pattern;\n            }\n            return isArray ? options : [\n                options\n            ];\n        },\n        drawGrid: function(opt) {\n            var gridSize = this.options.drawGridSize || this.options.gridSize;\n            if (gridSize <= 1) return this.clearGrid();\n            var localOptions = Array.isArray(opt) ? opt : [\n                opt\n            ];\n            var ctm = this.matrix();\n            var refs = this._getGridRefs();\n            this._gridSettings.forEach(function(gridLayerSetting, index) {\n                var id = \"pattern_\" + index;\n                var options = merge(gridLayerSetting, localOptions[index], {\n                    sx: ctm.a || 1,\n                    sy: ctm.d || 1,\n                    ox: ctm.e || 0,\n                    oy: ctm.f || 0\n                });\n                options.width = gridSize * (ctm.a || 1) * (options.scaleFactor || 1);\n                options.height = gridSize * (ctm.d || 1) * (options.scaleFactor || 1);\n                if (!refs.exist(id)) refs.add(id, V(\"pattern\", {\n                    id: id,\n                    patternUnits: \"userSpaceOnUse\"\n                }, V(options.markup)));\n                var patternDefVel = refs.get(id);\n                if (isFunction(options.update)) options.update(patternDefVel.node.childNodes[0], options);\n                var x = options.ox % options.width;\n                if (x < 0) x += options.width;\n                var y = options.oy % options.height;\n                if (y < 0) y += options.height;\n                patternDefVel.attr({\n                    x: x,\n                    y: y,\n                    width: options.width,\n                    height: options.height\n                });\n            });\n            var patternUri = new XMLSerializer().serializeToString(refs.root.node);\n            patternUri = \"url(data:image/svg+xml;base64,\" + btoa(patternUri) + \")\";\n            this.$grid.css(\"backgroundImage\", patternUri);\n            return this;\n        },\n        updateBackgroundImage: function(opt) {\n            opt = opt || {};\n            var backgroundPosition = opt.position || \"center\";\n            var backgroundSize = opt.size || \"auto auto\";\n            var currentScale = this.scale();\n            var currentTranslate = this.translate();\n            // backgroundPosition\n            if (isObject$1(backgroundPosition)) {\n                var x = currentTranslate.tx + currentScale.sx * (backgroundPosition.x || 0);\n                var y = currentTranslate.ty + currentScale.sy * (backgroundPosition.y || 0);\n                backgroundPosition = x + \"px \" + y + \"px\";\n            }\n            // backgroundSize\n            if (isObject$1(backgroundSize)) {\n                backgroundSize = new Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\n                backgroundSize = backgroundSize.width + \"px \" + backgroundSize.height + \"px\";\n            }\n            this.$background.css({\n                backgroundSize: backgroundSize,\n                backgroundPosition: backgroundPosition\n            });\n        },\n        drawBackgroundImage: function(img, opt) {\n            // Clear the background image if no image provided\n            if (!(img instanceof HTMLImageElement)) {\n                this.$background.css(\"backgroundImage\", \"\");\n                return;\n            }\n            if (!this._background || this._background.id !== opt.id) // Draw only the last image requested (see drawBackground())\n            return;\n            opt = opt || {};\n            var backgroundImage;\n            var backgroundSize = opt.size;\n            var backgroundRepeat = opt.repeat || \"no-repeat\";\n            var backgroundOpacity = opt.opacity || 1;\n            var backgroundQuality = Math.abs(opt.quality) || 1;\n            var backgroundPattern = this.constructor.backgroundPatterns[camelCase(backgroundRepeat)];\n            if (isFunction(backgroundPattern)) {\n                // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\n                img.width *= backgroundQuality;\n                img.height *= backgroundQuality;\n                var canvas = backgroundPattern(img, opt);\n                if (!(canvas instanceof HTMLCanvasElement)) throw new Error(\"dia.Paper: background pattern must return an HTML Canvas instance\");\n                backgroundImage = canvas.toDataURL(\"image/png\");\n                backgroundRepeat = \"repeat\";\n                if (isObject$1(backgroundSize)) {\n                    // recalculate the tile size if an object passed in\n                    backgroundSize.width *= canvas.width / img.width;\n                    backgroundSize.height *= canvas.height / img.height;\n                } else if (backgroundSize === undefined) // calculate the tile size if no provided\n                opt.size = {\n                    width: canvas.width / backgroundQuality,\n                    height: canvas.height / backgroundQuality\n                };\n            } else {\n                // backgroundRepeat:\n                // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\n                backgroundImage = img.src;\n                if (backgroundSize === undefined) // pass the image size for  the backgroundSize if no size provided\n                opt.size = {\n                    width: img.width,\n                    height: img.height\n                };\n            }\n            this.$background.css({\n                opacity: backgroundOpacity,\n                backgroundRepeat: backgroundRepeat,\n                backgroundImage: \"url(\" + backgroundImage + \")\"\n            });\n            this.updateBackgroundImage(opt);\n        },\n        updateBackgroundColor: function(color) {\n            this.$el.css(\"backgroundColor\", color || \"\");\n        },\n        drawBackground: function(opt) {\n            opt = opt || {};\n            this.updateBackgroundColor(opt.color);\n            if (opt.image) {\n                opt = this._background = cloneDeep(opt);\n                guid(opt);\n                var img = document.createElement(\"img\");\n                img.onload = this.drawBackgroundImage.bind(this, img, opt);\n                img.src = opt.image;\n            } else {\n                this.drawBackgroundImage(null);\n                this._background = null;\n            }\n            return this;\n        },\n        setInteractivity: function(value) {\n            this.options.interactive = value;\n            invoke(this._views, \"setInteractivity\", value);\n        },\n        // Paper definitions.\n        // ------------------\n        isDefined: function(defId) {\n            return !!this.svg.getElementById(defId);\n        },\n        defineFilter: function(filter$1) {\n            if (!isObject$1(filter$1)) throw new TypeError(\"dia.Paper: defineFilter() requires 1. argument to be an object.\");\n            var filterId = filter$1.id;\n            var name = filter$1.name;\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            if (!filterId) filterId = name + this.svg.id + hashCode(JSON.stringify(filter$1));\n            // If the filter already exists in the document,\n            // we're done and we can just use it (reference it using `url()`).\n            // If not, create one.\n            if (!this.isDefined(filterId)) {\n                var namespace = filter;\n                var filterSVGString = namespace[name] && namespace[name](filter$1.args || {});\n                if (!filterSVGString) throw new Error(\"Non-existing filter \" + name);\n                // Set the filter area to be 3x the bounding box of the cell\n                // and center the filter around the cell.\n                var filterAttrs = assign({\n                    filterUnits: \"objectBoundingBox\",\n                    x: -1,\n                    y: -1,\n                    width: 3,\n                    height: 3\n                }, filter$1.attrs, {\n                    id: filterId\n                });\n                V(filterSVGString, filterAttrs).appendTo(this.defs);\n            }\n            return filterId;\n        },\n        defineGradient: function(gradient) {\n            if (!isObject$1(gradient)) throw new TypeError(\"dia.Paper: defineGradient() requires 1. argument to be an object.\");\n            var ref = this;\n            var svg = ref.svg;\n            var defs = ref.defs;\n            var type = gradient.type;\n            var id = gradient.id;\n            if (id === void 0) id = type + svg.id + hashCode(JSON.stringify(gradient));\n            var stops = gradient.stops;\n            var attrs = gradient.attrs;\n            if (attrs === void 0) attrs = {};\n            // If the gradient already exists in the document,\n            // we're done and we can just use it (reference it using `url()`).\n            if (this.isDefined(id)) return id;\n            // If not, create one.\n            var stopVEls = toArray(stops).map(function(ref) {\n                var offset = ref.offset;\n                var color = ref.color;\n                var opacity = ref.opacity;\n                return V(\"stop\").attr({\n                    \"offset\": offset,\n                    \"stop-color\": color,\n                    \"stop-opacity\": Number.isFinite(opacity) ? opacity : 1\n                });\n            });\n            var gradientVEl = V(type, attrs, stopVEls);\n            gradientVEl.id = id;\n            gradientVEl.appendTo(defs);\n            return id;\n        },\n        definePattern: function(pattern) {\n            if (!isObject$1(pattern)) throw new TypeError(\"dia.Paper: definePattern() requires 1. argument to be an object.\");\n            var ref = this;\n            var svg = ref.svg;\n            var defs = ref.defs;\n            var id = pattern.id;\n            if (id === void 0) id = svg.id + hashCode(JSON.stringify(pattern));\n            var markup = pattern.markup;\n            var attrs = pattern.attrs;\n            if (attrs === void 0) attrs = {};\n            if (!markup) throw new TypeError(\"dia.Paper: definePattern() requires markup.\");\n            // If the gradient already exists in the document,\n            // we're done and we can just use it (reference it using `url()`).\n            if (this.isDefined(id)) return id;\n            // If not, create one.\n            var patternVEl = V(\"pattern\", {\n                patternUnits: \"userSpaceOnUse\"\n            });\n            patternVEl.id = id;\n            patternVEl.attr(attrs);\n            if (typeof markup === \"string\") patternVEl.append(V(markup));\n            else {\n                var ref$1 = parseDOMJSON(markup);\n                var fragment = ref$1.fragment;\n                patternVEl.append(fragment);\n            }\n            patternVEl.appendTo(defs);\n            return id;\n        },\n        defineMarker: function(marker) {\n            if (!isObject$1(marker)) throw new TypeError(\"dia.Paper: defineMarker() requires the first argument to be an object.\");\n            var ref = this;\n            var svg = ref.svg;\n            var defs = ref.defs;\n            var id = marker.id;\n            if (id === void 0) id = svg.id + hashCode(JSON.stringify(marker));\n            var markup = marker.markup;\n            var attrs = marker.attrs;\n            if (attrs === void 0) attrs = {};\n            var markerUnits = marker.markerUnits;\n            if (markerUnits === void 0) markerUnits = \"userSpaceOnUse\";\n            // If the marker already exists in the document,\n            // we're done and we can just use it (reference it using `url()`).\n            if (this.isDefined(id)) return id;\n            // If not, create one.\n            var markerVEl = V(\"marker\", {\n                orient: \"auto\",\n                overflow: \"visible\",\n                markerUnits: markerUnits\n            });\n            markerVEl.id = id;\n            markerVEl.attr(attrs);\n            var markerContentVEl;\n            if (markup) {\n                var markupVEl;\n                if (typeof markup === \"string\") {\n                    // Marker object has a `markup` property of type string.\n                    // - Construct V from the provided string.\n                    markupVEl = V(markup);\n                    // `markupVEl` is now either a single VEl, or an array of VEls.\n                    // - Coerce it to an array.\n                    markupVEl = Array.isArray(markupVEl) ? markupVEl : [\n                        markupVEl\n                    ];\n                } else {\n                    // Marker object has a `markup` property of type object.\n                    // - Construct V from the object by parsing it as DOM JSON.\n                    var ref$1 = parseDOMJSON(markup);\n                    var fragment = ref$1.fragment;\n                    markupVEl = V(fragment).children();\n                }\n                // `markupVEl` is an array with one or more VEls inside.\n                // - If there are multiple VEls, wrap them in a newly-constructed <g> element\n                if (markupVEl.length > 1) markerContentVEl = V(\"g\").append(markupVEl);\n                else markerContentVEl = markupVEl[0];\n            } else {\n                // Marker object is a flat structure.\n                // - Construct a new V of type `marker.type`.\n                var type = marker.type;\n                if (type === void 0) type = \"path\";\n                markerContentVEl = V(type);\n            }\n            // `markerContentVEl` is a single VEl.\n            // Assign additional attributes to it (= context attributes + marker attributes):\n            // - Attribute values are taken from non-special properties of `marker`.\n            var markerAttrs = omit(marker, \"type\", \"id\", \"markup\", \"attrs\", \"markerUnits\");\n            var markerAttrsKeys = Object.keys(markerAttrs);\n            markerAttrsKeys.forEach(function(key) {\n                var value = markerAttrs[key];\n                var markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority\n                if (markupValue == null) // Default logic:\n                markerContentVEl.attr(key, value);\n                else // Properties with special logic should be added as cases to this switch block:\n                switch(key){\n                    case \"transform\":\n                        // - Prepend `transform` to existing value.\n                        markerContentVEl.attr(key, value + \" \" + markupValue);\n                        break;\n                }\n            });\n            markerContentVEl.appendTo(markerVEl);\n            markerVEl.appendTo(defs);\n            return id;\n        }\n    }, {\n        sorting: sortingTypes,\n        Layers: LayersNames,\n        backgroundPatterns: {\n            flipXy: function(img) {\n                // d b\n                // q p\n                var canvas = document.createElement(\"canvas\");\n                var imgWidth = img.width;\n                var imgHeight = img.height;\n                canvas.width = 2 * imgWidth;\n                canvas.height = 2 * imgHeight;\n                var ctx = canvas.getContext(\"2d\");\n                // top-left image\n                ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n                // xy-flipped bottom-right image\n                ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\n                ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n                // x-flipped top-right image\n                ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\n                ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n                // y-flipped bottom-left image\n                ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n                ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n                return canvas;\n            },\n            flipX: function(img) {\n                // d b\n                // d b\n                var canvas = document.createElement(\"canvas\");\n                var imgWidth = img.width;\n                var imgHeight = img.height;\n                canvas.width = imgWidth * 2;\n                canvas.height = imgHeight;\n                var ctx = canvas.getContext(\"2d\");\n                // left image\n                ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n                // flipped right image\n                ctx.translate(2 * imgWidth, 0);\n                ctx.scale(-1, 1);\n                ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n                return canvas;\n            },\n            flipY: function(img) {\n                // d d\n                // q q\n                var canvas = document.createElement(\"canvas\");\n                var imgWidth = img.width;\n                var imgHeight = img.height;\n                canvas.width = imgWidth;\n                canvas.height = imgHeight * 2;\n                var ctx = canvas.getContext(\"2d\");\n                // top image\n                ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n                // flipped bottom image\n                ctx.translate(0, 2 * imgHeight);\n                ctx.scale(1, -1);\n                ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n                return canvas;\n            },\n            watermark: function(img, opt) {\n                //   d\n                // d\n                opt = opt || {};\n                var imgWidth = img.width;\n                var imgHeight = img.height;\n                var canvas = document.createElement(\"canvas\");\n                canvas.width = imgWidth * 3;\n                canvas.height = imgHeight * 3;\n                var ctx = canvas.getContext(\"2d\");\n                var angle = isNumber(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\n                var radians = toRad(angle);\n                var stepX = canvas.width / 4;\n                var stepY = canvas.height / 4;\n                for(var i = 0; i < 4; i++){\n                    for(var j = 0; j < 4; j++)if ((i + j) % 2 > 0) {\n                        // reset the current transformations\n                        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);\n                        ctx.rotate(radians);\n                        ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\n                    }\n                }\n                return canvas;\n            }\n        },\n        gridPatterns: {\n            dot: [\n                {\n                    color: \"#AAAAAA\",\n                    thickness: 1,\n                    markup: \"rect\",\n                    update: function(el, opt) {\n                        V(el).attr({\n                            width: opt.thickness * opt.sx,\n                            height: opt.thickness * opt.sy,\n                            fill: opt.color\n                        });\n                    }\n                }\n            ],\n            fixedDot: [\n                {\n                    color: \"#AAAAAA\",\n                    thickness: 1,\n                    markup: \"rect\",\n                    update: function(el, opt) {\n                        var size = opt.sx <= 1 ? opt.thickness * opt.sx : opt.thickness;\n                        V(el).attr({\n                            width: size,\n                            height: size,\n                            fill: opt.color\n                        });\n                    }\n                }\n            ],\n            mesh: [\n                {\n                    color: \"#AAAAAA\",\n                    thickness: 1,\n                    markup: \"path\",\n                    update: function(el, opt) {\n                        var d;\n                        var width = opt.width;\n                        var height = opt.height;\n                        var thickness = opt.thickness;\n                        if (width - thickness >= 0 && height - thickness >= 0) d = [\n                            \"M\",\n                            width,\n                            0,\n                            \"H0 M0 0 V0\",\n                            height\n                        ].join(\" \");\n                        else d = \"M 0 0 0 0\";\n                        V(el).attr({\n                            \"d\": d,\n                            stroke: opt.color,\n                            \"stroke-width\": opt.thickness\n                        });\n                    }\n                }\n            ],\n            doubleMesh: [\n                {\n                    color: \"#AAAAAA\",\n                    thickness: 1,\n                    markup: \"path\",\n                    update: function(el, opt) {\n                        var d;\n                        var width = opt.width;\n                        var height = opt.height;\n                        var thickness = opt.thickness;\n                        if (width - thickness >= 0 && height - thickness >= 0) d = [\n                            \"M\",\n                            width,\n                            0,\n                            \"H0 M0 0 V0\",\n                            height\n                        ].join(\" \");\n                        else d = \"M 0 0 0 0\";\n                        V(el).attr({\n                            \"d\": d,\n                            stroke: opt.color,\n                            \"stroke-width\": opt.thickness\n                        });\n                    }\n                },\n                {\n                    color: \"#000000\",\n                    thickness: 3,\n                    scaleFactor: 4,\n                    markup: \"path\",\n                    update: function(el, opt) {\n                        var d;\n                        var width = opt.width;\n                        var height = opt.height;\n                        var thickness = opt.thickness;\n                        if (width - thickness >= 0 && height - thickness >= 0) d = [\n                            \"M\",\n                            width,\n                            0,\n                            \"H0 M0 0 V0\",\n                            height\n                        ].join(\" \");\n                        else d = \"M 0 0 0 0\";\n                        V(el).attr({\n                            \"d\": d,\n                            stroke: opt.color,\n                            \"stroke-width\": opt.thickness\n                        });\n                    }\n                }\n            ]\n        }\n    });\n    var ToolView = View.extend({\n        name: null,\n        tagName: \"g\",\n        className: \"tool\",\n        svgElement: true,\n        _visible: true,\n        init: function() {\n            var name = this.name;\n            if (name) this.vel.attr(\"data-tool-name\", name);\n        },\n        configure: function(view, toolsView) {\n            this.relatedView = view;\n            this.paper = view.paper;\n            this.parentView = toolsView;\n            this.simulateRelatedView(this.el);\n            // Delegate events in case the ToolView was removed from the DOM and reused.\n            this.delegateEvents();\n            return this;\n        },\n        simulateRelatedView: function(el) {\n            if (el) el.setAttribute(\"model-id\", this.relatedView.model.id);\n        },\n        getName: function() {\n            return this.name;\n        },\n        show: function() {\n            this.el.style.display = \"\";\n            this._visible = true;\n        },\n        hide: function() {\n            this.el.style.display = \"none\";\n            this._visible = false;\n        },\n        isVisible: function() {\n            return !!this._visible;\n        },\n        focus: function() {\n            var opacity = this.options.focusOpacity;\n            if (isFinite(opacity)) this.el.style.opacity = opacity;\n            this.parentView.focusTool(this);\n        },\n        blur: function() {\n            this.el.style.opacity = \"\";\n            this.parentView.blurTool(this);\n        },\n        update: function() {\n        // to be overridden\n        },\n        guard: function(evt) {\n            // Let the context-menu event bubble up to the relatedView\n            var ref = this;\n            var paper = ref.paper;\n            var relatedView = ref.relatedView;\n            if (!paper || !relatedView) return true;\n            return paper.guard(evt, relatedView);\n        }\n    });\n    var ToolsView = View.extend({\n        tagName: \"g\",\n        className: \"tools\",\n        svgElement: true,\n        tools: null,\n        isRendered: false,\n        options: {\n            tools: null,\n            relatedView: null,\n            name: null\n        },\n        configure: function(options) {\n            options = assign(this.options, options);\n            var tools = options.tools;\n            if (!Array.isArray(tools)) return this;\n            var relatedView = options.relatedView;\n            if (!(relatedView instanceof CellView)) return this;\n            var views = this.tools = [];\n            for(var i = 0, n = tools.length; i < n; i++){\n                var tool = tools[i];\n                if (!(tool instanceof ToolView)) continue;\n                tool.configure(relatedView, this);\n                this.vel.append(tool.el);\n                views.push(tool);\n            }\n            this.isRendered = false;\n            relatedView.requestUpdate(relatedView.getFlag(\"TOOLS\"));\n            return this;\n        },\n        getName: function() {\n            return this.options.name;\n        },\n        update: function(opt) {\n            opt || (opt = {});\n            var tools = this.tools;\n            if (!tools) return this;\n            var isRendered = this.isRendered;\n            for(var i = 0, n = tools.length; i < n; i++){\n                var tool = tools[i];\n                if (!isRendered) // First update executes render()\n                tool.render();\n                else if (opt.tool !== tool.cid && tool.isVisible()) tool.update();\n            }\n            if (!this.isMounted()) this.mount();\n            if (!isRendered) {\n                // Make sure tools are visible (if they were hidden and the tool removed)\n                this.blurTool();\n                this.isRendered = true;\n            }\n            return this;\n        },\n        focusTool: function(focusedTool) {\n            var tools = this.tools;\n            if (!tools) return this;\n            for(var i = 0, n = tools.length; i < n; i++){\n                var tool = tools[i];\n                if (focusedTool === tool) tool.show();\n                else tool.hide();\n            }\n            return this;\n        },\n        blurTool: function(blurredTool) {\n            var tools = this.tools;\n            if (!tools) return this;\n            for(var i = 0, n = tools.length; i < n; i++){\n                var tool = tools[i];\n                if (tool !== blurredTool && !tool.isVisible()) {\n                    tool.show();\n                    tool.update();\n                }\n            }\n            return this;\n        },\n        hide: function() {\n            return this.focusTool(null);\n        },\n        show: function() {\n            return this.blurTool(null);\n        },\n        onRemove: function() {\n            var tools = this.tools;\n            if (!tools) return this;\n            for(var i = 0, n = tools.length; i < n; i++)tools[i].remove();\n            this.tools = null;\n        },\n        mount: function() {\n            var ref = this;\n            var options = ref.options;\n            var el = ref.el;\n            var relatedView = options.relatedView;\n            var layer = options.layer;\n            if (layer === void 0) layer = LayersNames.TOOLS;\n            var z = options.z;\n            if (relatedView) {\n                if (layer) relatedView.paper.getLayerView(layer).insertSortedNode(el, z);\n                else relatedView.el.appendChild(el);\n            }\n            return this;\n        },\n        isMounted: function() {\n            return this.el.parentNode !== null;\n        }\n    });\n    var index$2 = {\n        Graph: Graph,\n        attributes: attributes,\n        LayersNames: LayersNames,\n        PaperLayer: PaperLayer,\n        Cell: Cell,\n        CellView: CellView,\n        Element: Element$1,\n        ElementView: ElementView,\n        Link: Link,\n        LinkView: LinkView,\n        Paper: Paper,\n        ToolView: ToolView,\n        ToolsView: ToolsView,\n        HighlighterView: HighlighterView\n    };\n    var DirectedGraph = {\n        exportElement: function(element) {\n            // The width and height of the element.\n            return element.size();\n        },\n        exportLink: function(link) {\n            var labelSize = link.get(\"labelSize\") || {};\n            var edge = {\n                // The number of ranks to keep between the source and target of the edge.\n                minLen: link.get(\"minLen\") || 1,\n                // The weight to assign edges. Higher weight edges are generally\n                // made shorter and straighter than lower weight edges.\n                weight: link.get(\"weight\") || 1,\n                // Where to place the label relative to the edge.\n                // l = left, c = center r = right.\n                labelpos: link.get(\"labelPosition\") || \"c\",\n                // How many pixels to move the label away from the edge.\n                // Applies only when labelpos is l or r.\n                labeloffset: link.get(\"labelOffset\") || 0,\n                // The width of the edge label in pixels.\n                width: labelSize.width || 0,\n                // The height of the edge label in pixels.\n                height: labelSize.height || 0\n            };\n            return edge;\n        },\n        importElement: function(opt, v, gl) {\n            var element = this.getCell(v);\n            var glNode = gl.node(v);\n            if (opt.setPosition) opt.setPosition(element, glNode);\n            else element.set(\"position\", {\n                x: glNode.x - glNode.width / 2,\n                y: glNode.y - glNode.height / 2\n            });\n        },\n        importLink: function(opt, edgeObj, gl) {\n            var SIMPLIFY_THRESHOLD = 0.001;\n            var link = this.getCell(edgeObj.name);\n            var glEdge = gl.edge(edgeObj);\n            var points = glEdge.points || [];\n            var polyline = new Polyline(points);\n            // check the `setLinkVertices` here for backwards compatibility\n            if (opt.setVertices || opt.setLinkVertices) {\n                if (isFunction(opt.setVertices)) opt.setVertices(link, points);\n                else {\n                    // simplify the `points` polyline\n                    polyline.simplify({\n                        threshold: SIMPLIFY_THRESHOLD\n                    });\n                    var polylinePoints = polyline.points.map(function(point) {\n                        return point.toJSON();\n                    }); // JSON of points after simplification\n                    var numPolylinePoints = polylinePoints.length; // number of points after simplification\n                    // set simplified polyline points as link vertices\n                    // remove first and last polyline points (= source/target sonnectionPoints)\n                    link.set(\"vertices\", polylinePoints.slice(1, numPolylinePoints - 1));\n                }\n            }\n            if (opt.setLabels && \"x\" in glEdge && \"y\" in glEdge) {\n                var labelPosition = {\n                    x: glEdge.x,\n                    y: glEdge.y\n                };\n                if (isFunction(opt.setLabels)) opt.setLabels(link, labelPosition, points);\n                else {\n                    // convert the absolute label position to a relative position\n                    // towards the closest point on the edge\n                    var length = polyline.closestPointLength(labelPosition);\n                    var closestPoint = polyline.pointAtLength(length);\n                    var distance = length / polyline.length();\n                    var offset = new Point(labelPosition).difference(closestPoint).toJSON();\n                    link.label(0, {\n                        position: {\n                            distance: distance,\n                            offset: offset\n                        }\n                    });\n                }\n            }\n        },\n        layout: function(graphOrCells, opt) {\n            var graph;\n            if (graphOrCells instanceof Graph) graph = graphOrCells;\n            else // Reset cells in dry mode so the graph reference is not stored on the cells.\n            // `sort: false` to prevent elements to change their order based on the z-index\n            graph = new Graph().resetCells(graphOrCells, {\n                dry: true,\n                sort: false\n            });\n            // This is not needed anymore.\n            graphOrCells = null;\n            opt = defaults(opt || {}, {\n                resizeClusters: true,\n                clusterPadding: 10,\n                exportElement: this.exportElement,\n                exportLink: this.exportLink\n            });\n            /* eslint-disable no-undef */ var dagreUtil = opt.dagre || (typeof dagre !== \"undefined\" ? dagre : undefined);\n            /* eslint-enable no-undef */ if (dagreUtil === undefined) throw new Error('The the \"dagre\" utility is a mandatory dependency.');\n            // create a graphlib.Graph that represents the joint.dia.Graph\n            // var glGraph = graph.toGraphLib({\n            var glGraph = DirectedGraph.toGraphLib(graph, {\n                graphlib: opt.graphlib,\n                directed: true,\n                // We are about to use edge naming feature.\n                multigraph: true,\n                // We are able to layout graphs with embeds.\n                compound: true,\n                setNodeLabel: opt.exportElement,\n                setEdgeLabel: opt.exportLink,\n                setEdgeName: function(link) {\n                    // Graphlib edges have no ids. We use edge name property\n                    // to store and retrieve ids instead.\n                    return link.id;\n                }\n            });\n            var glLabel = {};\n            var marginX = opt.marginX || 0;\n            var marginY = opt.marginY || 0;\n            // Dagre layout accepts options as lower case.\n            // Direction for rank nodes. Can be TB, BT, LR, or RL\n            if (opt.rankDir) glLabel.rankdir = opt.rankDir;\n            // Alignment for rank nodes. Can be UL, UR, DL, or DR\n            if (opt.align) glLabel.align = opt.align;\n            // Number of pixels that separate nodes horizontally in the layout.\n            if (opt.nodeSep) glLabel.nodesep = opt.nodeSep;\n            // Number of pixels that separate edges horizontally in the layout.\n            if (opt.edgeSep) glLabel.edgesep = opt.edgeSep;\n            // Number of pixels between each rank in the layout.\n            if (opt.rankSep) glLabel.ranksep = opt.rankSep;\n            // Type of algorithm to assign a rank to each node in the input graph.\n            // Possible values: network-simplex, tight-tree or longest-path\n            if (opt.ranker) glLabel.ranker = opt.ranker;\n            // Number of pixels to use as a margin around the left and right of the graph.\n            if (marginX) glLabel.marginx = marginX;\n            // Number of pixels to use as a margin around the top and bottom of the graph.\n            if (marginY) glLabel.marginy = marginY;\n            // Set the option object for the graph label.\n            glGraph.setGraph(glLabel);\n            // Executes the layout.\n            dagreUtil.layout(glGraph, {\n                debugTiming: !!opt.debugTiming\n            });\n            // Wrap all graph changes into a batch.\n            graph.startBatch(\"layout\");\n            DirectedGraph.fromGraphLib(glGraph, {\n                importNode: this.importElement.bind(graph, opt),\n                importEdge: this.importLink.bind(graph, opt)\n            });\n            // // Update the graph.\n            // graph.fromGraphLib(glGraph, {\n            //     importNode: this.importElement.bind(graph, opt),\n            //     importEdge: this.importLink.bind(graph, opt)\n            // });\n            if (opt.resizeClusters) {\n                // Resize and reposition cluster elements (parents of other elements)\n                // to fit their children.\n                // 1. filter clusters only\n                // 2. map id on cells\n                // 3. sort cells by their depth (the deepest first)\n                // 4. resize cell to fit their direct children only.\n                var clusters = glGraph.nodes().filter(function(v) {\n                    return glGraph.children(v).length > 0;\n                }).map(graph.getCell.bind(graph)).sort(function(aCluster, bCluster) {\n                    return bCluster.getAncestors().length - aCluster.getAncestors().length;\n                });\n                invoke(clusters, \"fitToChildren\", {\n                    padding: opt.clusterPadding\n                });\n            }\n            graph.stopBatch(\"layout\");\n            // Width and height of the graph extended by margins.\n            var glSize = glGraph.graph();\n            // Return the bounding box of the graph after the layout.\n            return new Rect(marginX, marginY, Math.abs(glSize.width - 2 * marginX), Math.abs(glSize.height - 2 * marginY));\n        },\n        fromGraphLib: function(glGraph, opt) {\n            opt = opt || {};\n            var importNode = opt.importNode || noop;\n            var importEdge = opt.importEdge || noop;\n            var graph = this instanceof Graph ? this : new Graph;\n            // Import all nodes.\n            glGraph.nodes().forEach(function(node) {\n                importNode.call(graph, node, glGraph, graph, opt);\n            });\n            // Import all edges.\n            glGraph.edges().forEach(function(edge) {\n                importEdge.call(graph, edge, glGraph, graph, opt);\n            });\n            return graph;\n        },\n        // Create new graphlib graph from existing JointJS graph.\n        toGraphLib: function(graph, opt) {\n            opt = opt || {};\n            /* eslint-disable no-undef */ var graphlibUtil = opt.graphlib || (typeof graphlib !== \"undefined\" ? graphlib : undefined);\n            /* eslint-enable no-undef */ if (graphlibUtil === undefined) throw new Error('The the \"graphlib\" utility is a mandatory dependency.');\n            var glGraphType = pick(opt, \"directed\", \"compound\", \"multigraph\");\n            var glGraph = new graphlibUtil.Graph(glGraphType);\n            var setNodeLabel = opt.setNodeLabel || noop;\n            var setEdgeLabel = opt.setEdgeLabel || noop;\n            var setEdgeName = opt.setEdgeName || noop;\n            var collection = graph.get(\"cells\");\n            for(var i = 0, n = collection.length; i < n; i++){\n                var cell = collection.at(i);\n                if (cell.isLink()) {\n                    var source = cell.get(\"source\");\n                    var target = cell.get(\"target\");\n                    // Links that end at a point are ignored.\n                    if (!source.id || !target.id) break;\n                    // Note that if we are creating a multigraph we can name the edges. If\n                    // we try to name edges on a non-multigraph an exception is thrown.\n                    glGraph.setEdge(source.id, target.id, setEdgeLabel(cell), setEdgeName(cell));\n                } else {\n                    glGraph.setNode(cell.id, setNodeLabel(cell));\n                    // For the compound graphs we have to take embeds into account.\n                    if (glGraph.isCompound() && cell.has(\"parent\")) {\n                        var parentId = cell.get(\"parent\");\n                        if (collection.has(parentId)) // Make sure the parent cell is included in the graph (this can\n                        // happen when the layout is run on part of the graph only).\n                        glGraph.setParent(cell.id, parentId);\n                    }\n                }\n            }\n            return glGraph;\n        }\n    };\n    Graph.prototype.toGraphLib = function(opt) {\n        return DirectedGraph.toGraphLib(this, opt);\n    };\n    Graph.prototype.fromGraphLib = function(glGraph, opt) {\n        return DirectedGraph.fromGraphLib.call(this, glGraph, opt);\n    };\n    var env = {\n        _results: {},\n        _tests: {\n            svgforeignobject: function() {\n                return !!document.createElementNS && /SVGForeignObject/.test(({}).toString.call(document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\")));\n            }\n        },\n        addTest: function(name, fn) {\n            return this._tests[name] = fn;\n        },\n        test: function(name) {\n            var fn = this._tests[name];\n            if (!fn) throw new Error('Test not defined (\"' + name + '\"). Use `joint.env.addTest(name, fn) to add a new test.`');\n            var result = this._results[name];\n            if (typeof result !== \"undefined\") return result;\n            try {\n                result = fn();\n            } catch (error) {\n                result = false;\n            }\n            // Cache the test result.\n            this._results[name] = result;\n            return result;\n        }\n    };\n    var Generic = Element$1.define(\"basic.Generic\", {\n        attrs: {\n            \".\": {\n                fill: \"#ffffff\",\n                stroke: \"none\"\n            }\n        }\n    });\n    var Rect$1 = Generic.define(\"basic.Rect\", {\n        attrs: {\n            \"rect\": {\n                fill: \"#ffffff\",\n                stroke: \"#000000\",\n                width: 100,\n                height: 60\n            },\n            \"text\": {\n                fill: \"#000000\",\n                text: \"\",\n                \"font-size\": 14,\n                \"ref-x\": .5,\n                \"ref-y\": .5,\n                \"text-anchor\": \"middle\",\n                \"y-alignment\": \"middle\",\n                \"font-family\": \"Arial, helvetica, sans-serif\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect/></g><text/></g>'\n    });\n    var TextView = ElementView.extend({\n        presentationAttributes: ElementView.addPresentationAttributes({\n            // The element view is not automatically re-scaled to fit the model size\n            // when the attribute 'attrs' is changed.\n            attrs: [\n                \"SCALE\"\n            ]\n        }),\n        confirmUpdate: function() {\n            var flags = ElementView.prototype.confirmUpdate.apply(this, arguments);\n            if (this.hasFlag(flags, \"SCALE\")) {\n                this.resize();\n                flags = this.removeFlag(flags, \"SCALE\");\n            }\n            return flags;\n        }\n    });\n    var Text = Generic.define(\"basic.Text\", {\n        attrs: {\n            \"text\": {\n                \"font-size\": 18,\n                fill: \"#000000\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><text/></g></g>'\n    });\n    var Circle = Generic.define(\"basic.Circle\", {\n        size: {\n            width: 60,\n            height: 60\n        },\n        attrs: {\n            \"circle\": {\n                fill: \"#ffffff\",\n                stroke: \"#000000\",\n                r: 30,\n                cx: 30,\n                cy: 30\n            },\n            \"text\": {\n                \"font-size\": 14,\n                text: \"\",\n                \"text-anchor\": \"middle\",\n                \"ref-x\": .5,\n                \"ref-y\": .5,\n                \"y-alignment\": \"middle\",\n                fill: \"#000000\",\n                \"font-family\": \"Arial, helvetica, sans-serif\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle/></g><text/></g>'\n    });\n    var Ellipse$1 = Generic.define(\"basic.Ellipse\", {\n        size: {\n            width: 60,\n            height: 40\n        },\n        attrs: {\n            \"ellipse\": {\n                fill: \"#ffffff\",\n                stroke: \"#000000\",\n                rx: 30,\n                ry: 20,\n                cx: 30,\n                cy: 20\n            },\n            \"text\": {\n                \"font-size\": 14,\n                text: \"\",\n                \"text-anchor\": \"middle\",\n                \"ref-x\": .5,\n                \"ref-y\": .5,\n                \"y-alignment\": \"middle\",\n                fill: \"#000000\",\n                \"font-family\": \"Arial, helvetica, sans-serif\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><ellipse/></g><text/></g>'\n    });\n    var Polygon$1 = Generic.define(\"basic.Polygon\", {\n        size: {\n            width: 60,\n            height: 40\n        },\n        attrs: {\n            \"polygon\": {\n                fill: \"#ffffff\",\n                stroke: \"#000000\"\n            },\n            \"text\": {\n                \"font-size\": 14,\n                text: \"\",\n                \"text-anchor\": \"middle\",\n                \"ref-x\": .5,\n                \"ref-dy\": 20,\n                \"y-alignment\": \"middle\",\n                fill: \"#000000\",\n                \"font-family\": \"Arial, helvetica, sans-serif\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon/></g><text/></g>'\n    });\n    var Polyline$1 = Generic.define(\"basic.Polyline\", {\n        size: {\n            width: 60,\n            height: 40\n        },\n        attrs: {\n            \"polyline\": {\n                fill: \"#ffffff\",\n                stroke: \"#000000\"\n            },\n            \"text\": {\n                \"font-size\": 14,\n                text: \"\",\n                \"text-anchor\": \"middle\",\n                \"ref-x\": .5,\n                \"ref-dy\": 20,\n                \"y-alignment\": \"middle\",\n                fill: \"#000000\",\n                \"font-family\": \"Arial, helvetica, sans-serif\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><polyline/></g><text/></g>'\n    });\n    var Image = Generic.define(\"basic.Image\", {\n        attrs: {\n            \"text\": {\n                \"font-size\": 14,\n                text: \"\",\n                \"text-anchor\": \"middle\",\n                \"ref-x\": .5,\n                \"ref-dy\": 20,\n                \"y-alignment\": \"middle\",\n                fill: \"#000000\",\n                \"font-family\": \"Arial, helvetica, sans-serif\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><image/></g><text/></g>'\n    });\n    var Path$1 = Generic.define(\"basic.Path\", {\n        size: {\n            width: 60,\n            height: 60\n        },\n        attrs: {\n            \"path\": {\n                fill: \"#ffffff\",\n                stroke: \"#000000\"\n            },\n            \"text\": {\n                \"font-size\": 14,\n                text: \"\",\n                \"text-anchor\": \"middle\",\n                \"ref\": \"path\",\n                \"ref-x\": .5,\n                \"ref-dy\": 10,\n                fill: \"#000000\",\n                \"font-family\": \"Arial, helvetica, sans-serif\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><path/></g><text/></g>'\n    });\n    var Rhombus = Path$1.define(\"basic.Rhombus\", {\n        attrs: {\n            \"path\": {\n                d: \"M 30 0 L 60 30 30 60 0 30 z\"\n            },\n            \"text\": {\n                \"ref-y\": .5,\n                \"ref-dy\": null,\n                \"y-alignment\": \"middle\"\n            }\n        }\n    });\n    var svgForeignObjectSupported = env.test(\"svgforeignobject\");\n    var TextBlock = Generic.define(\"basic.TextBlock\", {\n        // see joint.css for more element styles\n        attrs: {\n            rect: {\n                fill: \"#ffffff\",\n                stroke: \"#000000\",\n                width: 80,\n                height: 100\n            },\n            text: {\n                fill: \"#000000\",\n                \"font-size\": 14,\n                \"font-family\": \"Arial, helvetica, sans-serif\"\n            },\n            \".content\": {\n                text: \"\",\n                \"ref-x\": .5,\n                \"ref-y\": .5,\n                \"y-alignment\": \"middle\",\n                \"x-alignment\": \"middle\"\n            }\n        },\n        content: \"\"\n    }, {\n        markup: [\n            '<g class=\"rotatable\">',\n            '<g class=\"scalable\"><rect/></g>',\n            svgForeignObjectSupported ? '<foreignObject class=\"fobj\"><body xmlns=\"http://www.w3.org/1999/xhtml\"><div class=\"content\"/></body></foreignObject>' : '<text class=\"content\"/>',\n            \"</g>\"\n        ].join(\"\"),\n        initialize: function() {\n            this.listenTo(this, \"change:size\", this.updateSize);\n            this.listenTo(this, \"change:content\", this.updateContent);\n            this.updateSize(this, this.get(\"size\"));\n            this.updateContent(this, this.get(\"content\"));\n            Generic.prototype.initialize.apply(this, arguments);\n        },\n        updateSize: function(cell, size) {\n            // Selector `foreignObject' doesn't work across all browsers, we're using class selector instead.\n            // We have to clone size as we don't want attributes.div.style to be same object as attributes.size.\n            this.attr({\n                \".fobj\": assign({}, size),\n                div: {\n                    style: assign({}, size)\n                }\n            });\n        },\n        updateContent: function(cell, content) {\n            if (svgForeignObjectSupported) // Content element is a <div> element.\n            this.attr({\n                \".content\": {\n                    html: sanitizeHTML(content)\n                }\n            });\n            else // Content element is a <text> element.\n            // SVG elements don't have innerHTML attribute.\n            this.attr({\n                \".content\": {\n                    text: content\n                }\n            });\n        },\n        // Here for backwards compatibility:\n        setForeignObjectSize: function() {\n            this.updateSize.apply(this, arguments);\n        },\n        // Here for backwards compatibility:\n        setDivContent: function() {\n            this.updateContent.apply(this, arguments);\n        }\n    });\n    // TextBlockView implements the fallback for IE when no foreignObject exists and\n    // the text needs to be manually broken.\n    var TextBlockView = ElementView.extend({\n        presentationAttributes: svgForeignObjectSupported ? ElementView.prototype.presentationAttributes : ElementView.addPresentationAttributes({\n            content: [\n                \"CONTENT\"\n            ],\n            size: [\n                \"CONTENT\"\n            ]\n        }),\n        initFlag: [\n            \"RENDER\",\n            \"CONTENT\"\n        ],\n        confirmUpdate: function() {\n            var flags = ElementView.prototype.confirmUpdate.apply(this, arguments);\n            if (this.hasFlag(flags, \"CONTENT\")) {\n                this.updateContent(this.model);\n                flags = this.removeFlag(flags, \"CONTENT\");\n            }\n            return flags;\n        },\n        update: function(_, renderingOnlyAttrs) {\n            var model = this.model;\n            if (!svgForeignObjectSupported) {\n                // Update everything but the content first.\n                var noTextAttrs = omit(renderingOnlyAttrs || model.get(\"attrs\"), \".content\");\n                ElementView.prototype.update.call(this, model, noTextAttrs);\n                if (!renderingOnlyAttrs || has$2(renderingOnlyAttrs, \".content\")) // Update the content itself.\n                this.updateContent(model, renderingOnlyAttrs);\n            } else ElementView.prototype.update.call(this, model, renderingOnlyAttrs);\n        },\n        updateContent: function(cell, renderingOnlyAttrs) {\n            // Create copy of the text attributes\n            var textAttrs = merge({}, (renderingOnlyAttrs || cell.get(\"attrs\"))[\".content\"]);\n            textAttrs = omit(textAttrs, \"text\");\n            // Break the content to fit the element size taking into account the attributes\n            // set on the model.\n            var text = breakText(cell.get(\"content\"), cell.get(\"size\"), textAttrs, {\n                // measuring sandbox svg document\n                svgDocument: this.paper.svg\n            });\n            // Create a new attrs with same structure as the model attrs { text: { *textAttributes* }}\n            var attrs = setByPath({}, \".content\", textAttrs, \"/\");\n            // Replace text attribute with the one we just processed.\n            attrs[\".content\"].text = text;\n            // Update the view using renderingOnlyAttributes parameter.\n            ElementView.prototype.update.call(this, cell, attrs);\n        }\n    });\n    var basic = {\n        Generic: Generic,\n        Rect: Rect$1,\n        TextView: TextView,\n        Text: Text,\n        Circle: Circle,\n        Ellipse: Ellipse$1,\n        Polygon: Polygon$1,\n        Polyline: Polyline$1,\n        Image: Image,\n        Path: Path$1,\n        Rhombus: Rhombus,\n        TextBlock: TextBlock,\n        TextBlockView: TextBlockView\n    };\n    // ELEMENTS\n    var Rectangle = Element$1.define(\"standard.Rectangle\", {\n        attrs: {\n            body: {\n                refWidth: \"100%\",\n                refHeight: \"100%\",\n                strokeWidth: 2,\n                stroke: \"#000000\",\n                fill: \"#FFFFFF\"\n            },\n            label: {\n                textVerticalAnchor: \"middle\",\n                textAnchor: \"middle\",\n                refX: \"50%\",\n                refY: \"50%\",\n                fontSize: 14,\n                fill: \"#333333\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"rect\",\n                selector: \"body\"\n            },\n            {\n                tagName: \"text\",\n                selector: \"label\"\n            }\n        ]\n    });\n    var Circle$1 = Element$1.define(\"standard.Circle\", {\n        attrs: {\n            body: {\n                refCx: \"50%\",\n                refCy: \"50%\",\n                refR: \"50%\",\n                strokeWidth: 2,\n                stroke: \"#333333\",\n                fill: \"#FFFFFF\"\n            },\n            label: {\n                textVerticalAnchor: \"middle\",\n                textAnchor: \"middle\",\n                refX: \"50%\",\n                refY: \"50%\",\n                fontSize: 14,\n                fill: \"#333333\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"circle\",\n                selector: \"body\"\n            },\n            {\n                tagName: \"text\",\n                selector: \"label\"\n            }\n        ]\n    });\n    var Ellipse$2 = Element$1.define(\"standard.Ellipse\", {\n        attrs: {\n            body: {\n                refCx: \"50%\",\n                refCy: \"50%\",\n                refRx: \"50%\",\n                refRy: \"50%\",\n                strokeWidth: 2,\n                stroke: \"#333333\",\n                fill: \"#FFFFFF\"\n            },\n            label: {\n                textVerticalAnchor: \"middle\",\n                textAnchor: \"middle\",\n                refX: \"50%\",\n                refY: \"50%\",\n                fontSize: 14,\n                fill: \"#333333\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"ellipse\",\n                selector: \"body\"\n            },\n            {\n                tagName: \"text\",\n                selector: \"label\"\n            }\n        ]\n    });\n    var Path$2 = Element$1.define(\"standard.Path\", {\n        attrs: {\n            body: {\n                refD: \"M 0 0 L 10 0 10 10 0 10 Z\",\n                strokeWidth: 2,\n                stroke: \"#333333\",\n                fill: \"#FFFFFF\"\n            },\n            label: {\n                textVerticalAnchor: \"middle\",\n                textAnchor: \"middle\",\n                refX: \"50%\",\n                refY: \"50%\",\n                fontSize: 14,\n                fill: \"#333333\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"path\",\n                selector: \"body\"\n            },\n            {\n                tagName: \"text\",\n                selector: \"label\"\n            }\n        ]\n    });\n    var Polygon$2 = Element$1.define(\"standard.Polygon\", {\n        attrs: {\n            body: {\n                refPoints: \"0 0 10 0 10 10 0 10\",\n                strokeWidth: 2,\n                stroke: \"#333333\",\n                fill: \"#FFFFFF\"\n            },\n            label: {\n                textVerticalAnchor: \"middle\",\n                textAnchor: \"middle\",\n                refX: \"50%\",\n                refY: \"50%\",\n                fontSize: 14,\n                fill: \"#333333\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"polygon\",\n                selector: \"body\"\n            },\n            {\n                tagName: \"text\",\n                selector: \"label\"\n            }\n        ]\n    });\n    var Polyline$2 = Element$1.define(\"standard.Polyline\", {\n        attrs: {\n            body: {\n                refPoints: \"0 0 10 0 10 10 0 10 0 0\",\n                strokeWidth: 2,\n                stroke: \"#333333\",\n                fill: \"#FFFFFF\"\n            },\n            label: {\n                textVerticalAnchor: \"middle\",\n                textAnchor: \"middle\",\n                refX: \"50%\",\n                refY: \"50%\",\n                fontSize: 14,\n                fill: \"#333333\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"polyline\",\n                selector: \"body\"\n            },\n            {\n                tagName: \"text\",\n                selector: \"label\"\n            }\n        ]\n    });\n    var Image$1 = Element$1.define(\"standard.Image\", {\n        attrs: {\n            image: {\n                refWidth: \"100%\",\n                refHeight: \"100%\"\n            },\n            label: {\n                textVerticalAnchor: \"top\",\n                textAnchor: \"middle\",\n                refX: \"50%\",\n                refY: \"100%\",\n                refY2: 10,\n                fontSize: 14,\n                fill: \"#333333\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"image\",\n                selector: \"image\"\n            },\n            {\n                tagName: \"text\",\n                selector: \"label\"\n            }\n        ]\n    });\n    var BorderedImage = Element$1.define(\"standard.BorderedImage\", {\n        attrs: {\n            border: {\n                refWidth: \"100%\",\n                refHeight: \"100%\",\n                stroke: \"#333333\",\n                strokeWidth: 2\n            },\n            background: {\n                refWidth: -1,\n                refHeight: -1,\n                x: 0.5,\n                y: 0.5,\n                fill: \"#FFFFFF\"\n            },\n            image: {\n                // xlinkHref: '[URL]'\n                refWidth: -1,\n                refHeight: -1,\n                x: 0.5,\n                y: 0.5\n            },\n            label: {\n                textVerticalAnchor: \"top\",\n                textAnchor: \"middle\",\n                refX: \"50%\",\n                refY: \"100%\",\n                refY2: 10,\n                fontSize: 14,\n                fill: \"#333333\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"rect\",\n                selector: \"background\",\n                attributes: {\n                    \"stroke\": \"none\"\n                }\n            },\n            {\n                tagName: \"image\",\n                selector: \"image\"\n            },\n            {\n                tagName: \"rect\",\n                selector: \"border\",\n                attributes: {\n                    \"fill\": \"none\"\n                }\n            },\n            {\n                tagName: \"text\",\n                selector: \"label\"\n            }\n        ]\n    });\n    var EmbeddedImage = Element$1.define(\"standard.EmbeddedImage\", {\n        attrs: {\n            body: {\n                refWidth: \"100%\",\n                refHeight: \"100%\",\n                stroke: \"#333333\",\n                fill: \"#FFFFFF\",\n                strokeWidth: 2\n            },\n            image: {\n                // xlinkHref: '[URL]'\n                refWidth: \"30%\",\n                refHeight: -20,\n                x: 10,\n                y: 10,\n                preserveAspectRatio: \"xMidYMin\"\n            },\n            label: {\n                textVerticalAnchor: \"top\",\n                textAnchor: \"left\",\n                refX: \"30%\",\n                refX2: 20,\n                refY: 10,\n                fontSize: 14,\n                fill: \"#333333\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"rect\",\n                selector: \"body\"\n            },\n            {\n                tagName: \"image\",\n                selector: \"image\"\n            },\n            {\n                tagName: \"text\",\n                selector: \"label\"\n            }\n        ]\n    });\n    var InscribedImage = Element$1.define(\"standard.InscribedImage\", {\n        attrs: {\n            border: {\n                refRx: \"50%\",\n                refRy: \"50%\",\n                refCx: \"50%\",\n                refCy: \"50%\",\n                stroke: \"#333333\",\n                strokeWidth: 2\n            },\n            background: {\n                refRx: \"50%\",\n                refRy: \"50%\",\n                refCx: \"50%\",\n                refCy: \"50%\",\n                fill: \"#FFFFFF\"\n            },\n            image: {\n                // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%\n                refWidth: \"68%\",\n                refHeight: \"68%\",\n                // The image offset is calculated as (100% - 68%) / 2\n                refX: \"16%\",\n                refY: \"16%\",\n                preserveAspectRatio: \"xMidYMid\"\n            },\n            label: {\n                textVerticalAnchor: \"top\",\n                textAnchor: \"middle\",\n                refX: \"50%\",\n                refY: \"100%\",\n                refY2: 10,\n                fontSize: 14,\n                fill: \"#333333\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"ellipse\",\n                selector: \"background\"\n            },\n            {\n                tagName: \"image\",\n                selector: \"image\"\n            },\n            {\n                tagName: \"ellipse\",\n                selector: \"border\",\n                attributes: {\n                    \"fill\": \"none\"\n                }\n            },\n            {\n                tagName: \"text\",\n                selector: \"label\"\n            }\n        ]\n    });\n    var HeaderedRectangle = Element$1.define(\"standard.HeaderedRectangle\", {\n        attrs: {\n            body: {\n                refWidth: \"100%\",\n                refHeight: \"100%\",\n                strokeWidth: 2,\n                stroke: \"#000000\",\n                fill: \"#FFFFFF\"\n            },\n            header: {\n                refWidth: \"100%\",\n                height: 30,\n                strokeWidth: 2,\n                stroke: \"#000000\",\n                fill: \"#FFFFFF\"\n            },\n            headerText: {\n                textVerticalAnchor: \"middle\",\n                textAnchor: \"middle\",\n                refX: \"50%\",\n                refY: 15,\n                fontSize: 16,\n                fill: \"#333333\"\n            },\n            bodyText: {\n                textVerticalAnchor: \"middle\",\n                textAnchor: \"middle\",\n                refX: \"50%\",\n                refY: \"50%\",\n                refY2: 15,\n                fontSize: 14,\n                fill: \"#333333\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"rect\",\n                selector: \"body\"\n            },\n            {\n                tagName: \"rect\",\n                selector: \"header\"\n            },\n            {\n                tagName: \"text\",\n                selector: \"headerText\"\n            },\n            {\n                tagName: \"text\",\n                selector: \"bodyText\"\n            }\n        ]\n    });\n    var CYLINDER_TILT = 10;\n    var Cylinder = Element$1.define(\"standard.Cylinder\", {\n        attrs: {\n            body: {\n                lateralArea: CYLINDER_TILT,\n                fill: \"#FFFFFF\",\n                stroke: \"#333333\",\n                strokeWidth: 2\n            },\n            top: {\n                refCx: \"50%\",\n                cy: CYLINDER_TILT,\n                refRx: \"50%\",\n                ry: CYLINDER_TILT,\n                fill: \"#FFFFFF\",\n                stroke: \"#333333\",\n                strokeWidth: 2\n            },\n            label: {\n                textVerticalAnchor: \"middle\",\n                textAnchor: \"middle\",\n                refX: \"50%\",\n                refY: \"100%\",\n                refY2: 15,\n                fontSize: 14,\n                fill: \"#333333\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"path\",\n                selector: \"body\"\n            },\n            {\n                tagName: \"ellipse\",\n                selector: \"top\"\n            },\n            {\n                tagName: \"text\",\n                selector: \"label\"\n            }\n        ],\n        topRy: function(t, opt) {\n            // getter\n            if (t === undefined) return this.attr(\"body/lateralArea\");\n            // setter\n            var isPercentageSetter = isPercentage(t);\n            var bodyAttrs = {\n                lateralArea: t\n            };\n            var topAttrs = isPercentageSetter ? {\n                refCy: t,\n                refRy: t,\n                cy: null,\n                ry: null\n            } : {\n                refCy: null,\n                refRy: null,\n                cy: t,\n                ry: t\n            };\n            return this.attr({\n                body: bodyAttrs,\n                top: topAttrs\n            }, opt);\n        }\n    }, {\n        attributes: {\n            lateralArea: {\n                set: function(t, refBBox) {\n                    var isPercentageSetter = isPercentage(t);\n                    if (isPercentageSetter) t = parseFloat(t) / 100;\n                    var x = refBBox.x;\n                    var y = refBBox.y;\n                    var w = refBBox.width;\n                    var h = refBBox.height;\n                    // curve control point variables\n                    var rx = w / 2;\n                    var ry = isPercentageSetter ? h * t : t;\n                    var kappa = V.KAPPA;\n                    var cx = kappa * rx;\n                    var cy = kappa * (isPercentageSetter ? h * t : t);\n                    // shape variables\n                    var xLeft = x;\n                    var xCenter = x + w / 2;\n                    var xRight = x + w;\n                    var ySideTop = y + ry;\n                    var yCurveTop = ySideTop - ry;\n                    var ySideBottom = y + h - ry;\n                    var yCurveBottom = y + h;\n                    // return calculated shape\n                    var data = [\n                        \"M\",\n                        xLeft,\n                        ySideTop,\n                        \"L\",\n                        xLeft,\n                        ySideBottom,\n                        \"C\",\n                        x,\n                        ySideBottom + cy,\n                        xCenter - cx,\n                        yCurveBottom,\n                        xCenter,\n                        yCurveBottom,\n                        \"C\",\n                        xCenter + cx,\n                        yCurveBottom,\n                        xRight,\n                        ySideBottom + cy,\n                        xRight,\n                        ySideBottom,\n                        \"L\",\n                        xRight,\n                        ySideTop,\n                        \"C\",\n                        xRight,\n                        ySideTop - cy,\n                        xCenter + cx,\n                        yCurveTop,\n                        xCenter,\n                        yCurveTop,\n                        \"C\",\n                        xCenter - cx,\n                        yCurveTop,\n                        xLeft,\n                        ySideTop - cy,\n                        xLeft,\n                        ySideTop,\n                        \"Z\"\n                    ];\n                    return {\n                        d: data.join(\" \")\n                    };\n                }\n            }\n        }\n    });\n    var foLabelMarkup = {\n        tagName: \"foreignObject\",\n        selector: \"foreignObject\",\n        attributes: {\n            \"overflow\": \"hidden\"\n        },\n        children: [\n            {\n                tagName: \"div\",\n                namespaceURI: \"http://www.w3.org/1999/xhtml\",\n                selector: \"label\",\n                style: {\n                    width: \"100%\",\n                    height: \"100%\",\n                    position: \"static\",\n                    backgroundColor: \"transparent\",\n                    textAlign: \"center\",\n                    margin: 0,\n                    padding: \"0px 5px\",\n                    boxSizing: \"border-box\",\n                    display: \"flex\",\n                    alignItems: \"center\",\n                    justifyContent: \"center\"\n                }\n            }\n        ]\n    };\n    var svgLabelMarkup = {\n        tagName: \"text\",\n        selector: \"label\",\n        attributes: {\n            \"text-anchor\": \"middle\"\n        }\n    };\n    var labelMarkup = env.test(\"svgforeignobject\") ? foLabelMarkup : svgLabelMarkup;\n    var TextBlock$1 = Element$1.define(\"standard.TextBlock\", {\n        attrs: {\n            body: {\n                refWidth: \"100%\",\n                refHeight: \"100%\",\n                stroke: \"#333333\",\n                fill: \"#ffffff\",\n                strokeWidth: 2\n            },\n            foreignObject: {\n                refWidth: \"100%\",\n                refHeight: \"100%\"\n            },\n            label: {\n                style: {\n                    fontSize: 14\n                }\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"rect\",\n                selector: \"body\"\n            },\n            labelMarkup\n        ]\n    }, {\n        attributes: {\n            text: {\n                set: function(text, refBBox, node, attrs) {\n                    if (node instanceof HTMLElement) node.textContent = text;\n                    else {\n                        // No foreign object\n                        var style = attrs.style || {};\n                        var wrapValue = {\n                            text: text,\n                            width: -5,\n                            height: \"100%\"\n                        };\n                        var wrapAttrs = assign({\n                            textVerticalAnchor: \"middle\"\n                        }, style);\n                        attributes.textWrap.set.call(this, wrapValue, refBBox, node, wrapAttrs);\n                        return {\n                            fill: style.color || null\n                        };\n                    }\n                },\n                position: function(text, refBBox, node) {\n                    // No foreign object\n                    if (node instanceof SVGElement) return refBBox.center();\n                }\n            }\n        }\n    });\n    // LINKS\n    var Link$1 = Link.define(\"standard.Link\", {\n        attrs: {\n            line: {\n                connection: true,\n                stroke: \"#333333\",\n                strokeWidth: 2,\n                strokeLinejoin: \"round\",\n                targetMarker: {\n                    \"type\": \"path\",\n                    \"d\": \"M 10 -5 0 0 10 5 z\"\n                }\n            },\n            wrapper: {\n                connection: true,\n                strokeWidth: 10,\n                strokeLinejoin: \"round\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"path\",\n                selector: \"wrapper\",\n                attributes: {\n                    \"fill\": \"none\",\n                    \"cursor\": \"pointer\",\n                    \"stroke\": \"transparent\",\n                    \"stroke-linecap\": \"round\"\n                }\n            },\n            {\n                tagName: \"path\",\n                selector: \"line\",\n                attributes: {\n                    \"fill\": \"none\",\n                    \"pointer-events\": \"none\"\n                }\n            }\n        ]\n    });\n    var DoubleLink = Link.define(\"standard.DoubleLink\", {\n        attrs: {\n            line: {\n                connection: true,\n                stroke: \"#DDDDDD\",\n                strokeWidth: 4,\n                strokeLinejoin: \"round\",\n                targetMarker: {\n                    type: \"path\",\n                    stroke: \"#000000\",\n                    d: \"M 10 -3 10 -10 -2 0 10 10 10 3\"\n                }\n            },\n            outline: {\n                connection: true,\n                stroke: \"#000000\",\n                strokeWidth: 6,\n                strokeLinejoin: \"round\"\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"path\",\n                selector: \"outline\",\n                attributes: {\n                    \"fill\": \"none\"\n                }\n            },\n            {\n                tagName: \"path\",\n                selector: \"line\",\n                attributes: {\n                    \"fill\": \"none\"\n                }\n            }\n        ]\n    });\n    var ShadowLink = Link.define(\"standard.ShadowLink\", {\n        attrs: {\n            line: {\n                connection: true,\n                stroke: \"#FF0000\",\n                strokeWidth: 20,\n                strokeLinejoin: \"round\",\n                targetMarker: {\n                    \"type\": \"path\",\n                    \"stroke\": \"none\",\n                    \"d\": \"M 0 -10 -10 0 0 10 z\"\n                },\n                sourceMarker: {\n                    \"type\": \"path\",\n                    \"stroke\": \"none\",\n                    \"d\": \"M -10 -10 0 0 -10 10 0 10 0 -10 z\"\n                }\n            },\n            shadow: {\n                connection: true,\n                refX: 3,\n                refY: 6,\n                stroke: \"#000000\",\n                strokeOpacity: 0.2,\n                strokeWidth: 20,\n                strokeLinejoin: \"round\",\n                targetMarker: {\n                    \"type\": \"path\",\n                    \"d\": \"M 0 -10 -10 0 0 10 z\",\n                    \"stroke\": \"none\"\n                },\n                sourceMarker: {\n                    \"type\": \"path\",\n                    \"stroke\": \"none\",\n                    \"d\": \"M -10 -10 0 0 -10 10 0 10 0 -10 z\"\n                }\n            }\n        }\n    }, {\n        markup: [\n            {\n                tagName: \"path\",\n                selector: \"shadow\",\n                attributes: {\n                    \"fill\": \"none\"\n                }\n            },\n            {\n                tagName: \"path\",\n                selector: \"line\",\n                attributes: {\n                    \"fill\": \"none\"\n                }\n            }\n        ]\n    });\n    var standard = {\n        Rectangle: Rectangle,\n        Circle: Circle$1,\n        Ellipse: Ellipse$2,\n        Path: Path$2,\n        Polygon: Polygon$2,\n        Polyline: Polyline$2,\n        Image: Image$1,\n        BorderedImage: BorderedImage,\n        EmbeddedImage: EmbeddedImage,\n        InscribedImage: InscribedImage,\n        HeaderedRectangle: HeaderedRectangle,\n        Cylinder: Cylinder,\n        TextBlock: TextBlock$1,\n        Link: Link$1,\n        DoubleLink: DoubleLink,\n        ShadowLink: ShadowLink\n    };\n    /**\n\t * @deprecated use the port api instead\n\t */ var Model = Generic.define(\"devs.Model\", {\n        inPorts: [],\n        outPorts: [],\n        size: {\n            width: 80,\n            height: 80\n        },\n        attrs: {\n            \".\": {\n                magnet: false\n            },\n            \".label\": {\n                text: \"Model\",\n                \"ref-x\": .5,\n                \"ref-y\": 10,\n                \"font-size\": 18,\n                \"text-anchor\": \"middle\",\n                fill: \"#000\"\n            },\n            \".body\": {\n                \"ref-width\": \"100%\",\n                \"ref-height\": \"100%\",\n                stroke: \"#000\"\n            }\n        },\n        ports: {\n            groups: {\n                \"in\": {\n                    position: {\n                        name: \"left\"\n                    },\n                    attrs: {\n                        \".port-label\": {\n                            fill: \"#000\"\n                        },\n                        \".port-body\": {\n                            fill: \"#fff\",\n                            stroke: \"#000\",\n                            r: 10,\n                            magnet: true\n                        }\n                    },\n                    label: {\n                        position: {\n                            name: \"left\",\n                            args: {\n                                y: 10\n                            }\n                        }\n                    }\n                },\n                \"out\": {\n                    position: {\n                        name: \"right\"\n                    },\n                    attrs: {\n                        \".port-label\": {\n                            fill: \"#000\"\n                        },\n                        \".port-body\": {\n                            fill: \"#fff\",\n                            stroke: \"#000\",\n                            r: 10,\n                            magnet: true\n                        }\n                    },\n                    label: {\n                        position: {\n                            name: \"right\",\n                            args: {\n                                y: 10\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><rect class=\"body\"/><text class=\"label\"/></g>',\n        portMarkup: '<circle class=\"port-body\"/>',\n        portLabelMarkup: '<text class=\"port-label\"/>',\n        initialize: function() {\n            Generic.prototype.initialize.apply(this, arguments);\n            this.on(\"change:inPorts change:outPorts\", this.updatePortItems, this);\n            this.updatePortItems();\n        },\n        updatePortItems: function(model, changed, opt) {\n            // Make sure all ports are unique.\n            var inPorts = uniq(this.get(\"inPorts\"));\n            var outPorts = difference(uniq(this.get(\"outPorts\")), inPorts);\n            var inPortItems = this.createPortItems(\"in\", inPorts);\n            var outPortItems = this.createPortItems(\"out\", outPorts);\n            this.prop(\"ports/items\", inPortItems.concat(outPortItems), assign({\n                rewrite: true\n            }, opt));\n        },\n        createPortItem: function(group, port) {\n            return {\n                id: port,\n                group: group,\n                attrs: {\n                    \".port-label\": {\n                        text: port\n                    }\n                }\n            };\n        },\n        createPortItems: function(group, ports) {\n            return toArray(ports).map(this.createPortItem.bind(this, group));\n        },\n        _addGroupPort: function(port, group, opt) {\n            var ports = this.get(group);\n            return this.set(group, Array.isArray(ports) ? ports.concat(port) : [\n                port\n            ], opt);\n        },\n        addOutPort: function(port, opt) {\n            return this._addGroupPort(port, \"outPorts\", opt);\n        },\n        addInPort: function(port, opt) {\n            return this._addGroupPort(port, \"inPorts\", opt);\n        },\n        _removeGroupPort: function(port, group, opt) {\n            return this.set(group, without(this.get(group), port), opt);\n        },\n        removeOutPort: function(port, opt) {\n            return this._removeGroupPort(port, \"outPorts\", opt);\n        },\n        removeInPort: function(port, opt) {\n            return this._removeGroupPort(port, \"inPorts\", opt);\n        },\n        _changeGroup: function(group, properties, opt) {\n            return this.prop(\"ports/groups/\" + group, isObject$1(properties) ? properties : {}, opt);\n        },\n        changeInGroup: function(properties, opt) {\n            return this._changeGroup(\"in\", properties, opt);\n        },\n        changeOutGroup: function(properties, opt) {\n            return this._changeGroup(\"out\", properties, opt);\n        }\n    });\n    var Atomic = Model.define(\"devs.Atomic\", {\n        size: {\n            width: 80,\n            height: 80\n        },\n        attrs: {\n            \".label\": {\n                text: \"Atomic\"\n            }\n        }\n    });\n    var Coupled = Model.define(\"devs.Coupled\", {\n        size: {\n            width: 200,\n            height: 300\n        },\n        attrs: {\n            \".label\": {\n                text: \"Coupled\"\n            }\n        }\n    });\n    var Link$2 = Link.define(\"devs.Link\", {\n        attrs: {\n            \".connection\": {\n                \"stroke-width\": 2\n            }\n        }\n    });\n    var devs = {\n        Model: Model,\n        Atomic: Atomic,\n        Coupled: Coupled,\n        Link: Link$2\n    };\n    var Gate = Generic.define(\"logic.Gate\", {\n        size: {\n            width: 80,\n            height: 40\n        },\n        attrs: {\n            \".\": {\n                magnet: false\n            },\n            \".body\": {\n                width: 100,\n                height: 50\n            },\n            circle: {\n                r: 7,\n                stroke: \"black\",\n                fill: \"transparent\",\n                \"stroke-width\": 2\n            }\n        }\n    }, {\n        operation: function() {\n            return true;\n        }\n    });\n    var IO = Gate.define(\"logic.IO\", {\n        size: {\n            width: 60,\n            height: 30\n        },\n        attrs: {\n            \".body\": {\n                fill: \"white\",\n                stroke: \"black\",\n                \"stroke-width\": 2\n            },\n            \".wire\": {\n                ref: \".body\",\n                \"ref-y\": .5,\n                stroke: \"black\"\n            },\n            text: {\n                fill: \"black\",\n                ref: \".body\",\n                \"ref-x\": .5,\n                \"ref-y\": .5,\n                \"y-alignment\": \"middle\",\n                \"text-anchor\": \"middle\",\n                \"font-weight\": \"bold\",\n                \"font-variant\": \"small-caps\",\n                \"text-transform\": \"capitalize\",\n                \"font-size\": \"14px\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"body\"/></g><path class=\"wire\"/><circle/><text/></g>'\n    });\n    var Input = IO.define(\"logic.Input\", {\n        attrs: {\n            \".wire\": {\n                \"ref-dx\": 0,\n                d: \"M 0 0 L 23 0\"\n            },\n            circle: {\n                ref: \".body\",\n                \"ref-dx\": 30,\n                \"ref-y\": 0.5,\n                magnet: true,\n                \"class\": \"output\",\n                port: \"out\"\n            },\n            text: {\n                text: \"input\"\n            }\n        }\n    });\n    var Output = IO.define(\"logic.Output\", {\n        attrs: {\n            \".wire\": {\n                \"ref-x\": 0,\n                d: \"M 0 0 L -23 0\"\n            },\n            circle: {\n                ref: \".body\",\n                \"ref-x\": -30,\n                \"ref-y\": 0.5,\n                magnet: \"passive\",\n                \"class\": \"input\",\n                port: \"in\"\n            },\n            text: {\n                text: \"output\"\n            }\n        }\n    });\n    var Gate11 = Gate.define(\"logic.Gate11\", {\n        attrs: {\n            \".input\": {\n                ref: \".body\",\n                \"ref-x\": -2,\n                \"ref-y\": 0.5,\n                magnet: \"passive\",\n                port: \"in\"\n            },\n            \".output\": {\n                ref: \".body\",\n                \"ref-dx\": 2,\n                \"ref-y\": 0.5,\n                magnet: true,\n                port: \"out\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><image class=\"body\"/></g><circle class=\"input\"/><circle class=\"output\"/></g>'\n    });\n    var Gate21 = Gate.define(\"logic.Gate21\", {\n        attrs: {\n            \".input1\": {\n                ref: \".body\",\n                \"ref-x\": -2,\n                \"ref-y\": 0.3,\n                magnet: \"passive\",\n                port: \"in1\"\n            },\n            \".input2\": {\n                ref: \".body\",\n                \"ref-x\": -2,\n                \"ref-y\": 0.7,\n                magnet: \"passive\",\n                port: \"in2\"\n            },\n            \".output\": {\n                ref: \".body\",\n                \"ref-dx\": 2,\n                \"ref-y\": 0.5,\n                magnet: true,\n                port: \"out\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><image class=\"body\"/></g><circle class=\"input input1\"/><circle  class=\"input input2\"/><circle class=\"output\"/></g>'\n    });\n    var Repeater = Gate11.define(\"logic.Repeater\", {\n        attrs: {\n            image: {\n                \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzIuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICA8L2c+Cjwvc3ZnPgo=\"\n            }\n        }\n    }, {\n        operation: function(input) {\n            return input;\n        }\n    });\n    var Not = Gate11.define(\"logic.Not\", {\n        attrs: {\n            image: {\n                \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzkuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDI2NzEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzYiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA4MCwyNSBBIDQsNCAwIDEgMSA3MiwyNSBBIDQsNCAwIDEgMSA4MCwyNSB6IgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEsMCkiIC8+CiAgPC9nPgo8L3N2Zz4K\"\n            }\n        }\n    }, {\n        operation: function(input) {\n            return !input;\n        }\n    });\n    var Or = Gate21.define(\"logic.Or\", {\n        attrs: {\n            image: {\n                \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik9SIEFOU0kuc3ZnIgogICBpbmtzY2FwZTpvdXRwdXRfZXh0ZW5zaW9uPSJvcmcuaW5rc2NhcGUub3V0cHV0LnN2Zy5pbmtzY2FwZSI+CiAgPGRlZnMKICAgICBpZD0iZGVmczQiPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTAgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjcxNCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iMSA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMC41IDogMC4zMzMzMzMzMyA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODA2IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODE5IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjM3Mi4wNDcyNCA6IDM1MC43ODczOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI3NDQuMDk0NDggOiA1MjYuMTgxMDkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzc3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49Ijc1IDogNDAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTUwIDogNjAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDYwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTMyNzUiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNTAgOiAzMy4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTAwIDogNTAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTU1MzMiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzIgOiAyMS4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNjQgOiAzMiA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMzIgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjU1NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDE2LjY2NjY2NyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDI1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAyNSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iNCIKICAgICBpbmtzY2FwZTpjeD0iMTEzLjAwMDM5IgogICAgIGlua3NjYXBlOmN5PSIxMi44OTM3MzEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImcyNTYwIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTpncmlkLWJib3g9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1wb2ludHM9InRydWUiCiAgICAgZ3JpZHRvbGVyYW5jZT0iMTAwMDAiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxMzk5IgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9Ijg3NCIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMzciCiAgICAgaW5rc2NhcGU6d2luZG93LXk9Ii00IgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNzAsMjUgYyAyMCwwIDI1LDAgMjUsMCIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMSwxNSA1LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzIsMzUgNSwzNSIKICAgICAgIGlkPSJwYXRoMzk0NCIgLz4KICAgIDxnCiAgICAgICBpZD0iZzI1NjAiCiAgICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI2LjUsLTM5LjUpIj4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICA8L2c+Cjwvc3ZnPgo=\"\n            }\n        }\n    }, {\n        operation: function(input1, input2) {\n            return input1 || input2;\n        }\n    });\n    var And = Gate21.define(\"logic.And\", {\n        attrs: {\n            image: {\n                \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IkFORCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI4IgogICAgIGlua3NjYXBlOmN4PSI1Ni42OTgzNDgiCiAgICAgaW5rc2NhcGU6Y3k9IjI1LjMyNjg5OSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZvbnQtc2l6ZTptZWRpdW07Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDt0ZXh0LWluZGVudDowO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6bm9ybWFsO2xldHRlci1zcGFjaW5nOm5vcm1hbDt3b3JkLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7ZGlyZWN0aW9uOmx0cjtibG9jay1wcm9ncmVzc2lvbjp0Yjt3cml0aW5nLW1vZGU6bHItdGI7dGV4dC1hbmNob3I6c3RhcnQ7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDozO21hcmtlcjpub25lO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGU7Zm9udC1mYW1pbHk6Qml0c3RyZWFtIFZlcmEgU2FuczstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkJpdHN0cmVhbSBWZXJhIFNhbnMiCiAgICAgICBkPSJNIDMwLDUgTCAzMCw2LjQyODU3MTQgTCAzMCw0My41NzE0MjkgTCAzMCw0NSBMIDMxLjQyODU3MSw0NSBMIDUwLjQ3NjE5LDQ1IEMgNjEuNzQ0MDk4LDQ1IDcwLjQ3NjE5LDM1Ljk5OTk1NSA3MC40NzYxOSwyNSBDIDcwLjQ3NjE5LDE0LjAwMDA0NSA2MS43NDQwOTksNS4wMDAwMDAyIDUwLjQ3NjE5LDUgQyA1MC40NzYxOSw1IDUwLjQ3NjE5LDUgMzEuNDI4NTcxLDUgTCAzMCw1IHogTSAzMi44NTcxNDMsNy44NTcxNDI5IEMgNDAuODM0MjY0LDcuODU3MTQyOSA0NS45MTgzNjgsNy44NTcxNDI5IDQ4LjA5NTIzOCw3Ljg1NzE0MjkgQyA0OS4yODU3MTQsNy44NTcxNDI5IDQ5Ljg4MDk1Miw3Ljg1NzE0MjkgNTAuMTc4NTcxLDcuODU3MTQyOSBDIDUwLjMyNzM4MSw3Ljg1NzE0MjkgNTAuNDA5MjI3LDcuODU3MTQyOSA1MC40NDY0MjksNy44NTcxNDI5IEMgNTAuNDY1MDI5LDcuODU3MTQyOSA1MC40NzE1NDMsNy44NTcxNDI5IDUwLjQ3NjE5LDcuODU3MTQyOSBDIDYwLjIzNjg1Myw3Ljg1NzE0MyA2Ny4xNDI4NTcsMTUuNDk3MDk4IDY3LjE0Mjg1NywyNSBDIDY3LjE0Mjg1NywzNC41MDI5MDIgNTkuNzYwNjYyLDQyLjE0Mjg1NyA1MCw0Mi4xNDI4NTcgTCAzMi44NTcxNDMsNDIuMTQyODU3IEwgMzIuODU3MTQzLDcuODU3MTQyOSB6IgogICAgICAgaWQ9InBhdGgyODg0IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2NjY2NzY2NjY3Nzc3NzY2NjIiAvPgogIDwvZz4KPC9zdmc+Cg==\"\n            }\n        }\n    }, {\n        operation: function(input1, input2) {\n            return input1 && input2;\n        }\n    });\n    var Nor = Gate21.define(\"logic.Nor\", {\n        attrs: {\n            image: {\n                \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjEiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjY3NzY0NCIKICAgICBpbmtzY2FwZTpjeT0iMjIuMTAyMzQ0IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjM3IgogICAgIGlua3NjYXBlOndpbmRvdy15PSItNCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc5LDI1IEMgOTksMjUgOTUsMjUgOTUsMjUiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHNvZGlwb2RpOnR5cGU9ImFyYyIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgICBpZD0icGF0aDI2MDQiCiAgICAgICAgIHNvZGlwb2RpOmN4PSI3NSIKICAgICAgICAgc29kaXBvZGk6Y3k9IjI1IgogICAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgICAgc29kaXBvZGk6cnk9IjQiCiAgICAgICAgIGQ9Ik0gNzksMjUgQSA0LDQgMCAxIDEgNzEsMjUgQSA0LDQgMCAxIDEgNzksMjUgeiIKICAgICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTI2LjUsMzkuNSkiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K\"\n            }\n        }\n    }, {\n        operation: function(input1, input2) {\n            return !(input1 || input2);\n        }\n    });\n    var Nand = Gate21.define(\"logic.Nand\", {\n        attrs: {\n            image: {\n                \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5BTkQgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iMTYiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjI4MzMwNyIKICAgICBpbmtzY2FwZTpjeT0iMTYuNDQyODQzIgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzksMjUgQyA5MS44LDI1IDk1LDI1IDk1LDI1IgogICAgICAgaWQ9InBhdGgzMDU5IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMxLDE1IDUsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMiwzNSA1LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MzttYXJrZXI6bm9uZTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlO2ZvbnQtZmFtaWx5OkJpdHN0cmVhbSBWZXJhIFNhbnM7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpCaXRzdHJlYW0gVmVyYSBTYW5zIgogICAgICAgZD0iTSAzMCw1IEwgMzAsNi40Mjg1NzE0IEwgMzAsNDMuNTcxNDI5IEwgMzAsNDUgTCAzMS40Mjg1NzEsNDUgTCA1MC40NzYxOSw0NSBDIDYxLjc0NDA5OCw0NSA3MC40NzYxOSwzNS45OTk5NTUgNzAuNDc2MTksMjUgQyA3MC40NzYxOSwxNC4wMDAwNDUgNjEuNzQ0MDk5LDUuMDAwMDAwMiA1MC40NzYxOSw1IEMgNTAuNDc2MTksNSA1MC40NzYxOSw1IDMxLjQyODU3MSw1IEwgMzAsNSB6IE0gMzIuODU3MTQzLDcuODU3MTQyOSBDIDQwLjgzNDI2NCw3Ljg1NzE0MjkgNDUuOTE4MzY4LDcuODU3MTQyOSA0OC4wOTUyMzgsNy44NTcxNDI5IEMgNDkuMjg1NzE0LDcuODU3MTQyOSA0OS44ODA5NTIsNy44NTcxNDI5IDUwLjE3ODU3MSw3Ljg1NzE0MjkgQyA1MC4zMjczODEsNy44NTcxNDI5IDUwLjQwOTIyNyw3Ljg1NzE0MjkgNTAuNDQ2NDI5LDcuODU3MTQyOSBDIDUwLjQ2NTAyOSw3Ljg1NzE0MjkgNTAuNDcxNTQzLDcuODU3MTQyOSA1MC40NzYxOSw3Ljg1NzE0MjkgQyA2MC4yMzY4NTMsNy44NTcxNDMgNjcuMTQyODU3LDE1LjQ5NzA5OCA2Ny4xNDI4NTcsMjUgQyA2Ny4xNDI4NTcsMzQuNTAyOTAyIDU5Ljc2MDY2Miw0Mi4xNDI4NTcgNTAsNDIuMTQyODU3IEwgMzIuODU3MTQzLDQyLjE0Mjg1NyBMIDMyLjg1NzE0Myw3Ljg1NzE0MjkgeiIKICAgICAgIGlkPSJwYXRoMjg4NCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2Njc2NjY2Nzc3Nzc2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDQwMDgiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg==\"\n            }\n        }\n    }, {\n        operation: function(input1, input2) {\n            return !(input1 && input2);\n        }\n    });\n    var Xor = Gate21.define(\"logic.Xor\", {\n        attrs: {\n            image: {\n                \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhPUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjUuNjU2ODU0MiIKICAgICBpbmtzY2FwZTpjeD0iMjUuOTM4MTE2IgogICAgIGlua3NjYXBlOmN5PSIxNy4yMzAwNSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzAuMzg1NzE3LDE1IEwgNC45OTk5OTk4LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5NzY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEuMzYyMDkxLDM1IEwgNC45OTk5OTk4LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPGcKICAgICAgIGlkPSJnMjU2MCIKICAgICAgIGlua3NjYXBlOmxhYmVsPSJMYXllciAxIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYuNSwtMzkuNSkiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM1MTYiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi4yNSw4MS41MDAwMDUgQyAtMy44NDczNzQsODQuMTQ0NDA1IC00LjUsODQuNTAwMDA1IC00LjUsODQuNTAwMDA1IEwgLTguMTU2MjUsODQuNTAwMDA1IEwgLTYuMTU2MjUsODIuMDYyNTA1IEMgLTYuMTU2MjUsODIuMDYyNTA1IC0wLjUsNzUuMDYyNDUxIC0wLjUsNjQuNSBDIC0wLjUsNTMuOTM3NTQ5IC02LjE1NjI1LDQ2LjkzNzUgLTYuMTU2MjUsNDYuOTM3NSBMIC04LjE1NjI1LDQ0LjUgTCAtNC41LDQ0LjUgQyAtMy43MTg3NSw0NS40Mzc1IC0zLjA3ODEyNSw0Ni4xNTYyNSAtMi4yODEyNSw0Ny41IEMgLTAuNDA4NTMxLDUwLjU5OTgxNSAyLjUsNTYuNTI2NjQ2IDIuNSw2NC41IEMgMi41LDcyLjQ1MDY1IC0wLjM5NjY5Nyw3OC4zNzk0MjUgLTIuMjUsODEuNTAwMDA1IHoiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY3NjY2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K\"\n            }\n        }\n    }, {\n        operation: function(input1, input2) {\n            return (!input1 || input2) && (input1 || !input2);\n        }\n    });\n    var Xnor = Gate21.define(\"logic.Xnor\", {\n        attrs: {\n            image: {\n                \"xlink:href\": \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhOT1IgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNTU3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTYuNjY2NjY3IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDI1IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI0IgogICAgIGlua3NjYXBlOmN4PSI5NS43MjM2NiIKICAgICBpbmtzY2FwZTpjeT0iLTI2Ljc3NTAyMyIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjAwMDAwMDI0O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc4LjMzMzMzMiwyNSBDIDkxLjY2NjY2NiwyNSA5NSwyNSA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMC4zODU3MTcsMTUgTCA0Ljk5OTk5OTgsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk3NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMS4zNjIwOTEsMzUgTCA0Ljk5OTk5OTgsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMzUxNiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjI1LDgxLjUwMDAwNSBDIC0zLjg0NzM3NCw4NC4xNDQ0MDUgLTQuNSw4NC41MDAwMDUgLTQuNSw4NC41MDAwMDUgTCAtOC4xNTYyNSw4NC41MDAwMDUgTCAtNi4xNTYyNSw4Mi4wNjI1MDUgQyAtNi4xNTYyNSw4Mi4wNjI1MDUgLTAuNSw3NS4wNjI0NTEgLTAuNSw2NC41IEMgLTAuNSw1My45Mzc1NDkgLTYuMTU2MjUsNDYuOTM3NSAtNi4xNTYyNSw0Ni45Mzc1IEwgLTguMTU2MjUsNDQuNSBMIC00LjUsNDQuNSBDIC0zLjcxODc1LDQ1LjQzNzUgLTMuMDc4MTI1LDQ2LjE1NjI1IC0yLjI4MTI1LDQ3LjUgQyAtMC40MDg1MzEsNTAuNTk5ODE1IDIuNSw1Ni41MjY2NDYgMi41LDY0LjUgQyAyLjUsNzIuNDUwNjUgLTAuMzk2Njk3LDc4LjM3OTQyNSAtMi4yNSw4MS41MDAwMDUgeiIKICAgICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2Njc2NjY2NzYyIgLz4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDM1NTEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg==\"\n            }\n        }\n    }, {\n        operation: function(input1, input2) {\n            return (!input1 || !input2) && (input1 || input2);\n        }\n    });\n    var Wire = Link.define(\"logic.Wire\", {\n        attrs: {\n            \".connection\": {\n                \"stroke-width\": 2\n            },\n            \".marker-vertex\": {\n                r: 7\n            }\n        },\n        router: {\n            name: \"orthogonal\"\n        },\n        connector: {\n            name: \"rounded\",\n            args: {\n                radius: 10\n            }\n        }\n    }, {\n        arrowheadMarkup: [\n            '<g class=\"marker-arrowhead-group marker-arrowhead-group-<%= end %>\">',\n            '<circle class=\"marker-arrowhead\" end=\"<%= end %>\" r=\"7\"/>',\n            \"</g>\"\n        ].join(\"\"),\n        vertexMarkup: [\n            '<g class=\"marker-vertex-group\" transform=\"translate(<%= x %>, <%= y %>)\">',\n            '<circle class=\"marker-vertex\" idx=\"<%= idx %>\" r=\"10\" />',\n            '<g class=\"marker-vertex-remove-group\">',\n            '<path class=\"marker-vertex-remove-area\" idx=\"<%= idx %>\" d=\"M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z\" transform=\"translate(5, -33)\"/>',\n            '<path class=\"marker-vertex-remove\" idx=\"<%= idx %>\" transform=\"scale(.8) translate(9.5, -37)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\">',\n            \"<title>Remove vertex.</title>\",\n            \"</path>\",\n            \"</g>\",\n            \"</g>\"\n        ].join(\"\")\n    });\n    var logic = {\n        Gate: Gate,\n        IO: IO,\n        Input: Input,\n        Output: Output,\n        Gate11: Gate11,\n        Gate21: Gate21,\n        Repeater: Repeater,\n        Not: Not,\n        Or: Or,\n        And: And,\n        Nor: Nor,\n        Nand: Nand,\n        Xor: Xor,\n        Xnor: Xnor,\n        Wire: Wire\n    };\n    var KingWhite = Generic.define(\"chess.KingWhite\", {\n        size: {\n            width: 42,\n            height: 38\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\"><path      d=\"M 22.5,11.63 L 22.5,6\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path      d=\"M 20,8 L 25,8\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path      d=\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\"      style=\"fill:#ffffff; stroke:#000000; stroke-linecap:butt; stroke-linejoin:miter;\" />    <path      d=\"M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z \"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 11.5,30 C 17,27 27,27 32.5,30\"      style=\"fill:none; stroke:#000000;\" />    <path      d=\"M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5\"      style=\"fill:none; stroke:#000000;\" />    <path      d=\"M 11.5,37 C 17,34 27,34 32.5,37\"      style=\"fill:none; stroke:#000000;\" />  </g></g></g>'\n    });\n    var KingBlack = Generic.define(\"chess.KingBlack\", {\n        size: {\n            width: 42,\n            height: 38\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path       d=\"M 22.5,11.63 L 22.5,6\"       style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\"       id=\"path6570\" />    <path       d=\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\"       style=\"fill:#000000;fill-opacity:1; stroke-linecap:butt; stroke-linejoin:miter;\" />    <path       d=\"M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z \"       style=\"fill:#000000; stroke:#000000;\" />    <path       d=\"M 20,8 L 25,8\"       style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path       d=\"M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.51,26.6 L 22.5,24.5 C 20,18 9.906,14 6.997,19.85 C 4.5,25.5 11.85,28.85 11.85,28.85\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 11.5,30 C 17,27 27,27 32.5,30 M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5 M 11.5,37 C 17,34 27,34 32.5,37\"       style=\"fill:none; stroke:#ffffff;\" />  </g></g></g>'\n    });\n    var QueenWhite = Generic.define(\"chess.QueenWhite\", {\n        size: {\n            width: 42,\n            height: 38\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(-1,-1)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(15.5,-5.5)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(32,-1)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(7,-4.5)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(24,-4)\" />    <path      d=\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38,14 L 31,25 L 31,11 L 25.5,24.5 L 22.5,9.5 L 19.5,24.5 L 14,10.5 L 14,25 L 7,14 L 9,26 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11.5,30 C 15,29 30,29 33.5,30\"      style=\"fill:none;\" />    <path      d=\"M 12,33.5 C 18,32.5 27,32.5 33,33.5\"      style=\"fill:none;\" />  </g></g></g>'\n    });\n    var QueenBlack = Generic.define(\"chess.QueenBlack\", {\n        size: {\n            width: 42,\n            height: 38\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#000000; stroke:none;\">      <circle cx=\"6\"    cy=\"12\" r=\"2.75\" />      <circle cx=\"14\"   cy=\"9\"  r=\"2.75\" />      <circle cx=\"22.5\" cy=\"8\"  r=\"2.75\" />      <circle cx=\"31\"   cy=\"9\"  r=\"2.75\" />      <circle cx=\"39\"   cy=\"12\" r=\"2.75\" />    </g>    <path       d=\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\"       style=\"stroke-linecap:butt; stroke:#000000;\" />    <path       d=\"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z\"       style=\"stroke-linecap:butt;\" />    <path       d=\"M 11,38.5 A 35,35 1 0 0 34,38.5\"       style=\"fill:none; stroke:#000000; stroke-linecap:butt;\" />    <path       d=\"M 11,29 A 35,35 1 0 1 34,29\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 12.5,31.5 L 32.5,31.5\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 11.5,34.5 A 35,35 1 0 0 33.5,34.5\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 10.5,37.5 A 35,35 1 0 0 34.5,37.5\"       style=\"fill:none; stroke:#ffffff;\" />  </g></g></g>'\n    });\n    var RookWhite = Generic.define(\"chess.RookWhite\", {\n        size: {\n            width: 32,\n            height: 34\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14\"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 34,14 L 31,17 L 14,17 L 11,14\" />    <path      d=\"M 31,17 L 31,29.5 L 14,29.5 L 14,17\"      style=\"stroke-linecap:butt; stroke-linejoin:miter;\" />    <path      d=\"M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5\" />    <path      d=\"M 11,14 L 34,14\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />  </g></g></g>'\n    });\n    var RookBlack = Generic.define(\"chess.RookBlack\", {\n        size: {\n            width: 32,\n            height: 34\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z \"      style=\"stroke-linecap:butt;stroke-linejoin:miter;\" />    <path      d=\"M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,35.5 L 33,35.5 L 33,35.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 13,31.5 L 32,31.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 14,29.5 L 31,29.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 14,16.5 L 31,16.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 11,14 L 34,14\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />  </g></g></g>'\n    });\n    var BishopWhite = Generic.define(\"chess.BishopWhite\", {\n        size: {\n            width: 38,\n            height: 38\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#ffffff; stroke:#000000; stroke-linecap:butt;\">       <path        d=\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z\" />      <path        d=\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" />      <path        d=\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" />    </g>    <path      d=\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />  </g></g></g>'\n    });\n    var BishopBlack = Generic.define(\"chess.BishopBlack\", {\n        size: {\n            width: 38,\n            height: 38\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#000000; stroke:#000000; stroke-linecap:butt;\">       <path        d=\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z\" />      <path        d=\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" />      <path        d=\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" />    </g>    <path       d=\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\"       style=\"fill:none; stroke:#ffffff; stroke-linejoin:miter;\" />  </g></g></g>'\n    });\n    var KnightWhite = Generic.define(\"chess.KnightWhite\", {\n        size: {\n            width: 38,\n            height: 37\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\"      transform=\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\"      style=\"fill:#000000; stroke:#000000;\" />  </g></g></g>'\n    });\n    var KnightBlack = Generic.define(\"chess.KnightBlack\", {\n        size: {\n            width: 38,\n            height: 37\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\"      style=\"fill:#ffffff; stroke:#ffffff;\" />    <path      d=\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\"      transform=\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\"      style=\"fill:#ffffff; stroke:#ffffff;\" />    <path      d=\"M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z \"      style=\"fill:#ffffff; stroke:none;\" />  </g></g></g>'\n    });\n    var PawnWhite = Generic.define(\"chess.PawnWhite\", {\n        size: {\n            width: 28,\n            height: 33\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><path d=\"M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z \"  style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\" /></g></g>'\n    });\n    var PawnBlack = Generic.define(\"chess.PawnBlack\", {\n        size: {\n            width: 28,\n            height: 33\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><path d=\"M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z \"  style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\" /></g></g>'\n    });\n    var chess = {\n        KingWhite: KingWhite,\n        KingBlack: KingBlack,\n        QueenWhite: QueenWhite,\n        QueenBlack: QueenBlack,\n        RookWhite: RookWhite,\n        RookBlack: RookBlack,\n        BishopWhite: BishopWhite,\n        BishopBlack: BishopBlack,\n        KnightWhite: KnightWhite,\n        KnightBlack: KnightBlack,\n        PawnWhite: PawnWhite,\n        PawnBlack: PawnBlack\n    };\n    var Entity = Element$1.define(\"erd.Entity\", {\n        size: {\n            width: 150,\n            height: 60\n        },\n        attrs: {\n            \".outer\": {\n                fill: \"#2ECC71\",\n                stroke: \"#27AE60\",\n                \"stroke-width\": 2,\n                points: \"100,0 100,60 0,60 0,0\"\n            },\n            \".inner\": {\n                fill: \"#2ECC71\",\n                stroke: \"#27AE60\",\n                \"stroke-width\": 2,\n                points: \"95,5 95,55 5,55 5,5\",\n                display: \"none\"\n            },\n            text: {\n                text: \"Entity\",\n                \"font-family\": \"Arial\",\n                \"font-size\": 14,\n                \"ref-x\": .5,\n                \"ref-y\": .5,\n                \"y-alignment\": \"middle\",\n                \"text-anchor\": \"middle\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon class=\"outer\"/><polygon class=\"inner\"/></g><text/></g>'\n    });\n    var WeakEntity = Entity.define(\"erd.WeakEntity\", {\n        attrs: {\n            \".inner\": {\n                display: \"auto\"\n            },\n            text: {\n                text: \"Weak Entity\"\n            }\n        }\n    });\n    var Relationship = Element$1.define(\"erd.Relationship\", {\n        size: {\n            width: 80,\n            height: 80\n        },\n        attrs: {\n            \".outer\": {\n                fill: \"#3498DB\",\n                stroke: \"#2980B9\",\n                \"stroke-width\": 2,\n                points: \"40,0 80,40 40,80 0,40\"\n            },\n            \".inner\": {\n                fill: \"#3498DB\",\n                stroke: \"#2980B9\",\n                \"stroke-width\": 2,\n                points: \"40,5 75,40 40,75 5,40\",\n                display: \"none\"\n            },\n            text: {\n                text: \"Relationship\",\n                \"font-family\": \"Arial\",\n                \"font-size\": 12,\n                \"ref-x\": .5,\n                \"ref-y\": .5,\n                \"y-alignment\": \"middle\",\n                \"text-anchor\": \"middle\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon class=\"outer\"/><polygon class=\"inner\"/></g><text/></g>'\n    });\n    var IdentifyingRelationship = Relationship.define(\"erd.IdentifyingRelationship\", {\n        attrs: {\n            \".inner\": {\n                display: \"auto\"\n            },\n            text: {\n                text: \"Identifying\"\n            }\n        }\n    });\n    var Attribute = Element$1.define(\"erd.Attribute\", {\n        size: {\n            width: 100,\n            height: 50\n        },\n        attrs: {\n            \"ellipse\": {\n                transform: \"translate(50, 25)\"\n            },\n            \".outer\": {\n                stroke: \"#D35400\",\n                \"stroke-width\": 2,\n                cx: 0,\n                cy: 0,\n                rx: 50,\n                ry: 25,\n                fill: \"#E67E22\"\n            },\n            \".inner\": {\n                stroke: \"#D35400\",\n                \"stroke-width\": 2,\n                cx: 0,\n                cy: 0,\n                rx: 45,\n                ry: 20,\n                fill: \"#E67E22\",\n                display: \"none\"\n            },\n            text: {\n                \"font-family\": \"Arial\",\n                \"font-size\": 14,\n                \"ref-x\": .5,\n                \"ref-y\": .5,\n                \"y-alignment\": \"middle\",\n                \"text-anchor\": \"middle\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><ellipse class=\"outer\"/><ellipse class=\"inner\"/></g><text/></g>'\n    });\n    var Multivalued = Attribute.define(\"erd.Multivalued\", {\n        attrs: {\n            \".inner\": {\n                display: \"block\"\n            },\n            text: {\n                text: \"multivalued\"\n            }\n        }\n    });\n    var Derived = Attribute.define(\"erd.Derived\", {\n        attrs: {\n            \".outer\": {\n                \"stroke-dasharray\": \"3,5\"\n            },\n            text: {\n                text: \"derived\"\n            }\n        }\n    });\n    var Key = Attribute.define(\"erd.Key\", {\n        attrs: {\n            ellipse: {\n                \"stroke-width\": 4\n            },\n            text: {\n                text: \"key\",\n                \"font-weight\": \"800\",\n                \"text-decoration\": \"underline\"\n            }\n        }\n    });\n    var Normal = Attribute.define(\"erd.Normal\", {\n        attrs: {\n            text: {\n                text: \"Normal\"\n            }\n        }\n    });\n    var ISA = Element$1.define(\"erd.ISA\", {\n        type: \"erd.ISA\",\n        size: {\n            width: 100,\n            height: 50\n        },\n        attrs: {\n            polygon: {\n                points: \"0,0 50,50 100,0\",\n                fill: \"#F1C40F\",\n                stroke: \"#F39C12\",\n                \"stroke-width\": 2\n            },\n            text: {\n                text: \"ISA\",\n                \"font-size\": 18,\n                \"ref-x\": .5,\n                \"ref-y\": .3,\n                \"y-alignment\": \"middle\",\n                \"text-anchor\": \"middle\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon/></g><text/></g>'\n    });\n    var Line$1 = Link.define(\"erd.Line\", {}, {\n        cardinality: function(value) {\n            this.set(\"labels\", [\n                {\n                    position: -20,\n                    attrs: {\n                        text: {\n                            dy: -8,\n                            text: value\n                        }\n                    }\n                }\n            ]);\n        }\n    });\n    var erd = {\n        Entity: Entity,\n        WeakEntity: WeakEntity,\n        Relationship: Relationship,\n        IdentifyingRelationship: IdentifyingRelationship,\n        Attribute: Attribute,\n        Multivalued: Multivalued,\n        Derived: Derived,\n        Key: Key,\n        Normal: Normal,\n        ISA: ISA,\n        Line: Line$1\n    };\n    var State = Circle.define(\"fsa.State\", {\n        attrs: {\n            circle: {\n                \"stroke-width\": 3\n            },\n            text: {\n                \"font-weight\": \"800\"\n            }\n        }\n    });\n    var StartState = Element$1.define(\"fsa.StartState\", {\n        size: {\n            width: 20,\n            height: 20\n        },\n        attrs: {\n            circle: {\n                transform: \"translate(10, 10)\",\n                r: 10,\n                fill: \"#000000\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle/></g></g>'\n    });\n    var EndState = Element$1.define(\"fsa.EndState\", {\n        size: {\n            width: 20,\n            height: 20\n        },\n        attrs: {\n            \".outer\": {\n                transform: \"translate(10, 10)\",\n                r: 10,\n                fill: \"#ffffff\",\n                stroke: \"#000000\"\n            },\n            \".inner\": {\n                transform: \"translate(10, 10)\",\n                r: 6,\n                fill: \"#000000\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"outer\"/><circle class=\"inner\"/></g></g>'\n    });\n    var Arrow = Link.define(\"fsa.Arrow\", {\n        attrs: {\n            \".marker-target\": {\n                d: \"M 10 0 L 0 5 L 10 10 z\"\n            }\n        },\n        smooth: true\n    });\n    var fsa = {\n        State: State,\n        StartState: StartState,\n        EndState: EndState,\n        Arrow: Arrow\n    };\n    var Member = Element$1.define(\"org.Member\", {\n        size: {\n            width: 180,\n            height: 70\n        },\n        attrs: {\n            rect: {\n                width: 170,\n                height: 60\n            },\n            \".card\": {\n                fill: \"#FFFFFF\",\n                stroke: \"#000000\",\n                \"stroke-width\": 2,\n                \"pointer-events\": \"visiblePainted\",\n                rx: 10,\n                ry: 10\n            },\n            image: {\n                width: 48,\n                height: 48,\n                ref: \".card\",\n                \"ref-x\": 10,\n                \"ref-y\": 5\n            },\n            \".rank\": {\n                \"text-decoration\": \"underline\",\n                ref: \".card\",\n                \"ref-x\": 0.9,\n                \"ref-y\": 0.2,\n                \"font-family\": \"Courier New\",\n                \"font-size\": 14,\n                \"text-anchor\": \"end\"\n            },\n            \".name\": {\n                \"font-weight\": \"800\",\n                ref: \".card\",\n                \"ref-x\": 0.9,\n                \"ref-y\": 0.6,\n                \"font-family\": \"Courier New\",\n                \"font-size\": 14,\n                \"text-anchor\": \"end\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"card\"/><image/></g><text class=\"rank\"/><text class=\"name\"/></g>'\n    });\n    var Arrow$1 = Link.define(\"org.Arrow\", {\n        source: {\n            selector: \".card\"\n        },\n        target: {\n            selector: \".card\"\n        },\n        attrs: {\n            \".connection\": {\n                stroke: \"#585858\",\n                \"stroke-width\": 3\n            }\n        },\n        z: -1\n    });\n    var org = {\n        Member: Member,\n        Arrow: Arrow$1\n    };\n    var Place = Generic.define(\"pn.Place\", {\n        size: {\n            width: 50,\n            height: 50\n        },\n        attrs: {\n            \".root\": {\n                r: 25,\n                fill: \"#ffffff\",\n                stroke: \"#000000\",\n                transform: \"translate(25, 25)\"\n            },\n            \".label\": {\n                \"text-anchor\": \"middle\",\n                \"ref-x\": .5,\n                \"ref-y\": -20,\n                ref: \".root\",\n                fill: \"#000000\",\n                \"font-size\": 12\n            },\n            \".tokens > circle\": {\n                fill: \"#000000\",\n                r: 5\n            },\n            \".tokens.one > circle\": {\n                transform: \"translate(25, 25)\"\n            },\n            \".tokens.two > circle:nth-child(1)\": {\n                transform: \"translate(19, 25)\"\n            },\n            \".tokens.two > circle:nth-child(2)\": {\n                transform: \"translate(31, 25)\"\n            },\n            \".tokens.three > circle:nth-child(1)\": {\n                transform: \"translate(18, 29)\"\n            },\n            \".tokens.three > circle:nth-child(2)\": {\n                transform: \"translate(25, 19)\"\n            },\n            \".tokens.three > circle:nth-child(3)\": {\n                transform: \"translate(32, 29)\"\n            },\n            \".tokens.alot > text\": {\n                transform: \"translate(25, 18)\",\n                \"text-anchor\": \"middle\",\n                fill: \"#000000\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"root\"/><g class=\"tokens\" /></g><text class=\"label\"/></g>'\n    });\n    var PlaceView = ElementView.extend({\n        presentationAttributes: ElementView.addPresentationAttributes({\n            tokens: [\n                \"TOKENS\"\n            ]\n        }),\n        initFlag: ElementView.prototype.initFlag.concat([\n            \"TOKENS\"\n        ]),\n        confirmUpdate: function() {\n            var ref;\n            var args = [], len = arguments.length;\n            while(len--)args[len] = arguments[len];\n            var flags = (ref = ElementView.prototype.confirmUpdate).call.apply(ref, [\n                this\n            ].concat(args));\n            if (this.hasFlag(flags, \"TOKENS\")) {\n                this.renderTokens();\n                this.update();\n                flags = this.removeFlag(flags, \"TOKENS\");\n            }\n            return flags;\n        },\n        renderTokens: function() {\n            var vTokens = this.vel.findOne(\".tokens\").empty();\n            [\n                \"one\",\n                \"two\",\n                \"three\",\n                \"alot\"\n            ].forEach(function(className) {\n                vTokens.removeClass(className);\n            });\n            var tokens = this.model.get(\"tokens\");\n            if (!tokens) return;\n            switch(tokens){\n                case 1:\n                    vTokens.addClass(\"one\");\n                    vTokens.append(V(\"circle\"));\n                    break;\n                case 2:\n                    vTokens.addClass(\"two\");\n                    vTokens.append([\n                        V(\"circle\"),\n                        V(\"circle\")\n                    ]);\n                    break;\n                case 3:\n                    vTokens.addClass(\"three\");\n                    vTokens.append([\n                        V(\"circle\"),\n                        V(\"circle\"),\n                        V(\"circle\")\n                    ]);\n                    break;\n                default:\n                    vTokens.addClass(\"alot\");\n                    vTokens.append(V(\"text\").text(tokens + \"\"));\n                    break;\n            }\n        }\n    });\n    var Transition = Generic.define(\"pn.Transition\", {\n        size: {\n            width: 12,\n            height: 50\n        },\n        attrs: {\n            \"rect\": {\n                width: 12,\n                height: 50,\n                fill: \"#000000\",\n                stroke: \"#000000\"\n            },\n            \".label\": {\n                \"text-anchor\": \"middle\",\n                \"ref-x\": .5,\n                \"ref-y\": -20,\n                ref: \"rect\",\n                fill: \"#000000\",\n                \"font-size\": 12\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"root\"/></g></g><text class=\"label\"/>'\n    });\n    var Link$3 = Link.define(\"pn.Link\", {\n        attrs: {\n            \".marker-target\": {\n                d: \"M 10 0 L 0 5 L 10 10 z\"\n            }\n        }\n    });\n    var pn = {\n        Place: Place,\n        PlaceView: PlaceView,\n        Transition: Transition,\n        Link: Link$3\n    };\n    var Class = Generic.define(\"uml.Class\", {\n        attrs: {\n            rect: {\n                \"width\": 200\n            },\n            \".uml-class-name-rect\": {\n                \"stroke\": \"black\",\n                \"stroke-width\": 2,\n                \"fill\": \"#3498db\"\n            },\n            \".uml-class-attrs-rect\": {\n                \"stroke\": \"black\",\n                \"stroke-width\": 2,\n                \"fill\": \"#2980b9\"\n            },\n            \".uml-class-methods-rect\": {\n                \"stroke\": \"black\",\n                \"stroke-width\": 2,\n                \"fill\": \"#2980b9\"\n            },\n            \".uml-class-name-text\": {\n                \"ref\": \".uml-class-name-rect\",\n                \"ref-y\": .5,\n                \"ref-x\": .5,\n                \"text-anchor\": \"middle\",\n                \"y-alignment\": \"middle\",\n                \"font-weight\": \"bold\",\n                \"fill\": \"black\",\n                \"font-size\": 12,\n                \"font-family\": \"Times New Roman\"\n            },\n            \".uml-class-attrs-text\": {\n                \"ref\": \".uml-class-attrs-rect\",\n                \"ref-y\": 5,\n                \"ref-x\": 5,\n                \"fill\": \"black\",\n                \"font-size\": 12,\n                \"font-family\": \"Times New Roman\"\n            },\n            \".uml-class-methods-text\": {\n                \"ref\": \".uml-class-methods-rect\",\n                \"ref-y\": 5,\n                \"ref-x\": 5,\n                \"fill\": \"black\",\n                \"font-size\": 12,\n                \"font-family\": \"Times New Roman\"\n            }\n        },\n        name: [],\n        attributes: [],\n        methods: []\n    }, {\n        markup: [\n            '<g class=\"rotatable\">',\n            '<g class=\"scalable\">',\n            '<rect class=\"uml-class-name-rect\"/><rect class=\"uml-class-attrs-rect\"/><rect class=\"uml-class-methods-rect\"/>',\n            \"</g>\",\n            '<text class=\"uml-class-name-text\"/><text class=\"uml-class-attrs-text\"/><text class=\"uml-class-methods-text\"/>',\n            \"</g>\"\n        ].join(\"\"),\n        initialize: function() {\n            this.on(\"change:name change:attributes change:methods\", function() {\n                this.updateRectangles();\n                this.trigger(\"uml-update\");\n            }, this);\n            this.updateRectangles();\n            Generic.prototype.initialize.apply(this, arguments);\n        },\n        getClassName: function() {\n            return this.get(\"name\");\n        },\n        updateRectangles: function() {\n            var attrs = this.get(\"attrs\");\n            var rects = [\n                {\n                    type: \"name\",\n                    text: this.getClassName()\n                },\n                {\n                    type: \"attrs\",\n                    text: this.get(\"attributes\")\n                },\n                {\n                    type: \"methods\",\n                    text: this.get(\"methods\")\n                }\n            ];\n            var offsetY = 0;\n            rects.forEach(function(rect) {\n                var lines = Array.isArray(rect.text) ? rect.text : [\n                    rect.text\n                ];\n                var rectHeight = lines.length * 20 + 20;\n                attrs[\".uml-class-\" + rect.type + \"-text\"].text = lines.join(\"\\n\");\n                attrs[\".uml-class-\" + rect.type + \"-rect\"].height = rectHeight;\n                attrs[\".uml-class-\" + rect.type + \"-rect\"].transform = \"translate(0,\" + offsetY + \")\";\n                offsetY += rectHeight;\n            });\n        }\n    });\n    var ClassView = ElementView.extend({\n        initialize: function() {\n            ElementView.prototype.initialize.apply(this, arguments);\n            this.listenTo(this.model, \"uml-update\", function() {\n                this.update();\n                this.resize();\n            });\n        }\n    });\n    var Abstract = Class.define(\"uml.Abstract\", {\n        attrs: {\n            \".uml-class-name-rect\": {\n                fill: \"#e74c3c\"\n            },\n            \".uml-class-attrs-rect\": {\n                fill: \"#c0392b\"\n            },\n            \".uml-class-methods-rect\": {\n                fill: \"#c0392b\"\n            }\n        }\n    }, {\n        getClassName: function() {\n            return [\n                \"<<Abstract>>\",\n                this.get(\"name\")\n            ];\n        }\n    });\n    var AbstractView = ClassView;\n    var Interface = Class.define(\"uml.Interface\", {\n        attrs: {\n            \".uml-class-name-rect\": {\n                fill: \"#f1c40f\"\n            },\n            \".uml-class-attrs-rect\": {\n                fill: \"#f39c12\"\n            },\n            \".uml-class-methods-rect\": {\n                fill: \"#f39c12\"\n            }\n        }\n    }, {\n        getClassName: function() {\n            return [\n                \"<<Interface>>\",\n                this.get(\"name\")\n            ];\n        }\n    });\n    var InterfaceView = ClassView;\n    var Generalization = Link.define(\"uml.Generalization\", {\n        attrs: {\n            \".marker-target\": {\n                d: \"M 20 0 L 0 10 L 20 20 z\",\n                fill: \"white\"\n            }\n        }\n    });\n    var Implementation = Link.define(\"uml.Implementation\", {\n        attrs: {\n            \".marker-target\": {\n                d: \"M 20 0 L 0 10 L 20 20 z\",\n                fill: \"white\"\n            },\n            \".connection\": {\n                \"stroke-dasharray\": \"3,3\"\n            }\n        }\n    });\n    var Aggregation = Link.define(\"uml.Aggregation\", {\n        attrs: {\n            \".marker-target\": {\n                d: \"M 40 10 L 20 20 L 0 10 L 20 0 z\",\n                fill: \"white\"\n            }\n        }\n    });\n    var Composition = Link.define(\"uml.Composition\", {\n        attrs: {\n            \".marker-target\": {\n                d: \"M 40 10 L 20 20 L 0 10 L 20 0 z\",\n                fill: \"black\"\n            }\n        }\n    });\n    var Association = Link.define(\"uml.Association\");\n    // Statechart\n    var State$1 = Generic.define(\"uml.State\", {\n        attrs: {\n            \".uml-state-body\": {\n                \"width\": 200,\n                \"height\": 200,\n                \"rx\": 10,\n                \"ry\": 10,\n                \"fill\": \"#ecf0f1\",\n                \"stroke\": \"#bdc3c7\",\n                \"stroke-width\": 3\n            },\n            \".uml-state-separator\": {\n                \"stroke\": \"#bdc3c7\",\n                \"stroke-width\": 2\n            },\n            \".uml-state-name\": {\n                \"ref\": \".uml-state-body\",\n                \"ref-x\": .5,\n                \"ref-y\": 5,\n                \"text-anchor\": \"middle\",\n                \"fill\": \"#000000\",\n                \"font-family\": \"Courier New\",\n                \"font-size\": 14\n            },\n            \".uml-state-events\": {\n                \"ref\": \".uml-state-separator\",\n                \"ref-x\": 5,\n                \"ref-y\": 5,\n                \"fill\": \"#000000\",\n                \"font-family\": \"Courier New\",\n                \"font-size\": 14\n            }\n        },\n        name: \"State\",\n        events: []\n    }, {\n        markup: [\n            '<g class=\"rotatable\">',\n            '<g class=\"scalable\">',\n            '<rect class=\"uml-state-body\"/>',\n            \"</g>\",\n            '<path class=\"uml-state-separator\"/>',\n            '<text class=\"uml-state-name\"/>',\n            '<text class=\"uml-state-events\"/>',\n            \"</g>\"\n        ].join(\"\"),\n        initialize: function() {\n            this.on({\n                \"change:name\": this.updateName,\n                \"change:events\": this.updateEvents,\n                \"change:size\": this.updatePath\n            }, this);\n            this.updateName();\n            this.updateEvents();\n            this.updatePath();\n            Generic.prototype.initialize.apply(this, arguments);\n        },\n        updateName: function() {\n            this.attr(\".uml-state-name/text\", this.get(\"name\"));\n        },\n        updateEvents: function() {\n            this.attr(\".uml-state-events/text\", this.get(\"events\").join(\"\\n\"));\n        },\n        updatePath: function() {\n            var d = \"M 0 20 L \" + this.get(\"size\").width + \" 20\";\n            // We are using `silent: true` here because updatePath() is meant to be called\n            // on resize and there's no need to to update the element twice (`change:size`\n            // triggers also an update).\n            this.attr(\".uml-state-separator/d\", d, {\n                silent: true\n            });\n        }\n    });\n    var StartState$1 = Circle.define(\"uml.StartState\", {\n        type: \"uml.StartState\",\n        attrs: {\n            circle: {\n                \"fill\": \"#34495e\",\n                \"stroke\": \"#2c3e50\",\n                \"stroke-width\": 2,\n                \"rx\": 1\n            }\n        }\n    });\n    var EndState$1 = Generic.define(\"uml.EndState\", {\n        size: {\n            width: 20,\n            height: 20\n        },\n        attrs: {\n            \"circle.outer\": {\n                transform: \"translate(10, 10)\",\n                r: 10,\n                fill: \"#ffffff\",\n                stroke: \"#2c3e50\"\n            },\n            \"circle.inner\": {\n                transform: \"translate(10, 10)\",\n                r: 6,\n                fill: \"#34495e\"\n            }\n        }\n    }, {\n        markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"outer\"/><circle class=\"inner\"/></g></g>'\n    });\n    var Transition$1 = Link.define(\"uml.Transition\", {\n        attrs: {\n            \".marker-target\": {\n                d: \"M 10 0 L 0 5 L 10 10 z\",\n                fill: \"#34495e\",\n                stroke: \"#2c3e50\"\n            },\n            \".connection\": {\n                stroke: \"#2c3e50\"\n            }\n        }\n    });\n    var uml = {\n        Class: Class,\n        ClassView: ClassView,\n        Abstract: Abstract,\n        AbstractView: AbstractView,\n        Interface: Interface,\n        InterfaceView: InterfaceView,\n        Generalization: Generalization,\n        Implementation: Implementation,\n        Aggregation: Aggregation,\n        Composition: Composition,\n        Association: Association,\n        State: State$1,\n        StartState: StartState$1,\n        EndState: EndState$1,\n        Transition: Transition$1\n    };\n    var index$3 = {\n        basic: basic,\n        standard: standard,\n        devs: devs,\n        logic: logic,\n        chess: chess,\n        erd: erd,\n        fsa: fsa,\n        org: org,\n        pn: pn,\n        uml: uml\n    };\n    function abs2rel(absolute, max) {\n        if (max === 0) return \"0%\";\n        // round to 3 decimal places\n        var dp = 1000;\n        var relative = Math.round(absolute / max * 100 * dp) / dp;\n        return relative + \"%\";\n    }\n    function pin(relative) {\n        return function(end, view, magnet, coords) {\n            var fn = view.isNodeConnection(magnet) ? pinnedLinkEnd : pinnedElementEnd;\n            return fn(relative, end, view, magnet, coords);\n        };\n    }\n    function pinnedElementEnd(relative, end, view, magnet, coords) {\n        var angle = view.model.angle();\n        var bbox = view.getNodeUnrotatedBBox(magnet);\n        var origin = view.model.getBBox().center();\n        coords.rotate(origin, angle);\n        var dx = coords.x - bbox.x;\n        var dy = coords.y - bbox.y;\n        if (relative) {\n            dx = abs2rel(dx, bbox.width);\n            dy = abs2rel(dy, bbox.height);\n        }\n        end.anchor = {\n            name: \"topLeft\",\n            args: {\n                dx: dx,\n                dy: dy,\n                rotate: true\n            }\n        };\n        return end;\n    }\n    function pinnedLinkEnd(relative, end, view, _magnet, coords) {\n        var connection = view.getConnection();\n        if (!connection) return end;\n        var length = connection.closestPointLength(coords);\n        if (relative) {\n            var totalLength = connection.length();\n            end.anchor = {\n                name: \"connectionRatio\",\n                args: {\n                    ratio: length / totalLength\n                }\n            };\n        } else end.anchor = {\n            name: \"connectionLength\",\n            args: {\n                length: length\n            }\n        };\n        return end;\n    }\n    var useDefaults = noop;\n    var pinAbsolute = pin(false);\n    var pinRelative = pin(true);\n    var index$4 = {\n        useDefaults: useDefaults,\n        pinAbsolute: pinAbsolute,\n        pinRelative: pinRelative\n    };\n    // Vertex Handles\n    var VertexHandle = View.extend({\n        tagName: \"circle\",\n        svgElement: true,\n        className: \"marker-vertex\",\n        events: {\n            mousedown: \"onPointerDown\",\n            touchstart: \"onPointerDown\",\n            dblclick: \"onDoubleClick\",\n            dbltap: \"onDoubleClick\"\n        },\n        documentEvents: {\n            mousemove: \"onPointerMove\",\n            touchmove: \"onPointerMove\",\n            mouseup: \"onPointerUp\",\n            touchend: \"onPointerUp\",\n            touchcancel: \"onPointerUp\"\n        },\n        attributes: {\n            \"r\": 6,\n            \"fill\": \"#33334F\",\n            \"stroke\": \"#FFFFFF\",\n            \"stroke-width\": 2,\n            \"cursor\": \"move\"\n        },\n        position: function(x, y) {\n            var ref = this;\n            var vel = ref.vel;\n            var options = ref.options;\n            var scale = options.scale;\n            var matrix = V.createSVGMatrix().translate(x, y);\n            if (scale) matrix = matrix.scale(scale);\n            vel.transform(matrix, {\n                absolute: true\n            });\n        },\n        onPointerDown: function(evt) {\n            if (this.options.guard(evt)) return;\n            evt.stopPropagation();\n            evt.preventDefault();\n            this.options.paper.undelegateEvents();\n            this.delegateDocumentEvents(null, evt.data);\n            this.trigger(\"will-change\", this, evt);\n        },\n        onPointerMove: function(evt) {\n            this.trigger(\"changing\", this, evt);\n        },\n        onDoubleClick: function(evt) {\n            this.trigger(\"remove\", this, evt);\n        },\n        onPointerUp: function(evt) {\n            this.trigger(\"changed\", this, evt);\n            this.undelegateDocumentEvents();\n            this.options.paper.delegateEvents();\n        }\n    });\n    var Vertices = ToolView.extend({\n        name: \"vertices\",\n        options: {\n            handleClass: VertexHandle,\n            snapRadius: 20,\n            redundancyRemoval: true,\n            vertexAdding: true,\n            stopPropagation: true,\n            scale: null\n        },\n        children: [\n            {\n                tagName: \"path\",\n                selector: \"connection\",\n                className: \"joint-vertices-path\",\n                attributes: {\n                    \"fill\": \"none\",\n                    \"stroke\": \"transparent\",\n                    \"stroke-width\": 10,\n                    \"cursor\": \"cell\"\n                }\n            }\n        ],\n        handles: null,\n        events: {\n            \"mousedown .joint-vertices-path\": \"onPathPointerDown\",\n            \"touchstart .joint-vertices-path\": \"onPathPointerDown\"\n        },\n        onRender: function() {\n            if (this.options.vertexAdding) {\n                this.renderChildren();\n                this.updatePath();\n            }\n            this.resetHandles();\n            this.renderHandles();\n            return this;\n        },\n        update: function() {\n            var relatedView = this.relatedView;\n            var vertices = relatedView.model.vertices();\n            if (vertices.length === this.handles.length) this.updateHandles();\n            else {\n                this.resetHandles();\n                this.renderHandles();\n            }\n            if (this.options.vertexAdding) this.updatePath();\n            return this;\n        },\n        resetHandles: function() {\n            var handles = this.handles;\n            this.handles = [];\n            this.stopListening();\n            if (!Array.isArray(handles)) return;\n            for(var i = 0, n = handles.length; i < n; i++)handles[i].remove();\n        },\n        renderHandles: function() {\n            var this$1 = this;\n            var relatedView = this.relatedView;\n            var vertices = relatedView.model.vertices();\n            for(var i = 0, n = vertices.length; i < n; i++){\n                var vertex = vertices[i];\n                var handle = new this.options.handleClass({\n                    index: i,\n                    paper: this.paper,\n                    scale: this.options.scale,\n                    guard: function(evt) {\n                        return this$1.guard(evt);\n                    }\n                });\n                handle.render();\n                handle.position(vertex.x, vertex.y);\n                this.simulateRelatedView(handle.el);\n                handle.vel.appendTo(this.el);\n                this.handles.push(handle);\n                this.startHandleListening(handle);\n            }\n        },\n        updateHandles: function() {\n            var relatedView = this.relatedView;\n            var vertices = relatedView.model.vertices();\n            for(var i = 0, n = vertices.length; i < n; i++){\n                var vertex = vertices[i];\n                var handle = this.handles[i];\n                if (!handle) return;\n                handle.position(vertex.x, vertex.y);\n            }\n        },\n        updatePath: function() {\n            var connection = this.childNodes.connection;\n            if (connection) connection.setAttribute(\"d\", this.relatedView.getSerializedConnection());\n        },\n        startHandleListening: function(handle) {\n            var relatedView = this.relatedView;\n            if (relatedView.can(\"vertexMove\")) {\n                this.listenTo(handle, \"will-change\", this.onHandleWillChange);\n                this.listenTo(handle, \"changing\", this.onHandleChanging);\n                this.listenTo(handle, \"changed\", this.onHandleChanged);\n            }\n            if (relatedView.can(\"vertexRemove\")) this.listenTo(handle, \"remove\", this.onHandleRemove);\n        },\n        getNeighborPoints: function(index) {\n            var linkView = this.relatedView;\n            var vertices = linkView.model.vertices();\n            var prev = index > 0 ? vertices[index - 1] : linkView.sourceAnchor;\n            var next = index < vertices.length - 1 ? vertices[index + 1] : linkView.targetAnchor;\n            return {\n                prev: new Point(prev),\n                next: new Point(next)\n            };\n        },\n        onHandleWillChange: function(_handle, evt) {\n            this.focus();\n            var ref = this;\n            var relatedView = ref.relatedView;\n            var options = ref.options;\n            relatedView.model.startBatch(\"vertex-move\", {\n                ui: true,\n                tool: this.cid\n            });\n            if (!options.stopPropagation) relatedView.notifyPointerdown.apply(relatedView, relatedView.paper.getPointerArgs(evt));\n        },\n        onHandleChanging: function(handle, evt) {\n            var ref = this;\n            var options = ref.options;\n            var linkView = ref.relatedView;\n            var index = handle.options.index;\n            var ref$1 = linkView.paper.getPointerArgs(evt);\n            var normalizedEvent = ref$1[0];\n            var x = ref$1[1];\n            var y = ref$1[2];\n            var vertex = {\n                x: x,\n                y: y\n            };\n            this.snapVertex(vertex, index);\n            linkView.model.vertex(index, vertex, {\n                ui: true,\n                tool: this.cid\n            });\n            handle.position(vertex.x, vertex.y);\n            if (!options.stopPropagation) linkView.notifyPointermove(normalizedEvent, x, y);\n        },\n        onHandleChanged: function(_handle, evt) {\n            var ref = this;\n            var options = ref.options;\n            var linkView = ref.relatedView;\n            if (options.vertexAdding) this.updatePath();\n            if (!options.redundancyRemoval) return;\n            var verticesRemoved = linkView.removeRedundantLinearVertices({\n                ui: true,\n                tool: this.cid\n            });\n            if (verticesRemoved) this.render();\n            this.blur();\n            linkView.model.stopBatch(\"vertex-move\", {\n                ui: true,\n                tool: this.cid\n            });\n            if (this.eventData(evt).vertexAdded) linkView.model.stopBatch(\"vertex-add\", {\n                ui: true,\n                tool: this.cid\n            });\n            var ref$1 = linkView.paper.getPointerArgs(evt);\n            var normalizedEvt = ref$1[0];\n            var x = ref$1[1];\n            var y = ref$1[2];\n            if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvt, x, y);\n            linkView.checkMouseleave(normalizedEvt);\n        },\n        snapVertex: function(vertex, index) {\n            var snapRadius = this.options.snapRadius;\n            if (snapRadius > 0) {\n                var neighbors = this.getNeighborPoints(index);\n                var prev = neighbors.prev;\n                var next = neighbors.next;\n                if (Math.abs(vertex.x - prev.x) < snapRadius) vertex.x = prev.x;\n                else if (Math.abs(vertex.x - next.x) < snapRadius) vertex.x = next.x;\n                if (Math.abs(vertex.y - prev.y) < snapRadius) vertex.y = neighbors.prev.y;\n                else if (Math.abs(vertex.y - next.y) < snapRadius) vertex.y = next.y;\n            }\n        },\n        onHandleRemove: function(handle, evt) {\n            var index$1 = handle.options.index;\n            var linkView = this.relatedView;\n            linkView.model.removeVertex(index$1, {\n                ui: true\n            });\n            if (this.options.vertexAdding) this.updatePath();\n            linkView.checkMouseleave(normalizeEvent(evt));\n        },\n        onPathPointerDown: function(evt) {\n            if (this.guard(evt)) return;\n            evt.stopPropagation();\n            evt.preventDefault();\n            var normalizedEvent = normalizeEvent(evt);\n            var vertex = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY).toJSON();\n            var relatedView = this.relatedView;\n            relatedView.model.startBatch(\"vertex-add\", {\n                ui: true,\n                tool: this.cid\n            });\n            var index$1 = relatedView.getVertexIndex(vertex.x, vertex.y);\n            this.snapVertex(vertex, index$1);\n            relatedView.model.insertVertex(index$1, vertex, {\n                ui: true,\n                tool: this.cid\n            });\n            this.update();\n            var handle = this.handles[index$1];\n            this.eventData(normalizedEvent, {\n                vertexAdded: true\n            });\n            handle.onPointerDown(normalizedEvent);\n        },\n        onRemove: function() {\n            this.resetHandles();\n        }\n    }, {\n        VertexHandle: VertexHandle // keep as class property\n    });\n    function getViewBBox(view, useModelGeometry) {\n        var model = view.model;\n        if (useModelGeometry) return model.getBBox();\n        return model.isLink() ? view.getConnection().bbox() : view.getNodeUnrotatedBBox(view.el);\n    }\n    function getAnchor(coords, view, magnet) {\n        // take advantage of an existing logic inside of the\n        // pin relative connection strategy\n        var end = pinRelative.call(this.paper, {}, view, magnet, coords, this.model);\n        return end.anchor;\n    }\n    function snapAnchor(coords, view, magnet, type, relatedView, toolView) {\n        var snapRadius = toolView.options.snapRadius;\n        var isSource = type === \"source\";\n        var refIndex = isSource ? 0 : -1;\n        var ref = this.model.vertex(refIndex) || this.getEndAnchor(isSource ? \"target\" : \"source\");\n        if (ref) {\n            if (Math.abs(ref.x - coords.x) < snapRadius) coords.x = ref.x;\n            if (Math.abs(ref.y - coords.y) < snapRadius) coords.y = ref.y;\n        }\n        return coords;\n    }\n    var SegmentHandle = View.extend({\n        tagName: \"g\",\n        svgElement: true,\n        className: \"marker-segment\",\n        events: {\n            mousedown: \"onPointerDown\",\n            touchstart: \"onPointerDown\"\n        },\n        documentEvents: {\n            mousemove: \"onPointerMove\",\n            touchmove: \"onPointerMove\",\n            mouseup: \"onPointerUp\",\n            touchend: \"onPointerUp\",\n            touchcancel: \"onPointerUp\"\n        },\n        children: [\n            {\n                tagName: \"line\",\n                selector: \"line\",\n                attributes: {\n                    \"stroke\": \"#33334F\",\n                    \"stroke-width\": 2,\n                    \"fill\": \"none\",\n                    \"pointer-events\": \"none\"\n                }\n            },\n            {\n                tagName: \"rect\",\n                selector: \"handle\",\n                attributes: {\n                    \"width\": 20,\n                    \"height\": 8,\n                    \"x\": -10,\n                    \"y\": -4,\n                    \"rx\": 4,\n                    \"ry\": 4,\n                    \"fill\": \"#33334F\",\n                    \"stroke\": \"#FFFFFF\",\n                    \"stroke-width\": 2\n                }\n            }\n        ],\n        onRender: function() {\n            this.renderChildren();\n        },\n        position: function(x, y, angle, view) {\n            var ref = this.options;\n            var scale = ref.scale;\n            var matrix = V.createSVGMatrix().translate(x, y).rotate(angle);\n            if (scale) matrix = matrix.scale(scale);\n            var handle = this.childNodes.handle;\n            handle.setAttribute(\"transform\", V.matrixToTransformString(matrix));\n            handle.setAttribute(\"cursor\", angle % 180 === 0 ? \"row-resize\" : \"col-resize\");\n            var viewPoint = view.getClosestPoint(new Point(x, y));\n            var line = this.childNodes.line;\n            line.setAttribute(\"x1\", x);\n            line.setAttribute(\"y1\", y);\n            line.setAttribute(\"x2\", viewPoint.x);\n            line.setAttribute(\"y2\", viewPoint.y);\n        },\n        onPointerDown: function(evt) {\n            if (this.options.guard(evt)) return;\n            this.trigger(\"change:start\", this, evt);\n            evt.stopPropagation();\n            evt.preventDefault();\n            this.options.paper.undelegateEvents();\n            this.delegateDocumentEvents(null, evt.data);\n        },\n        onPointerMove: function(evt) {\n            this.trigger(\"changing\", this, evt);\n        },\n        onPointerUp: function(evt) {\n            this.undelegateDocumentEvents();\n            this.options.paper.delegateEvents();\n            this.trigger(\"change:end\", this, evt);\n        },\n        show: function() {\n            this.el.style.display = \"\";\n        },\n        hide: function() {\n            this.el.style.display = \"none\";\n        }\n    });\n    var Segments = ToolView.extend({\n        name: \"segments\",\n        precision: .5,\n        options: {\n            handleClass: SegmentHandle,\n            segmentLengthThreshold: 40,\n            redundancyRemoval: true,\n            anchor: getAnchor,\n            snapRadius: 10,\n            snapHandle: true,\n            stopPropagation: true\n        },\n        handles: null,\n        onRender: function() {\n            this.resetHandles();\n            var relatedView = this.relatedView;\n            var vertices = relatedView.model.vertices();\n            vertices.unshift(relatedView.sourcePoint);\n            vertices.push(relatedView.targetPoint);\n            for(var i = 0, n = vertices.length; i < n - 1; i++){\n                var vertex = vertices[i];\n                var nextVertex = vertices[i + 1];\n                var handle = this.renderHandle(vertex, nextVertex);\n                this.simulateRelatedView(handle.el);\n                this.handles.push(handle);\n                handle.options.index = i;\n            }\n            return this;\n        },\n        renderHandle: function(vertex, nextVertex) {\n            var this$1 = this;\n            var handle = new this.options.handleClass({\n                paper: this.paper,\n                scale: this.options.scale,\n                guard: function(evt) {\n                    return this$1.guard(evt);\n                }\n            });\n            handle.render();\n            this.updateHandle(handle, vertex, nextVertex);\n            handle.vel.appendTo(this.el);\n            this.startHandleListening(handle);\n            return handle;\n        },\n        update: function() {\n            this.render();\n            return this;\n        },\n        startHandleListening: function(handle) {\n            this.listenTo(handle, \"change:start\", this.onHandleChangeStart);\n            this.listenTo(handle, \"changing\", this.onHandleChanging);\n            this.listenTo(handle, \"change:end\", this.onHandleChangeEnd);\n        },\n        resetHandles: function() {\n            var handles = this.handles;\n            this.handles = [];\n            this.stopListening();\n            if (!Array.isArray(handles)) return;\n            for(var i = 0, n = handles.length; i < n; i++)handles[i].remove();\n        },\n        shiftHandleIndexes: function(value) {\n            var handles = this.handles;\n            for(var i = 0, n = handles.length; i < n; i++)handles[i].options.index += value;\n        },\n        resetAnchor: function(type, anchor) {\n            var relatedModel = this.relatedView.model;\n            if (anchor) relatedModel.prop([\n                type,\n                \"anchor\"\n            ], anchor, {\n                rewrite: true,\n                ui: true,\n                tool: this.cid\n            });\n            else relatedModel.removeProp([\n                type,\n                \"anchor\"\n            ], {\n                ui: true,\n                tool: this.cid\n            });\n        },\n        snapHandle: function(handle, position, data) {\n            var index = handle.options.index;\n            var linkView = this.relatedView;\n            var link = linkView.model;\n            var vertices = link.vertices();\n            var axis = handle.options.axis;\n            var prev = vertices[index - 2] || data.sourceAnchor;\n            var next = vertices[index + 1] || data.targetAnchor;\n            var snapRadius = this.options.snapRadius;\n            if (Math.abs(position[axis] - prev[axis]) < snapRadius) position[axis] = prev[axis];\n            else if (Math.abs(position[axis] - next[axis]) < snapRadius) position[axis] = next[axis];\n            return position;\n        },\n        onHandleChanging: function(handle, evt) {\n            var ref = this;\n            var options = ref.options;\n            var data = this.eventData(evt);\n            var relatedView = this.relatedView;\n            var paper = relatedView.paper;\n            var index$1 = handle.options.index - 1;\n            var normalizedEvent = normalizeEvent(evt);\n            var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n            var position = this.snapHandle(handle, coords.clone(), data);\n            var axis = handle.options.axis;\n            var offset = this.options.snapHandle ? 0 : coords[axis] - position[axis];\n            var link = relatedView.model;\n            var vertices = cloneDeep(link.vertices());\n            var anchorFn = this.options.anchor;\n            if (typeof anchorFn !== \"function\") anchorFn = null;\n            var handleIndex = handle.options.index;\n            var vertexPoints = [\n                relatedView.sourcePoint.clone()\n            ].concat(vertices, [\n                relatedView.targetPoint.clone()\n            ]);\n            var indexOffset = 0;\n            // check if vertex before handle vertex exists\n            if (handleIndex - 1 >= 0) {\n                var v1 = vertexPoints[handleIndex - 1];\n                var v2 = vertexPoints[handleIndex];\n                var theta = new Line(v1, v2).vector().theta();\n                // check only non-orthogonal segments\n                if (theta % 90 !== 0) {\n                    vertices.splice(handleIndex - 1, 0, data.originalVertices[handleIndex - 1]);\n                    indexOffset++;\n                    this.shiftHandleIndexes(1);\n                }\n            }\n            var vertex = vertices[index$1 + indexOffset];\n            var nextVertex = vertices[index$1 + 1 + indexOffset];\n            // check if vertex after handle vertex exists\n            if (handleIndex + 2 < vertexPoints.length) {\n                var v1$1 = vertexPoints[handleIndex + 1];\n                var v2$1 = vertexPoints[handleIndex + 2];\n                var theta$1 = new Line(v1$1, v2$1).vector().theta();\n                // check only non-orthogonal segments\n                if (theta$1 % 90 !== 0) {\n                    var isSingleVertex = data.originalVertices.length === 1;\n                    var origVIndex = isSingleVertex ? 0 : handleIndex;\n                    var additionalOffset = data.firstHandleShifted && !isSingleVertex ? 1 : 0;\n                    var nextVIndex = 1 + indexOffset;\n                    vertices.splice(handleIndex + nextVIndex, 0, data.originalVertices[origVIndex - additionalOffset]);\n                }\n            }\n            // First Segment\n            var sourceView = relatedView.sourceView;\n            var sourceBBox = relatedView.sourceBBox;\n            var changeSourceAnchor = false;\n            var deleteSourceAnchor = false;\n            if (!vertex) {\n                vertex = relatedView.sourceAnchor.toJSON();\n                vertex[axis] = position[axis];\n                if (sourceBBox.containsPoint(vertex)) {\n                    vertex[axis] = position[axis];\n                    changeSourceAnchor = true;\n                } else {\n                    // we left the area of the source magnet for the first time\n                    vertices.unshift(vertex);\n                    this.shiftHandleIndexes(1);\n                    data.firstHandleShifted = true;\n                    deleteSourceAnchor = true;\n                }\n            } else if (index$1 === 0) {\n                if (sourceBBox.containsPoint(vertex)) {\n                    vertices.shift();\n                    this.shiftHandleIndexes(-1);\n                    changeSourceAnchor = true;\n                } else {\n                    vertex[axis] = position[axis];\n                    deleteSourceAnchor = true;\n                }\n            } else vertex[axis] = position[axis];\n            if (anchorFn && sourceView) {\n                if (changeSourceAnchor) {\n                    var sourceAnchorPosition = data.sourceAnchor.clone();\n                    sourceAnchorPosition[axis] = position[axis];\n                    var sourceAnchor = anchorFn.call(relatedView, sourceAnchorPosition, sourceView, relatedView.sourceMagnet || sourceView.el, \"source\", relatedView);\n                    this.resetAnchor(\"source\", sourceAnchor);\n                }\n                if (deleteSourceAnchor) this.resetAnchor(\"source\", data.sourceAnchorDef);\n            }\n            // Last segment\n            var targetView = relatedView.targetView;\n            var targetBBox = relatedView.targetBBox;\n            var changeTargetAnchor = false;\n            var deleteTargetAnchor = false;\n            if (!nextVertex) {\n                nextVertex = relatedView.targetAnchor.toJSON();\n                nextVertex[axis] = position[axis];\n                if (targetBBox.containsPoint(nextVertex)) changeTargetAnchor = true;\n                else {\n                    // we left the area of the target magnet for the first time\n                    vertices.push(nextVertex);\n                    deleteTargetAnchor = true;\n                }\n            } else if (index$1 === vertices.length - 2) {\n                if (targetBBox.containsPoint(nextVertex)) {\n                    vertices.pop();\n                    changeTargetAnchor = true;\n                } else {\n                    nextVertex[axis] = position[axis];\n                    deleteTargetAnchor = true;\n                }\n            } else nextVertex[axis] = position[axis];\n            if (anchorFn && targetView) {\n                if (changeTargetAnchor) {\n                    var targetAnchorPosition = data.targetAnchor.clone();\n                    targetAnchorPosition[axis] = position[axis];\n                    var targetAnchor = anchorFn.call(relatedView, targetAnchorPosition, targetView, relatedView.targetMagnet || targetView.el, \"target\", relatedView);\n                    this.resetAnchor(\"target\", targetAnchor);\n                }\n                if (deleteTargetAnchor) this.resetAnchor(\"target\", data.targetAnchorDef);\n            }\n            link.vertices(vertices, {\n                ui: true,\n                tool: this.cid\n            });\n            this.updateHandle(handle, vertex, nextVertex, offset);\n            if (!options.stopPropagation) relatedView.notifyPointermove(normalizedEvent, coords.x, coords.y);\n        },\n        onHandleChangeStart: function(handle, evt) {\n            var ref = this;\n            var options = ref.options;\n            var handles = ref.handles;\n            var linkView = ref.relatedView;\n            var model = linkView.model;\n            var paper = linkView.paper;\n            var index$1 = handle.options.index;\n            if (!Array.isArray(handles)) return;\n            for(var i = 0, n = handles.length; i < n; i++)if (i !== index$1) handles[i].hide();\n            this.focus();\n            this.eventData(evt, {\n                sourceAnchor: linkView.sourceAnchor.clone(),\n                targetAnchor: linkView.targetAnchor.clone(),\n                sourceAnchorDef: clone(model.prop([\n                    \"source\",\n                    \"anchor\"\n                ])),\n                targetAnchorDef: clone(model.prop([\n                    \"target\",\n                    \"anchor\"\n                ])),\n                originalVertices: cloneDeep(model.vertices()),\n                firstHandleShifted: false\n            });\n            model.startBatch(\"segment-move\", {\n                ui: true,\n                tool: this.cid\n            });\n            if (!options.stopPropagation) linkView.notifyPointerdown.apply(linkView, paper.getPointerArgs(evt));\n        },\n        onHandleChangeEnd: function(_handle, evt) {\n            var ref = this;\n            var options = ref.options;\n            var linkView = ref.relatedView;\n            var paper = linkView.paper;\n            var model = linkView.model;\n            if (options.redundancyRemoval) linkView.removeRedundantLinearVertices({\n                ui: true,\n                tool: this.cid\n            });\n            var normalizedEvent = normalizeEvent(evt);\n            var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n            this.render();\n            this.blur();\n            model.stopBatch(\"segment-move\", {\n                ui: true,\n                tool: this.cid\n            });\n            if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvent, coords.x, coords.y);\n            linkView.checkMouseleave(normalizedEvent);\n        },\n        updateHandle: function(handle, vertex, nextVertex, offset) {\n            var vertical = Math.abs(vertex.x - nextVertex.x) < this.precision;\n            var horizontal = Math.abs(vertex.y - nextVertex.y) < this.precision;\n            if (vertical || horizontal) {\n                var segmentLine = new Line(vertex, nextVertex);\n                var length = segmentLine.length();\n                if (length < this.options.segmentLengthThreshold) handle.hide();\n                else {\n                    var position = segmentLine.midpoint();\n                    var axis = vertical ? \"x\" : \"y\";\n                    position[axis] += offset || 0;\n                    var angle = segmentLine.vector().vectorAngle(new Point(1, 0));\n                    handle.position(position.x, position.y, angle, this.relatedView);\n                    handle.show();\n                    handle.options.axis = axis;\n                }\n            } else handle.hide();\n        },\n        onRemove: function() {\n            this.resetHandles();\n        }\n    }, {\n        SegmentHandle: SegmentHandle // keep as class property\n    });\n    // End Markers\n    var Arrowhead = ToolView.extend({\n        tagName: \"path\",\n        xAxisVector: new Point(1, 0),\n        events: {\n            mousedown: \"onPointerDown\",\n            touchstart: \"onPointerDown\"\n        },\n        documentEvents: {\n            mousemove: \"onPointerMove\",\n            touchmove: \"onPointerMove\",\n            mouseup: \"onPointerUp\",\n            touchend: \"onPointerUp\",\n            touchcancel: \"onPointerUp\"\n        },\n        options: {\n            scale: null\n        },\n        onRender: function() {\n            this.update();\n        },\n        update: function() {\n            var ratio = this.ratio;\n            var view = this.relatedView;\n            var tangent = view.getTangentAtRatio(ratio);\n            var position, angle;\n            if (tangent) {\n                position = tangent.start;\n                angle = tangent.vector().vectorAngle(this.xAxisVector) || 0;\n            } else {\n                position = view.getPointAtRatio(ratio);\n                angle = 0;\n            }\n            if (!position) return this;\n            var matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle);\n            var ref = this.options;\n            var scale = ref.scale;\n            if (scale) matrix = matrix.scale(scale);\n            this.vel.transform(matrix, {\n                absolute: true\n            });\n            return this;\n        },\n        onPointerDown: function(evt) {\n            if (this.guard(evt)) return;\n            evt.stopPropagation();\n            evt.preventDefault();\n            var relatedView = this.relatedView;\n            relatedView.model.startBatch(\"arrowhead-move\", {\n                ui: true,\n                tool: this.cid\n            });\n            if (relatedView.can(\"arrowheadMove\")) {\n                relatedView.startArrowheadMove(this.arrowheadType);\n                this.delegateDocumentEvents();\n                relatedView.paper.undelegateEvents();\n            }\n            this.focus();\n            this.el.style.pointerEvents = \"none\";\n        },\n        onPointerMove: function(evt) {\n            var normalizedEvent = normalizeEvent(evt);\n            var coords = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n            this.relatedView.pointermove(normalizedEvent, coords.x, coords.y);\n        },\n        onPointerUp: function(evt) {\n            this.undelegateDocumentEvents();\n            var relatedView = this.relatedView;\n            var paper = relatedView.paper;\n            var normalizedEvent = normalizeEvent(evt);\n            var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n            relatedView.pointerup(normalizedEvent, coords.x, coords.y);\n            paper.delegateEvents();\n            this.blur();\n            this.el.style.pointerEvents = \"\";\n            relatedView.model.stopBatch(\"arrowhead-move\", {\n                ui: true,\n                tool: this.cid\n            });\n        }\n    });\n    var TargetArrowhead = Arrowhead.extend({\n        name: \"target-arrowhead\",\n        ratio: 1,\n        arrowheadType: \"target\",\n        attributes: {\n            \"d\": \"M -10 -8 10 0 -10 8 Z\",\n            \"fill\": \"#33334F\",\n            \"stroke\": \"#FFFFFF\",\n            \"stroke-width\": 2,\n            \"cursor\": \"move\",\n            \"class\": \"target-arrowhead\"\n        }\n    });\n    var SourceArrowhead = Arrowhead.extend({\n        name: \"source-arrowhead\",\n        ratio: 0,\n        arrowheadType: \"source\",\n        attributes: {\n            \"d\": \"M 10 -8 -10 0 10 8 Z\",\n            \"fill\": \"#33334F\",\n            \"stroke\": \"#FFFFFF\",\n            \"stroke-width\": 2,\n            \"cursor\": \"move\",\n            \"class\": \"source-arrowhead\"\n        }\n    });\n    var Boundary = ToolView.extend({\n        name: \"boundary\",\n        tagName: \"rect\",\n        options: {\n            padding: 10,\n            useModelGeometry: false\n        },\n        attributes: {\n            \"fill\": \"none\",\n            \"stroke\": \"#33334F\",\n            \"stroke-width\": .5,\n            \"stroke-dasharray\": \"5, 5\",\n            \"pointer-events\": \"none\"\n        },\n        onRender: function() {\n            this.update();\n        },\n        update: function() {\n            var ref = this;\n            var view = ref.relatedView;\n            var options = ref.options;\n            var vel = ref.vel;\n            var useModelGeometry = options.useModelGeometry;\n            var rotate = options.rotate;\n            var padding = normalizeSides(options.padding);\n            var bbox = getViewBBox(view, useModelGeometry).moveAndExpand({\n                x: -padding.left,\n                y: -padding.top,\n                width: padding.left + padding.right,\n                height: padding.top + padding.bottom\n            });\n            var model = view.model;\n            if (model.isElement()) {\n                var angle = model.angle();\n                if (angle) {\n                    if (rotate) {\n                        var origin = model.getBBox().center();\n                        vel.rotate(angle, origin.x, origin.y, {\n                            absolute: true\n                        });\n                    } else bbox = bbox.bbox(angle);\n                }\n            }\n            vel.attr(bbox.toJSON());\n            return this;\n        }\n    });\n    var Anchor = ToolView.extend({\n        tagName: \"g\",\n        type: null,\n        children: [\n            {\n                tagName: \"circle\",\n                selector: \"anchor\",\n                attributes: {\n                    \"cursor\": \"pointer\"\n                }\n            },\n            {\n                tagName: \"rect\",\n                selector: \"area\",\n                attributes: {\n                    \"pointer-events\": \"none\",\n                    \"fill\": \"none\",\n                    \"stroke\": \"#33334F\",\n                    \"stroke-dasharray\": \"2,4\",\n                    \"rx\": 5,\n                    \"ry\": 5\n                }\n            }\n        ],\n        events: {\n            mousedown: \"onPointerDown\",\n            touchstart: \"onPointerDown\",\n            dblclick: \"onPointerDblClick\",\n            dbltap: \"onPointerDblClick\"\n        },\n        documentEvents: {\n            mousemove: \"onPointerMove\",\n            touchmove: \"onPointerMove\",\n            mouseup: \"onPointerUp\",\n            touchend: \"onPointerUp\",\n            touchcancel: \"onPointerUp\"\n        },\n        options: {\n            snap: snapAnchor,\n            anchor: getAnchor,\n            scale: null,\n            resetAnchor: true,\n            customAnchorAttributes: {\n                \"stroke-width\": 4,\n                \"stroke\": \"#33334F\",\n                \"fill\": \"#FFFFFF\",\n                \"r\": 5\n            },\n            defaultAnchorAttributes: {\n                \"stroke-width\": 2,\n                \"stroke\": \"#FFFFFF\",\n                \"fill\": \"#33334F\",\n                \"r\": 6\n            },\n            areaPadding: 6,\n            snapRadius: 10,\n            restrictArea: true,\n            redundancyRemoval: true\n        },\n        onRender: function() {\n            this.renderChildren();\n            this.toggleArea(false);\n            this.update();\n        },\n        update: function() {\n            var type = this.type;\n            var relatedView = this.relatedView;\n            var view = relatedView.getEndView(type);\n            if (view) {\n                this.updateAnchor();\n                this.updateArea();\n                this.el.style.display = \"\";\n            } else this.el.style.display = \"none\";\n            return this;\n        },\n        updateAnchor: function() {\n            var childNodes = this.childNodes;\n            if (!childNodes) return;\n            var anchorNode = childNodes.anchor;\n            if (!anchorNode) return;\n            var relatedView = this.relatedView;\n            var type = this.type;\n            var position = relatedView.getEndAnchor(type);\n            var options = this.options;\n            var customAnchor = relatedView.model.prop([\n                type,\n                \"anchor\"\n            ]);\n            var transformString = \"translate(\" + position.x + \",\" + position.y + \")\";\n            if (options.scale) transformString += \" scale(\" + options.scale + \")\";\n            anchorNode.setAttribute(\"transform\", transformString);\n            var anchorAttributes = customAnchor ? options.customAnchorAttributes : options.defaultAnchorAttributes;\n            for(var attrName in anchorAttributes)anchorNode.setAttribute(attrName, anchorAttributes[attrName]);\n        },\n        updateArea: function() {\n            var childNodes = this.childNodes;\n            if (!childNodes) return;\n            var areaNode = childNodes.area;\n            if (!areaNode) return;\n            var relatedView = this.relatedView;\n            var type = this.type;\n            var view = relatedView.getEndView(type);\n            var model = view.model;\n            var magnet = relatedView.getEndMagnet(type);\n            var padding = this.options.areaPadding;\n            if (!isFinite(padding)) padding = 0;\n            var bbox, angle, center;\n            if (view.isNodeConnection(magnet)) {\n                bbox = view.getNodeBBox(magnet);\n                angle = 0;\n                center = bbox.center();\n            } else {\n                bbox = view.getNodeUnrotatedBBox(magnet);\n                angle = model.angle();\n                center = bbox.center();\n                if (angle) center.rotate(model.getBBox().center(), -angle);\n            // TODO: get the link's magnet rotation into account\n            }\n            bbox.inflate(padding);\n            areaNode.setAttribute(\"x\", -bbox.width / 2);\n            areaNode.setAttribute(\"y\", -bbox.height / 2);\n            areaNode.setAttribute(\"width\", bbox.width);\n            areaNode.setAttribute(\"height\", bbox.height);\n            areaNode.setAttribute(\"transform\", \"translate(\" + center.x + \",\" + center.y + \") rotate(\" + angle + \")\");\n        },\n        toggleArea: function(visible) {\n            var childNodes = this.childNodes;\n            if (!childNodes) return;\n            var areaNode = childNodes.area;\n            if (!areaNode) return;\n            areaNode.style.display = visible ? \"\" : \"none\";\n        },\n        onPointerDown: function(evt) {\n            if (this.guard(evt)) return;\n            evt.stopPropagation();\n            evt.preventDefault();\n            this.paper.undelegateEvents();\n            this.delegateDocumentEvents();\n            this.focus();\n            this.toggleArea(this.options.restrictArea);\n            this.relatedView.model.startBatch(\"anchor-move\", {\n                ui: true,\n                tool: this.cid\n            });\n        },\n        resetAnchor: function(anchor) {\n            var type = this.type;\n            var relatedModel = this.relatedView.model;\n            if (anchor) relatedModel.prop([\n                type,\n                \"anchor\"\n            ], anchor, {\n                rewrite: true,\n                ui: true,\n                tool: this.cid\n            });\n            else relatedModel.removeProp([\n                type,\n                \"anchor\"\n            ], {\n                ui: true,\n                tool: this.cid\n            });\n        },\n        onPointerMove: function(evt) {\n            var relatedView = this.relatedView;\n            var type = this.type;\n            var view = relatedView.getEndView(type);\n            var model = view.model;\n            var magnet = relatedView.getEndMagnet(type);\n            var normalizedEvent = normalizeEvent(evt);\n            var coords = this.paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n            var snapFn = this.options.snap;\n            if (typeof snapFn === \"function\") {\n                coords = snapFn.call(relatedView, coords, view, magnet, type, relatedView, this);\n                coords = new Point(coords);\n            }\n            if (this.options.restrictArea) {\n                if (view.isNodeConnection(magnet)) {\n                    // snap coords to the link's connection\n                    var pointAtConnection = view.getClosestPoint(coords);\n                    if (pointAtConnection) coords = pointAtConnection;\n                } else {\n                    // snap coords within node bbox\n                    var bbox = view.getNodeUnrotatedBBox(magnet);\n                    var angle = model.angle();\n                    var origin = model.getBBox().center();\n                    var rotatedCoords = coords.clone().rotate(origin, angle);\n                    if (!bbox.containsPoint(rotatedCoords)) coords = bbox.pointNearestToPoint(rotatedCoords).rotate(origin, -angle);\n                }\n            }\n            var anchor;\n            var anchorFn = this.options.anchor;\n            if (typeof anchorFn === \"function\") anchor = anchorFn.call(relatedView, coords, view, magnet, type, relatedView);\n            this.resetAnchor(anchor);\n            this.update();\n        },\n        onPointerUp: function(evt) {\n            var normalizedEvent = normalizeEvent(evt);\n            this.paper.delegateEvents();\n            this.undelegateDocumentEvents();\n            this.blur();\n            this.toggleArea(false);\n            var linkView = this.relatedView;\n            if (this.options.redundancyRemoval) linkView.removeRedundantLinearVertices({\n                ui: true,\n                tool: this.cid\n            });\n            linkView.checkMouseleave(normalizedEvent);\n            linkView.model.stopBatch(\"anchor-move\", {\n                ui: true,\n                tool: this.cid\n            });\n        },\n        onPointerDblClick: function() {\n            var anchor = this.options.resetAnchor;\n            if (anchor === false) return;\n             // reset anchor disabled\n            if (anchor === true) anchor = null;\n             // remove the current anchor\n            this.resetAnchor(cloneDeep(anchor));\n            this.update();\n        }\n    });\n    var SourceAnchor = Anchor.extend({\n        name: \"source-anchor\",\n        type: \"source\"\n    });\n    var TargetAnchor = Anchor.extend({\n        name: \"target-anchor\",\n        type: \"target\"\n    });\n    var Button = ToolView.extend({\n        name: \"button\",\n        events: {\n            \"mousedown\": \"onPointerDown\",\n            \"touchstart\": \"onPointerDown\"\n        },\n        options: {\n            distance: 0,\n            offset: 0,\n            scale: null,\n            rotate: false\n        },\n        onRender: function() {\n            this.renderChildren(this.options.markup);\n            this.update();\n        },\n        update: function() {\n            this.position();\n            return this;\n        },\n        position: function() {\n            var ref = this;\n            var vel = ref.vel;\n            vel.transform(this.getCellMatrix(), {\n                absolute: true\n            });\n        },\n        getCellMatrix: function getCellMatrix() {\n            return this.relatedView.model.isLink() ? this.getLinkMatrix() : this.getElementMatrix();\n        },\n        getElementMatrix: function getElementMatrix() {\n            var ref = this;\n            var view = ref.relatedView;\n            var options = ref.options;\n            var x = options.x;\n            if (x === void 0) x = 0;\n            var y = options.y;\n            if (y === void 0) y = 0;\n            var offset = options.offset;\n            if (offset === void 0) offset = {};\n            var useModelGeometry = options.useModelGeometry;\n            var rotate = options.rotate;\n            var scale = options.scale;\n            var bbox = getViewBBox(view, useModelGeometry);\n            var angle = view.model.angle();\n            if (!rotate) bbox = bbox.bbox(angle);\n            var offsetX = offset.x;\n            if (offsetX === void 0) offsetX = 0;\n            var offsetY = offset.y;\n            if (offsetY === void 0) offsetY = 0;\n            if (isPercentage(x)) x = parseFloat(x) / 100 * bbox.width;\n            else if (isCalcAttribute(x)) x = Number(evalCalcAttribute(x, bbox));\n            if (isPercentage(y)) y = parseFloat(y) / 100 * bbox.height;\n            else if (isCalcAttribute(y)) y = Number(evalCalcAttribute(y, bbox));\n            var matrix = V.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n            if (rotate) matrix = matrix.rotate(angle);\n            matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);\n            if (scale) matrix = matrix.scale(scale);\n            return matrix;\n        },\n        getLinkMatrix: function getLinkMatrix() {\n            var ref = this;\n            var view = ref.relatedView;\n            var options = ref.options;\n            var offset = options.offset;\n            if (offset === void 0) offset = 0;\n            var distance = options.distance;\n            if (distance === void 0) distance = 0;\n            var rotate = options.rotate;\n            var scale = options.scale;\n            var tangent, position, angle;\n            if (isPercentage(distance)) tangent = view.getTangentAtRatio(parseFloat(distance) / 100);\n            else tangent = view.getTangentAtLength(distance);\n            if (tangent) {\n                position = tangent.start;\n                angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;\n            } else {\n                position = view.getConnection().start;\n                angle = 0;\n            }\n            var matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle).translate(0, offset);\n            if (!rotate) matrix = matrix.rotate(-angle);\n            if (scale) matrix = matrix.scale(scale);\n            return matrix;\n        },\n        onPointerDown: function(evt) {\n            if (this.guard(evt)) return;\n            evt.stopPropagation();\n            evt.preventDefault();\n            var actionFn = this.options.action;\n            if (typeof actionFn === \"function\") actionFn.call(this.relatedView, evt, this.relatedView, this);\n        }\n    });\n    var Remove = Button.extend({\n        children: [\n            {\n                tagName: \"circle\",\n                selector: \"button\",\n                attributes: {\n                    \"r\": 7,\n                    \"fill\": \"#FF1D00\",\n                    \"cursor\": \"pointer\"\n                }\n            },\n            {\n                tagName: \"path\",\n                selector: \"icon\",\n                attributes: {\n                    \"d\": \"M -3 -3 3 3 M -3 3 3 -3\",\n                    \"fill\": \"none\",\n                    \"stroke\": \"#FFFFFF\",\n                    \"stroke-width\": 2,\n                    \"pointer-events\": \"none\"\n                }\n            }\n        ],\n        options: {\n            distance: 60,\n            offset: 0,\n            action: function(evt, view, tool) {\n                view.model.remove({\n                    ui: true,\n                    tool: tool.cid\n                });\n            }\n        }\n    });\n    var Connect = Button.extend({\n        name: \"connect\",\n        documentEvents: {\n            mousemove: \"drag\",\n            touchmove: \"drag\",\n            mouseup: \"dragend\",\n            touchend: \"dragend\",\n            touchcancel: \"dragend\"\n        },\n        children: [\n            {\n                tagName: \"circle\",\n                selector: \"button\",\n                attributes: {\n                    \"r\": 7,\n                    \"fill\": \"#333333\",\n                    \"cursor\": \"pointer\"\n                }\n            },\n            {\n                tagName: \"path\",\n                selector: \"icon\",\n                attributes: {\n                    \"d\": \"M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z\",\n                    \"fill\": \"#FFFFFF\",\n                    \"stroke\": \"none\",\n                    \"stroke-width\": 2,\n                    \"pointer-events\": \"none\"\n                }\n            }\n        ],\n        options: {\n            distance: 80,\n            offset: 0,\n            magnet: function(view) {\n                return view.el;\n            },\n            action: function(evt, _view, tool) {\n                return tool.dragstart(evt);\n            }\n        },\n        getMagnetNode: function() {\n            var assign;\n            var ref = this;\n            var options = ref.options;\n            var relatedView = ref.relatedView;\n            var magnet = options.magnet;\n            var magnetNode;\n            switch(typeof magnet){\n                case \"function\":\n                    magnetNode = magnet.call(this, relatedView, this);\n                    break;\n                case \"string\":\n                    assign = relatedView.findBySelector(magnet), magnetNode = assign[0];\n                    break;\n                default:\n                    magnetNode = magnet;\n                    break;\n            }\n            if (!magnetNode) magnetNode = relatedView.el;\n            if (magnetNode instanceof SVGElement) return magnetNode;\n            throw new Error(\"Connect: magnet must be an SVGElement\");\n        },\n        dragstart: function(evt) {\n            var ref = this;\n            var paper = ref.paper;\n            var relatedView = ref.relatedView;\n            var normalizedEvent = normalizeEvent(evt);\n            var ref$1 = paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n            var x = ref$1.x;\n            var y = ref$1.y;\n            relatedView.dragLinkStart(normalizedEvent, this.getMagnetNode(), x, y);\n            paper.undelegateEvents();\n            this.delegateDocumentEvents(null, normalizedEvent.data);\n            this.focus();\n        },\n        drag: function(evt) {\n            var ref = this;\n            var paper = ref.paper;\n            var relatedView = ref.relatedView;\n            var normalizedEvent = normalizeEvent(evt);\n            var ref$1 = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n            var x = ref$1.x;\n            var y = ref$1.y;\n            relatedView.dragLink(normalizedEvent, x, y);\n        },\n        dragend: function(evt) {\n            var ref = this;\n            var paper = ref.paper;\n            var relatedView = ref.relatedView;\n            var normalizedEvent = normalizeEvent(evt);\n            var ref$1 = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n            var x = ref$1.x;\n            var y = ref$1.y;\n            relatedView.dragLinkEnd(normalizedEvent, x, y);\n            this.undelegateDocumentEvents();\n            paper.delegateEvents();\n            this.blur();\n            relatedView.checkMouseleave(normalizedEvent);\n        }\n    });\n    var HoverConnect = Connect.extend({\n        name: \"hover-connect\",\n        defaultMarkup: [\n            {\n                tagName: \"circle\",\n                attributes: {\n                    \"r\": 7,\n                    \"fill\": \"#333333\",\n                    \"cursor\": \"pointer\"\n                }\n            },\n            {\n                tagName: \"path\",\n                attributes: {\n                    \"d\": \"M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z\",\n                    \"fill\": \"#FFFFFF\",\n                    \"stroke\": \"none\",\n                    \"stroke-width\": 2\n                }\n            }\n        ],\n        children: function children() {\n            var ref = this;\n            var options = ref.options;\n            var defaultMarkup = ref.defaultMarkup;\n            return [\n                {\n                    tagName: \"path\",\n                    selector: \"track\",\n                    attributes: {\n                        \"fill\": \"none\",\n                        \"stroke\": \"transparent\",\n                        \"stroke-width\": options.trackWidth || 15,\n                        \"cursor\": \"pointer\"\n                    }\n                },\n                {\n                    tagName: \"g\",\n                    selector: \"button\",\n                    attributes: {\n                        \"pointer-events\": \"none\",\n                        \"display\": \"none\"\n                    },\n                    children: options.markup || defaultMarkup\n                }\n            ];\n        },\n        events: Object.assign({\n            mousemove: \"onMousemove\",\n            mouseenter: \"onMouseenter\",\n            mouseleave: \"onMouseleave\"\n        }, Connect.prototype.events),\n        onRender: function() {\n            this.renderChildren();\n            this.update();\n        },\n        trackPath: null,\n        update: function update() {\n            var ref = this;\n            var childNodes = ref.childNodes;\n            this.trackPath = this.getTrackPath();\n            Connect.prototype.update.apply(this, arguments);\n            childNodes.track.setAttribute(\"d\", this.trackPath.serialize());\n        },\n        position: function position() {\n            var ref = this;\n            var el = ref.el;\n            var childNodes = ref.childNodes;\n            childNodes.button.setAttribute(\"transform\", V.matrixToTransformString(this.getButtonMatrix()));\n            el.setAttribute(\"transform\", V.matrixToTransformString(this.getTrackMatrix()));\n        },\n        getButtonMatrix: function getButtonMatrix() {\n            var ref = this;\n            var options = ref.options;\n            var trackPath = ref.trackPath;\n            var offset = options.offset;\n            if (offset === void 0) offset = 0;\n            var distance = options.distance;\n            if (distance === void 0) distance = 0;\n            var rotate = options.rotate;\n            var scale = options.scale;\n            var tangent, position, angle;\n            if (isPercentage(distance)) tangent = trackPath.tangentAtRatio(parseFloat(distance) / 100);\n            else tangent = trackPath.tangentAtLength(distance);\n            if (tangent) {\n                position = tangent.start;\n                angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;\n            } else {\n                position = trackPath.start;\n                angle = 0;\n            }\n            var matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle).translate(0, offset);\n            if (!rotate) matrix = matrix.rotate(-angle);\n            if (scale) matrix = matrix.scale(scale);\n            return matrix;\n        },\n        getTrackPath: function getTrackPath() {\n            return this.relatedView.getConnection();\n        },\n        getTrackMatrix: function getTrackMatrix() {\n            return V.createSVGMatrix();\n        },\n        getTrackRatioFromEvent: function getTrackRatioFromEvent(evt) {\n            var ref = this;\n            var relatedView = ref.relatedView;\n            var trackPath = ref.trackPath;\n            var localPoint = relatedView.paper.clientToLocalPoint(evt.clientX, evt.clientY);\n            var trackPoint = V.transformPoint(localPoint, this.getTrackMatrix().inverse());\n            return trackPath.closestPointLength(trackPoint);\n        },\n        canShowButton: function canShowButton() {\n            // Has been the paper events undelegated? If so, we can't show the button.\n            // TODO: add a method to the paper to check if the events are delegated.\n            return $._data(this.paper.el, \"events\");\n        },\n        showButton: function showButton() {\n            this.childNodes.button.style.display = \"block\";\n        },\n        hideButton: function hideButton() {\n            this.childNodes.button.style.display = \"\";\n        },\n        onMousemove: function onMousemove(evt) {\n            var ref = this;\n            var trackPath = ref.trackPath;\n            if (!trackPath) return;\n            var ref$1 = this;\n            var options = ref$1.options;\n            options.distance = this.getTrackRatioFromEvent(evt);\n            this.position();\n        },\n        onMouseenter: function onMouseenter() {\n            if (!this.canShowButton()) return;\n            this.showButton();\n        },\n        onMouseleave: function onMouseleave() {\n            this.hideButton();\n        }\n    });\n    var index$5 = {\n        Vertices: Vertices,\n        Segments: Segments,\n        TargetArrowhead: TargetArrowhead,\n        SourceArrowhead: SourceArrowhead,\n        Boundary: Boundary,\n        SourceAnchor: SourceAnchor,\n        TargetAnchor: TargetAnchor,\n        Button: Button,\n        Remove: Remove,\n        Connect: Connect,\n        HoverConnect: HoverConnect\n    };\n    var Control = ToolView.extend({\n        tagName: \"g\",\n        children: [\n            {\n                tagName: \"circle\",\n                selector: \"handle\",\n                attributes: {\n                    \"cursor\": \"pointer\",\n                    \"stroke-width\": 2,\n                    \"stroke\": \"#FFFFFF\",\n                    \"fill\": \"#33334F\",\n                    \"r\": 6\n                }\n            },\n            {\n                tagName: \"rect\",\n                selector: \"extras\",\n                attributes: {\n                    \"pointer-events\": \"none\",\n                    \"fill\": \"none\",\n                    \"stroke\": \"#33334F\",\n                    \"stroke-dasharray\": \"2,4\",\n                    \"rx\": 5,\n                    \"ry\": 5\n                }\n            }\n        ],\n        events: {\n            mousedown: \"onPointerDown\",\n            touchstart: \"onPointerDown\",\n            dblclick: \"onPointerDblClick\",\n            dbltap: \"onPointerDblClick\"\n        },\n        documentEvents: {\n            mousemove: \"onPointerMove\",\n            touchmove: \"onPointerMove\",\n            mouseup: \"onPointerUp\",\n            touchend: \"onPointerUp\",\n            touchcancel: \"onPointerUp\"\n        },\n        options: {\n            handleAttributes: null,\n            selector: \"root\",\n            padding: 6,\n            scale: null\n        },\n        getPosition: function() {\n        // To be overridden\n        },\n        setPosition: function() {\n        // To be overridden\n        },\n        resetPosition: function() {\n        // To be overridden\n        },\n        onRender: function() {\n            this.renderChildren();\n            this.toggleExtras(false);\n            this.update();\n        },\n        update: function() {\n            var ref = this.childNodes;\n            var handle = ref.handle;\n            var extras = ref.extras;\n            if (handle) this.updateHandle(handle);\n            else throw new Error(\"Control: markup selector `handle` is required\");\n            if (extras) this.updateExtras(extras);\n            return this;\n        },\n        updateHandle: function(handleNode) {\n            var ref = this;\n            var relatedView = ref.relatedView;\n            var options = ref.options;\n            var model = relatedView.model;\n            var relativePos = this.getPosition(relatedView, this);\n            var absolutePos = model.getAbsolutePointFromRelative(relativePos);\n            var handleAttributes = options.handleAttributes;\n            var scale = options.scale;\n            var transformString = \"translate(\" + absolutePos.x + \",\" + absolutePos.y + \")\";\n            if (scale) transformString += \" scale(\" + scale + \")\";\n            handleNode.setAttribute(\"transform\", transformString);\n            if (handleAttributes) for(var attrName in handleAttributes)handleNode.setAttribute(attrName, handleAttributes[attrName]);\n        },\n        updateExtras: function(extrasNode) {\n            var ref = this;\n            var relatedView = ref.relatedView;\n            var options = ref.options;\n            var ref$1 = this.options;\n            var selector = ref$1.selector;\n            if (!selector) {\n                this.toggleExtras(false);\n                return;\n            }\n            var ref$2 = relatedView.findBySelector(selector);\n            var magnet = ref$2[0];\n            if (!magnet) throw new Error(\"Control: invalid selector.\");\n            var padding = options.padding;\n            if (!isFinite(padding)) padding = 0;\n            var bbox = relatedView.getNodeUnrotatedBBox(magnet);\n            var model = relatedView.model;\n            var angle = model.angle();\n            var center = bbox.center();\n            if (angle) center.rotate(model.getBBox().center(), -angle);\n            bbox.inflate(padding);\n            extrasNode.setAttribute(\"x\", -bbox.width / 2);\n            extrasNode.setAttribute(\"y\", -bbox.height / 2);\n            extrasNode.setAttribute(\"width\", bbox.width);\n            extrasNode.setAttribute(\"height\", bbox.height);\n            extrasNode.setAttribute(\"transform\", \"translate(\" + center.x + \",\" + center.y + \") rotate(\" + angle + \")\");\n        },\n        toggleExtras: function(visible) {\n            var ref = this.childNodes;\n            var extras = ref.extras;\n            if (!extras) return;\n            extras.style.display = visible ? \"\" : \"none\";\n        },\n        onPointerDown: function(evt) {\n            var ref = this;\n            var relatedView = ref.relatedView;\n            var paper = ref.paper;\n            if (this.guard(evt)) return;\n            evt.stopPropagation();\n            evt.preventDefault();\n            paper.undelegateEvents();\n            this.delegateDocumentEvents();\n            this.focus();\n            this.toggleExtras(true);\n            relatedView.model.startBatch(\"control-move\", {\n                ui: true,\n                tool: this.cid\n            });\n        },\n        onPointerMove: function(evt) {\n            var ref = this;\n            var relatedView = ref.relatedView;\n            var paper = ref.paper;\n            var model = relatedView.model;\n            var ref$1 = normalizeEvent(evt);\n            var clientX = ref$1.clientX;\n            var clientY = ref$1.clientY;\n            var coords = paper.clientToLocalPoint(clientX, clientY);\n            var relativeCoords = model.getRelativePointFromAbsolute(coords);\n            this.setPosition(relatedView, relativeCoords, this);\n            this.update();\n        },\n        onPointerUp: function(_evt) {\n            var ref = this;\n            var relatedView = ref.relatedView;\n            var paper = ref.paper;\n            paper.delegateEvents();\n            this.undelegateDocumentEvents();\n            this.blur();\n            this.toggleExtras(false);\n            relatedView.model.stopBatch(\"control-move\", {\n                ui: true,\n                tool: this.cid\n            });\n        },\n        onPointerDblClick: function() {\n            var ref = this;\n            var relatedView = ref.relatedView;\n            this.resetPosition(relatedView, this);\n            this.update();\n        }\n    });\n    var HoverConnect$1 = HoverConnect.extend({\n        getTrackPath: function getTrackPath() {\n            var ref = this;\n            var view = ref.relatedView;\n            var options = ref.options;\n            var useModelGeometry = options.useModelGeometry;\n            var trackPath = options.trackPath;\n            if (trackPath === void 0) trackPath = \"M 0 0 H calc(w) V calc(h) H 0 Z\";\n            if (typeof trackPath === \"function\") trackPath = trackPath.call(this, view);\n            if (isCalcAttribute(trackPath)) {\n                var bbox = getViewBBox(view, useModelGeometry);\n                trackPath = evalCalcAttribute(trackPath, bbox);\n            }\n            return new Path(V.normalizePathData(trackPath));\n        },\n        getTrackMatrix: function getTrackMatrix() {\n            var ref = this;\n            var view = ref.relatedView;\n            var options = ref.options;\n            var useModelGeometry = options.useModelGeometry;\n            var rotate = options.rotate;\n            var bbox = getViewBBox(view, useModelGeometry);\n            var angle = view.model.angle();\n            if (!rotate) bbox = bbox.bbox(angle);\n            var matrix = V.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n            if (rotate) matrix = matrix.rotate(angle);\n            matrix = matrix.translate(-bbox.width / 2, -bbox.height / 2);\n            return matrix;\n        }\n    });\n    var index$6 = {\n        Button: Button,\n        Remove: Remove,\n        Connect: Connect,\n        Boundary: Boundary,\n        HoverConnect: HoverConnect$1,\n        Control: Control\n    };\n    var version = \"3.7.1\";\n    var Vectorizer = V;\n    var layout = {\n        PortLabel: PortLabel,\n        Port: Port\n    };\n    var setTheme = function(theme, opt) {\n        opt = opt || {};\n        invoke(views, \"setTheme\", theme, opt);\n        // Update the default theme on the view prototype.\n        View.prototype.defaultTheme = theme;\n    };\n    var layout$1 = {\n        DirectedGraph: DirectedGraph,\n        PortLabel: PortLabel,\n        Port: Port\n    };\n    // export empty namespaces - backward compatibility\n    var format$1 = {};\n    var ui = {};\n    exports1.V = V;\n    exports1.Vectorizer = Vectorizer;\n    exports1.anchors = anchors;\n    exports1.config = config;\n    exports1.connectionPoints = connectionPoints;\n    exports1.connectionStrategies = index$4;\n    exports1.connectors = connectors;\n    exports1.dia = index$2;\n    exports1.elementTools = index$6;\n    exports1.env = env;\n    exports1.format = format$1;\n    exports1.g = g;\n    exports1.highlighters = highlighters;\n    exports1.layout = layout$1;\n    exports1.linkAnchors = linkAnchors;\n    exports1.linkTools = index$5;\n    exports1.mvc = index$1;\n    exports1.routers = routers;\n    exports1.setTheme = setTheme;\n    exports1.shapes = index$3;\n    exports1.ui = ui;\n    exports1.util = index;\n    exports1.version = version;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n});\nif (typeof joint !== \"undefined\") var $f5012df62a53a94d$var$g = joint.g, $f5012df62a53a94d$var$V = joint.V, $f5012df62a53a94d$var$Vectorizer = joint.V;\n\n\n//# sourceMappingURL=client.2f082e59.js.map\n","//     Backbone.js 1.5.0\n\n//     (c) 2010-2022 Jeremy Ashkenas and DocumentCloud\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n\n(function(factory) {\n\n  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.\n  // We use `self` instead of `window` for `WebWorker` support.\n  var root = typeof self == 'object' && self.self === self && self ||\n            typeof global == 'object' && global.global === global && global;\n\n  // Set up Backbone appropriately for the environment. Start with AMD.\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {\n      // Export global even in AMD case in case this script is loaded with\n      // others that may still expect a global Backbone.\n      root.Backbone = factory(root, exports, _, $);\n    });\n\n  // Next for Node.js or CommonJS. jQuery may not be needed as a module.\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore'), $;\n    try { $ = require('jquery'); } catch (e) {}\n    factory(root, exports, _, $);\n\n  // Finally, as a browser global.\n  } else {\n    root.Backbone = factory(root, {}, root._, root.jQuery || root.Zepto || root.ender || root.$);\n  }\n\n})(function(root, Backbone, _, $) {\n\n  // Initial Setup\n  // -------------\n\n  // Save the previous value of the `Backbone` variable, so that it can be\n  // restored later on, if `noConflict` is used.\n  var previousBackbone = root.Backbone;\n\n  // Create a local reference to a common array method we'll want to use later.\n  var slice = Array.prototype.slice;\n\n  // Current version of the library. Keep in sync with `package.json`.\n  Backbone.VERSION = '1.5.0';\n\n  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\n  // the `$` variable.\n  Backbone.$ = $;\n\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n  // to its previous owner. Returns a reference to this Backbone object.\n  Backbone.noConflict = function() {\n    root.Backbone = previousBackbone;\n    return this;\n  };\n\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n  // will fake `\"PATCH\"`, `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n  // set a `X-Http-Method-Override` header.\n  Backbone.emulateHTTP = false;\n\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n  // `application/json` requests ... this will encode the body as\n  // `application/x-www-form-urlencoded` instead and will send the model in a\n  // form param named `model`.\n  Backbone.emulateJSON = false;\n\n  // Backbone.Events\n  // ---------------\n\n  // A module that can be mixed in to *any object* in order to provide it with\n  // a custom event channel. You may bind a callback to an event with `on` or\n  // remove with `off`; `trigger`-ing an event fires all callbacks in\n  // succession.\n  //\n  //     var object = {};\n  //     _.extend(object, Backbone.Events);\n  //     object.on('expand', function(){ alert('expanded'); });\n  //     object.trigger('expand');\n  //\n  var Events = Backbone.Events = {};\n\n  // Regular expression used to split event strings.\n  var eventSplitter = /\\s+/;\n\n  // A private global variable to share between listeners and listenees.\n  var _listening;\n\n  // Iterates over the standard `event, callback` (as well as the fancy multiple\n  // space-separated events `\"change blur\", callback` and jQuery-style event\n  // maps `{event: callback}`).\n  var eventsApi = function(iteratee, events, name, callback, opts) {\n    var i = 0, names;\n    if (name && typeof name === 'object') {\n      // Handle event maps.\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;\n      for (names = _.keys(name); i < names.length ; i++) {\n        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n      }\n    } else if (name && eventSplitter.test(name)) {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(eventSplitter); i < names.length; i++) {\n        events = iteratee(events, names[i], callback, opts);\n      }\n    } else {\n      // Finally, standard events.\n      events = iteratee(events, name, callback, opts);\n    }\n    return events;\n  };\n\n  // Bind an event to a `callback` function. Passing `\"all\"` will bind\n  // the callback to all events fired.\n  Events.on = function(name, callback, context) {\n    this._events = eventsApi(onApi, this._events || {}, name, callback, {\n      context: context,\n      ctx: this,\n      listening: _listening\n    });\n\n    if (_listening) {\n      var listeners = this._listeners || (this._listeners = {});\n      listeners[_listening.id] = _listening;\n      // Allow the listening to use a counter, instead of tracking\n      // callbacks for library interop\n      _listening.interop = false;\n    }\n\n    return this;\n  };\n\n  // Inversion-of-control versions of `on`. Tell *this* object to listen to\n  // an event in another object... keeping track of what it's listening to\n  // for easier unbinding later.\n  Events.listenTo = function(obj, name, callback) {\n    if (!obj) return this;\n    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var listening = _listening = listeningTo[id];\n\n    // This object is not listening to any other events on `obj` yet.\n    // Setup the necessary references to track the listening callbacks.\n    if (!listening) {\n      this._listenId || (this._listenId = _.uniqueId('l'));\n      listening = _listening = listeningTo[id] = new Listening(this, obj);\n    }\n\n    // Bind callbacks on obj.\n    var error = tryCatchOn(obj, name, callback, this);\n    _listening = void 0;\n\n    if (error) throw error;\n    // If the target obj is not Backbone.Events, track events manually.\n    if (listening.interop) listening.on(name, callback);\n\n    return this;\n  };\n\n  // The reducing API that adds a callback to the `events` object.\n  var onApi = function(events, name, callback, options) {\n    if (callback) {\n      var handlers = events[name] || (events[name] = []);\n      var context = options.context, ctx = options.ctx, listening = options.listening;\n      if (listening) listening.count++;\n\n      handlers.push({callback: callback, context: context, ctx: context || ctx, listening: listening});\n    }\n    return events;\n  };\n\n  // An try-catch guarded #on function, to prevent poisoning the global\n  // `_listening` variable.\n  var tryCatchOn = function(obj, name, callback, context) {\n    try {\n      obj.on(name, callback, context);\n    } catch (e) {\n      return e;\n    }\n  };\n\n  // Remove one or many callbacks. If `context` is null, removes all\n  // callbacks with that function. If `callback` is null, removes all\n  // callbacks for the event. If `name` is null, removes all bound\n  // callbacks for all events.\n  Events.off = function(name, callback, context) {\n    if (!this._events) return this;\n    this._events = eventsApi(offApi, this._events, name, callback, {\n      context: context,\n      listeners: this._listeners\n    });\n\n    return this;\n  };\n\n  // Tell this object to stop listening to either specific events ... or\n  // to every object it's currently listening to.\n  Events.stopListening = function(obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo) return this;\n\n    var ids = obj ? [obj._listenId] : _.keys(listeningTo);\n    for (var i = 0; i < ids.length; i++) {\n      var listening = listeningTo[ids[i]];\n\n      // If listening doesn't exist, this object is not currently\n      // listening to obj. Break out early.\n      if (!listening) break;\n\n      listening.obj.off(name, callback, this);\n      if (listening.interop) listening.off(name, callback);\n    }\n    if (_.isEmpty(listeningTo)) this._listeningTo = void 0;\n\n    return this;\n  };\n\n  // The reducing API that removes a callback from the `events` object.\n  var offApi = function(events, name, callback, options) {\n    if (!events) return;\n\n    var context = options.context, listeners = options.listeners;\n    var i = 0, names;\n\n    // Delete all event listeners and \"drop\" events.\n    if (!name && !context && !callback) {\n      for (names = _.keys(listeners); i < names.length; i++) {\n        listeners[names[i]].cleanup();\n      }\n      return;\n    }\n\n    names = name ? [name] : _.keys(events);\n    for (; i < names.length; i++) {\n      name = names[i];\n      var handlers = events[name];\n\n      // Bail out if there are no events stored.\n      if (!handlers) break;\n\n      // Find any remaining events.\n      var remaining = [];\n      for (var j = 0; j < handlers.length; j++) {\n        var handler = handlers[j];\n        if (\n          callback && callback !== handler.callback &&\n            callback !== handler.callback._callback ||\n              context && context !== handler.context\n        ) {\n          remaining.push(handler);\n        } else {\n          var listening = handler.listening;\n          if (listening) listening.off(name, callback);\n        }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length) {\n        events[name] = remaining;\n      } else {\n        delete events[name];\n      }\n    }\n\n    return events;\n  };\n\n  // Bind an event to only be triggered a single time. After the first time\n  // the callback is invoked, its listener will be removed. If multiple events\n  // are passed in using the space-separated syntax, the handler will fire\n  // once for each event, not once for a combination of all events.\n  Events.once = function(name, callback, context) {\n    // Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));\n    if (typeof name === 'string' && context == null) callback = void 0;\n    return this.on(events, callback, context);\n  };\n\n  // Inversion-of-control versions of `once`.\n  Events.listenToOnce = function(obj, name, callback) {\n    // Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));\n    return this.listenTo(obj, events);\n  };\n\n  // Reduces the event callbacks into a map of `{event: onceWrapper}`.\n  // `offer` unbinds the `onceWrapper` after it has been called.\n  var onceMap = function(map, name, callback, offer) {\n    if (callback) {\n      var once = map[name] = _.once(function() {\n        offer(name, once);\n        callback.apply(this, arguments);\n      });\n      once._callback = callback;\n    }\n    return map;\n  };\n\n  // Trigger one or many events, firing all bound callbacks. Callbacks are\n  // passed the same arguments as `trigger` is, apart from the event name\n  // (unless you're listening on `\"all\"`, which will cause your callback to\n  // receive the true name of the event as the first argument).\n  Events.trigger = function(name) {\n    if (!this._events) return this;\n\n    var length = Math.max(0, arguments.length - 1);\n    var args = Array(length);\n    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];\n\n    eventsApi(triggerApi, this._events, name, void 0, args);\n    return this;\n  };\n\n  // Handles triggering the appropriate event callbacks.\n  var triggerApi = function(objEvents, name, callback, args) {\n    if (objEvents) {\n      var events = objEvents[name];\n      var allEvents = objEvents.all;\n      if (events && allEvents) allEvents = allEvents.slice();\n      if (events) triggerEvents(events, args);\n      if (allEvents) triggerEvents(allEvents, [name].concat(args));\n    }\n    return objEvents;\n  };\n\n  // A difficult-to-believe, but optimized internal dispatch function for\n  // triggering events. Tries to keep the usual cases speedy (most internal\n  // Backbone events have 3 arguments).\n  var triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\n    }\n  };\n\n  // A listening class that tracks and cleans up memory bindings\n  // when all callbacks have been offed.\n  var Listening = function(listener, obj) {\n    this.id = listener._listenId;\n    this.listener = listener;\n    this.obj = obj;\n    this.interop = true;\n    this.count = 0;\n    this._events = void 0;\n  };\n\n  Listening.prototype.on = Events.on;\n\n  // Offs a callback (or several).\n  // Uses an optimized counter if the listenee uses Backbone.Events.\n  // Otherwise, falls back to manual tracking to support events\n  // library interop.\n  Listening.prototype.off = function(name, callback) {\n    var cleanup;\n    if (this.interop) {\n      this._events = eventsApi(offApi, this._events, name, callback, {\n        context: void 0,\n        listeners: void 0\n      });\n      cleanup = !this._events;\n    } else {\n      this.count--;\n      cleanup = this.count === 0;\n    }\n    if (cleanup) this.cleanup();\n  };\n\n  // Cleans up memory bindings between the listener and the listenee.\n  Listening.prototype.cleanup = function() {\n    delete this.listener._listeningTo[this.obj._listenId];\n    if (!this.interop) delete this.obj._listeners[this.id];\n  };\n\n  // Aliases for backwards compatibility.\n  Events.bind   = Events.on;\n  Events.unbind = Events.off;\n\n  // Allow the `Backbone` object to serve as a global event bus, for folks who\n  // want global \"pubsub\" in a convenient place.\n  _.extend(Backbone, Events);\n\n  // Backbone.Model\n  // --------------\n\n  // Backbone **Models** are the basic data object in the framework --\n  // frequently representing a row in a table in a database on your server.\n  // A discrete chunk of data and a bunch of useful, related methods for\n  // performing computations and transformations on that data.\n\n  // Create a new model with the specified attributes. A client id (`cid`)\n  // is automatically generated and assigned for you.\n  var Model = Backbone.Model = function(attributes, options) {\n    var attrs = attributes || {};\n    options || (options = {});\n    this.preinitialize.apply(this, arguments);\n    this.cid = _.uniqueId(this.cidPrefix);\n    this.attributes = {};\n    if (options.collection) this.collection = options.collection;\n    if (options.parse) attrs = this.parse(attrs, options) || {};\n    var defaults = _.result(this, 'defaults');\n\n    // Just _.defaults would work fine, but the additional _.extends\n    // is in there for historical reasons. See #3843.\n    attrs = _.defaults(_.extend({}, defaults, attrs), defaults);\n\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n  };\n\n  // Attach all inheritable methods to the Model prototype.\n  _.extend(Model.prototype, Events, {\n\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n\n    // The value returned during the last failed validation.\n    validationError: null,\n\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n    // CouchDB users may want to set this to `\"_id\"`.\n    idAttribute: 'id',\n\n    // The prefix is used to create the client id which is used to identify models locally.\n    // You may want to override this if you're experiencing name clashes with model ids.\n    cidPrefix: 'c',\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the Model.\n    preinitialize: function(){},\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Return a copy of the model's `attributes` object.\n    toJSON: function(options) {\n      return _.clone(this.attributes);\n    },\n\n    // Proxy `Backbone.sync` by default -- but override this if you need\n    // custom syncing semantics for *this* particular model.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Get the value of an attribute.\n    get: function(attr) {\n      return this.attributes[attr];\n    },\n\n    // Get the HTML-escaped value of an attribute.\n    escape: function(attr) {\n      return _.escape(this.get(attr));\n    },\n\n    // Returns `true` if the attribute contains a value that is not null\n    // or undefined.\n    has: function(attr) {\n      return this.get(attr) != null;\n    },\n\n    // Special-cased proxy to underscore's `_.matches` method.\n    matches: function(attrs) {\n      return !!_.iteratee(attrs, this)(this.attributes);\n    },\n\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\n    // the core primitive operation of a model, updating the data and notifying\n    // anyone who needs to know about the change in state. The heart of the beast.\n    set: function(key, val, options) {\n      if (key == null) return this;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      var attrs;\n      if (typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options || (options = {});\n\n      // Run validation.\n      if (!this._validate(attrs, options)) return false;\n\n      // Extract attributes and options.\n      var unset      = options.unset;\n      var silent     = options.silent;\n      var changes    = [];\n      var changing   = this._changing;\n      this._changing = true;\n\n      if (!changing) {\n        this._previousAttributes = _.clone(this.attributes);\n        this.changed = {};\n      }\n\n      var current = this.attributes;\n      var changed = this.changed;\n      var prev    = this._previousAttributes;\n\n      // For each `set` attribute, update or delete the current value.\n      for (var attr in attrs) {\n        val = attrs[attr];\n        if (!_.isEqual(current[attr], val)) changes.push(attr);\n        if (!_.isEqual(prev[attr], val)) {\n          changed[attr] = val;\n        } else {\n          delete changed[attr];\n        }\n        unset ? delete current[attr] : current[attr] = val;\n      }\n\n      // Update the `id`.\n      if (this.idAttribute in attrs) {\n        var prevId = this.id;\n        this.id = this.get(this.idAttribute);\n        this.trigger('changeId', this, prevId, options);\n      }\n\n      // Trigger all relevant attribute changes.\n      if (!silent) {\n        if (changes.length) this._pending = options;\n        for (var i = 0; i < changes.length; i++) {\n          this.trigger('change:' + changes[i], this, current[changes[i]], options);\n        }\n      }\n\n      // You might be wondering why there's a `while` loop here. Changes can\n      // be recursively nested within `\"change\"` events.\n      if (changing) return this;\n      if (!silent) {\n        while (this._pending) {\n          options = this._pending;\n          this._pending = false;\n          this.trigger('change', this, options);\n        }\n      }\n      this._pending = false;\n      this._changing = false;\n      return this;\n    },\n\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n    // if the attribute doesn't exist.\n    unset: function(attr, options) {\n      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\n    },\n\n    // Clear all attributes on the model, firing `\"change\"`.\n    clear: function(options) {\n      var attrs = {};\n      for (var key in this.attributes) attrs[key] = void 0;\n      return this.set(attrs, _.extend({}, options, {unset: true}));\n    },\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged: function(attr) {\n      if (attr == null) return !_.isEmpty(this.changed);\n      return _.has(this.changed, attr);\n    },\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes: function(diff) {\n      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\n      var old = this._changing ? this._previousAttributes : this.attributes;\n      var changed = {};\n      var hasChanged;\n      for (var attr in diff) {\n        var val = diff[attr];\n        if (_.isEqual(old[attr], val)) continue;\n        changed[attr] = val;\n        hasChanged = true;\n      }\n      return hasChanged ? changed : false;\n    },\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous: function(attr) {\n      if (attr == null || !this._previousAttributes) return null;\n      return this._previousAttributes[attr];\n    },\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes: function() {\n      return _.clone(this._previousAttributes);\n    },\n\n    // Fetch the model from the server, merging the response with the model's\n    // local attributes. Any changed attributes will trigger a \"change\" event.\n    fetch: function(options) {\n      options = _.extend({parse: true}, options);\n      var model = this;\n      var success = options.success;\n      options.success = function(resp) {\n        var serverAttrs = options.parse ? model.parse(resp, options) : resp;\n        if (!model.set(serverAttrs, options)) return false;\n        if (success) success.call(options.context, model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Set a hash of model attributes, and sync the model to the server.\n    // If the server returns an attributes hash that differs, the model's\n    // state will be `set` again.\n    save: function(key, val, options) {\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      var attrs;\n      if (key == null || typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options = _.extend({validate: true, parse: true}, options);\n      var wait = options.wait;\n\n      // If we're not waiting and attributes exist, save acts as\n      // `set(attr).save(null, opts)` with validation. Otherwise, check if\n      // the model will be valid when the attributes, if any, are set.\n      if (attrs && !wait) {\n        if (!this.set(attrs, options)) return false;\n      } else if (!this._validate(attrs, options)) {\n        return false;\n      }\n\n      // After a successful server-side save, the client is (optionally)\n      // updated with the server-side state.\n      var model = this;\n      var success = options.success;\n      var attributes = this.attributes;\n      options.success = function(resp) {\n        // Ensure attributes are restored during synchronous saves.\n        model.attributes = attributes;\n        var serverAttrs = options.parse ? model.parse(resp, options) : resp;\n        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);\n        if (serverAttrs && !model.set(serverAttrs, options)) return false;\n        if (success) success.call(options.context, model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n\n      // Set temporary attributes if `{wait: true}` to properly find new ids.\n      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);\n\n      var method = this.isNew() ? 'create' : options.patch ? 'patch' : 'update';\n      if (method === 'patch' && !options.attrs) options.attrs = attrs;\n      var xhr = this.sync(method, this, options);\n\n      // Restore attributes.\n      this.attributes = attributes;\n\n      return xhr;\n    },\n\n    // Destroy this model on the server if it was already persisted.\n    // Optimistically removes the model from its collection, if it has one.\n    // If `wait: true` is passed, waits for the server to respond before removal.\n    destroy: function(options) {\n      options = options ? _.clone(options) : {};\n      var model = this;\n      var success = options.success;\n      var wait = options.wait;\n\n      var destroy = function() {\n        model.stopListening();\n        model.trigger('destroy', model, model.collection, options);\n      };\n\n      options.success = function(resp) {\n        if (wait) destroy();\n        if (success) success.call(options.context, model, resp, options);\n        if (!model.isNew()) model.trigger('sync', model, resp, options);\n      };\n\n      var xhr = false;\n      if (this.isNew()) {\n        _.defer(options.success);\n      } else {\n        wrapError(this, options);\n        xhr = this.sync('delete', this, options);\n      }\n      if (!wait) destroy();\n      return xhr;\n    },\n\n    // Default URL for the model's representation on the server -- if you're\n    // using Backbone's restful methods, override this to change the endpoint\n    // that will be called.\n    url: function() {\n      var base =\n        _.result(this, 'urlRoot') ||\n        _.result(this.collection, 'url') ||\n        urlError();\n      if (this.isNew()) return base;\n      var id = this.get(this.idAttribute);\n      return base.replace(/[^\\/]$/, '$&/') + encodeURIComponent(id);\n    },\n\n    // **parse** converts a response into the hash of attributes to be `set` on\n    // the model. The default implementation is just to pass the response along.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new model with identical attributes to this one.\n    clone: function() {\n      return new this.constructor(this.attributes);\n    },\n\n    // A model is new if it has never been saved to the server, and lacks an id.\n    isNew: function() {\n      return !this.has(this.idAttribute);\n    },\n\n    // Check if the model is currently in a valid state.\n    isValid: function(options) {\n      return this._validate({}, _.extend({}, options, {validate: true}));\n    },\n\n    // Run validation against the next complete set of model attributes,\n    // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n    _validate: function(attrs, options) {\n      if (!options.validate || !this.validate) return true;\n      attrs = _.extend({}, this.attributes, attrs);\n      var error = this.validationError = this.validate(attrs, options) || null;\n      if (!error) return true;\n      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));\n      return false;\n    }\n\n  });\n\n  // Backbone.Collection\n  // -------------------\n\n  // If models tend to represent a single row of data, a Backbone Collection is\n  // more analogous to a table full of data ... or a small slice or page of that\n  // table, or a collection of rows that belong together for a particular reason\n  // -- all of the messages in this particular folder, all of the documents\n  // belonging to this particular author, and so on. Collections maintain\n  // indexes of their models, both in order, and for lookup by `id`.\n\n  // Create a new **Collection**, perhaps to contain a specific type of `model`.\n  // If a `comparator` is specified, the Collection will maintain\n  // its models in sort order, as they're added and removed.\n  var Collection = Backbone.Collection = function(models, options) {\n    options || (options = {});\n    this.preinitialize.apply(this, arguments);\n    if (options.model) this.model = options.model;\n    if (options.comparator !== void 0) this.comparator = options.comparator;\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, _.extend({silent: true}, options));\n  };\n\n  // Default options for `Collection#set`.\n  var setOptions = {add: true, remove: true, merge: true};\n  var addOptions = {add: true, remove: false};\n\n  // Splices `insert` into `array` at index `at`.\n  var splice = function(array, insert, at) {\n    at = Math.min(Math.max(at, 0), array.length);\n    var tail = Array(array.length - at);\n    var length = insert.length;\n    var i;\n    for (i = 0; i < tail.length; i++) tail[i] = array[i + at];\n    for (i = 0; i < length; i++) array[i + at] = insert[i];\n    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];\n  };\n\n  // Define the Collection's inheritable methods.\n  _.extend(Collection.prototype, Events, {\n\n    // The default model for a collection is just a **Backbone.Model**.\n    // This should be overridden in most cases.\n    model: Model,\n\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the Collection.\n    preinitialize: function(){},\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // The JSON representation of a Collection is an array of the\n    // models' attributes.\n    toJSON: function(options) {\n      return this.map(function(model) { return model.toJSON(options); });\n    },\n\n    // Proxy `Backbone.sync` by default.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Add a model, or list of models to the set. `models` may be Backbone\n    // Models or raw JavaScript objects to be converted to Models, or any\n    // combination of the two.\n    add: function(models, options) {\n      return this.set(models, _.extend({merge: false}, options, addOptions));\n    },\n\n    // Remove a model, or a list of models from the set.\n    remove: function(models, options) {\n      options = _.extend({}, options);\n      var singular = !_.isArray(models);\n      models = singular ? [models] : models.slice();\n      var removed = this._removeModels(models, options);\n      if (!options.silent && removed.length) {\n        options.changes = {added: [], merged: [], removed: removed};\n        this.trigger('update', this, options);\n      }\n      return singular ? removed[0] : removed;\n    },\n\n    // Update a collection by `set`-ing a new list of models, adding new ones,\n    // removing models that are no longer present, and merging models that\n    // already exist in the collection, as necessary. Similar to **Model#set**,\n    // the core operation for updating the data contained by the collection.\n    set: function(models, options) {\n      if (models == null) return;\n\n      options = _.extend({}, setOptions, options);\n      if (options.parse && !this._isModel(models)) {\n        models = this.parse(models, options) || [];\n      }\n\n      var singular = !_.isArray(models);\n      models = singular ? [models] : models.slice();\n\n      var at = options.at;\n      if (at != null) at = +at;\n      if (at > this.length) at = this.length;\n      if (at < 0) at += this.length + 1;\n\n      var set = [];\n      var toAdd = [];\n      var toMerge = [];\n      var toRemove = [];\n      var modelMap = {};\n\n      var add = options.add;\n      var merge = options.merge;\n      var remove = options.remove;\n\n      var sort = false;\n      var sortable = this.comparator && at == null && options.sort !== false;\n      var sortAttr = _.isString(this.comparator) ? this.comparator : null;\n\n      // Turn bare objects into model references, and prevent invalid models\n      // from being added.\n      var model, i;\n      for (i = 0; i < models.length; i++) {\n        model = models[i];\n\n        // If a duplicate is found, prevent it from being added and\n        // optionally merge it into the existing model.\n        var existing = this.get(model);\n        if (existing) {\n          if (merge && model !== existing) {\n            var attrs = this._isModel(model) ? model.attributes : model;\n            if (options.parse) attrs = existing.parse(attrs, options);\n            existing.set(attrs, options);\n            toMerge.push(existing);\n            if (sortable && !sort) sort = existing.hasChanged(sortAttr);\n          }\n          if (!modelMap[existing.cid]) {\n            modelMap[existing.cid] = true;\n            set.push(existing);\n          }\n          models[i] = existing;\n\n        // If this is a new, valid model, push it to the `toAdd` list.\n        } else if (add) {\n          model = models[i] = this._prepareModel(model, options);\n          if (model) {\n            toAdd.push(model);\n            this._addReference(model, options);\n            modelMap[model.cid] = true;\n            set.push(model);\n          }\n        }\n      }\n\n      // Remove stale models.\n      if (remove) {\n        for (i = 0; i < this.length; i++) {\n          model = this.models[i];\n          if (!modelMap[model.cid]) toRemove.push(model);\n        }\n        if (toRemove.length) this._removeModels(toRemove, options);\n      }\n\n      // See if sorting is needed, update `length` and splice in new models.\n      var orderChanged = false;\n      var replace = !sortable && add && remove;\n      if (set.length && replace) {\n        orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {\n          return m !== set[index];\n        });\n        this.models.length = 0;\n        splice(this.models, set, 0);\n        this.length = this.models.length;\n      } else if (toAdd.length) {\n        if (sortable) sort = true;\n        splice(this.models, toAdd, at == null ? this.length : at);\n        this.length = this.models.length;\n      }\n\n      // Silently sort the collection if appropriate.\n      if (sort) this.sort({silent: true});\n\n      // Unless silenced, it's time to fire all appropriate add/sort/update events.\n      if (!options.silent) {\n        for (i = 0; i < toAdd.length; i++) {\n          if (at != null) options.index = at + i;\n          model = toAdd[i];\n          model.trigger('add', model, this, options);\n        }\n        if (sort || orderChanged) this.trigger('sort', this, options);\n        if (toAdd.length || toRemove.length || toMerge.length) {\n          options.changes = {\n            added: toAdd,\n            removed: toRemove,\n            merged: toMerge\n          };\n          this.trigger('update', this, options);\n        }\n      }\n\n      // Return the added (or merged) model (or models).\n      return singular ? models[0] : models;\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any granular `add` or `remove` events. Fires `reset` when finished.\n    // Useful for bulk operations and optimizations.\n    reset: function(models, options) {\n      options = options ? _.clone(options) : {};\n      for (var i = 0; i < this.models.length; i++) {\n        this._removeReference(this.models[i], options);\n      }\n      options.previousModels = this.models;\n      this._reset();\n      models = this.add(models, _.extend({silent: true}, options));\n      if (!options.silent) this.trigger('reset', this, options);\n      return models;\n    },\n\n    // Add a model to the end of the collection.\n    push: function(model, options) {\n      return this.add(model, _.extend({at: this.length}, options));\n    },\n\n    // Remove a model from the end of the collection.\n    pop: function(options) {\n      var model = this.at(this.length - 1);\n      return this.remove(model, options);\n    },\n\n    // Add a model to the beginning of the collection.\n    unshift: function(model, options) {\n      return this.add(model, _.extend({at: 0}, options));\n    },\n\n    // Remove a model from the beginning of the collection.\n    shift: function(options) {\n      var model = this.at(0);\n      return this.remove(model, options);\n    },\n\n    // Slice out a sub-array of models from the collection.\n    slice: function() {\n      return slice.apply(this.models, arguments);\n    },\n\n    // Get a model from the set by id, cid, model object with id or cid\n    // properties, or an attributes object that is transformed through modelId.\n    get: function(obj) {\n      if (obj == null) return void 0;\n      return this._byId[obj] ||\n        this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj, obj.idAttribute)] ||\n        obj.cid && this._byId[obj.cid];\n    },\n\n    // Returns `true` if the model is in the collection.\n    has: function(obj) {\n      return this.get(obj) != null;\n    },\n\n    // Get the model at the given index.\n    at: function(index) {\n      if (index < 0) index += this.length;\n      return this.models[index];\n    },\n\n    // Return models with matching attributes. Useful for simple cases of\n    // `filter`.\n    where: function(attrs, first) {\n      return this[first ? 'find' : 'filter'](attrs);\n    },\n\n    // Return the first model with matching attributes. Useful for simple cases\n    // of `find`.\n    findWhere: function(attrs) {\n      return this.where(attrs, true);\n    },\n\n    // Force the collection to re-sort itself. You don't need to call this under\n    // normal circumstances, as the set will maintain sort order as each item\n    // is added.\n    sort: function(options) {\n      var comparator = this.comparator;\n      if (!comparator) throw new Error('Cannot sort a set without a comparator');\n      options || (options = {});\n\n      var length = comparator.length;\n      if (_.isFunction(comparator)) comparator = comparator.bind(this);\n\n      // Run sort based on type of `comparator`.\n      if (length === 1 || _.isString(comparator)) {\n        this.models = this.sortBy(comparator);\n      } else {\n        this.models.sort(comparator);\n      }\n      if (!options.silent) this.trigger('sort', this, options);\n      return this;\n    },\n\n    // Pluck an attribute from each model in the collection.\n    pluck: function(attr) {\n      return this.map(attr + '');\n    },\n\n    // Fetch the default set of models for this collection, resetting the\n    // collection when they arrive. If `reset: true` is passed, the response\n    // data will be passed through the `reset` method instead of `set`.\n    fetch: function(options) {\n      options = _.extend({parse: true}, options);\n      var success = options.success;\n      var collection = this;\n      options.success = function(resp) {\n        var method = options.reset ? 'reset' : 'set';\n        collection[method](resp, options);\n        if (success) success.call(options.context, collection, resp, options);\n        collection.trigger('sync', collection, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Create a new instance of a model in this collection. Add the model to the\n    // collection immediately, unless `wait: true` is passed, in which case we\n    // wait for the server to agree.\n    create: function(model, options) {\n      options = options ? _.clone(options) : {};\n      var wait = options.wait;\n      model = this._prepareModel(model, options);\n      if (!model) return false;\n      if (!wait) this.add(model, options);\n      var collection = this;\n      var success = options.success;\n      options.success = function(m, resp, callbackOpts) {\n        if (wait) {\n          m.off('error', this._forwardPristineError, this);\n          collection.add(m, callbackOpts);\n        }\n        if (success) success.call(callbackOpts.context, m, resp, callbackOpts);\n      };\n      // In case of wait:true, our collection is not listening to any\n      // of the model's events yet, so it will not forward the error\n      // event. In this special case, we need to listen for it\n      // separately and handle the event just once.\n      // (The reason we don't need to do this for the sync event is\n      // in the success handler above: we add the model first, which\n      // causes the collection to listen, and then invoke the callback\n      // that triggers the event.)\n      if (wait) {\n        model.once('error', this._forwardPristineError, this);\n      }\n      model.save(null, options);\n      return model;\n    },\n\n    // **parse** converts a response into a list of models to be added to the\n    // collection. The default implementation is just to pass it through.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new collection with an identical list of models as this one.\n    clone: function() {\n      return new this.constructor(this.models, {\n        model: this.model,\n        comparator: this.comparator\n      });\n    },\n\n    // Define how to uniquely identify models in the collection.\n    modelId: function(attrs, idAttribute) {\n      return attrs[idAttribute || this.model.prototype.idAttribute || 'id'];\n    },\n\n    // Get an iterator of all models in this collection.\n    values: function() {\n      return new CollectionIterator(this, ITERATOR_VALUES);\n    },\n\n    // Get an iterator of all model IDs in this collection.\n    keys: function() {\n      return new CollectionIterator(this, ITERATOR_KEYS);\n    },\n\n    // Get an iterator of all [ID, model] tuples in this collection.\n    entries: function() {\n      return new CollectionIterator(this, ITERATOR_KEYSVALUES);\n    },\n\n    // Private method to reset all internal state. Called when the collection\n    // is first initialized or reset.\n    _reset: function() {\n      this.length = 0;\n      this.models = [];\n      this._byId  = {};\n    },\n\n    // Prepare a hash of attributes (or other model) to be added to this\n    // collection.\n    _prepareModel: function(attrs, options) {\n      if (this._isModel(attrs)) {\n        if (!attrs.collection) attrs.collection = this;\n        return attrs;\n      }\n      options = options ? _.clone(options) : {};\n      options.collection = this;\n\n      var model;\n      if (this.model.prototype) {\n        model = new this.model(attrs, options);\n      } else {\n        // ES class methods didn't have prototype\n        model = this.model(attrs, options);\n      }\n\n      if (!model.validationError) return model;\n      this.trigger('invalid', this, model.validationError, options);\n      return false;\n    },\n\n    // Internal method called by both remove and set.\n    _removeModels: function(models, options) {\n      var removed = [];\n      for (var i = 0; i < models.length; i++) {\n        var model = this.get(models[i]);\n        if (!model) continue;\n\n        var index = this.indexOf(model);\n        this.models.splice(index, 1);\n        this.length--;\n\n        // Remove references before triggering 'remove' event to prevent an\n        // infinite loop. #3693\n        delete this._byId[model.cid];\n        var id = this.modelId(model.attributes, model.idAttribute);\n        if (id != null) delete this._byId[id];\n\n        if (!options.silent) {\n          options.index = index;\n          model.trigger('remove', model, this, options);\n        }\n\n        removed.push(model);\n        this._removeReference(model, options);\n      }\n      if (models.length > 0 && !options.silent) delete options.index;\n      return removed;\n    },\n\n    // Method for checking whether an object should be considered a model for\n    // the purposes of adding to the collection.\n    _isModel: function(model) {\n      return model instanceof Model;\n    },\n\n    // Internal method to create a model's ties to a collection.\n    _addReference: function(model, options) {\n      this._byId[model.cid] = model;\n      var id = this.modelId(model.attributes, model.idAttribute);\n      if (id != null) this._byId[id] = model;\n      model.on('all', this._onModelEvent, this);\n    },\n\n    // Internal method to sever a model's ties to a collection.\n    _removeReference: function(model, options) {\n      delete this._byId[model.cid];\n      var id = this.modelId(model.attributes, model.idAttribute);\n      if (id != null) delete this._byId[id];\n      if (this === model.collection) delete model.collection;\n      model.off('all', this._onModelEvent, this);\n    },\n\n    // Internal method called every time a model in the set fires an event.\n    // Sets need to update their indexes when models change ids. All other\n    // events simply proxy through. \"add\" and \"remove\" events that originate\n    // in other collections are ignored.\n    _onModelEvent: function(event, model, collection, options) {\n      if (model) {\n        if ((event === 'add' || event === 'remove') && collection !== this) return;\n        if (event === 'destroy') this.remove(model, options);\n        if (event === 'changeId') {\n          var prevId = this.modelId(model.previousAttributes(), model.idAttribute);\n          var id = this.modelId(model.attributes, model.idAttribute);\n          if (prevId != null) delete this._byId[prevId];\n          if (id != null) this._byId[id] = model;\n        }\n      }\n      this.trigger.apply(this, arguments);\n    },\n\n    // Internal callback method used in `create`. It serves as a\n    // stand-in for the `_onModelEvent` method, which is not yet bound\n    // during the `wait` period of the `create` call. We still want to\n    // forward any `'error'` event at the end of the `wait` period,\n    // hence a customized callback.\n    _forwardPristineError: function(model, collection, options) {\n      // Prevent double forward if the model was already in the\n      // collection before the call to `create`.\n      if (this.has(model)) return;\n      this._onModelEvent('error', model, collection, options);\n    }\n  });\n\n  // Defining an @@iterator method implements JavaScript's Iterable protocol.\n  // In modern ES2015 browsers, this value is found at Symbol.iterator.\n  /* global Symbol */\n  var $$iterator = typeof Symbol === 'function' && Symbol.iterator;\n  if ($$iterator) {\n    Collection.prototype[$$iterator] = Collection.prototype.values;\n  }\n\n  // CollectionIterator\n  // ------------------\n\n  // A CollectionIterator implements JavaScript's Iterator protocol, allowing the\n  // use of `for of` loops in modern browsers and interoperation between\n  // Backbone.Collection and other JavaScript functions and third-party libraries\n  // which can operate on Iterables.\n  var CollectionIterator = function(collection, kind) {\n    this._collection = collection;\n    this._kind = kind;\n    this._index = 0;\n  };\n\n  // This \"enum\" defines the three possible kinds of values which can be emitted\n  // by a CollectionIterator that correspond to the values(), keys() and entries()\n  // methods on Collection, respectively.\n  var ITERATOR_VALUES = 1;\n  var ITERATOR_KEYS = 2;\n  var ITERATOR_KEYSVALUES = 3;\n\n  // All Iterators should themselves be Iterable.\n  if ($$iterator) {\n    CollectionIterator.prototype[$$iterator] = function() {\n      return this;\n    };\n  }\n\n  CollectionIterator.prototype.next = function() {\n    if (this._collection) {\n\n      // Only continue iterating if the iterated collection is long enough.\n      if (this._index < this._collection.length) {\n        var model = this._collection.at(this._index);\n        this._index++;\n\n        // Construct a value depending on what kind of values should be iterated.\n        var value;\n        if (this._kind === ITERATOR_VALUES) {\n          value = model;\n        } else {\n          var id = this._collection.modelId(model.attributes, model.idAttribute);\n          if (this._kind === ITERATOR_KEYS) {\n            value = id;\n          } else { // ITERATOR_KEYSVALUES\n            value = [id, model];\n          }\n        }\n        return {value: value, done: false};\n      }\n\n      // Once exhausted, remove the reference to the collection so future\n      // calls to the next method always return done.\n      this._collection = void 0;\n    }\n\n    return {value: void 0, done: true};\n  };\n\n  // Backbone.View\n  // -------------\n\n  // Backbone Views are almost more convention than they are actual code. A View\n  // is simply a JavaScript object that represents a logical chunk of UI in the\n  // DOM. This might be a single item, an entire list, a sidebar or panel, or\n  // even the surrounding frame which wraps your whole app. Defining a chunk of\n  // UI as a **View** allows you to define your DOM events declaratively, without\n  // having to worry about render order ... and makes it easy for the view to\n  // react to specific changes in the state of your models.\n\n  // Creating a Backbone.View creates its initial element outside of the DOM,\n  // if an existing element is not provided...\n  var View = Backbone.View = function(options) {\n    this.cid = _.uniqueId('view');\n    this.preinitialize.apply(this, arguments);\n    _.extend(this, _.pick(options, viewOptions));\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regex to split keys for `delegate`.\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n  // List of view options to be set as properties.\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\n\n  // Set up all inheritable **Backbone.View** properties and methods.\n  _.extend(View.prototype, Events, {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    // jQuery delegate for element lookup, scoped to DOM elements within the\n    // current view. This should be preferred to global lookups where possible.\n    $: function(selector) {\n      return this.$el.find(selector);\n    },\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the View\n    preinitialize: function(){},\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function() {\n      return this;\n    },\n\n    // Remove this view by taking the element out of the DOM, and removing any\n    // applicable Backbone.Events listeners.\n    remove: function() {\n      this._removeElement();\n      this.stopListening();\n      return this;\n    },\n\n    // Remove this view's element from the document and all event listeners\n    // attached to it. Exposed for subclasses using an alternative DOM\n    // manipulation API.\n    _removeElement: function() {\n      this.$el.remove();\n    },\n\n    // Change the view's element (`this.el` property) and re-delegate the\n    // view's events on the new element.\n    setElement: function(element) {\n      this.undelegateEvents();\n      this._setElement(element);\n      this.delegateEvents();\n      return this;\n    },\n\n    // Creates the `this.el` and `this.$el` references for this view using the\n    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery\n    // context or an element. Subclasses can override this to utilize an\n    // alternative DOM manipulation API and are only required to set the\n    // `this.el` property.\n    _setElement: function(el) {\n      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);\n      this.el = this.$el[0];\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save',\n    //       'click .open':       function(e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    delegateEvents: function(events) {\n      events || (events = _.result(this, 'events'));\n      if (!events) return this;\n      this.undelegateEvents();\n      for (var key in events) {\n        var method = events[key];\n        if (!_.isFunction(method)) method = this[method];\n        if (!method) continue;\n        var match = key.match(delegateEventSplitter);\n        this.delegate(match[1], match[2], method.bind(this));\n      }\n      return this;\n    },\n\n    // Add a single event listener to the view's element (or a child element\n    // using `selector`). This only works for delegate-able events: not `focus`,\n    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.\n    delegate: function(eventName, selector, listener) {\n      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);\n      return this;\n    },\n\n    // Clears all callbacks previously bound to the view by `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // Backbone views attached to the same DOM element.\n    undelegateEvents: function() {\n      if (this.$el) this.$el.off('.delegateEvents' + this.cid);\n      return this;\n    },\n\n    // A finer-grained `undelegateEvents` for removing a single delegated event.\n    // `selector` and `listener` are both optional.\n    undelegate: function(eventName, selector, listener) {\n      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);\n      return this;\n    },\n\n    // Produces a DOM element to be assigned to your view. Exposed for\n    // subclasses using an alternative DOM manipulation API.\n    _createElement: function(tagName) {\n      return document.createElement(tagName);\n    },\n\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function() {\n      if (!this.el) {\n        var attrs = _.extend({}, _.result(this, 'attributes'));\n        if (this.id) attrs.id = _.result(this, 'id');\n        if (this.className) attrs['class'] = _.result(this, 'className');\n        this.setElement(this._createElement(_.result(this, 'tagName')));\n        this._setAttributes(attrs);\n      } else {\n        this.setElement(_.result(this, 'el'));\n      }\n    },\n\n    // Set attributes from a hash on this view's element.  Exposed for\n    // subclasses using an alternative DOM manipulation API.\n    _setAttributes: function(attributes) {\n      this.$el.attr(attributes);\n    }\n\n  });\n\n  // Proxy Backbone class methods to Underscore functions, wrapping the model's\n  // `attributes` object or collection's `models` array behind the scenes.\n  //\n  // collection.filter(function(model) { return model.get('age') > 10 });\n  // collection.each(this.addView);\n  //\n  // `Function#apply` can be slow so we use the method's arg count, if we know it.\n  var addMethod = function(base, length, method, attribute) {\n    switch (length) {\n      case 1: return function() {\n        return base[method](this[attribute]);\n      };\n      case 2: return function(value) {\n        return base[method](this[attribute], value);\n      };\n      case 3: return function(iteratee, context) {\n        return base[method](this[attribute], cb(iteratee, this), context);\n      };\n      case 4: return function(iteratee, defaultVal, context) {\n        return base[method](this[attribute], cb(iteratee, this), defaultVal, context);\n      };\n      default: return function() {\n        var args = slice.call(arguments);\n        args.unshift(this[attribute]);\n        return base[method].apply(base, args);\n      };\n    }\n  };\n\n  var addUnderscoreMethods = function(Class, base, methods, attribute) {\n    _.each(methods, function(length, method) {\n      if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute);\n    });\n  };\n\n  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.\n  var cb = function(iteratee, instance) {\n    if (_.isFunction(iteratee)) return iteratee;\n    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);\n    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };\n    return iteratee;\n  };\n  var modelMatcher = function(attrs) {\n    var matcher = _.matches(attrs);\n    return function(model) {\n      return matcher(model.attributes);\n    };\n  };\n\n  // Underscore methods that we want to implement on the Collection.\n  // 90% of the core usefulness of Backbone Collections is actually implemented\n  // right here:\n  var collectionMethods = {forEach: 3, each: 3, map: 3, collect: 3, reduce: 0,\n    foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3,\n    select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,\n    contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,\n    head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,\n    without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,\n    isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,\n    sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3};\n\n\n  // Underscore methods that we want to implement on the Model, mapped to the\n  // number of arguments they take.\n  var modelMethods = {keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,\n    omit: 0, chain: 1, isEmpty: 1};\n\n  // Mix in each Underscore method as a proxy to `Collection#models`.\n\n  _.each([\n    [Collection, collectionMethods, 'models'],\n    [Model, modelMethods, 'attributes']\n  ], function(config) {\n    var Base = config[0],\n        methods = config[1],\n        attribute = config[2];\n\n    Base.mixin = function(obj) {\n      var mappings = _.reduce(_.functions(obj), function(memo, name) {\n        memo[name] = 0;\n        return memo;\n      }, {});\n      addUnderscoreMethods(Base, obj, mappings, attribute);\n    };\n\n    addUnderscoreMethods(Base, _, methods, attribute);\n  });\n\n  // Backbone.sync\n  // -------------\n\n  // Override this function to change the manner in which Backbone persists\n  // models to the server. You will be passed the type of request, and the\n  // model in question. By default, makes a RESTful Ajax request\n  // to the model's `url()`. Some possible customizations could be:\n  //\n  // * Use `setTimeout` to batch rapid-fire updates into a single request.\n  // * Send up the models as XML instead of JSON.\n  // * Persist models via WebSockets instead of Ajax.\n  //\n  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n  // as `POST`, with a `_method` parameter containing the true HTTP method,\n  // as well as all requests with the body as `application/x-www-form-urlencoded`\n  // instead of `application/json` with the model in a param named `model`.\n  // Useful when interfacing with server-side languages like **PHP** that make\n  // it difficult to read the body of `PUT` requests.\n  Backbone.sync = function(method, model, options) {\n    var type = methodMap[method];\n\n    // Default options, unless specified.\n    _.defaults(options || (options = {}), {\n      emulateHTTP: Backbone.emulateHTTP,\n      emulateJSON: Backbone.emulateJSON\n    });\n\n    // Default JSON-request options.\n    var params = {type: type, dataType: 'json'};\n\n    // Ensure that we have a URL.\n    if (!options.url) {\n      params.url = _.result(model, 'url') || urlError();\n    }\n\n    // Ensure that we have the appropriate request data.\n    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\n      params.contentType = 'application/json';\n      params.data = JSON.stringify(options.attrs || model.toJSON(options));\n    }\n\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\n    if (options.emulateJSON) {\n      params.contentType = 'application/x-www-form-urlencoded';\n      params.data = params.data ? {model: params.data} : {};\n    }\n\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n    // And an `X-HTTP-Method-Override` header.\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\n      params.type = 'POST';\n      if (options.emulateJSON) params.data._method = type;\n      var beforeSend = options.beforeSend;\n      options.beforeSend = function(xhr) {\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\n        if (beforeSend) return beforeSend.apply(this, arguments);\n      };\n    }\n\n    // Don't process data on a non-GET request.\n    if (params.type !== 'GET' && !options.emulateJSON) {\n      params.processData = false;\n    }\n\n    // Pass along `textStatus` and `errorThrown` from jQuery.\n    var error = options.error;\n    options.error = function(xhr, textStatus, errorThrown) {\n      options.textStatus = textStatus;\n      options.errorThrown = errorThrown;\n      if (error) error.call(options.context, xhr, textStatus, errorThrown);\n    };\n\n    // Make the request, allowing the user to override any Ajax options.\n    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\n    model.trigger('request', model, xhr, options);\n    return xhr;\n  };\n\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n  var methodMap = {\n    'create': 'POST',\n    'update': 'PUT',\n    'patch': 'PATCH',\n    'delete': 'DELETE',\n    'read': 'GET'\n  };\n\n  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n  // Override this if you'd like to use a different library.\n  Backbone.ajax = function() {\n    return Backbone.$.ajax.apply(Backbone.$, arguments);\n  };\n\n  // Backbone.Router\n  // ---------------\n\n  // Routers map faux-URLs to actions, and fire events when routes are\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\n  var Router = Backbone.Router = function(options) {\n    options || (options = {});\n    this.preinitialize.apply(this, arguments);\n    if (options.routes) this.routes = options.routes;\n    this._bindRoutes();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regular expressions for matching named param parts and splatted\n  // parts of route strings.\n  var optionalParam = /\\((.*?)\\)/g;\n  var namedParam    = /(\\(\\?)?:\\w+/g;\n  var splatParam    = /\\*\\w+/g;\n  var escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n  // Set up all inheritable **Backbone.Router** properties and methods.\n  _.extend(Router.prototype, Events, {\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the Router.\n    preinitialize: function(){},\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Manually bind a single named route to a callback. For example:\n    //\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\n    //       ...\n    //     });\n    //\n    route: function(route, name, callback) {\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\n      if (_.isFunction(name)) {\n        callback = name;\n        name = '';\n      }\n      if (!callback) callback = this[name];\n      var router = this;\n      Backbone.history.route(route, function(fragment) {\n        var args = router._extractParameters(route, fragment);\n        if (router.execute(callback, args, name) !== false) {\n          router.trigger.apply(router, ['route:' + name].concat(args));\n          router.trigger('route', name, args);\n          Backbone.history.trigger('route', router, name, args);\n        }\n      });\n      return this;\n    },\n\n    // Execute a route handler with the provided parameters.  This is an\n    // excellent place to do pre-route setup or post-route cleanup.\n    execute: function(callback, args, name) {\n      if (callback) callback.apply(this, args);\n    },\n\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\n    navigate: function(fragment, options) {\n      Backbone.history.navigate(fragment, options);\n      return this;\n    },\n\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\n    // order of the routes here to support behavior where the most general\n    // routes can be defined at the bottom of the route map.\n    _bindRoutes: function() {\n      if (!this.routes) return;\n      this.routes = _.result(this, 'routes');\n      var route, routes = _.keys(this.routes);\n      while ((route = routes.pop()) != null) {\n        this.route(route, this.routes[route]);\n      }\n    },\n\n    // Convert a route string into a regular expression, suitable for matching\n    // against the current location hash.\n    _routeToRegExp: function(route) {\n      route = route.replace(escapeRegExp, '\\\\$&')\n      .replace(optionalParam, '(?:$1)?')\n      .replace(namedParam, function(match, optional) {\n        return optional ? match : '([^/?]+)';\n      })\n      .replace(splatParam, '([^?]*?)');\n      return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\n    },\n\n    // Given a route, and a URL fragment that it matches, return the array of\n    // extracted decoded parameters. Empty or unmatched parameters will be\n    // treated as `null` to normalize cross-browser behavior.\n    _extractParameters: function(route, fragment) {\n      var params = route.exec(fragment).slice(1);\n      return _.map(params, function(param, i) {\n        // Don't decode the search params.\n        if (i === params.length - 1) return param || null;\n        return param ? decodeURIComponent(param) : null;\n      });\n    }\n\n  });\n\n  // Backbone.History\n  // ----------------\n\n  // Handles cross-browser history management, based on either\n  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n  // and URL fragments. If the browser supports neither (old IE, natch),\n  // falls back to polling.\n  var History = Backbone.History = function() {\n    this.handlers = [];\n    this.checkUrl = this.checkUrl.bind(this);\n\n    // Ensure that `History` can be used outside of the browser.\n    if (typeof window !== 'undefined') {\n      this.location = window.location;\n      this.history = window.history;\n    }\n  };\n\n  // Cached regex for stripping a leading hash/slash and trailing space.\n  var routeStripper = /^[#\\/]|\\s+$/g;\n\n  // Cached regex for stripping leading and trailing slashes.\n  var rootStripper = /^\\/+|\\/+$/g;\n\n  // Cached regex for stripping urls of hash.\n  var pathStripper = /#.*$/;\n\n  // Has the history handling already been started?\n  History.started = false;\n\n  // Set up all inheritable **Backbone.History** properties and methods.\n  _.extend(History.prototype, Events, {\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    interval: 50,\n\n    // Are we at the app root?\n    atRoot: function() {\n      var path = this.location.pathname.replace(/[^\\/]$/, '$&/');\n      return path === this.root && !this.getSearch();\n    },\n\n    // Does the pathname match the root?\n    matchRoot: function() {\n      var path = this.decodeFragment(this.location.pathname);\n      var rootPath = path.slice(0, this.root.length - 1) + '/';\n      return rootPath === this.root;\n    },\n\n    // Unicode characters in `location.pathname` are percent encoded so they're\n    // decoded for comparison. `%25` should not be decoded since it may be part\n    // of an encoded parameter.\n    decodeFragment: function(fragment) {\n      return decodeURI(fragment.replace(/%25/g, '%2525'));\n    },\n\n    // In IE6, the hash fragment and search params are incorrect if the\n    // fragment contains `?`.\n    getSearch: function() {\n      var match = this.location.href.replace(/#.*/, '').match(/\\?.+/);\n      return match ? match[0] : '';\n    },\n\n    // Gets the true hash value. Cannot use location.hash directly due to bug\n    // in Firefox where location.hash will always be decoded.\n    getHash: function(window) {\n      var match = (window || this).location.href.match(/#(.*)$/);\n      return match ? match[1] : '';\n    },\n\n    // Get the pathname and search params, without the root.\n    getPath: function() {\n      var path = this.decodeFragment(\n        this.location.pathname + this.getSearch()\n      ).slice(this.root.length - 1);\n      return path.charAt(0) === '/' ? path.slice(1) : path;\n    },\n\n    // Get the cross-browser normalized URL fragment from the path or hash.\n    getFragment: function(fragment) {\n      if (fragment == null) {\n        if (this._usePushState || !this._wantsHashChange) {\n          fragment = this.getPath();\n        } else {\n          fragment = this.getHash();\n        }\n      }\n      return fragment.replace(routeStripper, '');\n    },\n\n    // Start the hash change handling, returning `true` if the current URL matches\n    // an existing route, and `false` otherwise.\n    start: function(options) {\n      if (History.started) throw new Error('Backbone.history has already been started');\n      History.started = true;\n\n      // Figure out the initial configuration. Do we need an iframe?\n      // Is pushState desired ... is it available?\n      this.options          = _.extend({root: '/'}, this.options, options);\n      this.root             = this.options.root;\n      this._trailingSlash   = this.options.trailingSlash;\n      this._wantsHashChange = this.options.hashChange !== false;\n      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);\n      this._useHashChange   = this._wantsHashChange && this._hasHashChange;\n      this._wantsPushState  = !!this.options.pushState;\n      this._hasPushState    = !!(this.history && this.history.pushState);\n      this._usePushState    = this._wantsPushState && this._hasPushState;\n      this.fragment         = this.getFragment();\n\n      // Normalize root to always include a leading and trailing slash.\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n\n      // Transition from hashChange to pushState or vice versa if both are\n      // requested.\n      if (this._wantsHashChange && this._wantsPushState) {\n\n        // If we've started off with a route from a `pushState`-enabled\n        // browser, but we're currently in a browser that doesn't support it...\n        if (!this._hasPushState && !this.atRoot()) {\n          var rootPath = this.root.slice(0, -1) || '/';\n          this.location.replace(rootPath + '#' + this.getPath());\n          // Return immediately as browser will do redirect to new url\n          return true;\n\n        // Or if we've started out with a hash-based route, but we're currently\n        // in a browser where it could be `pushState`-based instead...\n        } else if (this._hasPushState && this.atRoot()) {\n          this.navigate(this.getHash(), {replace: true});\n        }\n\n      }\n\n      // Proxy an iframe to handle location events if the browser doesn't\n      // support the `hashchange` event, HTML5 history, or the user wants\n      // `hashChange` but not `pushState`.\n      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {\n        this.iframe = document.createElement('iframe');\n        this.iframe.src = 'javascript:0';\n        this.iframe.style.display = 'none';\n        this.iframe.tabIndex = -1;\n        var body = document.body;\n        // Using `appendChild` will throw on IE < 9 if the document is not ready.\n        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;\n        iWindow.document.open();\n        iWindow.document.close();\n        iWindow.location.hash = '#' + this.fragment;\n      }\n\n      // Add a cross-platform `addEventListener` shim for older browsers.\n      var addEventListener = window.addEventListener || function(eventName, listener) {\n        return attachEvent('on' + eventName, listener);\n      };\n\n      // Depending on whether we're using pushState or hashes, and whether\n      // 'onhashchange' is supported, determine how we check the URL state.\n      if (this._usePushState) {\n        addEventListener('popstate', this.checkUrl, false);\n      } else if (this._useHashChange && !this.iframe) {\n        addEventListener('hashchange', this.checkUrl, false);\n      } else if (this._wantsHashChange) {\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n      }\n\n      if (!this.options.silent) return this.loadUrl();\n    },\n\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n    // but possibly useful for unit testing Routers.\n    stop: function() {\n      // Add a cross-platform `removeEventListener` shim for older browsers.\n      var removeEventListener = window.removeEventListener || function(eventName, listener) {\n        return detachEvent('on' + eventName, listener);\n      };\n\n      // Remove window listeners.\n      if (this._usePushState) {\n        removeEventListener('popstate', this.checkUrl, false);\n      } else if (this._useHashChange && !this.iframe) {\n        removeEventListener('hashchange', this.checkUrl, false);\n      }\n\n      // Clean up the iframe if necessary.\n      if (this.iframe) {\n        document.body.removeChild(this.iframe);\n        this.iframe = null;\n      }\n\n      // Some environments will throw when clearing an undefined interval.\n      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\n      History.started = false;\n    },\n\n    // Add a route to be tested when the fragment changes. Routes added later\n    // may override previous routes.\n    route: function(route, callback) {\n      this.handlers.unshift({route: route, callback: callback});\n    },\n\n    // Checks the current URL to see if it has changed, and if it has,\n    // calls `loadUrl`, normalizing across the hidden iframe.\n    checkUrl: function(e) {\n      var current = this.getFragment();\n\n      // If the user pressed the back button, the iframe's hash will have\n      // changed and we should use that for comparison.\n      if (current === this.fragment && this.iframe) {\n        current = this.getHash(this.iframe.contentWindow);\n      }\n\n      if (current === this.fragment) return false;\n      if (this.iframe) this.navigate(current);\n      this.loadUrl();\n    },\n\n    // Attempt to load the current URL fragment. If a route succeeds with a\n    // match, returns `true`. If no defined routes matches the fragment,\n    // returns `false`.\n    loadUrl: function(fragment) {\n      // If the root doesn't match, no routes can match either.\n      if (!this.matchRoot()) return false;\n      fragment = this.fragment = this.getFragment(fragment);\n      return _.some(this.handlers, function(handler) {\n        if (handler.route.test(fragment)) {\n          handler.callback(fragment);\n          return true;\n        }\n      });\n    },\n\n    // Save a fragment into the hash history, or replace the URL state if the\n    // 'replace' option is passed. You are responsible for properly URL-encoding\n    // the fragment in advance.\n    //\n    // The options object can contain `trigger: true` if you wish to have the\n    // route callback be fired (not usually desirable), or `replace: true`, if\n    // you wish to modify the current URL without adding an entry to the history.\n    navigate: function(fragment, options) {\n      if (!History.started) return false;\n      if (!options || options === true) options = {trigger: !!options};\n\n      // Normalize the fragment.\n      fragment = this.getFragment(fragment || '');\n\n      // Strip trailing slash on the root unless _trailingSlash is true\n      var rootPath = this.root;\n      if (!this._trailingSlash && (fragment === '' || fragment.charAt(0) === '?')) {\n        rootPath = rootPath.slice(0, -1) || '/';\n      }\n      var url = rootPath + fragment;\n\n      // Strip the fragment of the query and hash for matching.\n      fragment = fragment.replace(pathStripper, '');\n\n      // Decode for matching.\n      var decodedFragment = this.decodeFragment(fragment);\n\n      if (this.fragment === decodedFragment) return;\n      this.fragment = decodedFragment;\n\n      // If pushState is available, we use it to set the fragment as a real URL.\n      if (this._usePushState) {\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n      // If hash changes haven't been explicitly disabled, update the hash\n      // fragment to store history.\n      } else if (this._wantsHashChange) {\n        this._updateHash(this.location, fragment, options.replace);\n        if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {\n          var iWindow = this.iframe.contentWindow;\n\n          // Opening and closing the iframe tricks IE7 and earlier to push a\n          // history entry on hash-tag change.  When replace is true, we don't\n          // want this.\n          if (!options.replace) {\n            iWindow.document.open();\n            iWindow.document.close();\n          }\n\n          this._updateHash(iWindow.location, fragment, options.replace);\n        }\n\n      // If you've told us that you explicitly don't want fallback hashchange-\n      // based history, then `navigate` becomes a page refresh.\n      } else {\n        return this.location.assign(url);\n      }\n      if (options.trigger) return this.loadUrl(fragment);\n    },\n\n    // Update the hash location, either replacing the current entry, or adding\n    // a new one to the browser history.\n    _updateHash: function(location, fragment, replace) {\n      if (replace) {\n        var href = location.href.replace(/(javascript:|#).*$/, '');\n        location.replace(href + '#' + fragment);\n      } else {\n        // Some browsers require that `hash` contains a leading #.\n        location.hash = '#' + fragment;\n      }\n    }\n\n  });\n\n  // Create the default Backbone.history.\n  Backbone.history = new History;\n\n  // Helpers\n  // -------\n\n  // Helper function to correctly set up the prototype chain for subclasses.\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\n  // class properties to be extended.\n  var extend = function(protoProps, staticProps) {\n    var parent = this;\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent constructor.\n    if (protoProps && _.has(protoProps, 'constructor')) {\n      child = protoProps.constructor;\n    } else {\n      child = function(){ return parent.apply(this, arguments); };\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    _.extend(child, parent, staticProps);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function and add the prototype properties.\n    child.prototype = _.create(parent.prototype, protoProps);\n    child.prototype.constructor = child;\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n\n    return child;\n  };\n\n  // Set up inheritance for the model, collection, router, view and history.\n  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\n\n  // Throw an error when a URL is needed, and none is supplied.\n  var urlError = function() {\n    throw new Error('A \"url\" property or function must be specified');\n  };\n\n  // Wrap an optional error callback with a fallback error event.\n  var wrapError = function(model, options) {\n    var error = options.error;\n    options.error = function(resp) {\n      if (error) error.call(options.context, model, resp, options);\n      model.trigger('error', model, resp, options);\n    };\n  };\n\n  return Backbone;\n});\n","/*! JointJS v3.7.1 (2023-04-28) - JavaScript diagramming library\n\n\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n*/\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('backbone'), require('jquery')) :\n\ttypeof define === 'function' && define.amd ? define(['exports', 'backbone', 'jquery'], factory) :\n\t(global = global || self, factory(global.joint = {}, global.Backbone, global.$));\n}(this, function (exports, Backbone, $) { 'use strict';\n\n\tBackbone = Backbone && Backbone.hasOwnProperty('default') ? Backbone['default'] : Backbone;\n\t$ = $ && $.hasOwnProperty('default') ? $['default'] : $;\n\n\tvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction commonjsRequire () {\n\t\tthrow new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');\n\t}\n\n\tfunction unwrapExports (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;\n\t}\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tfunction getCjsExportFromNamespace (n) {\n\t\treturn n && n.default || n;\n\t}\n\n\tvar check = function (it) {\n\t  return it && it.Math == Math && it;\n\t};\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global_1 =\n\t  // eslint-disable-next-line no-undef\n\t  check(typeof globalThis == 'object' && globalThis) ||\n\t  check(typeof window == 'object' && window) ||\n\t  check(typeof self == 'object' && self) ||\n\t  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n\t  // eslint-disable-next-line no-new-func\n\t  (function () { return this; })() || Function('return this')();\n\n\tvar fails = function (exec) {\n\t  try {\n\t    return !!exec();\n\t  } catch (error) {\n\t    return true;\n\t  }\n\t};\n\n\t// Detect IE8's incomplete defineProperty implementation\n\tvar descriptors = !fails(function () {\n\t  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n\t});\n\n\t'use strict';\n\tvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\n\tvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\t// Nashorn ~ JDK8 bug\n\tvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\n\t// `Object.prototype.propertyIsEnumerable` method implementation\n\t// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\n\tvar f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n\t  var descriptor = getOwnPropertyDescriptor(this, V);\n\t  return !!descriptor && descriptor.enumerable;\n\t} : nativePropertyIsEnumerable;\n\n\tvar objectPropertyIsEnumerable = {\n\t\tf: f\n\t};\n\n\tvar createPropertyDescriptor = function (bitmap, value) {\n\t  return {\n\t    enumerable: !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable: !(bitmap & 4),\n\t    value: value\n\t  };\n\t};\n\n\tvar toString = {}.toString;\n\n\tvar classofRaw = function (it) {\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n\tvar split = ''.split;\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar indexedObject = fails(function () {\n\t  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n\t  // eslint-disable-next-line no-prototype-builtins\n\t  return !Object('z').propertyIsEnumerable(0);\n\t}) ? function (it) {\n\t  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);\n\t} : Object;\n\n\t// `RequireObjectCoercible` abstract operation\n\t// https://tc39.es/ecma262/#sec-requireobjectcoercible\n\tvar requireObjectCoercible = function (it) {\n\t  if (it == undefined) { throw TypeError(\"Can't call method on \" + it); }\n\t  return it;\n\t};\n\n\t// toObject with fallback for non-array-like ES3 strings\n\n\n\n\tvar toIndexedObject = function (it) {\n\t  return indexedObject(requireObjectCoercible(it));\n\t};\n\n\tvar isObject = function (it) {\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n\t// `ToPrimitive` abstract operation\n\t// https://tc39.es/ecma262/#sec-toprimitive\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tvar toPrimitive = function (input, PREFERRED_STRING) {\n\t  if (!isObject(input)) { return input; }\n\t  var fn, val;\n\t  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) { return val; }\n\t  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) { return val; }\n\t  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) { return val; }\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n\tvar hasOwnProperty$1 = {}.hasOwnProperty;\n\n\tvar has = function (it, key) {\n\t  return hasOwnProperty$1.call(it, key);\n\t};\n\n\tvar document$1 = global_1.document;\n\t// typeof document.createElement is 'object' in old IE\n\tvar EXISTS = isObject(document$1) && isObject(document$1.createElement);\n\n\tvar documentCreateElement = function (it) {\n\t  return EXISTS ? document$1.createElement(it) : {};\n\t};\n\n\t// Thank's IE8 for his funny defineProperty\n\tvar ie8DomDefine = !descriptors && !fails(function () {\n\t  return Object.defineProperty(documentCreateElement('div'), 'a', {\n\t    get: function () { return 7; }\n\t  }).a != 7;\n\t});\n\n\tvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\t// `Object.getOwnPropertyDescriptor` method\n\t// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n\tvar f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n\t  O = toIndexedObject(O);\n\t  P = toPrimitive(P, true);\n\t  if (ie8DomDefine) { try {\n\t    return nativeGetOwnPropertyDescriptor(O, P);\n\t  } catch (error) { /* empty */ } }\n\t  if (has(O, P)) { return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]); }\n\t};\n\n\tvar objectGetOwnPropertyDescriptor = {\n\t\tf: f$1\n\t};\n\n\tvar anObject = function (it) {\n\t  if (!isObject(it)) {\n\t    throw TypeError(String(it) + ' is not an object');\n\t  } return it;\n\t};\n\n\tvar nativeDefineProperty = Object.defineProperty;\n\n\t// `Object.defineProperty` method\n\t// https://tc39.es/ecma262/#sec-object.defineproperty\n\tvar f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if (ie8DomDefine) { try {\n\t    return nativeDefineProperty(O, P, Attributes);\n\t  } catch (error) { /* empty */ } }\n\t  if ('get' in Attributes || 'set' in Attributes) { throw TypeError('Accessors not supported'); }\n\t  if ('value' in Attributes) { O[P] = Attributes.value; }\n\t  return O;\n\t};\n\n\tvar objectDefineProperty = {\n\t\tf: f$2\n\t};\n\n\tvar createNonEnumerableProperty = descriptors ? function (object, key, value) {\n\t  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));\n\t} : function (object, key, value) {\n\t  object[key] = value;\n\t  return object;\n\t};\n\n\tvar setGlobal = function (key, value) {\n\t  try {\n\t    createNonEnumerableProperty(global_1, key, value);\n\t  } catch (error) {\n\t    global_1[key] = value;\n\t  } return value;\n\t};\n\n\tvar SHARED = '__core-js_shared__';\n\tvar store = global_1[SHARED] || setGlobal(SHARED, {});\n\n\tvar sharedStore = store;\n\n\tvar functionToString = Function.toString;\n\n\t// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper\n\tif (typeof sharedStore.inspectSource != 'function') {\n\t  sharedStore.inspectSource = function (it) {\n\t    return functionToString.call(it);\n\t  };\n\t}\n\n\tvar inspectSource = sharedStore.inspectSource;\n\n\tvar WeakMap = global_1.WeakMap;\n\n\tvar nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));\n\n\tvar isPure = false;\n\n\tvar shared = createCommonjsModule(function (module) {\n\t(module.exports = function (key, value) {\n\t  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});\n\t})('versions', []).push({\n\t  version: '3.8.3',\n\t  mode: isPure ? 'pure' : 'global',\n\t  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'\n\t});\n\t});\n\n\tvar id = 0;\n\tvar postfix = Math.random();\n\n\tvar uid = function (key) {\n\t  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n\t};\n\n\tvar keys = shared('keys');\n\n\tvar sharedKey = function (key) {\n\t  return keys[key] || (keys[key] = uid(key));\n\t};\n\n\tvar hiddenKeys = {};\n\n\tvar WeakMap$1 = global_1.WeakMap;\n\tvar set, get, has$1;\n\n\tvar enforce = function (it) {\n\t  return has$1(it) ? get(it) : set(it, {});\n\t};\n\n\tvar getterFor = function (TYPE) {\n\t  return function (it) {\n\t    var state;\n\t    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n\t      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n\t    } return state;\n\t  };\n\t};\n\n\tif (nativeWeakMap) {\n\t  var store$1 = sharedStore.state || (sharedStore.state = new WeakMap$1());\n\t  var wmget = store$1.get;\n\t  var wmhas = store$1.has;\n\t  var wmset = store$1.set;\n\t  set = function (it, metadata) {\n\t    metadata.facade = it;\n\t    wmset.call(store$1, it, metadata);\n\t    return metadata;\n\t  };\n\t  get = function (it) {\n\t    return wmget.call(store$1, it) || {};\n\t  };\n\t  has$1 = function (it) {\n\t    return wmhas.call(store$1, it);\n\t  };\n\t} else {\n\t  var STATE = sharedKey('state');\n\t  hiddenKeys[STATE] = true;\n\t  set = function (it, metadata) {\n\t    metadata.facade = it;\n\t    createNonEnumerableProperty(it, STATE, metadata);\n\t    return metadata;\n\t  };\n\t  get = function (it) {\n\t    return has(it, STATE) ? it[STATE] : {};\n\t  };\n\t  has$1 = function (it) {\n\t    return has(it, STATE);\n\t  };\n\t}\n\n\tvar internalState = {\n\t  set: set,\n\t  get: get,\n\t  has: has$1,\n\t  enforce: enforce,\n\t  getterFor: getterFor\n\t};\n\tvar internalState_1 = internalState.set;\n\tvar internalState_2 = internalState.get;\n\tvar internalState_3 = internalState.has;\n\tvar internalState_4 = internalState.enforce;\n\tvar internalState_5 = internalState.getterFor;\n\n\tvar redefine = createCommonjsModule(function (module) {\n\tvar getInternalState = internalState.get;\n\tvar enforceInternalState = internalState.enforce;\n\tvar TEMPLATE = String(String).split('String');\n\n\t(module.exports = function (O, key, value, options) {\n\t  var unsafe = options ? !!options.unsafe : false;\n\t  var simple = options ? !!options.enumerable : false;\n\t  var noTargetGet = options ? !!options.noTargetGet : false;\n\t  var state;\n\t  if (typeof value == 'function') {\n\t    if (typeof key == 'string' && !has(value, 'name')) {\n\t      createNonEnumerableProperty(value, 'name', key);\n\t    }\n\t    state = enforceInternalState(value);\n\t    if (!state.source) {\n\t      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');\n\t    }\n\t  }\n\t  if (O === global_1) {\n\t    if (simple) { O[key] = value; }\n\t    else { setGlobal(key, value); }\n\t    return;\n\t  } else if (!unsafe) {\n\t    delete O[key];\n\t  } else if (!noTargetGet && O[key]) {\n\t    simple = true;\n\t  }\n\t  if (simple) { O[key] = value; }\n\t  else { createNonEnumerableProperty(O, key, value); }\n\t// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\t})(Function.prototype, 'toString', function toString() {\n\t  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);\n\t});\n\t});\n\n\tvar path = global_1;\n\n\tvar aFunction = function (variable) {\n\t  return typeof variable == 'function' ? variable : undefined;\n\t};\n\n\tvar getBuiltIn = function (namespace, method) {\n\t  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])\n\t    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];\n\t};\n\n\tvar ceil = Math.ceil;\n\tvar floor = Math.floor;\n\n\t// `ToInteger` abstract operation\n\t// https://tc39.es/ecma262/#sec-tointeger\n\tvar toInteger = function (argument) {\n\t  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n\t};\n\n\tvar min = Math.min;\n\n\t// `ToLength` abstract operation\n\t// https://tc39.es/ecma262/#sec-tolength\n\tvar toLength = function (argument) {\n\t  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n\t};\n\n\tvar max = Math.max;\n\tvar min$1 = Math.min;\n\n\t// Helper for a popular repeating case of the spec:\n\t// Let integer be ? ToInteger(index).\n\t// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n\tvar toAbsoluteIndex = function (index, length) {\n\t  var integer = toInteger(index);\n\t  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n\t};\n\n\t// `Array.prototype.{ indexOf, includes }` methods implementation\n\tvar createMethod = function (IS_INCLUDES) {\n\t  return function ($this, el, fromIndex) {\n\t    var O = toIndexedObject($this);\n\t    var length = toLength(O.length);\n\t    var index = toAbsoluteIndex(fromIndex, length);\n\t    var value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    // eslint-disable-next-line no-self-compare\n\t    if (IS_INCLUDES && el != el) { while (length > index) {\n\t      value = O[index++];\n\t      // eslint-disable-next-line no-self-compare\n\t      if (value != value) { return true; }\n\t    // Array#indexOf ignores holes, Array#includes - not\n\t    } } else { for (;length > index; index++) {\n\t      if ((IS_INCLUDES || index in O) && O[index] === el) { return IS_INCLUDES || index || 0; }\n\t    } } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n\tvar arrayIncludes = {\n\t  // `Array.prototype.includes` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.includes\n\t  includes: createMethod(true),\n\t  // `Array.prototype.indexOf` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n\t  indexOf: createMethod(false)\n\t};\n\tvar arrayIncludes_1 = arrayIncludes.includes;\n\tvar arrayIncludes_2 = arrayIncludes.indexOf;\n\n\tvar indexOf = arrayIncludes.indexOf;\n\n\n\tvar objectKeysInternal = function (object, names) {\n\t  var O = toIndexedObject(object);\n\t  var i = 0;\n\t  var result = [];\n\t  var key;\n\t  for (key in O) { !has(hiddenKeys, key) && has(O, key) && result.push(key); }\n\t  // Don't enum bug & hidden keys\n\t  while (names.length > i) { if (has(O, key = names[i++])) {\n\t    ~indexOf(result, key) || result.push(key);\n\t  } }\n\t  return result;\n\t};\n\n\t// IE8- don't enum bug keys\n\tvar enumBugKeys = [\n\t  'constructor',\n\t  'hasOwnProperty',\n\t  'isPrototypeOf',\n\t  'propertyIsEnumerable',\n\t  'toLocaleString',\n\t  'toString',\n\t  'valueOf'\n\t];\n\n\tvar hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');\n\n\t// `Object.getOwnPropertyNames` method\n\t// https://tc39.es/ecma262/#sec-object.getownpropertynames\n\tvar f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n\t  return objectKeysInternal(O, hiddenKeys$1);\n\t};\n\n\tvar objectGetOwnPropertyNames = {\n\t\tf: f$3\n\t};\n\n\tvar f$4 = Object.getOwnPropertySymbols;\n\n\tvar objectGetOwnPropertySymbols = {\n\t\tf: f$4\n\t};\n\n\t// all object keys, includes non-enumerable and symbols\n\tvar ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n\t  var keys = objectGetOwnPropertyNames.f(anObject(it));\n\t  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n\t  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n\t};\n\n\tvar copyConstructorProperties = function (target, source) {\n\t  var keys = ownKeys(source);\n\t  var defineProperty = objectDefineProperty.f;\n\t  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\t  for (var i = 0; i < keys.length; i++) {\n\t    var key = keys[i];\n\t    if (!has(target, key)) { defineProperty(target, key, getOwnPropertyDescriptor(source, key)); }\n\t  }\n\t};\n\n\tvar replacement = /#|\\.prototype\\./;\n\n\tvar isForced = function (feature, detection) {\n\t  var value = data[normalize(feature)];\n\t  return value == POLYFILL ? true\n\t    : value == NATIVE ? false\n\t    : typeof detection == 'function' ? fails(detection)\n\t    : !!detection;\n\t};\n\n\tvar normalize = isForced.normalize = function (string) {\n\t  return String(string).replace(replacement, '.').toLowerCase();\n\t};\n\n\tvar data = isForced.data = {};\n\tvar NATIVE = isForced.NATIVE = 'N';\n\tvar POLYFILL = isForced.POLYFILL = 'P';\n\n\tvar isForced_1 = isForced;\n\n\tvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\n\n\n\n\n\n\n\t/*\n\t  options.target      - name of the target object\n\t  options.global      - target is the global object\n\t  options.stat        - export as static methods of target\n\t  options.proto       - export as prototype methods of target\n\t  options.real        - real prototype method for the `pure` version\n\t  options.forced      - export even if the native feature is available\n\t  options.bind        - bind methods to the target, required for the `pure` version\n\t  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n\t  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n\t  options.sham        - add a flag to not completely full polyfills\n\t  options.enumerable  - export as enumerable property\n\t  options.noTargetGet - prevent calling a getter on target\n\t*/\n\tvar _export = function (options, source) {\n\t  var TARGET = options.target;\n\t  var GLOBAL = options.global;\n\t  var STATIC = options.stat;\n\t  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n\t  if (GLOBAL) {\n\t    target = global_1;\n\t  } else if (STATIC) {\n\t    target = global_1[TARGET] || setGlobal(TARGET, {});\n\t  } else {\n\t    target = (global_1[TARGET] || {}).prototype;\n\t  }\n\t  if (target) { for (key in source) {\n\t    sourceProperty = source[key];\n\t    if (options.noTargetGet) {\n\t      descriptor = getOwnPropertyDescriptor$1(target, key);\n\t      targetProperty = descriptor && descriptor.value;\n\t    } else { targetProperty = target[key]; }\n\t    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n\t    // contained in target\n\t    if (!FORCED && targetProperty !== undefined) {\n\t      if (typeof sourceProperty === typeof targetProperty) { continue; }\n\t      copyConstructorProperties(sourceProperty, targetProperty);\n\t    }\n\t    // add a flag to not completely full polyfills\n\t    if (options.sham || (targetProperty && targetProperty.sham)) {\n\t      createNonEnumerableProperty(sourceProperty, 'sham', true);\n\t    }\n\t    // extend global\n\t    redefine(target, key, sourceProperty, options);\n\t  } }\n\t};\n\n\tvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {\n\t  // Chrome 38 Symbol has incorrect toString conversion\n\t  // eslint-disable-next-line no-undef\n\t  return !String(Symbol());\n\t});\n\n\tvar useSymbolAsUid = nativeSymbol\n\t  // eslint-disable-next-line no-undef\n\t  && !Symbol.sham\n\t  // eslint-disable-next-line no-undef\n\t  && typeof Symbol.iterator == 'symbol';\n\n\tvar WellKnownSymbolsStore = shared('wks');\n\tvar Symbol$1 = global_1.Symbol;\n\tvar createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;\n\n\tvar wellKnownSymbol = function (name) {\n\t  if (!has(WellKnownSymbolsStore, name)) {\n\t    if (nativeSymbol && has(Symbol$1, name)) { WellKnownSymbolsStore[name] = Symbol$1[name]; }\n\t    else { WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name); }\n\t  } return WellKnownSymbolsStore[name];\n\t};\n\n\t// `Object.keys` method\n\t// https://tc39.es/ecma262/#sec-object.keys\n\tvar objectKeys = Object.keys || function keys(O) {\n\t  return objectKeysInternal(O, enumBugKeys);\n\t};\n\n\t// `Object.defineProperties` method\n\t// https://tc39.es/ecma262/#sec-object.defineproperties\n\tvar objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n\t  anObject(O);\n\t  var keys = objectKeys(Properties);\n\t  var length = keys.length;\n\t  var index = 0;\n\t  var key;\n\t  while (length > index) { objectDefineProperty.f(O, key = keys[index++], Properties[key]); }\n\t  return O;\n\t};\n\n\tvar html = getBuiltIn('document', 'documentElement');\n\n\tvar GT = '>';\n\tvar LT = '<';\n\tvar PROTOTYPE = 'prototype';\n\tvar SCRIPT = 'script';\n\tvar IE_PROTO = sharedKey('IE_PROTO');\n\n\tvar EmptyConstructor = function () { /* empty */ };\n\n\tvar scriptTag = function (content) {\n\t  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n\t};\n\n\t// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\n\tvar NullProtoObjectViaActiveX = function (activeXDocument) {\n\t  activeXDocument.write(scriptTag(''));\n\t  activeXDocument.close();\n\t  var temp = activeXDocument.parentWindow.Object;\n\t  activeXDocument = null; // avoid memory leak\n\t  return temp;\n\t};\n\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar NullProtoObjectViaIFrame = function () {\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = documentCreateElement('iframe');\n\t  var JS = 'java' + SCRIPT + ':';\n\t  var iframeDocument;\n\t  iframe.style.display = 'none';\n\t  html.appendChild(iframe);\n\t  // https://github.com/zloirock/core-js/issues/475\n\t  iframe.src = String(JS);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(scriptTag('document.F=Object'));\n\t  iframeDocument.close();\n\t  return iframeDocument.F;\n\t};\n\n\t// Check for document.domain and active x support\n\t// No need to use active x approach when document.domain is not set\n\t// see https://github.com/es-shims/es5-shim/issues/150\n\t// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n\t// avoid IE GC bug\n\tvar activeXDocument;\n\tvar NullProtoObject = function () {\n\t  try {\n\t    /* global ActiveXObject */\n\t    activeXDocument = document.domain && new ActiveXObject('htmlfile');\n\t  } catch (error) { /* ignore */ }\n\t  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\n\t  var length = enumBugKeys.length;\n\t  while (length--) { delete NullProtoObject[PROTOTYPE][enumBugKeys[length]]; }\n\t  return NullProtoObject();\n\t};\n\n\thiddenKeys[IE_PROTO] = true;\n\n\t// `Object.create` method\n\t// https://tc39.es/ecma262/#sec-object.create\n\tvar objectCreate = Object.create || function create(O, Properties) {\n\t  var result;\n\t  if (O !== null) {\n\t    EmptyConstructor[PROTOTYPE] = anObject(O);\n\t    result = new EmptyConstructor();\n\t    EmptyConstructor[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO] = O;\n\t  } else { result = NullProtoObject(); }\n\t  return Properties === undefined ? result : objectDefineProperties(result, Properties);\n\t};\n\n\tvar UNSCOPABLES = wellKnownSymbol('unscopables');\n\tvar ArrayPrototype = Array.prototype;\n\n\t// Array.prototype[@@unscopables]\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\tif (ArrayPrototype[UNSCOPABLES] == undefined) {\n\t  objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {\n\t    configurable: true,\n\t    value: objectCreate(null)\n\t  });\n\t}\n\n\t// add a key to Array.prototype[@@unscopables]\n\tvar addToUnscopables = function (key) {\n\t  ArrayPrototype[UNSCOPABLES][key] = true;\n\t};\n\n\tvar defineProperty = Object.defineProperty;\n\tvar cache = {};\n\n\tvar thrower = function (it) { throw it; };\n\n\tvar arrayMethodUsesToLength = function (METHOD_NAME, options) {\n\t  if (has(cache, METHOD_NAME)) { return cache[METHOD_NAME]; }\n\t  if (!options) { options = {}; }\n\t  var method = [][METHOD_NAME];\n\t  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;\n\t  var argument0 = has(options, 0) ? options[0] : thrower;\n\t  var argument1 = has(options, 1) ? options[1] : undefined;\n\n\t  return cache[METHOD_NAME] = !!method && !fails(function () {\n\t    if (ACCESSORS && !descriptors) { return true; }\n\t    var O = { length: -1 };\n\n\t    if (ACCESSORS) { defineProperty(O, 1, { enumerable: true, get: thrower }); }\n\t    else { O[1] = 1; }\n\n\t    method.call(O, argument0, argument1);\n\t  });\n\t};\n\n\t'use strict';\n\n\tvar $includes = arrayIncludes.includes;\n\n\n\n\tvar USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });\n\n\t// `Array.prototype.includes` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.includes\n\t_export({ target: 'Array', proto: true, forced: !USES_TO_LENGTH }, {\n\t  includes: function includes(el /* , fromIndex = 0 */) {\n\t    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables('includes');\n\n\tvar es_array_includes = {\n\n\t};\n\n\tvar aFunction$1 = function (it) {\n\t  if (typeof it != 'function') {\n\t    throw TypeError(String(it) + ' is not a function');\n\t  } return it;\n\t};\n\n\t// optional / simple context binding\n\tvar functionBindContext = function (fn, that, length) {\n\t  aFunction$1(fn);\n\t  if (that === undefined) { return fn; }\n\t  switch (length) {\n\t    case 0: return function () {\n\t      return fn.call(that);\n\t    };\n\t    case 1: return function (a) {\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function (a, b) {\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function (a, b, c) {\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function (/* ...args */) {\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n\tvar call = Function.call;\n\n\tvar entryUnbind = function (CONSTRUCTOR, METHOD, length) {\n\t  return functionBindContext(call, global_1[CONSTRUCTOR].prototype[METHOD], length);\n\t};\n\n\tvar includes = entryUnbind('Array', 'includes');\n\n\tvar includes$1 = includes;\n\n\t// `ToObject` abstract operation\n\t// https://tc39.es/ecma262/#sec-toobject\n\tvar toObject = function (argument) {\n\t  return Object(requireObjectCoercible(argument));\n\t};\n\n\t// `IsArray` abstract operation\n\t// https://tc39.es/ecma262/#sec-isarray\n\tvar isArray = Array.isArray || function isArray(arg) {\n\t  return classofRaw(arg) == 'Array';\n\t};\n\n\tvar SPECIES = wellKnownSymbol('species');\n\n\t// `ArraySpeciesCreate` abstract operation\n\t// https://tc39.es/ecma262/#sec-arrayspeciescreate\n\tvar arraySpeciesCreate = function (originalArray, length) {\n\t  var C;\n\t  if (isArray(originalArray)) {\n\t    C = originalArray.constructor;\n\t    // cross-realm fallback\n\t    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) { C = undefined; }\n\t    else if (isObject(C)) {\n\t      C = C[SPECIES];\n\t      if (C === null) { C = undefined; }\n\t    }\n\t  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n\t};\n\n\tvar push = [].push;\n\n\t// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation\n\tvar createMethod$1 = function (TYPE) {\n\t  var IS_MAP = TYPE == 1;\n\t  var IS_FILTER = TYPE == 2;\n\t  var IS_SOME = TYPE == 3;\n\t  var IS_EVERY = TYPE == 4;\n\t  var IS_FIND_INDEX = TYPE == 6;\n\t  var IS_FILTER_OUT = TYPE == 7;\n\t  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n\t  return function ($this, callbackfn, that, specificCreate) {\n\t    var O = toObject($this);\n\t    var self = indexedObject(O);\n\t    var boundFunction = functionBindContext(callbackfn, that, 3);\n\t    var length = toLength(self.length);\n\t    var index = 0;\n\t    var create = specificCreate || arraySpeciesCreate;\n\t    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;\n\t    var value, result;\n\t    for (;length > index; index++) { if (NO_HOLES || index in self) {\n\t      value = self[index];\n\t      result = boundFunction(value, index, O);\n\t      if (TYPE) {\n\t        if (IS_MAP) { target[index] = result; } // map\n\t        else if (result) { switch (TYPE) {\n\t          case 3: return true;              // some\n\t          case 5: return value;             // find\n\t          case 6: return index;             // findIndex\n\t          case 2: push.call(target, value); // filter\n\t        } } else { switch (TYPE) {\n\t          case 4: return false;             // every\n\t          case 7: push.call(target, value); // filterOut\n\t        } }\n\t      }\n\t    } }\n\t    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n\t  };\n\t};\n\n\tvar arrayIteration = {\n\t  // `Array.prototype.forEach` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n\t  forEach: createMethod$1(0),\n\t  // `Array.prototype.map` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.map\n\t  map: createMethod$1(1),\n\t  // `Array.prototype.filter` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.filter\n\t  filter: createMethod$1(2),\n\t  // `Array.prototype.some` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.some\n\t  some: createMethod$1(3),\n\t  // `Array.prototype.every` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.every\n\t  every: createMethod$1(4),\n\t  // `Array.prototype.find` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.find\n\t  find: createMethod$1(5),\n\t  // `Array.prototype.findIndex` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n\t  findIndex: createMethod$1(6),\n\t  // `Array.prototype.filterOut` method\n\t  // https://github.com/tc39/proposal-array-filtering\n\t  filterOut: createMethod$1(7)\n\t};\n\tvar arrayIteration_1 = arrayIteration.forEach;\n\tvar arrayIteration_2 = arrayIteration.map;\n\tvar arrayIteration_3 = arrayIteration.filter;\n\tvar arrayIteration_4 = arrayIteration.some;\n\tvar arrayIteration_5 = arrayIteration.every;\n\tvar arrayIteration_6 = arrayIteration.find;\n\tvar arrayIteration_7 = arrayIteration.findIndex;\n\tvar arrayIteration_8 = arrayIteration.filterOut;\n\n\t'use strict';\n\n\tvar $find = arrayIteration.find;\n\n\n\n\tvar FIND = 'find';\n\tvar SKIPS_HOLES = true;\n\n\tvar USES_TO_LENGTH$1 = arrayMethodUsesToLength(FIND);\n\n\t// Shouldn't skip holes\n\tif (FIND in []) { Array(1)[FIND](function () { SKIPS_HOLES = false; }); }\n\n\t// `Array.prototype.find` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.find\n\t_export({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH$1 }, {\n\t  find: function find(callbackfn /* , that = undefined */) {\n\t    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables(FIND);\n\n\tvar es_array_find = {\n\n\t};\n\n\tvar find = entryUnbind('Array', 'find');\n\n\tvar find$1 = find;\n\n\t// `String.prototype.{ codePointAt, at }` methods implementation\n\tvar createMethod$2 = function (CONVERT_TO_STRING) {\n\t  return function ($this, pos) {\n\t    var S = String(requireObjectCoercible($this));\n\t    var position = toInteger(pos);\n\t    var size = S.length;\n\t    var first, second;\n\t    if (position < 0 || position >= size) { return CONVERT_TO_STRING ? '' : undefined; }\n\t    first = S.charCodeAt(position);\n\t    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n\t      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF\n\t        ? CONVERT_TO_STRING ? S.charAt(position) : first\n\t        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n\t  };\n\t};\n\n\tvar stringMultibyte = {\n\t  // `String.prototype.codePointAt` method\n\t  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n\t  codeAt: createMethod$2(false),\n\t  // `String.prototype.at` method\n\t  // https://github.com/mathiasbynens/String.prototype.at\n\t  charAt: createMethod$2(true)\n\t};\n\tvar stringMultibyte_1 = stringMultibyte.codeAt;\n\tvar stringMultibyte_2 = stringMultibyte.charAt;\n\n\tvar correctPrototypeGetter = !fails(function () {\n\t  function F() { /* empty */ }\n\t  F.prototype.constructor = null;\n\t  return Object.getPrototypeOf(new F()) !== F.prototype;\n\t});\n\n\tvar IE_PROTO$1 = sharedKey('IE_PROTO');\n\tvar ObjectPrototype = Object.prototype;\n\n\t// `Object.getPrototypeOf` method\n\t// https://tc39.es/ecma262/#sec-object.getprototypeof\n\tvar objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {\n\t  O = toObject(O);\n\t  if (has(O, IE_PROTO$1)) { return O[IE_PROTO$1]; }\n\t  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectPrototype : null;\n\t};\n\n\t'use strict';\n\n\n\n\n\n\n\n\tvar ITERATOR = wellKnownSymbol('iterator');\n\tvar BUGGY_SAFARI_ITERATORS = false;\n\n\tvar returnThis = function () { return this; };\n\n\t// `%IteratorPrototype%` object\n\t// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\n\tvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n\tif ([].keys) {\n\t  arrayIterator = [].keys();\n\t  // Safari 8 has buggy iterators w/o `next`\n\t  if (!('next' in arrayIterator)) { BUGGY_SAFARI_ITERATORS = true; }\n\t  else {\n\t    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));\n\t    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) { IteratorPrototype = PrototypeOfArrayIteratorPrototype; }\n\t  }\n\t}\n\n\tvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {\n\t  var test = {};\n\t  // FF44- legacy iterators case\n\t  return IteratorPrototype[ITERATOR].call(test) !== test;\n\t});\n\n\tif (NEW_ITERATOR_PROTOTYPE) { IteratorPrototype = {}; }\n\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\tif ((!isPure || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {\n\t  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\n\t}\n\n\tvar iteratorsCore = {\n\t  IteratorPrototype: IteratorPrototype,\n\t  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n\t};\n\tvar iteratorsCore_1 = iteratorsCore.IteratorPrototype;\n\tvar iteratorsCore_2 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n\n\tvar defineProperty$1 = objectDefineProperty.f;\n\n\n\n\tvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\n\tvar setToStringTag = function (it, TAG, STATIC) {\n\t  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n\t    defineProperty$1(it, TO_STRING_TAG, { configurable: true, value: TAG });\n\t  }\n\t};\n\n\tvar iterators = {};\n\n\t'use strict';\n\tvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\n\n\n\n\n\n\tvar returnThis$1 = function () { return this; };\n\n\tvar createIteratorConstructor = function (IteratorConstructor, NAME, next) {\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });\n\t  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n\t  iterators[TO_STRING_TAG] = returnThis$1;\n\t  return IteratorConstructor;\n\t};\n\n\tvar aPossiblePrototype = function (it) {\n\t  if (!isObject(it) && it !== null) {\n\t    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n\t  } return it;\n\t};\n\n\t// `Object.setPrototypeOf` method\n\t// https://tc39.es/ecma262/#sec-object.setprototypeof\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t/* eslint-disable no-proto */\n\tvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n\t  var CORRECT_SETTER = false;\n\t  var test = {};\n\t  var setter;\n\t  try {\n\t    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n\t    setter.call(test, []);\n\t    CORRECT_SETTER = test instanceof Array;\n\t  } catch (error) { /* empty */ }\n\t  return function setPrototypeOf(O, proto) {\n\t    anObject(O);\n\t    aPossiblePrototype(proto);\n\t    if (CORRECT_SETTER) { setter.call(O, proto); }\n\t    else { O.__proto__ = proto; }\n\t    return O;\n\t  };\n\t}() : undefined);\n\n\t'use strict';\n\n\n\n\n\n\n\n\n\n\n\n\n\tvar IteratorPrototype$2 = iteratorsCore.IteratorPrototype;\n\tvar BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n\tvar ITERATOR$1 = wellKnownSymbol('iterator');\n\tvar KEYS = 'keys';\n\tvar VALUES = 'values';\n\tvar ENTRIES = 'entries';\n\n\tvar returnThis$2 = function () { return this; };\n\n\tvar defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n\t  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n\t  var getIterationMethod = function (KIND) {\n\t    if (KIND === DEFAULT && defaultIterator) { return defaultIterator; }\n\t    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) { return IterablePrototype[KIND]; }\n\t    switch (KIND) {\n\t      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n\t      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n\t      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n\t    } return function () { return new IteratorConstructor(this); };\n\t  };\n\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  var INCORRECT_VALUES_NAME = false;\n\t  var IterablePrototype = Iterable.prototype;\n\t  var nativeIterator = IterablePrototype[ITERATOR$1]\n\t    || IterablePrototype['@@iterator']\n\t    || DEFAULT && IterablePrototype[DEFAULT];\n\t  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);\n\t  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n\t  var CurrentIteratorPrototype, methods, KEY;\n\n\t  // fix native\n\t  if (anyNativeIterator) {\n\t    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));\n\t    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {\n\t      if (!isPure && objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {\n\t        if (objectSetPrototypeOf) {\n\t          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);\n\t        } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {\n\t          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);\n\t        }\n\t      }\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n\t      if (isPure) { iterators[TO_STRING_TAG] = returnThis$2; }\n\t    }\n\t  }\n\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n\t    INCORRECT_VALUES_NAME = true;\n\t    defaultIterator = function values() { return nativeIterator.call(this); };\n\t  }\n\n\t  // define iterator\n\t  if ((!isPure || FORCED) && IterablePrototype[ITERATOR$1] !== defaultIterator) {\n\t    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);\n\t  }\n\t  iterators[NAME] = defaultIterator;\n\n\t  // export additional methods\n\t  if (DEFAULT) {\n\t    methods = {\n\t      values: getIterationMethod(VALUES),\n\t      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n\t      entries: getIterationMethod(ENTRIES)\n\t    };\n\t    if (FORCED) { for (KEY in methods) {\n\t      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n\t        redefine(IterablePrototype, KEY, methods[KEY]);\n\t      }\n\t    } } else { _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods); }\n\t  }\n\n\t  return methods;\n\t};\n\n\t'use strict';\n\tvar charAt = stringMultibyte.charAt;\n\n\n\n\tvar STRING_ITERATOR = 'String Iterator';\n\tvar setInternalState = internalState.set;\n\tvar getInternalState = internalState.getterFor(STRING_ITERATOR);\n\n\t// `String.prototype[@@iterator]` method\n\t// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\n\tdefineIterator(String, 'String', function (iterated) {\n\t  setInternalState(this, {\n\t    type: STRING_ITERATOR,\n\t    string: String(iterated),\n\t    index: 0\n\t  });\n\t// `%StringIteratorPrototype%.next` method\n\t// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n\t}, function next() {\n\t  var state = getInternalState(this);\n\t  var string = state.string;\n\t  var index = state.index;\n\t  var point;\n\t  if (index >= string.length) { return { value: undefined, done: true }; }\n\t  point = charAt(string, index);\n\t  state.index += point.length;\n\t  return { value: point, done: false };\n\t});\n\n\tvar es_string_iterator = {\n\n\t};\n\n\tvar iteratorClose = function (iterator) {\n\t  var returnMethod = iterator['return'];\n\t  if (returnMethod !== undefined) {\n\t    return anObject(returnMethod.call(iterator)).value;\n\t  }\n\t};\n\n\t// call something on iterator step with safe closing on error\n\tvar callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {\n\t  try {\n\t    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n\t  // 7.4.6 IteratorClose(iterator, completion)\n\t  } catch (error) {\n\t    iteratorClose(iterator);\n\t    throw error;\n\t  }\n\t};\n\n\tvar ITERATOR$2 = wellKnownSymbol('iterator');\n\tvar ArrayPrototype$1 = Array.prototype;\n\n\t// check on default Array iterator\n\tvar isArrayIteratorMethod = function (it) {\n\t  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$2] === it);\n\t};\n\n\t'use strict';\n\n\n\n\n\tvar createProperty = function (object, key, value) {\n\t  var propertyKey = toPrimitive(key);\n\t  if (propertyKey in object) { objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value)); }\n\t  else { object[propertyKey] = value; }\n\t};\n\n\tvar TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');\n\tvar test = {};\n\n\ttest[TO_STRING_TAG$1] = 'z';\n\n\tvar toStringTagSupport = String(test) === '[object z]';\n\n\tvar TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');\n\t// ES3 wrong here\n\tvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function (it, key) {\n\t  try {\n\t    return it[key];\n\t  } catch (error) { /* empty */ }\n\t};\n\n\t// getting tag from ES6+ `Object.prototype.toString`\n\tvar classof = toStringTagSupport ? classofRaw : function (it) {\n\t  var O, tag, result;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag\n\t    // builtinTag case\n\t    : CORRECT_ARGUMENTS ? classofRaw(O)\n\t    // ES3 arguments fallback\n\t    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n\t};\n\n\tvar ITERATOR$3 = wellKnownSymbol('iterator');\n\n\tvar getIteratorMethod = function (it) {\n\t  if (it != undefined) { return it[ITERATOR$3]\n\t    || it['@@iterator']\n\t    || iterators[classof(it)]; }\n\t};\n\n\t'use strict';\n\n\n\n\n\n\n\n\n\t// `Array.from` method implementation\n\t// https://tc39.es/ecma262/#sec-array.from\n\tvar arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n\t  var O = toObject(arrayLike);\n\t  var C = typeof this == 'function' ? this : Array;\n\t  var argumentsLength = arguments.length;\n\t  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n\t  var mapping = mapfn !== undefined;\n\t  var iteratorMethod = getIteratorMethod(O);\n\t  var index = 0;\n\t  var length, result, step, iterator, next, value;\n\t  if (mapping) { mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2); }\n\t  // if the target is not iterable or it's an array with the default iterator - use a simple case\n\t  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n\t    iterator = iteratorMethod.call(O);\n\t    next = iterator.next;\n\t    result = new C();\n\t    for (;!(step = next.call(iterator)).done; index++) {\n\t      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n\t      createProperty(result, index, value);\n\t    }\n\t  } else {\n\t    length = toLength(O.length);\n\t    result = new C(length);\n\t    for (;length > index; index++) {\n\t      value = mapping ? mapfn(O[index], index) : O[index];\n\t      createProperty(result, index, value);\n\t    }\n\t  }\n\t  result.length = index;\n\t  return result;\n\t};\n\n\tvar ITERATOR$4 = wellKnownSymbol('iterator');\n\tvar SAFE_CLOSING = false;\n\n\ttry {\n\t  var called = 0;\n\t  var iteratorWithReturn = {\n\t    next: function () {\n\t      return { done: !!called++ };\n\t    },\n\t    'return': function () {\n\t      SAFE_CLOSING = true;\n\t    }\n\t  };\n\t  iteratorWithReturn[ITERATOR$4] = function () {\n\t    return this;\n\t  };\n\t  // eslint-disable-next-line no-throw-literal\n\t  Array.from(iteratorWithReturn, function () { throw 2; });\n\t} catch (error) { /* empty */ }\n\n\tvar checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {\n\t  if (!SKIP_CLOSING && !SAFE_CLOSING) { return false; }\n\t  var ITERATION_SUPPORT = false;\n\t  try {\n\t    var object = {};\n\t    object[ITERATOR$4] = function () {\n\t      return {\n\t        next: function () {\n\t          return { done: ITERATION_SUPPORT = true };\n\t        }\n\t      };\n\t    };\n\t    exec(object);\n\t  } catch (error) { /* empty */ }\n\t  return ITERATION_SUPPORT;\n\t};\n\n\tvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n\t  Array.from(iterable);\n\t});\n\n\t// `Array.from` method\n\t// https://tc39.es/ecma262/#sec-array.from\n\t_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {\n\t  from: arrayFrom\n\t});\n\n\tvar es_array_from = {\n\n\t};\n\n\tvar from_1 = path.Array.from;\n\n\tvar from_1$1 = from_1;\n\n\t'use strict';\n\n\tvar $findIndex = arrayIteration.findIndex;\n\n\n\n\tvar FIND_INDEX = 'findIndex';\n\tvar SKIPS_HOLES$1 = true;\n\n\tvar USES_TO_LENGTH$2 = arrayMethodUsesToLength(FIND_INDEX);\n\n\t// Shouldn't skip holes\n\tif (FIND_INDEX in []) { Array(1)[FIND_INDEX](function () { SKIPS_HOLES$1 = false; }); }\n\n\t// `Array.prototype.findIndex` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.findindex\n\t_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$2 }, {\n\t  findIndex: function findIndex(callbackfn /* , that = undefined */) {\n\t    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables(FIND_INDEX);\n\n\tvar es_array_findIndex = {\n\n\t};\n\n\tvar findIndex = entryUnbind('Array', 'findIndex');\n\n\tvar findIndex$1 = findIndex;\n\n\tvar base64 = createCommonjsModule(function (module, exports) {\n\t(function() {\n\n\t    /**\n\t     * version: 0.3.0\n\t     * git://github.com/davidchambers/Base64.js.git\n\t     */\n\n\t    var object = 'object' != 'undefined' ? exports : this; // #8: web workers\n\t    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n\t    function InvalidCharacterError(message) {\n\t        this.message = message;\n\t    }\n\n\t    InvalidCharacterError.prototype = new Error;\n\t    InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n\t    // encoder\n\t    // [https://gist.github.com/999166] by [https://github.com/nignag]\n\t    object.btoa || (\n\t        object.btoa = function(input) {\n\t            var str = String(input);\n\t            for (\n\t                // initialize result and counter\n\t                var block, charCode, idx = 0, map = chars, output = '';\n\t                // if the next str index does not exist:\n\t                //   change the mapping table to \"=\"\n\t                //   check if d has no fractional digits\n\t                str.charAt(idx | 0) || (map = '=', idx % 1);\n\t                // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n\t                output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n\t            ) {\n\t                charCode = str.charCodeAt(idx += 3 / 4);\n\t                if (charCode > 0xFF) {\n\t                    throw new InvalidCharacterError('\\'btoa\\' failed: The string to be encoded contains characters outside of the Latin1 range.');\n\t                }\n\t                block = block << 8 | charCode;\n\t            }\n\t            return output;\n\t        });\n\n\t    // decoder\n\t    // [https://gist.github.com/1020396] by [https://github.com/atk]\n\t    object.atob || (\n\t        object.atob = function(input) {\n\t            var str = String(input).replace(/=+$/, '');\n\t            if (str.length % 4 == 1) {\n\t                throw new InvalidCharacterError('\\'atob\\' failed: The string to be decoded is not correctly encoded.');\n\t            }\n\t            for (\n\t                // initialize result and counters\n\t                var bc = 0, bs, buffer, idx = 0, output = '';\n\t                // get next character\n\t                // eslint-disable-next-line no-cond-assign\n\t                buffer = str.charAt(idx++);\n\t                // character found in table? initialize bit storage and add its ascii value;\n\t                ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n\t                // and if not first of each 4 characters,\n\t                // convert the first 8 bits to one ascii character\n\t                bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n\t            ) {\n\t                // try to find character in table (0-63, not found => -1)\n\t                buffer = chars.indexOf(buffer);\n\t            }\n\t            return output;\n\t        });\n\n\t}());\n\t});\n\n\t// `Number.isNaN` method\n\t// https://tc39.es/ecma262/#sec-number.isnan\n\t_export({ target: 'Number', stat: true }, {\n\t  isNaN: function isNaN(number) {\n\t    // eslint-disable-next-line no-self-compare\n\t    return number != number;\n\t  }\n\t});\n\n\tvar es_number_isNan = {\n\n\t};\n\n\tvar isNan = path.Number.isNaN;\n\n\tvar isNan$1 = isNan;\n\n\tvar globalIsFinite = global_1.isFinite;\n\n\t// `Number.isFinite` method\n\t// https://tc39.es/ecma262/#sec-number.isfinite\n\tvar numberIsFinite = Number.isFinite || function isFinite(it) {\n\t  return typeof it == 'number' && globalIsFinite(it);\n\t};\n\n\t// `Number.isFinite` method\n\t// https://tc39.es/ecma262/#sec-number.isfinite\n\t_export({ target: 'Number', stat: true }, { isFinite: numberIsFinite });\n\n\tvar es_number_isFinite = {\n\n\t};\n\n\tvar _isFinite = path.Number.isFinite;\n\n\tvar _isFinite$1 = _isFinite;\n\n\tvar MATCH = wellKnownSymbol('match');\n\n\t// `IsRegExp` abstract operation\n\t// https://tc39.es/ecma262/#sec-isregexp\n\tvar isRegexp = function (it) {\n\t  var isRegExp;\n\t  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');\n\t};\n\n\tvar notARegexp = function (it) {\n\t  if (isRegexp(it)) {\n\t    throw TypeError(\"The method doesn't accept regular expressions\");\n\t  } return it;\n\t};\n\n\tvar MATCH$1 = wellKnownSymbol('match');\n\n\tvar correctIsRegexpLogic = function (METHOD_NAME) {\n\t  var regexp = /./;\n\t  try {\n\t    '/./'[METHOD_NAME](regexp);\n\t  } catch (error1) {\n\t    try {\n\t      regexp[MATCH$1] = false;\n\t      return '/./'[METHOD_NAME](regexp);\n\t    } catch (error2) { /* empty */ }\n\t  } return false;\n\t};\n\n\t'use strict';\n\n\n\n\n\n\t// `String.prototype.includes` method\n\t// https://tc39.es/ecma262/#sec-string.prototype.includes\n\t_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {\n\t  includes: function includes(searchString /* , position = 0 */) {\n\t    return !!~String(requireObjectCoercible(this))\n\t      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\tvar es_string_includes = {\n\n\t};\n\n\tvar includes$2 = entryUnbind('String', 'includes');\n\n\tvar includes$3 = includes$2;\n\n\t'use strict';\n\n\tvar getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;\n\n\n\n\n\n\n\tvar nativeStartsWith = ''.startsWith;\n\tvar min$2 = Math.min;\n\n\tvar CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('startsWith');\n\t// https://github.com/zloirock/core-js/pull/702\n\tvar MDN_POLYFILL_BUG = !isPure && !CORRECT_IS_REGEXP_LOGIC && !!function () {\n\t  var descriptor = getOwnPropertyDescriptor$2(String.prototype, 'startsWith');\n\t  return descriptor && !descriptor.writable;\n\t}();\n\n\t// `String.prototype.startsWith` method\n\t// https://tc39.es/ecma262/#sec-string.prototype.startswith\n\t_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {\n\t  startsWith: function startsWith(searchString /* , position = 0 */) {\n\t    var that = String(requireObjectCoercible(this));\n\t    notARegexp(searchString);\n\t    var index = toLength(min$2(arguments.length > 1 ? arguments[1] : undefined, that.length));\n\t    var search = String(searchString);\n\t    return nativeStartsWith\n\t      ? nativeStartsWith.call(that, search, index)\n\t      : that.slice(index, index + search.length) === search;\n\t  }\n\t});\n\n\tvar es_string_startsWith = {\n\n\t};\n\n\tvar startsWith = entryUnbind('String', 'startsWith');\n\n\tvar startsWith$1 = startsWith;\n\n\t(function() {\n\n\t    if (typeof Uint8Array !== 'undefined' || typeof window === 'undefined') {\n\t        return;\n\t    }\n\n\t    function subarray(start, end) {\n\t        return this.slice(start, end);\n\t    }\n\n\t    function set_(array, offset) {\n\n\t        if (arguments.length < 2) {\n\t            offset = 0;\n\t        }\n\t        for (var i = 0, n = array.length; i < n; ++i, ++offset) {\n\t            this[offset] = array[i] & 0xFF;\n\t        }\n\t    }\n\n\t    // we need typed arrays\n\t    function TypedArray(arg1) {\n\n\t        var result;\n\t        if (typeof arg1 === 'number') {\n\t            result = new Array(arg1);\n\t            for (var i = 0; i < arg1; ++i) {\n\t                result[i] = 0;\n\t            }\n\t        } else {\n\t            result = arg1.slice(0);\n\t        }\n\t        result.subarray = subarray;\n\t        result.buffer = result;\n\t        result.byteLength = result.length;\n\t        result.set = set_;\n\t        if (typeof arg1 === 'object' && arg1.buffer) {\n\t            result.buffer = arg1.buffer;\n\t        }\n\n\t        return result;\n\t    }\n\n\t    window.Uint8Array = TypedArray;\n\t    window.Uint32Array = TypedArray;\n\t    window.Int32Array = TypedArray;\n\t})();\n\n\tvar props = {\n\t    x: 'x',\n\t    y: 'y',\n\t    width: 'w',\n\t    height: 'h',\n\t    minimum: 's',\n\t    maximum: 'l',\n\t    diagonal: 'd'\n\t};\n\tvar propsList = Object.keys(props).map(function (key) { return props[key]; }).join('');\n\tvar numberPattern = '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?';\n\tvar findSpacesRegex = /\\s/g;\n\tvar parseExpressionRegExp = new RegExp((\"^(\" + numberPattern + \"\\\\*)?([\" + propsList + \"])(/\" + numberPattern + \")?([-+]{1,2}\" + numberPattern + \")?$\"), 'g');\n\n\tfunction throwInvalid(expression) {\n\t    throw new Error((\"Invalid calc() expression: \" + expression));\n\t}\n\n\tfunction evalCalcExpression(expression, bbox) {\n\t    var match = parseExpressionRegExp.exec(expression.replace(findSpacesRegex, ''));\n\t    if (!match) { throwInvalid(expression); }\n\t    parseExpressionRegExp.lastIndex = 0; // reset regex results for the next run\n\t    var multiply = match[1];\n\t    var property = match[2];\n\t    var divide = match[3];\n\t    var add = match[4];\n\t    var x = bbox.x;\n\t    var y = bbox.y;\n\t    var width = bbox.width;\n\t    var height = bbox.height;\n\t    var value = 0;\n\t    switch (property) {\n\t        case props.width: {\n\t            value = width;\n\t            break;\n\t        }\n\t        case props.height: {\n\t            value = height;\n\t            break;\n\t        }\n\t        case props.x: {\n\t            value = x;\n\t            break;\n\t        }\n\t        case props.y: {\n\t            value = y;\n\t            break;\n\t        }\n\t        case props.minimum: {\n\t            value = Math.min(height, width);\n\t            break;\n\t        }\n\t        case props.maximum: {\n\t            value = Math.max(height, width);\n\t            break;\n\t        }\n\t        case props.diagonal: {\n\t            value = Math.sqrt((height * height) + (width * width));\n\t            break;\n\t        }\n\t    }\n\t    if (multiply) {\n\t        // e.g \"2*\"\n\t        value *= parseFloat(multiply);\n\t    }\n\t    if (divide) {\n\t        // e.g \"/2\"\n\t        value /= parseFloat(divide.slice(1));\n\t    }\n\t    if (add) {\n\t        value += evalAddExpression(add);\n\t    }\n\t    return value;\n\t}\n\n\tfunction evalAddExpression(addExpression) {\n\t    if (!addExpression) { return 0; }\n\t    var sign = addExpression[0];\n\t    switch (sign) {\n\t        case '+': {\n\t            return parseFloat(addExpression.substr(1));\n\t        }\n\t        case '-': {\n\t            return -parseFloat(addExpression.substr(1));\n\t        }\n\t    }\n\t    return parseFloat(addExpression);\n\t}\n\n\tfunction isCalcAttribute(value) {\n\t    return typeof value === 'string' && value.includes('calc');\n\t}\n\n\tvar calcStart = 'calc(';\n\tvar calcStartOffset = calcStart.length;\n\n\tfunction evalCalcAttribute(attributeValue, refBBox) {\n\t    var value = attributeValue;\n\t    var startSearchIndex = 0;\n\t    do {\n\t        var calcIndex = value.indexOf(calcStart, startSearchIndex);\n\t        if (calcIndex === -1) { return value; }\n\t        var calcEndIndex = calcIndex + calcStartOffset;\n\t        var brackets = 1;\n\t        findClosingBracket: do {\n\t            switch (value[calcEndIndex]) {\n\t                case '(': {\n\t                    brackets++;\n\t                    break;\n\t                }\n\t                case ')': {\n\t                    brackets--;\n\t                    if (brackets === 0) { break findClosingBracket; }\n\t                    break;\n\t                }\n\t                case undefined: {\n\t                    // Could not find the closing bracket.\n\t                    throwInvalid(value);\n\t                }\n\t            }\n\t            calcEndIndex++;\n\t        } while (true);\n\t        // Get the calc() expression without nested calcs (recursion)\n\t        var expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);\n\t        if (isCalcAttribute(expression)) {\n\t            expression = evalCalcAttribute(expression, refBBox);\n\t        }\n\t        // Eval the calc() expression without nested calcs.\n\t        var calcValue = String(evalCalcExpression(expression, refBBox));\n\t        // Replace the calc() expression and continue search\n\t        value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);\n\t        startSearchIndex = calcIndex + calcValue.length;\n\t    } while (true);\n\t}\n\n\t// Declare shorthands to the most used math functions.\n\tvar round = Math.round;\n\tvar floor$1 = Math.floor;\n\tvar PI = Math.PI;\n\n\tvar scale = {\n\n\t    // Return the `value` from the `domain` interval scaled to the `range` interval.\n\t    linear: function(domain, range, value) {\n\n\t        var domainSpan = domain[1] - domain[0];\n\t        var rangeSpan = range[1] - range[0];\n\t        return (((value - domain[0]) / domainSpan) * rangeSpan + range[0]) || 0;\n\t    }\n\t};\n\n\tvar normalizeAngle = function(angle) {\n\n\t    return (angle % 360) + (angle < 0 ? 360 : 0);\n\t};\n\n\tvar snapToGrid = function(value, gridSize) {\n\n\t    return gridSize * round(value / gridSize);\n\t};\n\n\tvar toDeg = function(rad) {\n\n\t    return (180 * rad / PI) % 360;\n\t};\n\n\tvar toRad = function(deg, over360) {\n\n\t    over360 = over360 || false;\n\t    deg = over360 ? deg : (deg % 360);\n\t    return deg * PI / 180;\n\t};\n\n\t// Return a random integer from the interval [min,max], inclusive.\n\tvar random = function(min, max) {\n\n\t    if (max === undefined) {\n\t        // use first argument as max, min is 0\n\t        max = (min === undefined) ? 1 : min;\n\t        min = 0;\n\n\t    } else if (max < min) {\n\t        // switch max and min\n\t        var temp = min;\n\t        min = max;\n\t        max = temp;\n\t    }\n\n\t    return floor$1((Math.random() * (max - min + 1)) + min);\n\t};\n\n\t// @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n\n\tvar cos = Math.cos;\n\tvar sin = Math.sin;\n\tvar atan2 = Math.atan2;\n\n\tvar bearing = function(p, q) {\n\n\t    var lat1 = toRad(p.y);\n\t    var lat2 = toRad(q.y);\n\t    var lon1 = p.x;\n\t    var lon2 = q.x;\n\t    var dLon = toRad(lon2 - lon1);\n\t    var y = sin(dLon) * cos(lat2);\n\t    var x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);\n\t    var brng = toDeg(atan2(y, x));\n\n\t    var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n\n\t    var index = brng - 22.5;\n\t    if (index < 0)\n\t        { index += 360; }\n\t    index = parseInt(index / 45);\n\n\t    return bearings[index];\n\t};\n\n\t// @return {integer} length without sqrt\n\t// @note for applications where the exact length is not necessary (e.g. compare only)\n\tvar squaredLength = function(start, end) {\n\n\t    var x0 = start.x;\n\t    var y0 = start.y;\n\t    var x1 = end.x;\n\t    var y1 = end.y;\n\t    return (x0 -= x1) * x0 + (y0 -= y1) * y0;\n\t};\n\n\tvar length = function(start, end) {\n\t    return Math.sqrt(squaredLength(start, end));\n\t};\n\n\tvar types = {\n\t    Point: 1,\n\t    Line: 2,\n\t    Ellipse: 3,\n\t    Rect: 4,\n\t    Polyline: 5,\n\t    Polygon: 6,\n\t    Curve: 7,\n\t    Path: 8\n\t};\n\n\t/*\n\t    Point is the most basic object consisting of x/y coordinate.\n\n\t    Possible instantiations are:\n\t    * `Point(10, 20)`\n\t    * `new Point(10, 20)`\n\t    * `Point('10 20')`\n\t    * `Point(Point(10, 20))`\n\t*/\n\n\tvar abs = Math.abs;\n\tvar cos$1 = Math.cos;\n\tvar sin$1 = Math.sin;\n\tvar sqrt = Math.sqrt;\n\tvar min$3 = Math.min;\n\tvar max$1 = Math.max;\n\tvar atan2$1 = Math.atan2;\n\tvar round$1 = Math.round;\n\tvar pow = Math.pow;\n\tvar PI$1 = Math.PI;\n\n\tvar Point = function(x, y) {\n\n\t    if (!(this instanceof Point)) {\n\t        return new Point(x, y);\n\t    }\n\n\t    if (typeof x === 'string') {\n\t        var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n\t        x = parseFloat(xy[0]);\n\t        y = parseFloat(xy[1]);\n\n\t    } else if (Object(x) === x) {\n\t        y = x.y;\n\t        x = x.x;\n\t    }\n\n\t    this.x = x === undefined ? 0 : x;\n\t    this.y = y === undefined ? 0 : y;\n\t};\n\n\t// Alternative constructor, from polar coordinates.\n\t// @param {number} Distance.\n\t// @param {number} Angle in radians.\n\t// @param {point} [optional] Origin.\n\tPoint.fromPolar = function(distance, angle, origin) {\n\n\t    origin = new Point(origin);\n\t    var x = abs(distance * cos$1(angle));\n\t    var y = abs(distance * sin$1(angle));\n\t    var deg = normalizeAngle(toDeg(angle));\n\n\t    if (deg < 90) {\n\t        y = -y;\n\n\t    } else if (deg < 180) {\n\t        x = -x;\n\t        y = -y;\n\n\t    } else if (deg < 270) {\n\t        x = -x;\n\t    }\n\n\t    return new Point(origin.x + x, origin.y + y);\n\t};\n\n\t// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\n\tPoint.random = function(x1, x2, y1, y2) {\n\n\t    return new Point(random(x1, x2), random(y1, y2));\n\t};\n\n\tPoint.prototype = {\n\n\t    type: types.Point,\n\n\t    chooseClosest: function(points) {\n\n\t        var n = points.length;\n\t        if (n === 1) { return new Point(points[0]); }\n\t        var closest = null;\n\t        var minSqrDistance = Infinity;\n\t        for (var i = 0; i < n; i++) {\n\t            var p = new Point(points[i]);\n\t            var sqrDistance = this.squaredDistance(p);\n\t            if (sqrDistance < minSqrDistance) {\n\t                closest = p;\n\t                minSqrDistance = sqrDistance;\n\t            }\n\t        }\n\t        return closest;\n\t    },\n\n\t    // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n\t    // otherwise return point itself.\n\t    // (see Squeak Smalltalk, Point>>adhereTo:)\n\t    adhereToRect: function(r) {\n\n\t        if (r.containsPoint(this)) {\n\t            return this;\n\t        }\n\n\t        this.x = min$3(max$1(this.x, r.x), r.x + r.width);\n\t        this.y = min$3(max$1(this.y, r.y), r.y + r.height);\n\t        return this;\n\t    },\n\n\t    // Compute the angle between vector from me to p1 and the vector from me to p2.\n\t    // ordering of points p1 and p2 is important!\n\t    // theta function's angle convention:\n\t    // returns angles between 0 and 180 when the angle is counterclockwise\n\t    // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n\t    // returns NaN if any of the points p1, p2 is coincident with this point\n\t    angleBetween: function(p1, p2) {\n\n\t        var angleBetween = (this.equals(p1) || this.equals(p2)) ? NaN : (this.theta(p2) - this.theta(p1));\n\n\t        if (angleBetween < 0) {\n\t            angleBetween += 360; // correction to keep angleBetween between 0 and 360\n\t        }\n\n\t        return angleBetween;\n\t    },\n\n\t    // Return the bearing between me and the given point.\n\t    bearing: function(point) {\n\t        return bearing(this, point);\n\t    },\n\n\t    // Returns change in angle from my previous position (-dx, -dy) to my new position\n\t    // relative to ref point.\n\t    changeInAngle: function(dx, dy, ref) {\n\n\t        // Revert the translation and measure the change in angle around x-axis.\n\t        return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n\t    },\n\n\t    clone: function() {\n\n\t        return new Point(this);\n\t    },\n\n\t    // Returns the cross product of this point relative to two other points\n\t    // this point is the common point\n\t    // point p1 lies on the first vector, point p2 lies on the second vector\n\t    // watch out for the ordering of points p1 and p2!\n\t    // positive result indicates a clockwise (\"right\") turn from first to second vector\n\t    // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n\t    // zero indicates that the first and second vector are collinear\n\t    // note that the above directions are reversed from the usual answer on the Internet\n\t    // that is because we are in a left-handed coord system (because the y-axis points downward)\n\t    cross: function(p1, p2) {\n\n\t        return (p1 && p2) ? (((p2.x - this.x) * (p1.y - this.y)) - ((p2.y - this.y) * (p1.x - this.x))) : NaN;\n\t    },\n\n\t    difference: function(dx, dy) {\n\n\t        if ((Object(dx) === dx)) {\n\t            dy = dx.y;\n\t            dx = dx.x;\n\t        }\n\n\t        return new Point(this.x - (dx || 0), this.y - (dy || 0));\n\t    },\n\n\t    // Returns distance between me and point `p`.\n\t    distance: function(p) {\n\t        return length(this, p);\n\t    },\n\n\t    // Returns the dot product of this point with given other point\n\t    dot: function(p) {\n\n\t        return p ? (this.x * p.x + this.y * p.y) : NaN;\n\t    },\n\n\t    equals: function(p) {\n\n\t        return !!p &&\n\t            this.x === p.x &&\n\t            this.y === p.y;\n\t    },\n\n\t    // Linear interpolation\n\t    lerp: function(p, t) {\n\n\t        var x = this.x;\n\t        var y = this.y;\n\t        return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n\t    },\n\n\t    magnitude: function() {\n\n\t        return sqrt((this.x * this.x) + (this.y * this.y)) || 0.01;\n\t    },\n\n\t    // Returns a manhattan (taxi-cab) distance between me and point `p`.\n\t    manhattanDistance: function(p) {\n\n\t        return abs(p.x - this.x) + abs(p.y - this.y);\n\t    },\n\n\t    // Move point on line starting from ref ending at me by\n\t    // distance distance.\n\t    move: function(ref, distance) {\n\n\t        var theta = toRad((new Point(ref)).theta(this));\n\t        var offset = this.offset(cos$1(theta) * distance, -sin$1(theta) * distance);\n\t        return offset;\n\t    },\n\n\t    // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n\t    normalize: function(length) {\n\n\t        var scale = (length || 1) / this.magnitude();\n\t        return this.scale(scale, scale);\n\t    },\n\n\t    // Offset me by the specified amount.\n\t    offset: function(dx, dy) {\n\n\t        if ((Object(dx) === dx)) {\n\t            dy = dx.y;\n\t            dx = dx.x;\n\t        }\n\n\t        this.x += dx || 0;\n\t        this.y += dy || 0;\n\t        return this;\n\t    },\n\n\t    // Returns a point that is the reflection of me with\n\t    // the center of inversion in ref point.\n\t    reflection: function(ref) {\n\n\t        return (new Point(ref)).move(this, this.distance(ref));\n\t    },\n\n\t    // Rotate point by angle around origin.\n\t    // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n\t    rotate: function(origin, angle) {\n\n\t        if (angle === 0) { return this; }\n\n\t        origin = origin || new Point(0, 0);\n\n\t        angle = toRad(normalizeAngle(-angle));\n\t        var cosAngle = cos$1(angle);\n\t        var sinAngle = sin$1(angle);\n\n\t        var x = (cosAngle * (this.x - origin.x)) - (sinAngle * (this.y - origin.y)) + origin.x;\n\t        var y = (sinAngle * (this.x - origin.x)) + (cosAngle * (this.y - origin.y)) + origin.y;\n\n\t        this.x = x;\n\t        this.y = y;\n\t        return this;\n\t    },\n\n\t    round: function(precision) {\n\n\t        var f = 1; // case 0\n\t        if (precision) {\n\t            switch (precision) {\n\t                case 1: f = 10; break;\n\t                case 2: f = 100; break;\n\t                case 3: f = 1000; break;\n\t                default: f = pow(10, precision); break;\n\t            }\n\t        }\n\n\t        this.x = round$1(this.x * f) / f;\n\t        this.y = round$1(this.y * f) / f;\n\t        return this;\n\t    },\n\n\t    // Scale point with origin.\n\t    scale: function(sx, sy, origin) {\n\n\t        origin = (origin && new Point(origin)) || new Point(0, 0);\n\t        this.x = origin.x + sx * (this.x - origin.x);\n\t        this.y = origin.y + sy * (this.y - origin.y);\n\t        return this;\n\t    },\n\n\t    snapToGrid: function(gx, gy) {\n\n\t        this.x = snapToGrid(this.x, gx);\n\t        this.y = snapToGrid(this.y, gy || gx);\n\t        return this;\n\t    },\n\n\t    squaredDistance: function(p) {\n\t        return squaredLength(this, p);\n\t    },\n\n\t    // Compute the angle between me and `p` and the x axis.\n\t    // (cartesian-to-polar coordinates conversion)\n\t    // Return theta angle in degrees.\n\t    theta: function(p) {\n\n\t        p = new Point(p);\n\n\t        // Invert the y-axis.\n\t        var y = -(p.y - this.y);\n\t        var x = p.x - this.x;\n\t        var rad = atan2$1(y, x); // defined for all 0 corner cases\n\n\t        // Correction for III. and IV. quadrant.\n\t        if (rad < 0) {\n\t            rad = 2 * PI$1 + rad;\n\t        }\n\n\t        return 180 * rad / PI$1;\n\t    },\n\n\t    toJSON: function() {\n\n\t        return { x: this.x, y: this.y };\n\t    },\n\n\t    // Converts rectangular to polar coordinates.\n\t    // An origin can be specified, otherwise it's 0@0.\n\t    toPolar: function(o) {\n\n\t        o = (o && new Point(o)) || new Point(0, 0);\n\t        var x = this.x;\n\t        var y = this.y;\n\t        this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n\t        this.y = toRad(o.theta(new Point(x, y)));\n\t        return this;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.x + '@' + this.y;\n\t    },\n\n\t    serialize: function() {\n\n\t        return this.x + ',' + this.y;\n\t    },\n\n\t    update: function(x, y) {\n\n\t        if ((Object(x) === x)) {\n\t            y = x.y;\n\t            x = x.x;\n\t        }\n\n\t        this.x = x || 0;\n\t        this.y = y || 0;\n\t        return this;\n\t    },\n\n\t    // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n\t    // Returns NaN if p is at 0,0.\n\t    vectorAngle: function(p) {\n\n\t        var zero = new Point(0, 0);\n\t        return zero.angleBetween(this, p);\n\t    }\n\t};\n\n\tPoint.prototype.translate = Point.prototype.offset;\n\n\t// For backwards compatibility:\n\tvar point = Point;\n\n\tvar max$2 = Math.max;\n\tvar min$4 = Math.min;\n\n\tvar Line = function(p1, p2) {\n\n\t    if (!(this instanceof Line)) {\n\t        return new Line(p1, p2);\n\t    }\n\n\t    if (p1 instanceof Line) {\n\t        return new Line(p1.start, p1.end);\n\t    }\n\n\t    this.start = new Point(p1);\n\t    this.end = new Point(p2);\n\t};\n\n\tLine.prototype = {\n\n\t    type: types.Line,\n\n\t    // @returns the angle of incline of the line.\n\t    angle: function() {\n\n\t        var horizontalPoint = new Point(this.start.x + 1, this.start.y);\n\t        return this.start.angleBetween(this.end, horizontalPoint);\n\t    },\n\n\t    bbox: function() {\n\n\t        var left = min$4(this.start.x, this.end.x);\n\t        var top = min$4(this.start.y, this.end.y);\n\t        var right = max$2(this.start.x, this.end.x);\n\t        var bottom = max$2(this.start.y, this.end.y);\n\n\t        return new Rect(left, top, (right - left), (bottom - top));\n\t    },\n\n\t    // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n\t    // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n\t    bearing: function() {\n\t        return bearing(this.start, this.end);\n\t    },\n\n\t    clone: function() {\n\n\t        return new Line(this.start, this.end);\n\t    },\n\n\t    // @return {point} the closest point on the line to point `p`\n\t    closestPoint: function(p) {\n\n\t        return this.pointAt(this.closestPointNormalizedLength(p));\n\t    },\n\n\t    closestPointLength: function(p) {\n\n\t        return this.closestPointNormalizedLength(p) * this.length();\n\t    },\n\n\t    // @return {number} the normalized length of the closest point on the line to point `p`\n\t    closestPointNormalizedLength: function(p) {\n\n\t        var product = this.vector().dot((new Line(this.start, p)).vector());\n\t        var cpNormalizedLength = min$4(1, max$2(0, product / this.squaredLength()));\n\n\t        // cpNormalizedLength returns `NaN` if this line has zero length\n\t        // we can work with that - if `NaN`, return 0\n\t        if (cpNormalizedLength !== cpNormalizedLength) { return 0; } // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n\t        // (`NaN` is the only value that is not equal to itself)\n\n\t        return cpNormalizedLength;\n\t    },\n\n\t    closestPointTangent: function(p) {\n\n\t        return this.tangentAt(this.closestPointNormalizedLength(p));\n\t    },\n\n\t    // Returns `true` if the point lies on the line.\n\t    containsPoint: function(p) {\n\n\t        var start = this.start;\n\t        var end = this.end;\n\n\t        if (start.cross(p, end) !== 0) { return false; }\n\t        // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n\t        var length = this.length();\n\t        if ((new Line(start, p)).length() > length) { return false; }\n\t        if ((new Line(p, end)).length() > length) { return false; }\n\t        // else: `p` lies between start and end of the line\n\n\t        return true;\n\t    },\n\n\t    // Divides the line into two at requested `ratio` between 0 and 1.\n\t    divideAt: function(ratio) {\n\n\t        var dividerPoint = this.pointAt(ratio);\n\n\t        // return array with two lines\n\t        return [\n\t            new Line(this.start, dividerPoint),\n\t            new Line(dividerPoint, this.end)\n\t        ];\n\t    },\n\n\t    // Divides the line into two at requested `length`.\n\t    divideAtLength: function(length) {\n\n\t        var dividerPoint = this.pointAtLength(length);\n\n\t        // return array with two new lines\n\t        return [\n\t            new Line(this.start, dividerPoint),\n\t            new Line(dividerPoint, this.end)\n\t        ];\n\t    },\n\n\t    equals: function(l) {\n\n\t        return !!l &&\n\t            this.start.x === l.start.x &&\n\t            this.start.y === l.start.y &&\n\t            this.end.x === l.end.x &&\n\t            this.end.y === l.end.y;\n\t    },\n\n\t    // @return {point} Point where I'm intersecting a line.\n\t    // @return [point] Points where I'm intersecting a rectangle.\n\t    // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n\t    intersect: function(shape, opt) {\n\n\t        if (shape && shape.intersectionWithLine) {\n\t            var intersection = shape.intersectionWithLine(this, opt);\n\n\t            // Backwards compatibility\n\t            if (intersection && (shape instanceof Line)) {\n\t                intersection = intersection[0];\n\t            }\n\n\t            return intersection;\n\t        }\n\n\t        return null;\n\t    },\n\n\t    intersectionWithLine: function(line) {\n\n\t        var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n\t        var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n\t        var det = (pt1Dir.x * pt2Dir.y) - (pt1Dir.y * pt2Dir.x);\n\t        var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n\t        var alpha = (deltaPt.x * pt2Dir.y) - (deltaPt.y * pt2Dir.x);\n\t        var beta = (deltaPt.x * pt1Dir.y) - (deltaPt.y * pt1Dir.x);\n\n\t        if (det === 0 || alpha * det < 0 || beta * det < 0) {\n\t            // No intersection found.\n\t            return null;\n\t        }\n\n\t        if (det > 0) {\n\t            if (alpha > det || beta > det) {\n\t                return null;\n\t            }\n\n\t        } else {\n\t            if (alpha < det || beta < det) {\n\t                return null;\n\t            }\n\t        }\n\n\t        return [new Point(\n\t            this.start.x + (alpha * pt1Dir.x / det),\n\t            this.start.y + (alpha * pt1Dir.y / det)\n\t        )];\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        return !this.start.equals(this.end);\n\t    },\n\n\t    // @return {double} length of the line\n\t    length: function() {\n\t        return length(this.start, this.end);\n\t    },\n\n\t    // @return {point} my midpoint\n\t    midpoint: function() {\n\n\t        return new Point(\n\t            (this.start.x + this.end.x) / 2,\n\t            (this.start.y + this.end.y) / 2\n\t        );\n\t    },\n\n\t    parallel: function(distance) {\n\t        var l = this.clone();\n\t        if (!this.isDifferentiable()) { return l; }\n\t        var start = l.start;\n\t        var end = l.end;\n\t        var eRef = start.clone().rotate(end, 270);\n\t        var sRef = end.clone().rotate(start, 90);\n\t        start.move(sRef, distance);\n\t        end.move(eRef, distance);\n\t        return l;\n\t    },\n\n\t    // @return {point} my point at 't' <0,1>\n\t    pointAt: function(t) {\n\n\t        var start = this.start;\n\t        var end = this.end;\n\n\t        if (t <= 0) { return start.clone(); }\n\t        if (t >= 1) { return end.clone(); }\n\n\t        return start.lerp(end, t);\n\t    },\n\n\t    pointAtLength: function(length) {\n\n\t        var start = this.start;\n\t        var end = this.end;\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        var lineLength = this.length();\n\t        if (length >= lineLength) { return (fromStart ? end.clone() : start.clone()); }\n\n\t        return this.pointAt((fromStart ? (length) : (lineLength - length)) / lineLength);\n\t    },\n\n\t    // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n\t    pointOffset: function(p) {\n\n\t        // Find the sign of the determinant of vectors (start,end), where p is the query point.\n\t        p = new Point(p);\n\t        var start = this.start;\n\t        var end = this.end;\n\t        var determinant = ((end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x));\n\n\t        return determinant / this.length();\n\t    },\n\n\t    rotate: function(origin, angle) {\n\n\t        this.start.rotate(origin, angle);\n\t        this.end.rotate(origin, angle);\n\t        return this;\n\t    },\n\n\t    round: function(precision) {\n\n\t        this.start.round(precision);\n\t        this.end.round(precision);\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        this.start.scale(sx, sy, origin);\n\t        this.end.scale(sx, sy, origin);\n\t        return this;\n\t    },\n\n\t    // @return {number} scale the line so that it has the requested length\n\t    setLength: function(length) {\n\n\t        var currentLength = this.length();\n\t        if (!currentLength) { return this; }\n\n\t        var scaleFactor = length / currentLength;\n\t        return this.scale(scaleFactor, scaleFactor, this.start);\n\t    },\n\n\t    // @return {integer} length without sqrt\n\t    // @note for applications where the exact length is not necessary (e.g. compare only)\n\t    squaredLength: function() {\n\t        return squaredLength(this.start, this.end);\n\t    },\n\n\t    tangentAt: function(t) {\n\n\t        if (!this.isDifferentiable()) { return null; }\n\n\t        var start = this.start;\n\t        var end = this.end;\n\n\t        var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n\t        var tangentLine = new Line(start, end);\n\t        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n\t        return tangentLine;\n\t    },\n\n\t    tangentAtLength: function(length) {\n\n\t        if (!this.isDifferentiable()) { return null; }\n\n\t        var start = this.start;\n\t        var end = this.end;\n\n\t        var tangentStart = this.pointAtLength(length);\n\n\t        var tangentLine = new Line(start, end);\n\t        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n\t        return tangentLine;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.start.toString() + ' ' + this.end.toString();\n\t    },\n\n\t    serialize: function() {\n\n\t        return this.start.serialize() + ' ' + this.end.serialize();\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        this.start.translate(tx, ty);\n\t        this.end.translate(tx, ty);\n\t        return this;\n\t    },\n\n\t    // @return vector {point} of the line\n\t    vector: function() {\n\n\t        return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n\t    }\n\t};\n\n\t// For backwards compatibility:\n\tLine.prototype.intersection = Line.prototype.intersect;\n\n\n\t// For backwards compatibility:\n\tvar line = Line;\n\n\tvar sqrt$1 = Math.sqrt;\n\tvar round$2 = Math.round;\n\tvar pow$1 = Math.pow;\n\n\tvar Ellipse = function(c, a, b) {\n\n\t    if (!(this instanceof Ellipse)) {\n\t        return new Ellipse(c, a, b);\n\t    }\n\n\t    if (c instanceof Ellipse) {\n\t        return new Ellipse(new Point(c.x, c.y), c.a, c.b);\n\t    }\n\n\t    c = new Point(c);\n\t    this.x = c.x;\n\t    this.y = c.y;\n\t    this.a = a;\n\t    this.b = b;\n\t};\n\n\tEllipse.fromRect = function(rect) {\n\n\t    rect = new Rect(rect);\n\t    return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n\t};\n\n\tEllipse.prototype = {\n\n\t    type: types.Ellipse,\n\n\t    bbox: function() {\n\n\t        return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n\t    },\n\n\t    /**\n\t     * @returns {g.Point}\n\t     */\n\t    center: function() {\n\n\t        return new Point(this.x, this.y);\n\t    },\n\n\t    clone: function() {\n\n\t        return new Ellipse(this);\n\t    },\n\n\t    /**\n\t     * @param {g.Point} p\n\t     * @returns {boolean}\n\t     */\n\t    containsPoint: function(p) {\n\n\t        return this.normalizedDistance(p) <= 1;\n\t    },\n\n\t    equals: function(ellipse) {\n\n\t        return !!ellipse &&\n\t            ellipse.x === this.x &&\n\t            ellipse.y === this.y &&\n\t            ellipse.a === this.a &&\n\t            ellipse.b === this.b;\n\t    },\n\n\t    // inflate by dx and dy\n\t    // @param dx {delta_x} representing additional size to x\n\t    // @param dy {delta_y} representing additional size to y -\n\t    // dy param is not required -> in that case y is sized by dx\n\t    inflate: function(dx, dy) {\n\t        if (dx === undefined) {\n\t            dx = 0;\n\t        }\n\n\t        if (dy === undefined) {\n\t            dy = dx;\n\t        }\n\n\t        this.a += 2 * dx;\n\t        this.b += 2 * dy;\n\n\t        return this;\n\t    },\n\n\t    intersectionWithLine: function(line) {\n\n\t        var intersections = [];\n\t        var a1 = line.start;\n\t        var a2 = line.end;\n\t        var rx = this.a;\n\t        var ry = this.b;\n\t        var dir = line.vector();\n\t        var diff = a1.difference(new Point(this));\n\t        var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n\t        var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n\n\t        var a = dir.dot(mDir);\n\t        var b = dir.dot(mDiff);\n\t        var c = diff.dot(mDiff) - 1.0;\n\t        var d = b * b - a * c;\n\n\t        if (d < 0) {\n\t            return null;\n\t        } else if (d > 0) {\n\t            var root = sqrt$1(d);\n\t            var ta = (-b - root) / a;\n\t            var tb = (-b + root) / a;\n\n\t            if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n\t                // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n\t                return null;\n\t            } else {\n\t                if (0 <= ta && ta <= 1) { intersections.push(a1.lerp(a2, ta)); }\n\t                if (0 <= tb && tb <= 1) { intersections.push(a1.lerp(a2, tb)); }\n\t            }\n\t        } else {\n\t            var t = -b / a;\n\t            if (0 <= t && t <= 1) {\n\t                intersections.push(a1.lerp(a2, t));\n\t            } else {\n\t                // outside\n\t                return null;\n\t            }\n\t        }\n\n\t        return intersections;\n\t    },\n\n\t    // Find point on me where line from my center to\n\t    // point p intersects my boundary.\n\t    // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n\t    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n\t        p = new Point(p);\n\n\t        if (angle) { p.rotate(new Point(this.x, this.y), angle); }\n\n\t        var dx = p.x - this.x;\n\t        var dy = p.y - this.y;\n\t        var result;\n\n\t        if (dx === 0) {\n\t            result = this.bbox().pointNearestToPoint(p);\n\t            if (angle) { return result.rotate(new Point(this.x, this.y), -angle); }\n\t            return result;\n\t        }\n\n\t        var m = dy / dx;\n\t        var mSquared = m * m;\n\t        var aSquared = this.a * this.a;\n\t        var bSquared = this.b * this.b;\n\n\t        var x = sqrt$1(1 / ((1 / aSquared) + (mSquared / bSquared)));\n\t        x = dx < 0 ? -x : x;\n\n\t        var y = m * x;\n\t        result = new Point(this.x + x, this.y + y);\n\n\t        if (angle) { return result.rotate(new Point(this.x, this.y), -angle); }\n\t        return result;\n\t    },\n\n\t    /**\n\t     * @param {g.Point} point\n\t     * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n\t     */\n\t    normalizedDistance: function(point) {\n\n\t        var x0 = point.x;\n\t        var y0 = point.y;\n\t        var a = this.a;\n\t        var b = this.b;\n\t        var x = this.x;\n\t        var y = this.y;\n\n\t        return ((x0 - x) * (x0 - x)) / (a * a) + ((y0 - y) * (y0 - y)) / (b * b);\n\t    },\n\n\t    round: function(precision) {\n\n\t        var f = 1; // case 0\n\t        if (precision) {\n\t            switch (precision) {\n\t                case 1: f = 10; break;\n\t                case 2: f = 100; break;\n\t                case 3: f = 1000; break;\n\t                default: f = pow$1(10, precision); break;\n\t            }\n\t        }\n\n\t        this.x = round$2(this.x * f) / f;\n\t        this.y = round$2(this.y * f) / f;\n\t        this.a = round$2(this.a * f) / f;\n\t        this.b = round$2(this.b * f) / f;\n\t        return this;\n\t    },\n\n\t    /** Compute angle between tangent and x axis\n\t     * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n\t     * @returns {number} angle between tangent and x axis\n\t     */\n\t    tangentTheta: function(p) {\n\n\t        var refPointDelta = 30;\n\t        var x0 = p.x;\n\t        var y0 = p.y;\n\t        var a = this.a;\n\t        var b = this.b;\n\t        var center = this.bbox().center();\n\t        var m = center.x;\n\t        var n = center.y;\n\n\t        var q1 = x0 > center.x + a / 2;\n\t        var q3 = x0 < center.x - a / 2;\n\n\t        var y, x;\n\t        if (q1 || q3) {\n\t            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n\t            x = (a * a / (x0 - m)) - (a * a * (y0 - n) * (y - n)) / (b * b * (x0 - m)) + m;\n\n\t        } else {\n\t            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n\t            y = (b * b / (y0 - n)) - (b * b * (x0 - m) * (x - m)) / (a * a * (y0 - n)) + n;\n\t        }\n\n\t        return (new Point(x, y)).theta(p);\n\n\t    },\n\n\t    toString: function() {\n\n\t        return (new Point(this.x, this.y)).toString() + ' ' + this.a + ' ' + this.b;\n\t    }\n\t};\n\n\t// For backwards compatibility:\n\tvar ellipse = Ellipse;\n\n\tvar abs$1 = Math.abs;\n\tvar cos$2 = Math.cos;\n\tvar sin$2 = Math.sin;\n\tvar min$5 = Math.min;\n\tvar max$3 = Math.max;\n\tvar round$3 = Math.round;\n\tvar pow$2 = Math.pow;\n\n\tvar Rect = function(x, y, w, h) {\n\n\t    if (!(this instanceof Rect)) {\n\t        return new Rect(x, y, w, h);\n\t    }\n\n\t    if ((Object(x) === x)) {\n\t        y = x.y;\n\t        w = x.width;\n\t        h = x.height;\n\t        x = x.x;\n\t    }\n\n\t    this.x = x === undefined ? 0 : x;\n\t    this.y = y === undefined ? 0 : y;\n\t    this.width = w === undefined ? 0 : w;\n\t    this.height = h === undefined ? 0 : h;\n\t};\n\n\tRect.fromEllipse = function(e) {\n\n\t    e = new Ellipse(e);\n\t    return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n\t};\n\n\tRect.fromPointUnion = function() {\n\t    var points = [], len = arguments.length;\n\t    while ( len-- ) points[ len ] = arguments[ len ];\n\n\n\t    if (points.length === 0) { return null; }\n\n\t    var p = new Point();\n\t    var minX, minY, maxX, maxY;\n\t    minX = minY = Infinity;\n\t    maxX = maxY = -Infinity;\n\n\t    for (var i = 0; i < points.length; i++) {\n\t        p.update(points[i]);\n\t        var x = p.x;\n\t        var y = p.y;\n\n\t        if (x < minX) { minX = x; }\n\t        if (x > maxX) { maxX = x; }\n\t        if (y < minY) { minY = y; }\n\t        if (y > maxY) { maxY = y; }\n\t    }\n\n\t    return new Rect(minX, minY, maxX - minX, maxY - minY);\n\t};\n\n\tRect.fromRectUnion = function() {\n\t    var rects = [], len = arguments.length;\n\t    while ( len-- ) rects[ len ] = arguments[ len ];\n\n\n\t    if (rects.length === 0) { return null; }\n\n\t    var r = new Rect();\n\t    var minX, minY, maxX, maxY;\n\t    minX = minY = Infinity;\n\t    maxX = maxY = -Infinity;\n\n\t    for (var i = 0; i < rects.length; i++) {\n\t        r.update(rects[i]);\n\t        var x = r.x;\n\t        var y = r.y;\n\t        var mX = x + r.width;\n\t        var mY = y + r.height;\n\n\t        if (x < minX) { minX = x; }\n\t        if (mX > maxX) { maxX = mX; }\n\t        if (y < minY) { minY = y; }\n\t        if (mY > maxY) { maxY = mY; }\n\t    }\n\n\t    return new Rect(minX, minY, maxX - minX, maxY - minY);\n\t};\n\n\tRect.prototype = {\n\n\t    type: types.Rect,\n\n\t    // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n\t    // @return r {rectangle} representing a bounding box\n\t    bbox: function(angle) {\n\t        return this.clone().rotateAroundCenter(angle);\n\t    },\n\n\t    rotateAroundCenter: function(angle) {\n\t        if (!angle) { return this; }\n\t        var ref = this;\n\t        var width = ref.width;\n\t        var height = ref.height;\n\t        var theta = toRad(angle);\n\t        var st = abs$1(sin$2(theta));\n\t        var ct = abs$1(cos$2(theta));\n\t        var w = width * ct + height * st;\n\t        var h = width * st + height * ct;\n\t        this.x += (width - w) / 2;\n\t        this.y += (height - h) / 2;\n\t        this.width = w;\n\t        this.height = h;\n\t        return this;\n\t    },\n\n\t    bottomLeft: function() {\n\n\t        return new Point(this.x, this.y + this.height);\n\t    },\n\n\t    bottomLine: function() {\n\n\t        return new Line(this.bottomLeft(), this.bottomRight());\n\t    },\n\n\t    bottomMiddle: function() {\n\n\t        return new Point(this.x + this.width / 2, this.y + this.height);\n\t    },\n\n\t    center: function() {\n\n\t        return new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t    },\n\n\t    clone: function() {\n\n\t        return new Rect(this);\n\t    },\n\n\t    // @return {bool} true if point p is inside me.\n\t    containsPoint: function(p) {\n\t        p = new Point(p);\n\t        return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;\n\t    },\n\n\t    // @return {bool} true if rectangle `r` is inside me.\n\t    containsRect: function(r) {\n\n\t        var r0 = new Rect(this).normalize();\n\t        var r1 = new Rect(r).normalize();\n\t        var w0 = r0.width;\n\t        var h0 = r0.height;\n\t        var w1 = r1.width;\n\t        var h1 = r1.height;\n\n\t        if (!w0 || !h0 || !w1 || !h1) {\n\t            // At least one of the dimensions is 0\n\t            return false;\n\t        }\n\n\t        var x0 = r0.x;\n\t        var y0 = r0.y;\n\t        var x1 = r1.x;\n\t        var y1 = r1.y;\n\n\t        w1 += x1;\n\t        w0 += x0;\n\t        h1 += y1;\n\t        h0 += y0;\n\n\t        return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n\t    },\n\n\t    corner: function() {\n\n\t        return new Point(this.x + this.width, this.y + this.height);\n\t    },\n\n\t    // @return {boolean} true if rectangles are equal.\n\t    equals: function(r) {\n\n\t        var mr = (new Rect(this)).normalize();\n\t        var nr = (new Rect(r)).normalize();\n\t        return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n\t    },\n\n\t    // inflate by dx and dy, recompute origin [x, y]\n\t    // @param dx {delta_x} representing additional size to x\n\t    // @param dy {delta_y} representing additional size to y -\n\t    // dy param is not required -> in that case y is sized by dx\n\t    inflate: function(dx, dy) {\n\n\t        if (dx === undefined) {\n\t            dx = 0;\n\t        }\n\n\t        if (dy === undefined) {\n\t            dy = dx;\n\t        }\n\n\t        this.x -= dx;\n\t        this.y -= dy;\n\t        this.width += 2 * dx;\n\t        this.height += 2 * dy;\n\n\t        return this;\n\t    },\n\n\t    // @return {rect} if rectangles intersect, {null} if not.\n\t    intersect: function(r) {\n\n\t        var myOrigin = this.origin();\n\t        var myCorner = this.corner();\n\t        var rOrigin = r.origin();\n\t        var rCorner = r.corner();\n\n\t        // No intersection found\n\t        if (rCorner.x <= myOrigin.x ||\n\t            rCorner.y <= myOrigin.y ||\n\t            rOrigin.x >= myCorner.x ||\n\t            rOrigin.y >= myCorner.y) { return null; }\n\n\t        var x = max$3(myOrigin.x, rOrigin.x);\n\t        var y = max$3(myOrigin.y, rOrigin.y);\n\n\t        return new Rect(x, y, min$5(myCorner.x, rCorner.x) - x, min$5(myCorner.y, rCorner.y) - y);\n\t    },\n\n\t    intersectionWithLine: function(line) {\n\n\t        var r = this;\n\t        var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n\t        var points = [];\n\t        var dedupeArr = [];\n\t        var pt, i;\n\n\t        var n = rectLines.length;\n\t        for (i = 0; i < n; i++) {\n\n\t            pt = line.intersect(rectLines[i]);\n\t            if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n\t                points.push(pt);\n\t                dedupeArr.push(pt.toString());\n\t            }\n\t        }\n\n\t        return points.length > 0 ? points : null;\n\t    },\n\n\t    // Find point on my boundary where line starting\n\t    // from my center ending in point p intersects me.\n\t    // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n\t    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n\t        p = new Point(p);\n\t        var center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t        var result;\n\n\t        if (angle) { p.rotate(center, angle); }\n\n\t        // (clockwise, starting from the top side)\n\t        var sides = [\n\t            this.topLine(),\n\t            this.rightLine(),\n\t            this.bottomLine(),\n\t            this.leftLine()\n\t        ];\n\t        var connector = new Line(center, p);\n\n\t        for (var i = sides.length - 1; i >= 0; --i) {\n\t            var intersection = sides[i].intersection(connector);\n\t            if (intersection !== null) {\n\t                result = intersection;\n\t                break;\n\t            }\n\t        }\n\t        if (result && angle) { result.rotate(center, -angle); }\n\t        return result;\n\t    },\n\n\t    leftLine: function() {\n\n\t        return new Line(this.topLeft(), this.bottomLeft());\n\t    },\n\n\t    leftMiddle: function() {\n\n\t        return new Point(this.x, this.y + this.height / 2);\n\t    },\n\n\t    maxRectScaleToFit: function(rect, origin) {\n\n\t        rect = new Rect(rect);\n\t        origin || (origin = rect.center());\n\n\t        var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n\t        var ox = origin.x;\n\t        var oy = origin.y;\n\n\t        // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n\t        // so when the scale is applied the point is still inside the rectangle.\n\n\t        sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n\n\t        // Top Left\n\t        var p1 = rect.topLeft();\n\t        if (p1.x < ox) {\n\t            sx1 = (this.x - ox) / (p1.x - ox);\n\t        }\n\t        if (p1.y < oy) {\n\t            sy1 = (this.y - oy) / (p1.y - oy);\n\t        }\n\t        // Bottom Right\n\t        var p2 = rect.bottomRight();\n\t        if (p2.x > ox) {\n\t            sx2 = (this.x + this.width - ox) / (p2.x - ox);\n\t        }\n\t        if (p2.y > oy) {\n\t            sy2 = (this.y + this.height - oy) / (p2.y - oy);\n\t        }\n\t        // Top Right\n\t        var p3 = rect.topRight();\n\t        if (p3.x > ox) {\n\t            sx3 = (this.x + this.width - ox) / (p3.x - ox);\n\t        }\n\t        if (p3.y < oy) {\n\t            sy3 = (this.y - oy) / (p3.y - oy);\n\t        }\n\t        // Bottom Left\n\t        var p4 = rect.bottomLeft();\n\t        if (p4.x < ox) {\n\t            sx4 = (this.x - ox) / (p4.x - ox);\n\t        }\n\t        if (p4.y > oy) {\n\t            sy4 = (this.y + this.height - oy) / (p4.y - oy);\n\t        }\n\n\t        return {\n\t            sx: min$5(sx1, sx2, sx3, sx4),\n\t            sy: min$5(sy1, sy2, sy3, sy4)\n\t        };\n\t    },\n\n\t    maxRectUniformScaleToFit: function(rect, origin) {\n\n\t        var scale = this.maxRectScaleToFit(rect, origin);\n\t        return min$5(scale.sx, scale.sy);\n\t    },\n\n\t    // Move and expand me.\n\t    // @param r {rectangle} representing deltas\n\t    moveAndExpand: function(r) {\n\n\t        this.x += r.x || 0;\n\t        this.y += r.y || 0;\n\t        this.width += r.width || 0;\n\t        this.height += r.height || 0;\n\t        return this;\n\t    },\n\n\t    // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n\t    // If width < 0 the function swaps the left and right corners,\n\t    // and it swaps the top and bottom corners if height < 0\n\t    // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n\t    normalize: function() {\n\n\t        var newx = this.x;\n\t        var newy = this.y;\n\t        var newwidth = this.width;\n\t        var newheight = this.height;\n\t        if (this.width < 0) {\n\t            newx = this.x + this.width;\n\t            newwidth = -this.width;\n\t        }\n\t        if (this.height < 0) {\n\t            newy = this.y + this.height;\n\t            newheight = -this.height;\n\t        }\n\t        this.x = newx;\n\t        this.y = newy;\n\t        this.width = newwidth;\n\t        this.height = newheight;\n\t        return this;\n\t    },\n\n\t    // Offset me by the specified amount.\n\t    offset: function(dx, dy) {\n\n\t        // pretend that this is a point and call offset()\n\t        // rewrites x and y according to dx and dy\n\t        return Point.prototype.offset.call(this, dx, dy);\n\t    },\n\n\t    origin: function() {\n\n\t        return new Point(this.x, this.y);\n\t    },\n\n\t    // @return {point} a point on my boundary nearest to the given point.\n\t    // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n\t    pointNearestToPoint: function(point) {\n\n\t        point = new Point(point);\n\t        if (this.containsPoint(point)) {\n\t            var side = this.sideNearestToPoint(point);\n\t            switch (side) {\n\t                case 'right':\n\t                    return new Point(this.x + this.width, point.y);\n\t                case 'left':\n\t                    return new Point(this.x, point.y);\n\t                case 'bottom':\n\t                    return new Point(point.x, this.y + this.height);\n\t                case 'top':\n\t                    return new Point(point.x, this.y);\n\t            }\n\t        }\n\t        return point.adhereToRect(this);\n\t    },\n\n\t    rightLine: function() {\n\n\t        return new Line(this.topRight(), this.bottomRight());\n\t    },\n\n\t    rightMiddle: function() {\n\n\t        return new Point(this.x + this.width, this.y + this.height / 2);\n\t    },\n\n\t    round: function(precision) {\n\n\t        var f = 1; // case 0\n\t        if (precision) {\n\t            switch (precision) {\n\t                case 1: f = 10; break;\n\t                case 2: f = 100; break;\n\t                case 3: f = 1000; break;\n\t                default: f = pow$2(10, precision); break;\n\t            }\n\t        }\n\n\t        this.x = round$3(this.x * f) / f;\n\t        this.y = round$3(this.y * f) / f;\n\t        this.width = round$3(this.width * f) / f;\n\t        this.height = round$3(this.height * f) / f;\n\t        return this;\n\t    },\n\n\t    // Scale rectangle with origin.\n\t    scale: function(sx, sy, origin) {\n\n\t        origin = this.origin().scale(sx, sy, origin);\n\t        this.x = origin.x;\n\t        this.y = origin.y;\n\t        this.width *= sx;\n\t        this.height *= sy;\n\t        return this;\n\t    },\n\n\t    // @return {string} (left|right|top|bottom) side which is nearest to point\n\t    // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n\t    sideNearestToPoint: function(point) {\n\n\t        point = new Point(point);\n\t        var distToLeft = point.x - this.x;\n\t        var distToRight = (this.x + this.width) - point.x;\n\t        var distToTop = point.y - this.y;\n\t        var distToBottom = (this.y + this.height) - point.y;\n\t        var closest = distToLeft;\n\t        var side = 'left';\n\n\t        if (distToRight < closest) {\n\t            closest = distToRight;\n\t            side = 'right';\n\t        }\n\t        if (distToTop < closest) {\n\t            closest = distToTop;\n\t            side = 'top';\n\t        }\n\t        if (distToBottom < closest) {\n\t            // closest = distToBottom;\n\t            side = 'bottom';\n\t        }\n\t        return side;\n\t    },\n\n\t    snapToGrid: function(gx, gy) {\n\n\t        var origin = this.origin().snapToGrid(gx, gy);\n\t        var corner = this.corner().snapToGrid(gx, gy);\n\t        this.x = origin.x;\n\t        this.y = origin.y;\n\t        this.width = corner.x - origin.x;\n\t        this.height = corner.y - origin.y;\n\t        return this;\n\t    },\n\n\t    toJSON: function() {\n\n\t        return { x: this.x, y: this.y, width: this.width, height: this.height };\n\t    },\n\n\t    topLine: function() {\n\n\t        return new Line(this.topLeft(), this.topRight());\n\t    },\n\n\t    topMiddle: function() {\n\n\t        return new Point(this.x + this.width / 2, this.y);\n\t    },\n\n\t    topRight: function() {\n\n\t        return new Point(this.x + this.width, this.y);\n\t    },\n\n\t    toString: function() {\n\n\t        return this.origin().toString() + ' ' + this.corner().toString();\n\t    },\n\n\t    // @return {rect} representing the union of both rectangles.\n\t    union: function(rect) {\n\n\t        return Rect.fromRectUnion(this, rect);\n\t    },\n\n\t    update: function(x, y, w, h) {\n\n\t        if ((Object(x) === x)) {\n\t            y = x.y;\n\t            w = x.width;\n\t            h = x.height;\n\t            x = x.x;\n\t        }\n\n\t        this.x = x || 0;\n\t        this.y = y || 0;\n\t        this.width = w || 0;\n\t        this.height = h || 0;\n\t        return this;\n\t    }\n\t};\n\n\tRect.prototype.bottomRight = Rect.prototype.corner;\n\n\tRect.prototype.topLeft = Rect.prototype.origin;\n\n\tRect.prototype.translate = Rect.prototype.offset;\n\n\t// For backwards compatibility:\n\tvar rect = Rect;\n\n\tfunction parsePoints(svgString) {\n\n\t    // Step 1: Discard surrounding spaces\n\t    var trimmedString = svgString.trim();\n\t    if (trimmedString === '') { return []; }\n\n\t    var points = [];\n\n\t    // Step 2: Split at commas (+ their surrounding spaces) or at multiple spaces\n\t    // ReDoS mitigation: Have an anchor at the beginning of each alternation\n\t    // Note: This doesn't simplify double (or more) commas - causes empty coords\n\t    // This regex is used by `split()`, so it doesn't need to use /g\n\t    var coords = trimmedString.split(/\\b\\s*,\\s*|,\\s*|\\s+/);\n\n\t    var numCoords = coords.length;\n\t    for (var i = 0; i < numCoords; i += 2) {\n\t        // Step 3: Convert each coord to number\n\t        // Note: If the coord cannot be converted to a number, it will be `NaN`\n\t        // Note: If the coord is empty (\"\", e.g. from \",,\" input), it will be `0`\n\t        // Note: If we end up with an odd number of coords, the last point's second coord will be `NaN`\n\t        points.push({ x: +coords[i], y: +coords[i + 1] });\n\t    }\n\t    return points;\n\t}\n\n\tfunction clonePoints(points) {\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) { return []; }\n\t    var newPoints = [];\n\t    for (var i = 0; i < numPoints; i++) {\n\t        var point = points[i].clone();\n\t        newPoints.push(point);\n\t    }\n\t    return newPoints;\n\t}\n\n\t// Returns a convex-hull polyline from this polyline.\n\t// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n\t// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n\t// Minimal polyline is found (only vertices of the hull are reported, no collinear points).\n\tfunction convexHull(points) {\n\n\t    var abs = Math.abs;\n\n\t    var i;\n\t    var n;\n\n\t    var numPoints = points.length;\n\t    if (numPoints === 0) { return []; } // if points array is empty\n\n\t    // step 1: find the starting point - point with the lowest y (if equality, highest x)\n\t    var startPoint;\n\t    for (i = 0; i < numPoints; i++) {\n\t        if (startPoint === undefined) {\n\t            // if this is the first point we see, set it as start point\n\t            startPoint = points[i];\n\n\t        } else if (points[i].y < startPoint.y) {\n\t            // start point should have lowest y from all points\n\t            startPoint = points[i];\n\n\t        } else if ((points[i].y === startPoint.y) && (points[i].x > startPoint.x)) {\n\t            // if two points have the lowest y, choose the one that has highest x\n\t            // there are no points to the right of startPoint - no ambiguity about theta 0\n\t            // if there are several coincident start point candidates, first one is reported\n\t            startPoint = points[i];\n\t        }\n\t    }\n\n\t    // step 2: sort the list of points\n\t    // sorting by angle between line from startPoint to point and the x-axis (theta)\n\n\t    // step 2a: create the point records = [point, originalIndex, angle]\n\t    var sortedPointRecords = [];\n\t    for (i = 0; i < numPoints; i++) {\n\n\t        var angle = startPoint.theta(points[i]);\n\t        if (angle === 0) {\n\t            angle = 360; // give highest angle to start point\n\t            // the start point will end up at end of sorted list\n\t            // the start point will end up at beginning of hull points list\n\t        }\n\n\t        var entry = [points[i], i, angle];\n\t        sortedPointRecords.push(entry);\n\t    }\n\n\t    // step 2b: sort the list in place\n\t    sortedPointRecords.sort(function(record1, record2) {\n\t        // returning a negative number here sorts record1 before record2\n\t        // if first angle is smaller than second, first angle should come before second\n\n\t        var sortOutput = record1[2] - record2[2];  // negative if first angle smaller\n\t        if (sortOutput === 0) {\n\t            // if the two angles are equal, sort by originalIndex\n\t            sortOutput = record2[1] - record1[1]; // negative if first index larger\n\t            // coincident points will be sorted in reverse-numerical order\n\t            // so the coincident points with lower original index will be considered first\n\t        }\n\n\t        return sortOutput;\n\t    });\n\n\t    // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n\t    if (sortedPointRecords.length > 2) {\n\t        var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n\t        sortedPointRecords.unshift(startPointRecord);\n\t    }\n\n\t    // step 3a: go through sorted points in order and find those with right turns\n\t    // we want to get our results in clockwise order\n\t    var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n\t    var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n\t    var currentPointRecord;\n\t    var currentPoint;\n\t    var lastHullPointRecord;\n\t    var lastHullPoint;\n\t    var secondLastHullPointRecord;\n\t    var secondLastHullPoint;\n\t    while (sortedPointRecords.length !== 0) {\n\n\t        currentPointRecord = sortedPointRecords.pop();\n\t        currentPoint = currentPointRecord[0];\n\n\t        // check if point has already been discarded\n\t        // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n\t        if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n\t            // this point had an incorrect turn at some previous iteration of this loop\n\t            // this disqualifies it from possibly being on the hull\n\t            continue;\n\t        }\n\n\t        var correctTurnFound = false;\n\t        while (!correctTurnFound) {\n\n\t            if (hullPointRecords.length < 2) {\n\t                // not enough points for comparison, just add current point\n\t                hullPointRecords.push(currentPointRecord);\n\t                correctTurnFound = true;\n\n\t            } else {\n\t                lastHullPointRecord = hullPointRecords.pop();\n\t                lastHullPoint = lastHullPointRecord[0];\n\t                secondLastHullPointRecord = hullPointRecords.pop();\n\t                secondLastHullPoint = secondLastHullPointRecord[0];\n\n\t                var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n\t                if (crossProduct < 0) {\n\t                    // found a right turn\n\t                    hullPointRecords.push(secondLastHullPointRecord);\n\t                    hullPointRecords.push(lastHullPointRecord);\n\t                    hullPointRecords.push(currentPointRecord);\n\t                    correctTurnFound = true;\n\n\t                } else if (crossProduct === 0) {\n\t                    // the three points are collinear\n\t                    // three options:\n\t                    // there may be a 180 or 0 degree angle at lastHullPoint\n\t                    // or two of the three points are coincident\n\t                    var THRESHOLD = 1e-10; // we have to take rounding errors into account\n\t                    var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n\t                    if (abs(angleBetween - 180) < THRESHOLD) { // rounding around 180 to 180\n\t                        // if the cross product is 0 because the angle is 180 degrees\n\t                        // discard last hull point (add to insidePoints)\n\t                        //insidePoints.unshift(lastHullPoint);\n\t                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n\t                        // reenter second-to-last hull point (will be last at next iter)\n\t                        hullPointRecords.push(secondLastHullPointRecord);\n\t                        // do not do anything with current point\n\t                        // correct turn not found\n\n\t                    } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n\t                        // if the cross product is 0 because two points are the same\n\t                        // discard last hull point (add to insidePoints)\n\t                        //insidePoints.unshift(lastHullPoint);\n\t                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n\t                        // reenter second-to-last hull point (will be last at next iter)\n\t                        hullPointRecords.push(secondLastHullPointRecord);\n\t                        // do not do anything with current point\n\t                        // correct turn not found\n\n\t                    } else if (abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) { // rounding around 0 and 360 to 0\n\t                        // if the cross product is 0 because the angle is 0 degrees\n\t                        // remove last hull point from hull BUT do not discard it\n\t                        // reenter second-to-last hull point (will be last at next iter)\n\t                        hullPointRecords.push(secondLastHullPointRecord);\n\t                        // put last hull point back into the sorted point records list\n\t                        sortedPointRecords.push(lastHullPointRecord);\n\t                        // we are switching the order of the 0deg and 180deg points\n\t                        // correct turn not found\n\t                    }\n\n\t                } else {\n\t                    // found a left turn\n\t                    // discard last hull point (add to insidePoints)\n\t                    //insidePoints.unshift(lastHullPoint);\n\t                    insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n\t                    // reenter second-to-last hull point (will be last at next iter of loop)\n\t                    hullPointRecords.push(secondLastHullPointRecord);\n\t                    // do not do anything with current point\n\t                    // correct turn not found\n\t                }\n\t            }\n\t        }\n\t    }\n\t    // at this point, hullPointRecords contains the output points in clockwise order\n\t    // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n\t    // step 3b: remove duplicated startPointRecord from the end of the array\n\t    if (hullPointRecords.length > 2) {\n\t        hullPointRecords.pop();\n\t    }\n\n\t    // step 4: find the lowest originalIndex record and put it at the beginning of hull\n\t    var lowestHullIndex; // the lowest originalIndex on the hull\n\t    var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n\t    n = hullPointRecords.length;\n\t    for (i = 0; i < n; i++) {\n\n\t        var currentHullIndex = hullPointRecords[i][1];\n\n\t        if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n\t            lowestHullIndex = currentHullIndex;\n\t            indexOfLowestHullIndexRecord = i;\n\t        }\n\t    }\n\n\t    var hullPointRecordsReordered = [];\n\t    if (indexOfLowestHullIndexRecord > 0) {\n\t        var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n\t        var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n\t        hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n\n\t    } else {\n\t        hullPointRecordsReordered = hullPointRecords;\n\t    }\n\n\t    var hullPoints = [];\n\t    n = hullPointRecordsReordered.length;\n\t    for (i = 0; i < n; i++) {\n\t        hullPoints.push(hullPointRecordsReordered[i][0]);\n\t    }\n\n\t    return hullPoints;\n\t}\n\n\tvar Polyline = function(points) {\n\n\t    if (!(this instanceof Polyline)) {\n\t        return new Polyline(points);\n\t    }\n\n\t    if (typeof points === 'string') {\n\t        return new Polyline.parse(points);\n\t    }\n\n\t    this.points = (Array.isArray(points) ? points.map(Point) : []);\n\t};\n\n\tPolyline.parse = function(svgString) {\n\t    return new Polyline(parsePoints(svgString));\n\t};\n\n\tPolyline.fromRect = function(rect) {\n\t    return new Polyline([\n\t        rect.topLeft(),\n\t        rect.topRight(),\n\t        rect.bottomRight(),\n\t        rect.bottomLeft(),\n\t        rect.topLeft() ]);\n\t};\n\n\tPolyline.prototype = {\n\n\t    type: types.Polyline,\n\n\t    bbox: function() {\n\n\t        var x1 = Infinity;\n\t        var x2 = -Infinity;\n\t        var y1 = Infinity;\n\t        var y2 = -Infinity;\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\n\t        for (var i = 0; i < numPoints; i++) {\n\n\t            var point = points[i];\n\t            var x = point.x;\n\t            var y = point.y;\n\n\t            if (x < x1) { x1 = x; }\n\t            if (x > x2) { x2 = x; }\n\t            if (y < y1) { y1 = y; }\n\t            if (y > y2) { y2 = y; }\n\t        }\n\n\t        return new Rect(x1, y1, x2 - x1, y2 - y1);\n\t    },\n\n\t    clone: function() {\n\t        return new Polyline(clonePoints(this.points));\n\t    },\n\n\t    closestPoint: function(p) {\n\n\t        var cpLength = this.closestPointLength(p);\n\n\t        return this.pointAtLength(cpLength);\n\t    },\n\n\t    closestPointLength: function(p) {\n\n\t        var points = this.lengthPoints();\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return 0; } // if points array is empty\n\t        if (numPoints === 1) { return 0; } // if there is only one point\n\n\t        var cpLength;\n\t        var minSqrDistance = Infinity;\n\t        var length = 0;\n\t        var n = numPoints - 1;\n\t        for (var i = 0; i < n; i++) {\n\n\t            var line = new Line(points[i], points[i + 1]);\n\t            var lineLength = line.length();\n\n\t            var cpNormalizedLength = line.closestPointNormalizedLength(p);\n\t            var cp = line.pointAt(cpNormalizedLength);\n\n\t            var sqrDistance = cp.squaredDistance(p);\n\t            if (sqrDistance < minSqrDistance) {\n\t                minSqrDistance = sqrDistance;\n\t                cpLength = length + (cpNormalizedLength * lineLength);\n\t            }\n\n\t            length += lineLength;\n\t        }\n\n\t        return cpLength;\n\t    },\n\n\t    closestPointNormalizedLength: function(p) {\n\n\t        var cpLength = this.closestPointLength(p);\n\t        if (cpLength === 0) { return 0; } // shortcut\n\n\t        var length = this.length();\n\t        if (length === 0) { return 0; } // prevents division by zero\n\n\t        return cpLength / length;\n\t    },\n\n\t    closestPointTangent: function(p) {\n\n\t        var cpLength = this.closestPointLength(p);\n\n\t        return this.tangentAtLength(cpLength);\n\t    },\n\n\t    // Returns `true` if the area surrounded by the polyline contains the point `p`.\n\t    // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n\t    // (Uses horizontal rays to the right of `p` to look for intersections.)\n\t    // Closes open polylines (always imagines a final closing segment).\n\t    containsPoint: function(p) {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return false; } // shortcut (this polyline has no points)\n\n\t        var x = p.x;\n\t        var y = p.y;\n\n\t        // initialize a final closing segment by creating one from last-first points on polyline\n\t        var startIndex = numPoints - 1; // start of current polyline segment\n\t        var endIndex = 0; // end of current polyline segment\n\t        var numIntersections = 0;\n\t        var segment = new Line();\n\t        var ray = new Line();\n\t        var rayEnd = new Point();\n\t        for (; endIndex < numPoints; endIndex++) {\n\t            var start = points[startIndex];\n\t            var end = points[endIndex];\n\t            if (p.equals(start)) { return true; } // shortcut (`p` is a point on polyline)\n\t            // current polyline segment\n\t            segment.start = start;\n\t            segment.end = end;\n\t            if (segment.containsPoint(p)) { return true; } // shortcut (`p` lies on a polyline segment)\n\n\t            // do we have an intersection?\n\t            if (((y <= start.y) && (y > end.y)) || ((y > start.y) && (y <= end.y))) {\n\t                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n\t                // (when `y === start.y === end.y`)\n\t                // this conditional branch IS entered when `segment` touches `ray` at only one point\n\t                // (e.g. when `y === start.y !== end.y`)\n\t                // since this branch is entered again for the following segment, the two touches cancel out\n\n\t                var xDifference = (((start.x - x) > (end.x - x)) ? (start.x - x) : (end.x - x));\n\t                if (xDifference >= 0) {\n\t                    // segment lies at least partially to the right of `p`\n\t                    rayEnd.x = x + xDifference;\n\t                    rayEnd.y = y; // right\n\t                    ray.start = p;\n\t                    ray.end = rayEnd;\n\t                    if (segment.intersect(ray)) {\n\t                        // an intersection was detected to the right of `p`\n\t                        numIntersections++;\n\t                    }\n\t                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n\t            }\n\n\t            // move to check the next polyline segment\n\t            startIndex = endIndex;\n\t        }\n\n\t        // returns `true` for odd numbers of intersections (even-odd algorithm)\n\t        return ((numIntersections % 2) === 1);\n\t    },\n\n\t    close: function() {\n\t        var ref = this;\n\t        var start = ref.start;\n\t        var end = ref.end;\n\t        var points = ref.points;\n\t        if (start && end && !start.equals(end)) {\n\t            points.push(start.clone());\n\t        }\n\t        return this;\n\t    },\n\n\t    lengthPoints: function() {\n\t        return this.points;\n\t    },\n\n\t    convexHull: function() {\n\t        return new Polyline(convexHull(this.points));\n\t    },\n\n\t    // Checks whether two polylines are exactly the same.\n\t    // If `p` is undefined or null, returns false.\n\t    equals: function(p) {\n\n\t        if (!p) { return false; }\n\n\t        var points = this.points;\n\t        var otherPoints = p.points;\n\n\t        var numPoints = points.length;\n\t        if (otherPoints.length !== numPoints) { return false; } // if the two polylines have different number of points, they cannot be equal\n\n\t        for (var i = 0; i < numPoints; i++) {\n\n\t            var point = points[i];\n\t            var otherPoint = p.points[i];\n\n\t            // as soon as an inequality is found in points, return false\n\t            if (!point.equals(otherPoint)) { return false; }\n\t        }\n\n\t        // if no inequality found in points, return true\n\t        return true;\n\t    },\n\n\t    intersectionWithLine: function(l) {\n\t        var line = new Line(l);\n\t        var intersections = [];\n\t        var points = this.lengthPoints();\n\t        var l2 = new Line();\n\t        for (var i = 0, n = points.length - 1; i < n; i++) {\n\t            l2.start = points[i];\n\t            l2.end = points[i + 1];\n\t            var int = line.intersectionWithLine(l2);\n\t            if (int) { intersections.push(int[0]); }\n\t        }\n\t        return (intersections.length > 0) ? intersections : null;\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return false; }\n\n\t        var line = new Line();\n\t        var n = numPoints - 1;\n\t        for (var i = 0; i < n; i++) {\n\t            line.start = points[i];\n\t            line.end = points[i + 1];\n\t            // as soon as a differentiable line is found between two points, return true\n\t            if (line.isDifferentiable()) { return true; }\n\t        }\n\n\t        // if no differentiable line is found between pairs of points, return false\n\t        return false;\n\t    },\n\n\t    length: function() {\n\n\t        var points = this.lengthPoints();\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return 0; } // if points array is empty\n\n\t        var length = 0;\n\t        var n = numPoints - 1;\n\t        for (var i = 0; i < n; i++) {\n\t            length += points[i].distance(points[i + 1]);\n\t        }\n\n\t        return length;\n\t    },\n\n\t    pointAt: function(ratio) {\n\n\t        var points = this.lengthPoints();\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\t        if (numPoints === 1) { return points[0].clone(); } // if there is only one point\n\n\t        if (ratio <= 0) { return points[0].clone(); }\n\t        if (ratio >= 1) { return points[numPoints - 1].clone(); }\n\n\t        var polylineLength = this.length();\n\t        var length = polylineLength * ratio;\n\n\t        return this.pointAtLength(length);\n\t    },\n\n\t    pointAtLength: function(length) {\n\n\t        var points = this.lengthPoints();\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\t        if (numPoints === 1) { return points[0].clone(); } // if there is only one point\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        var l = 0;\n\t        var n = numPoints - 1;\n\t        for (var i = 0; i < n; i++) {\n\t            var index = (fromStart ? i : (n - 1 - i));\n\n\t            var a = points[index];\n\t            var b = points[index + 1];\n\t            var line = new Line(a, b);\n\t            var d = a.distance(b);\n\n\t            if (length <= (l + d)) {\n\t                return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        // if length requested is higher than the length of the polyline, return last endpoint\n\t        var lastPoint = (fromStart ? points[numPoints - 1] : points[0]);\n\t        return lastPoint.clone();\n\t    },\n\n\t    round: function(precision) {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\n\t        for (var i = 0; i < numPoints; i++) {\n\t            points[i].round(precision);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\n\t        for (var i = 0; i < numPoints; i++) {\n\t            points[i].scale(sx, sy, origin);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    simplify: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        var points = this.points;\n\t        if (points.length < 3) { return this; } // we need at least 3 points\n\n\t        // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n\t        var threshold = opt.threshold || 0; // = max distance of middle point from chord to be simplified\n\n\t        // start at the beginning of the polyline and go forward\n\t        var currentIndex = 0;\n\t        // we need at least one intermediate point (3 points) in every iteration\n\t        // as soon as that stops being true, we know we reached the end of the polyline\n\t        while (points[currentIndex + 2]) {\n\t            var firstIndex = currentIndex;\n\t            var middleIndex = (currentIndex + 1);\n\t            var lastIndex = (currentIndex + 2);\n\n\t            var firstPoint = points[firstIndex];\n\t            var middlePoint = points[middleIndex];\n\t            var lastPoint = points[lastIndex];\n\n\t            var chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n\t            var closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n\t            var closestPointDistance = closestPoint.distance(middlePoint);\n\t            if (closestPointDistance <= threshold) {\n\t                // middle point is close enough to the chord = simplify\n\t                // 1) remove middle point:\n\t                points.splice(middleIndex, 1);\n\t                // 2) in next iteration, investigate the newly-created triplet of points\n\t                //    - do not change `currentIndex`\n\t                //    = (first point stays, point after removed point becomes middle point)\n\t            } else {\n\t                // middle point is far from the chord\n\t                // 1) preserve middle point\n\t                // 2) in next iteration, move `currentIndex` by one step:\n\t                currentIndex += 1;\n\t                //    = (point after first point becomes first point)\n\t            }\n\t        }\n\n\t        // `points` array was modified in-place\n\t        return this;\n\t    },\n\n\t    tangentAt: function(ratio) {\n\n\t        var points = this.lengthPoints();\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\t        if (numPoints === 1) { return null; } // if there is only one point\n\n\t        if (ratio < 0) { ratio = 0; }\n\t        if (ratio > 1) { ratio = 1; }\n\n\t        var polylineLength = this.length();\n\t        var length = polylineLength * ratio;\n\n\t        return this.tangentAtLength(length);\n\t    },\n\n\t    tangentAtLength: function(length) {\n\n\t        var points = this.lengthPoints();\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\t        if (numPoints === 1) { return null; } // if there is only one point\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        var lastValidLine; // differentiable (with a tangent)\n\t        var l = 0; // length so far\n\t        var n = numPoints - 1;\n\t        for (var i = 0; i < n; i++) {\n\t            var index = (fromStart ? i : (n - 1 - i));\n\n\t            var a = points[index];\n\t            var b = points[index + 1];\n\t            var line = new Line(a, b);\n\t            var d = a.distance(b);\n\n\t            if (line.isDifferentiable()) { // has a tangent line (line length is not 0)\n\t                if (length <= (l + d)) {\n\t                    return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n\t                }\n\n\t                lastValidLine = line;\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        // if length requested is higher than the length of the polyline, return last valid endpoint\n\t        if (lastValidLine) {\n\t            var ratio = (fromStart ? 1 : 0);\n\t            return lastValidLine.tangentAt(ratio);\n\t        }\n\n\t        // if no valid line, return null\n\t        return null;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.points + '';\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\n\t        for (var i = 0; i < numPoints; i++) {\n\t            points[i].translate(tx, ty);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    // Return svgString that can be used to recreate this line.\n\t    serialize: function() {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return ''; } // if points array is empty\n\n\t        var output = '';\n\t        for (var i = 0; i < numPoints; i++) {\n\n\t            var point = points[i];\n\t            output += point.x + ',' + point.y + ' ';\n\t        }\n\n\t        return output.trim();\n\t    }\n\t};\n\n\tObject.defineProperty(Polyline.prototype, 'start', {\n\t    // Getter for the first point of the polyline.\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\n\t        return this.points[0];\n\t    },\n\t});\n\n\tObject.defineProperty(Polyline.prototype, 'end', {\n\t    // Getter for the last point of the polyline.\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\n\t        return this.points[numPoints - 1];\n\t    },\n\t});\n\n\tvar abs$2 = Math.abs;\n\tvar sqrt$2 = Math.sqrt;\n\tvar min$6 = Math.min;\n\tvar max$4 = Math.max;\n\tvar pow$3 = Math.pow;\n\n\tvar Curve = function(p1, p2, p3, p4) {\n\n\t    if (!(this instanceof Curve)) {\n\t        return new Curve(p1, p2, p3, p4);\n\t    }\n\n\t    if (p1 instanceof Curve) {\n\t        return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n\t    }\n\n\t    this.start = new Point(p1);\n\t    this.controlPoint1 = new Point(p2);\n\t    this.controlPoint2 = new Point(p3);\n\t    this.end = new Point(p4);\n\t};\n\n\t// Curve passing through points.\n\t// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n\t// @param {array} points Array of points through which the smooth line will go.\n\t// @return {array} curves.\n\tCurve.throughPoints = (function() {\n\n\t    // Get open-ended Bezier Spline Control Points.\n\t    // @param knots Input Knot Bezier spline points (At least two points!).\n\t    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n\t    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n\t    function getCurveControlPoints(knots) {\n\n\t        var firstControlPoints = [];\n\t        var secondControlPoints = [];\n\t        var n = knots.length - 1;\n\t        var i;\n\n\t        // Special case: Bezier curve should be a straight line.\n\t        if (n == 1) {\n\t            // 3P1 = 2P0 + P3\n\t            firstControlPoints[0] = new Point(\n\t                (2 * knots[0].x + knots[1].x) / 3,\n\t                (2 * knots[0].y + knots[1].y) / 3\n\t            );\n\n\t            // P2 = 2P1  P0\n\t            secondControlPoints[0] = new Point(\n\t                2 * firstControlPoints[0].x - knots[0].x,\n\t                2 * firstControlPoints[0].y - knots[0].y\n\t            );\n\n\t            return [firstControlPoints, secondControlPoints];\n\t        }\n\n\t        // Calculate first Bezier control points.\n\t        // Right hand side vector.\n\t        var rhs = [];\n\n\t        // Set right hand side X values.\n\t        for (i = 1; i < n - 1; i++) {\n\t            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n\t        }\n\n\t        rhs[0] = knots[0].x + 2 * knots[1].x;\n\t        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n\t        // Get first control points X-values.\n\t        var x = getFirstControlPoints(rhs);\n\n\t        // Set right hand side Y values.\n\t        for (i = 1; i < n - 1; ++i) {\n\t            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n\t        }\n\n\t        rhs[0] = knots[0].y + 2 * knots[1].y;\n\t        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n\t        // Get first control points Y-values.\n\t        var y = getFirstControlPoints(rhs);\n\n\t        // Fill output arrays.\n\t        for (i = 0; i < n; i++) {\n\t            // First control point.\n\t            firstControlPoints.push(new Point(x[i], y[i]));\n\n\t            // Second control point.\n\t            if (i < n - 1) {\n\t                secondControlPoints.push(new Point(\n\t                    2 * knots [i + 1].x - x[i + 1],\n\t                    2 * knots[i + 1].y - y[i + 1]\n\t                ));\n\n\t            } else {\n\t                secondControlPoints.push(new Point(\n\t                    (knots[n].x + x[n - 1]) / 2,\n\t                    (knots[n].y + y[n - 1]) / 2\n\t                ));\n\t            }\n\t        }\n\n\t        return [firstControlPoints, secondControlPoints];\n\t    }\n\n\t    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n\t    // @param rhs Right hand side vector.\n\t    // @return Solution vector.\n\t    function getFirstControlPoints(rhs) {\n\n\t        var n = rhs.length;\n\t        // `x` is a solution vector.\n\t        var x = [];\n\t        var tmp = [];\n\t        var b = 2.0;\n\n\t        x[0] = rhs[0] / b;\n\n\t        // Decomposition and forward substitution.\n\t        for (var i = 1; i < n; i++) {\n\t            tmp[i] = 1 / b;\n\t            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n\t            x[i] = (rhs[i] - x[i - 1]) / b;\n\t        }\n\n\t        for (i = 1; i < n; i++) {\n\t            // Backsubstitution.\n\t            x[n - i - 1] -= tmp[n - i] * x[n - i];\n\t        }\n\n\t        return x;\n\t    }\n\n\t    return function(points) {\n\n\t        if (!points || (Array.isArray(points) && points.length < 2)) {\n\t            throw new Error('At least 2 points are required');\n\t        }\n\n\t        var controlPoints = getCurveControlPoints(points);\n\n\t        var curves = [];\n\t        var n = controlPoints[0].length;\n\t        for (var i = 0; i < n; i++) {\n\n\t            var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n\t            var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n\n\t            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n\t        }\n\n\t        return curves;\n\t    };\n\t})();\n\n\tCurve.prototype = {\n\n\t    type: types.Curve,\n\n\t    // Returns a bbox that tightly envelops the curve.\n\t    bbox: function() {\n\n\t        var start = this.start;\n\t        var controlPoint1 = this.controlPoint1;\n\t        var controlPoint2 = this.controlPoint2;\n\t        var end = this.end;\n\n\t        var x0 = start.x;\n\t        var y0 = start.y;\n\t        var x1 = controlPoint1.x;\n\t        var y1 = controlPoint1.y;\n\t        var x2 = controlPoint2.x;\n\t        var y2 = controlPoint2.y;\n\t        var x3 = end.x;\n\t        var y3 = end.y;\n\n\t        var points = new Array(); // local extremes\n\t        var tvalues = new Array(); // t values of local extremes\n\t        var bounds = [new Array(), new Array()];\n\n\t        var a, b, c, t;\n\t        var t1, t2;\n\t        var b2ac, sqrtb2ac;\n\n\t        for (var i = 0; i < 2; ++i) {\n\n\t            if (i === 0) {\n\t                b = 6 * x0 - 12 * x1 + 6 * x2;\n\t                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n\t                c = 3 * x1 - 3 * x0;\n\n\t            } else {\n\t                b = 6 * y0 - 12 * y1 + 6 * y2;\n\t                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n\t                c = 3 * y1 - 3 * y0;\n\t            }\n\n\t            if (abs$2(a) < 1e-12) { // Numerical robustness\n\t                if (abs$2(b) < 1e-12) { // Numerical robustness\n\t                    continue;\n\t                }\n\n\t                t = -c / b;\n\t                if ((0 < t) && (t < 1)) { tvalues.push(t); }\n\n\t                continue;\n\t            }\n\n\t            b2ac = b * b - 4 * c * a;\n\t            sqrtb2ac = sqrt$2(b2ac);\n\n\t            if (b2ac < 0) { continue; }\n\n\t            t1 = (-b + sqrtb2ac) / (2 * a);\n\t            if ((0 < t1) && (t1 < 1)) { tvalues.push(t1); }\n\n\t            t2 = (-b - sqrtb2ac) / (2 * a);\n\t            if ((0 < t2) && (t2 < 1)) { tvalues.push(t2); }\n\t        }\n\n\t        var j = tvalues.length;\n\t        var jlen = j;\n\t        var mt;\n\t        var x, y;\n\n\t        while (j--) {\n\t            t = tvalues[j];\n\t            mt = 1 - t;\n\n\t            x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n\t            bounds[0][j] = x;\n\n\t            y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n\t            bounds[1][j] = y;\n\n\t            points[j] = { X: x, Y: y };\n\t        }\n\n\t        tvalues[jlen] = 0;\n\t        tvalues[jlen + 1] = 1;\n\n\t        points[jlen] = { X: x0, Y: y0 };\n\t        points[jlen + 1] = { X: x3, Y: y3 };\n\n\t        bounds[0][jlen] = x0;\n\t        bounds[1][jlen] = y0;\n\n\t        bounds[0][jlen + 1] = x3;\n\t        bounds[1][jlen + 1] = y3;\n\n\t        tvalues.length = jlen + 2;\n\t        bounds[0].length = jlen + 2;\n\t        bounds[1].length = jlen + 2;\n\t        points.length = jlen + 2;\n\n\t        var left = min$6.apply(null, bounds[0]);\n\t        var top = min$6.apply(null, bounds[1]);\n\t        var right = max$4.apply(null, bounds[0]);\n\t        var bottom = max$4.apply(null, bounds[1]);\n\n\t        return new Rect(left, top, (right - left), (bottom - top));\n\t    },\n\n\t    clone: function() {\n\n\t        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t    },\n\n\t    // Returns the point on the curve closest to point `p`\n\t    closestPoint: function(p, opt) {\n\n\t        return this.pointAtT(this.closestPointT(p, opt));\n\t    },\n\n\t    closestPointLength: function(p, opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n\t        return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n\t    },\n\n\t    closestPointNormalizedLength: function(p, opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n\t        var cpLength = this.closestPointLength(p, localOpt);\n\t        if (!cpLength) { return 0; }\n\n\t        var length = this.length(localOpt);\n\t        if (length === 0) { return 0; }\n\n\t        return cpLength / length;\n\t    },\n\n\t    // Returns `t` of the point on the curve closest to point `p`\n\t    closestPointT: function(p, opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        // does not use localOpt\n\n\t        // identify the subdivision that contains the point:\n\t        var investigatedSubdivision;\n\t        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n\t        var investigatedSubdivisionEndT;\n\t        var distFromStart; // distance of point from start of baseline\n\t        var distFromEnd; // distance of point from end of baseline\n\t        var chordLength; // distance between start and end of the subdivision\n\t        var minSumDist; // lowest observed sum of the two distances\n\t        var n = subdivisions.length;\n\t        var subdivisionSize = (n ? (1 / n) : 0);\n\t        for (var i = 0; i < n; i++) {\n\n\t            var currentSubdivision = subdivisions[i];\n\n\t            var startDist = currentSubdivision.start.distance(p);\n\t            var endDist = currentSubdivision.end.distance(p);\n\t            var sumDist = startDist + endDist;\n\n\t            // check that the point is closest to current subdivision and not any other\n\t            if (!minSumDist || (sumDist < minSumDist)) {\n\t                investigatedSubdivision = currentSubdivision;\n\n\t                investigatedSubdivisionStartT = i * subdivisionSize;\n\t                investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n\n\t                distFromStart = startDist;\n\t                distFromEnd = endDist;\n\n\t                chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n\n\t                minSumDist = sumDist;\n\t            }\n\t        }\n\n\t        var precisionRatio = pow$3(10, -precision);\n\n\t        // recursively divide investigated subdivision:\n\t        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n\t        // then return the closest endpoint of that final subdivision\n\t        while (true) {\n\n\t            // check if we have reached at least one required observed precision\n\t            // - calculated as: the difference in distances from point to start and end divided by the distance\n\t            // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n\t            // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n\t            // - this criterion works well for points lying far away from the curve\n\t            var startPrecisionRatio = (distFromStart ? (abs$2(distFromStart - distFromEnd) / distFromStart) : 0);\n\t            var endPrecisionRatio = (distFromEnd ? (abs$2(distFromStart - distFromEnd) / distFromEnd) : 0);\n\t            var hasRequiredPrecision = ((startPrecisionRatio < precisionRatio) || (endPrecisionRatio < precisionRatio));\n\n\t            // check if we have reached at least one required minimal distance\n\t            // - calculated as: the subdivision chord length multiplied by precisionRatio\n\t            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n\t            // - this is a backup criterion that works well for points lying \"almost at\" the curve\n\t            var hasMinimalStartDistance = (distFromStart ? (distFromStart < (chordLength * precisionRatio)) : true);\n\t            var hasMinimalEndDistance = (distFromEnd ? (distFromEnd < (chordLength * precisionRatio)) : true);\n\t            var hasMinimalDistance = (hasMinimalStartDistance || hasMinimalEndDistance);\n\n\t            // do we stop now?\n\t            if (hasRequiredPrecision || hasMinimalDistance) {\n\t                return ((distFromStart <= distFromEnd) ? investigatedSubdivisionStartT : investigatedSubdivisionEndT);\n\t            }\n\n\t            // otherwise, set up for next iteration\n\t            var divided = investigatedSubdivision.divide(0.5);\n\t            subdivisionSize /= 2;\n\n\t            var startDist1 = divided[0].start.distance(p);\n\t            var endDist1 = divided[0].end.distance(p);\n\t            var sumDist1 = startDist1 + endDist1;\n\n\t            var startDist2 = divided[1].start.distance(p);\n\t            var endDist2 = divided[1].end.distance(p);\n\t            var sumDist2 = startDist2 + endDist2;\n\n\t            if (sumDist1 <= sumDist2) {\n\t                investigatedSubdivision = divided[0];\n\n\t                investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n\t                distFromStart = startDist1;\n\t                distFromEnd = endDist1;\n\n\t            } else {\n\t                investigatedSubdivision = divided[1];\n\n\t                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n\t                distFromStart = startDist2;\n\t                distFromEnd = endDist2;\n\t            }\n\t        }\n\t    },\n\n\t    closestPointTangent: function(p, opt) {\n\n\t        return this.tangentAtT(this.closestPointT(p, opt));\n\t    },\n\n\t    // Returns `true` if the area surrounded by the curve contains the point `p`.\n\t    // Implements the even-odd algorithm (self-intersections are \"outside\").\n\t    // Closes open curves (always imagines a closing segment).\n\t    // Precision may be adjusted by passing an `opt` object.\n\t    containsPoint: function(p, opt) {\n\n\t        var polyline = this.toPolyline(opt);\n\t        return polyline.containsPoint(p);\n\t    },\n\n\t    // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    // For a function that uses `t`, use Curve.divideAtT().\n\t    divideAt: function(ratio, opt) {\n\n\t        if (ratio <= 0) { return this.divideAtT(0); }\n\t        if (ratio >= 1) { return this.divideAtT(1); }\n\n\t        var t = this.tAt(ratio, opt);\n\n\t        return this.divideAtT(t);\n\t    },\n\n\t    // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    divideAtLength: function(length, opt) {\n\n\t        var t = this.tAtLength(length, opt);\n\n\t        return this.divideAtT(t);\n\t    },\n\n\t    // Divides the curve into two at point defined by `t` between 0 and 1.\n\t    // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n\t    // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n\t    divideAtT: function(t) {\n\n\t        var start = this.start;\n\t        var controlPoint1 = this.controlPoint1;\n\t        var controlPoint2 = this.controlPoint2;\n\t        var end = this.end;\n\n\t        // shortcuts for `t` values that are out of range\n\t        if (t <= 0) {\n\t            return [\n\t                new Curve(start, start, start, start),\n\t                new Curve(start, controlPoint1, controlPoint2, end)\n\t            ];\n\t        }\n\n\t        if (t >= 1) {\n\t            return [\n\t                new Curve(start, controlPoint1, controlPoint2, end),\n\t                new Curve(end, end, end, end)\n\t            ];\n\t        }\n\n\t        var dividerPoints = this.getSkeletonPoints(t);\n\n\t        var startControl1 = dividerPoints.startControlPoint1;\n\t        var startControl2 = dividerPoints.startControlPoint2;\n\t        var divider = dividerPoints.divider;\n\t        var dividerControl1 = dividerPoints.dividerControlPoint1;\n\t        var dividerControl2 = dividerPoints.dividerControlPoint2;\n\n\t        // return array with two new curves\n\t        return [\n\t            new Curve(start, startControl1, startControl2, divider),\n\t            new Curve(divider, dividerControl1, dividerControl2, end)\n\t        ];\n\t    },\n\n\t    // Returns the distance between the curve's start and end points.\n\t    endpointDistance: function() {\n\n\t        return this.start.distance(this.end);\n\t    },\n\n\t    // Checks whether two curves are exactly the same.\n\t    equals: function(c) {\n\n\t        return !!c &&\n\t            this.start.x === c.start.x &&\n\t            this.start.y === c.start.y &&\n\t            this.controlPoint1.x === c.controlPoint1.x &&\n\t            this.controlPoint1.y === c.controlPoint1.y &&\n\t            this.controlPoint2.x === c.controlPoint2.x &&\n\t            this.controlPoint2.y === c.controlPoint2.y &&\n\t            this.end.x === c.end.x &&\n\t            this.end.y === c.end.y;\n\t    },\n\n\t    // Returns five helper points necessary for curve division.\n\t    getSkeletonPoints: function(t) {\n\n\t        var start = this.start;\n\t        var control1 = this.controlPoint1;\n\t        var control2 = this.controlPoint2;\n\t        var end = this.end;\n\n\t        // shortcuts for `t` values that are out of range\n\t        if (t <= 0) {\n\t            return {\n\t                startControlPoint1: start.clone(),\n\t                startControlPoint2: start.clone(),\n\t                divider: start.clone(),\n\t                dividerControlPoint1: control1.clone(),\n\t                dividerControlPoint2: control2.clone()\n\t            };\n\t        }\n\n\t        if (t >= 1) {\n\t            return {\n\t                startControlPoint1: control1.clone(),\n\t                startControlPoint2: control2.clone(),\n\t                divider: end.clone(),\n\t                dividerControlPoint1: end.clone(),\n\t                dividerControlPoint2: end.clone()\n\t            };\n\t        }\n\n\t        var midpoint1 = (new Line(start, control1)).pointAt(t);\n\t        var midpoint2 = (new Line(control1, control2)).pointAt(t);\n\t        var midpoint3 = (new Line(control2, end)).pointAt(t);\n\n\t        var subControl1 = (new Line(midpoint1, midpoint2)).pointAt(t);\n\t        var subControl2 = (new Line(midpoint2, midpoint3)).pointAt(t);\n\n\t        var divider = (new Line(subControl1, subControl2)).pointAt(t);\n\n\t        var output = {\n\t            startControlPoint1: midpoint1,\n\t            startControlPoint2: subControl1,\n\t            divider: divider,\n\t            dividerControlPoint1: subControl2,\n\t            dividerControlPoint2: midpoint3\n\t        };\n\n\t        return output;\n\t    },\n\n\t    // Returns a list of curves whose flattened length is better than `opt.precision`.\n\t    // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n\t    // (Observed difference is not real precision, but close enough as long as special cases are covered)\n\t    // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)\n\t    // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)\n\t    // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)\n\t    // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n\t    // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n\t    // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n\t    // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n\t    getSubdivisions: function(opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        // not using opt.subdivisions\n\t        // not using localOpt\n\n\t        var start = this.start;\n\t        var control1 = this.controlPoint1;\n\t        var control2 = this.controlPoint2;\n\t        var end = this.end;\n\n\t        var subdivisions = [new Curve(start, control1, control2, end)];\n\t        if (precision === 0) { return subdivisions; }\n\n\t        // special case #1: point-like curves\n\t        // - no need to calculate subdivisions, they would all be identical\n\t        var isPoint = !this.isDifferentiable();\n\t        if (isPoint) { return subdivisions; }\n\n\t        var previousLength = this.endpointDistance();\n\n\t        var precisionRatio = pow$3(10, -precision);\n\n\t        // special case #2: sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n\t        // - not a problem for further iterations because cubic curves cannot have more than two local extrema\n\t        // - (i.e. cubic curves cannot intersect the baseline more than once)\n\t        // - therefore starting from iteration = 2 ensures that subsequent iterations do not produce sampling with equal length\n\t        // - (unless it's a straight-line curve, see below)\n\t        var minIterations = 2; // = 2*1\n\n\t        // special case #3: straight-line curves have the same observed length in all iterations\n\t        // - this causes observed precision ratio to always be 0 (= lower than `precisionRatio`, which is our exit condition)\n\t        // - we enforce the expected number of iterations = 2 * precision\n\t        var isLine = ((control1.cross(start, end) === 0) && (control2.cross(start, end) === 0));\n\t        if (isLine) {\n\t            minIterations = (2 * precision);\n\t        }\n\n\t        // recursively divide curve at `t = 0.5`\n\t        // until we reach `minIterations`\n\t        // and until the difference between observed length at subsequent iterations is lower than `precision`\n\t        var iteration = 0;\n\t        while (true) {\n\t            iteration += 1;\n\n\t            // divide all subdivisions\n\t            var newSubdivisions = [];\n\t            var numSubdivisions = subdivisions.length;\n\t            for (var i = 0; i < numSubdivisions; i++) {\n\n\t                var currentSubdivision = subdivisions[i];\n\t                var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n\t                newSubdivisions.push(divided[0], divided[1]);\n\t            }\n\n\t            // measure new length\n\t            var length = 0;\n\t            var numNewSubdivisions = newSubdivisions.length;\n\t            for (var j = 0; j < numNewSubdivisions; j++) {\n\n\t                var currentNewSubdivision = newSubdivisions[j];\n\t                length += currentNewSubdivision.endpointDistance();\n\t            }\n\n\t            // check if we have reached minimum number of iterations\n\t            if (iteration >= minIterations) {\n\n\t                // check if we have reached required observed precision\n\t                var observedPrecisionRatio = ((length !== 0) ? ((length - previousLength) / length) : 0);\n\t                if (observedPrecisionRatio < precisionRatio) {\n\t                    return newSubdivisions;\n\t                }\n\t            }\n\n\t            // otherwise, set up for next iteration\n\t            subdivisions = newSubdivisions;\n\t            previousLength = length;\n\t        }\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        var start = this.start;\n\t        var control1 = this.controlPoint1;\n\t        var control2 = this.controlPoint2;\n\t        var end = this.end;\n\n\t        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n\t    },\n\n\t    // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n\t    length: function(opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        // not using localOpt\n\n\t        var length = 0;\n\t        var n = subdivisions.length;\n\t        for (var i = 0; i < n; i++) {\n\n\t            var currentSubdivision = subdivisions[i];\n\t            length += currentSubdivision.endpointDistance();\n\t        }\n\n\t        return length;\n\t    },\n\n\t    // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n\t    lengthAtT: function(t, opt) {\n\n\t        if (t <= 0) { return 0; }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        // not using opt.subdivisions\n\t        // not using localOpt\n\n\t        var subCurve = this.divide(t)[0];\n\t        var subCurveLength = subCurve.length({ precision: precision });\n\n\t        return subCurveLength;\n\t    },\n\n\t    // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    // Mirrors Line.pointAt() function.\n\t    // For a function that tracks `t`, use Curve.pointAtT().\n\t    pointAt: function(ratio, opt) {\n\n\t        if (ratio <= 0) { return this.start.clone(); }\n\t        if (ratio >= 1) { return this.end.clone(); }\n\n\t        var t = this.tAt(ratio, opt);\n\n\t        return this.pointAtT(t);\n\t    },\n\n\t    // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    pointAtLength: function(length, opt) {\n\n\t        var t = this.tAtLength(length, opt);\n\n\t        return this.pointAtT(t);\n\t    },\n\n\t    // Returns the point at provided `t` between 0 and 1.\n\t    // `t` does not track distance along curve as it does in Line objects.\n\t    // Non-linear relationship, speeds up and slows down as curve warps!\n\t    // For linear length-based solution, use Curve.pointAt().\n\t    pointAtT: function(t) {\n\n\t        if (t <= 0) { return this.start.clone(); }\n\t        if (t >= 1) { return this.end.clone(); }\n\n\t        return this.getSkeletonPoints(t).divider;\n\t    },\n\n\t    // Default precision\n\t    PRECISION: 3,\n\n\t    round: function(precision) {\n\n\t        this.start.round(precision);\n\t        this.controlPoint1.round(precision);\n\t        this.controlPoint2.round(precision);\n\t        this.end.round(precision);\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        this.start.scale(sx, sy, origin);\n\t        this.controlPoint1.scale(sx, sy, origin);\n\t        this.controlPoint2.scale(sx, sy, origin);\n\t        this.end.scale(sx, sy, origin);\n\t        return this;\n\t    },\n\n\t    // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n\t    tangentAt: function(ratio, opt) {\n\n\t        if (!this.isDifferentiable()) { return null; }\n\n\t        if (ratio < 0) { ratio = 0; }\n\t        else if (ratio > 1) { ratio = 1; }\n\n\t        var t = this.tAt(ratio, opt);\n\n\t        return this.tangentAtT(t);\n\t    },\n\n\t    // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n\t    tangentAtLength: function(length, opt) {\n\n\t        if (!this.isDifferentiable()) { return null; }\n\n\t        var t = this.tAtLength(length, opt);\n\n\t        return this.tangentAtT(t);\n\t    },\n\n\t    // Returns a tangent line at requested `t`.\n\t    tangentAtT: function(t) {\n\n\t        if (!this.isDifferentiable()) { return null; }\n\n\t        if (t < 0) { t = 0; }\n\t        else if (t > 1) { t = 1; }\n\n\t        var skeletonPoints = this.getSkeletonPoints(t);\n\n\t        var p1 = skeletonPoints.startControlPoint2;\n\t        var p2 = skeletonPoints.dividerControlPoint1;\n\n\t        var tangentStart = skeletonPoints.divider;\n\n\t        var tangentLine = new Line(p1, p2);\n\t        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n\t        return tangentLine;\n\t    },\n\n\t    // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    tAt: function(ratio, opt) {\n\n\t        if (ratio <= 0) { return 0; }\n\t        if (ratio >= 1) { return 1; }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n\t        var curveLength = this.length(localOpt);\n\t        var length = curveLength * ratio;\n\n\t        return this.tAtLength(length, localOpt);\n\t    },\n\n\t    // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    // Uses `precision` to approximate length within `precision` (always underestimates)\n\t    // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n\t    // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n\t    // - Precision 0 (chooses one of the two endpoints) - 0 levels\n\t    // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n\t    // - Precision 2 (<1% error) - 3 levels\n\t    // - Precision 3 (<0.1% error) - 7 levels\n\t    // - Precision 4 (<0.01% error) - 15 levels\n\t    tAtLength: function(length, opt) {\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n\t        // identify the subdivision that contains the point at requested `length`:\n\t        var investigatedSubdivision;\n\t        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n\t        var investigatedSubdivisionEndT;\n\t        //var baseline; // straightened version of subdivision to investigate\n\t        //var baselinePoint; // point on the baseline that is the requested distance away from start\n\t        var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n\t        var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n\t        var l = 0; // length so far\n\t        var n = subdivisions.length;\n\t        var subdivisionSize = 1 / n;\n\t        for (var i = 0; i < n; i++) {\n\t            var index = (fromStart ? i : (n - 1 - i));\n\n\t            var currentSubdivision = subdivisions[i];\n\t            var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n\t            if (length <= (l + d)) {\n\t                investigatedSubdivision = currentSubdivision;\n\n\t                investigatedSubdivisionStartT = index * subdivisionSize;\n\t                investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n\n\t                baselinePointDistFromStart = (fromStart ? (length - l) : ((d + l) - length));\n\t                baselinePointDistFromEnd = (fromStart ? ((d + l) - length) : (length - l));\n\n\t                break;\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        if (!investigatedSubdivision) { return (fromStart ? 1 : 0); } // length requested is out of range - return maximum t\n\t        // note that precision affects what length is recorded\n\t        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n\t        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n\t        var curveLength = this.length(localOpt);\n\n\t        var precisionRatio = pow$3(10, -precision);\n\n\t        // recursively divide investigated subdivision:\n\t        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n\t        // then return the closest endpoint of that final subdivision\n\t        while (true) {\n\n\t            // check if we have reached required observed precision\n\t            var observedPrecisionRatio;\n\n\t            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromStart / curveLength) : 0);\n\t            if (observedPrecisionRatio < precisionRatio) { return investigatedSubdivisionStartT; }\n\t            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromEnd / curveLength) : 0);\n\t            if (observedPrecisionRatio < precisionRatio) { return investigatedSubdivisionEndT; }\n\n\t            // otherwise, set up for next iteration\n\t            var newBaselinePointDistFromStart;\n\t            var newBaselinePointDistFromEnd;\n\n\t            var divided = investigatedSubdivision.divide(0.5);\n\t            subdivisionSize /= 2;\n\n\t            var baseline1Length = divided[0].endpointDistance();\n\t            var baseline2Length = divided[1].endpointDistance();\n\n\t            if (baselinePointDistFromStart <= baseline1Length) { // point at requested length is inside divided[0]\n\t                investigatedSubdivision = divided[0];\n\n\t                investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n\t                newBaselinePointDistFromStart = baselinePointDistFromStart;\n\t                newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n\n\t            } else { // point at requested length is inside divided[1]\n\t                investigatedSubdivision = divided[1];\n\n\t                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n\t                newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n\t                newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n\t            }\n\n\t            baselinePointDistFromStart = newBaselinePointDistFromStart;\n\t            baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n\t        }\n\t    },\n\n\t    // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n\t    // Flattened length is no more than 10^(-precision) away from real curve length.\n\t    toPoints: function(opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        // not using localOpt\n\n\t        var points = [subdivisions[0].start.clone()];\n\t        var n = subdivisions.length;\n\t        for (var i = 0; i < n; i++) {\n\n\t            var currentSubdivision = subdivisions[i];\n\t            points.push(currentSubdivision.end.clone());\n\t        }\n\n\t        return points;\n\t    },\n\n\t    // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n\t    // Flattened length is no more than 10^(-precision) away from real curve length.\n\t    toPolyline: function(opt) {\n\n\t        return new Polyline(this.toPoints(opt));\n\t    },\n\n\t    toString: function() {\n\n\t        return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        this.start.translate(tx, ty);\n\t        this.controlPoint1.translate(tx, ty);\n\t        this.controlPoint2.translate(tx, ty);\n\t        this.end.translate(tx, ty);\n\t        return this;\n\t    }\n\t};\n\n\tCurve.prototype.divide = Curve.prototype.divideAtT;\n\n\t// Local helper function.\n\t// Add properties from arguments on top of properties from `obj`.\n\t// This allows for rudimentary inheritance.\n\t// - The `obj` argument acts as parent.\n\t// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n\t// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\n\tfunction extend(obj) {\n\t    var arguments$1 = arguments;\n\n\t    // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n\t    // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n\t    // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n\t    // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n\t    // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n\t    // - This method provides a way to do exactly that.\n\t    // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n\t    // - Therefore, to continue with the example above:\n\t    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n\t    //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n\t    //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n\t    //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n\t    // - Multiple inheritance is also possible, if multiple arguments are provided.\n\t    // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n\t    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n\t    //   - The ancestors are applied in order of appearance.\n\t    //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n\t    //   - Any number of ancestors may be provided.\n\t    // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n\t    // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n\t    //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n\t    //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n\t    // - Therefore, both of the following are valid:\n\t    //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n\t    //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n\n\t    var i;\n\t    var n;\n\n\t    var args = [];\n\t    n = arguments.length;\n\t    for (i = 1; i < n; i++) { // skip over obj\n\t        args.push(arguments$1[i]);\n\t    }\n\n\t    if (!obj) { throw new Error('Missing a parent object.'); }\n\t    var child = Object.create(obj);\n\n\t    n = args.length;\n\t    for (i = 0; i < n; i++) {\n\n\t        var src = args[i];\n\n\t        var inheritedProperty;\n\t        var key;\n\t        for (key in src) {\n\n\t            if (src.hasOwnProperty(key)) {\n\t                delete child[key]; // delete property inherited from parent\n\t                inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n\t                Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n\t            }\n\t        }\n\t    }\n\n\t    return child;\n\t}\n\n\t// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n\tvar Path = function(arg) {\n\n\t    if (!(this instanceof Path)) {\n\t        return new Path(arg);\n\t    }\n\n\t    if (typeof arg === 'string') { // create from a path data string\n\t        return new Path.parse(arg);\n\t    }\n\n\t    this.segments = [];\n\n\t    var i;\n\t    var n;\n\n\t    if (!arg) {\n\t        // don't do anything\n\n\t    } else if (Array.isArray(arg) && arg.length !== 0) { // if arg is a non-empty array\n\t        // flatten one level deep\n\t        // so we can chain arbitrary Path.createSegment results\n\t        arg = arg.reduce(function(acc, val) {\n\t            return acc.concat(val);\n\t        }, []);\n\n\t        n = arg.length;\n\t        if (arg[0].isSegment) { // create from an array of segments\n\t            for (i = 0; i < n; i++) {\n\n\t                var segment = arg[i];\n\n\t                this.appendSegment(segment);\n\t            }\n\n\t        } else { // create from an array of Curves and/or Lines\n\t            var previousObj = null;\n\t            for (i = 0; i < n; i++) {\n\n\t                var obj = arg[i];\n\n\t                if (!((obj instanceof Line) || (obj instanceof Curve))) {\n\t                    throw new Error('Cannot construct a path segment from the provided object.');\n\t                }\n\n\t                if (i === 0) { this.appendSegment(Path.createSegment('M', obj.start)); }\n\n\t                // if objects do not link up, moveto segments are inserted to cover the gaps\n\t                if (previousObj && !previousObj.end.equals(obj.start)) { this.appendSegment(Path.createSegment('M', obj.start)); }\n\n\t                if (obj instanceof Line) {\n\t                    this.appendSegment(Path.createSegment('L', obj.end));\n\n\t                } else if (obj instanceof Curve) {\n\t                    this.appendSegment(Path.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n\t                }\n\n\t                previousObj = obj;\n\t            }\n\t        }\n\n\t    } else if (arg.isSegment) { // create from a single segment\n\t        this.appendSegment(arg);\n\n\t    } else if (arg instanceof Line) { // create from a single Line\n\t        this.appendSegment(Path.createSegment('M', arg.start));\n\t        this.appendSegment(Path.createSegment('L', arg.end));\n\n\t    } else if (arg instanceof Curve) { // create from a single Curve\n\t        this.appendSegment(Path.createSegment('M', arg.start));\n\t        this.appendSegment(Path.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n\n\t    } else if (arg instanceof Polyline) { // create from a Polyline\n\t        if (!(arg.points && (arg.points.length !== 0))) { return; } // if Polyline has no points, leave Path empty\n\n\t        n = arg.points.length;\n\t        for (i = 0; i < n; i++) {\n\n\t            var point = arg.points[i];\n\n\t            if (i === 0) { this.appendSegment(Path.createSegment('M', point)); }\n\t            else { this.appendSegment(Path.createSegment('L', point)); }\n\t        }\n\n\t    } else { // unknown object\n\t        throw new Error('Cannot construct a path from the provided object.');\n\t    }\n\t};\n\n\t// More permissive than V.normalizePathData and Path.prototype.serialize.\n\t// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n\t// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n\t// Allows for command argument chaining.\n\t// Throws an error if wrong number of arguments is provided with a command.\n\t// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\n\tPath.parse = function(pathData) {\n\n\t    if (!pathData) { return new Path(); }\n\n\t    var path = new Path();\n\n\t    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n\t    var commands = pathData.match(commandRe);\n\n\t    var numCommands = commands.length;\n\t    for (var i = 0; i < numCommands; i++) {\n\n\t        var command = commands[i];\n\t        var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n\t        var args = command.match(argRe);\n\n\t        var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n\t        path.appendSegment(segment);\n\t    }\n\n\t    return path;\n\t};\n\n\t// Create a segment or an array of segments.\n\t// Accepts unlimited points/coords arguments after `type`.\n\tPath.createSegment = function(type) {\n\t    var arguments$1 = arguments;\n\n\n\t    if (!type) { throw new Error('Type must be provided.'); }\n\n\t    var segmentConstructor = Path.segmentTypes[type];\n\t    if (!segmentConstructor) { throw new Error(type + ' is not a recognized path segment type.'); }\n\n\t    var args = [];\n\t    var n = arguments.length;\n\t    for (var i = 1; i < n; i++) { // do not add first element (`type`) to args array\n\t        args.push(arguments$1[i]);\n\t    }\n\n\t    return applyToNew(segmentConstructor, args);\n\t};\n\n\tPath.prototype = {\n\n\t    type: types.Path,\n\n\t    // Accepts one segment or an array of segments as argument.\n\t    // Throws an error if argument is not a segment or an array of segments.\n\t    appendSegment: function(arg) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        // works even if path has no segments\n\n\t        var currentSegment;\n\n\t        var previousSegment = ((numSegments !== 0) ? segments[numSegments - 1] : null); // if we are appending to an empty path, previousSegment is null\n\t        var nextSegment = null;\n\n\t        if (!Array.isArray(arg)) { // arg is a segment\n\t            if (!arg || !arg.isSegment) { throw new Error('Segment required.'); }\n\n\t            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n\t            segments.push(currentSegment);\n\n\t        } else { // arg is an array of segments\n\t            // flatten one level deep\n\t            // so we can chain arbitrary Path.createSegment results\n\t            arg = arg.reduce(function(acc, val) {\n\t                return acc.concat(val);\n\t            }, []);\n\n\t            if (!arg[0].isSegment) { throw new Error('Segments required.'); }\n\n\t            var n = arg.length;\n\t            for (var i = 0; i < n; i++) {\n\n\t                var currentArg = arg[i];\n\t                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n\t                segments.push(currentSegment);\n\t                previousSegment = currentSegment;\n\t            }\n\t        }\n\t    },\n\n\t    // Returns the bbox of the path.\n\t    // If path has no segments, returns null.\n\t    // If path has only invisible segments, returns bbox of the end point of last segment.\n\t    bbox: function() {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        var bbox;\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            if (segment.isVisible) {\n\t                var segmentBBox = segment.bbox();\n\t                bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n\t            }\n\t        }\n\n\t        if (bbox) { return bbox; }\n\n\t        // if the path has only invisible elements, return end point of last segment\n\t        var lastSegment = segments[numSegments - 1];\n\t        return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n\t    },\n\n\t    // Returns a new path that is a clone of this path.\n\t    clone: function() {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        // works even if path has no segments\n\n\t        var path = new Path();\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i].clone();\n\t            path.appendSegment(segment);\n\t        }\n\n\t        return path;\n\t    },\n\n\t    closestPoint: function(p, opt) {\n\n\t        var t = this.closestPointT(p, opt);\n\t        if (!t) { return null; }\n\n\t        return this.pointAtT(t);\n\t    },\n\n\t    closestPointLength: function(p, opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n\t        var t = this.closestPointT(p, localOpt);\n\t        if (!t) { return 0; }\n\n\t        return this.lengthAtT(t, localOpt);\n\t    },\n\n\t    closestPointNormalizedLength: function(p, opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n\t        var cpLength = this.closestPointLength(p, localOpt);\n\t        if (cpLength === 0) { return 0; } // shortcut\n\n\t        var length = this.length(localOpt);\n\t        if (length === 0) { return 0; } // prevents division by zero\n\n\t        return cpLength / length;\n\t    },\n\n\t    // Private function.\n\t    closestPointT: function(p, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var closestPointT;\n\t        var minSquaredDistance = Infinity;\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            var subdivisions = segmentSubdivisions[i];\n\n\t            if (segment.isVisible) {\n\t                var segmentClosestPointT = segment.closestPointT(p, {\n\t                    precision: precision,\n\t                    subdivisions: subdivisions\n\t                });\n\t                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n\t                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n\t                if (squaredDistance < minSquaredDistance) {\n\t                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };\n\t                    minSquaredDistance = squaredDistance;\n\t                }\n\t            }\n\t        }\n\n\t        if (closestPointT) { return closestPointT; }\n\n\t        // if no visible segment, return end of last segment\n\t        return { segmentIndex: numSegments - 1, value: 1 };\n\t    },\n\n\t    closestPointTangent: function(p, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var closestPointTangent;\n\t        var minSquaredDistance = Infinity;\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            var subdivisions = segmentSubdivisions[i];\n\n\t            if (segment.isDifferentiable()) {\n\t                var segmentClosestPointT = segment.closestPointT(p, {\n\t                    precision: precision,\n\t                    subdivisions: subdivisions\n\t                });\n\t                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n\t                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n\t                if (squaredDistance < minSquaredDistance) {\n\t                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n\t                    minSquaredDistance = squaredDistance;\n\t                }\n\t            }\n\t        }\n\n\t        if (closestPointTangent) { return closestPointTangent; }\n\n\t        // if no valid segment, return null\n\t        return null;\n\t    },\n\n\t    // Returns `true` if the area surrounded by the path contains the point `p`.\n\t    // Implements the even-odd algorithm (self-intersections are \"outside\").\n\t    // Closes open paths (always imagines a final closing segment).\n\t    // Precision may be adjusted by passing an `opt` object.\n\t    containsPoint: function(p, opt) {\n\n\t        var polylines = this.toPolylines(opt);\n\t        if (!polylines) { return false; } // shortcut (this path has no polylines)\n\n\t        var numPolylines = polylines.length;\n\n\t        // how many component polylines does `p` lie within?\n\t        var numIntersections = 0;\n\t        for (var i = 0; i < numPolylines; i++) {\n\t            var polyline = polylines[i];\n\t            if (polyline.containsPoint(p)) {\n\t                // `p` lies within this polyline\n\t                numIntersections++;\n\t            }\n\t        }\n\n\t        // returns `true` for odd numbers of intersections (even-odd algorithm)\n\t        return ((numIntersections % 2) === 1);\n\t    },\n\n\t    // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    divideAt: function(ratio, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        if (ratio < 0) { ratio = 0; }\n\t        if (ratio > 1) { ratio = 1; }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n\t        var pathLength = this.length(localOpt);\n\t        var length = pathLength * ratio;\n\n\t        return this.divideAtLength(length, localOpt);\n\t    },\n\n\t    // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    divideAtLength: function(length, opt) {\n\n\t        var numSegments = this.segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var i;\n\t        var segment;\n\n\t        // identify the segment to divide:\n\n\t        var l = 0; // length so far\n\t        var divided;\n\t        var dividedSegmentIndex;\n\t        var lastValidSegment; // visible AND differentiable\n\t        var lastValidSegmentIndex;\n\t        var t;\n\t        for (i = 0; i < numSegments; i++) {\n\t            var index = (fromStart ? i : (numSegments - 1 - i));\n\n\t            segment = this.getSegment(index);\n\t            var subdivisions = segmentSubdivisions[index];\n\t            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n\t            if (segment.isDifferentiable()) { // segment is not just a point\n\t                lastValidSegment = segment;\n\t                lastValidSegmentIndex = index;\n\n\t                if (length <= (l + d)) {\n\t                    dividedSegmentIndex = index;\n\t                    divided = segment.divideAtLength(((fromStart ? 1 : -1) * (length - l)), {\n\t                        precision: precision,\n\t                        subdivisions: subdivisions\n\t                    });\n\t                    break;\n\t                }\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        if (!lastValidSegment) { // no valid segment found\n\t            return null;\n\t        }\n\n\t        // else: the path contains at least one valid segment\n\n\t        if (!divided) { // the desired length is greater than the length of the path\n\t            dividedSegmentIndex = lastValidSegmentIndex;\n\t            t = (fromStart ? 1 : 0);\n\t            divided = lastValidSegment.divideAtT(t);\n\t        }\n\n\t        // create a copy of this path and replace the identified segment with its two divided parts:\n\n\t        var pathCopy = this.clone();\n\t        pathCopy.replaceSegment(dividedSegmentIndex, divided);\n\n\t        var divisionStartIndex = dividedSegmentIndex;\n\t        var divisionMidIndex = dividedSegmentIndex + 1;\n\t        var divisionEndIndex = dividedSegmentIndex + 2;\n\n\t        // do not insert the part if it looks like a point\n\t        if (!divided[0].isDifferentiable()) {\n\t            pathCopy.removeSegment(divisionStartIndex);\n\t            divisionMidIndex -= 1;\n\t            divisionEndIndex -= 1;\n\t        }\n\n\t        // insert a Moveto segment to ensure secondPath will be valid:\n\t        var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n\t        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n\t        divisionEndIndex += 1;\n\n\t        // do not insert the part if it looks like a point\n\t        if (!divided[1].isDifferentiable()) {\n\t            pathCopy.removeSegment(divisionEndIndex - 1);\n\t            divisionEndIndex -= 1;\n\t        }\n\n\t        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n\t        var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n\t        for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n\n\t            var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n\t            segment = pathCopy.getSegment(i);\n\n\t            if ((segment.type === 'Z') && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n\t                // pathCopy segment's subpathStartSegment is different from original segment's one\n\t                // convert this Closepath segment to a Lineto and replace it in pathCopy\n\t                var convertedSegment = Path.createSegment('L', originalSegment.end);\n\t                pathCopy.replaceSegment(i, convertedSegment);\n\t            }\n\t        }\n\n\t        // distribute pathCopy segments into two paths and return those:\n\n\t        var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n\t        var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n\n\t        return [firstPath, secondPath];\n\t    },\n\n\t    // Checks whether two paths are exactly the same.\n\t    // If `p` is undefined or null, returns false.\n\t    equals: function(p) {\n\n\t        if (!p) { return false; }\n\n\t        var segments = this.segments;\n\t        var otherSegments = p.segments;\n\n\t        var numSegments = segments.length;\n\t        if (otherSegments.length !== numSegments) { return false; } // if the two paths have different number of segments, they cannot be equal\n\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            var otherSegment = otherSegments[i];\n\n\t            // as soon as an inequality is found in segments, return false\n\t            if ((segment.type !== otherSegment.type) || (!segment.equals(otherSegment))) { return false; }\n\t        }\n\n\t        // if no inequality found in segments, return true\n\t        return true;\n\t    },\n\n\t    // Accepts negative indices.\n\t    // Throws an error if path has no segments.\n\t    // Throws an error if index is out of range.\n\t    getSegment: function(index) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { throw new Error('Path has no segments.'); }\n\n\t        if (index < 0) { index = numSegments + index; } // convert negative indices to positive\n\t        if (index >= numSegments || index < 0) { throw new Error('Index out of range.'); }\n\n\t        return segments[index];\n\t    },\n\n\t    // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n\t    getSegmentSubdivisions: function(opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        // works even if path has no segments\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        // not using opt.segmentSubdivisions\n\t        // not using localOpt\n\n\t        var segmentSubdivisions = [];\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            var subdivisions = segment.getSubdivisions({ precision: precision });\n\t            segmentSubdivisions.push(subdivisions);\n\t        }\n\n\t        return segmentSubdivisions;\n\t    },\n\n\t    // Returns an array of subpaths of this path.\n\t    // Invalid paths are validated first.\n\t    // Returns `[]` if path has no segments.\n\t    getSubpaths: function() {\n\n\t        var validatedPath = this.clone().validate();\n\n\t        var segments = validatedPath.segments;\n\t        var numSegments = segments.length;\n\n\t        var subpaths = [];\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            if (segment.isSubpathStart) {\n\t                // we encountered a subpath start segment\n\t                // create a new path for segment, and push it to list of subpaths\n\t                subpaths.push(new Path(segment));\n\n\t            } else {\n\t                // append current segment to the last subpath\n\t                subpaths[subpaths.length - 1].appendSegment(segment);\n\t            }\n\t        }\n\n\t        return subpaths;\n\t    },\n\n\t    // Insert `arg` at given `index`.\n\t    // `index = 0` means insert at the beginning.\n\t    // `index = segments.length` means insert at the end.\n\t    // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n\t    // Accepts one segment or an array of segments as argument.\n\t    // Throws an error if index is out of range.\n\t    // Throws an error if argument is not a segment or an array of segments.\n\t    insertSegment: function(index, arg) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        // works even if path has no segments\n\n\t        // note that these are incremented compared to getSegments()\n\t        // we can insert after last element (note that this changes the meaning of index -1)\n\t        if (index < 0) { index = numSegments + index + 1; } // convert negative indices to positive\n\t        if (index > numSegments || index < 0) { throw new Error('Index out of range.'); }\n\n\t        var currentSegment;\n\n\t        var previousSegment = null;\n\t        var nextSegment = null;\n\n\t        if (numSegments !== 0) {\n\t            if (index >= 1) {\n\t                previousSegment = segments[index - 1];\n\t                nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n\n\t            } else { // if index === 0\n\t                // previousSegment is null\n\t                nextSegment = segments[0];\n\t            }\n\t        }\n\n\t        if (!Array.isArray(arg)) {\n\t            if (!arg || !arg.isSegment) { throw new Error('Segment required.'); }\n\n\t            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n\t            segments.splice(index, 0, currentSegment);\n\n\t        } else {\n\t            // flatten one level deep\n\t            // so we can chain arbitrary Path.createSegment results\n\t            arg = arg.reduce(function(acc, val) {\n\t                return acc.concat(val);\n\t            }, []);\n\n\t            if (!arg[0].isSegment) { throw new Error('Segments required.'); }\n\n\t            var n = arg.length;\n\t            for (var i = 0; i < n; i++) {\n\n\t                var currentArg = arg[i];\n\t                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n\t                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n\t                previousSegment = currentSegment;\n\t            }\n\t        }\n\t    },\n\n\t    intersectionWithLine: function(line, opt) {\n\n\t        var intersection = null;\n\t        var polylines = this.toPolylines(opt);\n\t        if (!polylines) { return null; }\n\t        for (var i = 0, n = polylines.length; i < n; i++) {\n\t            var polyline = polylines[i];\n\t            var polylineIntersection = line.intersect(polyline);\n\t            if (polylineIntersection) {\n\t                intersection || (intersection = []);\n\t                if (Array.isArray(polylineIntersection)) {\n\t                    Array.prototype.push.apply(intersection, polylineIntersection);\n\t                } else {\n\t                    intersection.push(polylineIntersection);\n\t                }\n\t            }\n\t        }\n\n\t        return intersection;\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            // as soon as a differentiable segment is found in segments, return true\n\t            if (segment.isDifferentiable()) { return true; }\n\t        }\n\n\t        // if no differentiable segment is found in segments, return false\n\t        return false;\n\t    },\n\n\t    // Checks whether current path segments are valid.\n\t    // Note that d is allowed to be empty - should disable rendering of the path.\n\t    isValid: function() {\n\n\t        var segments = this.segments;\n\t        var isValid = (segments.length === 0) || (segments[0].type === 'M'); // either empty or first segment is a Moveto\n\t        return isValid;\n\t    },\n\n\t    // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n\t    // If path has no segments, returns 0.\n\t    length: function(opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return 0; } // if segments is an empty array\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var length = 0;\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            var subdivisions = segmentSubdivisions[i];\n\t            length += segment.length({ subdivisions: subdivisions });\n\t        }\n\n\t        return length;\n\t    },\n\n\t    // Private function.\n\t    lengthAtT: function(t, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return 0; } // if segments is an empty array\n\n\t        var segmentIndex = t.segmentIndex;\n\t        if (segmentIndex < 0) { return 0; } // regardless of t.value\n\n\t        var tValue = t.value;\n\t        if (segmentIndex >= numSegments) {\n\t            segmentIndex = numSegments - 1;\n\t            tValue = 1;\n\t        } else if (tValue < 0) { tValue = 0; }\n\t        else if (tValue > 1) { tValue = 1; }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var subdivisions;\n\t        var length = 0;\n\t        for (var i = 0; i < segmentIndex; i++) {\n\n\t            var segment = segments[i];\n\t            subdivisions = segmentSubdivisions[i];\n\t            length += segment.length({ precisison: precision, subdivisions: subdivisions });\n\t        }\n\n\t        segment = segments[segmentIndex];\n\t        subdivisions = segmentSubdivisions[segmentIndex];\n\t        length += segment.lengthAtT(tValue, { precisison: precision, subdivisions: subdivisions });\n\n\t        return length;\n\t    },\n\n\t    // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t    pointAt: function(ratio, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        if (ratio <= 0) { return this.start.clone(); }\n\t        if (ratio >= 1) { return this.end.clone(); }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n\t        var pathLength = this.length(localOpt);\n\t        var length = pathLength * ratio;\n\n\t        return this.pointAtLength(length, localOpt);\n\t    },\n\n\t    // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t    // Accepts negative length.\n\t    pointAtLength: function(length, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        if (length === 0) { return this.start.clone(); }\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var lastVisibleSegment;\n\t        var l = 0; // length so far\n\t        for (var i = 0; i < numSegments; i++) {\n\t            var index = (fromStart ? i : (numSegments - 1 - i));\n\n\t            var segment = segments[index];\n\t            var subdivisions = segmentSubdivisions[index];\n\t            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n\t            if (segment.isVisible) {\n\t                if (length <= (l + d)) {\n\t                    return segment.pointAtLength(((fromStart ? 1 : -1) * (length - l)), {\n\t                        precision: precision,\n\t                        subdivisions: subdivisions\n\t                    });\n\t                }\n\n\t                lastVisibleSegment = segment;\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        // if length requested is higher than the length of the path, return last visible segment endpoint\n\t        if (lastVisibleSegment) { return (fromStart ? lastVisibleSegment.end : lastVisibleSegment.start); }\n\n\t        // if no visible segment, return last segment end point (no matter if fromStart or no)\n\t        var lastSegment = segments[numSegments - 1];\n\t        return lastSegment.end.clone();\n\t    },\n\n\t    // Private function.\n\t    pointAtT: function(t) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        var segmentIndex = t.segmentIndex;\n\t        if (segmentIndex < 0) { return segments[0].pointAtT(0); }\n\t        if (segmentIndex >= numSegments) { return segments[numSegments - 1].pointAtT(1); }\n\n\t        var tValue = t.value;\n\t        if (tValue < 0) { tValue = 0; }\n\t        else if (tValue > 1) { tValue = 1; }\n\n\t        return segments[segmentIndex].pointAtT(tValue);\n\t    },\n\n\t    // Default precision\n\t    PRECISION: 3,\n\n\t    // Helper method for adding segments.\n\t    prepareSegment: function(segment, previousSegment, nextSegment) {\n\n\t        // insert after previous segment and before previous segment's next segment\n\t        segment.previousSegment = previousSegment;\n\t        segment.nextSegment = nextSegment;\n\t        if (previousSegment) { previousSegment.nextSegment = segment; }\n\t        if (nextSegment) { nextSegment.previousSegment = segment; }\n\n\t        var updateSubpathStart = segment;\n\t        if (segment.isSubpathStart) {\n\t            segment.subpathStartSegment = segment; // assign self as subpath start segment\n\t            updateSubpathStart = nextSegment; // start updating from next segment\n\t        }\n\n\t        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n\t        if (updateSubpathStart) { this.updateSubpathStartSegment(updateSubpathStart); }\n\n\t        return segment;\n\t    },\n\n\t    // Remove the segment at `index`.\n\t    // Accepts negative indices, from `-1` to `-segments.length`.\n\t    // Throws an error if path has no segments.\n\t    // Throws an error if index is out of range.\n\t    removeSegment: function(index) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { throw new Error('Path has no segments.'); }\n\n\t        if (index < 0) { index = numSegments + index; } // convert negative indices to positive\n\t        if (index >= numSegments || index < 0) { throw new Error('Index out of range.'); }\n\n\t        var removedSegment = segments.splice(index, 1)[0];\n\t        var previousSegment = removedSegment.previousSegment;\n\t        var nextSegment = removedSegment.nextSegment;\n\n\t        // link the previous and next segments together (if present)\n\t        if (previousSegment) { previousSegment.nextSegment = nextSegment; } // may be null\n\t        if (nextSegment) { nextSegment.previousSegment = previousSegment; } // may be null\n\n\t        // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n\t        if (removedSegment.isSubpathStart && nextSegment) { this.updateSubpathStartSegment(nextSegment); }\n\t    },\n\n\t    // Replace the segment at `index` with `arg`.\n\t    // Accepts negative indices, from `-1` to `-segments.length`.\n\t    // Accepts one segment or an array of segments as argument.\n\t    // Throws an error if path has no segments.\n\t    // Throws an error if index is out of range.\n\t    // Throws an error if argument is not a segment or an array of segments.\n\t    replaceSegment: function(index, arg) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { throw new Error('Path has no segments.'); }\n\n\t        if (index < 0) { index = numSegments + index; } // convert negative indices to positive\n\t        if (index >= numSegments || index < 0) { throw new Error('Index out of range.'); }\n\n\t        var currentSegment;\n\n\t        var replacedSegment = segments[index];\n\t        var previousSegment = replacedSegment.previousSegment;\n\t        var nextSegment = replacedSegment.nextSegment;\n\n\t        var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n\t        if (!Array.isArray(arg)) {\n\t            if (!arg || !arg.isSegment) { throw new Error('Segment required.'); }\n\n\t            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n\t            segments.splice(index, 1, currentSegment); // directly replace\n\n\t            if (updateSubpathStart && currentSegment.isSubpathStart) { updateSubpathStart = false; } // already updated by `prepareSegment`\n\n\t        } else {\n\t            // flatten one level deep\n\t            // so we can chain arbitrary Path.createSegment results\n\t            arg = arg.reduce(function(acc, val) {\n\t                return acc.concat(val);\n\t            }, []);\n\n\t            if (!arg[0].isSegment) { throw new Error('Segments required.'); }\n\n\t            segments.splice(index, 1);\n\n\t            var n = arg.length;\n\t            for (var i = 0; i < n; i++) {\n\n\t                var currentArg = arg[i];\n\t                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n\t                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n\t                previousSegment = currentSegment;\n\n\t                if (updateSubpathStart && currentSegment.isSubpathStart) { updateSubpathStart = false; } // already updated by `prepareSegment`\n\t            }\n\t        }\n\n\t        // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n\t        if (updateSubpathStart && nextSegment) { this.updateSubpathStartSegment(nextSegment); }\n\t    },\n\n\t    round: function(precision) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            segment.round(precision);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            segment.scale(sx, sy, origin);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    segmentAt: function(ratio, opt) {\n\n\t        var index = this.segmentIndexAt(ratio, opt);\n\t        if (!index) { return null; }\n\n\t        return this.getSegment(index);\n\t    },\n\n\t    // Accepts negative length.\n\t    segmentAtLength: function(length, opt) {\n\n\t        var index = this.segmentIndexAtLength(length, opt);\n\t        if (!index) { return null; }\n\n\t        return this.getSegment(index);\n\t    },\n\n\t    segmentIndexAt: function(ratio, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        if (ratio < 0) { ratio = 0; }\n\t        if (ratio > 1) { ratio = 1; }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n\t        var pathLength = this.length(localOpt);\n\t        var length = pathLength * ratio;\n\n\t        return this.segmentIndexAtLength(length, localOpt);\n\t    },\n\n\t    // Accepts negative length.\n\t    segmentIndexAtLength: function(length, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var lastVisibleSegmentIndex = null;\n\t        var l = 0; // length so far\n\t        for (var i = 0; i < numSegments; i++) {\n\t            var index = (fromStart ? i : (numSegments - 1 - i));\n\n\t            var segment = segments[index];\n\t            var subdivisions = segmentSubdivisions[index];\n\t            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n\t            if (segment.isVisible) {\n\t                if (length <= (l + d)) { return index; }\n\t                lastVisibleSegmentIndex = index;\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        // if length requested is higher than the length of the path, return last visible segment index\n\t        // if no visible segment, return null\n\t        return lastVisibleSegmentIndex;\n\t    },\n\n\t    // Returns a string that can be used to reconstruct the path.\n\t    // Additional error checking compared to toString (must start with M segment).\n\t    serialize: function() {\n\n\t        if (!this.isValid()) { throw new Error('Invalid path segments.'); }\n\n\t        return this.toString();\n\t    },\n\n\t    // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t    tangentAt: function(ratio, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        if (ratio < 0) { ratio = 0; }\n\t        if (ratio > 1) { ratio = 1; }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n\t        var pathLength = this.length(localOpt);\n\t        var length = pathLength * ratio;\n\n\t        return this.tangentAtLength(length, localOpt);\n\t    },\n\n\t    // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t    // Accepts negative length.\n\t    tangentAtLength: function(length, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var lastValidSegment; // visible AND differentiable (with a tangent)\n\t        var l = 0; // length so far\n\t        for (var i = 0; i < numSegments; i++) {\n\t            var index = (fromStart ? i : (numSegments - 1 - i));\n\n\t            var segment = segments[index];\n\t            var subdivisions = segmentSubdivisions[index];\n\t            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n\t            if (segment.isDifferentiable()) {\n\t                if (length <= (l + d)) {\n\t                    return segment.tangentAtLength(((fromStart ? 1 : -1) * (length - l)), {\n\t                        precision: precision,\n\t                        subdivisions: subdivisions\n\t                    });\n\t                }\n\n\t                lastValidSegment = segment;\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n\t        if (lastValidSegment) {\n\t            var t = (fromStart ? 1 : 0);\n\t            return lastValidSegment.tangentAtT(t);\n\t        }\n\n\t        // if no valid segment, return null\n\t        return null;\n\t    },\n\n\t    // Private function.\n\t    tangentAtT: function(t) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        var segmentIndex = t.segmentIndex;\n\t        if (segmentIndex < 0) { return segments[0].tangentAtT(0); }\n\t        if (segmentIndex >= numSegments) { return segments[numSegments - 1].tangentAtT(1); }\n\n\t        var tValue = t.value;\n\t        if (tValue < 0) { tValue = 0; }\n\t        else if (tValue > 1) { tValue = 1; }\n\n\t        return segments[segmentIndex].tangentAtT(tValue);\n\t    },\n\n\t    toPoints: function(opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\n\t        var points = [];\n\t        var partialPoints = [];\n\t        for (var i = 0; i < numSegments; i++) {\n\t            var segment = segments[i];\n\t            if (segment.isVisible) {\n\t                var currentSegmentSubdivisions = segmentSubdivisions[i];\n\t                if (currentSegmentSubdivisions.length > 0) {\n\t                    var subdivisionPoints = currentSegmentSubdivisions.map(function(curve) {\n\t                        return curve.start;\n\t                    });\n\t                    Array.prototype.push.apply(partialPoints, subdivisionPoints);\n\t                } else {\n\t                    partialPoints.push(segment.start);\n\t                }\n\t            } else if (partialPoints.length > 0) {\n\t                partialPoints.push(segments[i - 1].end);\n\t                points.push(partialPoints);\n\t                partialPoints = [];\n\t            }\n\t        }\n\n\t        if (partialPoints.length > 0) {\n\t            partialPoints.push(this.end);\n\t            points.push(partialPoints);\n\t        }\n\t        return points;\n\t    },\n\n\t    toPolylines: function(opt) {\n\n\t        var polylines = [];\n\t        var points = this.toPoints(opt);\n\t        if (!points) { return null; }\n\t        for (var i = 0, n = points.length; i < n; i++) {\n\t            polylines.push(new Polyline(points[i]));\n\t        }\n\n\t        return polylines;\n\t    },\n\n\t    toString: function() {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\n\t        var pathData = '';\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            pathData += segment.serialize() + ' ';\n\t        }\n\n\t        return pathData.trim();\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            segment.translate(tx, ty);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    // Helper method for updating subpath start of segments, starting with the one provided.\n\t    updateSubpathStartSegment: function(segment) {\n\n\t        var previousSegment = segment.previousSegment; // may be null\n\t        while (segment && !segment.isSubpathStart) {\n\n\t            // assign previous segment's subpath start segment to this segment\n\t            if (previousSegment) { segment.subpathStartSegment = previousSegment.subpathStartSegment; } // may be null\n\t            else { segment.subpathStartSegment = null; } // if segment had no previous segment, assign null - creates an invalid path!\n\n\t            previousSegment = segment;\n\t            segment = segment.nextSegment; // move on to the segment after etc.\n\t        }\n\t    },\n\n\t    // If the path is not valid, insert M 0 0 at the beginning.\n\t    // Path with no segments is considered valid, so nothing is inserted.\n\t    validate: function() {\n\n\t        if (!this.isValid()) { this.insertSegment(0, Path.createSegment('M', 0, 0)); }\n\t        return this;\n\t    }\n\t};\n\n\tObject.defineProperty(Path.prototype, 'start', {\n\t    // Getter for the first visible endpoint of the path.\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; }\n\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            if (segment.isVisible) { return segment.start; }\n\t        }\n\n\t        // if no visible segment, return last segment end point\n\t        return segments[numSegments - 1].end;\n\t    }\n\t});\n\n\tObject.defineProperty(Path.prototype, 'end', {\n\t    // Getter for the last visible endpoint of the path.\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; }\n\n\t        for (var i = numSegments - 1; i >= 0; i--) {\n\n\t            var segment = segments[i];\n\t            if (segment.isVisible) { return segment.end; }\n\t        }\n\n\t        // if no visible segment, return last segment end point\n\t        return segments[numSegments - 1].end;\n\t    }\n\t});\n\n\n\t// Local helper function.\n\t// Use an array of arguments to call a constructor (function called with `new`).\n\t// Adapted from https://stackoverflow.com/a/8843181/2263595\n\t// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n\t// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n\t// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n\t// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\n\tfunction applyToNew(constructor, argsArray) {\n\t    // The `new` keyword can only be applied to functions that take a limited number of arguments.\n\t    // - We can fake that with .bind().\n\t    // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n\t    // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n\t    // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n\t    // We need to pass in a variable number of arguments to the bind() call.\n\t    // - We can use .apply().\n\t    // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\t    // - `thisArg` can still be anything because `new` overwrites it.\n\t    // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n\t    // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\n\t    // The function expects `argsArray[0]` to be `thisArg`.\n\t    // - This means that whatever is sent as the first element will be ignored.\n\t    // - The constructor will only see arguments starting from argsArray[1].\n\t    // - So, a new dummy element is inserted at the start of the array.\n\t    argsArray.unshift(null);\n\n\t    return new (Function.prototype.bind.apply(constructor, argsArray));\n\t}\n\n\t// Path segment interface:\n\tvar segmentPrototype = {\n\n\t    // virtual\n\t    bbox: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    clone: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    closestPoint: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    closestPointLength: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    closestPointNormalizedLength: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n\t    closestPointT: function(p) {\n\n\t        if (this.closestPointNormalizedLength) { return this.closestPointNormalizedLength(p); }\n\n\t        throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n\t    },\n\n\t    // virtual\n\t    closestPointTangent: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    divideAt: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    divideAtLength: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n\t    divideAtT: function(t) {\n\n\t        if (this.divideAt) { return this.divideAt(t); }\n\n\t        throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n\t    },\n\n\t    // virtual\n\t    equals: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    getSubdivisions: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    isDifferentiable: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    isSegment: true,\n\n\t    isSubpathStart: false, // true for Moveto segments\n\n\t    isVisible: true, // false for Moveto segments\n\n\t    // virtual\n\t    length: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n\t    lengthAtT: function(t) {\n\n\t        if (t <= 0) { return 0; }\n\n\t        var length = this.length();\n\n\t        if (t >= 1) { return length; }\n\n\t        return length * t;\n\t    },\n\n\t    nextSegment: null, // needed for subpath start segment updating\n\n\t    // virtual\n\t    pointAt: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    pointAtLength: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n\t    pointAtT: function(t) {\n\n\t        if (this.pointAt) { return this.pointAt(t); }\n\n\t        throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n\t    },\n\n\t    previousSegment: null, // needed to get segment start property\n\n\t    // virtual\n\t    round: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    subpathStartSegment: null, // needed to get Closepath segment end property\n\n\t    // virtual\n\t    scale: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    serialize: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    tangentAt: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    tangentAtLength: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n\t    tangentAtT: function(t) {\n\n\t        if (this.tangentAt) { return this.tangentAt(t); }\n\n\t        throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n\t    },\n\n\t    // virtual\n\t    toString: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    translate: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    }\n\t};\n\n\t// usually directly assigned\n\t// getter for Closepath\n\tObject.defineProperty(segmentPrototype, 'end', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    writable: true\n\t});\n\n\t// always a getter\n\t// always throws error for Moveto\n\tObject.defineProperty(segmentPrototype, 'start', {\n\t    // get a reference to the end point of previous segment\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        if (!this.previousSegment) { throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)'); }\n\n\t        return this.previousSegment.end;\n\t    }\n\t});\n\n\t// virtual\n\tObject.defineProperty(segmentPrototype, 'type', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        throw new Error('Bad segment declaration. No type specified.');\n\t    }\n\t});\n\n\t// Path segment implementations:\n\tvar Lineto = function() {\n\t    var arguments$1 = arguments;\n\n\n\t    var args = [];\n\t    var n = arguments.length;\n\t    for (var i = 0; i < n; i++) {\n\t        args.push(arguments$1[i]);\n\t    }\n\n\t    if (!(this instanceof Lineto)) { // switching context of `this` to Lineto when called without `new`\n\t        return applyToNew(Lineto, args);\n\t    }\n\n\t    if (n === 0) {\n\t        throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n\t    }\n\n\t    var outputArray;\n\n\t    if (args[0] instanceof Line) { // lines provided\n\t        if (n === 1) {\n\t            this.end = args[0].end.clone();\n\t            return this;\n\n\t        } else {\n\t            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n\t        }\n\n\t    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n\t        if (n === 2) {\n\t            this.end = new Point(+args[0], +args[1]);\n\t            return this;\n\n\t        } else if (n < 2) {\n\t            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n\t        } else { // this is a poly-line segment\n\t            var segmentCoords;\n\t            outputArray = [];\n\t            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n\t                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n\t                outputArray.push(applyToNew(Lineto, segmentCoords));\n\t            }\n\t            return outputArray;\n\t        }\n\n\t    } else { // points provided (needs to be last to also cover plain objects with x and y)\n\t        if (n === 1) {\n\t            this.end = new Point(args[0]);\n\t            return this;\n\n\t        } else { // this is a poly-line segment\n\t            var segmentPoint;\n\t            outputArray = [];\n\t            for (i = 0; i < n; i += 1) {\n\n\t                segmentPoint = args[i];\n\t                outputArray.push(new Lineto(segmentPoint));\n\t            }\n\t            return outputArray;\n\t        }\n\t    }\n\t};\n\n\tvar linetoPrototype = {\n\n\t    clone: function() {\n\n\t        return new Lineto(this.end);\n\t    },\n\n\t    divideAt: function(ratio) {\n\n\t        var line = new Line(this.start, this.end);\n\t        var divided = line.divideAt(ratio);\n\t        return [\n\t            new Lineto(divided[0]),\n\t            new Lineto(divided[1])\n\t        ];\n\t    },\n\n\t    divideAtLength: function(length) {\n\n\t        var line = new Line(this.start, this.end);\n\t        var divided = line.divideAtLength(length);\n\t        return [\n\t            new Lineto(divided[0]),\n\t            new Lineto(divided[1])\n\t        ];\n\t    },\n\n\t    getSubdivisions: function() {\n\n\t        return [];\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        if (!this.previousSegment) { return false; }\n\n\t        return !this.start.equals(this.end);\n\t    },\n\n\t    round: function(precision) {\n\n\t        this.end.round(precision);\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        this.end.scale(sx, sy, origin);\n\t        return this;\n\t    },\n\n\t    serialize: function() {\n\n\t        var end = this.end;\n\t        return this.type + ' ' + end.x + ' ' + end.y;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.type + ' ' + this.start + ' ' + this.end;\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        this.end.translate(tx, ty);\n\t        return this;\n\t    }\n\t};\n\n\tObject.defineProperty(linetoPrototype, 'type', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    value: 'L'\n\t});\n\n\tLineto.prototype = extend(segmentPrototype, Line.prototype, linetoPrototype);\n\n\tvar Curveto = function() {\n\t    var arguments$1 = arguments;\n\n\n\t    var args = [];\n\t    var n = arguments.length;\n\t    for (var i = 0; i < n; i++) {\n\t        args.push(arguments$1[i]);\n\t    }\n\n\t    if (!(this instanceof Curveto)) { // switching context of `this` to Curveto when called without `new`\n\t        return applyToNew(Curveto, args);\n\t    }\n\n\t    if (n === 0) {\n\t        throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n\t    }\n\n\t    var outputArray;\n\n\t    if (args[0] instanceof Curve) { // curves provided\n\t        if (n === 1) {\n\t            this.controlPoint1 = args[0].controlPoint1.clone();\n\t            this.controlPoint2 = args[0].controlPoint2.clone();\n\t            this.end = args[0].end.clone();\n\t            return this;\n\n\t        } else {\n\t            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n\t        }\n\n\t    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n\t        if (n === 6) {\n\t            this.controlPoint1 = new Point(+args[0], +args[1]);\n\t            this.controlPoint2 = new Point(+args[2], +args[3]);\n\t            this.end = new Point(+args[4], +args[5]);\n\t            return this;\n\n\t        } else if (n < 6) {\n\t            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n\n\t        } else { // this is a poly-bezier segment\n\t            var segmentCoords;\n\t            outputArray = [];\n\t            for (i = 0; i < n; i += 6) { // coords come in groups of six\n\n\t                segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n\t                outputArray.push(applyToNew(Curveto, segmentCoords));\n\t            }\n\t            return outputArray;\n\t        }\n\n\t    } else { // points provided (needs to be last to also cover plain objects with x and y)\n\t        if (n === 3) {\n\t            this.controlPoint1 = new Point(args[0]);\n\t            this.controlPoint2 = new Point(args[1]);\n\t            this.end = new Point(args[2]);\n\t            return this;\n\n\t        } else if (n < 3) {\n\t            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n\n\t        } else { // this is a poly-bezier segment\n\t            var segmentPoints;\n\t            outputArray = [];\n\t            for (i = 0; i < n; i += 3) { // points come in groups of three\n\n\t                segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n\t                outputArray.push(applyToNew(Curveto, segmentPoints));\n\t            }\n\t            return outputArray;\n\t        }\n\t    }\n\t};\n\n\tvar curvetoPrototype = {\n\n\t    clone: function() {\n\n\t        return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n\t    },\n\n\t    divideAt: function(ratio, opt) {\n\n\t        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t        var divided = curve.divideAt(ratio, opt);\n\t        return [\n\t            new Curveto(divided[0]),\n\t            new Curveto(divided[1])\n\t        ];\n\t    },\n\n\t    divideAtLength: function(length, opt) {\n\n\t        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t        var divided = curve.divideAtLength(length, opt);\n\t        return [\n\t            new Curveto(divided[0]),\n\t            new Curveto(divided[1])\n\t        ];\n\t    },\n\n\t    divideAtT: function(t) {\n\n\t        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t        var divided = curve.divideAtT(t);\n\t        return [\n\t            new Curveto(divided[0]),\n\t            new Curveto(divided[1])\n\t        ];\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        if (!this.previousSegment) { return false; }\n\n\t        var start = this.start;\n\t        var control1 = this.controlPoint1;\n\t        var control2 = this.controlPoint2;\n\t        var end = this.end;\n\n\t        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n\t    },\n\n\t    round: function(precision) {\n\n\t        this.controlPoint1.round(precision);\n\t        this.controlPoint2.round(precision);\n\t        this.end.round(precision);\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        this.controlPoint1.scale(sx, sy, origin);\n\t        this.controlPoint2.scale(sx, sy, origin);\n\t        this.end.scale(sx, sy, origin);\n\t        return this;\n\t    },\n\n\t    serialize: function() {\n\n\t        var c1 = this.controlPoint1;\n\t        var c2 = this.controlPoint2;\n\t        var end = this.end;\n\t        return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        this.controlPoint1.translate(tx, ty);\n\t        this.controlPoint2.translate(tx, ty);\n\t        this.end.translate(tx, ty);\n\t        return this;\n\t    }\n\t};\n\n\tObject.defineProperty(curvetoPrototype, 'type', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    value: 'C'\n\t});\n\n\tCurveto.prototype = extend(segmentPrototype, Curve.prototype, curvetoPrototype);\n\n\tvar Moveto = function() {\n\t    var arguments$1 = arguments;\n\n\n\t    var args = [];\n\t    var n = arguments.length;\n\t    for (var i = 0; i < n; i++) {\n\t        args.push(arguments$1[i]);\n\t    }\n\n\t    if (!(this instanceof Moveto)) { // switching context of `this` to Moveto when called without `new`\n\t        return applyToNew(Moveto, args);\n\t    }\n\n\t    if (n === 0) {\n\t        throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n\t    }\n\n\t    var outputArray;\n\n\t    if (args[0] instanceof Line) { // lines provided\n\t        if (n === 1) {\n\t            this.end = args[0].end.clone();\n\t            return this;\n\n\t        } else {\n\t            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n\t        }\n\n\t    } else if (args[0] instanceof Curve) { // curves provided\n\t        if (n === 1) {\n\t            this.end = args[0].end.clone();\n\t            return this;\n\n\t        } else {\n\t            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n\t        }\n\n\t    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n\t        if (n === 2) {\n\t            this.end = new Point(+args[0], +args[1]);\n\t            return this;\n\n\t        } else if (n < 2) {\n\t            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n\t        } else { // this is a moveto-with-subsequent-poly-line segment\n\t            var segmentCoords;\n\t            outputArray = [];\n\t            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n\t                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n\t                if (i === 0) { outputArray.push(applyToNew(Moveto, segmentCoords)); }\n\t                else { outputArray.push(applyToNew(Lineto, segmentCoords)); }\n\t            }\n\t            return outputArray;\n\t        }\n\n\t    } else { // points provided (needs to be last to also cover plain objects with x and y)\n\t        if (n === 1) {\n\t            this.end = new Point(args[0]);\n\t            return this;\n\n\t        } else { // this is a moveto-with-subsequent-poly-line segment\n\t            var segmentPoint;\n\t            outputArray = [];\n\t            for (i = 0; i < n; i += 1) { // points come one by one\n\n\t                segmentPoint = args[i];\n\t                if (i === 0) { outputArray.push(new Moveto(segmentPoint)); }\n\t                else { outputArray.push(new Lineto(segmentPoint)); }\n\t            }\n\t            return outputArray;\n\t        }\n\t    }\n\t};\n\n\tvar movetoPrototype = {\n\n\t    bbox: function() {\n\n\t        return null;\n\t    },\n\n\t    clone: function() {\n\n\t        return new Moveto(this.end);\n\t    },\n\n\t    closestPoint: function() {\n\n\t        return this.end.clone();\n\t    },\n\n\t    closestPointNormalizedLength: function() {\n\n\t        return 0;\n\t    },\n\n\t    closestPointLength: function() {\n\n\t        return 0;\n\t    },\n\n\t    closestPointT: function() {\n\n\t        return 1;\n\t    },\n\n\t    closestPointTangent: function() {\n\n\t        return null;\n\t    },\n\n\t    divideAt: function() {\n\n\t        return [\n\t            this.clone(),\n\t            this.clone()\n\t        ];\n\t    },\n\n\t    divideAtLength: function() {\n\n\t        return [\n\t            this.clone(),\n\t            this.clone()\n\t        ];\n\t    },\n\n\t    equals: function(m) {\n\n\t        return this.end.equals(m.end);\n\t    },\n\n\t    getSubdivisions: function() {\n\n\t        return [];\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        return false;\n\t    },\n\n\t    isSubpathStart: true,\n\n\t    isVisible: false,\n\n\t    length: function() {\n\n\t        return 0;\n\t    },\n\n\t    lengthAtT: function() {\n\n\t        return 0;\n\t    },\n\n\t    pointAt: function() {\n\n\t        return this.end.clone();\n\t    },\n\n\t    pointAtLength: function() {\n\n\t        return this.end.clone();\n\t    },\n\n\t    pointAtT: function() {\n\n\t        return this.end.clone();\n\t    },\n\n\t    round: function(precision) {\n\n\t        this.end.round(precision);\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        this.end.scale(sx, sy, origin);\n\t        return this;\n\t    },\n\n\t    serialize: function() {\n\n\t        var end = this.end;\n\t        return this.type + ' ' + end.x + ' ' + end.y;\n\t    },\n\n\t    tangentAt: function() {\n\n\t        return null;\n\t    },\n\n\t    tangentAtLength: function() {\n\n\t        return null;\n\t    },\n\n\t    tangentAtT: function() {\n\n\t        return null;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.type + ' ' + this.end;\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        this.end.translate(tx, ty);\n\t        return this;\n\t    }\n\t};\n\n\tObject.defineProperty(movetoPrototype, 'start', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        throw new Error('Illegal access. Moveto segments should not need a start property.');\n\t    }\n\t});\n\n\tObject.defineProperty(movetoPrototype, 'type', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    value: 'M'\n\t});\n\n\tMoveto.prototype = extend(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\n\tvar Closepath = function() {\n\t    var arguments$1 = arguments;\n\n\n\t    var args = [];\n\t    var n = arguments.length;\n\t    for (var i = 0; i < n; i++) {\n\t        args.push(arguments$1[i]);\n\t    }\n\n\t    if (!(this instanceof Closepath)) { // switching context of `this` to Closepath when called without `new`\n\t        return applyToNew(Closepath, args);\n\t    }\n\n\t    if (n > 0) {\n\t        throw new Error('Closepath constructor expects no arguments.');\n\t    }\n\n\t    return this;\n\t};\n\n\tvar closepathPrototype = {\n\n\t    clone: function() {\n\n\t        return new Closepath();\n\t    },\n\n\t    divideAt: function(ratio) {\n\n\t        var line = new Line(this.start, this.end);\n\t        var divided = line.divideAt(ratio);\n\t        return [\n\t            // if we didn't actually cut into the segment, first divided part can stay as Z\n\t            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n\t            new Lineto(divided[1])\n\t        ];\n\t    },\n\n\t    divideAtLength: function(length) {\n\n\t        var line = new Line(this.start, this.end);\n\t        var divided = line.divideAtLength(length);\n\t        return [\n\t            // if we didn't actually cut into the segment, first divided part can stay as Z\n\t            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n\t            new Lineto(divided[1])\n\t        ];\n\t    },\n\n\t    getSubdivisions: function() {\n\n\t        return [];\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        if (!this.previousSegment || !this.subpathStartSegment) { return false; }\n\n\t        return !this.start.equals(this.end);\n\t    },\n\n\t    round: function() {\n\n\t        return this;\n\t    },\n\n\t    scale: function() {\n\n\t        return this;\n\t    },\n\n\t    serialize: function() {\n\n\t        return this.type;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.type + ' ' + this.start + ' ' + this.end;\n\t    },\n\n\t    translate: function() {\n\n\t        return this;\n\t    }\n\t};\n\n\tObject.defineProperty(closepathPrototype, 'end', {\n\t    // get a reference to the end point of subpath start segment\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        if (!this.subpathStartSegment) { throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)'); }\n\n\t        return this.subpathStartSegment.end;\n\t    }\n\t});\n\n\tObject.defineProperty(closepathPrototype, 'type', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    value: 'Z'\n\t});\n\n\tClosepath.prototype = extend(segmentPrototype, Line.prototype, closepathPrototype);\n\n\tvar segmentTypes = Path.segmentTypes = {\n\t    L: Lineto,\n\t    C: Curveto,\n\t    M: Moveto,\n\t    Z: Closepath,\n\t    z: Closepath\n\t};\n\n\tPath.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\n\n\tPath.isDataSupported = function(data) {\n\n\t    if (typeof data !== 'string') { return false; }\n\t    return this.regexSupportedData.test(data);\n\t};\n\n\tvar bezier = {\n\n\t    // Cubic Bezier curve path through points.\n\t    // @deprecated\n\t    // @param {array} points Array of points through which the smooth line will go.\n\t    // @return {array} SVG Path commands as an array\n\t    curveThroughPoints: function(points) {\n\n\t        console.warn('deprecated');\n\n\t        return new Path(Curve.throughPoints(points)).serialize();\n\t    },\n\n\t    // Get open-ended Bezier Spline Control Points.\n\t    // @deprecated\n\t    // @param knots Input Knot Bezier spline points (At least two points!).\n\t    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n\t    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n\t    getCurveControlPoints: function(knots) {\n\n\t        console.warn('deprecated');\n\n\t        var firstControlPoints = [];\n\t        var secondControlPoints = [];\n\t        var n = knots.length - 1;\n\t        var i;\n\n\t        // Special case: Bezier curve should be a straight line.\n\t        if (n == 1) {\n\t            // 3P1 = 2P0 + P3\n\t            firstControlPoints[0] = new Point(\n\t                (2 * knots[0].x + knots[1].x) / 3,\n\t                (2 * knots[0].y + knots[1].y) / 3\n\t            );\n\n\t            // P2 = 2P1  P0\n\t            secondControlPoints[0] = new Point(\n\t                2 * firstControlPoints[0].x - knots[0].x,\n\t                2 * firstControlPoints[0].y - knots[0].y\n\t            );\n\n\t            return [firstControlPoints, secondControlPoints];\n\t        }\n\n\t        // Calculate first Bezier control points.\n\t        // Right hand side vector.\n\t        var rhs = [];\n\n\t        // Set right hand side X values.\n\t        for (i = 1; i < n - 1; i++) {\n\t            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n\t        }\n\n\t        rhs[0] = knots[0].x + 2 * knots[1].x;\n\t        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n\t        // Get first control points X-values.\n\t        var x = this.getFirstControlPoints(rhs);\n\n\t        // Set right hand side Y values.\n\t        for (i = 1; i < n - 1; ++i) {\n\t            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n\t        }\n\n\t        rhs[0] = knots[0].y + 2 * knots[1].y;\n\t        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n\t        // Get first control points Y-values.\n\t        var y = this.getFirstControlPoints(rhs);\n\n\t        // Fill output arrays.\n\t        for (i = 0; i < n; i++) {\n\t            // First control point.\n\t            firstControlPoints.push(new Point(x[i], y[i]));\n\n\t            // Second control point.\n\t            if (i < n - 1) {\n\t                secondControlPoints.push(new Point(\n\t                    2 * knots [i + 1].x - x[i + 1],\n\t                    2 * knots[i + 1].y - y[i + 1]\n\t                ));\n\n\t            } else {\n\t                secondControlPoints.push(new Point(\n\t                    (knots[n].x + x[n - 1]) / 2,\n\t                    (knots[n].y + y[n - 1]) / 2)\n\t                );\n\t            }\n\t        }\n\n\t        return [firstControlPoints, secondControlPoints];\n\t    },\n\n\t    // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n\t    // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n\t    // @deprecated\n\t    // @param control points (start, control start, control end, end)\n\t    // @return a function that accepts t and returns 2 curves.\n\t    getCurveDivider: function(p0, p1, p2, p3) {\n\n\t        console.warn('deprecated');\n\n\t        var curve = new Curve(p0, p1, p2, p3);\n\n\t        return function divideCurve(t) {\n\n\t            var divided = curve.divide(t);\n\n\t            return [{\n\t                p0: divided[0].start,\n\t                p1: divided[0].controlPoint1,\n\t                p2: divided[0].controlPoint2,\n\t                p3: divided[0].end\n\t            }, {\n\t                p0: divided[1].start,\n\t                p1: divided[1].controlPoint1,\n\t                p2: divided[1].controlPoint2,\n\t                p3: divided[1].end\n\t            }];\n\t        };\n\t    },\n\n\t    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n\t    // @deprecated\n\t    // @param rhs Right hand side vector.\n\t    // @return Solution vector.\n\t    getFirstControlPoints: function(rhs) {\n\n\t        console.warn('deprecated');\n\n\t        var n = rhs.length;\n\t        // `x` is a solution vector.\n\t        var x = [];\n\t        var tmp = [];\n\t        var b = 2.0;\n\n\t        x[0] = rhs[0] / b;\n\n\t        // Decomposition and forward substitution.\n\t        for (var i = 1; i < n; i++) {\n\t            tmp[i] = 1 / b;\n\t            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n\t            x[i] = (rhs[i] - x[i - 1]) / b;\n\t        }\n\n\t        for (i = 1; i < n; i++) {\n\t            // Backsubstitution.\n\t            x[n - i - 1] -= tmp[n - i] * x[n - i];\n\t        }\n\n\t        return x;\n\t    },\n\n\t    // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n\t    // a parametric curve x = x(t)/w(t), y = y(t)/w(t), nd the parameter value t\n\t    // which corresponds to that point.\n\t    // @deprecated\n\t    // @param control points (start, control start, control end, end)\n\t    // @return a function that accepts a point and returns t.\n\t    getInversionSolver: function(p0, p1, p2, p3) {\n\n\t        console.warn('deprecated');\n\n\t        var curve = new Curve(p0, p1, p2, p3);\n\n\t        return function solveInversion(p) {\n\n\t            return curve.closestPointT(p);\n\t        };\n\t    }\n\t};\n\n\tvar Polygon = function(points) {\n\n\t    if (!(this instanceof Polygon)) {\n\t        return new Polygon(points);\n\t    }\n\n\t    if (typeof points === 'string') {\n\t        return new Polygon.parse(points);\n\t    }\n\n\t    this.points = (Array.isArray(points) ? points.map(Point) : []);\n\t};\n\n\tPolygon.parse = function(svgString) {\n\t    return new Polygon(parsePoints(svgString));\n\t};\n\n\tPolygon.fromRect = function(rect) {\n\t    return new Polygon([\n\t        rect.topLeft(),\n\t        rect.topRight(),\n\t        rect.bottomRight(),\n\t        rect.bottomLeft()\n\t    ]);\n\t};\n\n\tPolygon.prototype = extend(Polyline.prototype, {\n\n\t    type: types.Polygon,\n\n\t    clone: function() {\n\t        return new Polygon(clonePoints(this.points));\n\t    },\n\n\t    convexHull: function() {\n\t        return new Polygon(convexHull(this.points));\n\t    },\n\n\t    lengthPoints: function() {\n\t        var ref = this;\n\t        var start = ref.start;\n\t        var end = ref.end;\n\t        var points = ref.points;\n\t        if (points.length <= 1 || start.equals(end)) { return points; }\n\t        return points.concat( [start.clone()]);\n\t    }\n\n\t});\n\n\tfunction exists(shape1, shape2, shape1opt, shape2opt) {\n\t    switch (shape1.type) {\n\t        case types.Line: {\n\t            switch (shape2.type) {\n\t                case types.Line: {\n\t                    return lineWithLine(shape1, shape2);\n\t                }\n\t            }\n\t            break;\n\t        }\n\t        case types.Ellipse: {\n\t            switch (shape2.type) {\n\t                case types.Line: {\n\t                    return ellipseWithLine(shape1, shape2);\n\t                }\n\t                case types.Ellipse: {\n\t                    return ellipseWithEllipse(shape1, shape2);\n\t                }\n\t            }\n\t            break;\n\t        }\n\t        case types.Rect: {\n\t            switch (shape2.type) {\n\t                case types.Line: {\n\t                    return rectWithLine(shape1, shape2);\n\t                }\n\t                case types.Ellipse: {\n\t                    return rectWithEllipse(shape1, shape2);\n\t                }\n\t                case types.Rect: {\n\t                    return rectWithRect(shape1, shape2);\n\t                }\n\t            }\n\t            break;\n\t        }\n\t        case types.Polyline: {\n\t            switch (shape2.type) {\n\t                case types.Line: {\n\t                    return polylineWithLine(shape1, shape2);\n\t                }\n\t                case types.Ellipse: {\n\t                    return polylineWithEllipse(shape1, shape2);\n\t                }\n\t                case types.Rect: {\n\t                    return polylineWithRect(shape1, shape2);\n\t                }\n\t                case types.Polyline: {\n\t                    return polylineWithPolyline(shape1, shape2);\n\t                }\n\t            }\n\t            break;\n\t        }\n\t        case types.Polygon: {\n\t            switch (shape2.type) {\n\t                case types.Line: {\n\t                    return polygonWithLine(shape1, shape2);\n\t                }\n\t                case types.Ellipse: {\n\t                    return polygonWithEllipse(shape1, shape2);\n\t                }\n\t                case types.Rect: {\n\t                    return polygonWithRect(shape1, shape2);\n\t                }\n\t                case types.Polyline: {\n\t                    return polygonWithPolyline(shape1, shape2);\n\t                }\n\t                case types.Polygon: {\n\t                    return polygonWithPolygon(shape1, shape2);\n\t                }\n\t            }\n\t            break;\n\t        }\n\t        case types.Path: {\n\t            switch (shape2.type) {\n\t                case types.Line: {\n\t                    return pathWithLine(shape1, shape2, shape1opt);\n\t                }\n\t                case types.Ellipse: {\n\t                    return pathWithEllipse(shape1, shape2, shape1opt);\n\t                }\n\t                case types.Rect: {\n\t                    return pathWithRect(shape1, shape2, shape1opt);\n\t                }\n\t                case types.Polyline: {\n\t                    return pathWithPolyline(shape1, shape2, shape1opt);\n\t                }\n\t                case types.Polygon: {\n\t                    return pathWithPolygon(shape1, shape2, shape1opt);\n\t                }\n\t                case types.Path: {\n\t                    return pathWithPath(shape1, shape2, shape1opt, shape2opt);\n\t                }\n\t            }\n\t            break;\n\t        }\n\t    }\n\t    // None of the cases above\n\t    switch (shape2.type) {\n\t        case types.Ellipse:\n\t        case types.Rect:\n\t        case types.Polyline:\n\t        case types.Polygon:\n\t        case types.Path: {\n\t            return exists(shape2, shape1, shape2opt, shape1opt);\n\t        }\n\t        default: {\n\t            throw Error((\"The intersection for \" + shape1 + \" and \" + shape2 + \" could not be found.\"));\n\t        }\n\t    }\n\t}\n\n\t/* Line */\n\n\tfunction lineWithLine(line1, line2) {\n\t    var x1 = line1.start.x;\n\t    var y1 = line1.start.y;\n\t    var x2 = line1.end.x;\n\t    var y2 = line1.end.y;\n\t    var x3 = line2.start.x;\n\t    var y3 = line2.start.y;\n\t    var x4 = line2.end.x;\n\t    var y4 = line2.end.y;\n\t    var s1x = x2 - x1;\n\t    var s1y = y2 - y1;\n\t    var s2x = x4 - x3;\n\t    var s2y = y4 - y3;\n\t    var s3x = x1 - x3;\n\t    var s3y = y1 - y3;\n\t    var p = s1x * s2y - s2x * s1y;\n\t    var s = (s1x * s3y - s1y * s3x) / p;\n\t    var t = (s2x * s3y - s2y * s3x) / p;\n\t    return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n\t}\n\n\t/* Ellipse */\n\n\tfunction ellipseWithLine(ellipse, line) {\n\t    var rex = ellipse.a;\n\t    var rey = ellipse.b;\n\t    var xe = ellipse.x;\n\t    var ye = ellipse.y;\n\t    var x1 = line.start.x - xe;\n\t    var x2 = line.end.x - xe;\n\t    var y1 = line.start.y - ye;\n\t    var y2 = line.end.y - ye;\n\t    var rex_2 = rex * rex;\n\t    var rey_2 = rey * rey;\n\t    var dx = x2 - x1;\n\t    var dy = y2 - y1;\n\t    var A = dx * dx / rex_2 + dy * dy / rey_2;\n\t    var B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;\n\t    var C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;\n\t    var D = B * B - 4 * A * C;\n\t    if (D === 0) {\n\t        var t = -B / 2 / A;\n\t        return t >= 0 && t <= 1;\n\t    } else if (D > 0) {\n\t        var sqrt = Math.sqrt(D);\n\t        var t1 = (-B + sqrt) / 2 / A;\n\t        var t2 = (-B - sqrt) / 2 / A;\n\t        return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);\n\t    }\n\t    return false;\n\t}\n\n\tfunction ellipseWithEllipse(ellipse1, ellipse2) {\n\t    return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);\n\t}\n\n\t/* Rect */\n\n\tfunction rectWithLine(rect, line) {\n\t    var start = line.start;\n\t    var end = line.end;\n\t    var x = rect.x;\n\t    var y = rect.y;\n\t    var width = rect.width;\n\t    var height = rect.height;\n\t    if (\n\t        (start.x > x + width && end.x > x + width)\n\t        || (start.x < x && end.x < x)\n\t        || (start.y > y + height && end.y > y + height)\n\t        || (start.y < y && end.y < y)\n\t    ) {\n\t        return false;\n\t    }\n\t    if (rect.containsPoint(line.start) || rect.containsPoint(line.end)) {\n\t        return true;\n\t    }\n\t    return lineWithLine(rect.topLine(), line)\n\t        || lineWithLine(rect.rightLine(), line)\n\t        || lineWithLine(rect.bottomLine(), line)\n\t        || lineWithLine(rect.leftLine(), line);\n\t}\n\n\tfunction rectWithEllipse(rect, ellipse) {\n\t    if (!rectWithRect(rect, Rect.fromEllipse(ellipse))) { return false; }\n\t    return polygonWithEllipse(Polygon.fromRect(rect), ellipse);\n\t}\n\n\tfunction rectWithRect(rect1, rect2) {\n\t    return rect1.x < rect2.x + rect2.width\n\t        && rect1.x + rect1.width > rect2.x\n\t        && rect1.y < rect2.y + rect2.height\n\t        && rect1.y + rect1.height > rect2.y;\n\t}\n\n\t/* Polyline */\n\n\tfunction polylineWithLine(polyline, line) {\n\t    return _polylineWithLine(polyline, line, { interior: false });\n\t}\n\n\tfunction polylineWithEllipse(polyline, ellipse) {\n\t    return _polylineWithEllipse(polyline, ellipse, { interior: false });\n\t}\n\n\tfunction polylineWithRect(polyline, rect) {\n\t    return _polylineWithRect(polyline, rect, { interior: false });\n\t}\n\n\tfunction polylineWithPolyline(polyline1, polyline2) {\n\t    return _polylineWithPolyline(polyline1, polyline2, { interior: false });\n\t}\n\n\t/* Polygon */\n\n\tfunction polygonWithLine(polygon, line) {\n\t    return _polylineWithLine(polygon, line, { interior: true });\n\t}\n\n\tfunction polygonWithEllipse(polygon, ellipse) {\n\t    return _polylineWithEllipse(polygon, ellipse, { interior: true });\n\t}\n\n\tfunction polygonWithRect(polygon, rect) {\n\t    return _polylineWithRect(polygon, rect, { interior: true });\n\t}\n\n\tfunction polygonWithPolyline(polygon, polyline) {\n\t    return _polylineWithPolyline(polygon, polyline, { interior: true });\n\t}\n\n\tfunction polygonWithPolygon(polygon1, polygon2) {\n\t    return _polylineWithPolygon(polygon1, polygon2, { interior: true });\n\t}\n\n\t/* Path */\n\n\tfunction pathWithLine(path, line, pathOpt) {\n\t    return path.getSubpaths().some(function (subpath) {\n\t        var ref = subpath.toPolylines(pathOpt);\n\t        var polyline = ref[0];\n\t        var ref$1 = subpath.getSegment(-1);\n\t        var type = ref$1.type;\n\t        if (type === 'Z') {\n\t            return polygonWithLine(polyline, line);\n\t        } else {\n\t            return polylineWithLine(polyline, line);\n\t        }\n\t    });\n\t}\n\n\tfunction pathWithEllipse(path, ellipse, pathOpt) {\n\t    return path.getSubpaths().some(function (subpath) {\n\t        var ref = subpath.toPolylines(pathOpt);\n\t        var polyline = ref[0];\n\t        var ref$1 = subpath.getSegment(-1);\n\t        var type = ref$1.type;\n\t        if (type === 'Z') {\n\t            return polygonWithEllipse(polyline, ellipse);\n\t        } else {\n\t            return polylineWithEllipse(polyline, ellipse);\n\t        }\n\t    });\n\t}\n\n\tfunction pathWithRect(path, rect, pathOpt) {\n\t    return pathWithPolygon(path, Polygon.fromRect(rect), pathOpt);\n\t}\n\n\tfunction pathWithPolyline(path, polyline, pathOpt) {\n\t    return _pathWithPolyline(path, polyline, pathOpt, { interior: false });\n\t}\n\n\tfunction pathWithPolygon(path, polygon, pathOpt) {\n\t    return _pathWithPolyline(path, polygon, pathOpt, { interior: true });\n\t}\n\n\tfunction pathWithPath(path1, path2, pathOpt1, pathOpt2) {\n\t    return path1.getSubpaths().some(function (subpath) {\n\t        var ref = subpath.toPolylines(pathOpt1);\n\t        var polyline1 = ref[0];\n\t        var ref$1 = subpath.getSegment(-1);\n\t        var type = ref$1.type;\n\t        if (type === 'Z') {\n\t            return pathWithPolygon(path2, polyline1, pathOpt2);\n\t        } else {\n\t            return pathWithPolyline(path2, polyline1, pathOpt2);\n\t        }\n\t    });\n\t}\n\n\tfunction _polylineWithLine(polyline, line, opt) {\n\t    if ( opt === void 0 ) opt = {};\n\n\t    var interior = opt.interior; if ( interior === void 0 ) interior = false;\n\t    var thisPoints;\n\t    if (interior) {\n\t        if (polyline.containsPoint(line.start)) {\n\t            // If any point of the polyline lies inside this polygon (interior = true)\n\t            // there is an intersection (we've chosen the start point)\n\t            return true;\n\t        }\n\t        var start = polyline.start;\n\t        var end = polyline.end;\n\t        var points = polyline.points;\n\t        thisPoints = end.equals(start) ? points : points.concat( [start]);\n\t    } else {\n\t        thisPoints = polyline.points;\n\t    }\n\t    var length = thisPoints.length;\n\t    var segment = new Line();\n\t    for (var i = 0; i < length - 1; i++) {\n\t        segment.start = thisPoints[i];\n\t        segment.end = thisPoints[i + 1];\n\t        if (lineWithLine(line, segment)) {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\n\tfunction _polylineWithEllipse(polyline, ellipse, opt) {\n\t    if ( opt === void 0 ) opt = {};\n\n\t    var start = polyline.start;\n\t    var end = polyline.end;\n\t    var points = polyline.points;\n\t    if (ellipse.containsPoint(start)) {\n\t        return true;\n\t    }\n\t    var thisPoints;\n\t    var interior = opt.interior; if ( interior === void 0 ) interior = false;\n\t    if (interior) {\n\t        if (polyline.containsPoint(ellipse.center())) {\n\t            // If any point of the ellipse lies inside this polygon (interior = true)\n\t            // there is an intersection (we've chosen the center point)\n\t            return true;\n\t        }\n\t        thisPoints = end.equals(start) ? points : points.concat( [start]);\n\t    } else {\n\t        thisPoints = points;\n\t    }\n\n\t    var length = thisPoints.length;\n\t    var segment = new Line();\n\t    for (var i = 0; i < length - 1; i++) {\n\t        segment.start = thisPoints[i];\n\t        segment.end = thisPoints[i + 1];\n\t        if (ellipseWithLine(ellipse, segment)) {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\n\tfunction _polylineWithRect(polyline, rect, opt) {\n\t    var polygon = Polygon.fromRect(rect);\n\t    return _polylineWithPolygon(polyline, polygon, opt);\n\t}\n\n\tfunction _pathWithPolyline(path, polyline1, pathOpt, opt) {\n\t    return path.getSubpaths().some(function (subpath) {\n\t        var ref = subpath.toPolylines(pathOpt);\n\t        var polyline2 = ref[0];\n\t        var ref$1 = subpath.getSegment(-1);\n\t        var type = ref$1.type;\n\t        if (type === 'Z') {\n\t            return _polylineWithPolygon(polyline1, polyline2, opt);\n\t        } else {\n\t            return _polylineWithPolyline(polyline1, polyline2, opt);\n\t        }\n\t    });\n\t}\n\n\tfunction _polylineWithPolyline(polyline1, polyline2, opt) {\n\t    if ( opt === void 0 ) opt = {};\n\n\t    var interior = opt.interior; if ( interior === void 0 ) interior = false;\n\t    var thisPolyline;\n\t    if (interior) {\n\t        var start = polyline2.start;\n\t        if (polyline1.containsPoint(start)) {\n\t            // If any point of the polyline lies inside this polygon (interior = true)\n\t            // there is an intersection (we've chosen the start point)\n\t            return true;\n\t        }\n\t        thisPolyline = polyline1.clone().close();\n\t    } else {\n\t        thisPolyline = polyline1;\n\t    }\n\t    var otherPoints = polyline2.points;\n\t    var length = otherPoints.length;\n\t    var segment = new Line();\n\t    for (var i = 0; i < length - 1; i++) {\n\t        segment.start = otherPoints[i];\n\t        segment.end = otherPoints[i + 1];\n\t        if (polylineWithLine(thisPolyline, segment)) {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\n\tfunction _polylineWithPolygon(polyline, polygon, opt) {\n\t    return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);\n\t}\n\n\tfunction _ellipsesIntersection(e1, w1, e2, w2) {\n\t    var cos = Math.cos;\n\t    var sin = Math.sin;\n\t    var sinW1 = sin(w1);\n\t    var cosW1 = cos(w1);\n\t    var sinW2 = sin(w2);\n\t    var cosW2 = cos(w2);\n\t    var sinW1s = sinW1 * sinW1;\n\t    var cosW1s = cosW1 * cosW1;\n\t    var sinCos1 = sinW1 * cosW1;\n\t    var sinW2s = sinW2 * sinW2;\n\t    var cosW2s = cosW2 * cosW2;\n\t    var sinCos2 = sinW2 * cosW2;\n\t    var a1s = e1.a * e1.a;\n\t    var b1s = e1.b * e1.b;\n\t    var a2s = e2.a * e2.a;\n\t    var b2s = e2.b * e2.b;\n\t    var A1 = a1s * sinW1s + b1s * cosW1s;\n\t    var A2 = a2s * sinW2s + b2s * cosW2s;\n\t    var B1 = a1s * cosW1s + b1s * sinW1s;\n\t    var B2 = a2s * cosW2s + b2s * sinW2s;\n\t    var C1 = 2 * (b1s - a1s) * sinCos1;\n\t    var C2 = 2 * (b2s - a2s) * sinCos2;\n\t    var D1 = (-2 * A1 * e1.x - C1 * e1.y);\n\t    var D2 = (-2 * A2 * e2.x - C2 * e2.y);\n\t    var E1 = (-C1 * e1.x - 2 * B1 * e1.y);\n\t    var E2 = (-C2 * e2.x - 2 * B2 * e2.y);\n\t    var F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;\n\t    var F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;\n\n\t    C1 = C1 / 2;\n\t    C2 = C2 / 2;\n\t    D1 = D1 / 2;\n\t    D2 = D2 / 2;\n\t    E1 = E1 / 2;\n\t    E2 = E2 / 2;\n\n\t    var l3 = det3([\n\t        [A1, C1, D1],\n\t        [C1, B1, E1],\n\t        [D1, E1, F1]\n\t    ]);\n\t    var l0 = det3([\n\t        [A2, C2, D2],\n\t        [C2, B2, E2],\n\t        [D2, E2, F2]\n\t    ]);\n\t    var l2 = 0.33333333 * (det3([\n\t        [A2, C1, D1],\n\t        [C2, B1, E1],\n\t        [D2, E1, F1]\n\t    ]) + det3([\n\t        [A1, C2, D1],\n\t        [C1, B2, E1],\n\t        [D1, E2, F1]\n\t    ]) + det3([\n\t        [A1, C1, D2],\n\t        [C1, B1, E2],\n\t        [D1, E1, F2]\n\t    ]));\n\t    var l1 = 0.33333333 * (det3([\n\t        [A1, C2, D2],\n\t        [C1, B2, E2],\n\t        [D1, E2, F2]\n\t    ]) + det3([\n\t        [A2, C1, D2],\n\t        [C2, B1, E2],\n\t        [D2, E1, F2]\n\t    ]) + det3([\n\t        [A2, C2, D1],\n\t        [C2, B2, E1],\n\t        [D2, E2, F1]\n\t    ]));\n\n\t    var delta1 = det2([\n\t        [l3, l2],\n\t        [l2, l1]\n\t    ]);\n\t    var delta2 = det2([\n\t        [l3, l1],\n\t        [l2, l0]\n\t    ]);\n\t    var delta3 = det2([\n\t        [l2, l1],\n\t        [l1, l0]\n\t    ]);\n\n\t    var dP = det2([\n\t        [2 * delta1, delta2],\n\t        [delta2, 2 * delta3]\n\t    ]);\n\n\t    if (dP > 0 && (l1 > 0 || l2 > 0)) {\n\t        return false;\n\t    }\n\t    return true;\n\t}\n\n\tfunction det2(m) {\n\t    return m[0][0] * m[1][1] - m[0][1] * m[1][0];\n\t}\n\n\tfunction det3(m) {\n\t    return m[0][0] * m[1][1] * m[2][2] -\n\t        m[0][0] * m[1][2] * m[2][1] -\n\t        m[0][1] * m[1][0] * m[2][2] +\n\t        m[0][1] * m[1][2] * m[2][0] +\n\t        m[0][2] * m[1][0] * m[2][1] -\n\t        m[0][2] * m[1][1] * m[2][0];\n\t}\n\n\tvar _intersection = ({\n\t\texists: exists,\n\t\tlineWithLine: lineWithLine,\n\t\tellipseWithLine: ellipseWithLine,\n\t\tellipseWithEllipse: ellipseWithEllipse,\n\t\trectWithLine: rectWithLine,\n\t\trectWithEllipse: rectWithEllipse,\n\t\trectWithRect: rectWithRect,\n\t\tpolylineWithLine: polylineWithLine,\n\t\tpolylineWithEllipse: polylineWithEllipse,\n\t\tpolylineWithRect: polylineWithRect,\n\t\tpolylineWithPolyline: polylineWithPolyline,\n\t\tpolygonWithLine: polygonWithLine,\n\t\tpolygonWithEllipse: polygonWithEllipse,\n\t\tpolygonWithRect: polygonWithRect,\n\t\tpolygonWithPolyline: polygonWithPolyline,\n\t\tpolygonWithPolygon: polygonWithPolygon,\n\t\tpathWithLine: pathWithLine,\n\t\tpathWithEllipse: pathWithEllipse,\n\t\tpathWithRect: pathWithRect,\n\t\tpathWithPolyline: pathWithPolyline,\n\t\tpathWithPolygon: pathWithPolygon,\n\t\tpathWithPath: pathWithPath\n\t});\n\n\t// Geometry library.\n\tvar intersection = _intersection;\n\n\tvar g = ({\n\t\tintersection: intersection,\n\t\tscale: scale,\n\t\tnormalizeAngle: normalizeAngle,\n\t\tsnapToGrid: snapToGrid,\n\t\ttoDeg: toDeg,\n\t\ttoRad: toRad,\n\t\trandom: random,\n\t\tbezier: bezier,\n\t\tCurve: Curve,\n\t\tEllipse: Ellipse,\n\t\tellipse: ellipse,\n\t\tLine: Line,\n\t\tline: line,\n\t\tPath: Path,\n\t\tPoint: Point,\n\t\tpoint: point,\n\t\tPolyline: Polyline,\n\t\tPolygon: Polygon,\n\t\tRect: Rect,\n\t\trect: rect,\n\t\ttypes: types\n\t});\n\n\t// Vectorizer.\n\n\tvar V = (function() {\n\n\t    var hasSvg = typeof window === 'object' && !!window.SVGAngle;\n\n\t    // SVG support is required.\n\t    if (!hasSvg) {\n\n\t        // Return a function that throws an error when it is used.\n\t        return function() {\n\t            throw new Error('SVG is required to use Vectorizer.');\n\t        };\n\t    }\n\n\t    // XML namespaces.\n\t    var ns = {\n\t        svg: 'http://www.w3.org/2000/svg',\n\t        xmlns: 'http://www.w3.org/2000/xmlns/',\n\t        xml: 'http://www.w3.org/XML/1998/namespace',\n\t        xlink: 'http://www.w3.org/1999/xlink',\n\t        xhtml: 'http://www.w3.org/1999/xhtml'\n\t    };\n\n\t    var SVGVersion = '1.1';\n\n\t    // Declare shorthands to the most used math functions.\n\t    var math = Math;\n\t    var PI = math.PI;\n\t    var atan2 = math.atan2;\n\t    var sqrt = math.sqrt;\n\t    var min = math.min;\n\t    var max = math.max;\n\t    var cos = math.cos;\n\t    var sin = math.sin;\n\n\t    var V = function(el, attrs, children) {\n\n\t        // This allows using V() without the new keyword.\n\t        if (!(this instanceof V)) {\n\t            return V.apply(Object.create(V.prototype), arguments);\n\t        }\n\n\t        if (!el) { return; }\n\n\t        if (V.isV(el)) {\n\t            el = el.node;\n\t        }\n\n\t        attrs = attrs || {};\n\n\t        if (V.isString(el)) {\n\n\t            el = el.trim();\n\n\t            if (el.toLowerCase() === 'svg') {\n\n\t                // Create a new SVG canvas.\n\t                el = V.createSvgDocument();\n\n\t            } else if (el[0] === '<') {\n\n\t                // Create element from an SVG string.\n\t                // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n\n\t                var svgDoc = V.createSvgDocument(el);\n\n\t                // Note that `V()` might also return an array should the SVG string passed as\n\t                // the first argument contain more than one root element.\n\t                if (svgDoc.childNodes.length > 1) {\n\n\t                    // Map child nodes to `V`s.\n\t                    var arrayOfVels = [];\n\t                    var i, len;\n\n\t                    for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {\n\n\t                        var childNode = svgDoc.childNodes[i];\n\t                        arrayOfVels.push(new V(document.importNode(childNode, true)));\n\t                    }\n\n\t                    return arrayOfVels;\n\t                }\n\n\t                el = document.importNode(svgDoc.firstChild, true);\n\n\t            } else {\n\n\t                el = document.createElementNS(ns.svg, el);\n\t            }\n\n\t            V.ensureId(el);\n\t        }\n\n\t        this.node = el;\n\n\t        this.setAttributes(attrs);\n\n\t        if (children) {\n\t            this.append(children);\n\t        }\n\n\t        return this;\n\t    };\n\n\t    var VPrototype = V.prototype;\n\n\t    Object.defineProperty(VPrototype, 'id', {\n\t        enumerable: true,\n\t        get: function() {\n\t            return this.node.id;\n\t        },\n\t        set: function(id) {\n\t            this.node.id = id;\n\t        }\n\t    });\n\n\t    /**\n\t     * @param {SVGGElement} toElem\n\t     * @returns {SVGMatrix}\n\t     */\n\t    VPrototype.getTransformToElement = function(target) {\n\t        var node = this.node;\n\t        if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {\n\t            var targetCTM = V.toNode(target).getScreenCTM();\n\t            var nodeCTM = node.getScreenCTM();\n\t            if (targetCTM && nodeCTM) {\n\t                return targetCTM.inverse().multiply(nodeCTM);\n\t            }\n\t        }\n\t        // Could not get actual transformation matrix\n\t        return V.createSVGMatrix();\n\t    };\n\n\t    /**\n\t     * @param {SVGMatrix} matrix\n\t     * @param {Object=} opt\n\t     * @returns {Vectorizer|SVGMatrix} Setter / Getter\n\t     */\n\t    VPrototype.transform = function(matrix, opt) {\n\n\t        var node = this.node;\n\t        if (V.isUndefined(matrix)) {\n\t            return V.transformStringToMatrix(this.attr('transform'));\n\t        }\n\n\t        if (opt && opt.absolute) {\n\t            return this.attr('transform', V.matrixToTransformString(matrix));\n\t        }\n\n\t        var svgTransform = V.createSVGTransform(matrix);\n\t        node.transform.baseVal.appendItem(svgTransform);\n\t        return this;\n\t    };\n\n\t    VPrototype.translate = function(tx, ty, opt) {\n\n\t        opt = opt || {};\n\t        ty = ty || 0;\n\n\t        var transformAttr = this.attr('transform') || '';\n\t        var transform = V.parseTransformString(transformAttr);\n\t        transformAttr = transform.value;\n\t        // Is it a getter?\n\t        if (V.isUndefined(tx)) {\n\t            return transform.translate;\n\t        }\n\n\t        transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n\n\t        var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n\t        var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n\t        var newTranslate = 'translate(' + newTx + ',' + newTy + ')';\n\n\t        // Note that `translate()` is always the first transformation. This is\n\t        // usually the desired case.\n\t        this.attr('transform', (newTranslate + ' ' + transformAttr).trim());\n\t        return this;\n\t    };\n\n\t    VPrototype.rotate = function(angle, cx, cy, opt) {\n\n\t        opt = opt || {};\n\n\t        var transformAttr = this.attr('transform') || '';\n\t        var transform = V.parseTransformString(transformAttr);\n\t        transformAttr = transform.value;\n\n\t        // Is it a getter?\n\t        if (V.isUndefined(angle)) {\n\t            return transform.rotate;\n\t        }\n\n\t        transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n\n\t        angle %= 360;\n\n\t        var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n\t        var newOrigin = (cx !== undefined && cy !== undefined) ? ',' + cx + ',' + cy : '';\n\t        var newRotate = 'rotate(' + newAngle + newOrigin + ')';\n\n\t        this.attr('transform', (transformAttr + ' ' + newRotate).trim());\n\t        return this;\n\t    };\n\n\t    // Note that `scale` as the only transformation does not combine with previous values.\n\t    VPrototype.scale = function(sx, sy) {\n\n\t        sy = V.isUndefined(sy) ? sx : sy;\n\n\t        var transformAttr = this.attr('transform') || '';\n\t        var transform = V.parseTransformString(transformAttr);\n\t        transformAttr = transform.value;\n\n\t        // Is it a getter?\n\t        if (V.isUndefined(sx)) {\n\t            return transform.scale;\n\t        }\n\n\t        transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n\n\t        var newScale = 'scale(' + sx + ',' + sy + ')';\n\n\t        this.attr('transform', (transformAttr + ' ' + newScale).trim());\n\t        return this;\n\t    };\n\n\t    // Get SVGRect that contains coordinates and dimension of the real bounding box,\n\t    // i.e. after transformations are applied.\n\t    // If `target` is specified, bounding box will be computed relatively to `target` element.\n\t    VPrototype.bbox = function(withoutTransformations, target) {\n\n\t        var box;\n\t        var node = this.node;\n\t        var ownerSVGElement = node.ownerSVGElement;\n\n\t        // If the element is not in the live DOM, it does not have a bounding box defined and\n\t        // so fall back to 'zero' dimension element.\n\t        if (!ownerSVGElement) {\n\t            return new Rect(0, 0, 0, 0);\n\t        }\n\n\t        try {\n\n\t            box = node.getBBox();\n\n\t        } catch (e) {\n\n\t            // Fallback for IE.\n\t            box = {\n\t                x: node.clientLeft,\n\t                y: node.clientTop,\n\t                width: node.clientWidth,\n\t                height: node.clientHeight\n\t            };\n\t        }\n\n\t        if (withoutTransformations) {\n\t            return new Rect(box);\n\t        }\n\n\t        var matrix = this.getTransformToElement(target || ownerSVGElement);\n\n\t        return V.transformRect(box, matrix);\n\t    };\n\n\t    // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n\t    // i.e. after transformations are applied.\n\t    // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n\t    // Takes an (Object) `opt` argument (optional) with the following attributes:\n\t    // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n\t    // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n\t    VPrototype.getBBox = function(opt) {\n\n\t        var options = {};\n\n\t        var outputBBox;\n\t        var node = this.node;\n\t        var ownerSVGElement = node.ownerSVGElement;\n\n\t        // If the element is not in the live DOM, it does not have a bounding box defined and\n\t        // so fall back to 'zero' dimension element.\n\t        // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n\t        if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {\n\t            return new Rect(0, 0, 0, 0);\n\t        }\n\n\t        if (opt) {\n\t            if (opt.target) { // check if target exists\n\t                options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n\t            }\n\t            if (opt.recursive) {\n\t                options.recursive = opt.recursive;\n\t            }\n\t        }\n\n\t        if (!options.recursive) {\n\t            try {\n\t                outputBBox = node.getBBox();\n\t            } catch (e) {\n\t                // Fallback for IE.\n\t                outputBBox = {\n\t                    x: node.clientLeft,\n\t                    y: node.clientTop,\n\t                    width: node.clientWidth,\n\t                    height: node.clientHeight\n\t                };\n\t            }\n\n\t            if (!options.target) {\n\t                // transform like this (that is, not at all)\n\t                return new Rect(outputBBox);\n\t            } else {\n\t                // transform like target\n\t                var matrix = this.getTransformToElement(options.target);\n\t                return V.transformRect(outputBBox, matrix);\n\t            }\n\t        } else { // if we want to calculate the bbox recursively\n\t            // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n\t            // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n\t            // this happens even if we wrap a single svg element into a group!\n\t            // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n\n\t            var children = this.children();\n\t            var n = children.length;\n\n\t            if (n === 0) {\n\t                return this.getBBox({ target: options.target, recursive: false });\n\t            }\n\n\t            // recursion's initial pass-through setting:\n\t            // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n\t            if (!options.target) {\n\t                // transform children/descendants like this (their parent/ancestor)\n\t                options.target = this;\n\t            } // else transform children/descendants like target\n\n\t            for (var i = 0; i < n; i++) {\n\t                var currentChild = children[i];\n\n\t                var childBBox;\n\n\t                // if currentChild is not a group element, get its bbox with a nonrecursive call\n\t                if (currentChild.children().length === 0) {\n\t                    childBBox = currentChild.getBBox({ target: options.target, recursive: false });\n\t                } else {\n\t                    // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n\t                    childBBox = currentChild.getBBox({ target: options.target, recursive: true });\n\t                }\n\n\t                if (!outputBBox) {\n\t                    // if this is the first iteration\n\t                    outputBBox = childBBox;\n\t                } else {\n\t                    // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n\t                    outputBBox = outputBBox.union(childBBox);\n\t                }\n\t            }\n\n\t            return outputBBox;\n\t        }\n\t    };\n\n\t    // Text() helpers\n\n\t    function createTextPathNode(attrs, vel) {\n\t        attrs || (attrs = {});\n\t        var textPathElement = V('textPath');\n\t        var d = attrs.d;\n\t        if (d && attrs['xlink:href'] === undefined) {\n\t            // If `opt.attrs` is a plain string, consider it to be directly the\n\t            // SVG path data for the text to go along (this is a shortcut).\n\t            // Otherwise if it is an object and contains the `d` property, then this is our path.\n\t            // Wrap the text in the SVG <textPath> element that points\n\t            // to a path defined by `opt.attrs` inside the `<defs>` element.\n\t            var linkedPath = V('path').attr('d', d).appendTo(vel.defs());\n\t            textPathElement.attr('xlink:href', '#' + linkedPath.id);\n\t        }\n\t        if (V.isObject(attrs)) {\n\t            // Set attributes on the `<textPath>`. The most important one\n\t            // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n\t            // Note that we also allow the following construct:\n\t            // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n\t            // In other words, one can completely skip the auto-creation of the path\n\t            // and use any other arbitrary path that is in the document.\n\t            textPathElement.attr(attrs);\n\t        }\n\t        return textPathElement.node;\n\t    }\n\n\t    function annotateTextLine(lineNode, lineAnnotations, opt) {\n\t        opt || (opt = {});\n\t        var includeAnnotationIndices = opt.includeAnnotationIndices;\n\t        var eol = opt.eol;\n\t        var lineHeight = opt.lineHeight;\n\t        var baseSize = opt.baseSize;\n\t        var maxFontSize = 0;\n\t        var fontMetrics = {};\n\t        var lastJ = lineAnnotations.length - 1;\n\t        for (var j = 0; j <= lastJ; j++) {\n\t            var annotation = lineAnnotations[j];\n\t            var fontSize = null;\n\t            if (V.isObject(annotation)) {\n\t                var annotationAttrs = annotation.attrs;\n\t                var vTSpan = V('tspan', annotationAttrs);\n\t                var tspanNode = vTSpan.node;\n\t                var t = annotation.t;\n\t                if (eol && j === lastJ) { t += eol; }\n\t                tspanNode.textContent = t;\n\t                // Per annotation className\n\t                var annotationClass = annotationAttrs['class'];\n\t                if (annotationClass) { vTSpan.addClass(annotationClass); }\n\t                // If `opt.includeAnnotationIndices` is `true`,\n\t                // set the list of indices of all the applied annotations\n\t                // in the `annotations` attribute. This list is a comma\n\t                // separated list of indices.\n\t                if (includeAnnotationIndices) { vTSpan.attr('annotations', annotation.annotations); }\n\t                // Check for max font size\n\t                fontSize = parseFloat(annotationAttrs['font-size']);\n\t                if (!isFinite(fontSize)) { fontSize = baseSize; }\n\t                if (fontSize && fontSize > maxFontSize) { maxFontSize = fontSize; }\n\t            } else {\n\t                if (eol && j === lastJ) { annotation += eol; }\n\t                tspanNode = document.createTextNode(annotation || ' ');\n\t                if (baseSize && baseSize > maxFontSize) { maxFontSize = baseSize; }\n\t            }\n\t            lineNode.appendChild(tspanNode);\n\t        }\n\n\t        if (maxFontSize) { fontMetrics.maxFontSize = maxFontSize; }\n\t        if (lineHeight) {\n\t            fontMetrics.lineHeight = lineHeight;\n\t        } else if (maxFontSize) {\n\t            fontMetrics.lineHeight = (maxFontSize * 1.2);\n\t        }\n\t        return fontMetrics;\n\t    }\n\n\t    var emRegex = /em$/;\n\n\t    function convertEmToPx(em, fontSize) {\n\t        var numerical = parseFloat(em);\n\t        if (emRegex.test(em)) { return numerical * fontSize; }\n\t        return numerical;\n\t    }\n\n\t    function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n\t        if (!Array.isArray(linesMetrics)) { return 0; }\n\t        var n = linesMetrics.length;\n\t        if (!n) { return 0; }\n\t        var lineMetrics = linesMetrics[0];\n\t        var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n\t        var rLineHeights = 0;\n\t        var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n\t        for (var i = 1; i < n; i++) {\n\t            lineMetrics = linesMetrics[i];\n\t            var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n\t            rLineHeights += iLineHeight;\n\t        }\n\t        var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n\t        var dy;\n\t        switch (alignment) {\n\t            case 'middle':\n\t                dy = (flMaxFont / 2) - (0.15 * llMaxFont) - (rLineHeights / 2);\n\t                break;\n\t            case 'bottom':\n\t                dy = -(0.25 * llMaxFont) - rLineHeights;\n\t                break;\n\t            default:\n\t            case 'top':\n\t                dy = (0.8 * flMaxFont);\n\t                break;\n\t        }\n\t        return dy;\n\t    }\n\n\t    VPrototype.text = function(content, opt) {\n\n\t        if (content && typeof content !== 'string') { throw new Error('Vectorizer: text() expects the first argument to be a string.'); }\n\n\t        // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n\t        // IE would otherwise collapse all spaces into one.\n\t        content = V.sanitizeText(content);\n\t        opt || (opt = {});\n\t        // Should we allow the text to be selected?\n\t        var displayEmpty = opt.displayEmpty;\n\t        // End of Line character\n\t        var eol = opt.eol;\n\t        // Text along path\n\t        var textPath = opt.textPath;\n\t        // Vertical shift\n\t        var verticalAnchor = opt.textVerticalAnchor;\n\t        var namedVerticalAnchor = (verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top');\n\t        // Horizontal shift applied to all the lines but the first.\n\t        var x = opt.x;\n\t        if (x === undefined) { x = this.attr('x') || 0; }\n\t        // Annotations\n\t        var iai = opt.includeAnnotationIndices;\n\t        var annotations = opt.annotations;\n\t        if (annotations && !V.isArray(annotations)) { annotations = [annotations]; }\n\t        // Shift all the <tspan> but first by one line (`1em`)\n\t        var defaultLineHeight = opt.lineHeight;\n\t        var autoLineHeight = (defaultLineHeight === 'auto');\n\t        var lineHeight = (autoLineHeight) ? '1.5em' : (defaultLineHeight || '1em');\n\t        // Clearing the element\n\t        this.empty();\n\t        this.attr({\n\t            // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n\t            'xml:space': 'preserve',\n\t            // An empty text gets rendered into the DOM in webkit-based browsers.\n\t            // In order to unify this behaviour across all browsers\n\t            // we rather hide the text element when it's empty.\n\t            'display': (content || displayEmpty) ? null : 'none'\n\t        });\n\n\t        // Set default font-size if none\n\t        var fontSize = parseFloat(this.attr('font-size'));\n\t        if (!fontSize) {\n\t            fontSize = 16;\n\t            if (namedVerticalAnchor || annotations) { this.attr('font-size', fontSize); }\n\t        }\n\n\t        var doc = document;\n\t        var containerNode;\n\t        if (textPath) {\n\t            // Now all the `<tspan>`s will be inside the `<textPath>`.\n\t            if (typeof textPath === 'string') { textPath = { d: textPath }; }\n\t            containerNode = createTextPathNode(textPath, this);\n\t        } else {\n\t            containerNode = doc.createDocumentFragment();\n\t        }\n\t        var offset = 0;\n\t        var lines = content.split('\\n');\n\t        var linesMetrics = [];\n\t        var annotatedY;\n\t        for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {\n\t            var dy = lineHeight;\n\t            var lineClassName = 'v-line';\n\t            var lineNode = doc.createElementNS(ns.svg, 'tspan');\n\t            var line = lines[i];\n\t            var lineMetrics;\n\t            if (line) {\n\t                if (annotations) {\n\t                    // Find the *compacted* annotations for this line.\n\t                    var lineAnnotations = V.annotateString(line, annotations, {\n\t                        offset: -offset,\n\t                        includeAnnotationIndices: iai\n\t                    });\n\t                    lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n\t                        includeAnnotationIndices: iai,\n\t                        eol: (i !== lastI && eol),\n\t                        lineHeight: (autoLineHeight) ? null : lineHeight,\n\t                        baseSize: fontSize\n\t                    });\n\t                    // Get the line height based on the biggest font size in the annotations for this line.\n\t                    var iLineHeight = lineMetrics.lineHeight;\n\t                    if (iLineHeight && autoLineHeight && i !== 0) { dy = iLineHeight; }\n\t                    if (i === 0) { annotatedY = lineMetrics.maxFontSize * 0.8; }\n\t                } else {\n\t                    if (eol && i !== lastI) { line += eol; }\n\t                    lineNode.textContent = line;\n\t                }\n\t            } else {\n\t                // Make sure the textContent is never empty. If it is, add a dummy\n\t                // character and make it invisible, making the following lines correctly\n\t                // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n\t                lineNode.textContent = '-';\n\t                lineClassName += ' v-empty-line';\n\t                // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n\t                // is not applied in Firefox\n\t                var lineNodeStyle = lineNode.style;\n\t                lineNodeStyle.fillOpacity = 0;\n\t                lineNodeStyle.strokeOpacity = 0;\n\t                if (annotations) {\n\t                    // Empty line with annotations.\n\t                    lineMetrics = {};\n\t                    lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);\n\t                    var lineFontSize = fontSize;\n\t                    // Check if any of the annotations overrides the font size.\n\t                    for (var j = lineAnnotations.length; j > 0; j--) {\n\t                        var attrs = lineAnnotations[j - 1].attrs;\n\t                        if (!attrs || !('font-size' in attrs)) { continue; }\n\t                        var fs = parseFloat(attrs['font-size']);\n\t                        if (isFinite(fs)) {\n\t                            lineFontSize = fs;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (autoLineHeight) {\n\t                        if (i > 0) {\n\t                            dy = lineFontSize * 1.2;\n\t                        } else {\n\t                            annotatedY = lineFontSize * 0.8;\n\t                        }\n\t                    }\n\t                    // The font size is important for the native selection box height.\n\t                    lineNode.setAttribute('font-size', lineFontSize);\n\t                    lineMetrics.maxFontSize = lineFontSize;\n\t                }\n\t            }\n\t            if (lineMetrics) { linesMetrics.push(lineMetrics); }\n\t            if (i > 0) { lineNode.setAttribute('dy', dy); }\n\t            // Firefox requires 'x' to be set on the first line when inside a text path\n\t            if (i > 0 || textPath) { lineNode.setAttribute('x', x); }\n\t            lineNode.className.baseVal = lineClassName;\n\t            containerNode.appendChild(lineNode);\n\t            offset += line.length + 1;      // + 1 = newline character.\n\t        }\n\t        // Y Alignment calculation\n\t        if (namedVerticalAnchor) {\n\t            if (annotations) {\n\t                dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n\t            } else if (verticalAnchor === 'top') {\n\t                // A shortcut for top alignment. It does not depend on font-size nor line-height\n\t                dy = '0.8em';\n\t            } else {\n\t                var rh; // remaining height\n\t                if (lastI > 0) {\n\t                    rh = parseFloat(lineHeight) || 1;\n\t                    rh *= lastI;\n\t                    if (!emRegex.test(lineHeight)) { rh /= fontSize; }\n\t                } else {\n\t                    // Single-line text\n\t                    rh = 0;\n\t                }\n\t                switch (verticalAnchor) {\n\t                    case 'middle':\n\t                        dy = (0.3 - (rh / 2)) + 'em';\n\t                        break;\n\t                    case 'bottom':\n\t                        dy = (-rh - 0.3) + 'em';\n\t                        break;\n\t                }\n\t            }\n\t        } else {\n\t            if (verticalAnchor === 0) {\n\t                dy = '0em';\n\t            } else if (verticalAnchor) {\n\t                dy = verticalAnchor;\n\t            } else {\n\t                // No vertical anchor is defined\n\t                dy = 0;\n\t                // Backwards compatibility - we change the `y` attribute instead of `dy`.\n\t                if (this.attr('y') === null) { this.attr('y', annotatedY || '0.8em'); }\n\t            }\n\t        }\n\t        containerNode.firstChild.setAttribute('dy', dy);\n\t        // Appending lines to the element.\n\t        this.append(containerNode);\n\t        return this;\n\t    };\n\n\t    /**\n\t     * @public\n\t     * @param {string} name\n\t     * @returns {Vectorizer}\n\t     */\n\t    VPrototype.removeAttr = function(name) {\n\n\t        var qualifiedName = V.qualifyAttr(name);\n\t        var el = this.node;\n\n\t        if (qualifiedName.ns) {\n\t            if (el.hasAttributeNS(qualifiedName.ns, qualifiedName.local)) {\n\t                el.removeAttributeNS(qualifiedName.ns, qualifiedName.local);\n\t            }\n\t        } else if (el.hasAttribute(name)) {\n\t            el.removeAttribute(name);\n\t        }\n\t        return this;\n\t    };\n\n\t    VPrototype.attr = function(name, value) {\n\n\t        if (V.isUndefined(name)) {\n\n\t            // Return all attributes.\n\t            var attributes = this.node.attributes;\n\t            var attrs = {};\n\n\t            for (var i = 0; i < attributes.length; i++) {\n\t                attrs[attributes[i].name] = attributes[i].value;\n\t            }\n\n\t            return attrs;\n\t        }\n\n\t        if (V.isString(name) && V.isUndefined(value)) {\n\t            return this.node.getAttribute(name);\n\t        }\n\n\t        if (typeof name === 'object') {\n\n\t            for (var attrName in name) {\n\t                if (name.hasOwnProperty(attrName)) {\n\t                    this.setAttribute(attrName, name[attrName]);\n\t                }\n\t            }\n\n\t        } else {\n\n\t            this.setAttribute(name, value);\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.normalizePath = function() {\n\n\t        var tagName = this.tagName();\n\t        if (tagName === 'PATH') {\n\t            this.attr('d', V.normalizePathData(this.attr('d')));\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.remove = function() {\n\n\t        if (this.node.parentNode) {\n\t            this.node.parentNode.removeChild(this.node);\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.empty = function() {\n\n\t        while (this.node.firstChild) {\n\t            this.node.removeChild(this.node.firstChild);\n\t        }\n\n\t        return this;\n\t    };\n\n\t    /**\n\t     * @private\n\t     * @param {object} attrs\n\t     * @returns {Vectorizer}\n\t     */\n\t    VPrototype.setAttributes = function(attrs) {\n\n\t        for (var key in attrs) {\n\t            if (attrs.hasOwnProperty(key)) {\n\t                this.setAttribute(key, attrs[key]);\n\t            }\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.append = function(els) {\n\n\t        if (!V.isArray(els)) {\n\t            els = [els];\n\t        }\n\n\t        for (var i = 0, len = els.length; i < len; i++) {\n\t            this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.prepend = function(els) {\n\n\t        var child = this.node.firstChild;\n\t        return child ? V(child).before(els) : this.append(els);\n\t    };\n\n\t    VPrototype.before = function(els) {\n\n\t        var node = this.node;\n\t        var parent = node.parentNode;\n\n\t        if (parent) {\n\n\t            if (!V.isArray(els)) {\n\t                els = [els];\n\t            }\n\n\t            for (var i = 0, len = els.length; i < len; i++) {\n\t                parent.insertBefore(V.toNode(els[i]), node);\n\t            }\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.appendTo = function(node) {\n\t        V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n\t        return this;\n\t    };\n\n\t    VPrototype.svg = function() {\n\n\t        return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n\t    };\n\n\t    VPrototype.tagName = function() {\n\n\t        return this.node.tagName.toUpperCase();\n\t    };\n\n\t    VPrototype.defs = function() {\n\t        var context = this.svg() || this;\n\t        var defsNode = context.node.getElementsByTagName('defs')[0];\n\t        if (defsNode) { return V(defsNode); }\n\t        return V('defs').appendTo(context);\n\t    };\n\n\t    VPrototype.clone = function() {\n\n\t        var clone = V(this.node.cloneNode(true/* deep */));\n\t        // Note that clone inherits also ID. Therefore, we need to change it here.\n\t        clone.node.id = V.uniqueId();\n\t        return clone;\n\t    };\n\n\t    VPrototype.findOne = function(selector) {\n\n\t        var found = this.node.querySelector(selector);\n\t        return found ? V(found) : undefined;\n\t    };\n\n\t    VPrototype.find = function(selector) {\n\n\t        var vels = [];\n\t        var nodes = this.node.querySelectorAll(selector);\n\n\t        if (nodes) {\n\n\t            // Map DOM elements to `V`s.\n\t            for (var i = 0; i < nodes.length; i++) {\n\t                vels.push(V(nodes[i]));\n\t            }\n\t        }\n\n\t        return vels;\n\t    };\n\n\t    // Returns an array of V elements made from children of this.node.\n\t    VPrototype.children = function() {\n\n\t        var children = this.node.childNodes;\n\n\t        var outputArray = [];\n\t        for (var i = 0; i < children.length; i++) {\n\t            var currentChild = children[i];\n\t            if (currentChild.nodeType === 1) {\n\t                outputArray.push(V(children[i]));\n\t            }\n\t        }\n\t        return outputArray;\n\t    };\n\n\t    // Returns the V element from parentNode of this.node.\n\t    VPrototype.parent = function() {\n\t        return V(this.node.parentNode) || null;\n\t    },\n\n\t    // Find an index of an element inside its container.\n\t    VPrototype.index = function() {\n\n\t        var index = 0;\n\t        var node = this.node.previousSibling;\n\n\t        while (node) {\n\t            // nodeType 1 for ELEMENT_NODE\n\t            if (node.nodeType === 1) { index++; }\n\t            node = node.previousSibling;\n\t        }\n\n\t        return index;\n\t    };\n\n\t    VPrototype.findParentByClass = function(className, terminator) {\n\n\t        var ownerSVGElement = this.node.ownerSVGElement;\n\t        var node = this.node.parentNode;\n\n\t        while (node && node !== terminator && node !== ownerSVGElement) {\n\n\t            var vel = V(node);\n\t            if (vel.hasClass(className)) {\n\t                return vel;\n\t            }\n\n\t            node = node.parentNode;\n\t        }\n\n\t        return null;\n\t    };\n\n\t    // https://jsperf.com/get-common-parent\n\t    VPrototype.contains = function(el) {\n\n\t        var a = this.node;\n\t        var b = V.toNode(el);\n\t        var bup = b && b.parentNode;\n\n\t        return (a === bup) || !!(bup && bup.nodeType === 1 && (a.compareDocumentPosition(bup) & 16));\n\t    };\n\n\t    // Convert global point into the coordinate space of this element.\n\t    VPrototype.toLocalPoint = function(x, y) {\n\n\t        var svg = this.svg().node;\n\n\t        var p = svg.createSVGPoint();\n\t        p.x = x;\n\t        p.y = y;\n\n\t        try {\n\n\t            var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n\t            var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n\n\t        } catch (e) {\n\t            // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n\t            // We have to make do with the original coordianates.\n\t            return p;\n\t        }\n\n\t        return globalPoint.matrixTransform(globalToLocalMatrix);\n\t    };\n\n\t    VPrototype.translateCenterToPoint = function(p) {\n\n\t        var bbox = this.getBBox({ target: this.svg() });\n\t        var center = bbox.center();\n\n\t        this.translate(p.x - center.x, p.y - center.y);\n\t        return this;\n\t    };\n\n\t    // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n\t    // of markers. The easiest way of understanding on what this does is to imagine the element is an\n\t    // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n\t    // being auto-oriented (properly rotated) towards the `reference` point.\n\t    // `target` is the element relative to which the transformations are applied. Usually a viewport.\n\t    VPrototype.translateAndAutoOrient = function(position, reference, target) {\n\n\t        position = new Point(position);\n\t        reference =  new Point(reference);\n\t        target || (target = this.svg());\n\n\t        // Clean-up previously set transformations except the scale. If we didn't clean up the\n\t        // previous transformations then they'd add up with the old ones. Scale is an exception as\n\t        // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n\t        // element is scaled by the factor 2, not 8.\n\t        var scale = this.scale();\n\t        this.attr('transform', '');\n\t        var bbox = this.getBBox({ target: target }).scale(scale.sx, scale.sy);\n\n\t        // 1. Translate to origin.\n\t        var translateToOrigin = V.createSVGTransform();\n\t        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n\n\t        // 2. Rotate around origin.\n\t        var rotateAroundOrigin = V.createSVGTransform();\n\t        var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n\t        if (angle) { rotateAroundOrigin.setRotate(angle, 0, 0); }\n\n\t        // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n\t        var translateFromOrigin = V.createSVGTransform();\n\t        var finalPosition = position.clone().move(reference, bbox.width / 2);\n\t        translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);\n\n\t        // 4. Get the current transformation matrix of this node\n\t        var ctm = this.getTransformToElement(target);\n\n\t        // 5. Apply transformations and the scale\n\t        var transform = V.createSVGTransform();\n\t        transform.setMatrix(\n\t            translateFromOrigin.matrix.multiply(\n\t                rotateAroundOrigin.matrix.multiply(\n\t                    translateToOrigin.matrix.multiply(\n\t                        ctm.scale(scale.sx, scale.sy)))));\n\n\t        this.attr('transform', V.matrixToTransformString(transform.matrix));\n\n\t        return this;\n\t    };\n\n\t    VPrototype.animateAlongPath = function(attrs, path) {\n\n\t        path = V.toNode(path);\n\n\t        var id = V.ensureId(path);\n\t        var animateMotion = V('animateMotion', attrs);\n\t        var mpath = V('mpath', { 'xlink:href': '#' + id });\n\n\t        animateMotion.append(mpath);\n\n\t        this.append(animateMotion);\n\t        try {\n\t            animateMotion.node.beginElement();\n\t        } catch (e) {\n\t            // Fallback for IE 9.\n\t            // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n\t            if (document.documentElement.getAttribute('smiling') === 'fake') {\n\t                /* global getTargets:true, Animator:true, animators:true id2anim:true */\n\t                // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n\t                var animation = animateMotion.node;\n\t                animation.animators = [];\n\n\t                var animationID = animation.getAttribute('id');\n\t                if (animationID) { id2anim[animationID] = animation; }\n\n\t                var targets = getTargets(animation);\n\t                for (var i = 0, len = targets.length; i < len; i++) {\n\t                    var target = targets[i];\n\t                    var animator = new Animator(animation, target, i);\n\t                    animators.push(animator);\n\t                    animation.animators[i] = animator;\n\t                    animator.register();\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\n\n\t    // Split a string into an array of tokens.\n\t    // https://infra.spec.whatwg.org/#ascii-whitespace\n\t    var noHTMLWhitespaceRegex = /[^\\x20\\t\\r\\n\\f]+/g;\n\t    function getTokenList(str) {\n\t        if (!V.isString(str)) { return []; }\n\t        return str.trim().match(noHTMLWhitespaceRegex) || [];\n\t    }\n\n\t    VPrototype.hasClass = function(className) {\n\t        if (!V.isString(className)) { return false; }\n\t        return this.node.classList.contains(className.trim());\n\t    };\n\n\t    VPrototype.addClass = function(className) {\n\t        var ref;\n\n\t        (ref = this.node.classList).add.apply(ref, getTokenList(className));\n\t        return this;\n\t    };\n\n\t    VPrototype.removeClass = function(className) {\n\t        var ref;\n\n\t        (ref = this.node.classList).remove.apply(ref, getTokenList(className));\n\t        return this;\n\t    };\n\n\t    VPrototype.toggleClass = function(className, toAdd) {\n\t        var tokens = getTokenList(className);\n\t        for (var i = 0; i < tokens.length; i++) {\n\t            this.node.classList.toggle(tokens[i], toAdd);\n\t        }\n\t        return this;\n\t    };\n\n\t    // Interpolate path by discrete points. The precision of the sampling\n\t    // is controlled by `interval`. In other words, `sample()` will generate\n\t    // a point on the path starting at the beginning of the path going to the end\n\t    // every `interval` pixels.\n\t    // The sampler can be very useful for e.g. finding intersection between two\n\t    // paths (finding the two closest points from two samples).\n\t    VPrototype.sample = function(interval) {\n\n\t        interval = interval || 1;\n\t        var node = this.node;\n\t        var length = node.getTotalLength();\n\t        var samples = [];\n\t        var distance = 0;\n\t        var sample;\n\t        while (distance < length) {\n\t            sample = node.getPointAtLength(distance);\n\t            samples.push({ x: sample.x, y: sample.y, distance: distance });\n\t            distance += interval;\n\t        }\n\t        return samples;\n\t    };\n\n\t    VPrototype.convertToPath = function() {\n\n\t        var path = V('path');\n\t        path.attr(this.attr());\n\t        var d = this.convertToPathData();\n\t        if (d) {\n\t            path.attr('d', d);\n\t        }\n\t        return path;\n\t    };\n\n\t    VPrototype.convertToPathData = function() {\n\n\t        var tagName = this.tagName();\n\n\t        switch (tagName) {\n\t            case 'PATH':\n\t                return this.attr('d');\n\t            case 'LINE':\n\t                return V.convertLineToPathData(this.node);\n\t            case 'POLYGON':\n\t                return V.convertPolygonToPathData(this.node);\n\t            case 'POLYLINE':\n\t                return V.convertPolylineToPathData(this.node);\n\t            case 'ELLIPSE':\n\t                return V.convertEllipseToPathData(this.node);\n\t            case 'CIRCLE':\n\t                return V.convertCircleToPathData(this.node);\n\t            case 'RECT':\n\t                return V.convertRectToPathData(this.node);\n\t        }\n\n\t        throw new Error(tagName + ' cannot be converted to PATH.');\n\t    };\n\n\t    V.prototype.toGeometryShape = function() {\n\t        var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n\t        switch (this.tagName()) {\n\n\t            case 'RECT':\n\t                x = parseFloat(this.attr('x')) || 0;\n\t                y = parseFloat(this.attr('y')) || 0;\n\t                width = parseFloat(this.attr('width')) || 0;\n\t                height = parseFloat(this.attr('height')) || 0;\n\t                return new Rect(x, y, width, height);\n\n\t            case 'CIRCLE':\n\t                cx = parseFloat(this.attr('cx')) || 0;\n\t                cy = parseFloat(this.attr('cy')) || 0;\n\t                r = parseFloat(this.attr('r')) || 0;\n\t                return new Ellipse({ x: cx, y: cy }, r, r);\n\n\t            case 'ELLIPSE':\n\t                cx = parseFloat(this.attr('cx')) || 0;\n\t                cy = parseFloat(this.attr('cy')) || 0;\n\t                rx = parseFloat(this.attr('rx')) || 0;\n\t                ry = parseFloat(this.attr('ry')) || 0;\n\t                return new Ellipse({ x: cx, y: cy }, rx, ry);\n\n\t            case 'POLYLINE':\n\t                points = V.getPointsFromSvgNode(this);\n\t                return new Polyline(points);\n\n\t            case 'POLYGON':\n\t                points = V.getPointsFromSvgNode(this);\n\t                if (points.length > 1) { points.push(points[0]); }\n\t                return new Polyline(points);\n\n\t            case 'PATH':\n\t                d = this.attr('d');\n\t                if (!Path.isDataSupported(d)) { d = V.normalizePathData(d); }\n\t                return new Path(d);\n\n\t            case 'LINE':\n\t                x1 = parseFloat(this.attr('x1')) || 0;\n\t                y1 = parseFloat(this.attr('y1')) || 0;\n\t                x2 = parseFloat(this.attr('x2')) || 0;\n\t                y2 = parseFloat(this.attr('y2')) || 0;\n\t                return new Line({ x: x1, y: y1 }, { x: x2, y: y2 });\n\t        }\n\n\t        // Anything else is a rectangle\n\t        return this.getBBox();\n\t    };\n\n\t    // Find the intersection of a line starting in the center\n\t    // of the SVG `node` ending in the point `ref`.\n\t    // `target` is an SVG element to which `node`s transformations are relative to.\n\t    // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n\t    // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n\t    // an intersection is found. Returns `undefined` otherwise.\n\t    VPrototype.findIntersection = function(ref, target) {\n\n\t        var svg = this.svg().node;\n\t        target = target || svg;\n\t        var bbox = this.getBBox({ target: target });\n\t        var center = bbox.center();\n\n\t        if (!bbox.intersectionWithLineFromCenterToPoint(ref)) { return undefined; }\n\n\t        var spot;\n\t        var tagName = this.tagName();\n\n\t        // Little speed up optimization for `<rect>` element. We do not do conversion\n\t        // to path element and sampling but directly calculate the intersection through\n\t        // a transformed geometrical rectangle.\n\t        if (tagName === 'RECT') {\n\n\t            var gRect = new Rect(\n\t                parseFloat(this.attr('x') || 0),\n\t                parseFloat(this.attr('y') || 0),\n\t                parseFloat(this.attr('width')),\n\t                parseFloat(this.attr('height'))\n\t            );\n\t            // Get the rect transformation matrix with regards to the SVG document.\n\t            var rectMatrix = this.getTransformToElement(target);\n\t            // Decompose the matrix to find the rotation angle.\n\t            var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\n\t            // Now we want to rotate the rectangle back so that we\n\t            // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n\t            var resetRotation = svg.createSVGTransform();\n\t            resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n\t            var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n\t            spot = (new Rect(rect)).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n\n\t        } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {\n\n\t            var pathNode = (tagName === 'PATH') ? this : this.convertToPath();\n\t            var samples = pathNode.sample();\n\t            var minDistance = Infinity;\n\t            var closestSamples = [];\n\n\t            var i, sample, gp, centerDistance, refDistance, distance;\n\n\t            for (i = 0; i < samples.length; i++) {\n\n\t                sample = samples[i];\n\t                // Convert the sample point in the local coordinate system to the global coordinate system.\n\t                gp = V.createSVGPoint(sample.x, sample.y);\n\t                gp = gp.matrixTransform(this.getTransformToElement(target));\n\t                sample = new Point(gp);\n\t                centerDistance = sample.distance(center);\n\t                // Penalize a higher distance to the reference point by 10%.\n\t                // This gives better results. This is due to\n\t                // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n\t                refDistance = sample.distance(ref) * 1.1;\n\t                distance = centerDistance + refDistance;\n\n\t                if (distance < minDistance) {\n\t                    minDistance = distance;\n\t                    closestSamples = [{ sample: sample, refDistance: refDistance }];\n\t                } else if (distance < minDistance + 1) {\n\t                    closestSamples.push({ sample: sample, refDistance: refDistance });\n\t                }\n\t            }\n\n\t            closestSamples.sort(function(a, b) {\n\t                return a.refDistance - b.refDistance;\n\t            });\n\n\t            if (closestSamples[0]) {\n\t                spot = closestSamples[0].sample;\n\t            }\n\t        }\n\n\t        return spot;\n\t    };\n\n\t    /**\n\t     * @private\n\t     * @param {string} name\n\t     * @param {string} value\n\t     * @returns {Vectorizer}\n\t     */\n\t    VPrototype.setAttribute = function(name, value) {\n\n\t        var el = this.node;\n\n\t        if (value === null) {\n\t            this.removeAttr(name);\n\t            return this;\n\t        }\n\n\t        var qualifiedName = V.qualifyAttr(name);\n\n\t        if (qualifiedName.ns) {\n\t            // Attribute names can be namespaced. E.g. `image` elements\n\t            // have a `xlink:href` attribute to set the source of the image.\n\t            el.setAttributeNS(qualifiedName.ns, name, value);\n\t        } else if (name === 'id') {\n\t            el.id = value;\n\t        } else {\n\t            el.setAttribute(name, value);\n\t        }\n\n\t        return this;\n\t    };\n\n\t    // Create an SVG document element.\n\t    // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n\t    V.createSvgDocument = function(content) {\n\n\t        if (content) {\n\t            var XMLString = \"<svg xmlns=\\\"\" + (ns.svg) + \"\\\" xmlns:xlink=\\\"\" + (ns.xlink) + \"\\\" version=\\\"\" + SVGVersion + \"\\\">\" + content + \"</svg>\";\n\t            var ref = V.parseXML(XMLString, { async: false });\n\t            var documentElement = ref.documentElement;\n\t            return documentElement;\n\t        }\n\n\t        var svg = document.createElementNS(ns.svg, 'svg');\n\t        svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n\t        svg.setAttribute('version', SVGVersion);\n\t        return svg;\n\t    };\n\n\t    V.createSVGStyle = function(stylesheet) {\n\t        var ref = V('style', { type: 'text/css' }, [\n\t            V.createCDATASection(stylesheet)\n\t        ]);\n\t        var node = ref.node;\n\t        return node;\n\t    },\n\n\t    V.createCDATASection = function(data) {\n\t        if ( data === void 0 ) data = '';\n\n\t        var xml = document.implementation.createDocument(null, 'xml', null);\n\t        return xml.createCDATASection(data);\n\t    };\n\n\t    V.idCounter = 0;\n\n\t    // A function returning a unique identifier for this client session with every call.\n\t    V.uniqueId = function() {\n\n\t        return 'v-' + (++V.idCounter);\n\t    };\n\n\t    V.toNode = function(el) {\n\n\t        return V.isV(el) ? el.node : (el.nodeName && el || el[0]);\n\t    };\n\n\t    V.ensureId = function(node) {\n\n\t        node = V.toNode(node);\n\t        return node.id || (node.id = V.uniqueId());\n\t    };\n\n\t    // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n\t    // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n\t    // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n\t    // when you want to compare the actual DOM text content without having to add the unicode character in\n\t    // the place of all spaces.\n\t    V.sanitizeText = function(text) {\n\n\t        return (text || '').replace(/ /g, '\\u00A0');\n\t    };\n\n\t    V.isUndefined = function(value) {\n\n\t        return typeof value === 'undefined';\n\t    };\n\n\t    V.isString = function(value) {\n\n\t        return typeof value === 'string';\n\t    };\n\n\t    V.isObject = function(value) {\n\n\t        return value && (typeof value === 'object');\n\t    };\n\n\t    V.isArray = Array.isArray;\n\n\t    V.parseXML = function(data, opt) {\n\n\t        opt = opt || {};\n\n\t        var xml;\n\n\t        try {\n\t            var parser = new DOMParser();\n\n\t            if (!V.isUndefined(opt.async)) {\n\t                parser.async = opt.async;\n\t            }\n\n\t            xml = parser.parseFromString(data, 'text/xml');\n\t        } catch (error) {\n\t            xml = undefined;\n\t        }\n\n\t        if (!xml || xml.getElementsByTagName('parsererror').length) {\n\t            throw new Error('Invalid XML: ' + data);\n\t        }\n\n\t        return xml;\n\t    };\n\n\t    /**\n\t     * @param {string} name\n\t     * @returns {{ns: string|null, local: string}} namespace and attribute name\n\t     */\n\t    V.qualifyAttr = function(name) {\n\n\t        if (name.indexOf(':') !== -1) {\n\t            var combinedKey = name.split(':');\n\t            return {\n\t                ns: ns[combinedKey[0]],\n\t                local: combinedKey[1]\n\t            };\n\t        }\n\n\t        return {\n\t            ns: null,\n\t            local: name\n\t        };\n\t    };\n\n\t    // Note: This regex allows multiple commas as separator which is incorrect in SVG\n\t    // This regex is used by `split()`, so it doesn't need to use /g\n\t    V.transformSeparatorRegex = /[ ,]+/;\n\t    // Note: All following regexes are more restrictive than SVG specification\n\t    // ReDoS mitigation: Use an anchor at the beginning of the match\n\t    // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)\n\t    // ReDoS mitigation: Don't match initial `(` inside repeated part\n\t    // The following regex needs to use /g (= cannot use capturing groups)\n\t    V.transformRegex = /\\b\\w+\\([^()]+\\)/g;\n\t    // The following regexes need to use capturing groups (= cannot use /g)\n\t    V.transformFunctionRegex = /\\b(\\w+)\\(([^()]+)\\)/;\n\t    V.transformTranslateRegex = /\\btranslate\\(([^()]+)\\)/;\n\t    V.transformRotateRegex = /\\brotate\\(([^()]+)\\)/;\n\t    V.transformScaleRegex = /\\bscale\\(([^()]+)\\)/;\n\n\t    V.transformStringToMatrix = function(transform) {\n\n\t        // Initialize result matrix as identity matrix\n\t        var transformationMatrix = V.createSVGMatrix();\n\n\t        // Note: Multiple transform functions are allowed in `transform` string\n\t        // `match()` returns `null` if none found\n\t        var transformMatches = transform && transform.match(V.transformRegex);\n\t        if (!transformMatches) {\n\t            // Return identity matrix\n\t            return transformationMatrix;\n\t        }\n\n\t        var numMatches = transformMatches.length;\n\t        for (var i = 0; i < numMatches; i++) {\n\n\t            var transformMatch = transformMatches[i];\n\t            // Use same regex as above, but with capturing groups\n\t            // `match()` returns values of capturing groups as `[1]`, `[2]`\n\t            var transformFunctionMatch = transformMatch.match(V.transformFunctionRegex);\n\t            if (transformFunctionMatch) {\n\n\t                var sx = (void 0), sy = (void 0), tx = (void 0), ty = (void 0), angle = (void 0);\n\t                var ctm = V.createSVGMatrix();\n\t                var transformFunction = transformFunctionMatch[1].toLowerCase();\n\t                var args = transformFunctionMatch[2].split(V.transformSeparatorRegex);\n\t                switch (transformFunction) {\n\n\t                    case 'scale':\n\t                        sx = parseFloat(args[0]);\n\t                        sy = (args[1] === undefined) ? sx : parseFloat(args[1]);\n\t                        ctm = ctm.scaleNonUniform(sx, sy);\n\t                        break;\n\n\t                    case 'translate':\n\t                        tx = parseFloat(args[0]);\n\t                        ty = parseFloat(args[1]);\n\t                        ctm = ctm.translate(tx, ty);\n\t                        break;\n\n\t                    case 'rotate':\n\t                        angle = parseFloat(args[0]);\n\t                        tx = parseFloat(args[1]) || 0;\n\t                        ty = parseFloat(args[2]) || 0;\n\t                        if (tx !== 0 || ty !== 0) {\n\t                            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n\t                        } else {\n\t                            ctm = ctm.rotate(angle);\n\t                        }\n\t                        break;\n\n\t                    case 'skewx':\n\t                        angle = parseFloat(args[0]);\n\t                        ctm = ctm.skewX(angle);\n\t                        break;\n\n\t                    case 'skewy':\n\t                        angle = parseFloat(args[0]);\n\t                        ctm = ctm.skewY(angle);\n\t                        break;\n\n\t                    case 'matrix':\n\t                        ctm.a = parseFloat(args[0]);\n\t                        ctm.b = parseFloat(args[1]);\n\t                        ctm.c = parseFloat(args[2]);\n\t                        ctm.d = parseFloat(args[3]);\n\t                        ctm.e = parseFloat(args[4]);\n\t                        ctm.f = parseFloat(args[5]);\n\t                        break;\n\n\t                    default:\n\t                        continue;\n\t                }\n\n\t                // Multiply current transformation into result matrix\n\t                transformationMatrix = transformationMatrix.multiply(ctm);\n\t            }\n\n\t        }\n\t        return transformationMatrix;\n\t    };\n\n\t    V.matrixToTransformString = function(matrix) {\n\t        matrix || (matrix = true);\n\n\t        return 'matrix(' +\n\t            (matrix.a !== undefined ? matrix.a : 1) + ',' +\n\t            (matrix.b !== undefined ? matrix.b : 0) + ',' +\n\t            (matrix.c !== undefined ? matrix.c : 0) + ',' +\n\t            (matrix.d !== undefined ? matrix.d : 1) + ',' +\n\t            (matrix.e !== undefined ? matrix.e : 0) + ',' +\n\t            (matrix.f !== undefined ? matrix.f : 0) +\n\t            ')';\n\t    };\n\n\t    V.parseTransformString = function(transform) {\n\n\t        var translate, rotate, scale;\n\n\t        if (transform) {\n\n\t            var separator = V.transformSeparatorRegex;\n\n\t            // Special handling for `transform` with one or more matrix functions\n\t            if (transform.trim().indexOf('matrix') >= 0) {\n\n\t                // Convert EVERYTHING in `transform` string to a matrix\n\t                // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates\n\t                // Note: In non-matrix case, we only take first one of each (if any)\n\t                var matrix = V.transformStringToMatrix(transform);\n\t                var decomposedMatrix = V.decomposeMatrix(matrix);\n\n\t                // Extract `translate`, `scale`, `rotate` from matrix\n\t                translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n\t                scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n\t                rotate = [decomposedMatrix.rotation];\n\n\t                // Rewrite `transform` string in `translate scale rotate` format\n\t                var transformations = [];\n\t                if (translate[0] !== 0 || translate[1] !== 0) {\n\t                    transformations.push('translate(' + translate + ')');\n\t                }\n\t                if (scale[0] !== 1 || scale[1] !== 1) {\n\t                    transformations.push('scale(' + scale + ')');\n\t                }\n\t                if (rotate[0] !== 0) {\n\t                    transformations.push('rotate(' + rotate + ')');\n\t                }\n\t                transform = transformations.join(' ');\n\n\t            } else {\n\n\t                // Extract `translate`, `rotate`, `scale` functions from `transform` string\n\t                // Note: We only detect the first match of each (if any)\n\t                // `match()` returns value of capturing group as `[1]`\n\t                var translateMatch = transform.match(V.transformTranslateRegex);\n\t                if (translateMatch) {\n\t                    translate = translateMatch[1].split(separator);\n\t                }\n\t                var rotateMatch = transform.match(V.transformRotateRegex);\n\t                if (rotateMatch) {\n\t                    rotate = rotateMatch[1].split(separator);\n\t                }\n\t                var scaleMatch = transform.match(V.transformScaleRegex);\n\t                if (scaleMatch) {\n\t                    scale = scaleMatch[1].split(separator);\n\t                }\n\t            }\n\t        }\n\n\t        var sx = (scale && scale[0]) ? parseFloat(scale[0]) : 1;\n\n\t        return {\n\t            value: transform,\n\t            translate: {\n\t                tx: (translate && translate[0]) ? parseInt(translate[0], 10) : 0,\n\t                ty: (translate && translate[1]) ? parseInt(translate[1], 10) : 0\n\t            },\n\t            rotate: {\n\t                angle: (rotate && rotate[0]) ? parseInt(rotate[0], 10) : 0,\n\t                cx: (rotate && rotate[1]) ? parseInt(rotate[1], 10) : undefined,\n\t                cy: (rotate && rotate[2]) ? parseInt(rotate[2], 10) : undefined\n\t            },\n\t            scale: {\n\t                sx: sx,\n\t                sy: (scale && scale[1]) ? parseFloat(scale[1]) : sx\n\t            }\n\t        };\n\t    };\n\n\t    V.deltaTransformPoint = function(matrix, point) {\n\n\t        var dx = point.x * matrix.a + point.y * matrix.c + 0;\n\t        var dy = point.x * matrix.b + point.y * matrix.d + 0;\n\t        return { x: dx, y: dy };\n\t    };\n\n\t    V.decomposeMatrix = function(matrix) {\n\n\t        // @see https://gist.github.com/2052247\n\n\t        // calculate delta transform point\n\t        var px = V.deltaTransformPoint(matrix, { x: 0, y: 1 });\n\t        var py = V.deltaTransformPoint(matrix, { x: 1, y: 0 });\n\n\t        // calculate skew\n\t        var skewX = ((180 / PI) * atan2(px.y, px.x) - 90);\n\t        var skewY = ((180 / PI) * atan2(py.y, py.x));\n\n\t        return {\n\n\t            translateX: matrix.e,\n\t            translateY: matrix.f,\n\t            scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n\t            scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n\t            skewX: skewX,\n\t            skewY: skewY,\n\t            rotation: skewX // rotation is the same as skew x\n\t        };\n\t    };\n\n\t    // Return the `scale` transformation from the following equation:\n\t    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\t    V.matrixToScale = function(matrix) {\n\n\t        var a, b, c, d;\n\t        if (matrix) {\n\t            a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n\t            d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n\t            b = matrix.b;\n\t            c = matrix.c;\n\t        } else {\n\t            a = d = 1;\n\t        }\n\t        return {\n\t            sx: b ? sqrt(a * a + b * b) : a,\n\t            sy: c ? sqrt(c * c + d * d) : d\n\t        };\n\t    };\n\n\t    // Return the `rotate` transformation from the following equation:\n\t    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\t    V.matrixToRotate = function(matrix) {\n\n\t        var p = { x: 0, y: 1 };\n\t        if (matrix) {\n\t            p = V.deltaTransformPoint(matrix, p);\n\t        }\n\n\t        return {\n\t            angle: normalizeAngle(toDeg(atan2(p.y, p.x)) - 90)\n\t        };\n\t    };\n\n\t    // Return the `translate` transformation from the following equation:\n\t    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\t    V.matrixToTranslate = function(matrix) {\n\n\t        return {\n\t            tx: (matrix && matrix.e) || 0,\n\t            ty: (matrix && matrix.f) || 0\n\t        };\n\t    };\n\n\t    V.isV = function(object) {\n\n\t        return object instanceof V;\n\t    };\n\n\t    // For backwards compatibility:\n\t    V.isVElement = V.isV;\n\n\t    // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n\t    // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n\t    V.isSVGGraphicsElement = function(node) {\n\t        if (!node) { return false; }\n\t        node = V.toNode(node);\n\t        // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n\t        return node instanceof SVGElement && typeof node.getScreenCTM === 'function';\n\t    };\n\n\t    var svgDocument = V('svg').node;\n\n\t    V.createSVGMatrix = function(matrix) {\n\n\t        var svgMatrix = svgDocument.createSVGMatrix();\n\t        for (var component in matrix) {\n\t            svgMatrix[component] = matrix[component];\n\t        }\n\n\t        return svgMatrix;\n\t    };\n\n\t    V.createSVGTransform = function(matrix) {\n\n\t        if (!V.isUndefined(matrix)) {\n\n\t            if (!(matrix instanceof SVGMatrix)) {\n\t                matrix = V.createSVGMatrix(matrix);\n\t            }\n\n\t            return svgDocument.createSVGTransformFromMatrix(matrix);\n\t        }\n\n\t        return svgDocument.createSVGTransform();\n\t    };\n\n\t    V.createSVGPoint = function(x, y) {\n\n\t        var p = svgDocument.createSVGPoint();\n\t        p.x = x;\n\t        p.y = y;\n\t        return p;\n\t    };\n\n\t    V.transformRect = function(r, matrix) {\n\n\t        var p = svgDocument.createSVGPoint();\n\n\t        p.x = r.x;\n\t        p.y = r.y;\n\t        var corner1 = p.matrixTransform(matrix);\n\n\t        p.x = r.x + r.width;\n\t        p.y = r.y;\n\t        var corner2 = p.matrixTransform(matrix);\n\n\t        p.x = r.x + r.width;\n\t        p.y = r.y + r.height;\n\t        var corner3 = p.matrixTransform(matrix);\n\n\t        p.x = r.x;\n\t        p.y = r.y + r.height;\n\t        var corner4 = p.matrixTransform(matrix);\n\n\t        var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n\t        var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n\t        var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n\t        var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n\n\t        return new Rect(minX, minY, maxX - minX, maxY - minY);\n\t    };\n\n\t    V.transformPoint = function(p, matrix) {\n\n\t        return new Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n\t    };\n\n\t    V.transformLine = function(l, matrix) {\n\n\t        return new Line(\n\t            V.transformPoint(l.start, matrix),\n\t            V.transformPoint(l.end, matrix)\n\t        );\n\t    };\n\n\t    V.transformPolyline = function(p, matrix) {\n\n\t        var inPoints = (p instanceof Polyline) ? p.points : p;\n\t        if (!V.isArray(inPoints)) { inPoints = []; }\n\t        var outPoints = [];\n\t        for (var i = 0, n = inPoints.length; i < n; i++) { outPoints[i] = V.transformPoint(inPoints[i], matrix); }\n\t        return new Polyline(outPoints);\n\t    };\n\n\t    // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n\t    // an object (`{ fill: 'blue', stroke: 'red' }`).\n\t    V.styleToObject = function(styleString) {\n\t        var ret = {};\n\t        var styles = styleString.split(';');\n\t        for (var i = 0; i < styles.length; i++) {\n\t            var style = styles[i];\n\t            var pair = style.split('=');\n\t            ret[pair[0].trim()] = pair[1].trim();\n\t        }\n\t        return ret;\n\t    };\n\n\t    // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n\t    V.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {\n\n\t        var svgArcMax = 2 * PI - 1e-6;\n\t        var r0 = innerRadius;\n\t        var r1 = outerRadius;\n\t        var a0 = startAngle;\n\t        var a1 = endAngle;\n\t        var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n\t        var df = da < PI ? '0' : '1';\n\t        var c0 = cos(a0);\n\t        var s0 = sin(a0);\n\t        var c1 = cos(a1);\n\t        var s1 = sin(a1);\n\n\t        return (da >= svgArcMax)\n\t            ? (r0\n\t                ? 'M0,' + r1\n\t                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n\t                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n\t                + 'M0,' + r0\n\t                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + (-r0)\n\t                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0\n\t                + 'Z'\n\t                : 'M0,' + r1\n\t                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n\t                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n\t                + 'Z')\n\t            : (r0\n\t                ? 'M' + r1 * c0 + ',' + r1 * s0\n\t                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n\t                + 'L' + r0 * c1 + ',' + r0 * s1\n\t                + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0\n\t                + 'Z'\n\t                : 'M' + r1 * c0 + ',' + r1 * s0\n\t                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n\t                + 'L0,0'\n\t                + 'Z');\n\t    };\n\n\t    // Merge attributes from object `b` with attributes in object `a`.\n\t    // Note that this modifies the object `a`.\n\t    // Also important to note that attributes are merged but CSS classes are concatenated.\n\t    V.mergeAttrs = function(a, b) {\n\n\t        for (var attr in b) {\n\n\t            if (attr === 'class') {\n\t                // Concatenate classes.\n\t                a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];\n\t            } else if (attr === 'style') {\n\t                // `style` attribute can be an object.\n\t                if (V.isObject(a[attr]) && V.isObject(b[attr])) {\n\t                    // `style` stored in `a` is an object.\n\t                    a[attr] = V.mergeAttrs(a[attr], b[attr]);\n\t                } else if (V.isObject(a[attr])) {\n\t                    // `style` in `a` is an object but it's a string in `b`.\n\t                    // Convert the style represented as a string to an object in `b`.\n\t                    a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n\t                } else if (V.isObject(b[attr])) {\n\t                    // `style` in `a` is a string, in `b` it's an object.\n\t                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n\t                } else {\n\t                    // Both styles are strings.\n\t                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n\t                }\n\t            } else {\n\t                a[attr] = b[attr];\n\t            }\n\t        }\n\n\t        return a;\n\t    };\n\n\t    V.annotateString = function(t, annotations, opt) {\n\n\t        annotations = annotations || [];\n\t        opt = opt || {};\n\n\t        var offset = opt.offset || 0;\n\t        var compacted = [];\n\t        var batch;\n\t        var ret = [];\n\t        var item;\n\t        var prev;\n\n\t        for (var i = 0; i < t.length; i++) {\n\n\t            item = ret[i] = t[i];\n\n\t            for (var j = 0; j < annotations.length; j++) {\n\n\t                var annotation = annotations[j];\n\t                var start = annotation.start + offset;\n\t                var end = annotation.end + offset;\n\n\t                if (i >= start && i < end) {\n\t                    // Annotation applies.\n\t                    if (V.isObject(item)) {\n\t                        // There is more than one annotation to be applied => Merge attributes.\n\t                        item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n\t                    } else {\n\t                        item = ret[i] = { t: t[i], attrs: annotation.attrs };\n\t                    }\n\t                    if (opt.includeAnnotationIndices) {\n\t                        (item.annotations || (item.annotations = [])).push(j);\n\t                    }\n\t                }\n\t            }\n\n\t            prev = ret[i - 1];\n\n\t            if (!prev) {\n\n\t                batch = item;\n\n\t            } else if (V.isObject(item) && V.isObject(prev)) {\n\t                // Both previous item and the current one are annotations. If the attributes\n\t                // didn't change, merge the text.\n\t                if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\n\t                    batch.t += item.t;\n\t                } else {\n\t                    compacted.push(batch);\n\t                    batch = item;\n\t                }\n\n\t            } else if (V.isObject(item)) {\n\t                // Previous item was a string, current item is an annotation.\n\t                compacted.push(batch);\n\t                batch = item;\n\n\t            } else if (V.isObject(prev)) {\n\t                // Previous item was an annotation, current item is a string.\n\t                compacted.push(batch);\n\t                batch = item;\n\n\t            } else {\n\t                // Both previous and current item are strings.\n\t                batch = (batch || '') + item;\n\t            }\n\t        }\n\n\t        if (batch) {\n\t            compacted.push(batch);\n\t        }\n\n\t        return compacted;\n\t    };\n\n\t    V.findAnnotationsAtIndex = function(annotations, index) {\n\n\t        var found = [];\n\n\t        if (annotations) {\n\n\t            annotations.forEach(function(annotation) {\n\n\t                if (annotation.start < index && index <= annotation.end) {\n\t                    found.push(annotation);\n\t                }\n\t            });\n\t        }\n\n\t        return found;\n\t    };\n\n\t    V.findAnnotationsBetweenIndexes = function(annotations, start, end) {\n\n\t        var found = [];\n\n\t        if (annotations) {\n\n\t            annotations.forEach(function(annotation) {\n\n\t                if ((start >= annotation.start && start < annotation.end) || (end > annotation.start && end <= annotation.end) || (annotation.start >= start && annotation.end < end)) {\n\t                    found.push(annotation);\n\t                }\n\t            });\n\t        }\n\n\t        return found;\n\t    };\n\n\t    // Shift all the text annotations after character `index` by `offset` positions.\n\t    V.shiftAnnotations = function(annotations, index, offset) {\n\n\t        if (annotations) {\n\n\t            annotations.forEach(function(annotation) {\n\n\t                if (annotation.start < index && annotation.end >= index) {\n\t                    annotation.end += offset;\n\t                } else if (annotation.start >= index) {\n\t                    annotation.start += offset;\n\t                    annotation.end += offset;\n\t                }\n\t            });\n\t        }\n\n\t        return annotations;\n\t    };\n\n\t    V.convertLineToPathData = function(line) {\n\n\t        line = V(line);\n\t        var d = [\n\t            'M', line.attr('x1'), line.attr('y1'),\n\t            'L', line.attr('x2'), line.attr('y2')\n\t        ].join(' ');\n\t        return d;\n\t    };\n\n\t    V.convertPolygonToPathData = function(polygon) {\n\n\t        var points = V.getPointsFromSvgNode(polygon);\n\t        if (points.length === 0) { return null; }\n\n\t        return V.svgPointsToPath(points) + ' Z';\n\t    };\n\n\t    V.convertPolylineToPathData = function(polyline) {\n\n\t        var points = V.getPointsFromSvgNode(polyline);\n\t        if (points.length === 0) { return null; }\n\n\t        return V.svgPointsToPath(points);\n\t    };\n\n\t    V.svgPointsToPath = function(points) {\n\n\t        for (var i = 0, n = points.length; i < n; i++) {\n\t            points[i] = points[i].x + ' ' + points[i].y;\n\t        }\n\n\t        return 'M ' + points.join(' L');\n\t    };\n\n\t    V.getPointsFromSvgNode = function(node) {\n\n\t        node = V.toNode(node);\n\t        var points = [];\n\t        var nodePoints = node.points;\n\t        if (nodePoints) {\n\t            for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {\n\t                points.push(nodePoints.getItem(i));\n\t            }\n\t        }\n\n\t        return points;\n\t    };\n\n\t    V.KAPPA = 0.551784;\n\n\t    V.convertCircleToPathData = function(circle) {\n\n\t        circle = V(circle);\n\t        var cx = parseFloat(circle.attr('cx')) || 0;\n\t        var cy = parseFloat(circle.attr('cy')) || 0;\n\t        var r = parseFloat(circle.attr('r'));\n\t        var cd = r * V.KAPPA; // Control distance.\n\n\t        var d = [\n\t            'M', cx, cy - r,    // Move to the first point.\n\t            'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, // I. Quadrant.\n\t            'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, // II. Quadrant.\n\t            'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, // III. Quadrant.\n\t            'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, // IV. Quadrant.\n\t            'Z'\n\t        ].join(' ');\n\t        return d;\n\t    };\n\n\t    V.convertEllipseToPathData = function(ellipse) {\n\n\t        ellipse = V(ellipse);\n\t        var cx = parseFloat(ellipse.attr('cx')) || 0;\n\t        var cy = parseFloat(ellipse.attr('cy')) || 0;\n\t        var rx = parseFloat(ellipse.attr('rx'));\n\t        var ry = parseFloat(ellipse.attr('ry')) || rx;\n\t        var cdx = rx * V.KAPPA; // Control distance x.\n\t        var cdy = ry * V.KAPPA; // Control distance y.\n\n\t        var d = [\n\t            'M', cx, cy - ry,    // Move to the first point.\n\t            'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, // I. Quadrant.\n\t            'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, // II. Quadrant.\n\t            'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, // III. Quadrant.\n\t            'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, // IV. Quadrant.\n\t            'Z'\n\t        ].join(' ');\n\t        return d;\n\t    };\n\n\t    V.convertRectToPathData = function(rect) {\n\n\t        rect = V(rect);\n\n\t        return V.rectToPath({\n\t            x: parseFloat(rect.attr('x')) || 0,\n\t            y: parseFloat(rect.attr('y')) || 0,\n\t            width: parseFloat(rect.attr('width')) || 0,\n\t            height: parseFloat(rect.attr('height')) || 0,\n\t            rx: parseFloat(rect.attr('rx')) || 0,\n\t            ry: parseFloat(rect.attr('ry')) || 0\n\t        });\n\t    };\n\n\t    // Convert a rectangle to SVG path commands. `r` is an object of the form:\n\t    // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n\t    // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n\t    // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n\t    // that has only `rx` and `ry` attributes).\n\t    V.rectToPath = function(r) {\n\n\t        var d;\n\t        var x = r.x;\n\t        var y = r.y;\n\t        var width = r.width;\n\t        var height = r.height;\n\t        var topRx = min(r.rx || r['top-rx'] || 0, width / 2);\n\t        var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);\n\t        var topRy = min(r.ry || r['top-ry'] || 0, height / 2);\n\t        var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);\n\n\t        if (topRx || bottomRx || topRy || bottomRy) {\n\t            d = [\n\t                'M', x, y + topRy,\n\t                'v', height - topRy - bottomRy,\n\t                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy,\n\t                'h', width - 2 * bottomRx,\n\t                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy,\n\t                'v', -(height - bottomRy - topRy),\n\t                'a', topRx, topRy, 0, 0, 0, -topRx, -topRy,\n\t                'h', -(width - 2 * topRx),\n\t                'a', topRx, topRy, 0, 0, 0, -topRx, topRy,\n\t                'Z'\n\t            ];\n\t        } else {\n\t            d = [\n\t                'M', x, y,\n\t                'H', x + width,\n\t                'V', y + height,\n\t                'H', x,\n\t                'V', y,\n\t                'Z'\n\t            ];\n\t        }\n\n\t        return d.join(' ');\n\t    };\n\n\t    // Take a path data string\n\t    // Return a normalized path data string\n\t    // If data cannot be parsed, return 'M 0 0'\n\t    // Adapted from Rappid normalizePath polyfill\n\t    // Highly inspired by Raphael Library (www.raphael.com)\n\t    V.normalizePathData = (function() {\n\n\t        var spaces = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\n\t        var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');\n\t        var pathValues = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');\n\n\t        var math = Math;\n\t        var PI = math.PI;\n\t        var sin = math.sin;\n\t        var cos = math.cos;\n\t        var tan = math.tan;\n\t        var asin = math.asin;\n\t        var sqrt = math.sqrt;\n\t        var abs = math.abs;\n\n\t        function q2c(x1, y1, ax, ay, x2, y2) {\n\n\t            var _13 = 1 / 3;\n\t            var _23 = 2 / 3;\n\t            return [(_13 * x1) + (_23 * ax), (_13 * y1) + (_23 * ay), (_13 * x2) + (_23 * ax), (_13 * y2) + (_23 * ay), x2, y2];\n\t        }\n\n\t        function rotate(x, y, rad) {\n\n\t            var X = (x * cos(rad)) - (y * sin(rad));\n\t            var Y = (x * sin(rad)) + (y * cos(rad));\n\t            return { x: X, y: Y };\n\t        }\n\n\t        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n\t            // for more information of where this math came from visit:\n\t            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n\t            var _120 = (PI * 120) / 180;\n\t            var rad = (PI / 180) * (+angle || 0);\n\t            var res = [];\n\t            var xy;\n\n\t            if (!recursive) {\n\t                xy = rotate(x1, y1, -rad);\n\t                x1 = xy.x;\n\t                y1 = xy.y;\n\n\t                xy = rotate(x2, y2, -rad);\n\t                x2 = xy.x;\n\t                y2 = xy.y;\n\n\t                var x = (x1 - x2) / 2;\n\t                var y = (y1 - y2) / 2;\n\t                var h = ((x * x) / (rx * rx)) + ((y * y) / (ry * ry));\n\n\t                if (h > 1) {\n\t                    h = sqrt(h);\n\t                    rx = h * rx;\n\t                    ry = h * ry;\n\t                }\n\n\t                var rx2 = rx * rx;\n\t                var ry2 = ry * ry;\n\n\t                var k = ((large_arc_flag == sweep_flag) ? -1 : 1) * sqrt(abs(((rx2 * ry2) - (rx2 * y * y) - (ry2 * x * x)) / ((rx2 * y * y) + (ry2 * x * x))));\n\n\t                var cx = ((k * rx * y) / ry) + ((x1 + x2) / 2);\n\t                var cy = ((k * -ry * x) / rx) + ((y1 + y2) / 2);\n\n\t                var f1 = asin(((y1 - cy) / ry).toFixed(9));\n\t                var f2 = asin(((y2 - cy) / ry).toFixed(9));\n\n\t                f1 = ((x1 < cx) ? (PI - f1) : f1);\n\t                f2 = ((x2 < cx) ? (PI - f2) : f2);\n\n\t                if (f1 < 0) { f1 = (PI * 2) + f1; }\n\t                if (f2 < 0) { f2 = (PI * 2) + f2; }\n\n\t                if (sweep_flag && (f1 > f2)) { f1 = f1 - (PI * 2); }\n\t                if (!sweep_flag && (f2 > f1)) { f2 = f2 - (PI * 2); }\n\n\t            } else {\n\t                f1 = recursive[0];\n\t                f2 = recursive[1];\n\t                cx = recursive[2];\n\t                cy = recursive[3];\n\t            }\n\n\t            var df = f2 - f1;\n\t            if (abs(df) > _120) {\n\t                var f2old = f2;\n\t                var x2old = x2;\n\t                var y2old = y2;\n\t                f2 = f1 + (_120 * ((sweep_flag && (f2 > f1)) ? 1 : -1));\n\t                x2 = cx + (rx * cos(f2));\n\t                y2 = cy + (ry * sin(f2));\n\t                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n\t            }\n\n\t            df = f2 - f1;\n\n\t            var c1 = cos(f1);\n\t            var s1 = sin(f1);\n\t            var c2 = cos(f2);\n\t            var s2 = sin(f2);\n\t            var t = tan(df / 4);\n\t            var hx = (4 / 3) * (rx * t);\n\t            var hy = (4 / 3) * (ry * t);\n\t            var m1 = [x1, y1];\n\t            var m2 = [x1 + (hx * s1), y1 - (hy * c1)];\n\t            var m3 = [x2 + (hx * s2), y2 - (hy * c2)];\n\t            var m4 = [x2, y2];\n\n\t            m2[0] = (2 * m1[0]) - m2[0];\n\t            m2[1] = (2 * m1[1]) - m2[1];\n\n\t            if (recursive) {\n\t                return [m2, m3, m4].concat(res);\n\t            } else {\n\t                res = [m2, m3, m4].concat(res).join().split(',');\n\t                var newres = [];\n\t                var ii = res.length;\n\t                for (var i = 0; i < ii; i++) {\n\t                    newres[i] = (i % 2) ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n\t                }\n\t                return newres;\n\t            }\n\t        }\n\n\t        function parsePathString(pathString) {\n\n\t            if (!pathString) { return null; }\n\n\t            var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };\n\t            var data = [];\n\n\t            String(pathString).replace(pathCommand, function(a, b, c) {\n\n\t                var params = [];\n\t                var name = b.toLowerCase();\n\t                c.replace(pathValues, function(a, b) {\n\t                    if (b) { params.push(+b); }\n\t                });\n\n\t                if ((name === 'm') && (params.length > 2)) {\n\t                    data.push([b].concat(params.splice(0, 2)));\n\t                    name = 'l';\n\t                    b = ((b === 'm') ? 'l' : 'L');\n\t                }\n\n\t                while (params.length >= paramCounts[name]) {\n\t                    data.push([b].concat(params.splice(0, paramCounts[name])));\n\t                    if (!paramCounts[name]) { break; }\n\t                }\n\t            });\n\n\t            return data;\n\t        }\n\n\t        function pathToAbsolute(pathArray) {\n\n\t            if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) { // rough assumption\n\t                pathArray = parsePathString(pathArray);\n\t            }\n\n\t            // if invalid string, return 'M 0 0'\n\t            if (!pathArray || !pathArray.length) { return [['M', 0, 0]]; }\n\n\t            var res = [];\n\t            var x = 0;\n\t            var y = 0;\n\t            var mx = 0;\n\t            var my = 0;\n\t            var start = 0;\n\t            var pa0;\n\n\t            var ii = pathArray.length;\n\t            for (var i = start; i < ii; i++) {\n\n\t                var r = [];\n\t                res.push(r);\n\n\t                var pa = pathArray[i];\n\t                pa0 = pa[0];\n\n\t                if (pa0 != pa0.toUpperCase()) {\n\t                    r[0] = pa0.toUpperCase();\n\n\t                    var jj;\n\t                    var j;\n\t                    switch (r[0]) {\n\t                        case 'A':\n\t                            r[1] = pa[1];\n\t                            r[2] = pa[2];\n\t                            r[3] = pa[3];\n\t                            r[4] = pa[4];\n\t                            r[5] = pa[5];\n\t                            r[6] = +pa[6] + x;\n\t                            r[7] = +pa[7] + y;\n\t                            break;\n\n\t                        case 'V':\n\t                            r[1] = +pa[1] + y;\n\t                            break;\n\n\t                        case 'H':\n\t                            r[1] = +pa[1] + x;\n\t                            break;\n\n\t                        case 'M':\n\t                            mx = +pa[1] + x;\n\t                            my = +pa[2] + y;\n\n\t                            jj = pa.length;\n\t                            for (j = 1; j < jj; j++) {\n\t                                r[j] = +pa[j] + ((j % 2) ? x : y);\n\t                            }\n\t                            break;\n\n\t                        default:\n\t                            jj = pa.length;\n\t                            for (j = 1; j < jj; j++) {\n\t                                r[j] = +pa[j] + ((j % 2) ? x : y);\n\t                            }\n\t                            break;\n\t                    }\n\t                } else {\n\t                    var kk = pa.length;\n\t                    for (var k = 0; k < kk; k++) {\n\t                        r[k] = pa[k];\n\t                    }\n\t                }\n\n\t                switch (r[0]) {\n\t                    case 'Z':\n\t                        x = +mx;\n\t                        y = +my;\n\t                        break;\n\n\t                    case 'H':\n\t                        x = r[1];\n\t                        break;\n\n\t                    case 'V':\n\t                        y = r[1];\n\t                        break;\n\n\t                    case 'M':\n\t                        mx = r[r.length - 2];\n\t                        my = r[r.length - 1];\n\t                        x = r[r.length - 2];\n\t                        y = r[r.length - 1];\n\t                        break;\n\n\t                    default:\n\t                        x = r[r.length - 2];\n\t                        y = r[r.length - 1];\n\t                        break;\n\t                }\n\t            }\n\n\t            return res;\n\t        }\n\n\t        function normalize(path) {\n\n\t            var p = pathToAbsolute(path);\n\t            var attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };\n\n\t            function processPath(path, d, pcom) {\n\n\t                var nx, ny;\n\n\t                if (!path) { return ['C', d.x, d.y, d.x, d.y, d.x, d.y]; }\n\n\t                if (!(path[0] in { T: 1, Q: 1 })) {\n\t                    d.qx = null;\n\t                    d.qy = null;\n\t                }\n\n\t                switch (path[0]) {\n\t                    case 'M':\n\t                        d.X = path[1];\n\t                        d.Y = path[2];\n\t                        break;\n\n\t                    case 'A':\n\t                        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n\t                            // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n\t                            // \"If either rx or ry is 0, then this arc is treated as a\n\t                            // straight line segment (a \"lineto\") joining the endpoints.\"\n\t                            path = ['L', path[6], path[7]];\n\t                        } else {\n\t                            path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n\t                        }\n\t                        break;\n\n\t                    case 'S':\n\t                        if (pcom === 'C' || pcom === 'S') { // In 'S' case we have to take into account, if the previous command is C/S.\n\t                            nx = (d.x * 2) - d.bx;          // And reflect the previous\n\t                            ny = (d.y * 2) - d.by;          // command's control point relative to the current point.\n\t                        } else {                            // or some else or nothing\n\t                            nx = d.x;\n\t                            ny = d.y;\n\t                        }\n\t                        path = ['C', nx, ny].concat(path.slice(1));\n\t                        break;\n\n\t                    case 'T':\n\t                        if (pcom === 'Q' || pcom === 'T') { // In 'T' case we have to take into account, if the previous command is Q/T.\n\t                            d.qx = (d.x * 2) - d.qx;        // And make a reflection similar\n\t                            d.qy = (d.y * 2) - d.qy;        // to case 'S'.\n\t                        } else {                            // or something else or nothing\n\t                            d.qx = d.x;\n\t                            d.qy = d.y;\n\t                        }\n\t                        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n\t                        break;\n\n\t                    case 'Q':\n\t                        d.qx = path[1];\n\t                        d.qy = path[2];\n\t                        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n\t                        break;\n\n\t                    case 'H':\n\t                        path = ['L'].concat(path[1], d.y);\n\t                        break;\n\n\t                    case 'V':\n\t                        path = ['L'].concat(d.x, path[1]);\n\t                        break;\n\n\t                    case 'L':\n\t                        break;\n\n\t                    case 'Z':\n\t                        break;\n\t                }\n\n\t                return path;\n\t            }\n\n\t            function fixArc(pp, i) {\n\n\t                if (pp[i].length > 7) {\n\n\t                    pp[i].shift();\n\t                    var pi = pp[i];\n\n\t                    while (pi.length) {\n\t                        pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved\n\t                        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n\t                    }\n\n\t                    pp.splice(i, 1);\n\t                    ii = p.length;\n\t                }\n\t            }\n\n\t            var pcoms = []; // path commands of original path p\n\t            var pfirst = ''; // temporary holder for original path command\n\t            var pcom = ''; // holder for previous path command of original path\n\n\t            var ii = p.length;\n\t            for (var i = 0; i < ii; i++) {\n\t                if (p[i]) { pfirst = p[i][0]; } // save current path command\n\n\t                if (pfirst !== 'C') { // C is not saved yet, because it may be result of conversion\n\t                    pcoms[i] = pfirst; // Save current path command\n\t                    if (i > 0) { pcom = pcoms[i - 1]; } // Get previous path command pcom\n\t                }\n\n\t                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n\t                if (pcoms[i] !== 'A' && pfirst === 'C') { pcoms[i] = 'C'; } // 'A' is the only command\n\t                // which may produce multiple 'C's\n\t                // so we have to make sure that 'C' is also 'C' in original path\n\n\t                fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n\n\t                var seg = p[i];\n\t                var seglen = seg.length;\n\n\t                attrs.x = seg[seglen - 2];\n\t                attrs.y = seg[seglen - 1];\n\n\t                attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n\t                attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n\t            }\n\n\t            // make sure normalized path data string starts with an M segment\n\t            if (!p[0][0] || p[0][0] !== 'M') {\n\t                p.unshift(['M', 0, 0]);\n\t            }\n\n\t            return p;\n\t        }\n\n\t        return function(pathData) {\n\t            return normalize(pathData).join(',').split(',').join(' ');\n\t        };\n\t    })();\n\n\t    V.namespace = ns;\n\n\t    V.g = g;\n\n\t    return V;\n\n\t})();\n\n\tvar config = {\n\t    // When set to `true` the cell selectors could be defined as CSS selectors.\n\t    // If not, only JSON Markup selectors are taken into account.\n\t    // export let useCSSSelectors = true;\n\t    useCSSSelectors: true,\n\t    // The class name prefix config is for advanced use only.\n\t    // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.\n\t    // export let classNamePrefix = 'joint-';\n\t    // export let defaultTheme = 'default';\n\t    classNamePrefix: 'joint-',\n\t    defaultTheme: 'default',\n\t    // The maximum delay required for two consecutive touchend events to be interpreted\n\t    // as a double-tap.\n\t    doubleTapInterval: 300\n\t};\n\n\t// code is inspired by https://github.com/lodash/lodash\n\n\t/* eslint-disable no-case-declarations */\n\t// -- helper constants\n\tvar argsTag = '[object Arguments]';\n\tvar arrayTag = '[object Array]';\n\tvar boolTag = '[object Boolean]';\n\tvar dateTag = '[object Date]';\n\tvar errorTag = '[object Error]';\n\tvar funcTag = '[object Function]';\n\tvar mapTag = '[object Map]';\n\tvar numberTag = '[object Number]';\n\tvar nullTag = '[object Null]';\n\tvar objectTag = '[object Object]';\n\tvar regexpTag = '[object RegExp]';\n\tvar setTag = '[object Set]';\n\tvar stringTag = '[object String]';\n\tvar symbolTag = '[object Symbol]';\n\tvar undefinedTag = '[object Undefined]';\n\tvar weakMapTag = '[object WeakMap]';\n\tvar arrayBufferTag = '[object ArrayBuffer]';\n\tvar dataViewTag = '[object DataView]';\n\tvar float32Tag = '[object Float32Array]';\n\tvar float64Tag = '[object Float64Array]';\n\tvar int8Tag = '[object Int8Array]';\n\tvar int16Tag = '[object Int16Array]';\n\tvar int32Tag = '[object Int32Array]';\n\tvar uint8Tag = '[object Uint8Array]';\n\tvar uint8ClampedTag = '[object Uint8ClampedArray]';\n\tvar uint16Tag = '[object Uint16Array]';\n\tvar uint32Tag = '[object Uint32Array]';\n\n\tvar CLONEABLE_TAGS = {};\n\tCLONEABLE_TAGS[argsTag] = true;\n\tCLONEABLE_TAGS[arrayTag] = true;\n\tCLONEABLE_TAGS[arrayBufferTag] = true;\n\tCLONEABLE_TAGS[dataViewTag] = true;\n\tCLONEABLE_TAGS[boolTag] = true;\n\tCLONEABLE_TAGS[dateTag] = true;\n\tCLONEABLE_TAGS[float32Tag] = true;\n\tCLONEABLE_TAGS[float64Tag] = true;\n\tCLONEABLE_TAGS[int8Tag] = true;\n\tCLONEABLE_TAGS[int16Tag] = true;\n\tCLONEABLE_TAGS[int32Tag] = true;\n\tCLONEABLE_TAGS[mapTag] = true;\n\tCLONEABLE_TAGS[numberTag] = true;\n\tCLONEABLE_TAGS[objectTag] = true;\n\tCLONEABLE_TAGS[regexpTag] = true;\n\tCLONEABLE_TAGS[setTag] = true;\n\tCLONEABLE_TAGS[stringTag] = true;\n\tCLONEABLE_TAGS[symbolTag] = true;\n\tCLONEABLE_TAGS[uint8Tag] = true;\n\tCLONEABLE_TAGS[uint8ClampedTag] = true;\n\tCLONEABLE_TAGS[uint16Tag] = true;\n\tCLONEABLE_TAGS[uint32Tag] = true;\n\tCLONEABLE_TAGS[errorTag] = false;\n\tCLONEABLE_TAGS[funcTag] = false;\n\tCLONEABLE_TAGS[weakMapTag] = false;\n\n\t/** Used to compose unicode character classes. */\n\tvar rsAstralRange = '\\\\ud800-\\\\udfff';\n\tvar rsComboMarksRange = '\\\\u0300-\\\\u036f';\n\tvar reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f';\n\tvar rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff';\n\tvar rsComboMarksExtendedRange = '\\\\u1ab0-\\\\u1aff';\n\tvar rsComboMarksSupplementRange = '\\\\u1dc0-\\\\u1dff';\n\tvar rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;\n\tvar rsDingbatRange = '\\\\u2700-\\\\u27bf';\n\tvar rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff';\n\tvar rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7';\n\tvar rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf';\n\tvar rsPunctuationRange = '\\\\u2000-\\\\u206f';\n\tvar rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000';\n\tvar rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde';\n\tvar rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\tvar rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n\t/** Used to compose unicode capture groups. */\n\tvar rsApos = '[\\'\\u2019]';\n\tvar rsBreak = \"[\" + rsBreakRange + \"]\";\n\tvar rsCombo = \"[\" + rsComboRange + \"]\";\n\tvar rsDigit = '\\\\d';\n\tvar rsDingbat = \"[\" + rsDingbatRange + \"]\";\n\tvar rsLower = \"[\" + rsLowerRange + \"]\";\n\tvar rsMisc = \"[^\" + rsAstralRange + (rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange) + \"]\";\n\tvar rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\n\tvar rsModifier = \"(?:\" + rsCombo + \"|\" + rsFitz + \")\";\n\tvar rsNonAstral = \"[^\" + rsAstralRange + \"]\";\n\tvar rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\n\tvar rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\n\tvar rsUpper = \"[\" + rsUpperRange + \"]\";\n\tvar rsZWJ = '\\\\u200d';\n\n\t/** Used to compose unicode regexes. */\n\tvar rsMiscLower = \"(?:\" + rsLower + \"|\" + rsMisc + \")\";\n\tvar rsMiscUpper = \"(?:\" + rsUpper + \"|\" + rsMisc + \")\";\n\tvar rsOptContrLower = \"(?:\" + rsApos + \"(?:d|ll|m|re|s|t|ve))?\";\n\tvar rsOptContrUpper = \"(?:\" + rsApos + \"(?:D|LL|M|RE|S|T|VE))?\";\n\tvar reOptMod = rsModifier + \"?\";\n\tvar rsOptVar = \"[\" + rsVarRange + \"]?\";\n\tvar rsOptJoin = \"(?:\" + rsZWJ + \"(?:\" + ([rsNonAstral, rsRegional, rsSurrPair].join('|')) + \")\" + (rsOptVar + reOptMod) + \")*\";\n\tvar rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])';\n\tvar rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])';\n\tvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\n\tvar rsEmoji = \"(?:\" + ([rsDingbat, rsRegional, rsSurrPair].join('|')) + \")\" + rsSeq;\n\n\tvar reUnicodeWords = RegExp([\n\t    (rsUpper + \"?\" + rsLower + \"+\" + rsOptContrLower + \"(?=\" + ([rsBreak, rsUpper, '$'].join('|')) + \")\"),\n\t    (rsMiscUpper + \"+\" + rsOptContrUpper + \"(?=\" + ([rsBreak, rsUpper + rsMiscLower, '$'].join('|')) + \")\"),\n\t    (rsUpper + \"?\" + rsMiscLower + \"+\" + rsOptContrLower),\n\t    (rsUpper + \"+\" + rsOptContrUpper),\n\t    rsOrdUpper,\n\t    rsOrdLower,\n\t    (rsDigit + \"+\"),\n\t    rsEmoji\n\t].join('|'), 'g');\n\n\tvar LARGE_ARRAY_SIZE = 200;\n\tvar HASH_UNDEFINED = '__hash_undefined__';\n\n\t// Used to match `toStringTag` values of typed arrays\n\tvar reTypedTag = /^\\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\\]$/;\n\n\t// Used to compose unicode capture groups\n\tvar rsAstral = \"[\" + rsAstralRange + \"]\";\n\n\t// Used to compose unicode regexes\n\tvar rsNonAstralCombo = \"\" + rsNonAstral + rsCombo + \"?\";\n\tvar rsSymbol = \"(?:\" + ([rsNonAstralCombo, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')) + \")\";\n\n\t// Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode)\n\tvar reUnicode = RegExp((rsFitz + \"(?=\" + rsFitz + \")|\" + (rsSymbol + rsSeq)), 'g');\n\n\tvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\n\tvar reIsPlainProp = /^\\w*$/;\n\n\tvar charCodeOfDot = '.'.charCodeAt(0);\n\tvar reEscapeChar = /\\\\(\\\\)?/g;\n\tvar rePropName = RegExp(\n\t    // Match anything that isn't a dot or bracket.\n\t    '[^.[\\\\]]+' + '|' +\n\t  // Or match property names within brackets.\n\t  '\\\\[(?:' +\n\t    // Match a non-string expression.\n\t    '([^\"\\'][^[]*)' + '|' +\n\t    // Or match strings (supports escaping characters).\n\t    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n\t  ')\\\\]'+ '|' +\n\t  // Or match \"\" as the space between consecutive dots or empty brackets.\n\t  '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\n\t    , 'g');\n\tvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n\tvar hasUnicodeWord = RegExp.prototype.test.bind(\n\t    /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/\n\t);\n\n\tvar MAX_ARRAY_INDEX = 4294967295 - 1;\n\n\t/** Used to match words composed of alphanumeric characters. */\n\t// eslint-disable-next-line no-control-regex\n\tvar reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n\n\n\t// -- helper functions\n\tvar hasUnicode = function (string) {\n\t    return reUnicode.test(string);\n\t};\n\n\tvar unicodeToArray = function (string) {\n\t    return string.match(reUnicode) || [];\n\t};\n\n\tvar asciiToArray = function (string) {\n\t    return string.split('');\n\t};\n\n\tvar stringToArray = function (string) {\n\t    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n\t};\n\n\tvar values = function (object) {\n\t    if (object == null) {\n\t        return [];\n\t    }\n\n\t    return keys$1(object).map(function (key) { return object[key]; });\n\t};\n\n\tvar keys$1 = function (object) {\n\t    return isArrayLike(object) ? arrayLikeKeys(object) : Object.keys(Object(object));\n\t};\n\n\tvar baseKeys = function (object) {\n\t    if (!isPrototype(object)) {\n\t        return Object.keys(object);\n\t    }\n\t    var result = [];\n\t    for (var key in Object(object)) {\n\t        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n\t            result.push(key);\n\t        }\n\t    }\n\n\t    return result;\n\t};\n\n\tvar arrayLikeKeys = function (value, inherited) {\n\t    var isArr = Array.isArray(value);\n\t    var isArg = !isArr && isObjectLike(value) && getTag(value) === argsTag;\n\t    var isType = !isArr && !isArg && isTypedArray(value);\n\t    var skipIndexes = isArr || isArg || isType;\n\t    var length = value.length;\n\t    var result = new Array(skipIndexes ? length : 0);\n\t    var index = skipIndexes ? -1 : length;\n\t    while (++index < length) {\n\t        result[index] = \"\" + index;\n\t    }\n\t    for (var key in value) {\n\t        if ((inherited || hasOwnProperty.call(value, key)) &&\n\t            !(skipIndexes && (\n\t                // Safari 9 has enumerable `arguments.length` in strict mode.\n\t                key === 'length' ||\n\t                // Skip index properties.\n\t                isIndex(key, length)\n\t            ))\n\t        ) {\n\t            result.push(key);\n\t        }\n\t    }\n\t    return result;\n\t};\n\n\tvar assocIndexOf = function (array, key) {\n\t    var length = array.length;\n\t    while (length--) {\n\t        if (eq(array[length][0], key)) {\n\t            return length;\n\t        }\n\t    }\n\t    return -1;\n\t};\n\n\tvar eq = function (value, other) {\n\t    return value === other || (value !== value && other !== other);\n\t};\n\n\tvar isObjectLike = function (value) {\n\t    return value != null && typeof value == 'object';\n\t};\n\n\tvar isIterateeCall = function (value, index, object) {\n\t    if (!isObject$1(object)) {\n\t        return false;\n\t    }\n\t    var type = typeof index;\n\n\t    var isPossibleIteratee = type == 'number' ?\n\t        (isArrayLike(object) && index > -1 && index < object.length) :\n\t        (type == 'string' && index in object);\n\n\t    if (isPossibleIteratee) {\n\t        return eq(object[index], value);\n\t    }\n\t    return false;\n\t};\n\n\tvar isSet = function (value) {\n\t    return isObjectLike(value) && getTag(value) == setTag;\n\t};\n\n\tvar isMap = function (value) {\n\t    return isObjectLike(value) && getTag(value) == mapTag;\n\t};\n\n\tvar isPrototype = function (value) {\n\t    var Ctor = value && value.constructor;\n\t    var proto = (typeof Ctor === 'function' && Ctor.prototype) || Object.prototype;\n\n\t    return value === proto;\n\t};\n\n\tvar assignValue = function (object, key, value) {\n\t    var objValue = object[key];\n\t    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n\t        (value === undefined && !(key in object))) {\n\t        object[key] = value;\n\t    }\n\t};\n\n\tvar copyObject = function (source, props, object) {\n\t    var index = -1;\n\t    var length = props.length;\n\n\t    while (++index < length) {\n\t        var key = props[index];\n\t        assignValue(object, key, source[key]);\n\t    }\n\t    return object;\n\t};\n\n\tvar isArrayLike = function (value) {\n\t    return value != null && typeof value !== 'function' && typeof value.length === 'number' &&\n\t        value.length > -1 && value.length % 1 === 0;\n\t};\n\n\tvar isSymbol = function (value) {\n\t    return typeof value == 'symbol' ||\n\t        (isObjectLike(value) && getTag(value) === symbolTag);\n\t};\n\n\tvar initCloneArray = function (array) {\n\t    var length = array.length;\n\t    var result = new array.constructor(length);\n\n\t    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n\t        result.index = array.index;\n\t        result.input = array.input;\n\t    }\n\n\t    return result;\n\t};\n\n\tvar copyArray = function (source, array) {\n\t    var index = -1;\n\t    var length = source.length;\n\n\t    array || (array = new Array(length));\n\t    while (++index < length) {\n\t        array[index] = source[index];\n\t    }\n\t    return array;\n\t};\n\n\tvar getTag = function (value) {\n\t    if (value == null) {\n\t        return value === undefined ? undefinedTag : nullTag;\n\t    }\n\n\t    return Object.prototype.toString.call(value);\n\t};\n\n\tvar cloneArrayBuffer = function (arrayBuffer) {\n\t    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n\t    new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n\t    return result;\n\t};\n\n\tvar cloneTypedArray = function (typedArray, isDeep) {\n\t    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n\t    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n\t};\n\n\tvar cloneRegExp = function (regexp) {\n\t    var result = new regexp.constructor(regexp.source, /\\w*$/.exec(regexp));\n\t    result.lastIndex = regexp.lastIndex;\n\t    return result;\n\t};\n\n\tvar initCloneObject = function (object) {\n\t    return (typeof object.constructor == 'function' && !isPrototype(object))\n\t        ? Object.create(Object.getPrototypeOf(object))\n\t        : {};\n\t};\n\n\tvar getSymbols = function (object) {\n\t    if (object == null) {\n\t        return [];\n\t    }\n\n\t    object = Object(object);\n\t    var symbols = Object.getOwnPropertySymbols(object);\n\n\t    return symbols.filter(function (symbol) { return propertyIsEnumerable.call(object, symbol); });\n\t};\n\n\tvar copySymbols = function (source, object) {\n\t    return copyObject(source, getSymbols(source), object);\n\t};\n\n\tfunction cloneDataView(dataView, isDeep) {\n\t    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n\t    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n\t}\n\n\tvar initCloneByTag = function (object, tag, isDeep) {\n\t    var Constructor = object.constructor;\n\t    switch(tag) {\n\t        case arrayBufferTag:\n\t            return cloneArrayBuffer(object, isDeep);\n\t        case boolTag:\n\t        case dateTag:\n\t            return new Constructor(+object);\n\t        case dataViewTag:\n\t            return cloneDataView(object, isDeep);\n\t        case float32Tag:\n\t        case float64Tag:\n\t        case int8Tag:\n\t        case int16Tag:\n\t        case int32Tag:\n\t        case uint8Tag:\n\t        case uint8ClampedTag:\n\t        case uint16Tag:\n\t        case uint32Tag:\n\t            return cloneTypedArray(object, isDeep);\n\t        case mapTag:\n\t            return new Constructor(object);\n\t        case numberTag:\n\t        case stringTag:\n\t            return new Constructor(object);\n\t        case regexpTag:\n\t            return cloneRegExp(object);\n\t        case setTag:\n\t            return new Constructor;\n\t        case symbolTag:\n\t            return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(object)) : {};\n\t    }\n\t};\n\n\tvar isTypedArray = function (value) {\n\t    return isObjectLike(value) && reTypedTag.test(getTag(value));\n\t};\n\n\tvar getAllKeys = function (object) {\n\t    var result = Object.keys(object);\n\t    if(!Array.isArray(object) && object != null) {\n\t        result.push.apply(result, getSymbols(Object(object)));\n\t    }\n\n\t    return result;\n\t};\n\n\tvar getSymbolsIn = function (object) {\n\t    var result = [];\n\t    while (object) {\n\t        result.push.apply(result, getSymbols(object));\n\t        object = Object.getPrototypeOf(Object(object));\n\t    }\n\n\t    return result;\n\t};\n\n\tvar getAllKeysIn = function (object) {\n\t    var result = [];\n\n\t    for (var key in object) {\n\t        result.push(key);\n\t    }\n\n\t    if (!Array.isArray(object)) {\n\t        result.push.apply(result, getSymbolsIn(object));\n\t    }\n\n\t    return result;\n\t};\n\n\tvar getMapData = function (ref, key) {\n\t    var __data__ = ref.__data__;\n\n\t    var data = __data__;\n\t    return isKeyable(key)\n\t        ? data[typeof key === 'string' ? 'string' : 'hash']\n\t        : data.map;\n\t};\n\n\tvar equalObjects = function (object, other, equalFunc, stack) {\n\t    var objProps = getAllKeys(object);\n\t    var objLength = objProps.length;\n\t    var othProps = getAllKeys(other);\n\t    var othLength = othProps.length;\n\n\t    if (objLength != othLength) {\n\t        return false;\n\t    }\n\t    var key;\n\t    var index = objLength;\n\t    while (index--) {\n\t        key = objProps[index];\n\t        if (!(hasOwnProperty.call(other, key))) {\n\t            return false;\n\t        }\n\t    }\n\n\t    var objStacked = stack.get(object);\n\t    var othStacked = stack.get(other);\n\t    if (objStacked && othStacked) {\n\t        return objStacked == other && othStacked == object;\n\t    }\n\t    var result = true;\n\t    stack.set(object, other);\n\t    stack.set(other, object);\n\n\t    var compared;\n\t    var skipCtor;\n\n\t    while (++index < objLength) {\n\t        key = objProps[index];\n\t        var objValue = object[key];\n\t        var othValue = other[key];\n\n\t        if (!(compared === undefined\n\t            ? (objValue === othValue || equalFunc(objValue, othValue, stack))\n\t            : compared\n\t        )) {\n\t            result = false;\n\t            break;\n\t        }\n\t        skipCtor || (skipCtor = key == 'constructor');\n\t    }\n\n\t    if (result && !skipCtor) {\n\t        var objCtor = object.constructor;\n\t        var othCtor = other.constructor;\n\n\t        if (objCtor != othCtor &&\n\t        ('constructor' in object && 'constructor' in other) &&\n\t        !(typeof objCtor === 'function' && objCtor instanceof objCtor &&\n\t            typeof othCtor === 'function' && othCtor instanceof othCtor)) {\n\t            result = false;\n\t        }\n\t    }\n\t    stack['delete'](object);\n\t    stack['delete'](other);\n\t    return result;\n\t};\n\n\tvar baseIsEqual = function (value, other, stack) {\n\t    if (value === other) {\n\t        return true;\n\t    }\n\t    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n\t        return value !== value && other !== other;\n\t    }\n\n\t    return baseIsEqualDeep(value, other, baseIsEqual, stack);\n\t};\n\n\tvar baseIsEqualDeep = function (object, other, equalFunc, stack) {\n\t    var objIsArr = Array.isArray(object);\n\t    var othIsArr = Array.isArray(other);\n\t    var objTag = objIsArr ? arrayTag : getTag(object);\n\t    var othTag = othIsArr ? arrayTag : getTag(other);\n\n\t    objTag = objTag == argsTag ? objectTag : objTag;\n\t    othTag = othTag == argsTag ? objectTag : othTag;\n\n\t    var objIsObj = objTag == objectTag;\n\t    var othIsObj = othTag == objectTag;\n\t    var isSameTag = objTag == othTag;\n\n\t    if (isSameTag && !objIsObj) {\n\t        stack || (stack = new Stack);\n\t        return (objIsArr || isTypedArray(object))\n\t            ? equalArrays(object, other, false, equalFunc, stack)\n\t            : equalByTag(object, other, objTag, equalFunc, stack);\n\t    }\n\n\t    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__');\n\t    var othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n\t    if (objIsWrapped || othIsWrapped) {\n\t        var objUnwrapped = objIsWrapped ? object.value() : object;\n\t        var othUnwrapped = othIsWrapped ? other.value() : other;\n\n\t        stack || (stack = new Stack);\n\t        return equalFunc(objUnwrapped, othUnwrapped, stack);\n\t    }\n\n\t    if (!isSameTag) {\n\t        return false;\n\t    }\n\n\t    stack || (stack = new Stack);\n\t    return equalObjects(object, other, equalFunc, stack);\n\t};\n\n\tvar equalArrays = function (array, other, compareUnordered, equalFunc, stack) {\n\t    var isPartial = false;\n\t    var arrLength = array.length;\n\t    var othLength = other.length;\n\n\t    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n\t        return false;\n\t    }\n\t    // Assume cyclic values are equal.\n\t    var arrStacked = stack.get(array);\n\t    var othStacked = stack.get(other);\n\t    if (arrStacked && othStacked) {\n\t        return arrStacked == other && othStacked == array;\n\t    }\n\t    var index = -1;\n\t    var result = true;\n\t    var seen = compareUnordered ? new SetCache : undefined;\n\n\t    stack.set(array, other);\n\t    stack.set(other, array);\n\n\t    var loop = function () {\n\t        var compared = (void 0);\n\t        var arrValue = array[index];\n\t        var othValue = other[index];\n\n\t        if (compared !== undefined) {\n\t            if (compared) {\n\t                return;\n\t            }\n\t            result = false;\n\t            return 'break';\n\t        }\n\n\t        if (seen) {\n\t            if (!some(other, function (othValue, othIndex) {\n\t                if (!cacheHas(seen, othIndex) &&\n\t            (arrValue === othValue || equalFunc(arrValue, othValue, stack))) {\n\t                    return seen.push(othIndex);\n\t                }\n\t            })) {\n\t                result = false;\n\t                return 'break';\n\t            }\n\t        } else if (!(\n\t            arrValue === othValue ||\n\t            equalFunc(arrValue, othValue, stack)\n\t        )) {\n\t            result = false;\n\t            return 'break';\n\t        }\n\t    };\n\n\t    while (++index < arrLength) {\n\t      var returned = loop();\n\n\t      if ( returned === 'break' ) break;\n\t    }\n\t    stack['delete'](array);\n\t    stack['delete'](other);\n\t    return result;\n\t};\n\n\tvar some = function (array, predicate) {\n\t    var index = -1;\n\t    var length = array == null ? 0 : array.length;\n\n\t    while (++index < length) {\n\t        if (predicate(array[index], index, array)) {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t};\n\n\tvar cacheHas = function (cache, key) {\n\t    return cache.has(key);\n\t};\n\n\tvar compareArrayBufferTag = function (object, other, equalFunc, stack) {\n\t    if ((object.byteLength != other.byteLength) ||\n\t                !equalFunc(new Uint8Array(object), new Uint8Array(other), stack)) {\n\t        return false;\n\t    }\n\t    return true;\n\t};\n\n\tvar equalByTag = function (object, other, tag, equalFunc, stack) {\n\n\t    switch (tag) {\n\t        case dataViewTag:\n\t            if ((object.byteLength != other.byteLength) ||\n\t                (object.byteOffset != other.byteOffset)) {\n\t                return false;\n\t            }\n\t            object = object.buffer;\n\t            other = other.buffer;\n\t            return compareArrayBufferTag(object, other, equalFunc, stack);\n\t        case arrayBufferTag:\n\t            return compareArrayBufferTag(object, other, equalFunc, stack);\n\t        case boolTag:\n\t        case dateTag:\n\t        case numberTag:\n\t            return eq(+object, +other);\n\t        case errorTag:\n\t            return object.name == other.name && object.message == other.message;\n\t        case regexpTag:\n\t        case stringTag:\n\t            return object == (\"\" + other);\n\t        case mapTag:\n\t            var convert = mapToArray;\n\t        // Intentional fallthrough\n\t        // eslint-disable-next-line no-fallthrough\n\t        case setTag:\n\t            convert || (convert = setToArray);\n\n\t            if (object.size != other.size) {\n\t                return false;\n\t            }\n\t            // Assume cyclic values are equal.\n\t            var stacked = stack.get(object);\n\t            if (stacked) {\n\t                return stacked == other;\n\t            }\n\n\t            // Recursively compare objects (susceptible to call stack limits).\n\t            stack.set(object, other);\n\t            var result = equalArrays(convert(object), convert(other), true, equalFunc, stack);\n\t            stack['delete'](object);\n\t            return result;\n\t        case symbolTag:\n\t            return Symbol.prototype.valueOf.call(object) == Symbol.prototype.valueOf.call(other);\n\t    }\n\n\t    return false;\n\t};\n\n\tvar mapToArray = function (map) {\n\t    var index = -1;\n\t    var result = Array(map.size);\n\n\t    map.forEach(function (value, key) {\n\t        result[++index] = [key, value];\n\t    });\n\t    return result;\n\t};\n\n\tvar setToArray = function (set) {\n\t    var index = -1;\n\t    var result = new Array(set.size);\n\n\t    set.forEach(function (value) {\n\t        result[++index] = value;\n\t    });\n\t    return result;\n\t};\n\n\tvar isKey = function (value, object) {\n\t    if (Array.isArray(value)) {\n\t        return false;\n\t    }\n\t    var type = typeof value;\n\t    if (type === 'number' || type === 'boolean' || value == null || isSymbol(value)) {\n\t        return true;\n\t    }\n\t    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n\t    (object != null && value in Object(object));\n\t};\n\n\tvar stringToPath = function (string) {\n\t    var result = [];\n\t    if (string.charCodeAt(0) === charCodeOfDot) {\n\t        result.push('');\n\t    }\n\t    string.replace(rePropName, function (match, expression, quote, subString) {\n\t        var key = match;\n\t        if (quote) {\n\t            key = subString.replace(reEscapeChar, '$1');\n\t        }\n\t        else if (expression) {\n\t            key = expression.trim();\n\t        }\n\t        result.push(key);\n\t    });\n\t    return result;\n\t};\n\n\tvar castPath = function (path, object) {\n\t    if (Array.isArray(path)) {\n\t        return path;\n\t    }\n\n\t    return isKey(path, object) ? [path] : stringToPath((\"\" + path));\n\t};\n\n\tvar get$1 = function (object, path) {\n\t    path = castPath(path, object);\n\n\t    var index = 0;\n\t    var length = path.length;\n\n\t    while (object != null && index < length) {\n\t        object = object[toKey(path[index])];\n\t        index++;\n\t    }\n\n\t    return (index && index == length) ? object : undefined;\n\t};\n\n\tfunction compareAscending(value, other) {\n\t    if (value !== other) {\n\t        var valIsDefined = value !== undefined;\n\t        var valIsNull = value === null;\n\t        var valIsReflexive = value === value;\n\t        var valIsSymbol = isSymbol(value);\n\n\t        var othIsDefined = other !== undefined;\n\t        var othIsNull = other === null;\n\t        var othIsReflexive = other === other;\n\t        var othIsSymbol = isSymbol(other);\n\n\t        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n\t            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n\t            (valIsNull && othIsDefined && othIsReflexive) ||\n\t            (!valIsDefined && othIsReflexive) ||\n\t            !valIsReflexive) {\n\t            return 1;\n\t        }\n\t        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n\t            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n\t            (othIsNull && valIsDefined && valIsReflexive) ||\n\t            (!othIsDefined && valIsReflexive) ||\n\t            !othIsReflexive) {\n\t            return -1;\n\t        }\n\t    }\n\t    return 0;\n\t}\n\n\tfunction compareMultiple(object, other, orders) {\n\t    var index = -1;\n\t    var objCriteria = object.criteria;\n\t    var othCriteria = other.criteria;\n\t    var length = objCriteria.length;\n\t    var ordersLength = orders.length;\n\n\t    while (++index < length) {\n\t        var order = index < ordersLength ? orders[index] : null;\n\t        var cmpFn = (order && typeof order === 'function') ? order : compareAscending;\n\t        var result = cmpFn(objCriteria[index], othCriteria[index]);\n\t        if (result) {\n\t            if (order && typeof order !== 'function') {\n\t                return result * (order == 'desc' ? -1 : 1);\n\t            }\n\t            return result;\n\t        }\n\t    }\n\n\t    return object.index - other.index;\n\t}\n\n\tvar diff = function (array, values) {\n\t    var includes = function (array, value) {\n\t        var length = array == null ? 0 : array.length;\n\t        return !!length && array.indexOf(value) > -1;\n\t    };\n\t    var isCommon = true;\n\t    var result = [];\n\t    var valuesLength = values.length;\n\n\t    if (!array.length) {\n\t        return result;\n\t    }\n\n\t    if (values.length >= LARGE_ARRAY_SIZE) {\n\t        includes = function (cache, key) { return cache.has(key); };\n\t        isCommon = false;\n\t        values = new SetCache(values);\n\t    }\n\n\t    outer:\n\t    for (var key in array) {\n\t        var value = array[key];\n\t        var computed = value;\n\n\t        value = (value !== 0) ? value : 0;\n\t        if (isCommon && computed === computed) {\n\t            var valuesIndex = valuesLength;\n\t            while (valuesIndex--) {\n\t                if (values[valuesIndex] === computed) {\n\t                    continue outer;\n\t                }\n\t            }\n\t            result.push(value);\n\t        }\n\t        else if (!includes(values, computed)) {\n\t            result.push(value);\n\t        }\n\t    }\n\n\t    return result;\n\t};\n\n\tvar intersect = function (arrays) {\n\t    var includes = function (array, value) {\n\t        var length = array == null ? 0 : array.length;\n\t        return !!length && array.indexOf(value) > -1;\n\t    };\n\t    var cacheHas = function (cache, key) { return cache.has(key); };\n\t    var length = arrays[0].length;\n\t    var othLength = arrays.length;\n\t    var caches = new Array(othLength);\n\t    var result = [];\n\n\t    var array;\n\t    var maxLength = Infinity;\n\t    var othIndex = othLength;\n\n\t    while (othIndex--) {\n\t        array = arrays[othIndex];\n\n\t        maxLength = Math.min(array.length, maxLength);\n\t        caches[othIndex] = length >= 120 && array.length >= 120\n\t            ? new SetCache(othIndex && array)\n\t            : undefined;\n\t    }\n\t    array = arrays[0];\n\n\t    var index = -1;\n\t    var seen = caches[0];\n\n\t    outer:\n\t    while (++index < length && result.length < maxLength) {\n\t        var value = array[index];\n\t        var computed = value;\n\n\t        value = (value !== 0) ? value : 0;\n\t        if (!(seen\n\t            ? cacheHas(seen, computed)\n\t            : includes(result, computed)\n\t        )) {\n\t            othIndex = othLength;\n\t            while (--othIndex) {\n\t                var cache = caches[othIndex];\n\t                if (!(cache\n\t                    ? cacheHas(cache, computed)\n\t                    : includes(arrays[othIndex], computed))\n\t                ) {\n\t                    continue outer;\n\t                }\n\t            }\n\t            if (seen) {\n\t                seen.push(computed);\n\t            }\n\t            result.push(value);\n\t        }\n\t    }\n\t    return result;\n\t};\n\n\tvar toKey = function (value) {\n\t    if (typeof value === 'string' || isSymbol(value)) {\n\t        return value;\n\t    }\n\t    var result = \"\" + value;\n\t    return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;\n\t};\n\n\tvar baseClone = function (value, isDeep, isFlat, isFull, customizer, key, object, stack) {\n\t    if ( isDeep === void 0 ) isDeep = false;\n\t    if ( isFlat === void 0 ) isFlat = false;\n\t    if ( isFull === void 0 ) isFull = true;\n\n\t    var result;\n\n\t    if (customizer) {\n\t        result = object ? customizer(value, key, object, stack) : customizer(value);\n\t    }\n\n\t    if (result !== undefined) {\n\t        return result;\n\t    }\n\n\t    if (!isObject$1(value)) {\n\t        return value;\n\t    }\n\n\t    var isArr = Array.isArray(value);\n\t    var tag = getTag(value);\n\n\t    if (isArr) {\n\t        result = initCloneArray(value);\n\n\t        if (!isDeep) {\n\t            return copyArray(value, result);\n\t        }\n\t    } else {\n\t        var isFunc = typeof value === 'function';\n\n\t        if (tag === objectTag || tag === argsTag || (isFunc && !object)) {\n\t            result = (isFlat || isFunc) ? {} : initCloneObject(value);\n\t            if (!isDeep) {\n\t                return isFlat ?\n\t                    copySymbolsIn(value, copyObject(value, Object.keys(value), result)) :\n\t                    copySymbols(value, Object.assign(result, value));\n\t            }\n\t        } else {\n\t            if (isFunc || !CLONEABLE_TAGS[tag]) {\n\t                return object ? value : {};\n\t            }\n\t            result = initCloneByTag(value, tag, isDeep);\n\t        }\n\t    }\n\n\t    stack || (stack = new Stack);\n\t    var stacked = stack.get(value);\n\n\t    if (stacked) {\n\t        return stacked;\n\t    }\n\n\t    stack.set(value, result);\n\n\t    if (isMap(value)) {\n\t        value.forEach(function (subValue, key) {\n\t            result.set(key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n\t        });\n\n\t        return result;\n\t    }\n\n\t    if (isSet(value)) {\n\t        value.forEach(function (subValue) {\n\t            result.add(baseClone(subValue, isDeep, isFlat, isFull, customizer, subValue, value, stack));\n\t        });\n\n\t        return result;\n\t    }\n\n\t    if(isTypedArray(value)) {\n\t        return result;\n\t    }\n\n\t    var keysFunc = isFull\n\t        ? (isFlat ? getAllKeysIn : getAllKeys)\n\t        : (isFlat ? keysIn : keys$1);\n\n\t    var props =  isArr ? undefined : keysFunc(value);\n\n\t    (props || value).forEach(function (subValue, key) {\n\t        if (props) {\n\t            key = subValue;\n\t            subValue = value[key];\n\t        }\n\n\t        assignValue(result, key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n\t    });\n\n\t    return result;\n\t};\n\n\tvar copySymbolsIn = function (source, object) {\n\t    return copyObject(source, getSymbolsIn(source), object);\n\t};\n\n\tvar parent = function (object, path) {\n\t    return path.length < 2 ? object : get$1(object, path.slice(0, -1));\n\t};\n\n\tvar set$1 = function (object, path, value) {\n\t    if (!isObject$1(object)) {\n\t        return object;\n\t    }\n\t    path = castPath(path, object);\n\n\t    var length = path.length;\n\t    var lastIndex = length - 1;\n\n\t    var index = -1;\n\t    var nested = object;\n\n\t    while (nested != null && ++index < length) {\n\t        var key = toKey(path[index]);\n\t        var newValue = value;\n\n\t        if (index != lastIndex) {\n\t            var objValue = nested[key];\n\t            newValue = undefined;\n\t            if (newValue === undefined) {\n\t                newValue = isObject$1(objValue)\n\t                    ? objValue\n\t                    : (isIndex(path[index + 1]) ? [] : {});\n\t            }\n\t        }\n\t        assignValue(nested, key, newValue);\n\t        nested = nested[key];\n\t    }\n\t    return object;\n\t};\n\n\tvar isIndex = function (value, length) {\n\t    var type = typeof value;\n\t    length = length == null ? Number.MAX_SAFE_INTEGER : length;\n\n\t    return !!length &&\n\t    (type === 'number' ||\n\t        (type !== 'symbol' && reIsUint.test(value))) &&\n\t        (value > -1 && value % 1 == 0 && value < length);\n\t};\n\n\tvar unset = function (object, path) {\n\t    path = castPath(path, object);\n\t    object = parent(object, path);\n\t    var lastSegment = path[path.length - 1];\n\t    return object == null || delete object[toKey(lastSegment)];\n\t};\n\n\tvar isKeyable = function (value) {\n\t    var type = typeof value;\n\t    return (type === 'string' || type === 'number' || type === 'symbol' || type === 'boolean')\n\t        ? (value !== '__proto__')\n\t        : (value === null);\n\t};\n\n\tvar keysIn = function (object) {\n\t    var result = [];\n\t    for (var key in object) {\n\t        result.push(key);\n\t    }\n\t    return result;\n\t};\n\n\tvar toPlainObject = function (value) {\n\t    value = Object(value);\n\t    var result = {};\n\t    for (var key in value) {\n\t        result[key] = value[key];\n\t    }\n\t    return result;\n\t};\n\n\tvar safeGet = function (object, key) {\n\t    if (key === 'constructor' && typeof object[key] === 'function') {\n\t        return;\n\t    }\n\n\t    if (key == '__proto__') {\n\t        return;\n\t    }\n\n\t    return object[key];\n\t};\n\n\tfunction createAssigner(assigner, isMerge) {\n\t    if ( isMerge === void 0 ) isMerge = false;\n\n\t    return function (object) {\n\t        var sources = [], len = arguments.length - 1;\n\t        while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n\t        var index = -1;\n\t        var length = sources.length;\n\t        var customizer = length > 1 ? sources[length - 1] : undefined;\n\t        var guard = length > 2 ? sources[2] : undefined;\n\n\t        customizer = (assigner.length > 3 && typeof customizer === 'function')\n\t            ? (length--, customizer)\n\t            : isMerge ? function (a, b) {\n\t                if (Array.isArray(a) && !Array.isArray(b)) {\n\t                    return b;\n\t                }\n\t            } : undefined;\n\n\t        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n\t            customizer = length < 3 ? undefined : customizer;\n\t            length = 1;\n\t        }\n\t        object = Object(object);\n\t        while (++index < length) {\n\t            var source = sources[index];\n\t            if (source) {\n\t                assigner(object, source, index, customizer);\n\t            }\n\t        }\n\t        return object;\n\t    };\n\t}\n\n\tvar baseMerge = function (object, source, srcIndex, customizer, stack) {\n\t    if (object === source) {\n\t        return;\n\t    }\n\n\t    forIn(source, function (srcValue, key) {\n\t        if (isObject$1(srcValue)) {\n\t            stack || (stack = new Stack);\n\t            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n\t        } else {\n\t            var newValue = customizer\n\t                ? customizer(object[key], srcValue, (\"\" + key), object, source, stack)\n\t                : undefined;\n\n\t            if (newValue === undefined) {\n\t                newValue = srcValue;\n\t            }\n\n\t            assignMergeValue(object, key, newValue);\n\t        }\n\t    }, keysIn);\n\t};\n\n\tvar baseMergeDeep = function (object, source, key, srcIndex, mergeFunc, customizer, stack) {\n\t    var objValue = safeGet(object, key);\n\t    var srcValue = safeGet(source, key);\n\t    var stacked = stack.get(srcValue);\n\n\t    if (stacked) {\n\t        assignMergeValue(object, key, stacked);\n\t        return;\n\t    }\n\n\t    var newValue = customizer\n\t        ? customizer(objValue, srcValue, (\"\" + key), object, source, stack)\n\t        : undefined;\n\n\t    var isCommon = newValue === undefined;\n\n\t    if (isCommon) {\n\t        var isArr = Array.isArray(srcValue);\n\t        var isTyped = !isArr && isTypedArray(srcValue);\n\n\t        newValue = srcValue;\n\t        if (isArr || isTyped) {\n\t            if (Array.isArray(objValue)) {\n\t                newValue = objValue;\n\t            }\n\t            else if (isObjectLike(objValue) && isArrayLike(objValue)) {\n\t                newValue = copyArray(objValue);\n\t            }\n\t            else if (isTyped) {\n\t                isCommon = false;\n\t                newValue = cloneTypedArray(srcValue, true);\n\t            }\n\t            else {\n\t                newValue = [];\n\t            }\n\t        }\n\t        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n\t            newValue = objValue;\n\t            if (isArguments(objValue)) {\n\t                newValue = toPlainObject(objValue);\n\t            }\n\t            else if (typeof objValue === 'function' || !isObject$1(objValue)) {\n\t                newValue = initCloneObject(srcValue);\n\t            }\n\t        }\n\t        else {\n\t            isCommon = false;\n\t        }\n\t    }\n\t    if (isCommon) {\n\t    // Recursively merge objects and arrays (susceptible to call stack limits).\n\t        stack.set(srcValue, newValue);\n\t        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n\t        stack['delete'](srcValue);\n\t    }\n\t    assignMergeValue(object, key, newValue);\n\t};\n\n\tvar assignMergeValue = function (object, key, value) {\n\t    if ((value !== undefined && !eq(object[key], value)) ||\n\t        (value === undefined && !(key in object))) {\n\t        assignValue(object, key, value);\n\t    }\n\t};\n\n\tfunction baseFor(object, iteratee, keysFunc) {\n\t    var iterable = Object(object);\n\t    var props = keysFunc(object);\n\t    var length = props.length;\n\t    var index = -1;\n\n\t    while (length--) {\n\t        var key = props[++index];\n\t        if (iteratee(iterable[key], key, iterable) === false) {\n\t            break;\n\t        }\n\t    }\n\t    return object;\n\t}\n\n\tvar baseForOwn = function (object, iteratee) {\n\t    return object && baseFor(object, iteratee, keys$1);\n\t};\n\n\tvar baseEach = function (collection, iteratee) {\n\t    if (collection == null) {\n\t        return collection;\n\t    }\n\t    if (!isArrayLike(collection)) {\n\t        return baseForOwn(collection, iteratee);\n\t    }\n\t    var length = collection.length;\n\t    var iterable = Object(collection);\n\t    var index = -1;\n\n\t    while (++index < length) {\n\t        if (iteratee(iterable[index], index, iterable) === false) {\n\t            break;\n\t        }\n\t    }\n\t    return collection;\n\t};\n\n\tfunction last(array) {\n\t    var length = array == null ? 0 : array.length;\n\t    return length ? array[length - 1] : undefined;\n\t}\n\n\tvar createSet = (Set && (1 / setToArray(new Set([undefined,-0]))[1]) == 1 / 0)\n\t    ? function (values) { return new Set(values); }\n\t    : function () {};\n\n\tfunction customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n\t    if (isObject$1(objValue) && isObject$1(srcValue)) {\n\t    // Recursively merge objects and arrays (susceptible to call stack limits).\n\t        stack.set(srcValue, objValue);\n\t        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n\t        stack['delete'](srcValue);\n\t    }\n\t    return objValue;\n\t}\n\n\tfunction baseOrderBy(collection, iteratees, orders) {\n\t    if (iteratees.length) {\n\t        iteratees = iteratees.map(function (iteratee) {\n\t            if (Array.isArray(iteratee)) {\n\t                return function (value) { return get$1(value, iteratee.length === 1 ? iteratee[0] : iteratee); };\n\t            }\n\n\t            return iteratee;\n\t        });\n\t    } else {\n\t        iteratees = [function (value) { return value; }];\n\t    }\n\n\t    var criteriaIndex = -1;\n\t    var eachIndex = -1;\n\n\t    var result = isArrayLike(collection) ? new Array(collection.length) : [];\n\n\t    baseEach(collection, function (value) {\n\t        var criteria = iteratees.map(function (iteratee) { return iteratee(value); });\n\n\t        result[++eachIndex] = {\n\t            criteria: criteria,\n\t            index: ++criteriaIndex,\n\t            value: value\n\t        };\n\t    });\n\n\t    return baseSortBy(result, function (object, other) { return compareMultiple(object, other, orders); });\n\t}\n\n\tfunction baseSortBy(array, comparer) {\n\t    var length = array.length;\n\n\t    array.sort(comparer);\n\t    while (length--) {\n\t        array[length] = array[length].value;\n\t    }\n\t    return array;\n\t}\n\n\tfunction isStrictComparable(value) {\n\t    return value === value && !isObject$1(value);\n\t}\n\n\tfunction matchesStrictComparable(key, srcValue) {\n\t    return function (object) {\n\t        if (object == null) {\n\t            return false;\n\t        }\n\t        return object[key] === srcValue &&\n\t            (srcValue !== undefined || (key in Object(object)));\n\t    };\n\t}\n\n\tfunction hasIn(object, path) {\n\t    return object != null && hasPath(object, path, baseHasIn);\n\t}\n\n\tfunction baseMatchesProperty(path, srcValue) {\n\t    if (isKey(path) && isStrictComparable(srcValue)) {\n\t        return matchesStrictComparable(toKey(path), srcValue);\n\t    }\n\t    return function (object) {\n\t        var objValue = get$1(object, path);\n\t        return (objValue === undefined && objValue === srcValue)\n\t            ? hasIn(object, path)\n\t            : baseIsEqual(srcValue, objValue);\n\t    };\n\t}\n\n\tfunction baseMatches(source) {\n\t    var matchData = getMatchData(source);\n\t    if (matchData.length === 1 && matchData[0][2]) {\n\t        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n\t    }\n\t    return function (object) { return object === source || baseIsMatch(object, source, matchData); };\n\t}\n\n\tfunction getMatchData(object) {\n\t    var result = keys$1(object);\n\t    var length = result.length;\n\n\t    while (length--) {\n\t        var key = result[length];\n\t        var value = object[key];\n\t        result[length] = [key, value, isStrictComparable(value)];\n\t    }\n\t    return result;\n\t}\n\n\tfunction baseIsMatch(object, source, matchData, customizer) {\n\t    var index = matchData.length;\n\t    var length = index;\n\t    var noCustomizer = !customizer;\n\n\t    if (object == null) {\n\t        return !length;\n\t    }\n\t    var data;\n\t    var result;\n\t    object = Object(object);\n\t    while (index--) {\n\t        data = matchData[index];\n\t        if ((noCustomizer && data[2])\n\t            ? data[1] !== object[data[0]]\n\t            : !(data[0] in object)\n\t        ) {\n\t            return false;\n\t        }\n\t    }\n\t    while (++index < length) {\n\t        data = matchData[index];\n\t        var key = data[0];\n\t        var objValue = object[key];\n\t        var srcValue = data[1];\n\n\t        if (noCustomizer && data[2]) {\n\t            if (objValue === undefined && !(key in object)) {\n\t                return false;\n\t            }\n\t        } else {\n\t            var stack = new Stack;\n\t            if (customizer) {\n\t                result = customizer(objValue, srcValue, key, object, source, stack);\n\t            }\n\t            if (!(result === undefined\n\t                ? baseIsEqual(srcValue, objValue, stack)\n\t                : result\n\t            )) {\n\t                return false;\n\t            }\n\t        }\n\t    }\n\t    return true;\n\t}\n\n\tfunction property(path) {\n\t    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n\t}\n\n\tfunction baseProperty(key) {\n\t    return function (object) { return object == null ? undefined : object[key]; };\n\t}\n\n\tfunction basePropertyDeep(path) {\n\t    return function (object) { return get$1(object, path); };\n\t}\n\n\tfunction baseIteratee(value) {\n\t    if (typeof value == 'function') {\n\t        return value;\n\t    }\n\t    if (value == null) {\n\t        return function (val) { return val; };\n\t    }\n\t    if (typeof value == 'object') {\n\t        return Array.isArray(value)\n\t            ? baseMatchesProperty(value[0], value[1])\n\t            : baseMatches(value);\n\t    }\n\t    return property(value);\n\t}\n\n\tfunction getIteratee() {\n\t    var result = baseIteratee;\n\t    return arguments.length ? result(arguments[0], arguments[1]) : result;\n\t}\n\n\tvar arrayReduce = function (array, iteratee, accumulator, initAccum) {\n\t    var index = -1;\n\t    var length = array == null ? 0 : array.length;\n\n\t    if (initAccum && length) {\n\t        accumulator = array[++index];\n\t    }\n\t    while (++index < length) {\n\t        accumulator = iteratee(accumulator, array[index], index, array);\n\t    }\n\t    return accumulator;\n\t};\n\n\tvar baseReduce = function (collection, iteratee, accumulator, initAccum, eachFunc) {\n\t    eachFunc(collection, function (value, index, collection) {\n\t        accumulator = initAccum\n\t            ? (initAccum = false, value)\n\t            : iteratee(accumulator, value, index, collection);\n\t    });\n\t    return accumulator;\n\t};\n\n\tfunction reduce(collection, iteratee, accumulator) {\n\t    var func = Array.isArray(collection) ? arrayReduce : baseReduce;\n\t    var initAccum = arguments.length < 3;\n\t    return func(collection, iteratee, accumulator, initAccum, baseEach);\n\t}\n\n\tvar isFlattenable = function (value) {\n\t    return Array.isArray(value) || isArguments(value) ||\n\t    !!(value && value[Symbol.isConcatSpreadable]);\n\t};\n\n\tfunction baseFlatten(array, depth, predicate, isStrict, result) {\n\t    var index = -1;\n\t    var length = array.length;\n\n\t    predicate || (predicate = isFlattenable);\n\t    result || (result = []);\n\n\t    while (++index < length) {\n\t        var value = array[index];\n\t        if (depth > 0 && predicate(value)) {\n\t            if (depth > 1) {\n\t                // Recursively flatten arrays (susceptible to call stack limits).\n\t                baseFlatten(value, depth - 1, predicate, isStrict, result);\n\t            } else {\n\t                result.push.apply(result, value);\n\t            }\n\t        } else if (!isStrict) {\n\t            result[result.length] = value;\n\t        }\n\t    }\n\t    return result;\n\t}\n\n\tvar isArguments = function (value) {\n\t    return isObjectLike(value) && getTag(value) == '[object Arguments]';\n\t};\n\n\tvar basePick = function (object, paths) {\n\t    return basePickBy(object, paths, function (value, path) { return hasIn(object, path); });\n\t};\n\n\tvar basePickBy = function (object, paths, predicate) {\n\t    var index = -1;\n\t    var length = paths.length;\n\t    var result = {};\n\n\t    while (++index < length) {\n\t        var path = paths[index];\n\t        var value = get$1(object, path);\n\t        if (predicate(value, path)) {\n\t            set$1(result, castPath(path, object), value);\n\t        }\n\t    }\n\t    return result;\n\t};\n\n\tvar isLength = function (value) {\n\t    return typeof value == 'number' &&\n\t        value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;\n\t};\n\n\tvar baseHasIn = function (object, key) {\n\t    return object != null && key in Object(object);\n\t};\n\n\tvar hasPath = function (object, path, hasFunc) {\n\t    path = castPath(path, object);\n\n\t    var index = -1,\n\t        length = path.length,\n\t        result = false;\n\n\t    while (++index < length) {\n\t        var key = toKey(path[index]);\n\t        if (!(result = object != null && hasFunc(object, key))) {\n\t            break;\n\t        }\n\t        object = object[key];\n\t    }\n\t    if (result || ++index != length) {\n\t        return result;\n\t    }\n\t    length = object == null ? 0 : object.length;\n\t    return !!length && isLength(length) && isIndex(key, length) &&\n\t        (Array.isArray(object) || isArguments(object));\n\t};\n\n\tvar asciiWords = function (string) {\n\t    return string.match(reAsciiWord);\n\t};\n\n\tvar unicodeWords = function (string) {\n\t    return string.match(reUnicodeWords);\n\t};\n\n\tvar words = function (string, pattern) {\n\t    if (pattern === undefined) {\n\t        var result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n\t        return result || [];\n\t    }\n\t    return string.match(pattern) || [];\n\t};\n\n\tvar castSlice = function (array, start, end) {\n\t    var length = array.length;\n\t    end = end === undefined ? length : end;\n\t    return (!start && end >= length) ? array : array.slice(start, end);\n\t};\n\n\tvar upperFirst = createCaseFirst('toUpperCase');\n\n\tfunction createCaseFirst(methodName) {\n\t    return function (string) {\n\t        if (!string) {\n\t            return '';\n\t        }\n\n\t        var strSymbols = hasUnicode(string)\n\t            ? stringToArray(string)\n\t            : undefined;\n\n\t        var chr = strSymbols\n\t            ? strSymbols[0]\n\t            : string[0];\n\n\t        var trailing = strSymbols\n\t            ? castSlice(strSymbols, 1).join('')\n\t            : string.slice(1);\n\n\t        return chr[methodName]() + trailing;\n\t    };\n\t}\n\n\t// -- helper classes\n\tvar Stack = function Stack(entries) {\n\t      var data = this.__data__ = new ListCache(entries);\n\t      this.size = data.size;\n\t  };\n\n\t  Stack.prototype.clear = function clear () {\n\t      this.__data__ = new ListCache;\n\t      this.size = 0;\n\t  };\n\n\t  Stack.prototype.delete = function delete$1 (key) {\n\t      var data = this.__data__;\n\t      var result = data['delete'](key);\n\n\t      this.size = data.size;\n\t      return result;\n\t  };\n\n\t  Stack.prototype.get = function get (key) {\n\t      return this.__data__.get(key);\n\t  };\n\n\t  Stack.prototype.has = function has (key) {\n\t      return this.__data__.has(key);\n\t  };\n\n\t  Stack.prototype.set = function set (key, value) {\n\t      var data = this.__data__;\n\t      if (data instanceof ListCache) {\n\t          var pairs = data.__data__;\n\t          if (pairs.length < LARGE_ARRAY_SIZE - 1) {\n\t              pairs.push([key, value]);\n\t              this.size = ++data.size;\n\t              return this;\n\t          }\n\t          data = this.__data__ = new MapCache(pairs);\n\t      }\n\t      data.set(key, value);\n\t      this.size = data.size;\n\t      return this;\n\t  };\n\n\tvar ListCache = function ListCache(entries) {\n\t      var index = -1;\n\t      var length = entries == null ? 0 : entries.length;\n\n\t      this.clear();\n\t      while (++index < length) {\n\t          var entry = entries[index];\n\t          this.set(entry[0], entry[1]);\n\t      }\n\t  };\n\n\t  ListCache.prototype.clear = function clear () {\n\t      this.__data__ = [];\n\t      this.size = 0;\n\t  };\n\n\t  ListCache.prototype.delete = function delete$2 (key) {\n\t      var data = this.__data__;\n\t      var index = assocIndexOf(data, key);\n\n\t      if (index < 0) {\n\t          return false;\n\t      }\n\t      var lastIndex = data.length - 1;\n\t      if (index == lastIndex) {\n\t          data.pop();\n\t      } else {\n\t          data.splice(index, 1);\n\t      }\n\t      --this.size;\n\t      return true;\n\t  };\n\n\t  ListCache.prototype.get = function get (key) {\n\t      var data = this.__data__;\n\t      var index = assocIndexOf(data, key);\n\t      return index < 0 ? undefined : data[index][1];\n\t  };\n\n\t  ListCache.prototype.has = function has (key) {\n\t      return assocIndexOf(this.__data__, key) > -1;\n\t  };\n\n\t  ListCache.prototype.set = function set (key, value) {\n\t      var data = this.__data__;\n\t      var index = assocIndexOf(data, key);\n\n\t      if (index < 0) {\n\t          ++this.size;\n\t          data.push([key, value]);\n\t      } else {\n\t          data[index][1] = value;\n\t      }\n\t      return this;\n\t  };\n\n\tvar MapCache = function MapCache(entries) {\n\t      var index = -1;\n\t      var length = entries == null ? 0 : entries.length;\n\n\t      this.clear();\n\t      while (++index < length) {\n\t          var entry = entries[index];\n\t          this.set(entry[0], entry[1]);\n\t      }\n\t  };\n\n\t  MapCache.prototype.clear = function clear () {\n\t      this.size = 0;\n\t      this.__data__ = {\n\t          'hash': new Hash,\n\t          'map': new Map,\n\t          'string': new Hash\n\t      };\n\t  };\n\n\t  MapCache.prototype.delete = function delete$3 (key) {\n\t      var result = getMapData(this, key)['delete'](key);\n\t      this.size -= result ? 1 : 0;\n\t      return result;\n\t  };\n\n\t  MapCache.prototype.get = function get (key) {\n\t      return getMapData(this, key).get(key);\n\t  };\n\n\t  MapCache.prototype.has = function has (key) {\n\t      return getMapData(this, key).has(key);\n\t  };\n\n\t  MapCache.prototype.set = function set (key, value) {\n\t      var data = getMapData(this, key);\n\t      var size = data.size;\n\n\t      data.set(key, value);\n\t      this.size += data.size == size ? 0 : 1;\n\t      return this;\n\t  };\n\n\tvar Hash = function Hash(entries) {\n\t      var index = -1;\n\t      var length = entries == null ? 0 : entries.length;\n\n\t      this.clear();\n\t      while (++index < length) {\n\t          var entry = entries[index];\n\t          this.set(entry[0], entry[1]);\n\t      }\n\t  };\n\n\t  Hash.prototype.clear = function clear () {\n\t      this.__data__ = Object.create(null);\n\t      this.size = 0;\n\t  };\n\n\t  Hash.prototype.delete = function delete$4 (key) {\n\t      var result = this.has(key) && delete this.__data__[key];\n\t      this.size -= result ? 1 : 0;\n\t      return result;\n\t  };\n\n\t  Hash.prototype.get = function get (key) {\n\t      var data = this.__data__;\n\t      var result = data[key];\n\t      return result === HASH_UNDEFINED ? undefined : result;\n\t  };\n\n\t  Hash.prototype.has = function has (key) {\n\t      var data = this.__data__;\n\t      return data[key] !== undefined;\n\t  };\n\n\t  Hash.prototype.set = function set (key, value) {\n\t      var data = this.__data__;\n\t      this.size += this.has(key) ? 0 : 1;\n\t      data[key] = value === undefined ? HASH_UNDEFINED : value;\n\t      return this;\n\t  };\n\n\tvar SetCache = function SetCache(values) {\n\t      var index = -1;\n\t      var length = values == null ? 0 : values.length;\n\n\t      this.__data__ = new MapCache;\n\t      while (++index < length) {\n\t          this.add(values[index]);\n\t      }\n\t  };\n\n\t  SetCache.prototype.add = function add (value) {\n\t      this.__data__.set(value, HASH_UNDEFINED);\n\t      return this;\n\t  };\n\n\t  SetCache.prototype.has = function has (value) {\n\t      return this.__data__.has(value);\n\t  };\n\n\tSetCache.prototype.push = SetCache.prototype.add;\n\n\t// -- top level functions\n\n\tvar isBoolean = function(value) {\n\t    var toString = Object.prototype.toString;\n\t    return value === true || value === false || (!!value && typeof value === 'object' && toString.call(value) === boolTag);\n\t};\n\n\tvar isObject$1 = function(value) {\n\t    return !!value && (typeof value === 'object' || typeof value === 'function');\n\t};\n\n\tvar isNumber = function(value) {\n\t    var toString = Object.prototype.toString;\n\t    return typeof value === 'number' || (!!value && typeof value === 'object' && toString.call(value) === numberTag);\n\t};\n\n\tvar isString = function(value) {\n\t    var toString = Object.prototype.toString;\n\t    return typeof value === 'string' || (!!value && typeof value === 'object' && toString.call(value) === stringTag);\n\t};\n\n\tvar assign = createAssigner(function (object, source) {\n\t    if (isPrototype(source) || isArrayLike(source)) {\n\t        copyObject(source, keys$1(source), object);\n\t        return;\n\t    }\n\t    for (var key in source) {\n\t        if (hasOwnProperty.call(source, key)) {\n\t            assignValue(object, key, source[key]);\n\t        }\n\t    }\n\t});\n\n\tvar mixin = assign;\n\n\tvar deepMixin = mixin;\n\n\tvar supplement = function (object) {\n\t    var sources = [], len = arguments.length - 1;\n\t    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n\t    var index = -1;\n\t    var length = sources.length;\n\t    var guard = length > 2 ? sources[2] : undefined;\n\n\t    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n\t        length = 1;\n\t    }\n\n\t    while (++index < length) {\n\t        var source = sources[index];\n\n\t        if (source == null) {\n\t            continue;\n\t        }\n\n\t        var props = Object.keys(source);\n\t        var propsLength = props.length;\n\t        var propsIndex = -1;\n\n\t        while (++propsIndex < propsLength) {\n\t            var key = props[propsIndex];\n\t            var value = object[key];\n\n\t            if (value === undefined ||\n\t                (eq(value, Object.prototype[key]) && !hasOwnProperty.call(object, key))) {\n\t                object[key] = source[key];\n\t            }\n\t        }\n\t    }\n\n\t    return object;\n\t};\n\n\tvar defaults = supplement;\n\n\tvar deepSupplement = function defaultsDeep() {\n\t    var args = [], len = arguments.length;\n\t    while ( len-- ) args[ len ] = arguments[ len ];\n\n\t    args.push(undefined, customDefaultsMerge);\n\t    return merge.apply(undefined, args);\n\t};\n\n\tvar defaultsDeep = deepSupplement;\n\n\t// _.invokeMap\n\tvar invoke = function (collection, path) {\n\t    var args = [], len = arguments.length - 2;\n\t    while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];\n\n\t    var index = -1;\n\t    var isFunc = typeof path === 'function';\n\t    var result = isArrayLike(collection) ? new Array(collection.length) : [];\n\n\t    baseEach(collection, function (value) {\n\t        result[++index] = isFunc ? path.apply(value, args) : invokeProperty.apply(void 0, [ value, path ].concat( args ));\n\t    });\n\n\t    return result;\n\t};\n\n\t// _.invoke\n\tvar invokeProperty = function (object, path) {\n\t    var args = [], len = arguments.length - 2;\n\t    while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];\n\n\t    path = castPath(path, object);\n\t    object = parent(object, path);\n\t    var func = object == null ? object : object[toKey(last(path))];\n\t    return func == null ? undefined : func.apply(object, args);\n\t};\n\n\tvar sortedIndex = function (array, value, iteratee) {\n\t    var low = 0;\n\t    var high = array == null ? 0 : array.length;\n\t    if (high == 0) {\n\t        return 0;\n\t    }\n\n\t    iteratee = getIteratee(iteratee, 2);\n\t    value = iteratee(value);\n\n\t    var valIsNaN = value !== value;\n\t    var valIsNull = value === null;\n\t    var valIsSymbol = isSymbol(value);\n\t    var valIsUndefined = value === undefined;\n\n\t    while (low < high) {\n\t        var setLow = (void 0);\n\t        var mid = Math.floor((low + high) / 2);\n\t        var computed = iteratee(array[mid]);\n\t        var othIsDefined = computed !== undefined;\n\t        var othIsNull = computed === null;\n\t        var othIsReflexive = computed === computed;\n\t        var othIsSymbol = isSymbol(computed);\n\n\t        if (valIsNaN) {\n\t            setLow = othIsReflexive;\n\t        } else if (valIsUndefined) {\n\t            setLow = othIsReflexive &&othIsDefined;\n\t        } else if (valIsNull) {\n\t            setLow = othIsReflexive && othIsDefined && !othIsNull;\n\t        } else if (valIsSymbol) {\n\t            setLow = othIsReflexive && othIsDefined && !othIsNull && !othIsSymbol;\n\t        } else if (othIsNull || othIsSymbol) {\n\t            setLow = false;\n\t        } else {\n\t            setLow = computed < value;\n\t        }\n\t        if (setLow) {\n\t            low = mid + 1;\n\t        } else {\n\t            high = mid;\n\t        }\n\t    }\n\t    return Math.min(high, MAX_ARRAY_INDEX);\n\t};\n\n\tvar uniq = function (array, iteratee) {\n\t    var index = -1;\n\t    var includes = function (array, value) {\n\t        var length = array == null ? 0 : array.length;\n\t        return !!length && array.indexOf(value) > -1;\n\t    };\n\t    iteratee = getIteratee(iteratee, 2);\n\t    var isCommon = true;\n\n\t    var length = array.length;\n\t    var result = [];\n\t    var seen = result;\n\n\t    if (length >= LARGE_ARRAY_SIZE) {\n\t        var set = iteratee ? null : createSet(array);\n\t        if (set) {\n\t            return setToArray(set);\n\t        }\n\t        isCommon = false;\n\t        includes = function (cache, key) { return cache.has(key); };\n\t        seen = new SetCache;\n\t    } else {\n\t        seen = iteratee ? [] : result;\n\t    }\n\t    outer:\n\t    while (++index < length) {\n\t        var value = array[index];\n\t        var computed = iteratee ? iteratee(value) : value;\n\n\t        value = (value !== 0) ? value : 0;\n\t        if (isCommon && computed === computed) {\n\t            var seenIndex = seen.length;\n\t            while (seenIndex--) {\n\t                if (seen[seenIndex] === computed) {\n\t                    continue outer;\n\t                }\n\t            }\n\t            if (iteratee) {\n\t                seen.push(computed);\n\t            }\n\t            result.push(value);\n\t        }\n\t        else if (!includes(seen, computed)) {\n\t            if (seen !== result) {\n\t                seen.push(computed);\n\t            }\n\t            result.push(value);\n\t        }\n\t    }\n\t    return result;\n\t};\n\n\tvar clone = function (value) { return baseClone(value); };\n\n\tvar cloneDeep = function (value) { return baseClone(value, true); };\n\n\tvar isEmpty = function (value) {\n\t    if (value == null) {\n\t        return true;\n\t    }\n\t    if (isArrayLike(value) &&\n\t        (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function' ||\n\t            isTypedArray(value) || isArguments(value))) {\n\t        return !value.length;\n\t    }\n\t    var tag = getTag(value);\n\t    if (tag == '[object Map]' || tag == '[object Set]') {\n\t        return !value.size;\n\t    }\n\t    if (isPrototype(value)) {\n\t        return !baseKeys(value).length;\n\t    }\n\t    for (var key in value) {\n\t        if (hasOwnProperty.call(value, key)) {\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t};\n\tvar isEqual = function (object, other) { return baseIsEqual(object, other); };\n\n\tvar isFunction = function (value) { return typeof value === 'function'; };\n\n\tvar isPlainObject = function (value) {\n\t    if (!isObjectLike(value) || getTag(value) != '[object Object]') {\n\t        return false;\n\t    }\n\t    if (Object.getPrototypeOf(value) === null) {\n\t        return true;\n\t    }\n\t    var proto = value;\n\t    while (Object.getPrototypeOf(proto) !== null) {\n\t        proto = Object.getPrototypeOf(proto);\n\t    }\n\t    return Object.getPrototypeOf(value) === proto;\n\t};\n\n\tvar toArray = function (value) {\n\t    if (!value) {\n\t        return [];\n\t    }\n\n\t    if (isArrayLike(value)) {\n\t        return isString(value) ? stringToArray(value) : copyArray(value);\n\t    }\n\n\t    if (Symbol.iterator && Symbol.iterator in Object(value)) {\n\t        var iterator = value[Symbol.iterator]();\n\t        var data;\n\t        var result = [];\n\n\t        while (!(data = iterator.next()).done) {\n\t            result.push(data.value);\n\t        }\n\t        return result;\n\t    }\n\n\t    var tag = getTag(value);\n\t    var func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n\t    return func(value);\n\t};\n\n\tfunction debounce(func, wait, opt) {\n\t    if (typeof func !== 'function') {\n\t        throw new TypeError('Expected a function');\n\t    }\n\n\t    var lastArgs;\n\t    var lastThis;\n\t    var maxWait;\n\t    var result;\n\t    var timerId;\n\t    var lastCallTime;\n\t    var lastInvokeTime = 0;\n\t    var leading = false;\n\t    var maxing = false;\n\t    var trailing = true;\n\n\t    var useRaf = (!wait && wait !== 0 && window && typeof window.requestAnimationFrame === 'function');\n\n\t    wait = +wait || 0;\n\n\t    if (isObject$1(opt)) {\n\t        leading = !!opt.leading;\n\t        maxing = 'maxWait' in opt;\n\t        maxWait = maxing ? Math.max(+opt.maxWait || 0, wait) : maxWait;\n\t        trailing = 'trailing' in opt ? !!opt.trailing : trailing;\n\t    }\n\n\t    function invokeFunc(time) {\n\t        var args = lastArgs;\n\t        var thisArg = lastThis;\n\n\t        lastArgs = lastThis = undefined;\n\t        lastInvokeTime = time;\n\t        result = func.apply(thisArg, args);\n\t        return result;\n\t    }\n\n\t    function startTimer(pendingFunc, wait) {\n\t        if (useRaf) {\n\t            window.cancelAnimationFrame(timerId);\n\t            return window.requestAnimationFrame(pendingFunc);\n\t        }\n\t        return setTimeout(pendingFunc, wait);\n\t    }\n\n\t    function cancelTimer(id) {\n\t        if (useRaf) {\n\t            return window.cancelAnimationFrame(id);\n\t        }\n\t        clearTimeout(id);\n\t    }\n\n\t    function leadingEdge(time) {\n\t        lastInvokeTime = time;\n\t        timerId = startTimer(timerExpired, wait);\n\t        return leading ? invokeFunc(time) : result;\n\t    }\n\n\t    function remainingWait(time) {\n\t        var timeSinceLastCall = time - lastCallTime;\n\t        var timeSinceLastInvoke = time - lastInvokeTime;\n\t        var timeWaiting = wait - timeSinceLastCall;\n\n\t        return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n\t    }\n\n\t    function shouldInvoke(time) {\n\t        var timeSinceLastCall = time - lastCallTime;\n\t        var timeSinceLastInvoke = time - lastInvokeTime;\n\n\t        return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) ||\n\t            (maxing && timeSinceLastInvoke >= maxWait));\n\t    }\n\n\t    function timerExpired() {\n\t        var time = Date.now();\n\t        if (shouldInvoke(time)) {\n\t            return trailingEdge(time);\n\t        }\n\t        timerId = startTimer(timerExpired, remainingWait(time));\n\t    }\n\n\t    function trailingEdge(time) {\n\t        timerId = undefined;\n\n\t        if (trailing && lastArgs) {\n\t            return invokeFunc(time);\n\t        }\n\t        lastArgs = lastThis = undefined;\n\t        return result;\n\t    }\n\n\t    function debounced() {\n\t        var args = [], len = arguments.length;\n\t        while ( len-- ) args[ len ] = arguments[ len ];\n\n\t        var time = Date.now();\n\t        var isInvoking = shouldInvoke(time);\n\n\t        lastArgs = args;\n\t        lastThis = this;\n\t        lastCallTime = time;\n\n\t        if (isInvoking) {\n\t            if (timerId === undefined) {\n\t                return leadingEdge(lastCallTime);\n\t            }\n\t            if (maxing) {\n\t                timerId = startTimer(timerExpired, wait);\n\t                return invokeFunc(lastCallTime);\n\t            }\n\t        }\n\t        if (timerId === undefined) {\n\t            timerId = startTimer(timerExpired, wait);\n\t        }\n\t        return result;\n\t    }\n\n\t    debounced.cancel = function () {\n\t        if (timerId !== undefined) {\n\t            cancelTimer(timerId);\n\t        }\n\t        lastInvokeTime = 0;\n\t        lastArgs = lastCallTime = lastThis = timerId = undefined;\n\t    };\n\t    debounced.flush = function () { return timerId === undefined ? result : trailingEdge(Date.now()); };\n\t    debounced.pending = function () { return timerId !== undefined; };\n\n\t    return debounced;\n\t}\n\n\tvar groupBy = function (collection, iteratee) {\n\t    iteratee = getIteratee(iteratee, 2);\n\n\t    return reduce(collection, function (result, value, key) {\n\t        key = iteratee(value);\n\t        if (hasOwnProperty.call(result, key)) {\n\t            result[key].push(value);\n\t        } else {\n\t            assignValue(result, key, [value]);\n\t        }\n\t        return result;\n\t    }, {});\n\t};\n\n\tvar sortBy = function (collection, iteratees) {\n\t    if ( iteratees === void 0 ) iteratees = [];\n\n\t    if (collection == null) {\n\t        return [];\n\t    }\n\n\t    var length = iteratees.length;\n\t    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n\t        iteratees = [];\n\t    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n\t        iteratees = [iteratees[0]];\n\t    }\n\n\t    if (!Array.isArray(iteratees)) {\n\t        iteratees = [getIteratee(iteratees, 2)];\n\t    }\n\n\t    return baseOrderBy(collection, iteratees.flat(1), []);\n\t};\n\n\tvar flattenDeep = function (array) {\n\t    var length = array == null ? 0 : array.length;\n\t    return length ? baseFlatten(array, Infinity) : [];\n\t};\n\n\tvar without = function (array) {\n\t  var values = [], len = arguments.length - 1;\n\t  while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\n\t  return isArrayLike(array) ? diff(array, values) : [];\n\t};\n\n\tvar difference = function (array) {\n\t      var values = [], len = arguments.length - 1;\n\t      while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\n\t      return isObjectLike(array) && isArrayLike(array) ?\n\t        diff(array, values.flat(1)) : [];\n\t};\n\n\tvar intersection$1 = function () {\n\t    var arrays = [], len = arguments.length;\n\t    while ( len-- ) arrays[ len ] = arguments[ len ];\n\n\t    var mapped = arrays.map(function (array) { return isObjectLike(array) && isArrayLike(array) ?\n\t            array : []; }\n\t    );\n\n\t    return mapped.length && mapped[0] === arrays[0] ?\n\t        intersect(mapped) : [];\n\t};\n\n\tvar union = function () {\n\t    var arrays = [], len = arguments.length;\n\t    while ( len-- ) arrays[ len ] = arguments[ len ];\n\n\t    var array = arrays.flat(1);\n\t    return uniq(array);\n\t};\n\n\tvar has$2 = function (object, key) {\n\t    if (object == null) {\n\t        return false;\n\t    }\n\n\t    if (typeof key === 'string') {\n\t        key = key.split('.');\n\t    }\n\n\t    var index = -1;\n\t    var value = object;\n\n\t    while (++index < key.length) {\n\t        if (!value || !hasOwnProperty.call(value, key[index])) {\n\t            return false;\n\t        }\n\t        value = value[key[index]];\n\t    }\n\n\t    return true;\n\t};\n\n\tvar result = function (object, path, defaultValue) {\n\t    path = castPath(path, object);\n\n\t    var index = -1;\n\t    var length = path.length;\n\n\t    if (!length) {\n\t        length = 1;\n\t        object = undefined;\n\t    }\n\t    while (++index < length) {\n\t        var value = object == null ? undefined : object[toKey(path[index])];\n\t        if (value === undefined) {\n\t            index = length;\n\t            value = defaultValue;\n\t        }\n\t        object = typeof value === 'function' ? value.call(object) : value;\n\t    }\n\t    return object;\n\t};\n\n\tvar omit = function (object) {\n\t    var paths = [], len = arguments.length - 1;\n\t    while ( len-- > 0 ) paths[ len ] = arguments[ len + 1 ];\n\n\t    var result = {};\n\t    if (object == null) {\n\t        return result;\n\t    }\n\t    var isDeep = false;\n\t    paths = paths.flat(1).map(function (path) {\n\t        path = castPath(path, object);\n\t        isDeep || (isDeep = path.length > 1);\n\t        return path;\n\t    });\n\t    copyObject(object, getAllKeysIn(object), result);\n\t    if (isDeep) {\n\t        result = baseClone(result, true, true, true, function (value) { return isPlainObject(value) ? undefined : value; });\n\t    }\n\t    var length = paths.length;\n\t    while (length--) {\n\t        unset(result, paths[length]);\n\t    }\n\t    return result;\n\t};\n\n\tvar pick = function (object) {\n\t    var paths = [], len = arguments.length - 1;\n\t    while ( len-- > 0 ) paths[ len ] = arguments[ len + 1 ];\n\n\t    return object == null ? {} : basePick(object, paths.flat(Infinity));\n\t};\n\n\tvar bindAll = function (object) {\n\t    var methodNames = [], len = arguments.length - 1;\n\t    while ( len-- > 0 ) methodNames[ len ] = arguments[ len + 1 ];\n\n\t    methodNames.flat(1).forEach(function (key) {\n\t        key = toKey(key);\n\t        assignValue(object, key, object[key].bind(object));\n\t    });\n\t    return object;\n\t};\n\n\tvar forIn = function (object, iteratee) {\n\t    if ( iteratee === void 0 ) iteratee = function (value) { return value; };\n\n\t    var index = -1;\n\t    var iterable = Object(object);\n\t    var props = isArrayLike(object) ? arrayLikeKeys(object, true) : keysIn(object);\n\t    var length = props.length;\n\n\t    while(length--) {\n\t        var key = props[++index];\n\t        if (iteratee(iterable[key], key, iterable) === false) {\n\t            break;\n\t        }\n\t    }\n\t};\n\n\tvar camelCase = function (string) {\n\t  if ( string === void 0 ) string = '';\n\n\t  return (\n\t    words((\"\" + string).replace(/['\\u2019]/g, ''))\n\t        .reduce(function (result, word, index) {\n\t            word = word.toLowerCase();\n\t            return result + (index ? upperFirst(word) : word);\n\t        }, '')\n\t);\n\t};\n\n\tvar idCounter = 0;\n\n\tvar uniqueId = function (prefix) {\n\t    if ( prefix === void 0 ) prefix = '';\n\n\t    var id = ++idCounter;\n\t    return \"\" + prefix + id;\n\t};\n\n\tvar merge = createAssigner(function (object, source, srcIndex, customizer) {\n\t    baseMerge(object, source, srcIndex, customizer);\n\t}, true);\n\n\tvar addClassNamePrefix = function(className) {\n\n\t    if (!className) { return className; }\n\n\t    return className.toString().split(' ').map(function(_className) {\n\n\t        if (_className.substr(0, config.classNamePrefix.length) !== config.classNamePrefix) {\n\t            _className = config.classNamePrefix + _className;\n\t        }\n\n\t        return _className;\n\n\t    }).join(' ');\n\t};\n\n\tvar removeClassNamePrefix = function(className) {\n\n\t    if (!className) { return className; }\n\n\t    return className.toString().split(' ').map(function(_className) {\n\n\t        if (_className.substr(0, config.classNamePrefix.length) === config.classNamePrefix) {\n\t            _className = _className.substr(config.classNamePrefix.length);\n\t        }\n\n\t        return _className;\n\n\t    }).join(' ');\n\t};\n\n\tvar parseDOMJSON = function(json, namespace) {\n\n\t    var selectors = {};\n\t    var groupSelectors = {};\n\t    var svgNamespace = V.namespace.svg;\n\n\t    var ns = namespace || svgNamespace;\n\t    var fragment = document.createDocumentFragment();\n\n\t    var parseNode = function(siblingsDef, parentNode, ns) {\n\t        for (var i = 0; i < siblingsDef.length; i++) {\n\t            var nodeDef = siblingsDef[i];\n\n\t            // Text node\n\t            if (typeof nodeDef === 'string') {\n\t                var textNode = document.createTextNode(nodeDef);\n\t                parentNode.appendChild(textNode);\n\t                continue;\n\t            }\n\n\t            // TagName\n\t            if (!nodeDef.hasOwnProperty('tagName')) { throw new Error('json-dom-parser: missing tagName'); }\n\t            var tagName = nodeDef.tagName;\n\n\t            var node = (void 0);\n\n\t            // Namespace URI\n\t            if (nodeDef.hasOwnProperty('namespaceURI')) { ns = nodeDef.namespaceURI; }\n\t            node = document.createElementNS(ns, tagName);\n\t            var svg = (ns === svgNamespace);\n\n\t            var wrapper = (svg) ? V : $;\n\t            // Attributes\n\t            var attributes = nodeDef.attributes;\n\t            if (attributes) { wrapper(node).attr(attributes); }\n\t            // Style\n\t            var style = nodeDef.style;\n\t            if (style) { $(node).css(style); }\n\t            // ClassName\n\t            if (nodeDef.hasOwnProperty('className')) {\n\t                var className = nodeDef.className;\n\t                if (svg) {\n\t                    node.className.baseVal = className;\n\t                } else {\n\t                    node.className = className;\n\t                }\n\t            }\n\t            // TextContent\n\t            if (nodeDef.hasOwnProperty('textContent')) {\n\t                node.textContent = nodeDef.textContent;\n\t            }\n\t            // Selector\n\t            if (nodeDef.hasOwnProperty('selector')) {\n\t                var nodeSelector = nodeDef.selector;\n\t                if (selectors[nodeSelector]) { throw new Error('json-dom-parser: selector must be unique'); }\n\t                selectors[nodeSelector] = node;\n\t                wrapper(node).attr('joint-selector', nodeSelector);\n\t            }\n\t            // Groups\n\t            if (nodeDef.hasOwnProperty('groupSelector')) {\n\t                var nodeGroups = nodeDef.groupSelector;\n\t                if (!Array.isArray(nodeGroups)) { nodeGroups = [nodeGroups]; }\n\t                for (var j = 0; j < nodeGroups.length; j++) {\n\t                    var nodeGroup = nodeGroups[j];\n\t                    var group = groupSelectors[nodeGroup];\n\t                    if (!group) { group = groupSelectors[nodeGroup] = []; }\n\t                    group.push(node);\n\t                }\n\t            }\n\n\t            parentNode.appendChild(node);\n\n\t            // Children\n\t            var childrenDef = nodeDef.children;\n\t            if (Array.isArray(childrenDef)) {\n\t                parseNode(childrenDef, node, ns);\n\t            }\n\t        }\n\t    };\n\t    parseNode(json, fragment, ns);\n\t    return {\n\t        fragment: fragment,\n\t        selectors: selectors,\n\t        groupSelectors: groupSelectors\n\t    };\n\t};\n\n\t// Return a simple hash code from a string. See http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/.\n\tvar hashCode = function(str) {\n\n\t    var hash = 0;\n\t    if (str.length === 0) { return hash; }\n\t    for (var i = 0; i < str.length; i++) {\n\t        var c = str.charCodeAt(i);\n\t        hash = ((hash << 5) - hash) + c;\n\t        hash = hash & hash; // Convert to 32bit integer\n\t    }\n\t    return hash;\n\t};\n\n\tvar getByPath = function(obj, path, delimiter) {\n\n\t    var keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n\t    var key;\n\t    var i = 0;\n\t    var length = keys.length;\n\t    while (i < length) {\n\t        key = keys[i++];\n\t        if (Object(obj) === obj && key in obj) {\n\t            obj = obj[key];\n\t        } else {\n\t            return undefined;\n\t        }\n\t    }\n\t    return obj;\n\t};\n\n\tvar isGetSafe = function(obj, key) {\n\t    // Prevent prototype pollution\n\t    // https://snyk.io/vuln/SNYK-JS-JSON8MERGEPATCH-1038399\n\t    if (typeof key !== 'string' && typeof key !== 'number') {\n\t        key = String(key);\n\t    }\n\t    if (key === 'constructor' && typeof obj[key] === 'function') {\n\t        return false;\n\t    }\n\t    if (key === '__proto__') {\n\t        return false;\n\t    }\n\t    return true;\n\t};\n\n\tvar setByPath = function(obj, path, value, delimiter) {\n\n\t    var keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n\t    var last = keys.length - 1;\n\t    var diver = obj;\n\t    var i = 0;\n\n\t    for (; i < last; i++) {\n\t        var key = keys[i];\n\t        if (!isGetSafe(diver, key)) { return obj; }\n\t        var value$1 = diver[key];\n\t        // diver creates an empty object if there is no nested object under such a key.\n\t        // This means that one can populate an empty nested object with setByPath().\n\t        diver = value$1 || (diver[key] = {});\n\t    }\n\n\t    diver[keys[last]] = value;\n\n\t    return obj;\n\t};\n\n\tvar unsetByPath = function(obj, path, delimiter) {\n\n\t    var keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n\t    var last = keys.length - 1;\n\t    var diver = obj;\n\t    var i = 0;\n\n\t    for (; i < last; i++) {\n\t        var key = keys[i];\n\t        if (!isGetSafe(diver, key)) { return obj; }\n\t        var value = diver[key];\n\t        if (!value) { return obj; }\n\t        diver = value;\n\t    }\n\n\t    delete diver[keys[last]];\n\n\t    return obj;\n\t};\n\n\tvar flattenObject = function(obj, delim, stop) {\n\n\t    delim = delim || '/';\n\t    var ret = {};\n\n\t    for (var key in obj) {\n\n\t        if (!obj.hasOwnProperty(key)) { continue; }\n\n\t        var shouldGoDeeper = typeof obj[key] === 'object';\n\t        if (shouldGoDeeper && stop && stop(obj[key])) {\n\t            shouldGoDeeper = false;\n\t        }\n\n\t        if (shouldGoDeeper) {\n\n\t            var flatObject = flattenObject(obj[key], delim, stop);\n\n\t            for (var flatKey in flatObject) {\n\t                if (!flatObject.hasOwnProperty(flatKey)) { continue; }\n\t                ret[key + delim + flatKey] = flatObject[flatKey];\n\t            }\n\n\t        } else {\n\n\t            ret[key] = obj[key];\n\t        }\n\t    }\n\n\t    return ret;\n\t};\n\n\tvar uuid = function() {\n\n\t    // credit: http://stackoverflow.com/posts/2117523/revisions\n\n\t    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t        var r = (Math.random() * 16) | 0;\n\t        var v = (c === 'x') ? r : (r & 0x3 | 0x8);\n\t        return v.toString(16);\n\t    });\n\t};\n\n\t// Generates global unique id and stores it as a property of the object, if provided.\n\tvar guid = function(obj) {\n\n\t    guid.id = guid.id || 1;\n\n\t    if (obj === undefined) {\n\t        return 'j_' + guid.id++;\n\t    }\n\n\t    obj.id = (obj.id === undefined ? 'j_' + guid.id++ : obj.id);\n\t    return obj.id;\n\t};\n\n\tvar toKebabCase = function(string) {\n\n\t    return string.replace(/[A-Z]/g, '-$&').toLowerCase();\n\t};\n\n\tvar normalizeEvent = function(evt) {\n\n\t    if (evt.normalized) { return evt; }\n\n\t    var originalEvent = evt.originalEvent;\n\t    var target = evt.target;\n\n\t    // If the event is a touch event, normalize it to a mouse event.\n\t    var touch = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];\n\t    if (touch) {\n\t        for (var property in touch) {\n\t            // copy all the properties from the first touch that are not\n\t            // defined on TouchEvent (clientX, clientY, pageX, pageY, screenX, screenY, identifier, ...)\n\t            if (evt[property] === undefined) {\n\t                evt[property] = touch[property];\n\t            }\n\t        }\n\t    }\n\t    // IE: evt.target could be set to SVGElementInstance for SVGUseElement\n\t    if (target) {\n\t        var useElement = target.correspondingUseElement;\n\t        if (useElement) { evt.target = useElement; }\n\t    }\n\n\t    evt.normalized = true;\n\n\t    return evt;\n\t};\n\n\tvar normalizeWheel = function(evt) {\n\t    // Sane values derived empirically\n\t    var PIXEL_STEP  = 10;\n\t    var LINE_HEIGHT = 40;\n\t    var PAGE_HEIGHT = 800;\n\n\t    var sX = 0, sY = 0, pX = 0, pY = 0;\n\n\t    // Legacy\n\t    if ('detail'      in evt) { sY = evt.detail; }\n\t    if ('wheelDelta'  in evt) { sY = -evt.wheelDelta / 120; }\n\t    if ('wheelDeltaY' in evt) { sY = -evt.wheelDeltaY / 120; }\n\t    if ('wheelDeltaX' in evt) { sX = -evt.wheelDeltaX / 120; }\n\n\t    // side scrolling on FF with DOMMouseScroll\n\t    if ( 'axis' in evt && evt.axis === evt.HORIZONTAL_AXIS ) {\n\t        sX = sY;\n\t        sY = 0;\n\t    }\n\n\t    pX = 'deltaX' in evt ? evt.deltaX : sX * PIXEL_STEP;\n\t    pY = 'deltaY' in evt ? evt.deltaY : sY * PIXEL_STEP;\n\n\t    if ((pX || pY) && evt.deltaMode) {\n\t        if (evt.deltaMode == 1) {\n\t            pX *= LINE_HEIGHT;\n\t            pY *= LINE_HEIGHT;\n\t        } else {\n\t            pX *= PAGE_HEIGHT;\n\t            pY *= PAGE_HEIGHT;\n\t        }\n\t    }\n\n\t    // macOS switches deltaX and deltaY automatically when scrolling with shift key, so this is needed in other cases\n\t    if (evt.deltaX === 0 && evt.deltaY !== 0 && evt.shiftKey) {\n\t        pX = pY;\n\t        pY = 0;\n\t        sX = sY;\n\t        sY = 0;\n\t    }\n\n\t    // Fall-back if spin cannot be determined\n\t    if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }\n\t    if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }\n\n\t    return {\n\t        spinX  : sX,\n\t        spinY  : sY,\n\t        deltaX : pX,\n\t        deltaY : pY,\n\t    };\n\t};\n\n\tvar cap = function(val, max) {\n\t    return val > max ? max : val < -max ? -max : val;\n\t};\n\n\tvar nextFrame = (function() {\n\n\t    var raf;\n\n\t    if (typeof window !== 'undefined') {\n\n\t        raf = window.requestAnimationFrame ||\n\t            window.webkitRequestAnimationFrame ||\n\t            window.mozRequestAnimationFrame ||\n\t            window.oRequestAnimationFrame ||\n\t            window.msRequestAnimationFrame;\n\t    }\n\n\t    if (!raf) {\n\n\t        var lastTime = 0;\n\n\t        raf = function(callback) {\n\n\t            var currTime = new Date().getTime();\n\t            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t            var id = setTimeout(function() {\n\t                callback(currTime + timeToCall);\n\t            }, timeToCall);\n\n\t            lastTime = currTime + timeToCall;\n\n\t            return id;\n\t        };\n\t    }\n\n\t    return function(callback, context) {\n\t        var rest = [], len = arguments.length - 2;\n\t        while ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];\n\n\t        return (context !== undefined)\n\t            ? raf(callback.bind.apply(callback, [ context ].concat( rest )))\n\t            : raf(callback);\n\t    };\n\n\t})();\n\n\tvar cancelFrame = (function() {\n\n\t    var caf;\n\t    var client = typeof window != 'undefined';\n\n\t    if (client) {\n\n\t        caf = window.cancelAnimationFrame ||\n\t            window.webkitCancelAnimationFrame ||\n\t            window.webkitCancelRequestAnimationFrame ||\n\t            window.msCancelAnimationFrame ||\n\t            window.msCancelRequestAnimationFrame ||\n\t            window.oCancelAnimationFrame ||\n\t            window.oCancelRequestAnimationFrame ||\n\t            window.mozCancelAnimationFrame ||\n\t            window.mozCancelRequestAnimationFrame;\n\t    }\n\n\t    caf = caf || clearTimeout;\n\n\t    return client ? caf.bind(window) : caf;\n\n\t})();\n\n\t/**\n\t * @deprecated\n\t */\n\tvar shapePerimeterConnectionPoint = function(linkView, view, magnet, reference) {\n\n\t    var bbox;\n\t    var spot;\n\n\t    if (!magnet) {\n\n\t        // There is no magnet, try to make the best guess what is the\n\t        // wrapping SVG element. This is because we want this \"smart\"\n\t        // connection points to work out of the box without the\n\t        // programmer to put magnet marks to any of the subelements.\n\t        // For example, we want the function to work on basic.Path elements\n\t        // without any special treatment of such elements.\n\t        // The code below guesses the wrapping element based on\n\t        // one simple assumption. The wrapping elemnet is the\n\t        // first child of the scalable group if such a group exists\n\t        // or the first child of the rotatable group if not.\n\t        // This makese sense because usually the wrapping element\n\t        // is below any other sub element in the shapes.\n\t        var scalable = view.$('.scalable')[0];\n\t        var rotatable = view.$('.rotatable')[0];\n\n\t        if (scalable && scalable.firstChild) {\n\n\t            magnet = scalable.firstChild;\n\n\t        } else if (rotatable && rotatable.firstChild) {\n\n\t            magnet = rotatable.firstChild;\n\t        }\n\t    }\n\n\t    if (magnet) {\n\n\t        spot = V(magnet).findIntersection(reference, linkView.paper.cells);\n\t        if (!spot) {\n\t            bbox = V(magnet).getBBox({ target: linkView.paper.cells });\n\t        }\n\n\t    } else {\n\n\t        bbox = view.model.getBBox();\n\t        spot = bbox.intersectionWithLineFromCenterToPoint(reference);\n\t    }\n\t    return spot || bbox.center();\n\t};\n\n\tvar isPercentage = function(val) {\n\n\t    return isString(val) && val.slice(-1) === '%';\n\t};\n\n\tvar parseCssNumeric = function(val, restrictUnits) {\n\n\t    function getUnit(validUnitExp) {\n\n\t        // one or more numbers, followed by\n\t        // any number of (\n\t        //  `.`, followed by\n\t        //  one or more numbers\n\t        // ), followed by\n\t        // `validUnitExp`, followed by\n\t        // end of string\n\t        var matches = new RegExp('(?:\\\\d+(?:\\\\.\\\\d+)*)(' + validUnitExp + ')$').exec(val);\n\n\t        if (!matches) { return null; }\n\t        return matches[1];\n\t    }\n\n\t    var number = parseFloat(val);\n\n\t    // if `val` cannot be parsed as a number, return `null`\n\t    if (Number.isNaN(number)) { return null; }\n\n\t    // else: we know `output.value`\n\t    var output = {};\n\t    output.value = number;\n\n\t    // determine the unit\n\t    var validUnitExp;\n\t    if (restrictUnits == null) {\n\t        // no restriction\n\t        // accept any unit, as well as no unit\n\t        validUnitExp = '[A-Za-z]*';\n\n\t    } else if (Array.isArray(restrictUnits)) {\n\t        // if this is an empty array, top restriction - return `null`\n\t        if (restrictUnits.length === 0) { return null; }\n\n\t        // else: restriction - an array of valid unit strings\n\t        validUnitExp = restrictUnits.join('|');\n\n\t    } else if (isString(restrictUnits)) {\n\t        // restriction - a single valid unit string\n\t        validUnitExp = restrictUnits;\n\t    }\n\t    var unit = getUnit(validUnitExp);\n\n\t    // if we found no matches for `restrictUnits`, return `null`\n\t    if (unit === null) { return null; }\n\n\t    // else: we know the unit\n\t    output.unit = unit;\n\t    return output;\n\t};\n\n\tvar NO_SPACE = 0;\n\n\tfunction splitWordWithEOL(word, eol) {\n\t    var eolWords = word.split(eol);\n\t    var n = 1;\n\t    for (var j = 0, jl = eolWords.length - 1; j < jl; j++) {\n\t        var replacement = [];\n\t        if (j > 0 || eolWords[0] !== '') { replacement.push(NO_SPACE); }\n\t        replacement.push(eol);\n\t        if (j < jl - 1 || eolWords[jl] !== '') { replacement.push(NO_SPACE); }\n\t        eolWords.splice.apply(eolWords, [ n, 0 ].concat( replacement ));\n\t        n += replacement.length + 1;\n\t    }\n\t    return eolWords.filter(function (word) { return word !== ''; });\n\t}\n\n\n\tfunction getLineHeight(heightValue, textElement) {\n\t    if (heightValue === null) {\n\t        // Default 1em lineHeight\n\t        return textElement.getBBox().height;\n\t    }\n\n\t    switch (heightValue.unit) {\n\t        case 'em':\n\t            return textElement.getBBox().height * heightValue.value;\n\t        case 'px':\n\t        case '':\n\t            return heightValue.value;\n\t    }\n\t}\n\n\tvar breakText = function(text, size, styles, opt) {\n\t    if ( styles === void 0 ) styles = {};\n\t    if ( opt === void 0 ) opt = {};\n\n\n\t    var width = size.width;\n\t    var height = size.height;\n\n\t    var svgDocument = opt.svgDocument || V('svg').node;\n\t    var textSpan = V('tspan').node;\n\t    var textElement = V('text').attr(styles).append(textSpan).node;\n\t    var textNode = document.createTextNode('');\n\n\t    // Prevent flickering\n\t    textElement.style.opacity = 0;\n\t    // Prevent FF from throwing an uncaught exception when `getBBox()`\n\t    // called on element that is not in the render tree (is not measurable).\n\t    // <tspan>.getComputedTextLength() returns always 0 in this case.\n\t    // Note that the `textElement` resp. `textSpan` can become hidden\n\t    // when it's appended to the DOM and a `display: none` CSS stylesheet\n\t    // rule gets applied.\n\t    textElement.style.display = 'block';\n\t    textSpan.style.display = 'block';\n\n\t    textSpan.appendChild(textNode);\n\t    svgDocument.appendChild(textElement); // lgtm [js/xss-through-dom]\n\n\t    if (!opt.svgDocument) {\n\n\t        document.body.appendChild(svgDocument);\n\t    }\n\n\t    var preserveSpaces = opt.preserveSpaces;\n\t    var space = ' ';\n\t    var separator = opt.separator || space;\n\t    var eol = opt.eol || '\\n';\n\t    var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\\w\\d]/;\n\t    var maxLineCount = opt.maxLineCount;\n\t    if (!isNumber(maxLineCount)) { maxLineCount = Infinity; }\n\n\t    var words = text.split(separator);\n\t    var full = [];\n\t    var lines = [];\n\t    var p, h;\n\t    var lineHeight;\n\n\t    if (preserveSpaces) {\n\t        V(textSpan).attr('xml:space', 'preserve');\n\t    }\n\n\t    for (var i = 0, l = 0, len = words.length; i < len; i++) {\n\n\t        var word = words[i];\n\n\t        if (!word && !preserveSpaces) { continue; }\n\t        if (typeof word !== 'string') { continue; }\n\n\t        var isEol = false;\n\t        if (eol && word.indexOf(eol) >= 0) {\n\t            // word contains end-of-line character\n\t            if (word.length > 1) {\n\t                // separate word and continue cycle\n\t                var eolWords = splitWordWithEOL(words[i], eol);\n\t                words.splice.apply(words, [ i, 1 ].concat( eolWords ));\n\t                i--;\n\t                len = words.length;\n\t                continue;\n\t            } else {\n\t                // creates a new line\n\t                if (preserveSpaces && typeof words[i - 1] === 'string' ) {\n\t                    words.splice(i, NO_SPACE, '', NO_SPACE);\n\t                    len += 2;\n\t                    i--;\n\t                    continue;\n\t                }\n\t                lines[++l] = (!preserveSpaces || typeof words[i + 1] === 'string') ? '' : undefined;\n\t                isEol = true;\n\t            }\n\t        }\n\n\t        if (!isEol) {\n\n\t            var data = (void 0);\n\t            if (preserveSpaces) {\n\t                data = lines[l] !== undefined ? lines[l] + space + word : word;\n\t            } else {\n\t                data = lines[l] ? lines[l] + space + word : word;\n\t            }\n\n\t            textNode.data = data;\n\n\t            if (textSpan.getComputedTextLength() <= width) {\n\n\t                // the current line fits\n\t                lines[l] = data;\n\n\t                if (p || h) {\n\t                // We were partitioning. Put rest of the word onto next line\n\t                    full[l++] = true;\n\n\t                    // cancel partitioning and splitting by hyphens\n\t                    p = 0;\n\t                    h = 0;\n\t                }\n\n\t            } else {\n\n\t                if (!lines[l] || p) {\n\n\t                    var partition = !!p;\n\n\t                    p = word.length - 1;\n\n\t                    if (partition || !p) {\n\n\t                        // word has only one character.\n\t                        if (!p) {\n\n\t                            if (!lines[l]) {\n\n\t                                // we won't fit this text within our rect\n\t                                lines = [];\n\n\t                                break;\n\t                            }\n\n\t                            // partitioning didn't help on the non-empty line\n\t                            // try again, but this time start with a new line\n\n\t                            // cancel partitions created\n\t                            words.splice(i, 2, word + words[i + 1]);\n\n\t                            // adjust word length\n\t                            len--;\n\n\t                            full[l++] = true;\n\t                            i--;\n\n\t                            continue;\n\t                        }\n\n\t                        // move last letter to the beginning of the next word\n\t                        words[i] = word.substring(0, p);\n\t                        words[i + 1] = word.substring(p) + (words[i + 1] === undefined ? '' : words[i + 1]);\n\n\t                    } else {\n\n\t                        if (h) {\n\t                        // cancel splitting and put the words together again\n\t                            words.splice(i, 2, words[i] + words[i + 1]);\n\t                            h = 0;\n\t                        } else {\n\t                            var hyphenIndex = word.search(hyphen);\n\t                            if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {\n\t                                h = hyphenIndex + 1;\n\t                                p = 0;\n\t                            }\n\n\t                            // We initiate partitioning or splitting\n\t                            // split the long word into two words\n\t                            words.splice(i, 1, word.substring(0, h || p), word.substring(h|| p));\n\t                            // adjust words length\n\t                            len++;\n\n\t                        }\n\n\t                        if (l && !full[l - 1]) {\n\t                        // if the previous line is not full, try to fit max part of\n\t                        // the current word there\n\t                            l--;\n\t                        }\n\t                    }\n\n\t                    if (!preserveSpaces || lines[l] !== '') {\n\t                        i--;\n\t                    }\n\n\t                    continue;\n\t                }\n\n\t                l++;\n\t                i--;\n\t            }\n\t        }\n\t        var lastL = null;\n\n\t        if (lines.length > maxLineCount) {\n\n\t            lastL = maxLineCount - 1;\n\n\t        } else if (height !== undefined) {\n\n\t            // if size.height is defined we have to check whether the height of the entire\n\t            // text exceeds the rect height\n\n\t            if (lineHeight === undefined && textNode.data !== '') {\n\n\t                // use the same defaults as in V.prototype.text\n\t                if (styles.lineHeight === 'auto') {\n\t                    lineHeight = getLineHeight({ value: 1.5, unit: 'em' }, textElement);\n\t                } else {\n\t                    var parsed = parseCssNumeric(styles.lineHeight, ['em', 'px', '']);\n\n\t                    lineHeight = getLineHeight(parsed, textElement);\n\t                }\n\t            }\n\n\t            if (lineHeight * lines.length > height) {\n\t                // remove overflowing lines\n\t                lastL = Math.floor(height / lineHeight) - 1;\n\t            }\n\t        }\n\n\t        if (lastL !== null) {\n\n\t            lines.splice(lastL + 1);\n\n\t            // add ellipsis\n\t            var ellipsis = opt.ellipsis;\n\t            if (!ellipsis || lastL < 0) { break; }\n\t            if (typeof ellipsis !== 'string') { ellipsis = '\\u2026'; }\n\n\t            var lastLine = lines[lastL];\n\t            if (!lastLine && !isEol) { break; }\n\t            var k = lastLine.length;\n\t            var lastLineWithOmission, lastChar, separatorChar;\n\t            do {\n\t                lastChar = lastLine[k];\n\t                lastLineWithOmission = lastLine.substring(0, k);\n\t                if (!lastChar) {\n\t                    separatorChar = (typeof separator === 'string') ? separator : ' ';\n\t                    lastLineWithOmission += separatorChar;\n\t                } else if (lastChar.match(separator)) {\n\t                    lastLineWithOmission += lastChar;\n\t                }\n\t                lastLineWithOmission += ellipsis;\n\t                textNode.data = lastLineWithOmission;\n\t                if (textSpan.getComputedTextLength() <= width) {\n\t                    lines[lastL] = lastLineWithOmission;\n\t                    break;\n\t                }\n\t                k--;\n\t            } while (k >= 0);\n\t            break;\n\t        }\n\t    }\n\n\t    if (opt.svgDocument) {\n\n\t        // svg document was provided, remove the text element only\n\t        svgDocument.removeChild(textElement);\n\n\t    } else {\n\n\t        // clean svg document\n\t        document.body.removeChild(svgDocument);\n\t    }\n\n\t    return lines.join(eol);\n\t};\n\n\t// Sanitize HTML\n\t// Based on https://gist.github.com/ufologist/5a0da51b2b9ef1b861c30254172ac3c9\n\t// Parses a string into an array of DOM nodes.\n\t// Then outputs it back as a string.\n\tvar sanitizeHTML = function(html) {\n\n\t    // Ignores tags that are invalid inside a <div> tag (e.g. <body>, <head>)\n\n\t    // If documentContext (second parameter) is not specified or given as `null` or `undefined`, a new document is used.\n\t    // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.\n\n\t    // If keepScripts (last parameter) is `false`, scripts are not executed.\n\t    var output = $($.parseHTML('<div>' + html + '</div>', null, false));\n\n\t    output.find('*').each(function() { // for all nodes\n\t        var currentNode = this;\n\n\t        $.each(currentNode.attributes, function() { // for all attributes in each node\n\t            var currentAttribute = this;\n\n\t            var attrName = currentAttribute.name;\n\t            var attrValue = currentAttribute.value;\n\n\t            // Remove attribute names that start with \"on\" (e.g. onload, onerror...).\n\t            // Remove attribute values that start with \"javascript:\" pseudo protocol (e.g. `href=\"javascript:alert(1)\"`).\n\t            if (attrName.startsWith('on') || attrValue.startsWith('javascript:') || attrValue.startsWith('data:') || attrValue.startsWith('vbscript:')) {\n\t                $(currentNode).removeAttr(attrName);\n\t            }\n\t        });\n\t    });\n\n\t    return output.html();\n\t};\n\n\t// Download `blob` as file with `fileName`.\n\t// Does not work in IE9.\n\tvar downloadBlob = function(blob, fileName) {\n\n\t    if (window.navigator.msSaveBlob) { // requires IE 10+\n\t        // pulls up a save dialog\n\t        window.navigator.msSaveBlob(blob, fileName);\n\n\t    } else { // other browsers\n\t        // downloads directly in Chrome and Safari\n\n\t        // presents a save/open dialog in Firefox\n\t        // Firefox bug: `from` field in save dialog always shows `from:blob:`\n\t        // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n\n\t        var url = window.URL.createObjectURL(blob);\n\t        var link = document.createElement('a');\n\n\t        link.href = url;\n\t        link.download = fileName;\n\t        document.body.appendChild(link);\n\n\t        link.click();\n\n\t        document.body.removeChild(link);\n\t        window.URL.revokeObjectURL(url); // mark the url for garbage collection\n\t    }\n\t};\n\n\t// Download `dataUri` as file with `fileName`.\n\t// Does not work in IE9.\n\tvar downloadDataUri = function(dataUri, fileName) {\n\n\t    var blob = dataUriToBlob(dataUri);\n\t    downloadBlob(blob, fileName);\n\t};\n\n\t// Convert an uri-encoded data component (possibly also base64-encoded) to a blob.\n\tvar dataUriToBlob = function(dataUri) {\n\n\t    // first, make sure there are no newlines in the data uri\n\t    dataUri = dataUri.replace(/\\s/g, '');\n\t    dataUri = decodeURIComponent(dataUri);\n\n\t    var firstCommaIndex = dataUri.indexOf(','); // split dataUri as `dataTypeString`,`data`\n\n\t    var dataTypeString = dataUri.slice(0, firstCommaIndex); // e.g. 'data:image/jpeg;base64'\n\t    var mimeString = dataTypeString.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'\n\n\t    var data = dataUri.slice(firstCommaIndex + 1);\n\t    var decodedString;\n\t    if (dataTypeString.indexOf('base64') >= 0) { // data may be encoded in base64\n\t        decodedString = atob(data); // decode data\n\t    } else {\n\t        // convert the decoded string to UTF-8\n\t        decodedString = unescape(encodeURIComponent(data));\n\t    }\n\t    // write the bytes of the string to a typed array\n\t    var ia = new Uint8Array(decodedString.length);\n\t    for (var i = 0; i < decodedString.length; i++) {\n\t        ia[i] = decodedString.charCodeAt(i);\n\t    }\n\n\t    return new Blob([ia], { type: mimeString }); // return the typed array as Blob\n\t};\n\n\t// Read an image at `url` and return it as base64-encoded data uri.\n\t// The mime type of the image is inferred from the `url` file extension.\n\t// If data uri is provided as `url`, it is returned back unchanged.\n\t// `callback` is a method with `err` as first argument and `dataUri` as second argument.\n\t// Works with IE9.\n\tvar imageToDataUri = function(url, callback) {\n\n\t    if (!url || url.substr(0, 'data:'.length) === 'data:') {\n\t        // No need to convert to data uri if it is already in data uri.\n\n\t        // This not only convenient but desired. For example,\n\t        // IE throws a security error if data:image/svg+xml is used to render\n\t        // an image to the canvas and an attempt is made to read out data uri.\n\t        // Now if our image is already in data uri, there is no need to render it to the canvas\n\t        // and so we can bypass this error.\n\n\t        // Keep the async nature of the function.\n\t        return setTimeout(function() {\n\t            callback(null, url);\n\t        }, 0);\n\t    }\n\n\t    // chrome, IE10+\n\t    var modernHandler = function(xhr, callback) {\n\n\t        if (xhr.status === 200) {\n\n\t            var reader = new FileReader();\n\n\t            reader.onload = function(evt) {\n\t                var dataUri = evt.target.result;\n\t                callback(null, dataUri);\n\t            };\n\n\t            reader.onerror = function() {\n\t                callback(new Error('Failed to load image ' + url));\n\t            };\n\n\t            reader.readAsDataURL(xhr.response);\n\t        } else {\n\t            callback(new Error('Failed to load image ' + url));\n\t        }\n\t    };\n\n\t    var legacyHandler = function(xhr, callback) {\n\n\t        var Uint8ToString = function(u8a) {\n\t            var CHUNK_SZ = 0x8000;\n\t            var c = [];\n\t            for (var i = 0; i < u8a.length; i += CHUNK_SZ) {\n\t                c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n\t            }\n\t            return c.join('');\n\t        };\n\n\t        if (xhr.status === 200) {\n\n\t            var bytes = new Uint8Array(xhr.response);\n\n\t            var suffix = (url.split('.').pop()) || 'png';\n\t            var map = {\n\t                'svg': 'svg+xml'\n\t            };\n\t            var meta = 'data:image/' + (map[suffix] || suffix) + ';base64,';\n\t            var b64encoded = meta + btoa(Uint8ToString(bytes));\n\t            callback(null, b64encoded);\n\t        } else {\n\t            callback(new Error('Failed to load image ' + url));\n\t        }\n\t    };\n\n\t    var xhr = new XMLHttpRequest();\n\n\t    xhr.open('GET', url, true);\n\t    xhr.addEventListener('error', function() {\n\t        callback(new Error('Failed to load image ' + url));\n\t    });\n\n\t    xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';\n\n\t    xhr.addEventListener('load', function() {\n\t        if (window.FileReader) {\n\t            modernHandler(xhr, callback);\n\t        } else {\n\t            legacyHandler(xhr, callback);\n\t        }\n\t    });\n\n\t    xhr.send();\n\t};\n\n\tvar getElementBBox = function(el) {\n\n\t    var $el = $(el);\n\t    if ($el.length === 0) {\n\t        throw new Error('Element not found');\n\t    }\n\n\t    var element = $el[0];\n\t    var doc = element.ownerDocument;\n\t    var clientBBox = element.getBoundingClientRect();\n\n\t    var strokeWidthX = 0;\n\t    var strokeWidthY = 0;\n\n\t    // Firefox correction\n\t    if (element.ownerSVGElement) {\n\n\t        var vel = V(element);\n\t        var bbox = vel.getBBox({ target: vel.svg() });\n\n\t        // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.\n\t        // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.\n\t        strokeWidthX = (clientBBox.width - bbox.width);\n\t        strokeWidthY = (clientBBox.height - bbox.height);\n\t    }\n\n\t    return {\n\t        x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,\n\t        y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,\n\t        width: clientBBox.width - strokeWidthX,\n\t        height: clientBBox.height - strokeWidthY\n\t    };\n\t};\n\n\n\t// Highly inspired by the jquery.sortElements plugin by Padolsey.\n\t// See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\n\tvar sortElements = function(elements, comparator) {\n\n\t    var $elements = $(elements);\n\t    var placements = $elements.map(function() {\n\n\t        var sortElement = this;\n\t        var parentNode = sortElement.parentNode;\n\t        // Since the element itself will change position, we have\n\t        // to have some way of storing it's original position in\n\t        // the DOM. The easiest way is to have a 'flag' node:\n\t        var nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);\n\n\t        return function() {\n\n\t            if (parentNode === this) {\n\t                throw new Error('You can\\'t sort elements if any one is a descendant of another.');\n\t            }\n\n\t            // Insert before flag:\n\t            parentNode.insertBefore(this, nextSibling);\n\t            // Remove flag:\n\t            parentNode.removeChild(nextSibling);\n\t        };\n\t    });\n\n\t    return Array.prototype.sort.call($elements, comparator).each(function(i) {\n\t        placements[i].call(this);\n\t    });\n\t};\n\n\t// Sets attributes on the given element and its descendants based on the selector.\n\t// `attrs` object: { [SELECTOR1]: { attrs1 }, [SELECTOR2]: { attrs2}, ... } e.g. { 'input': { color : 'red' }}\n\tvar setAttributesBySelector = function(element, attrs) {\n\n\t    var $element = $(element);\n\n\t    forIn(attrs, function(attrs, selector) {\n\t        var $elements = $element.find(selector).addBack().filter(selector);\n\t        // Make a special case for setting classes.\n\t        // We do not want to overwrite any existing class.\n\t        if (has$2(attrs, 'class')) {\n\t            $elements.addClass(attrs['class']);\n\t            attrs = omit(attrs, 'class');\n\t        }\n\t        $elements.attr(attrs);\n\t    });\n\t};\n\n\t// Return a new object with all four sides (top, right, bottom, left) in it.\n\t// Value of each side is taken from the given argument (either number or object).\n\t// Default value for a side is 0.\n\t// Examples:\n\t// normalizeSides(5) --> { top: 5, right: 5, bottom: 5, left: 5 }\n\t// normalizeSides({ horizontal: 5 }) --> { top: 0, right: 5, bottom: 0, left: 5 }\n\t// normalizeSides({ left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n\t// normalizeSides({ horizontal: 10, left: 5 }) --> { top: 0, right: 10, bottom: 0, left: 5 }\n\t// normalizeSides({ horizontal: 0, left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n\tvar normalizeSides = function(box) {\n\n\t    if (Object(box) !== box) { // `box` is not an object\n\t        var val = 0; // `val` left as 0 if `box` cannot be understood as finite number\n\t        if (isFinite(box)) { val = +box; } // actually also accepts string numbers (e.g. '100')\n\n\t        return { top: val, right: val, bottom: val, left: val };\n\t    }\n\n\t    // `box` is an object\n\t    var top, right, bottom, left;\n\t    top = right = bottom = left = 0;\n\n\t    if (isFinite(box.vertical)) { top = bottom = +box.vertical; }\n\t    if (isFinite(box.horizontal)) { right = left = +box.horizontal; }\n\n\t    if (isFinite(box.top)) { top = +box.top; } // overwrite vertical\n\t    if (isFinite(box.right)) { right = +box.right; } // overwrite horizontal\n\t    if (isFinite(box.bottom)) { bottom = +box.bottom; } // overwrite vertical\n\t    if (isFinite(box.left)) { left = +box.left; } // overwrite horizontal\n\n\t    return { top: top, right: right, bottom: bottom, left: left };\n\t};\n\n\tvar timing = {\n\n\t    linear: function(t) {\n\t        return t;\n\t    },\n\n\t    quad: function(t) {\n\t        return t * t;\n\t    },\n\n\t    cubic: function(t) {\n\t        return t * t * t;\n\t    },\n\n\t    inout: function(t) {\n\t        if (t <= 0) { return 0; }\n\t        if (t >= 1) { return 1; }\n\t        var t2 = t * t;\n\t        var t3 = t2 * t;\n\t        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n\t    },\n\n\t    exponential: function(t) {\n\t        return Math.pow(2, 10 * (t - 1));\n\t    },\n\n\t    bounce: function(t) {\n\t        for (var a = 0, b = 1; 1; a += b, b /= 2) {\n\t            if (t >= (7 - 4 * a) / 11) {\n\t                var q = (11 - 6 * a - 11 * t) / 4;\n\t                return -q * q + b * b;\n\t            }\n\t        }\n\t    },\n\n\t    reverse: function(f) {\n\t        return function(t) {\n\t            return 1 - f(1 - t);\n\t        };\n\t    },\n\n\t    reflect: function(f) {\n\t        return function(t) {\n\t            return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));\n\t        };\n\t    },\n\n\t    clamp: function(f, n, x) {\n\t        n = n || 0;\n\t        x = x || 1;\n\t        return function(t) {\n\t            var r = f(t);\n\t            return r < n ? n : r > x ? x : r;\n\t        };\n\t    },\n\n\t    back: function(s) {\n\t        if (!s) { s = 1.70158; }\n\t        return function(t) {\n\t            return t * t * ((s + 1) * t - s);\n\t        };\n\t    },\n\n\t    elastic: function(x) {\n\t        if (!x) { x = 1.5; }\n\t        return function(t) {\n\t            return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);\n\t        };\n\t    }\n\t};\n\n\tvar interpolate = {\n\n\t    number: function(a, b) {\n\t        var d = b - a;\n\t        return function(t) {\n\t            return a + d * t;\n\t        };\n\t    },\n\n\t    object: function(a, b) {\n\t        var s = Object.keys(a);\n\t        return function(t) {\n\t            var i, p;\n\t            var r = {};\n\t            for (i = s.length - 1; i != -1; i--) {\n\t                p = s[i];\n\t                r[p] = a[p] + (b[p] - a[p]) * t;\n\t            }\n\t            return r;\n\t        };\n\t    },\n\n\t    hexColor: function(a, b) {\n\n\t        var ca = parseInt(a.slice(1), 16);\n\t        var cb = parseInt(b.slice(1), 16);\n\t        var ra = ca & 0x0000ff;\n\t        var rd = (cb & 0x0000ff) - ra;\n\t        var ga = ca & 0x00ff00;\n\t        var gd = (cb & 0x00ff00) - ga;\n\t        var ba = ca & 0xff0000;\n\t        var bd = (cb & 0xff0000) - ba;\n\n\t        return function(t) {\n\n\t            var r = (ra + rd * t) & 0x000000ff;\n\t            var g = (ga + gd * t) & 0x0000ff00;\n\t            var b = (ba + bd * t) & 0x00ff0000;\n\n\t            return '#' + (1 << 24 | r | g | b).toString(16).slice(1);\n\t        };\n\t    },\n\n\t    unit: function(a, b) {\n\n\t        var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;\n\t        var ma = r.exec(a);\n\t        var mb = r.exec(b);\n\t        var p = mb[1].indexOf('.');\n\t        var f = p > 0 ? mb[1].length - p - 1 : 0;\n\t        a = +ma[1];\n\t        var d = +mb[1] - a;\n\t        var u = ma[2];\n\n\t        return function(t) {\n\t            return (a + d * t).toFixed(f) + u;\n\t        };\n\t    }\n\t};\n\n\t// SVG filters.\n\t// (values in parentheses are default values)\n\tvar filter = {\n\n\t    // `color` ... outline color ('blue')\n\t    // `width`... outline width (1)\n\t    // `opacity` ... outline opacity (1)\n\t    // `margin` ... gap between outline and the element (2)\n\t    outline: function(args) {\n\n\t        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" /><feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" /><feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/><feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/><feMerge><feMergeNode in=\"outline\"/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n\t        var margin = Number.isFinite(args.margin) ? args.margin : 2;\n\t        var width = Number.isFinite(args.width) ? args.width : 1;\n\n\t        return template(tpl)({\n\t            color: args.color || 'blue',\n\t            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n\t            outerRadius: margin + width,\n\t            innerRadius: margin\n\t        });\n\t    },\n\n\t    // `color` ... color ('red')\n\t    // `width`... width (1)\n\t    // `blur` ... blur (0)\n\t    // `opacity` ... opacity (1)\n\t    highlight: function(args) {\n\n\t        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/><feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/><feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/><feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/></filter>';\n\n\t        return template(tpl)({\n\t            color: args.color || 'red',\n\t            width: Number.isFinite(args.width) ? args.width : 1,\n\t            blur: Number.isFinite(args.blur) ? args.blur : 0,\n\t            opacity: Number.isFinite(args.opacity) ? args.opacity : 1\n\t        });\n\t    },\n\n\t    // `x` ... horizontal blur (2)\n\t    // `y` ... vertical blur (optional)\n\t    blur: function(args) {\n\n\t        var x = Number.isFinite(args.x) ? args.x : 2;\n\n\t        return template('<filter><feGaussianBlur stdDeviation=\"${stdDeviation}\"/></filter>')({\n\t            stdDeviation: Number.isFinite(args.y) ? [x, args.y] : x\n\t        });\n\t    },\n\n\t    // `dx` ... horizontal shift (0)\n\t    // `dy` ... vertical shift (0)\n\t    // `blur` ... blur (4)\n\t    // `color` ... color ('black')\n\t    // `opacity` ... opacity (1)\n\t    dropShadow: function(args) {\n\n\t        var tpl = 'SVGFEDropShadowElement' in window\n\t            ? '<filter><feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\"/></filter>'\n\t            : '<filter><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\"/><feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\"/><feFlood flood-color=\"${color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"${opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n\t        return template(tpl)({\n\t            dx: args.dx || 0,\n\t            dy: args.dy || 0,\n\t            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n\t            color: args.color || 'black',\n\t            blur: Number.isFinite(args.blur) ? args.blur : 4\n\t        });\n\t    },\n\n\t    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.\n\t    grayscale: function(args) {\n\n\t        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n\t        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/></filter>')({\n\t            a: 0.2126 + 0.7874 * (1 - amount),\n\t            b: 0.7152 - 0.7152 * (1 - amount),\n\t            c: 0.0722 - 0.0722 * (1 - amount),\n\t            d: 0.2126 - 0.2126 * (1 - amount),\n\t            e: 0.7152 + 0.2848 * (1 - amount),\n\t            f: 0.0722 - 0.0722 * (1 - amount),\n\t            g: 0.2126 - 0.2126 * (1 - amount),\n\t            h: 0.0722 + 0.9278 * (1 - amount)\n\t        });\n\t    },\n\n\t    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.\n\t    sepia: function(args) {\n\n\t        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n\t        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/></filter>')({\n\t            a: 0.393 + 0.607 * (1 - amount),\n\t            b: 0.769 - 0.769 * (1 - amount),\n\t            c: 0.189 - 0.189 * (1 - amount),\n\t            d: 0.349 - 0.349 * (1 - amount),\n\t            e: 0.686 + 0.314 * (1 - amount),\n\t            f: 0.168 - 0.168 * (1 - amount),\n\t            g: 0.272 - 0.272 * (1 - amount),\n\t            h: 0.534 - 0.534 * (1 - amount),\n\t            i: 0.131 + 0.869 * (1 - amount)\n\t        });\n\t    },\n\n\t    // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.\n\t    saturate: function(args) {\n\n\t        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n\t        return template('<filter><feColorMatrix type=\"saturate\" values=\"${amount}\"/></filter>')({\n\t            amount: 1 - amount\n\t        });\n\t    },\n\n\t    // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).\n\t    hueRotate: function(args) {\n\n\t        return template('<filter><feColorMatrix type=\"hueRotate\" values=\"${angle}\"/></filter>')({\n\t            angle: args.angle || 0\n\t        });\n\t    },\n\n\t    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.\n\t    invert: function(args) {\n\n\t        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n\t        return template('<filter><feComponentTransfer><feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/></feComponentTransfer></filter>')({\n\t            amount: amount,\n\t            amount2: 1 - amount\n\t        });\n\t    },\n\n\t    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n\t    brightness: function(args) {\n\n\t        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\"/><feFuncG type=\"linear\" slope=\"${amount}\"/><feFuncB type=\"linear\" slope=\"${amount}\"/></feComponentTransfer></filter>')({\n\t            amount: Number.isFinite(args.amount) ? args.amount : 1\n\t        });\n\t    },\n\n\t    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n\t    contrast: function(args) {\n\n\t        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n\t        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/></feComponentTransfer></filter>')({\n\t            amount: amount,\n\t            amount2: .5 - amount / 2\n\t        });\n\t    }\n\t};\n\n\tvar format = {\n\n\t    // Formatting numbers via the Python Format Specification Mini-language.\n\t    // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n\t    // Heavilly inspired by the D3.js library implementation.\n\t    number: function(specifier, value, locale) {\n\n\t        locale = locale || {\n\n\t            currency: ['$', ''],\n\t            decimal: '.',\n\t            thousands: ',',\n\t            grouping: [3]\n\t        };\n\n\t        // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n\t        // [[fill]align][sign][symbol][0][width][,][.precision][type]\n\t        var re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n\n\t        var match = re.exec(specifier);\n\t        var fill = match[1] || ' ';\n\t        var align = match[2] || '>';\n\t        var sign = match[3] || '';\n\t        var symbol = match[4] || '';\n\t        var zfill = match[5];\n\t        var width = +match[6];\n\t        var comma = match[7];\n\t        var precision = match[8];\n\t        var type = match[9];\n\t        var scale = 1;\n\t        var prefix = '';\n\t        var suffix = '';\n\t        var integer = false;\n\n\t        if (precision) { precision = +precision.substring(1); }\n\n\t        if (zfill || fill === '0' && align === '=') {\n\t            zfill = fill = '0';\n\t            align = '=';\n\t            if (comma) { width -= Math.floor((width - 1) / 4); }\n\t        }\n\n\t        switch (type) {\n\t            case 'n':\n\t                comma = true;\n\t                type = 'g';\n\t                break;\n\t            case '%':\n\t                scale = 100;\n\t                suffix = '%';\n\t                type = 'f';\n\t                break;\n\t            case 'p':\n\t                scale = 100;\n\t                suffix = '%';\n\t                type = 'r';\n\t                break;\n\t            case 'b':\n\t            case 'o':\n\t            case 'x':\n\t            case 'X':\n\t                if (symbol === '#') { prefix = '0' + type.toLowerCase(); }\n\t                break;\n\t            case 'c':\n\t            case 'd':\n\t                integer = true;\n\t                precision = 0;\n\t                break;\n\t            case 's':\n\t                scale = -1;\n\t                type = 'r';\n\t                break;\n\t        }\n\n\t        if (symbol === '$') {\n\t            prefix = locale.currency[0];\n\t            suffix = locale.currency[1];\n\t        }\n\n\t        // If no precision is specified for `'r'`, fallback to general notation.\n\t        if (type == 'r' && !precision) { type = 'g'; }\n\n\t        // Ensure that the requested precision is in the supported range.\n\t        if (precision != null) {\n\t            if (type == 'g') { precision = Math.max(1, Math.min(21, precision)); }\n\t            else if (type == 'e' || type == 'f') { precision = Math.max(0, Math.min(20, precision)); }\n\t        }\n\n\t        var zcomma = zfill && comma;\n\n\t        // Return the empty string for floats formatted as ints.\n\t        if (integer && (value % 1)) { return ''; }\n\n\t        // Convert negative to positive, and record the sign prefix.\n\t        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign;\n\n\t        var fullSuffix = suffix;\n\n\t        // Apply the scale, computing it from the value's exponent for si format.\n\t        // Preserve the existing suffix, if any, such as the currency symbol.\n\t        if (scale < 0) {\n\t            var unit = this.prefix(value, precision);\n\t            value = unit.scale(value);\n\t            fullSuffix = unit.symbol + suffix;\n\t        } else {\n\t            value *= scale;\n\t        }\n\n\t        // Convert to the desired precision.\n\t        value = this.convert(type, value, precision);\n\n\t        // Break the value into the integer part (before) and decimal part (after).\n\t        var i = value.lastIndexOf('.');\n\t        var before = i < 0 ? value : value.substring(0, i);\n\t        var after = i < 0 ? '' : locale.decimal + value.substring(i + 1);\n\n\t        function formatGroup(value) {\n\n\t            var i = value.length;\n\t            var t = [];\n\t            var j = 0;\n\t            var g = locale.grouping[0];\n\t            while (i > 0 && g > 0) {\n\t                t.push(value.substring(i -= g, i + g));\n\t                g = locale.grouping[j = (j + 1) % locale.grouping.length];\n\t            }\n\t            return t.reverse().join(locale.thousands);\n\t        }\n\n\t        // If the fill character is not `'0'`, grouping is applied before padding.\n\t        if (!zfill && comma && locale.grouping) {\n\n\t            before = formatGroup(before);\n\t        }\n\n\t        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);\n\t        var padding = length < width ? new Array(length = width - length + 1).join(fill) : '';\n\n\t        // If the fill character is `'0'`, grouping is applied after padding.\n\t        if (zcomma) { before = formatGroup(padding + before); }\n\n\t        // Apply prefix.\n\t        negative += prefix;\n\n\t        // Rejoin integer and decimal parts.\n\t        value = before + after;\n\n\t        return (align === '<' ? negative + value + padding\n\t            : align === '>' ? padding + negative + value\n\t                : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length)\n\t                    : negative + (zcomma ? value : padding + value)) + fullSuffix;\n\t    },\n\n\t    // Formatting string via the Python Format string.\n\t    // See https://docs.python.org/2/library/string.html#format-string-syntax)\n\t    string: function(formatString, value) {\n\n\t        var fieldDelimiterIndex;\n\t        var fieldDelimiter = '{';\n\t        var endPlaceholder = false;\n\t        var formattedStringArray = [];\n\n\t        while ((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1) {\n\n\t            var pieceFormattedString, formatSpec, fieldName;\n\n\t            pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);\n\n\t            if (endPlaceholder) {\n\t                formatSpec = pieceFormattedString.split(':');\n\t                fieldName = formatSpec.shift().split('.');\n\t                pieceFormattedString = value;\n\n\t                for (var i = 0; i < fieldName.length; i++)\n\t                    { pieceFormattedString = pieceFormattedString[fieldName[i]]; }\n\n\t                if (formatSpec.length)\n\t                    { pieceFormattedString = this.number(formatSpec, pieceFormattedString); }\n\t            }\n\n\t            formattedStringArray.push(pieceFormattedString);\n\n\t            formatString = formatString.slice(fieldDelimiterIndex + 1);\n\t            endPlaceholder = !endPlaceholder;\n\t            fieldDelimiter = (endPlaceholder) ? '}' : '{';\n\t        }\n\t        formattedStringArray.push(formatString);\n\n\t        return formattedStringArray.join('');\n\t    },\n\n\t    convert: function(type, value, precision) {\n\n\t        switch (type) {\n\t            case 'b':\n\t                return value.toString(2);\n\t            case 'c':\n\t                return String.fromCharCode(value);\n\t            case 'o':\n\t                return value.toString(8);\n\t            case 'x':\n\t                return value.toString(16);\n\t            case 'X':\n\t                return value.toString(16).toUpperCase();\n\t            case 'g':\n\t                return value.toPrecision(precision);\n\t            case 'e':\n\t                return value.toExponential(precision);\n\t            case 'f':\n\t                return value.toFixed(precision);\n\t            case 'r':\n\t                return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));\n\t            default:\n\t                return value + '';\n\t        }\n\t    },\n\n\t    round: function(value, precision) {\n\n\t        return precision\n\t            ? Math.round(value * (precision = Math.pow(10, precision))) / precision\n\t            : Math.round(value);\n\t    },\n\n\t    precision: function(value, precision) {\n\n\t        return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);\n\t    },\n\n\t    prefix: function(value, precision) {\n\n\t        var prefixes = ['y', 'z', 'a', 'f', 'p', 'n', '', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].map(function(d, i) {\n\t            var k = Math.pow(10, Math.abs(8 - i) * 3);\n\t            return {\n\t                scale: i > 8 ? function(d) {\n\t                    return d / k;\n\t                } : function(d) {\n\t                    return d * k;\n\t                },\n\t                symbol: d\n\t            };\n\t        });\n\n\t        var i = 0;\n\t        if (value) {\n\t            if (value < 0) { value *= -1; }\n\t            if (precision) { value = this.round(value, this.precision(value, precision)); }\n\t            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n\t            i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n\t        }\n\t        return prefixes[8 + i / 3];\n\t    }\n\t};\n\n\t/*\n\t    Pre-compile the HTML to be used as a template.\n\t*/\n\tvar template = function(html) {\n\n\t    /*\n\t        Must support the variation in templating syntax found here:\n\t        https://lodash.com/docs#template\n\t    */\n\t    var regex = /<%= ([^ ]+) %>|\\$\\{ ?([^{} ]+) ?\\}|\\{\\{([^{} ]+)\\}\\}/g;\n\n\t    return function(data) {\n\n\t        data = data || {};\n\n\t        return html.replace(regex, function(match) {\n\n\t            var args = Array.from(arguments);\n\t            var attr = args.slice(1, 4).find(function(_attr) {\n\t                return !!_attr;\n\t            });\n\n\t            var attrArray = attr.split('.');\n\t            var value = data[attrArray.shift()];\n\n\t            while (value !== undefined && attrArray.length) {\n\t                value = value[attrArray.shift()];\n\t            }\n\n\t            return value !== undefined ? value : '';\n\t        });\n\t    };\n\t};\n\n\t/**\n\t * @param {Element} el Element, which content is intent to display in full-screen mode, 'window.top.document.body' is default.\n\t */\n\tvar toggleFullScreen = function(el) {\n\n\t    var topDocument = window.top.document;\n\t    el = el || topDocument.body;\n\n\t    function prefixedResult(el, prop) {\n\n\t        var prefixes = ['webkit', 'moz', 'ms', 'o', ''];\n\t        for (var i = 0; i < prefixes.length; i++) {\n\t            var prefix = prefixes[i];\n\t            var propName = prefix ? (prefix + prop) : (prop.substr(0, 1).toLowerCase() + prop.substr(1));\n\t            if (el[propName] !== undefined) {\n\t                return isFunction(el[propName]) ? el[propName]() : el[propName];\n\t            }\n\t        }\n\t    }\n\n\t    if (prefixedResult(topDocument, 'FullscreenElement') || prefixedResult(topDocument, 'FullScreenElement')) {\n\t        prefixedResult(topDocument, 'ExitFullscreen') || // Spec.\n\t        prefixedResult(topDocument, 'CancelFullScreen'); // Firefox\n\t    } else {\n\t        prefixedResult(el, 'RequestFullscreen') || // Spec.\n\t        prefixedResult(el, 'RequestFullScreen'); // Firefox\n\t    }\n\t};\n\n\tvar noop = function() {\n\t};\n\n\t// Clone `cells` returning an object that maps the original cell ID to the clone. The number\n\t// of clones is exactly the same as the `cells.length`.\n\t// This function simply clones all the `cells`. However, it also reconstructs\n\t// all the `source/target` and `parent/embed` references within the `cells`.\n\t// This is the main difference from the `cell.clone()` method. The\n\t// `cell.clone()` method works on one single cell only.\n\t// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n\t// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n\t// the source and target of the link `L2` is changed to point to `A2` and `B2`.\n\tfunction cloneCells(cells) {\n\n\t    cells = uniq(cells);\n\n\t    // A map of the form [original cell ID] -> [clone] helping\n\t    // us to reconstruct references for source/target and parent/embeds.\n\t    // This is also the returned value.\n\t    var cloneMap = toArray(cells).reduce(function(map, cell) {\n\t        map[cell.id] = cell.clone();\n\t        return map;\n\t    }, {});\n\n\t    toArray(cells).forEach(function(cell) {\n\n\t        var clone = cloneMap[cell.id];\n\t        // assert(clone exists)\n\n\t        if (clone.isLink()) {\n\t            var source = clone.source();\n\t            var target = clone.target();\n\t            if (source.id && cloneMap[source.id]) {\n\t                // Source points to an element and the element is among the clones.\n\t                // => Update the source of the cloned link.\n\t                clone.prop('source/id', cloneMap[source.id].id);\n\t            }\n\t            if (target.id && cloneMap[target.id]) {\n\t                // Target points to an element and the element is among the clones.\n\t                // => Update the target of the cloned link.\n\t                clone.prop('target/id', cloneMap[target.id].id);\n\t            }\n\t        }\n\n\t        // Find the parent of the original cell\n\t        var parent = cell.get('parent');\n\t        if (parent && cloneMap[parent]) {\n\t            clone.set('parent', cloneMap[parent].id);\n\t        }\n\n\t        // Find the embeds of the original cell\n\t        var embeds = toArray(cell.get('embeds')).reduce(function(newEmbeds, embed) {\n\t            // Embedded cells that are not being cloned can not be carried\n\t            // over with other embedded cells.\n\t            if (cloneMap[embed]) {\n\t                newEmbeds.push(cloneMap[embed].id);\n\t            }\n\t            return newEmbeds;\n\t        }, []);\n\n\t        if (!isEmpty(embeds)) {\n\t            clone.set('embeds', embeds);\n\t        }\n\t    });\n\n\t    return cloneMap;\n\t}\n\n\tvar validPropertiesList = ['checked', 'selected', 'disabled', 'readOnly', 'contentEditable', 'value', 'indeterminate'];\n\n\tvar validProperties = validPropertiesList.reduce(function (acc, key) {\n\t    acc[key] = true;\n\t    return acc;\n\t}, {});\n\n\tvar props$1 = {\n\t    qualify: function(properties) {\n\t        return isPlainObject(properties);\n\t    },\n\t    set: function(properties, _, node) {\n\t        Object.keys(properties).forEach(function(key) {\n\t            if (validProperties[key] && key in node) {\n\t                var value = properties[key];\n\t                if (node.tagName === 'SELECT' && Array.isArray(value)) {\n\t                    Array.from(node.options).forEach(function(option, index) {\n\t                        option.selected = value.includes(option.value);\n\t                    });\n\t                } else {\n\t                    node[key] = value;\n\t                }\n\t            }\n\t        });\n\t    }\n\t};\n\n\tfunction setWrapper(attrName, dimension) {\n\t    return function(value, refBBox) {\n\t        var isValuePercentage = isPercentage(value);\n\t        value = parseFloat(value);\n\t        if (isValuePercentage) {\n\t            value /= 100;\n\t        }\n\n\t        var attrs = {};\n\t        if (isFinite(value)) {\n\t            var attrValue = (isValuePercentage || value >= 0 && value <= 1)\n\t                ? value * refBBox[dimension]\n\t                : Math.max(value + refBBox[dimension], 0);\n\t            attrs[attrName] = attrValue;\n\t        }\n\n\t        return attrs;\n\t    };\n\t}\n\n\tfunction positionWrapper(axis, dimension, origin) {\n\t    return function(value, refBBox) {\n\t        var valuePercentage = isPercentage(value);\n\t        value = parseFloat(value);\n\t        if (valuePercentage) {\n\t            value /= 100;\n\t        }\n\n\t        var delta;\n\t        if (isFinite(value)) {\n\t            var refOrigin = refBBox[origin]();\n\t            if (valuePercentage || value > 0 && value < 1) {\n\t                delta = refOrigin[axis] + refBBox[dimension] * value;\n\t            } else {\n\t                delta = refOrigin[axis] + value;\n\t            }\n\t        }\n\n\t        var point = Point();\n\t        point[axis] = delta || 0;\n\t        return point;\n\t    };\n\t}\n\n\tfunction offsetWrapper(axis, dimension, corner) {\n\t    return function(value, nodeBBox) {\n\t        var delta;\n\t        if (value === 'middle') {\n\t            delta = nodeBBox[dimension] / 2;\n\t        } else if (value === corner) {\n\t            delta = nodeBBox[dimension];\n\t        } else if (isFinite(value)) {\n\t            // TODO: or not to do a breaking change?\n\t            delta = (value > -1 && value < 1) ? (-nodeBBox[dimension] * value) : -value;\n\t        } else if (isPercentage(value)) {\n\t            delta = nodeBBox[dimension] * parseFloat(value) / 100;\n\t        } else {\n\t            delta = 0;\n\t        }\n\n\t        var point = Point();\n\t        point[axis] = -(nodeBBox[axis] + delta);\n\t        return point;\n\t    };\n\t}\n\n\tfunction shapeWrapper(shapeConstructor, opt) {\n\t    var cacheName = 'joint-shape';\n\t    var resetOffset = opt && opt.resetOffset;\n\t    return function(value, refBBox, node) {\n\t        var $node = $(node);\n\t        var cache = $node.data(cacheName);\n\t        if (!cache || cache.value !== value) {\n\t            // only recalculate if value has changed\n\t            var cachedShape = shapeConstructor(value);\n\t            cache = {\n\t                value: value,\n\t                shape: cachedShape,\n\t                shapeBBox: cachedShape.bbox()\n\t            };\n\t            $node.data(cacheName, cache);\n\t        }\n\n\t        var shape = cache.shape.clone();\n\t        var shapeBBox = cache.shapeBBox.clone();\n\t        var shapeOrigin = shapeBBox.origin();\n\t        var refOrigin = refBBox.origin();\n\n\t        shapeBBox.x = refOrigin.x;\n\t        shapeBBox.y = refOrigin.y;\n\n\t        var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);\n\t        // `maxRectScaleToFit` can give Infinity if width or height is 0\n\t        var sx = (shapeBBox.width === 0 || refBBox.width === 0) ? 1 : fitScale.sx;\n\t        var sy = (shapeBBox.height === 0 || refBBox.height === 0) ? 1 : fitScale.sy;\n\n\t        shape.scale(sx, sy, shapeOrigin);\n\t        if (resetOffset) {\n\t            shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n\t        }\n\n\t        return shape;\n\t    };\n\t}\n\n\t// `d` attribute for SVGPaths\n\tfunction dWrapper(opt) {\n\t    function pathConstructor(value) {\n\t        return new Path(V.normalizePathData(value));\n\t    }\n\n\t    var shape = shapeWrapper(pathConstructor, opt);\n\t    return function(value, refBBox, node) {\n\t        var path = shape(value, refBBox, node);\n\t        return {\n\t            d: path.serialize()\n\t        };\n\t    };\n\t}\n\n\t// `points` attribute for SVGPolylines and SVGPolygons\n\tfunction pointsWrapper(opt) {\n\t    var shape = shapeWrapper(Polyline, opt);\n\t    return function(value, refBBox, node) {\n\t        var polyline = shape(value, refBBox, node);\n\t        return {\n\t            points: polyline.serialize()\n\t        };\n\t    };\n\t}\n\n\tfunction atConnectionWrapper(method, opt) {\n\t    var zeroVector = new Point(1, 0);\n\t    return function(value) {\n\t        var p, angle;\n\t        var tangent = this[method](value);\n\t        if (tangent) {\n\t            angle = (opt.rotate) ? tangent.vector().vectorAngle(zeroVector) : 0;\n\t            p = tangent.start;\n\t        } else {\n\t            p = this.path.start;\n\t            angle = 0;\n\t        }\n\t        if (angle === 0) { return { transform: 'translate(' + p.x + ',' + p.y + ')' }; }\n\t        return { transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')' };\n\t    };\n\t}\n\n\tfunction setIfChangedWrapper(attribute) {\n\t    return function setIfChanged(value, _, node) {\n\t        var vel = V(node);\n\t        if (vel.attr(attribute) === value) { return; }\n\t        vel.attr(attribute, value);\n\t    };\n\t}\n\n\tfunction isTextInUse(_value, _node, attrs) {\n\t    return (attrs.text !== undefined);\n\t}\n\n\tfunction isLinkView() {\n\t    return this.model.isLink();\n\t}\n\n\tfunction contextMarker(context) {\n\t    var marker = {};\n\t    // Stroke\n\t    // The context 'fill' is disregared here. The usual case is to use the marker with a connection\n\t    // (for which 'fill' attribute is set to 'none').\n\t    var stroke = context.stroke;\n\t    if (typeof stroke === 'string') {\n\t        marker['stroke'] = stroke;\n\t        marker['fill'] = stroke;\n\t    }\n\t    // Opacity\n\t    // Again the context 'fill-opacity' is ignored.\n\t    var strokeOpacity = context.strokeOpacity;\n\t    if (strokeOpacity === undefined) { strokeOpacity = context['stroke-opacity']; }\n\t    if (strokeOpacity === undefined) { strokeOpacity = context.opacity; }\n\t    if (strokeOpacity !== undefined) {\n\t        marker['stroke-opacity'] = strokeOpacity;\n\t        marker['fill-opacity'] = strokeOpacity;\n\t    }\n\t    return marker;\n\t}\n\n\tfunction setPaintURL(def) {\n\t    var ref = this;\n\t    var paper = ref.paper;\n\t    var url = (def.type === 'pattern')\n\t        ? paper.definePattern(def)\n\t        : paper.defineGradient(def);\n\t    return (\"url(#\" + url + \")\");\n\t}\n\n\tvar attributesNS = {\n\n\t    xlinkShow: {\n\t        set: 'xlink:show'\n\t    },\n\n\t    xlinkRole: {\n\t        set: 'xlink:role'\n\t    },\n\n\t    xlinkType: {\n\t        set: 'xlink:type'\n\t    },\n\n\t    xlinkArcrole: {\n\t        set: 'xlink:arcrole'\n\t    },\n\n\t    xlinkTitle: {\n\t        set: 'xlink:title'\n\t    },\n\n\t    xlinkActuate: {\n\t        set: 'xlink:actuate'\n\t    },\n\n\t    xmlSpace: {\n\t        set: 'xml:space'\n\t    },\n\n\t    xmlBase: {\n\t        set: 'xml:base'\n\t    },\n\n\t    xmlLang: {\n\t        set: 'xml:lang'\n\t    },\n\n\t    preserveAspectRatio: {\n\t        set: 'preserveAspectRatio'\n\t    },\n\n\t    requiredExtension: {\n\t        set: 'requiredExtension'\n\t    },\n\n\t    requiredFeatures: {\n\t        set: 'requiredFeatures'\n\t    },\n\n\t    systemLanguage: {\n\t        set: 'systemLanguage'\n\t    },\n\n\t    externalResourcesRequired: {\n\t        set: 'externalResourceRequired'\n\t    },\n\n\t    href: {\n\t        set: setIfChangedWrapper('href')\n\t    },\n\n\t    xlinkHref: {\n\t        set: setIfChangedWrapper('xlink:href')\n\t    },\n\n\t    filter: {\n\t        qualify: isPlainObject,\n\t        set: function(filter) {\n\t            return 'url(#' + this.paper.defineFilter(filter) + ')';\n\t        }\n\t    },\n\n\t    fill: {\n\t        qualify: isPlainObject,\n\t        set: setPaintURL\n\t    },\n\n\t    stroke: {\n\t        qualify: isPlainObject,\n\t        set: setPaintURL\n\t    },\n\n\t    sourceMarker: {\n\t        qualify: isPlainObject,\n\t        set: function(marker, refBBox, node, attrs) {\n\t            marker = assign(contextMarker(attrs), marker);\n\t            return { 'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')' };\n\t        }\n\t    },\n\n\t    targetMarker: {\n\t        qualify: isPlainObject,\n\t        set: function(marker, refBBox, node, attrs) {\n\t            marker = assign(contextMarker(attrs), { 'transform': 'rotate(180)' }, marker);\n\t            return { 'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')' };\n\t        }\n\t    },\n\n\t    vertexMarker: {\n\t        qualify: isPlainObject,\n\t        set: function(marker, refBBox, node, attrs) {\n\t            marker = assign(contextMarker(attrs), marker);\n\t            return { 'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')' };\n\t        }\n\t    },\n\n\t    text: {\n\t        qualify: function(_text, _node, attrs) {\n\t            return !attrs.textWrap || !isPlainObject(attrs.textWrap);\n\t        },\n\t        set: function(text, refBBox, node, attrs) {\n\t            var $node = $(node);\n\t            var cacheName = 'joint-text';\n\t            var cache = $node.data(cacheName);\n\t            var textAttrs = pick(attrs, 'lineHeight', 'annotations', 'textPath', 'x', 'textVerticalAnchor', 'eol', 'displayEmpty');\n\t            // eval `x` if using calc()\n\t            var x = textAttrs.x;\n\t            if (isCalcAttribute(x)) {\n\t                textAttrs.x = evalCalcAttribute(x, refBBox);\n\t            }\n\n\t            var fontSizeAttr = attrs['font-size'] || attrs['fontSize'];\n\t            if (isCalcAttribute(fontSizeAttr)) {\n\t                fontSizeAttr = evalCalcAttribute(fontSizeAttr, refBBox);\n\t            }\n\t            var fontSize = textAttrs.fontSize = fontSizeAttr;\n\t            var textHash = JSON.stringify([text, textAttrs]);\n\t            // Update the text only if there was a change in the string\n\t            // or any of its attributes.\n\t            if (cache === undefined || cache !== textHash) {\n\t                // Chrome bug:\n\t                // Tspans positions defined as `em` are not updated\n\t                // when container `font-size` change.\n\t                if (fontSize) { node.setAttribute('font-size', fontSize); }\n\t                // Text Along Path Selector\n\t                var textPath = textAttrs.textPath;\n\t                if (isObject$1(textPath)) {\n\t                    var pathSelector = textPath.selector;\n\t                    if (typeof pathSelector === 'string') {\n\t                        var pathNode = this.findBySelector(pathSelector)[0];\n\t                        if (pathNode instanceof SVGPathElement) {\n\t                            textAttrs.textPath = assign({ 'xlink:href': '#' + pathNode.id }, textPath);\n\t                        }\n\t                    }\n\t                }\n\t                V(node).text('' + text, textAttrs);\n\t                $node.data(cacheName, textHash);\n\t            }\n\t        }\n\t    },\n\n\t    textWrap: {\n\t        qualify: isPlainObject,\n\t        set: function(value, refBBox, node, attrs) {\n\t            var size = {};\n\t            // option `width`\n\t            var width = value.width || 0;\n\t            if (isPercentage(width)) {\n\t                size.width = refBBox.width * parseFloat(width) / 100;\n\t            } else if (isCalcAttribute(width)) {\n\t                size.width = Number(evalCalcAttribute(width, refBBox));\n\t            } else {\n\t                if (value.width === null) {\n\t                    // breakText() requires width to be specified.\n\t                    size.width = Infinity;\n\t                } else if (width <= 0) {\n\t                    size.width = refBBox.width + width;\n\t                } else {\n\t                    size.width = width;\n\t                }\n\t            }\n\t            // option `height`\n\t            var height = value.height || 0;\n\t            if (isPercentage(height)) {\n\t                size.height = refBBox.height * parseFloat(height) / 100;\n\t            } else if (isCalcAttribute(height)) {\n\t                size.height = Number(evalCalcAttribute(height, refBBox));\n\t            } else {\n\t                if (value.height === null) {\n\t                    // if height is not specified breakText() does not\n\t                    // restrict the height of the text.\n\t                } else if (height <= 0) {\n\t                    size.height = refBBox.height + height;\n\t                } else {\n\t                    size.height = height;\n\t                }\n\t            }\n\t            // option `text`\n\t            var wrappedText;\n\t            var text = value.text;\n\t            if (text === undefined) { text = attrs.text; }\n\t            if (text !== undefined) {\n\t                var breakTextFn = value.breakText || breakText;\n\t                var fontSizeAttr = attrs['font-size'] || attrs.fontSize;\n\t                wrappedText = breakTextFn('' + text, size, {\n\t                    'font-weight': attrs['font-weight'] || attrs.fontWeight,\n\t                    'font-size': isCalcAttribute(fontSizeAttr) ? evalCalcAttribute(fontSizeAttr, refBBox) : fontSizeAttr,\n\t                    'font-family': attrs['font-family'] || attrs.fontFamily,\n\t                    'lineHeight': attrs.lineHeight,\n\t                    'letter-spacing': 'letter-spacing' in attrs ? attrs['letter-spacing'] : attrs.letterSpacing\n\t                }, {\n\t                    // Provide an existing SVG Document here\n\t                    // instead of creating a temporary one over again.\n\t                    svgDocument: this.paper.svg,\n\t                    ellipsis: value.ellipsis,\n\t                    hyphen: value.hyphen,\n\t                    maxLineCount: value.maxLineCount,\n\t                    preserveSpaces: value.preserveSpaces\n\t                });\n\t            } else {\n\t                wrappedText = '';\n\t            }\n\t            attributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n\t        }\n\t    },\n\n\t    title: {\n\t        qualify: function(title, node) {\n\t            // HTMLElement title is specified via an attribute (i.e. not an element)\n\t            return node instanceof SVGElement;\n\t        },\n\t        set: function(title, refBBox, node) {\n\t            var $node = $(node);\n\t            var cacheName = 'joint-title';\n\t            var cache = $node.data(cacheName);\n\t            if (cache === undefined || cache !== title) {\n\t                $node.data(cacheName, title);\n\t                if (node.tagName === 'title') {\n\t                    // The target node is a <title> element.\n\t                    node.textContent = title;\n\t                    return;\n\t                }\n\t                // Generally <title> element should be the first child element of its parent.\n\t                var firstChild = node.firstElementChild;\n\t                if (firstChild && firstChild.tagName === 'title') {\n\t                    // Update an existing title\n\t                    firstChild.textContent = title;\n\t                } else {\n\t                    // Create a new title\n\t                    var titleNode = document.createElementNS(node.namespaceURI, 'title');\n\t                    titleNode.textContent = title;\n\t                    node.insertBefore(titleNode, firstChild);\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    lineHeight: {\n\t        qualify: isTextInUse\n\t    },\n\n\t    textVerticalAnchor: {\n\t        qualify: isTextInUse\n\t    },\n\n\t    textPath: {\n\t        qualify: isTextInUse\n\t    },\n\n\t    annotations: {\n\t        qualify: isTextInUse\n\t    },\n\n\t    eol: {\n\t        qualify: isTextInUse\n\t    },\n\n\t    displayEmpty: {\n\t        qualify: isTextInUse\n\t    },\n\n\t    // `port` attribute contains the `id` of the port that the underlying magnet represents.\n\t    port: {\n\t        set: function(port) {\n\t            return (port === null || port.id === undefined) ? port : port.id;\n\t        }\n\t    },\n\n\t    // `style` attribute is special in the sense that it sets the CSS style of the subelement.\n\t    style: {\n\t        qualify: isPlainObject,\n\t        set: function(styles, refBBox, node) {\n\t            $(node).css(styles);\n\t        }\n\t    },\n\n\t    html: {\n\t        set: function(html, refBBox, node) {\n\t            $(node).html(html + '');\n\t        }\n\t    },\n\n\t    // Properties setter (set various properties on the node)\n\t    props: props$1,\n\n\t    ref: {\n\t        // We do not set `ref` attribute directly on an element.\n\t        // The attribute itself does not qualify for relative positioning.\n\t    },\n\n\t    // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n\t    // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n\t    // otherwise, `refX` is the left coordinate of the bounding box\n\n\t    refX: {\n\t        position: positionWrapper('x', 'width', 'origin')\n\t    },\n\n\t    refY: {\n\t        position: positionWrapper('y', 'height', 'origin')\n\t    },\n\n\t    // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n\t    // coordinate of the reference element.\n\n\t    refDx: {\n\t        position: positionWrapper('x', 'width', 'corner')\n\t    },\n\n\t    refDy: {\n\t        position: positionWrapper('y', 'height', 'corner')\n\t    },\n\n\t    // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n\t    // the reference element size\n\t    // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n\t    // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\n\t    refWidth: {\n\t        set: setWrapper('width', 'width')\n\t    },\n\n\t    refHeight: {\n\t        set: setWrapper('height', 'height')\n\t    },\n\n\t    refRx: {\n\t        set: setWrapper('rx', 'width')\n\t    },\n\n\t    refRy: {\n\t        set: setWrapper('ry', 'height')\n\t    },\n\n\t    refRInscribed: {\n\t        set: (function(attrName) {\n\t            var widthFn = setWrapper(attrName, 'width');\n\t            var heightFn = setWrapper(attrName, 'height');\n\t            return function(value, refBBox) {\n\t                var fn = (refBBox.height > refBBox.width) ? widthFn : heightFn;\n\t                return fn(value, refBBox);\n\t            };\n\t        })('r')\n\t    },\n\n\t    refRCircumscribed: {\n\t        set: function(value, refBBox) {\n\t            var isValuePercentage = isPercentage(value);\n\t            value = parseFloat(value);\n\t            if (isValuePercentage) {\n\t                value /= 100;\n\t            }\n\n\t            var diagonalLength = Math.sqrt((refBBox.height * refBBox.height) + (refBBox.width * refBBox.width));\n\n\t            var rValue;\n\t            if (isFinite(value)) {\n\t                if (isValuePercentage || value >= 0 && value <= 1) { rValue = value * diagonalLength; }\n\t                else { rValue = Math.max(value + diagonalLength, 0); }\n\t            }\n\n\t            return { r: rValue };\n\t        }\n\t    },\n\n\t    refCx: {\n\t        set: setWrapper('cx', 'width')\n\t    },\n\n\t    refCy: {\n\t        set: setWrapper('cy', 'height')\n\t    },\n\n\t    // `x-alignment` when set to `middle` causes centering of the subelement around its new x coordinate.\n\t    // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n\n\t    xAlignment: {\n\t        offset: offsetWrapper('x', 'width', 'right')\n\t    },\n\n\t    // `y-alignment` when set to `middle` causes centering of the subelement around its new y coordinate.\n\t    // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n\n\t    yAlignment: {\n\t        offset: offsetWrapper('y', 'height', 'bottom')\n\t    },\n\n\t    resetOffset: {\n\t        offset: function(val, nodeBBox) {\n\t            return (val)\n\t                ? { x: -nodeBBox.x, y: -nodeBBox.y }\n\t                : { x: 0, y: 0 };\n\t        }\n\n\t    },\n\n\t    refDResetOffset: {\n\t        set: dWrapper({ resetOffset: true })\n\t    },\n\n\t    refDKeepOffset: {\n\t        set: dWrapper({ resetOffset: false })\n\t    },\n\n\t    refPointsResetOffset: {\n\t        set: pointsWrapper({ resetOffset: true })\n\t    },\n\n\t    refPointsKeepOffset: {\n\t        set: pointsWrapper({ resetOffset: false })\n\t    },\n\n\t    // LinkView Attributes\n\n\t    connection: {\n\t        qualify: isLinkView,\n\t        set: function(ref) {\n\t            var stubs = ref.stubs; if ( stubs === void 0 ) stubs = 0;\n\n\t            var d;\n\t            if (isFinite(stubs) && stubs !== 0) {\n\t                var offset;\n\t                if (stubs < 0) {\n\t                    offset = (this.getConnectionLength() + stubs) / 2;\n\t                } else {\n\t                    offset = stubs;\n\t                }\n\t                var path = this.getConnection();\n\t                var segmentSubdivisions = this.getConnectionSubdivisions();\n\t                var sourceParts = path.divideAtLength(offset, { segmentSubdivisions: segmentSubdivisions });\n\t                var targetParts = path.divideAtLength(-offset, { segmentSubdivisions: segmentSubdivisions });\n\t                if (sourceParts && targetParts) {\n\t                    d = (sourceParts[0].serialize()) + \" \" + (targetParts[1].serialize());\n\t                }\n\t            }\n\n\t            return { d: d || this.getSerializedConnection() };\n\t        }\n\t    },\n\n\t    atConnectionLengthKeepGradient: {\n\t        qualify: isLinkView,\n\t        set: atConnectionWrapper('getTangentAtLength', { rotate: true })\n\t    },\n\n\t    atConnectionLengthIgnoreGradient: {\n\t        qualify: isLinkView,\n\t        set: atConnectionWrapper('getTangentAtLength', { rotate: false })\n\t    },\n\n\t    atConnectionRatioKeepGradient: {\n\t        qualify: isLinkView,\n\t        set: atConnectionWrapper('getTangentAtRatio', { rotate: true })\n\t    },\n\n\t    atConnectionRatioIgnoreGradient: {\n\t        qualify: isLinkView,\n\t        set: atConnectionWrapper('getTangentAtRatio', { rotate: false })\n\t    }\n\t};\n\n\tattributesNS['xlink:href'] = attributesNS.xlinkHref;\n\n\t// Support `calc()` with the following SVG attributes\n\t[\n\t    'transform', // g\n\t    'd', // path\n\t    'points', // polyline / polygon\n\t    'cx', 'cy', // circle / ellipse\n\t    'x1', 'x2', 'y1', 'y2', // line\n\t    'x', 'y', // rect / text / image\n\t    'dx', 'dy' // text\n\t].forEach(function (attribute) {\n\t    attributesNS[attribute] = {\n\t        qualify: isCalcAttribute,\n\t        set: function setCalcAttribute(value, refBBox) {\n\t            var obj;\n\n\t            return ( obj = {}, obj[attribute] = evalCalcAttribute(value, refBBox), obj );\n\t        }\n\t    };\n\t});\n\n\t// Prevent \"A negative value is not valid\" error.\n\t[\n\t    'width', 'height', // rect / image\n\t    'r', // circle\n\t    'rx', 'ry', // rect / ellipse\n\t    'font-size', // text\n\t    'stroke-width' // elements\n\t].forEach(function (attribute) {\n\t    attributesNS[attribute] = {\n\t        qualify: isCalcAttribute,\n\t        set: function setCalcAttribute(value, refBBox) {\n\t            var obj;\n\n\t            return ( obj = {}, obj[attribute] = Math.max(0, evalCalcAttribute(value, refBBox)), obj );\n\t        }\n\t    };\n\t});\n\n\t// Aliases\n\tattributesNS.refR = attributesNS.refRInscribed;\n\tattributesNS.refD = attributesNS.refDResetOffset;\n\tattributesNS.refPoints = attributesNS.refPointsResetOffset;\n\tattributesNS.atConnectionLength = attributesNS.atConnectionLengthKeepGradient;\n\tattributesNS.atConnectionRatio = attributesNS.atConnectionRatioKeepGradient;\n\tattributesNS.fontSize = attributesNS['font-size'];\n\tattributesNS.strokeWidth = attributesNS['stroke-width'];\n\n\t// This allows to combine both absolute and relative positioning\n\t// refX: 50%, refX2: 20\n\tattributesNS.refX2 = attributesNS.refX;\n\tattributesNS.refY2 = attributesNS.refY;\n\tattributesNS.refWidth2 = attributesNS.refWidth;\n\tattributesNS.refHeight2 = attributesNS.refHeight;\n\n\t// Aliases for backwards compatibility\n\tattributesNS['ref-x'] = attributesNS.refX;\n\tattributesNS['ref-y'] = attributesNS.refY;\n\tattributesNS['ref-dy'] = attributesNS.refDy;\n\tattributesNS['ref-dx'] = attributesNS.refDx;\n\tattributesNS['ref-width'] = attributesNS.refWidth;\n\tattributesNS['ref-height'] = attributesNS.refHeight;\n\tattributesNS['x-alignment'] = attributesNS.xAlignment;\n\tattributesNS['y-alignment'] = attributesNS.yAlignment;\n\n\tvar attributes = attributesNS;\n\n\t// Cell base model.\n\t// --------------------------\n\n\tvar Cell = Backbone.Model.extend({\n\n\t    // This is the same as Backbone.Model with the only difference that is uses util.merge\n\t    // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\n\t    constructor: function(attributes, options) {\n\n\t        var defaults;\n\t        var attrs = attributes || {};\n\t        if (typeof this.preinitialize === 'function') {\n\t            // Check to support an older version of Backbone (prior v1.4)\n\t            this.preinitialize.apply(this, arguments);\n\t        }\n\t        this.cid = uniqueId('c');\n\t        this.attributes = {};\n\t        if (options && options.collection) { this.collection = options.collection; }\n\t        if (options && options.parse) { attrs = this.parse(attrs, options) || {}; }\n\t        if ((defaults = result(this, 'defaults'))) {\n\t            //<custom code>\n\t            // Replaced the call to _.defaults with util.merge.\n\t            attrs = merge({}, defaults, attrs);\n\t            //</custom code>\n\t        }\n\t        this.set(attrs, options);\n\t        this.changed = {};\n\t        this.initialize.apply(this, arguments);\n\t    },\n\n\t    translate: function(dx, dy, opt) {\n\n\t        throw new Error('Must define a translate() method.');\n\t    },\n\n\t    toJSON: function() {\n\n\t        var defaults = result(this.constructor.prototype, 'defaults');\n\t        var defaultAttrs = defaults.attrs || {};\n\t        var attrs = this.attributes.attrs;\n\t        var finalAttrs = {};\n\n\t        // Loop through all the attributes and\n\t        // omit the default attributes as they are implicitly reconstructible by the cell 'type'.\n\t        forIn(attrs, function(attr, selector) {\n\n\t            var defaultAttr = defaultAttrs[selector];\n\n\t            forIn(attr, function(value, name) {\n\n\t                // attr is mainly flat though it might have one more level (consider the `style` attribute).\n\t                // Check if the `value` is object and if yes, go one level deep.\n\t                if (isObject$1(value) && !Array.isArray(value)) {\n\n\t                    forIn(value, function(value2, name2) {\n\n\t                        if (!defaultAttr || !defaultAttr[name] || !isEqual(defaultAttr[name][name2], value2)) {\n\n\t                            finalAttrs[selector] = finalAttrs[selector] || {};\n\t                            (finalAttrs[selector][name] || (finalAttrs[selector][name] = {}))[name2] = value2;\n\t                        }\n\t                    });\n\n\t                } else if (!defaultAttr || !isEqual(defaultAttr[name], value)) {\n\t                    // `value` is not an object, default attribute for such a selector does not exist\n\t                    // or it is different than the attribute value set on the model.\n\n\t                    finalAttrs[selector] = finalAttrs[selector] || {};\n\t                    finalAttrs[selector][name] = value;\n\t                }\n\t            });\n\t        });\n\n\t        var attributes = cloneDeep(omit(this.attributes, 'attrs'));\n\t        attributes.attrs = finalAttrs;\n\n\t        return attributes;\n\t    },\n\n\t    initialize: function(options) {\n\n\t        var idAttribute = this.getIdAttribute();\n\t        if (!options || options[idAttribute] === undefined) {\n\t            this.set(idAttribute, this.generateId(), { silent: true });\n\t        }\n\n\t        this._transitionIds = {};\n\t        this._scheduledTransitionIds = {};\n\n\t        // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n\t        this.processPorts();\n\t        this.on('change:attrs', this.processPorts, this);\n\t    },\n\n\t    getIdAttribute: function() {\n\t        return this.idAttribute || 'id';\n\t    },\n\n\t    generateId: function() {\n\t        return uuid();\n\t    },\n\n\t    /**\n\t     * @deprecated\n\t     */\n\t    processPorts: function() {\n\n\t        // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n\t        // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n\t        // set to that port, we remove those links as well (to follow the same behaviour as\n\t        // with a removed element).\n\n\t        var previousPorts = this.ports;\n\n\t        // Collect ports from the `attrs` object.\n\t        var ports = {};\n\t        forIn(this.get('attrs'), function(attrs, selector) {\n\n\t            if (attrs && attrs.port) {\n\n\t                // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n\t                if (attrs.port.id !== undefined) {\n\t                    ports[attrs.port.id] = attrs.port;\n\t                } else {\n\t                    ports[attrs.port] = { id: attrs.port };\n\t                }\n\t            }\n\t        });\n\n\t        // Collect ports that have been removed (compared to the previous ports) - if any.\n\t        // Use hash table for quick lookup.\n\t        var removedPorts = {};\n\t        forIn(previousPorts, function(port, id) {\n\n\t            if (!ports[id]) { removedPorts[id] = true; }\n\t        });\n\n\t        // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n\t        if (this.graph && !isEmpty(removedPorts)) {\n\n\t            var inboundLinks = this.graph.getConnectedLinks(this, { inbound: true });\n\t            inboundLinks.forEach(function(link) {\n\n\t                if (removedPorts[link.get('target').port]) { link.remove(); }\n\t            });\n\n\t            var outboundLinks = this.graph.getConnectedLinks(this, { outbound: true });\n\t            outboundLinks.forEach(function(link) {\n\n\t                if (removedPorts[link.get('source').port]) { link.remove(); }\n\t            });\n\t        }\n\n\t        // Update the `ports` object.\n\t        this.ports = ports;\n\t    },\n\n\t    remove: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        // Store the graph in a variable because `this.graph` won't be accessible\n\t        // after `this.trigger('remove', ...)` down below.\n\t        var ref = this;\n\t        var graph = ref.graph;\n\t        var collection = ref.collection;\n\t        if (!graph) {\n\t            // The collection is a common Backbone collection (not the graph collection).\n\t            if (collection) { collection.remove(this, opt); }\n\t            return this;\n\t        }\n\n\t        graph.startBatch('remove');\n\n\t        // First, unembed this cell from its parent cell if there is one.\n\t        var parentCell = this.getParentCell();\n\t        if (parentCell) {\n\t            parentCell.unembed(this, opt);\n\t        }\n\n\t        // Remove also all the cells, which were embedded into this cell\n\t        var embeddedCells = this.getEmbeddedCells();\n\t        for (var i = 0, n = embeddedCells.length; i < n; i++) {\n\t            var embed = embeddedCells[i];\n\t            if (embed) {\n\t                embed.remove(opt);\n\t            }\n\t        }\n\n\t        this.trigger('remove', this, graph.attributes.cells, opt);\n\n\t        graph.stopBatch('remove');\n\n\t        return this;\n\t    },\n\n\t    toFront: function(opt) {\n\t        var graph = this.graph;\n\t        if (graph) {\n\t            opt = opt || {};\n\n\t            var cells;\n\t            if (opt.deep) {\n\t                cells = this.getEmbeddedCells({ deep: true, breadthFirst: opt.breadthFirst !== false });\n\t                cells.unshift(this);\n\t            } else {\n\t                cells = [this];\n\t            }\n\n\t            var sortedCells = sortBy(cells, function (cell) { return cell.z(); });\n\n\t            var maxZ = graph.maxZIndex();\n\t            var z = maxZ - cells.length + 1;\n\n\t            var collection = graph.get('cells');\n\n\t            var shouldUpdate = (collection.indexOf(this) !== (collection.length - cells.length));\n\t            if (!shouldUpdate) {\n\t                shouldUpdate = sortedCells.some(function(cell, index) {\n\t                    return cell.z() !== z + index;\n\t                });\n\t            }\n\n\t            if (shouldUpdate) {\n\t                this.startBatch('to-front');\n\n\t                z = z + cells.length;\n\n\t                sortedCells.forEach(function(cell, index) {\n\t                    cell.set('z', z + index, opt);\n\t                });\n\n\t                this.stopBatch('to-front');\n\t            }\n\t        }\n\n\t        return this;\n\t    },\n\n\t    toBack: function(opt) {\n\t        var graph = this.graph;\n\t        if (graph) {\n\t            opt = opt || {};\n\n\t            var cells;\n\t            if (opt.deep) {\n\t                cells = this.getEmbeddedCells({ deep: true, breadthFirst: opt.breadthFirst !== false });\n\t                cells.unshift(this);\n\t            } else {\n\t                cells = [this];\n\t            }\n\n\t            var sortedCells = sortBy(cells, function (cell) { return cell.z(); });\n\n\t            var z = graph.minZIndex();\n\n\t            var collection = graph.get('cells');\n\n\t            var shouldUpdate = (collection.indexOf(this) !== 0);\n\t            if (!shouldUpdate) {\n\t                shouldUpdate = sortedCells.some(function(cell, index) {\n\t                    return cell.z() !== z + index;\n\t                });\n\t            }\n\n\t            if (shouldUpdate) {\n\t                this.startBatch('to-back');\n\n\t                z -= cells.length;\n\n\t                sortedCells.forEach(function(cell, index) {\n\t                    cell.set('z', z + index, opt);\n\t                });\n\n\t                this.stopBatch('to-back');\n\t            }\n\t        }\n\n\t        return this;\n\t    },\n\n\t    parent: function(parent, opt) {\n\n\t        // getter\n\t        if (parent === undefined) { return this.get('parent'); }\n\t        // setter\n\t        return this.set('parent', parent, opt);\n\t    },\n\n\t    embed: function(cell, opt) {\n\t        var this$1 = this;\n\n\t        var cells = Array.isArray(cell) ? cell : [cell];\n\t        if (!this.canEmbed(cells)) {\n\t            throw new Error('Recursive embedding not allowed.');\n\t        }\n\t        if (cells.some(function (c) { return c.isEmbedded() && this$1.id !== c.parent(); })) {\n\t            throw new Error('Embedding of already embedded cells is not allowed.');\n\t        }\n\t        this._embedCells(cells, opt);\n\t        return this;\n\t    },\n\n\t    unembed: function(cell, opt) {\n\t        var cells = Array.isArray(cell) ? cell : [cell];\n\t        this._unembedCells(cells, opt);\n\t        return this;\n\t    },\n\n\t    canEmbed: function(cell) {\n\t        var this$1 = this;\n\n\t        var cells = Array.isArray(cell) ? cell : [cell];\n\t        return cells.every(function (c) { return this$1 !== c && !this$1.isEmbeddedIn(c); });\n\t    },\n\n\t    _embedCells: function(cells, opt) {\n\t        var this$1 = this;\n\n\t        var batchName = 'embed';\n\t        this.startBatch(batchName);\n\t        var embeds = assign([], this.get('embeds'));\n\t        cells.forEach(function (cell) {\n\t            // We keep all element ids after link ids.\n\t            embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\n\t            cell.parent(this$1.id, opt);\n\t        });\n\t        this.set('embeds', uniq(embeds), opt);\n\t        this.stopBatch(batchName);\n\t    },\n\n\t    _unembedCells: function(cells, opt) {\n\t        var batchName = 'unembed';\n\t        this.startBatch(batchName);\n\t        cells.forEach(function (cell) { return cell.unset('parent', opt); });\n\t        this.set('embeds', without.apply(void 0, [ this.get('embeds') ].concat( cells.map(function (cell) { return cell.id; }) )), opt);\n\t        this.stopBatch(batchName);\n\t    },\n\n\t    getParentCell: function() {\n\n\t        // unlike link.source/target, cell.parent stores id directly as a string\n\t        var parentId = this.parent();\n\t        var graph = this.graph;\n\n\t        return (parentId && graph && graph.getCell(parentId)) || null;\n\t    },\n\n\t    // Return an array of ancestor cells.\n\t    // The array is ordered from the parent of the cell\n\t    // to the most distant ancestor.\n\t    getAncestors: function() {\n\n\t        var ancestors = [];\n\n\t        if (!this.graph) {\n\t            return ancestors;\n\t        }\n\n\t        var parentCell = this.getParentCell();\n\t        while (parentCell) {\n\t            ancestors.push(parentCell);\n\t            parentCell = parentCell.getParentCell();\n\t        }\n\n\t        return ancestors;\n\t    },\n\n\t    getEmbeddedCells: function(opt) {\n\n\t        opt = opt || {};\n\n\t        // Cell models can only be retrieved when this element is part of a collection.\n\t        // There is no way this element knows about other cells otherwise.\n\t        // This also means that calling e.g. `translate()` on an element with embeds before\n\t        // adding it to a graph does not translate its embeds.\n\t        if (this.graph) {\n\n\t            var cells;\n\n\t            if (opt.deep) {\n\n\t                if (opt.breadthFirst) {\n\n\t                    // breadthFirst algorithm\n\t                    cells = [];\n\t                    var queue = this.getEmbeddedCells();\n\n\t                    while (queue.length > 0) {\n\n\t                        var parent = queue.shift();\n\t                        cells.push(parent);\n\t                        queue.push.apply(queue, parent.getEmbeddedCells());\n\t                    }\n\n\t                } else {\n\n\t                    // depthFirst algorithm\n\t                    cells = this.getEmbeddedCells();\n\t                    cells.forEach(function(cell) {\n\t                        cells.push.apply(cells, cell.getEmbeddedCells(opt));\n\t                    });\n\t                }\n\n\t            } else {\n\n\t                cells = toArray(this.get('embeds')).map(this.graph.getCell, this.graph);\n\t            }\n\n\t            return cells;\n\t        }\n\t        return [];\n\t    },\n\n\t    isEmbeddedIn: function(cell, opt) {\n\n\t        var cellId = isString(cell) ? cell : cell.id;\n\t        var parentId = this.parent();\n\n\t        opt = assign({ deep: true }, opt);\n\n\t        // See getEmbeddedCells().\n\t        if (this.graph && opt.deep) {\n\n\t            while (parentId) {\n\t                if (parentId === cellId) {\n\t                    return true;\n\t                }\n\t                parentId = this.graph.getCell(parentId).parent();\n\t            }\n\n\t            return false;\n\n\t        } else {\n\n\t            // When this cell is not part of a collection check\n\t            // at least whether it's a direct child of given cell.\n\t            return parentId === cellId;\n\t        }\n\t    },\n\n\t    // Whether or not the cell is embedded in any other cell.\n\t    isEmbedded: function() {\n\n\t        return !!this.parent();\n\t    },\n\n\t    // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n\t    // Shallow cloning simply clones the cell and returns a new cell with different ID.\n\t    // Deep cloning clones the cell and all its embedded cells recursively.\n\t    clone: function(opt) {\n\n\t        opt = opt || {};\n\n\t        if (!opt.deep) {\n\t            // Shallow cloning.\n\n\t            var clone = Backbone.Model.prototype.clone.apply(this, arguments);\n\t            // We don't want the clone to have the same ID as the original.\n\t            clone.set(this.getIdAttribute(), this.generateId());\n\t            // A shallow cloned element does not carry over the original embeds.\n\t            clone.unset('embeds');\n\t            // And can not be embedded in any cell\n\t            // as the clone is not part of the graph.\n\t            clone.unset('parent');\n\n\t            return clone;\n\n\t        } else {\n\t            // Deep cloning.\n\n\t            // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\n\t            return toArray(cloneCells([this].concat(this.getEmbeddedCells({ deep: true }))));\n\t        }\n\t    },\n\n\t    // A convenient way to set nested properties.\n\t    // This method merges the properties you'd like to set with the ones\n\t    // stored in the cell and makes sure change events are properly triggered.\n\t    // You can either set a nested property with one object\n\t    // or use a property path.\n\t    // The most simple use case is:\n\t    // `cell.prop('name/first', 'John')` or\n\t    // `cell.prop({ name: { first: 'John' } })`.\n\t    // Nested arrays are supported too:\n\t    // `cell.prop('series/0/data/0/degree', 50)` or\n\t    // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n\t    prop: function(props, value, opt) {\n\n\t        var delim = '/';\n\t        var _isString = isString(props);\n\n\t        if (_isString || Array.isArray(props)) {\n\t            // Get/set an attribute by a special path syntax that delimits\n\t            // nested objects by the colon character.\n\n\t            if (arguments.length > 1) {\n\n\t                var path;\n\t                var pathArray;\n\n\t                if (_isString) {\n\t                    path = props;\n\t                    pathArray = path.split('/');\n\t                } else {\n\t                    path = props.join(delim);\n\t                    pathArray = props.slice();\n\t                }\n\n\t                var property = pathArray[0];\n\t                var pathArrayLength = pathArray.length;\n\n\t                var options$1 = opt || {};\n\t                options$1.propertyPath = path;\n\t                options$1.propertyValue = value;\n\t                options$1.propertyPathArray = pathArray;\n\t                if (!('rewrite' in options$1)) {\n\t                    options$1.rewrite = false;\n\t                }\n\n\t                var update = {};\n\t                // Initialize the nested object. Sub-objects are either arrays or objects.\n\t                // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n\t                // Note that this imposes a limitation on object keys one can use with Inspector.\n\t                // Pure integer keys will cause issues and are therefore not allowed.\n\t                var initializer = update;\n\t                var prevProperty = property;\n\n\t                for (var i = 1; i < pathArrayLength; i++) {\n\t                    var pathItem = pathArray[i];\n\t                    var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n\t                    initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n\t                    prevProperty = pathItem;\n\t                }\n\n\t                // Fill update with the `value` on `path`.\n\t                update = setByPath(update, pathArray, value, '/');\n\n\t                var baseAttributes = merge({}, this.attributes);\n\t                // if rewrite mode enabled, we replace value referenced by path with\n\t                // the new one (we don't merge).\n\t                options$1.rewrite && unsetByPath(baseAttributes, path, '/');\n\n\t                // Merge update with the model attributes.\n\t                var attributes = merge(baseAttributes, update);\n\t                // Finally, set the property to the updated attributes.\n\t                return this.set(property, attributes[property], options$1);\n\n\t            } else {\n\n\t                return getByPath(this.attributes, props, delim);\n\t            }\n\t        }\n\n\t        var options = value || {};\n\t        // Note: '' is not the path to the root. It's a path with an empty string i.e. { '': {}}.\n\t        options.propertyPath = null;\n\t        options.propertyValue = props;\n\t        options.propertyPathArray = [];\n\t        if (!('rewrite' in options)) {\n\t            options.rewrite = false;\n\t        }\n\n\t        return this.set(merge({}, this.attributes, props), options);\n\t    },\n\n\t    // A convenient way to unset nested properties\n\t    removeProp: function(path, opt) {\n\n\t        opt = opt || {};\n\n\t        var pathArray = Array.isArray(path) ? path : path.split('/');\n\n\t        // Once a property is removed from the `attrs` attribute\n\t        // the cellView will recognize a `dirty` flag and re-render itself\n\t        // in order to remove the attribute from SVG element.\n\t        var property = pathArray[0];\n\t        if (property === 'attrs') { opt.dirty = true; }\n\n\t        if (pathArray.length === 1) {\n\t            // A top level property\n\t            return this.unset(path, opt);\n\t        }\n\n\t        // A nested property\n\t        var nestedPath = pathArray.slice(1);\n\t        var propertyValue = this.get(property);\n\t        if (propertyValue === undefined || propertyValue === null) { return this; }\n\t        propertyValue = cloneDeep(propertyValue);\n\n\t        unsetByPath(propertyValue, nestedPath, '/');\n\n\t        return this.set(property, propertyValue, opt);\n\t    },\n\n\t    // A convenient way to set nested attributes.\n\t    attr: function(attrs, value, opt) {\n\n\t        var args = Array.from(arguments);\n\t        if (args.length === 0) {\n\t            return this.get('attrs');\n\t        }\n\n\t        if (Array.isArray(attrs)) {\n\t            args[0] = ['attrs'].concat(attrs);\n\t        } else if (isString(attrs)) {\n\t            // Get/set an attribute by a special path syntax that delimits\n\t            // nested objects by the colon character.\n\t            args[0] = 'attrs/' + attrs;\n\n\t        } else {\n\n\t            args[0] = { 'attrs' : attrs };\n\t        }\n\n\t        return this.prop.apply(this, args);\n\t    },\n\n\t    // A convenient way to unset nested attributes\n\t    removeAttr: function(path, opt) {\n\n\t        if (Array.isArray(path)) {\n\n\t            return this.removeProp(['attrs'].concat(path));\n\t        }\n\n\t        return this.removeProp('attrs/' + path, opt);\n\t    },\n\n\t    transition: function(path, value, opt, delim) {\n\t        var this$1 = this;\n\n\n\t        delim = delim || '/';\n\n\t        var defaults = {\n\t            duration: 100,\n\t            delay: 10,\n\t            timingFunction: timing.linear,\n\t            valueFunction: interpolate.number\n\t        };\n\n\t        opt = assign(defaults, opt);\n\n\t        var firstFrameTime = 0;\n\t        var interpolatingFunction;\n\n\t        var setter = function(runtime) {\n\n\t            var id, progress, propertyValue;\n\n\t            firstFrameTime = firstFrameTime || runtime;\n\t            runtime -= firstFrameTime;\n\t            progress = runtime / opt.duration;\n\n\t            if (progress < 1) {\n\t                this._transitionIds[path] = id = nextFrame(setter);\n\t            } else {\n\t                progress = 1;\n\t                delete this._transitionIds[path];\n\t            }\n\n\t            propertyValue = interpolatingFunction(opt.timingFunction(progress));\n\n\t            opt.transitionId = id;\n\n\t            this.prop(path, propertyValue, opt);\n\n\t            if (!id) { this.trigger('transition:end', this, path); }\n\n\t        }.bind(this);\n\n\t        var ref = this;\n\t        var _scheduledTransitionIds = ref._scheduledTransitionIds;\n\t        var initialId;\n\n\t        var initiator = function (callback) {\n\n\t            if (_scheduledTransitionIds[path]) {\n\t                _scheduledTransitionIds[path] = without(_scheduledTransitionIds[path], initialId);\n\t                if (_scheduledTransitionIds[path].length === 0) {\n\t                    delete _scheduledTransitionIds[path];\n\t                }\n\t            }\n\n\t            this$1.stopPendingTransitions(path, delim);\n\n\t            interpolatingFunction = opt.valueFunction(getByPath(this$1.attributes, path, delim), value);\n\n\t            this$1._transitionIds[path] = nextFrame(callback);\n\n\t            this$1.trigger('transition:start', this$1, path);\n\n\t        };\n\n\t        initialId = setTimeout(initiator, opt.delay, setter);\n\n\t        _scheduledTransitionIds[path] || (_scheduledTransitionIds[path] = []);\n\t        _scheduledTransitionIds[path].push(initialId);\n\n\t        return initialId;\n\t    },\n\n\t    getTransitions: function() {\n\t        return union(\n\t            Object.keys(this._transitionIds),\n\t            Object.keys(this._scheduledTransitionIds)\n\t        );\n\t    },\n\n\t    stopScheduledTransitions: function(path, delim) {\n\t        if ( delim === void 0 ) delim = '/';\n\n\t        var ref = this;\n\t        var _scheduledTransitionIds = ref._scheduledTransitionIds; if ( _scheduledTransitionIds === void 0 ) _scheduledTransitionIds = {};\n\t        var transitions = Object.keys(_scheduledTransitionIds);\n\t        if (path) {\n\t            var pathArray = path.split(delim);\n\t            transitions = transitions.filter(function (key) {\n\t                return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n\t            });\n\t        }\n\t        transitions.forEach(function (key) {\n\t            var transitionIds = _scheduledTransitionIds[key];\n\t            // stop the initiator\n\t            transitionIds.forEach(function (transitionId) { return clearTimeout(transitionId); });\n\t            delete _scheduledTransitionIds[key];\n\t            // Note: we could trigger transition:cancel` event here\n\t        });\n\t        return this;\n\t    },\n\n\t    stopPendingTransitions: function stopPendingTransitions(path, delim) {\n\t        var this$1 = this;\n\t        if ( delim === void 0 ) delim = '/';\n\n\t        var ref = this;\n\t        var _transitionIds = ref._transitionIds; if ( _transitionIds === void 0 ) _transitionIds = {};\n\t        var transitions = Object.keys(_transitionIds);\n\t        if (path) {\n\t            var pathArray = path.split(delim);\n\t            transitions = transitions.filter(function (key) {\n\t                return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n\t            });\n\t        }\n\t        transitions.forEach(function (key) {\n\t            var transitionId = _transitionIds[key];\n\t            // stop the setter\n\t            cancelFrame(transitionId);\n\t            delete _transitionIds[key];\n\t            this$1.trigger('transition:end', this$1, key);\n\t        });\n\t    },\n\n\t    stopTransitions: function(path, delim) {\n\t        if ( delim === void 0 ) delim = '/';\n\n\t        this.stopScheduledTransitions(path, delim);\n\t        this.stopPendingTransitions(path, delim);\n\t        return this;\n\t    },\n\n\t    // A shorcut making it easy to create constructs like the following:\n\t    // `var el = (new joint.shapes.basic.Rect).addTo(graph)`.\n\t    addTo: function(graph, opt) {\n\n\t        graph.addCell(this, opt);\n\t        return this;\n\t    },\n\n\t    // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n\t    // making it easy to create constructs like the following:\n\t    // `cell.findView(paper).highlight()`\n\t    findView: function(paper) {\n\n\t        return paper.findViewByModel(this);\n\t    },\n\n\t    isElement: function() {\n\n\t        return false;\n\t    },\n\n\t    isLink: function() {\n\n\t        return false;\n\t    },\n\n\t    startBatch: function(name, opt) {\n\n\t        if (this.graph) { this.graph.startBatch(name, assign({}, opt, { cell: this })); }\n\t        return this;\n\t    },\n\n\t    stopBatch: function(name, opt) {\n\n\t        if (this.graph) { this.graph.stopBatch(name, assign({}, opt, { cell: this })); }\n\t        return this;\n\t    },\n\n\t    getChangeFlag: function(attributes) {\n\n\t        var flag = 0;\n\t        if (!attributes) { return flag; }\n\t        for (var key in attributes) {\n\t            if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) { continue; }\n\t            flag |= attributes[key];\n\t        }\n\t        return flag;\n\t    },\n\n\t    angle: function() {\n\n\t        // To be overridden.\n\t        return 0;\n\t    },\n\n\t    position: function() {\n\n\t        // To be overridden.\n\t        return new Point(0, 0);\n\t    },\n\n\t    z: function() {\n\t        return this.get('z') || 0;\n\t    },\n\n\t    getPointFromConnectedLink: function() {\n\n\t        // To be overridden\n\t        return new Point();\n\t    },\n\n\t    getBBox: function() {\n\n\t        // To be overridden\n\t        return new Rect(0, 0, 0, 0);\n\t    },\n\n\t    getPointRotatedAroundCenter: function getPointRotatedAroundCenter(angle, x, y) {\n\t        var point = new Point(x, y);\n\t        if (angle) { point.rotate(this.getBBox().center(), angle); }\n\t        return point;\n\t    },\n\n\t    getAbsolutePointFromRelative: function getAbsolutePointFromRelative(x, y) {\n\t        // Rotate the position to take the model angle into account\n\t        return this.getPointRotatedAroundCenter(\n\t            -this.angle(),\n\t            // Transform the relative position to absolute\n\t            this.position().offset(x, y)\n\t        );\n\t    },\n\n\t    getRelativePointFromAbsolute: function getRelativePointFromAbsolute(x, y) {\n\t        return this\n\t            // Rotate the coordinates to mitigate the element's rotation.\n\t            .getPointRotatedAroundCenter(this.angle(), x, y)\n\t            // Transform the absolute position into relative\n\t            .difference(this.position());\n\t    }\n\n\t}, {\n\n\t    getAttributeDefinition: function(attrName) {\n\n\t        var defNS = this.attributes;\n\t        var globalDefNS = attributes;\n\t        return (defNS && defNS[attrName]) || globalDefNS[attrName];\n\t    },\n\n\t    define: function(type, defaults, protoProps, staticProps) {\n\n\t        protoProps = assign({\n\t            defaults: defaultsDeep({ type: type }, defaults, this.prototype.defaults)\n\t        }, protoProps);\n\n\t        var Cell = this.extend(protoProps, staticProps);\n\t        // es5 backward compatibility\n\t        /* eslint-disable no-undef */\n\t        if (typeof joint !== 'undefined' && has$2(joint, 'shapes')) {\n\t            setByPath(joint.shapes, type, Cell, '.');\n\t        }\n\t        /* eslint-enable no-undef */\n\t        return Cell;\n\t    }\n\t});\n\n\tvar wrapWith = function(object, methods, wrapper) {\n\n\t    if (isString(wrapper)) {\n\n\t        if (!wrappers[wrapper]) {\n\t            throw new Error('Unknown wrapper: \"' + wrapper + '\"');\n\t        }\n\n\t        wrapper = wrappers[wrapper];\n\t    }\n\n\t    if (!isFunction(wrapper)) {\n\t        throw new Error('Wrapper must be a function.');\n\t    }\n\n\t    toArray(methods).forEach(function(method) {\n\t        object[method] = wrapper(object[method]);\n\t    });\n\t};\n\n\tvar wrappers = {\n\n\t    cells: function(fn) {\n\n\t        return function() {\n\n\t            var args = Array.from(arguments);\n\t            var n = args.length;\n\t            var cells = n > 0 && args[0] || [];\n\t            var opt = n > 1 && args[n - 1] || {};\n\n\t            if (!Array.isArray(cells)) {\n\n\t                if (opt instanceof Cell) {\n\t                    cells = args;\n\t                } else if (cells instanceof Cell) {\n\t                    if (args.length > 1) {\n\t                        args.pop();\n\t                    }\n\t                    cells = args;\n\t                }\n\t            }\n\n\t            if (opt instanceof Cell) {\n\t                opt = {};\n\t            }\n\n\t            return fn.call(this, cells, opt);\n\t        };\n\t    }\n\n\t};\n\n\tfunction svg(strings) {\n\t    var expressions = [], len = arguments.length - 1;\n\t    while ( len-- > 0 ) expressions[ len ] = arguments[ len + 1 ];\n\n\t    var svgParts = [];\n\t    strings.forEach(function (part, index) {\n\t        svgParts.push(part);\n\t        if (index in expressions) {\n\t            svgParts.push(expressions[index]);\n\t        }\n\t    });\n\t    var markup = parseFromSVGString(svgParts.join(''));\n\t    return markup;\n\t}\n\n\tfunction parseFromSVGString(str) {\n\t    var parser = new DOMParser();\n\t    var markupString = \"<svg>\" + (str.trim()) + \"</svg>\";\n\t    var xmldocument = parser.parseFromString(markupString.replace(/@/g, ''), 'application/xml');\n\t    if (xmldocument.getElementsByTagName('parsererror')[0]) {\n\t        throw new Error('Invalid SVG markup');\n\t    }\n\t    var document = parser.parseFromString(markupString, 'text/html');\n\t    var svg = document.querySelector('svg');\n\t    return build(svg);\n\t}\n\n\tfunction buildNode(node) {\n\t    var markupNode = {};\n\t    var tagName = node.tagName;\n\t    var attributes = node.attributes;\n\t    var namespaceURI = node.namespaceURI;\n\t    var style = node.style;\n\t    var childNodes = node.childNodes;\n\n\t    markupNode.namespaceURI = namespaceURI;\n\t    markupNode.tagName = (namespaceURI === V.namespace.xhtml)\n\t        // XHTML documents must use lower case for all HTML element and attribute names.\n\t        // The tagName property returns upper case value for HTML elements.\n\t        // e.g. <DIV> vs.<div/>\n\t        ? tagName.toLowerCase()\n\t        : tagName;\n\n\t    var stylesObject = {};\n\t    for (var i = style.length; i--;) {\n\t        var nameString = style[i];\n\t        stylesObject[nameString] = style.getPropertyValue(nameString);\n\t    }\n\t    markupNode.style = stylesObject;\n\n\t    // selector fallbacks to tagName\n\t    var selectorAttribute = attributes.getNamedItem('@selector');\n\t    if (selectorAttribute) {\n\t        markupNode.selector = selectorAttribute.value;\n\t        attributes.removeNamedItem('@selector');\n\t    }\n\n\t    var groupSelectorAttribute = attributes.getNamedItem('@group-selector');\n\t    if (groupSelectorAttribute) {\n\t        var groupSelectors = groupSelectorAttribute.value.split(',');\n\t        markupNode.groupSelector = groupSelectors.map(function (s) { return s.trim(); });\n\n\t        attributes.removeNamedItem('@group-selector');\n\t    }\n\n\t    var className = attributes.getNamedItem('class');\n\t    if (className) {\n\t        markupNode.className = className.value;\n\t    }\n\n\t    var children = [];\n\t    childNodes.forEach(function (node) {\n\t        switch (node.nodeType) {\n\t            case Node.TEXT_NODE: {\n\t                var trimmedText = node.data.replace(/\\s\\s+/g, ' ');\n\t                if (trimmedText.trim()) {\n\t                    children.push(trimmedText);\n\t                }\n\t                break;\n\t            }\n\t            case Node.ELEMENT_NODE: {\n\t                children.push(buildNode(node));\n\t                break;\n\t            }\n\t            default:\n\t                break;\n\t        }\n\t    });\n\t    if (children.length) {\n\t        markupNode.children = children;\n\t    }\n\n\t    var nodeAttrs = {};\n\n\t    Array.from(attributes).forEach(function (nodeAttribute) {\n\t        var name = nodeAttribute.name;\n\t        var value = nodeAttribute.value;\n\t        nodeAttrs[name] = value;\n\t    });\n\n\t    if (Object.keys(nodeAttrs).length > 0) {\n\t        markupNode.attributes = nodeAttrs;\n\t    }\n\n\t    return markupNode;\n\t}\n\n\tfunction build(root) {\n\t    var markup = [];\n\n\t    Array.from(root.children).forEach(function (node) {\n\t        markup.push(buildNode(node));\n\t    });\n\n\t    return markup;\n\t}\n\n\tvar Positions = {\n\t    TOP: 'top',\n\t    RIGHT: 'right',\n\t    BOTTOM: 'bottom',\n\t    LEFT: 'left',\n\t    TOP_LEFT: 'top-left',\n\t    TOP_RIGHT: 'top-right',\n\t    BOTTOM_LEFT: 'bottom-left',\n\t    BOTTOM_RIGHT: 'bottom-right',\n\t    CENTER: 'center',\n\t};\n\n\tfunction getRectPoint(rect, position) {\n\t    var r = new Rect(rect);\n\t    switch (position) {\n\t        case undefined:\n\t            throw new Error('Position required');\n\n\t        // Middle Points\n\t        case Positions.LEFT:\n\t        case 'leftMiddle':\n\t            return r.leftMiddle();\n\n\t        case Positions.RIGHT:\n\t        case 'rightMiddle':\n\t            return r.rightMiddle();\n\n\t        case Positions.TOP:\n\t        case 'topMiddle':\n\t            return r.topMiddle();\n\n\t        case Positions.BOTTOM:\n\t        case 'bottomMiddle':\n\t            return r.bottomMiddle();\n\n\t        // Corners\n\t        case Positions.TOP_LEFT:\n\t        case 'topLeft':\n\t        case 'origin':\n\t            return r.topLeft();\n\n\t        case Positions.TOP_RIGHT:\n\t        case 'topRight':\n\t            return r.topRight();\n\n\t        case Positions.BOTTOM_LEFT:\n\t        case 'bottomLeft':\n\t            return r.bottomLeft();\n\n\t        case Positions.BOTTOM_RIGHT:\n\t        case 'bottomRight':\n\t        case 'corner':\n\t            return r.bottomRight();\n\n\t        // Center\n\t        case Positions.CENTER:\n\t            return r.center();\n\n\t        // TODO: calc(), percentage etc.\n\t        default:\n\t            throw new Error((\"Unknown position: \" + position));\n\t    }\n\t}\n\n\n\n\tvar index = ({\n\t\tgetRectPoint: getRectPoint,\n\t\twrapWith: wrapWith,\n\t\twrappers: wrappers,\n\t\taddClassNamePrefix: addClassNamePrefix,\n\t\tremoveClassNamePrefix: removeClassNamePrefix,\n\t\tparseDOMJSON: parseDOMJSON,\n\t\thashCode: hashCode,\n\t\tgetByPath: getByPath,\n\t\tsetByPath: setByPath,\n\t\tunsetByPath: unsetByPath,\n\t\tflattenObject: flattenObject,\n\t\tuuid: uuid,\n\t\tguid: guid,\n\t\ttoKebabCase: toKebabCase,\n\t\tnormalizeEvent: normalizeEvent,\n\t\tnormalizeWheel: normalizeWheel,\n\t\tcap: cap,\n\t\tnextFrame: nextFrame,\n\t\tcancelFrame: cancelFrame,\n\t\tshapePerimeterConnectionPoint: shapePerimeterConnectionPoint,\n\t\tisPercentage: isPercentage,\n\t\tparseCssNumeric: parseCssNumeric,\n\t\tbreakText: breakText,\n\t\tsanitizeHTML: sanitizeHTML,\n\t\tdownloadBlob: downloadBlob,\n\t\tdownloadDataUri: downloadDataUri,\n\t\tdataUriToBlob: dataUriToBlob,\n\t\timageToDataUri: imageToDataUri,\n\t\tgetElementBBox: getElementBBox,\n\t\tsortElements: sortElements,\n\t\tsetAttributesBySelector: setAttributesBySelector,\n\t\tnormalizeSides: normalizeSides,\n\t\ttiming: timing,\n\t\tinterpolate: interpolate,\n\t\tfilter: filter,\n\t\tformat: format,\n\t\ttemplate: template,\n\t\ttoggleFullScreen: toggleFullScreen,\n\t\tisBoolean: isBoolean,\n\t\tisObject: isObject$1,\n\t\tisNumber: isNumber,\n\t\tisString: isString,\n\t\tmixin: mixin,\n\t\tdeepMixin: deepMixin,\n\t\tsupplement: supplement,\n\t\tdefaults: defaults,\n\t\tdeepSupplement: deepSupplement,\n\t\tdefaultsDeep: defaultsDeep,\n\t\tassign: assign,\n\t\tinvoke: invoke,\n\t\tinvokeProperty: invokeProperty,\n\t\tsortedIndex: sortedIndex,\n\t\tuniq: uniq,\n\t\tclone: clone,\n\t\tcloneDeep: cloneDeep,\n\t\tisEmpty: isEmpty,\n\t\tisEqual: isEqual,\n\t\tisFunction: isFunction,\n\t\tisPlainObject: isPlainObject,\n\t\ttoArray: toArray,\n\t\tdebounce: debounce,\n\t\tgroupBy: groupBy,\n\t\tsortBy: sortBy,\n\t\tflattenDeep: flattenDeep,\n\t\twithout: without,\n\t\tdifference: difference,\n\t\tintersection: intersection$1,\n\t\tunion: union,\n\t\thas: has$2,\n\t\tresult: result,\n\t\tomit: omit,\n\t\tpick: pick,\n\t\tbindAll: bindAll,\n\t\tforIn: forIn,\n\t\tcamelCase: camelCase,\n\t\tuniqueId: uniqueId,\n\t\tmerge: merge,\n\t\tnoop: noop,\n\t\tcloneCells: cloneCells,\n\t\tsvg: svg\n\t});\n\n\tfunction portTransformAttrs(point, angle, opt) {\n\n\t    var trans = point.toJSON();\n\n\t    trans.angle = angle || 0;\n\n\t    return defaults({}, opt, trans);\n\t}\n\n\tfunction lineLayout(ports, p1, p2, elBBox) {\n\t    return ports.map(function(port, index, ports) {\n\t        var p = this.pointAt(((index + 0.5) / ports.length));\n\t        // `dx`,`dy` per port offset option\n\t        if (port.dx || port.dy) {\n\t            p.offset(port.dx || 0, port.dy || 0);\n\t        }\n\t        return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));\n\t    }, line(p1, p2));\n\t}\n\n\tfunction ellipseLayout(ports, elBBox, startAngle, stepFn) {\n\n\t    var center = elBBox.center();\n\t    var ratio = elBBox.width / elBBox.height;\n\t    var p1 = elBBox.topMiddle();\n\n\t    var ellipse = Ellipse.fromRect(elBBox);\n\n\t    return ports.map(function(port, index, ports) {\n\n\t        var angle = startAngle + stepFn(index, ports.length);\n\t        var p2 = p1.clone()\n\t            .rotate(center, -angle)\n\t            .scale(ratio, 1, center);\n\n\t        var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;\n\n\t        // `dx`,`dy` per port offset option\n\t        if (port.dx || port.dy) {\n\t            p2.offset(port.dx || 0, port.dy || 0);\n\t        }\n\n\t        // `dr` delta radius option\n\t        if (port.dr) {\n\t            p2.move(center, port.dr);\n\t        }\n\n\t        return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));\n\t    });\n\t}\n\n\n\tfunction argTransform(bbox, args) {\n\t    var x = args.x;\n\t    var y = args.y;\n\t    var angle = args.angle;\n\t    if (isPercentage(x)) {\n\t        x = parseFloat(x) / 100 * bbox.width;\n\t    } else if (isCalcAttribute(x)) {\n\t        x = Number(evalCalcAttribute(x, bbox));\n\t    }\n\t    if (isPercentage(y)) {\n\t        y = parseFloat(y) / 100 * bbox.height;\n\t    } else if (isCalcAttribute(y)) {\n\t        y = Number(evalCalcAttribute(y, bbox));\n\t    }\n\t    return { x: x, y: y, angle: angle };\n\t}\n\n\t// Creates a point stored in arguments\n\tfunction argPoint(bbox, args) {\n\t    var ref = argTransform(bbox, args);\n\t    var x = ref.x;\n\t    var y = ref.y;\n\t    return new Point(x || 0, y || 0);\n\t}\n\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar absolute = function(ports, elBBox) {\n\t    return ports.map(function (port) {\n\t        var transformation = argPoint(elBBox, port).round().toJSON();\n\t        transformation.angle = port.angle || 0;\n\t        return transformation;\n\t    });\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar fn = function(ports, elBBox, opt) {\n\t    return opt.fn(ports, elBBox, opt);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar line$1 = function(ports, elBBox, opt) {\n\n\t    var start = argPoint(elBBox, opt.start || elBBox.origin());\n\t    var end = argPoint(elBBox, opt.end || elBBox.corner());\n\n\t    return lineLayout(ports, start, end, elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar left = function(ports, elBBox, opt) {\n\t    return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar right = function(ports, elBBox, opt) {\n\t    return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar top = function(ports, elBBox, opt) {\n\t    return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar bottom = function(ports, elBBox, opt) {\n\t    return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar ellipseSpread = function(ports, elBBox, opt) {\n\n\t    var startAngle = opt.startAngle || 0;\n\t    var stepAngle = opt.step || 360 / ports.length;\n\n\t    return ellipseLayout(ports, elBBox, startAngle, function(index) {\n\t        return index * stepAngle;\n\t    });\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar ellipse$1 = function(ports, elBBox, opt) {\n\n\t    var startAngle = opt.startAngle || 0;\n\t    var stepAngle = opt.step || 20;\n\n\t    return ellipseLayout(ports, elBBox, startAngle, function(index, count) {\n\t        return (index + 0.5 - count / 2) * stepAngle;\n\t    });\n\t};\n\n\tvar Port = ({\n\t\tabsolute: absolute,\n\t\tfn: fn,\n\t\tline: line$1,\n\t\tleft: left,\n\t\tright: right,\n\t\ttop: top,\n\t\tbottom: bottom,\n\t\tellipseSpread: ellipseSpread,\n\t\tellipse: ellipse$1\n\t});\n\n\tfunction labelAttributes(opt1, opt2) {\n\n\t    return defaultsDeep({}, opt1, opt2, {\n\t        x: 0,\n\t        y: 0,\n\t        angle: 0,\n\t        attrs: {}\n\t    });\n\t}\n\n\tfunction outsideLayout(portPosition, elBBox, autoOrient, opt) {\n\n\t    opt = defaults({}, opt, { offset: 15 });\n\t    var angle = elBBox.center().theta(portPosition);\n\t    var x = getBBoxAngles(elBBox);\n\n\t    var tx, ty, y, textAnchor;\n\t    var offset = opt.offset;\n\t    var orientAngle = 0;\n\n\t    if (angle < x[1] || angle > x[2]) {\n\t        y = '.3em';\n\t        tx = offset;\n\t        ty = 0;\n\t        textAnchor = 'start';\n\t    } else if (angle < x[0]) {\n\t        tx = 0;\n\t        ty = -offset;\n\t        if (autoOrient) {\n\t            orientAngle = -90;\n\t            textAnchor = 'start';\n\t            y = '.3em';\n\t        } else {\n\t            textAnchor = 'middle';\n\t            y = '0';\n\t        }\n\t    } else if (angle < x[3]) {\n\t        y = '.3em';\n\t        tx = -offset;\n\t        ty = 0;\n\t        textAnchor = 'end';\n\t    } else {\n\t        tx = 0;\n\t        ty = offset;\n\t        if (autoOrient) {\n\t            orientAngle = 90;\n\t            textAnchor = 'start';\n\t            y = '.3em';\n\t        } else {\n\t            textAnchor = 'middle';\n\t            y = '.6em';\n\t        }\n\t    }\n\n\t    var round = Math.round;\n\t    return labelAttributes({\n\t        x: round(tx),\n\t        y: round(ty),\n\t        angle: orientAngle,\n\t        attrs: { labelText: { y: y, textAnchor: textAnchor }}\n\t    });\n\t}\n\n\tfunction getBBoxAngles(elBBox) {\n\n\t    var center = elBBox.center();\n\n\t    var tl = center.theta(elBBox.origin());\n\t    var bl = center.theta(elBBox.bottomLeft());\n\t    var br = center.theta(elBBox.corner());\n\t    var tr = center.theta(elBBox.topRight());\n\n\t    return [tl, tr, br, bl];\n\t}\n\n\tfunction insideLayout(portPosition, elBBox, autoOrient, opt) {\n\n\t    var angle = elBBox.center().theta(portPosition);\n\t    opt = defaults({}, opt, { offset: 15 });\n\n\t    var tx, ty, y, textAnchor;\n\t    var offset = opt.offset;\n\t    var orientAngle = 0;\n\n\t    var bBoxAngles = getBBoxAngles(elBBox);\n\n\t    if (angle < bBoxAngles[1] || angle > bBoxAngles[2]) {\n\t        y = '.3em';\n\t        tx = -offset;\n\t        ty = 0;\n\t        textAnchor = 'end';\n\t    } else if (angle < bBoxAngles[0]) {\n\t        tx = 0;\n\t        ty = offset;\n\t        if (autoOrient) {\n\t            orientAngle = 90;\n\t            textAnchor = 'start';\n\t            y = '.3em';\n\t        } else {\n\t            textAnchor = 'middle';\n\t            y = '.6em';\n\t        }\n\t    } else if (angle < bBoxAngles[3]) {\n\t        y = '.3em';\n\t        tx = offset;\n\t        ty = 0;\n\t        textAnchor = 'start';\n\t    } else {\n\t        tx = 0;\n\t        ty = -offset;\n\t        if (autoOrient) {\n\t            orientAngle = -90;\n\t            textAnchor = 'start';\n\t            y = '.3em';\n\t        } else {\n\t            textAnchor = 'middle';\n\t            y = '0';\n\t        }\n\t    }\n\n\t    var round = Math.round;\n\t    return labelAttributes({\n\t        x: round(tx),\n\t        y: round(ty),\n\t        angle: orientAngle,\n\t        attrs: { labelText: { y: y, textAnchor: textAnchor }}\n\t    });\n\t}\n\n\tfunction radialLayout(portCenterOffset, autoOrient, opt) {\n\n\t    opt = defaults({}, opt, { offset: 20 });\n\n\t    var origin = point(0, 0);\n\t    var angle = -portCenterOffset.theta(origin);\n\t    var orientAngle = angle;\n\t    var offset = portCenterOffset.clone()\n\t        .move(origin, opt.offset)\n\t        .difference(portCenterOffset)\n\t        .round();\n\n\t    var y = '.3em';\n\t    var textAnchor;\n\n\t    if ((angle + 90) % 180 === 0) {\n\t        textAnchor = autoOrient ? 'end' : 'middle';\n\t        if (!autoOrient && angle === -270) {\n\t            y = '0em';\n\t        }\n\t    } else if (angle > -270 && angle < -90) {\n\t        textAnchor = 'start';\n\t        orientAngle = angle - 180;\n\t    } else {\n\t        textAnchor = 'end';\n\t    }\n\n\t    var round = Math.round;\n\t    return labelAttributes({\n\t        x: round(offset.x),\n\t        y: round(offset.y),\n\t        angle: autoOrient ? orientAngle : 0,\n\t        attrs: {\n\t            labelText: {\n\t                y: y,\n\t                textAnchor: textAnchor\n\t            }\n\t        }\n\t    });\n\t}\n\n\tvar manual = function(_portPosition, _elBBox, opt) {\n\t    return labelAttributes(opt);\n\t};\n\n\tvar left$1 = function(portPosition, elBBox, opt) {\n\t    return labelAttributes(opt, {\n\t        x: -15,\n\t        attrs: { labelText: { y: '.3em', textAnchor: 'end' }},\n\t    });\n\t};\n\n\tvar right$1 = function(portPosition, elBBox, opt) {\n\t    return labelAttributes(opt, {\n\t        x: 15,\n\t        attrs: { labelText: { y: '.3em', textAnchor: 'start' }},\n\t    });\n\t};\n\n\tvar top$1 = function(portPosition, elBBox, opt) {\n\t    return labelAttributes(opt, {\n\t        y: -15,\n\t        attrs: { labelText: { y: '0', textAnchor: 'middle' }},\n\t    });\n\t};\n\n\tvar bottom$1 = function(portPosition, elBBox, opt) {\n\t    return labelAttributes(opt, {\n\t        y: 15,\n\t        attrs: { labelText: { y: '.6em', textAnchor: 'middle' }},\n\t    });\n\t};\n\n\tvar outsideOriented = function(portPosition, elBBox, opt) {\n\t    return outsideLayout(portPosition, elBBox, true, opt);\n\t};\n\n\tvar outside = function(portPosition, elBBox, opt) {\n\t    return outsideLayout(portPosition, elBBox, false, opt);\n\t};\n\n\tvar insideOriented = function(portPosition, elBBox, opt) {\n\t    return insideLayout(portPosition, elBBox, true, opt);\n\t};\n\n\tvar inside = function(portPosition, elBBox, opt) {\n\t    return insideLayout(portPosition, elBBox, false, opt);\n\t};\n\n\tvar radial = function(portPosition, elBBox, opt) {\n\t    return radialLayout(portPosition.difference(elBBox.center()), false, opt);\n\t};\n\n\tvar radialOriented = function(portPosition, elBBox, opt) {\n\t    return radialLayout(portPosition.difference(elBBox.center()), true, opt);\n\t};\n\n\tvar PortLabel = ({\n\t\tmanual: manual,\n\t\tleft: left$1,\n\t\tright: right$1,\n\t\ttop: top$1,\n\t\tbottom: bottom$1,\n\t\toutsideOriented: outsideOriented,\n\t\toutside: outside,\n\t\tinsideOriented: insideOriented,\n\t\tinside: inside,\n\t\tradial: radial,\n\t\tradialOriented: radialOriented\n\t});\n\n\t// Link base model.\n\t// --------------------------\n\n\tvar Link = Cell.extend({\n\n\t    // The default markup for links.\n\t    markup: [\n\t        '<path class=\"connection\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\n\t        '<path class=\"marker-source\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\n\t        '<path class=\"marker-target\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\n\t        '<path class=\"connection-wrap\" d=\"M 0 0 0 0\"/>',\n\t        '<g class=\"labels\"/>',\n\t        '<g class=\"marker-vertices\"/>',\n\t        '<g class=\"marker-arrowheads\"/>',\n\t        '<g class=\"link-tools\"/>'\n\t    ].join(''),\n\n\t    toolMarkup: [\n\t        '<g class=\"link-tool\">',\n\t        '<g class=\"tool-remove\" event=\"remove\">',\n\t        '<circle r=\"11\" />',\n\t        '<path transform=\"scale(.8) translate(-16, -16)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\" />',\n\t        '<title>Remove link.</title>',\n\t        '</g>',\n\t        '<g class=\"tool-options\" event=\"link:options\">',\n\t        '<circle r=\"11\" transform=\"translate(25)\"/>',\n\t        '<path fill=\"white\" transform=\"scale(.55) translate(29, -16)\" d=\"M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z\"/>',\n\t        '<title>Link options.</title>',\n\t        '</g>',\n\t        '</g>'\n\t    ].join(''),\n\n\t    doubleToolMarkup: undefined,\n\n\t    // The default markup for showing/removing vertices. These elements are the children of the .marker-vertices element (see `this.markup`).\n\t    // Only .marker-vertex and .marker-vertex-remove element have special meaning. The former is used for\n\t    // dragging vertices (changing their position). The latter is used for removing vertices.\n\t    vertexMarkup: [\n\t        '<g class=\"marker-vertex-group\" transform=\"translate(<%= x %>, <%= y %>)\">',\n\t        '<circle class=\"marker-vertex\" idx=\"<%= idx %>\" r=\"10\" />',\n\t        '<path class=\"marker-vertex-remove-area\" idx=\"<%= idx %>\" d=\"M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z\" transform=\"translate(5, -33)\"/>',\n\t        '<path class=\"marker-vertex-remove\" idx=\"<%= idx %>\" transform=\"scale(.8) translate(9.5, -37)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\">',\n\t        '<title>Remove vertex.</title>',\n\t        '</path>',\n\t        '</g>'\n\t    ].join(''),\n\n\t    arrowheadMarkup: [\n\t        '<g class=\"marker-arrowhead-group marker-arrowhead-group-<%= end %>\">',\n\t        '<path class=\"marker-arrowhead\" end=\"<%= end %>\" d=\"M 26 0 L 0 13 L 26 26 z\" />',\n\t        '</g>'\n\t    ].join(''),\n\n\t    // may be overwritten by user to change default label (its markup, size, attrs, position)\n\t    defaultLabel: undefined,\n\n\t    // deprecated\n\t    // may be overwritten by user to change default label markup\n\t    // lower priority than defaultLabel.markup\n\t    labelMarkup: undefined,\n\n\t    // private\n\t    _builtins: {\n\t        defaultLabel: {\n\t            // builtin default markup:\n\t            // used if neither defaultLabel.markup\n\t            // nor label.markup is set\n\t            markup: [\n\t                {\n\t                    tagName: 'rect',\n\t                    selector: 'rect' // faster than tagName CSS selector\n\t                }, {\n\t                    tagName: 'text',\n\t                    selector: 'text' // faster than tagName CSS selector\n\t                }\n\t            ],\n\t            // builtin default attributes:\n\t            // applied only if builtin default markup is used\n\t            attrs: {\n\t                text: {\n\t                    fill: '#000000',\n\t                    fontSize: 14,\n\t                    textAnchor: 'middle',\n\t                    yAlignment: 'middle',\n\t                    pointerEvents: 'none'\n\t                },\n\t                rect: {\n\t                    ref: 'text',\n\t                    fill: '#ffffff',\n\t                    rx: 3,\n\t                    ry: 3,\n\t                    refWidth: 1,\n\t                    refHeight: 1,\n\t                    refX: 0,\n\t                    refY: 0\n\t                }\n\t            },\n\t            // builtin default position:\n\t            // used if neither defaultLabel.position\n\t            // nor label.position is set\n\t            position: {\n\t                distance: 0.5\n\t            }\n\t        }\n\t    },\n\n\t    defaults: {\n\t        type: 'link',\n\t        source: {},\n\t        target: {}\n\t    },\n\n\t    isLink: function() {\n\n\t        return true;\n\t    },\n\n\t    disconnect: function(opt) {\n\n\t        return this.set({\n\t            source: { x: 0, y: 0 },\n\t            target: { x: 0, y: 0 }\n\t        }, opt);\n\t    },\n\n\t    source: function(source, args, opt) {\n\n\t        // getter\n\t        if (source === undefined) {\n\t            return clone(this.get('source'));\n\t        }\n\n\t        // setter\n\t        var setSource;\n\t        var setOpt;\n\n\t        // `source` is a cell\n\t        // take only its `id` and combine with `args`\n\t        var isCellProvided = source instanceof Cell;\n\t        if (isCellProvided) { // three arguments\n\t            setSource = clone(args) || {};\n\t            setSource.id = source.id;\n\t            setOpt = opt;\n\t            return this.set('source', setSource, setOpt);\n\t        }\n\n\t        // `source` is a point-like object\n\t        // for example, a g.Point\n\t        // take only its `x` and `y` and combine with `args`\n\t        var isPointProvided = !isPlainObject(source);\n\t        if (isPointProvided) { // three arguments\n\t            setSource = clone(args) || {};\n\t            setSource.x = source.x;\n\t            setSource.y = source.y;\n\t            setOpt = opt;\n\t            return this.set('source', setSource, setOpt);\n\t        }\n\n\t        // `source` is an object\n\t        // no checking\n\t        // two arguments\n\t        setSource = source;\n\t        setOpt = args;\n\t        return this.set('source', setSource, setOpt);\n\t    },\n\n\t    target: function(target, args, opt) {\n\n\t        // getter\n\t        if (target === undefined) {\n\t            return clone(this.get('target'));\n\t        }\n\n\t        // setter\n\t        var setTarget;\n\t        var setOpt;\n\n\t        // `target` is a cell\n\t        // take only its `id` argument and combine with `args`\n\t        var isCellProvided = target instanceof Cell;\n\t        if (isCellProvided) { // three arguments\n\t            setTarget = clone(args) || {};\n\t            setTarget.id = target.id;\n\t            setOpt = opt;\n\t            return this.set('target', setTarget, setOpt);\n\t        }\n\n\t        // `target` is a point-like object\n\t        // for example, a g.Point\n\t        // take only its `x` and `y` and combine with `args`\n\t        var isPointProvided = !isPlainObject(target);\n\t        if (isPointProvided) { // three arguments\n\t            setTarget = clone(args) || {};\n\t            setTarget.x = target.x;\n\t            setTarget.y = target.y;\n\t            setOpt = opt;\n\t            return this.set('target', setTarget, setOpt);\n\t        }\n\n\t        // `target` is an object\n\t        // no checking\n\t        // two arguments\n\t        setTarget = target;\n\t        setOpt = args;\n\t        return this.set('target', setTarget, setOpt);\n\t    },\n\n\t    router: function(name, args, opt) {\n\n\t        // getter\n\t        if (name === undefined) {\n\t            var router = this.get('router');\n\t            if (!router) {\n\t                if (this.get('manhattan')) { return { name: 'orthogonal' }; } // backwards compatibility\n\t                return null;\n\t            }\n\t            if (typeof router === 'object') { return clone(router); }\n\t            return router; // e.g. a function\n\t        }\n\n\t        // setter\n\t        var isRouterProvided = ((typeof name === 'object') || (typeof name === 'function'));\n\t        var localRouter = isRouterProvided ? name : { name: name, args: args };\n\t        var localOpt = isRouterProvided ? args : opt;\n\n\t        return this.set('router', localRouter, localOpt);\n\t    },\n\n\t    connector: function(name, args, opt) {\n\n\t        // getter\n\t        if (name === undefined) {\n\t            var connector = this.get('connector');\n\t            if (!connector) {\n\t                if (this.get('smooth')) { return { name: 'smooth' }; } // backwards compatibility\n\t                return null;\n\t            }\n\t            if (typeof connector === 'object') { return clone(connector); }\n\t            return connector; // e.g. a function\n\t        }\n\n\t        // setter\n\t        var isConnectorProvided = ((typeof name === 'object' || typeof name === 'function'));\n\t        var localConnector = isConnectorProvided ? name : { name: name, args: args };\n\t        var localOpt = isConnectorProvided ? args : opt;\n\n\t        return this.set('connector', localConnector, localOpt);\n\t    },\n\n\t    // Labels API\n\n\t    // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.\n\t    label: function(idx, label, opt) {\n\n\t        var labels = this.labels();\n\n\t        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : 0;\n\t        if (idx < 0) { idx = labels.length + idx; }\n\n\t        // getter\n\t        if (arguments.length <= 1) { return this.prop(['labels', idx]); }\n\t        // setter\n\t        return this.prop(['labels', idx], label, opt);\n\t    },\n\n\t    labels: function(labels, opt) {\n\n\t        // getter\n\t        if (arguments.length === 0) {\n\t            labels = this.get('labels');\n\t            if (!Array.isArray(labels)) { return []; }\n\t            return labels.slice();\n\t        }\n\t        // setter\n\t        if (!Array.isArray(labels)) { labels = []; }\n\t        return this.set('labels', labels, opt);\n\t    },\n\n\t    hasLabels: function() {\n\t        var ref = this.attributes;\n\t        var labels = ref.labels;\n\t        return Array.isArray(labels) && labels.length > 0;\n\t    },\n\n\t    insertLabel: function(idx, label, opt) {\n\n\t        if (!label) { throw new Error('dia.Link: no label provided'); }\n\n\t        var labels = this.labels();\n\t        var n = labels.length;\n\t        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : n;\n\t        if (idx < 0) { idx = n + idx + 1; }\n\n\t        labels.splice(idx, 0, label);\n\t        return this.labels(labels, opt);\n\t    },\n\n\t    // convenience function\n\t    // add label to end of labels array\n\t    appendLabel: function(label, opt) {\n\n\t        return this.insertLabel(-1, label, opt);\n\t    },\n\n\t    removeLabel: function(idx, opt) {\n\n\t        var labels = this.labels();\n\t        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : -1;\n\n\t        labels.splice(idx, 1);\n\t        return this.labels(labels, opt);\n\t    },\n\n\t    // Vertices API\n\n\t    vertex: function(idx, vertex, opt) {\n\n\t        var vertices = this.vertices();\n\n\t        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : 0;\n\t        if (idx < 0) { idx = vertices.length + idx; }\n\n\t        // getter\n\t        if (arguments.length <= 1) { return this.prop(['vertices', idx]); }\n\n\t        // setter\n\t        var setVertex = this._normalizeVertex(vertex);\n\t        return this.prop(['vertices', idx], setVertex, opt);\n\t    },\n\n\t    vertices: function(vertices, opt) {\n\n\t        // getter\n\t        if (arguments.length === 0) {\n\t            vertices = this.get('vertices');\n\t            if (!Array.isArray(vertices)) { return []; }\n\t            return vertices.slice();\n\t        }\n\n\t        // setter\n\t        if (!Array.isArray(vertices)) { vertices = []; }\n\t        var setVertices = [];\n\t        for (var i = 0; i < vertices.length; i++) {\n\t            var vertex = vertices[i];\n\t            var setVertex = this._normalizeVertex(vertex);\n\t            setVertices.push(setVertex);\n\t        }\n\t        return this.set('vertices', setVertices, opt);\n\t    },\n\n\t    insertVertex: function(idx, vertex, opt) {\n\n\t        if (!vertex) { throw new Error('dia.Link: no vertex provided'); }\n\n\t        var vertices = this.vertices();\n\t        var n = vertices.length;\n\t        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : n;\n\t        if (idx < 0) { idx = n + idx + 1; }\n\n\t        var setVertex = this._normalizeVertex(vertex);\n\t        vertices.splice(idx, 0, setVertex);\n\t        return this.vertices(vertices, opt);\n\t    },\n\n\t    removeVertex: function(idx, opt) {\n\n\t        var vertices = this.vertices();\n\t        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : -1;\n\n\t        vertices.splice(idx, 1);\n\t        return this.vertices(vertices, opt);\n\t    },\n\n\t    _normalizeVertex: function(vertex) {\n\n\t        // is vertex a point-like object?\n\t        // for example, a g.Point\n\t        var isPointProvided = !isPlainObject(vertex);\n\t        if (isPointProvided) { return { x: vertex.x, y: vertex.y }; }\n\n\t        // else: return vertex unchanged\n\t        return vertex;\n\t    },\n\n\t    // Transformations\n\n\t    translate: function(tx, ty, opt) {\n\n\t        // enrich the option object\n\t        opt = opt || {};\n\t        opt.translateBy = opt.translateBy || this.id;\n\t        opt.tx = tx;\n\t        opt.ty = ty;\n\n\t        return this.applyToPoints(function(p) {\n\t            return { x: (p.x || 0) + tx, y: (p.y || 0) + ty };\n\t        }, opt);\n\t    },\n\n\t    scale: function(sx, sy, origin, opt) {\n\n\t        return this.applyToPoints(function(p) {\n\t            return Point(p).scale(sx, sy, origin).toJSON();\n\t        }, opt);\n\t    },\n\n\t    applyToPoints: function(fn, opt) {\n\n\t        if (!isFunction(fn)) {\n\t            throw new TypeError('dia.Link: applyToPoints expects its first parameter to be a function.');\n\t        }\n\n\t        var attrs = {};\n\n\t        var ref = this.attributes;\n\t        var source = ref.source;\n\t        var target = ref.target;\n\t        if (!source.id) {\n\t            attrs.source = fn(source);\n\t        }\n\t        if (!target.id) {\n\t            attrs.target = fn(target);\n\t        }\n\n\t        var vertices = this.vertices();\n\t        if (vertices.length > 0) {\n\t            attrs.vertices = vertices.map(fn);\n\t        }\n\n\t        return this.set(attrs, opt);\n\t    },\n\n\t    getSourcePoint: function() {\n\t        var sourceCell = this.getSourceCell();\n\t        if (!sourceCell) { return new Point(this.source()); }\n\t        return sourceCell.getPointFromConnectedLink(this, 'source');\n\t    },\n\n\t    getTargetPoint: function() {\n\t        var targetCell = this.getTargetCell();\n\t        if (!targetCell) { return new Point(this.target()); }\n\t        return targetCell.getPointFromConnectedLink(this, 'target');\n\t    },\n\n\t    getPointFromConnectedLink: function(/* link, endType */) {\n\t        return this.getPolyline().pointAt(0.5);\n\t    },\n\n\t    getPolyline: function() {\n\t        var points = [\n\t            this.getSourcePoint() ].concat( this.vertices().map(Point),\n\t            [this.getTargetPoint()]\n\t        );\n\t        return new Polyline(points);\n\t    },\n\n\t    getBBox: function() {\n\t        return this.getPolyline().bbox();\n\t    },\n\n\t    reparent: function(opt) {\n\n\t        var newParent;\n\n\t        if (this.graph) {\n\n\t            var source = this.getSourceElement();\n\t            var target = this.getTargetElement();\n\t            var prevParent = this.getParentCell();\n\n\t            if (source && target) {\n\t                if (source === target || source.isEmbeddedIn(target)) {\n\t                    newParent = target;\n\t                } else if (target.isEmbeddedIn(source)) {\n\t                    newParent = source;\n\t                } else {\n\t                    newParent = this.graph.getCommonAncestor(source, target);\n\t                }\n\t            }\n\n\t            if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n\t                // Unembed the link if source and target has no common ancestor\n\t                // or common ancestor changed\n\t                prevParent.unembed(this, opt);\n\t            }\n\n\t            if (newParent) {\n\t                newParent.embed(this, opt);\n\t            }\n\t        }\n\n\t        return newParent;\n\t    },\n\n\t    hasLoop: function(opt) {\n\n\t        opt = opt || {};\n\n\t        var ref = this.attributes;\n\t        var source = ref.source;\n\t        var target = ref.target;\n\t        var sourceId = source.id;\n\t        var targetId = target.id;\n\n\t        if (!sourceId || !targetId) {\n\t            // Link \"pinned\" to the paper does not have a loop.\n\t            return false;\n\t        }\n\n\t        var loop = sourceId === targetId;\n\n\t        // Note that there in the deep mode a link can have a loop,\n\t        // even if it connects only a parent and its embed.\n\t        // A loop \"target equals source\" is valid in both shallow and deep mode.\n\t        if (!loop && opt.deep && this.graph) {\n\n\t            var sourceElement = this.getSourceCell();\n\t            var targetElement = this.getTargetCell();\n\n\t            loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);\n\t        }\n\n\t        return loop;\n\t    },\n\n\t    // unlike source(), this method returns null if source is a point\n\t    getSourceCell: function() {\n\n\t        var ref = this;\n\t        var graph = ref.graph;\n\t        var attributes = ref.attributes;\n\t        var source = attributes.source;\n\t        return (source && source.id && graph && graph.getCell(source.id)) || null;\n\t    },\n\n\t    getSourceElement: function() {\n\t        var cell = this;\n\t        var visited = {};\n\t        do {\n\t            if (visited[cell.id]) { return null; }\n\t            visited[cell.id] = true;\n\t            cell = cell.getSourceCell();\n\t        } while (cell && cell.isLink());\n\t        return cell;\n\t    },\n\n\t    // unlike target(), this method returns null if target is a point\n\t    getTargetCell: function() {\n\n\t        var ref = this;\n\t        var graph = ref.graph;\n\t        var attributes = ref.attributes;\n\t        var target = attributes.target;\n\t        return (target && target.id && graph && graph.getCell(target.id)) || null;\n\t    },\n\n\t    getTargetElement: function() {\n\t        var cell = this;\n\t        var visited = {};\n\t        do {\n\t            if (visited[cell.id]) { return null; }\n\t            visited[cell.id] = true;\n\t            cell = cell.getTargetCell();\n\t        } while (cell && cell.isLink());\n\t        return cell;\n\t    },\n\n\t    // Returns the common ancestor for the source element,\n\t    // target element and the link itself.\n\t    getRelationshipAncestor: function() {\n\n\t        var connectionAncestor;\n\n\t        if (this.graph) {\n\n\t            var cells = [\n\t                this,\n\t                this.getSourceElement(), // null if source is a point\n\t                this.getTargetElement() // null if target is a point\n\t            ].filter(function(item) {\n\t                return !!item;\n\t            });\n\n\t            connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);\n\t        }\n\n\t        return connectionAncestor || null;\n\t    },\n\n\t    // Is source, target and the link itself embedded in a given cell?\n\t    isRelationshipEmbeddedIn: function(cell) {\n\n\t        var cellId = (isString(cell) || isNumber(cell)) ? cell : cell.id;\n\t        var ancestor = this.getRelationshipAncestor();\n\n\t        return !!ancestor && (ancestor.id === cellId || ancestor.isEmbeddedIn(cellId));\n\t    },\n\n\t    // Get resolved default label.\n\t    _getDefaultLabel: function() {\n\n\t        var defaultLabel = this.get('defaultLabel') || this.defaultLabel || {};\n\n\t        var label = {};\n\t        label.markup = defaultLabel.markup || this.get('labelMarkup') || this.labelMarkup;\n\t        label.position = defaultLabel.position;\n\t        label.attrs = defaultLabel.attrs;\n\t        label.size = defaultLabel.size;\n\n\t        return label;\n\t    }\n\t}, {\n\n\t    endsEqual: function(a, b) {\n\n\t        var portsEqual = a.port === b.port || !a.port && !b.port;\n\t        return a.id === b.id && portsEqual;\n\t    }\n\t});\n\n\tvar PortData = function(data) {\n\n\t    var clonedData = cloneDeep(data) || {};\n\t    this.ports = [];\n\t    this.groups = {};\n\t    this.portLayoutNamespace = Port;\n\t    this.portLabelLayoutNamespace = PortLabel;\n\n\t    this._init(clonedData);\n\t};\n\n\tPortData.prototype = {\n\n\t    getPorts: function() {\n\t        return this.ports;\n\t    },\n\n\t    getGroup: function(name) {\n\t        return this.groups[name] || {};\n\t    },\n\n\t    getPortsByGroup: function(groupName) {\n\n\t        return this.ports.filter(function(port) {\n\t            return port.group === groupName;\n\t        });\n\t    },\n\n\t    getGroupPortsMetrics: function(groupName, elBBox) {\n\n\t        var group = this.getGroup(groupName);\n\t        var ports = this.getPortsByGroup(groupName);\n\n\t        var groupPosition = group.position || {};\n\t        var groupPositionName = groupPosition.name;\n\t        var namespace = this.portLayoutNamespace;\n\t        if (!namespace[groupPositionName]) {\n\t            groupPositionName = 'left';\n\t        }\n\n\t        var groupArgs = groupPosition.args || {};\n\t        var portsArgs = ports.map(function(port) {\n\t            return port && port.position && port.position.args;\n\t        });\n\t        var groupPortTransformations = namespace[groupPositionName](portsArgs, elBBox, groupArgs);\n\n\t        var accumulator = {\n\t            ports: ports,\n\t            result: []\n\t        };\n\n\t        toArray(groupPortTransformations).reduce(function(res, portTransformation, index) {\n\t            var port = res.ports[index];\n\t            res.result.push({\n\t                portId: port.id,\n\t                portTransformation: portTransformation,\n\t                labelTransformation: this._getPortLabelLayout(port, Point(portTransformation), elBBox),\n\t                portAttrs: port.attrs,\n\t                portSize: port.size,\n\t                labelSize: port.label.size\n\t            });\n\t            return res;\n\t        }.bind(this), accumulator);\n\n\t        return accumulator.result;\n\t    },\n\n\t    _getPortLabelLayout: function(port, portPosition, elBBox) {\n\n\t        var namespace = this.portLabelLayoutNamespace;\n\t        var labelPosition = port.label.position.name || 'left';\n\n\t        if (namespace[labelPosition]) {\n\t            return namespace[labelPosition](portPosition, elBBox, port.label.position.args);\n\t        }\n\n\t        return null;\n\t    },\n\n\t    _init: function(data) {\n\n\t        // prepare groups\n\t        if (isObject$1(data.groups)) {\n\t            var groups = Object.keys(data.groups);\n\t            for (var i = 0, n = groups.length; i < n; i++) {\n\t                var key = groups[i];\n\t                this.groups[key] = this._evaluateGroup(data.groups[key]);\n\t            }\n\t        }\n\n\t        // prepare ports\n\t        var ports = toArray(data.items);\n\t        for (var j = 0, m = ports.length; j < m; j++) {\n\t            this.ports.push(this._evaluatePort(ports[j]));\n\t        }\n\t    },\n\n\t    _evaluateGroup: function(group) {\n\n\t        return merge(group, {\n\t            position: this._getPosition(group.position, true),\n\t            label: this._getLabel(group, true)\n\t        });\n\t    },\n\n\t    _evaluatePort: function(port) {\n\n\t        var evaluated = assign({}, port);\n\n\t        var group = this.getGroup(port.group);\n\n\t        evaluated.markup = evaluated.markup || group.markup;\n\t        evaluated.attrs = merge({}, group.attrs, evaluated.attrs);\n\t        evaluated.position = this._createPositionNode(group, evaluated);\n\t        evaluated.label = merge({}, group.label, this._getLabel(evaluated));\n\t        evaluated.z = this._getZIndex(group, evaluated);\n\t        evaluated.size = assign({}, group.size, evaluated.size);\n\n\t        return evaluated;\n\t    },\n\n\t    _getZIndex: function(group, port) {\n\n\t        if (isNumber(port.z)) {\n\t            return port.z;\n\t        }\n\t        if (isNumber(group.z) || group.z === 'auto') {\n\t            return group.z;\n\t        }\n\t        return 'auto';\n\t    },\n\n\t    _createPositionNode: function(group, port) {\n\n\t        return merge({\n\t            name: 'left',\n\t            args: {}\n\t        }, group.position, { args: port.args });\n\t    },\n\n\t    _getPosition: function(position, setDefault) {\n\n\t        var args = {};\n\t        var positionName;\n\n\t        if (isFunction(position)) {\n\t            positionName = 'fn';\n\t            args.fn = position;\n\t        } else if (isString(position)) {\n\t            positionName = position;\n\t        } else if (position === undefined) {\n\t            positionName = setDefault ? 'left' : null;\n\t        } else if (Array.isArray(position)) {\n\t            positionName = 'absolute';\n\t            args.x = position[0];\n\t            args.y = position[1];\n\t        } else if (isObject$1(position)) {\n\t            positionName = position.name;\n\t            assign(args, position.args);\n\t        }\n\n\t        var result = { args: args };\n\n\t        if (positionName) {\n\t            result.name = positionName;\n\t        }\n\t        return result;\n\t    },\n\n\t    _getLabel: function(item, setDefaults) {\n\n\t        var label = item.label || {};\n\n\t        var ret = label;\n\t        ret.position = this._getPosition(label.position, setDefaults);\n\n\t        return ret;\n\t    }\n\t};\n\n\tvar elementPortPrototype = {\n\n\t    _initializePorts: function() {\n\n\t        this._createPortData();\n\t        this.on('change:ports', function() {\n\n\t            this._processRemovedPort();\n\t            this._createPortData();\n\t        }, this);\n\t    },\n\n\t    /**\n\t     * remove links tied wiht just removed element\n\t     * @private\n\t     */\n\t    _processRemovedPort: function() {\n\n\t        var current = this.get('ports') || {};\n\t        var currentItemsMap = {};\n\n\t        toArray(current.items).forEach(function(item) {\n\t            currentItemsMap[item.id] = true;\n\t        });\n\n\t        var previous = this.previous('ports') || {};\n\t        var removed = {};\n\n\t        toArray(previous.items).forEach(function(item) {\n\t            if (!currentItemsMap[item.id]) {\n\t                removed[item.id] = true;\n\t            }\n\t        });\n\n\t        var graph = this.graph;\n\t        if (graph && !isEmpty(removed)) {\n\n\t            var inboundLinks = graph.getConnectedLinks(this, { inbound: true });\n\t            inboundLinks.forEach(function(link) {\n\n\t                if (removed[link.get('target').port]) { link.remove(); }\n\t            });\n\n\t            var outboundLinks = graph.getConnectedLinks(this, { outbound: true });\n\t            outboundLinks.forEach(function(link) {\n\n\t                if (removed[link.get('source').port]) { link.remove(); }\n\t            });\n\t        }\n\t    },\n\n\t    /**\n\t     * @returns {boolean}\n\t     */\n\t    hasPorts: function() {\n\n\t        var ports = this.prop('ports/items');\n\t        return Array.isArray(ports) && ports.length > 0;\n\t    },\n\n\t    /**\n\t     * @param {string} id\n\t     * @returns {boolean}\n\t     */\n\t    hasPort: function(id) {\n\n\t        return this.getPortIndex(id) !== -1;\n\t    },\n\n\t    /**\n\t     * @returns {Array<object>}\n\t     */\n\t    getPorts: function() {\n\n\t        return cloneDeep(this.prop('ports/items')) || [];\n\t    },\n\n\t    /**\n\t     * @returns {Array<object>}\n\t     */\n\t    getGroupPorts: function(groupName) {\n\t        var groupPorts = toArray(this.prop(['ports','items'])).filter(function (port) { return port.group === groupName; });\n\t        return cloneDeep(groupPorts);\n\t    },\n\n\t    /**\n\t     * @param {string} id\n\t     * @returns {object}\n\t     */\n\t    getPort: function(id) {\n\n\t        return cloneDeep(toArray(this.prop('ports/items')).find(function(port) {\n\t            return port.id && port.id === id;\n\t        }));\n\t    },\n\n\t    /**\n\t     * @param {string} groupName\n\t     * @returns {Object<portId, {x: number, y: number, angle: number}>}\n\t     */\n\t    getPortsPositions: function(groupName) {\n\n\t        var portsMetrics = this._portSettingsData.getGroupPortsMetrics(groupName, Rect(this.size()));\n\n\t        return portsMetrics.reduce(function(positions, metrics) {\n\t            var transformation = metrics.portTransformation;\n\t            positions[metrics.portId] = {\n\t                x: transformation.x,\n\t                y: transformation.y,\n\t                angle: transformation.angle\n\t            };\n\t            return positions;\n\t        }, {});\n\t    },\n\n\t    /**\n\t     * @param {string|Port} port port id or port\n\t     * @returns {number} port index\n\t     */\n\t    getPortIndex: function(port) {\n\n\t        var id = isObject$1(port) ? port.id : port;\n\n\t        if (!this._isValidPortId(id)) {\n\t            return -1;\n\t        }\n\n\t        return toArray(this.prop('ports/items')).findIndex(function(item) {\n\t            return item.id === id;\n\t        });\n\t    },\n\n\t    /**\n\t     * @param {object} port\n\t     * @param {object} [opt]\n\t     * @returns {joint.dia.Element}\n\t     */\n\t    addPort: function(port, opt) {\n\n\t        if (!isObject$1(port) || Array.isArray(port)) {\n\t            throw new Error('Element: addPort requires an object.');\n\t        }\n\n\t        var ports = assign([], this.prop('ports/items'));\n\t        ports.push(port);\n\t        this.prop('ports/items', ports, opt);\n\n\t        return this;\n\t    },\n\n\t    /**\n\t     * @param {string|Port|number} before\n\t     * @param {object} port\n\t     * @param {object} [opt]\n\t     * @returns {joint.dia.Element}\n\t     */\n\t    insertPort: function(before, port, opt) {\n\t        var index$1 = (typeof before === 'number') ? before : this.getPortIndex(before);\n\n\t        if (!isObject$1(port) || Array.isArray(port)) {\n\t            throw new Error('dia.Element: insertPort requires an object.');\n\t        }\n\n\t        var ports = assign([], this.prop('ports/items'));\n\t        ports.splice(index$1, 0, port);\n\t        this.prop('ports/items', ports, opt);\n\n\t        return this;\n\t    },\n\n\t    /**\n\t     * @param {string} portId\n\t     * @param {string|object=} path\n\t     * @param {*=} value\n\t     * @param {object=} opt\n\t     * @returns {joint.dia.Element}\n\t     */\n\t    portProp: function(portId, path, value, opt) {\n\n\t        var index$1 = this.getPortIndex(portId);\n\n\t        if (index$1 === -1) {\n\t            throw new Error('Element: unable to find port with id ' + portId);\n\t        }\n\n\t        var args = Array.prototype.slice.call(arguments, 1);\n\t        if (Array.isArray(path)) {\n\t            args[0] = ['ports', 'items', index$1].concat(path);\n\t        } else if (isString(path)) {\n\n\t            // Get/set an attribute by a special path syntax that delimits\n\t            // nested objects by the colon character.\n\t            args[0] = ['ports/items/', index$1, '/', path].join('');\n\n\t        } else {\n\n\t            args = ['ports/items/' + index$1];\n\t            if (isPlainObject(path)) {\n\t                args.push(path);\n\t                args.push(value);\n\t            }\n\t        }\n\n\t        return this.prop.apply(this, args);\n\t    },\n\n\t    _validatePorts: function() {\n\n\t        var portsAttr = this.get('ports') || {};\n\n\t        var errorMessages = [];\n\t        portsAttr = portsAttr || {};\n\t        var ports = toArray(portsAttr.items);\n\n\t        ports.forEach(function(p) {\n\n\t            if (typeof p !== 'object') {\n\t                errorMessages.push('Element: invalid port ', p);\n\t            }\n\n\t            if (!this._isValidPortId(p.id)) {\n\t                p.id = this.generatePortId();\n\t            }\n\t        }, this);\n\n\t        if (uniq(ports, 'id').length !== ports.length) {\n\t            errorMessages.push('Element: found id duplicities in ports.');\n\t        }\n\n\t        return errorMessages;\n\t    },\n\n\t    generatePortId: function() {\n\t        return this.generateId();\n\t    },\n\n\t    /**\n\t     * @param {string} id port id\n\t     * @returns {boolean}\n\t     * @private\n\t     */\n\t    _isValidPortId: function(id) {\n\n\t        return id !== null && id !== undefined && !isObject$1(id);\n\t    },\n\n\t    addPorts: function(ports, opt) {\n\n\t        if (ports.length) {\n\t            this.prop('ports/items', assign([], this.prop('ports/items')).concat(ports), opt);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    removePort: function(port, opt) {\n\t        var options = opt || {};\n\t        var index$1 = this.getPortIndex(port);\n\t        if (index$1 !== -1) {\n\t            var ports = assign([], this.prop(['ports', 'items']));\n\t            ports.splice(index$1, 1);\n\t            options.rewrite = true;\n\t            this.startBatch('port-remove');\n\t            this.prop(['ports', 'items'], ports, options);\n\t            this.stopBatch('port-remove');\n\t        }\n\t        return this;\n\t    },\n\n\t    removePorts: function(portsForRemoval, opt) {\n\t        var options, newPorts;\n\t        if (Array.isArray(portsForRemoval)) {\n\t            options = opt || {};\n\t            if (portsForRemoval.length === 0) { return this.this; }\n\t            var currentPorts = assign([], this.prop(['ports', 'items']));\n\t            newPorts = currentPorts.filter(function(cp) {\n\t                return !portsForRemoval.some(function(rp) {\n\t                    var rpId = isObject$1(rp) ? rp.id : rp;\n\t                    return cp.id === rpId;\n\t                });\n\t            });\n\t        } else {\n\t            options = portsForRemoval || {};\n\t            newPorts = [];\n\t        }\n\t        this.startBatch('port-remove');\n\t        options.rewrite = true;\n\t        this.prop(['ports', 'items'], newPorts, options);\n\t        this.stopBatch('port-remove');\n\t        return this;\n\t    },\n\n\t    /**\n\t     * @private\n\t     */\n\t    _createPortData: function() {\n\n\t        var err = this._validatePorts();\n\n\t        if (err.length > 0) {\n\t            this.set('ports', this.previous('ports'));\n\t            throw new Error(err.join(' '));\n\t        }\n\n\t        var prevPortData;\n\n\t        if (this._portSettingsData) {\n\n\t            prevPortData = this._portSettingsData.getPorts();\n\t        }\n\n\t        this._portSettingsData = new PortData(this.get('ports'));\n\n\t        var curPortData = this._portSettingsData.getPorts();\n\n\t        if (prevPortData) {\n\n\t            var added = curPortData.filter(function(item) {\n\t                if (!prevPortData.find(function(prevPort) {\n\t                    return prevPort.id === item.id;\n\t                })) {\n\t                    return item;\n\t                }\n\t            });\n\n\t            var removed = prevPortData.filter(function(item) {\n\t                if (!curPortData.find(function(curPort) {\n\t                    return curPort.id === item.id;\n\t                })) {\n\t                    return item;\n\t                }\n\t            });\n\n\t            if (removed.length > 0) {\n\t                this.trigger('ports:remove', this, removed);\n\t            }\n\n\t            if (added.length > 0) {\n\t                this.trigger('ports:add', this, added);\n\t            }\n\t        }\n\t    }\n\t};\n\n\tvar elementViewPortPrototype = {\n\n\t    portContainerMarkup: 'g',\n\t    portMarkup: [{\n\t        tagName: 'circle',\n\t        selector: 'circle',\n\t        attributes: {\n\t            'r': 10,\n\t            'fill': '#FFFFFF',\n\t            'stroke': '#000000'\n\t        }\n\t    }],\n\t    portLabelMarkup: [{\n\t        tagName: 'text',\n\t        selector: 'text',\n\t        attributes: {\n\t            'fill': '#000000'\n\t        }\n\t    }],\n\t    /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */\n\t    _portElementsCache: null,\n\n\t    /**\n\t     * @private\n\t     */\n\t    _initializePorts: function() {\n\t        this._cleanPortsCache();\n\t    },\n\n\t    /**\n\t     * @typedef {Object} Port\n\t     *\n\t     * @property {string} id\n\t     * @property {Object} position\n\t     * @property {Object} label\n\t     * @property {Object} attrs\n\t     * @property {string} markup\n\t     * @property {string} group\n\t     */\n\n\t    /**\n\t     * @private\n\t     */\n\t    _refreshPorts: function() {\n\n\t        this._removePorts();\n\t        this._cleanPortsCache();\n\t        this._renderPorts();\n\t    },\n\n\t    _cleanPortsCache: function() {\n\t        this._portElementsCache = {};\n\t    },\n\n\t    /**\n\t     * @private\n\t     */\n\t    _renderPorts: function() {\n\n\t        // references to rendered elements without z-index\n\t        var elementReferences = [];\n\t        var elem = this._getContainerElement();\n\n\t        for (var i = 0, count = elem.node.childNodes.length; i < count; i++) {\n\t            elementReferences.push(elem.node.childNodes[i]);\n\t        }\n\n\t        var portsGropsByZ = groupBy(this.model._portSettingsData.getPorts(), 'z');\n\t        var withoutZKey = 'auto';\n\n\t        // render non-z first\n\t        toArray(portsGropsByZ[withoutZKey]).forEach(function(port) {\n\t            var portElement = this._getPortElement(port);\n\t            elem.append(portElement);\n\t            elementReferences.push(portElement);\n\t        }, this);\n\n\t        var groupNames = Object.keys(portsGropsByZ);\n\t        for (var k = 0; k < groupNames.length; k++) {\n\t            var groupName = groupNames[k];\n\t            if (groupName !== withoutZKey) {\n\t                var z = parseInt(groupName, 10);\n\t                this._appendPorts(portsGropsByZ[groupName], z, elementReferences);\n\t            }\n\t        }\n\n\t        this._updatePorts();\n\t    },\n\n\t    /**\n\t     * @returns {V}\n\t     * @private\n\t     */\n\t    _getContainerElement: function() {\n\n\t        return this.rotatableNode || this.vel;\n\t    },\n\n\t    /**\n\t     * @param {Array<Port>}ports\n\t     * @param {number} z\n\t     * @param refs\n\t     * @private\n\t     */\n\t    _appendPorts: function(ports, z, refs) {\n\n\t        var containerElement = this._getContainerElement();\n\t        var portElements = toArray(ports).map(this._getPortElement, this);\n\n\t        if (refs[z] || z < 0) {\n\t            V(refs[Math.max(z, 0)]).before(portElements);\n\t        } else {\n\t            containerElement.append(portElements);\n\t        }\n\t    },\n\n\t    /**\n\t     * Try to get element from cache,\n\t     * @param port\n\t     * @returns {*}\n\t     * @private\n\t     */\n\t    _getPortElement: function(port) {\n\n\t        if (this._portElementsCache[port.id]) {\n\t            return this._portElementsCache[port.id].portElement;\n\t        }\n\t        return this._createPortElement(port);\n\t    },\n\n\t    findPortNode: function(portId, selector) {\n\t        var portCache = this._portElementsCache[portId];\n\t        if (!portCache) { return null; }\n\t        if (!selector) { return portCache.portContentElement.node; }\n\t        var portRoot = portCache.portElement.node;\n\t        var portSelectors = portCache.portSelectors;\n\t        var ref = this.findBySelector(selector, portRoot, portSelectors);\n\t        var node = ref[0]; if ( node === void 0 ) node = null;\n\t        return node;\n\t    },\n\n\t    /**\n\t     * @private\n\t     */\n\t    _updatePorts: function() {\n\n\t        // layout ports without group\n\t        this._updatePortGroup(undefined);\n\t        // layout ports with explicit group\n\t        var groupsNames = Object.keys(this.model._portSettingsData.groups);\n\t        groupsNames.forEach(this._updatePortGroup, this);\n\t    },\n\n\t    /**\n\t     * @private\n\t     */\n\t    _removePorts: function() {\n\t        invoke(this._portElementsCache, 'portElement.remove');\n\t    },\n\n\t    /**\n\t     * @param {Port} port\n\t     * @returns {V}\n\t     * @private\n\t     */\n\t    _createPortElement: function(port) {\n\n\t        var portElement;\n\t        var labelElement;\n\t        var labelSelectors;\n\t        var portSelectors;\n\n\t        var portContainerElement = V(this.portContainerMarkup).addClass('joint-port');\n\n\t        var portMarkup = this._getPortMarkup(port);\n\t        if (Array.isArray(portMarkup)) {\n\t            var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);\n\t            var portFragment = portDoc.fragment;\n\t            if (portFragment.childNodes.length > 1) {\n\t                portElement = V('g').append(portFragment);\n\t            } else {\n\t                portElement = V(portFragment.firstChild);\n\t            }\n\t            portSelectors = portDoc.selectors;\n\t        } else {\n\t            portElement = V(portMarkup);\n\t            if (Array.isArray(portElement)) {\n\t                portElement = V('g').append(portElement);\n\t            }\n\t        }\n\n\t        if (!portElement) {\n\t            throw new Error('ElementView: Invalid port markup.');\n\t        }\n\n\t        portElement.attr({\n\t            'port': port.id,\n\t            'port-group': port.group\n\t        });\n\n\t        var labelMarkupDef = this._getPortLabelMarkup(port.label);\n\t        if (Array.isArray(labelMarkupDef)) {\n\t            // JSON Markup\n\t            var ref = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);\n\t            var fragment = ref.fragment;\n\t            var selectors = ref.selectors;\n\t            var childCount = fragment.childNodes.length;\n\t            if (childCount > 0) {\n\t                labelSelectors = selectors;\n\t                labelElement = (childCount === 1) ? V(fragment.firstChild) : V('g').append(fragment);\n\t            }\n\t        } else {\n\t            // String Markup\n\t            labelElement = V(labelMarkupDef);\n\t            if (Array.isArray(labelElement)) {\n\t                labelElement = V('g').append(labelElement);\n\t            }\n\t        }\n\n\t        var portContainerSelectors;\n\t        if (portSelectors && labelSelectors) {\n\t            for (var key in labelSelectors) {\n\t                if (portSelectors[key] && key !== this.selector) { throw new Error('ElementView: selectors within port must be unique.'); }\n\t            }\n\t            portContainerSelectors = assign({}, portSelectors, labelSelectors);\n\t        } else {\n\t            portContainerSelectors = portSelectors || labelSelectors || {};\n\t        }\n\n\t        // The `portRootSelector` points to the root SVGNode of the port.\n\t        // Either the implicit wrapping group <g/> in case the port consist of multiple SVGNodes.\n\t        // Or the single SVGNode of the port.\n\t        var portRootSelector = 'portRoot';\n\t        // The `labelRootSelector` points to the root SVGNode of the label.\n\t        var labelRootSelector = 'labelRoot';\n\t        // The `labelTextSelector` points to all text SVGNodes of the label.\n\t        var labelTextSelector = 'labelText';\n\n\t        if (!(portRootSelector in portContainerSelectors)) {\n\t            portContainerSelectors[portRootSelector] = portElement.node;\n\t        }\n\n\t        if (labelElement) {\n\t            var labelNode = labelElement.node;\n\t            if (!(labelRootSelector in portContainerSelectors)) {\n\t                portContainerSelectors[labelRootSelector] = labelNode;\n\t            }\n\t            if (!(labelTextSelector in portContainerSelectors)) {\n\t                // If the label is a <text> element, we can use it directly.\n\t                // Otherwise, we need to find the <text> element within the label.\n\t                var labelTextNode = (labelElement.tagName() === 'TEXT')\n\t                    ? labelNode\n\t                    : Array.from(labelNode.querySelectorAll('text'));\n\t                portContainerSelectors[labelTextSelector] = labelTextNode;\n\t                if (!labelSelectors) { labelSelectors = {}; }\n\t                labelSelectors[labelTextSelector] = labelTextNode;\n\t            }\n\t        }\n\n\t        portContainerElement.append(portElement.addClass('joint-port-body'));\n\t        if (labelElement) {\n\t            portContainerElement.append(labelElement.addClass('joint-port-label'));\n\t        }\n\n\t        this._portElementsCache[port.id] = {\n\t            portElement: portContainerElement,\n\t            portLabelElement: labelElement,\n\t            portSelectors: portContainerSelectors,\n\t            portLabelSelectors: labelSelectors,\n\t            portContentElement: portElement,\n\t            portContentSelectors: portSelectors\n\t        };\n\n\t        return portContainerElement;\n\t    },\n\n\t    /**\n\t     * @param {string=} groupName\n\t     * @private\n\t     */\n\t    _updatePortGroup: function(groupName) {\n\n\t        var elementBBox = Rect(this.model.size());\n\t        var portsMetrics = this.model._portSettingsData.getGroupPortsMetrics(groupName, elementBBox);\n\n\t        for (var i = 0, n = portsMetrics.length; i < n; i++) {\n\t            var metrics = portsMetrics[i];\n\t            var portId = metrics.portId;\n\t            var cached = this._portElementsCache[portId] || {};\n\t            var portTransformation = metrics.portTransformation;\n\t            var labelTransformation = metrics.labelTransformation;\n\t            if (labelTransformation && cached.portLabelElement) {\n\t                this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {\n\t                    rootBBox: new Rect(metrics.labelSize),\n\t                    selectors: cached.portLabelSelectors\n\t                });\n\t                this.applyPortTransform(cached.portLabelElement, labelTransformation, (-portTransformation.angle || 0));\n\t            }\n\t            this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {\n\t                rootBBox: new Rect(metrics.portSize),\n\t                selectors: cached.portSelectors\n\t            });\n\t            this.applyPortTransform(cached.portElement, portTransformation);\n\t        }\n\t    },\n\n\t    /**\n\t     * @param {Vectorizer} element\n\t     * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData\n\t     * @param {number=} initialAngle\n\t     * @constructor\n\t     */\n\t    applyPortTransform: function(element, transformData, initialAngle) {\n\n\t        var matrix = V.createSVGMatrix()\n\t            .rotate(initialAngle || 0)\n\t            .translate(transformData.x || 0, transformData.y || 0)\n\t            .rotate(transformData.angle || 0);\n\n\t        element.transform(matrix, { absolute: true });\n\t    },\n\n\t    /**\n\t     * @param {Port} port\n\t     * @returns {string}\n\t     * @private\n\t     */\n\t    _getPortMarkup: function(port) {\n\n\t        return port.markup || this.model.get('portMarkup') || this.model.portMarkup || this.portMarkup;\n\t    },\n\n\t    /**\n\t     * @param {Object} label\n\t     * @returns {string}\n\t     * @private\n\t     */\n\t    _getPortLabelMarkup: function(label) {\n\n\t        return label.markup || this.model.get('portLabelMarkup') || this.model.portLabelMarkup || this.portLabelMarkup;\n\t    }\n\t};\n\n\t// Element base model.\n\t// -----------------------------\n\n\tvar Element$1 = Cell.extend({\n\n\t    defaults: {\n\t        position: { x: 0, y: 0 },\n\t        size: { width: 1, height: 1 },\n\t        angle: 0\n\t    },\n\n\t    initialize: function() {\n\n\t        this._initializePorts();\n\t        Cell.prototype.initialize.apply(this, arguments);\n\t    },\n\n\t    /**\n\t     * @abstract\n\t     */\n\t    _initializePorts: function() {\n\t        // implemented in ports.js\n\t    },\n\n\t    _refreshPorts: function() {\n\t        // implemented in ports.js\n\t    },\n\n\t    isElement: function() {\n\n\t        return true;\n\t    },\n\n\t    position: function(x, y, opt) {\n\n\t        var isSetter = isNumber(y);\n\t        opt = (isSetter ? opt : x) || {};\n\t        var parentRelative = opt.parentRelative;\n\t        var deep = opt.deep;\n\t        var restrictedArea = opt.restrictedArea;\n\n\n\t        // option `parentRelative` for setting the position relative to the element's parent.\n\t        var parentPosition;\n\t        if (parentRelative) {\n\n\t            // Getting the parent's position requires the collection.\n\t            // Cell.parent() holds cell id only.\n\t            if (!this.graph) { throw new Error('Element must be part of a graph.'); }\n\n\t            var parent = this.getParentCell();\n\t            if (parent && !parent.isLink()) {\n\t                parentPosition = parent.get('position');\n\t            }\n\t        }\n\n\t        if (isSetter) {\n\n\t            if (parentPosition) {\n\t                x += parentPosition.x;\n\t                y += parentPosition.y;\n\t            }\n\n\t            if (deep || restrictedArea) {\n\t                var ref = this.get('position');\n\t                var x0 = ref.x;\n\t                var y0 = ref.y;\n\t                this.translate(x - x0, y - y0, opt);\n\t            } else {\n\t                this.set('position', { x: x, y: y }, opt);\n\t            }\n\n\t            return this;\n\n\t        } else { // Getter returns a geometry point.\n\n\t            var elementPosition = Point(this.get('position'));\n\t            return parentRelative\n\t                ? elementPosition.difference(parentPosition)\n\t                : elementPosition;\n\t        }\n\t    },\n\n\t    translate: function(tx, ty, opt) {\n\n\t        tx = tx || 0;\n\t        ty = ty || 0;\n\n\t        if (tx === 0 && ty === 0) {\n\t            // Like nothing has happened.\n\t            return this;\n\t        }\n\n\t        opt = opt || {};\n\t        // Pass the initiator of the translation.\n\t        opt.translateBy = opt.translateBy || this.id;\n\n\t        var position = this.get('position') || { x: 0, y: 0 };\n\t        var ra = opt.restrictedArea;\n\t        if (ra && opt.translateBy === this.id) {\n\n\t            if (typeof ra === 'function') {\n\n\t                var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n\n\t                tx = newPosition.x - position.x;\n\t                ty = newPosition.y - position.y;\n\n\t            } else  {\n\t                // We are restricting the translation for the element itself only. We get\n\t                // the bounding box of the element including all its embeds.\n\t                // All embeds have to be translated the exact same way as the element.\n\t                var bbox = this.getBBox({ deep: true });\n\t                //- - - - - - - - - - - - -> ra.x + ra.width\n\t                // - - - -> position.x      |\n\t                // -> bbox.x\n\t                //                   |\n\t                //         \n\t                //                 |\n\t                //   \n\t                //                  |\n\t                //   <-dx->                     | restricted area right border\n\t                //         <-width->        |    translated element\n\t                //   <- - bbox.width - ->        embedded element\n\t                var dx = position.x - bbox.x;\n\t                var dy = position.y - bbox.y;\n\t                // Find the maximal/minimal coordinates that the element can be translated\n\t                // while complies the restrictions.\n\t                var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n\t                var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n\t                // recalculate the translation taking the restrictions into account.\n\t                tx = x - position.x;\n\t                ty = y - position.y;\n\t            }\n\t        }\n\n\t        var translatedPosition = {\n\t            x: position.x + tx,\n\t            y: position.y + ty\n\t        };\n\n\t        // To find out by how much an element was translated in event 'change:position' handlers.\n\t        opt.tx = tx;\n\t        opt.ty = ty;\n\n\t        if (opt.transition) {\n\n\t            if (!isObject$1(opt.transition)) { opt.transition = {}; }\n\n\t            this.transition('position', translatedPosition, assign({}, opt.transition, {\n\t                valueFunction: interpolate.object\n\t            }));\n\n\t            // Recursively call `translate()` on all the embeds cells.\n\t            invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\n\t        } else {\n\n\t            this.startBatch('translate', opt);\n\t            this.set('position', translatedPosition, opt);\n\t            invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\t            this.stopBatch('translate', opt);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    size: function(width, height, opt) {\n\n\t        var currentSize = this.get('size');\n\t        // Getter\n\t        // () signature\n\t        if (width === undefined) {\n\t            return {\n\t                width: currentSize.width,\n\t                height: currentSize.height\n\t            };\n\t        }\n\t        // Setter\n\t        // (size, opt) signature\n\t        if (isObject$1(width)) {\n\t            opt = height;\n\t            height = isNumber(width.height) ? width.height : currentSize.height;\n\t            width = isNumber(width.width) ? width.width : currentSize.width;\n\t        }\n\n\t        return this.resize(width, height, opt);\n\t    },\n\n\t    resize: function(width, height, opt) {\n\n\t        opt = opt || {};\n\n\t        this.startBatch('resize', opt);\n\n\t        if (opt.direction) {\n\n\t            var currentSize = this.get('size');\n\n\t            switch (opt.direction) {\n\n\t                case 'left':\n\t                case 'right':\n\t                    // Don't change height when resizing horizontally.\n\t                    height = currentSize.height;\n\t                    break;\n\n\t                case 'top':\n\t                case 'bottom':\n\t                    // Don't change width when resizing vertically.\n\t                    width = currentSize.width;\n\t                    break;\n\t            }\n\n\t            // Get the angle and clamp its value between 0 and 360 degrees.\n\t            var angle = normalizeAngle(this.get('angle') || 0);\n\n\t            // This is a rectangle in size of the un-rotated element.\n\t            var bbox = this.getBBox();\n\n\t            var origin;\n\n\t            if (angle) {\n\n\t                var quadrant = {\n\t                    'top-right': 0,\n\t                    'right': 0,\n\t                    'top-left': 1,\n\t                    'top': 1,\n\t                    'bottom-left': 2,\n\t                    'left': 2,\n\t                    'bottom-right': 3,\n\t                    'bottom': 3\n\t                }[opt.direction];\n\n\t                if (opt.absolute) {\n\n\t                    // We are taking the element's rotation into account\n\t                    quadrant += Math.floor((angle + 45) / 90);\n\t                    quadrant %= 4;\n\t                }\n\n\t                // Pick the corner point on the element, which meant to stay on its place before and\n\t                // after the rotation.\n\t                var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]]();\n\n\t                // Find  an image of the previous indent point. This is the position, where is the\n\t                // point actually located on the screen.\n\t                var imageFixedPoint = Point(fixedPoint).rotate(bbox.center(), -angle);\n\n\t                // Every point on the element rotates around a circle with the centre of rotation\n\t                // in the middle of the element while the whole element is being rotated. That means\n\t                // that the distance from a point in the corner of the element (supposed its always rect) to\n\t                // the center of the element doesn't change during the rotation and therefore it equals\n\t                // to a distance on un-rotated element.\n\t                // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n\t                var radius = Math.sqrt((width * width) + (height * height)) / 2;\n\n\t                // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n\t                // and ending at the center of the element. We call this angle `alpha`.\n\n\t                // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n\t                // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n\t                //\n\t                // 3 | 2\n\t                // --c-- Quadrant positions around the element's center `c`\n\t                // 0 | 1\n\t                //\n\t                var alpha = quadrant * Math.PI / 2;\n\n\t                // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n\t                // going through the center of the element) and line crossing the indent of the fixed point and the center\n\t                // of the element. This is the angle we need but on the un-rotated element.\n\t                alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\n\n\t                // Lastly we have to deduct the original angle the element was rotated by and that's it.\n\t                alpha -= toRad(angle);\n\n\t                // With this angle and distance we can easily calculate the centre of the un-rotated element.\n\t                // Note that fromPolar constructor accepts an angle in radians.\n\t                var center = Point.fromPolar(radius, alpha, imageFixedPoint);\n\n\t                // The top left corner on the un-rotated element has to be half a width on the left\n\t                // and half a height to the top from the center. This will be the origin of rectangle\n\t                // we were looking for.\n\t                origin = Point(center).offset(width / -2, height / -2);\n\n\t            } else {\n\t                // calculation for the origin Point when there is no rotation of the element\n\t                origin = bbox.topLeft();\n\n\t                switch (opt.direction) {\n\t                    case 'top':\n\t                    case 'top-right':\n\t                        origin.offset(0, bbox.height - height);\n\t                        break;\n\t                    case 'left':\n\t                    case 'bottom-left':\n\t                        origin.offset(bbox.width -width, 0);\n\t                        break;\n\t                    case 'top-left':\n\t                        origin.offset(bbox.width - width, bbox.height - height);\n\t                        break;\n\t                }\n\t            }\n\n\t            // Resize the element (before re-positioning it).\n\t            this.set('size', { width: width, height: height }, opt);\n\n\t            // Finally, re-position the element.\n\t            this.position(origin.x, origin.y, opt);\n\n\t        } else {\n\n\t            // Resize the element.\n\t            this.set('size', { width: width, height: height }, opt);\n\t        }\n\n\t        this.stopBatch('resize', opt);\n\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin, opt) {\n\n\t        var scaledBBox = this.getBBox().scale(sx, sy, origin);\n\t        this.startBatch('scale', opt);\n\t        this.position(scaledBBox.x, scaledBBox.y, opt);\n\t        this.resize(scaledBBox.width, scaledBBox.height, opt);\n\t        this.stopBatch('scale');\n\t        return this;\n\t    },\n\n\t    fitEmbeds: function(opt) {\n\n\t        return this.fitToChildren(opt);\n\t    },\n\n\t    fitToChildren: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        // Getting the children's size and position requires the collection.\n\t        // Cell.get('embeds') holds an array of cell ids only.\n\t        var ref = this;\n\t        var graph = ref.graph;\n\t        if (!graph) { throw new Error('Element must be part of a graph.'); }\n\n\t        var childElements = this.getEmbeddedCells().filter(function (cell) { return cell.isElement(); });\n\t        if (childElements.length === 0) { return this; }\n\n\t        this.startBatch('fit-embeds', opt);\n\n\t        if (opt.deep) {\n\t            // `opt.deep = true` means \"fit to all descendants\".\n\t            // As the first action of the fitting algorithm, recursively apply `fitToChildren()` on all descendants.\n\t            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant, then go up (= this element).\n\t            invoke(childElements, 'fitToChildren', opt);\n\t        }\n\n\t        // Set new size and position of this element, based on:\n\t        // - union of bboxes of all children\n\t        // - inflated by given `opt.padding`\n\t        this._fitToElements(Object.assign({ elements: childElements }, opt));\n\n\t        this.stopBatch('fit-embeds');\n\n\t        return this;\n\t    },\n\n\t    fitParent: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        var ref = this;\n\t        var graph = ref.graph;\n\t        if (!graph) { throw new Error('Element must be part of a graph.'); }\n\n\t        // When `opt.deep = true`, we want `opt.terminator` to be the last ancestor processed.\n\t        // If the current element is `opt.terminator`, it means that this element has already been processed as parent so we can exit now.\n\t        if (opt.deep && opt.terminator && ((opt.terminator === this) || (opt.terminator === this.id))) { return this; }\n\n\t        var parentElement = this.getParentCell();\n\t        if (!parentElement || !parentElement.isElement()) { return this; }\n\n\t        // Get all children of parent element (i.e. this element + any sibling elements).\n\t        var siblingElements = parentElement.getEmbeddedCells().filter(function (cell) { return cell.isElement(); });\n\t        if (siblingElements.length === 0) { return this; }\n\n\t        this.startBatch('fit-parent', opt);\n\n\t        // Set new size and position of parent element, based on:\n\t        // - union of bboxes of all children of parent element (i.e. this element + any sibling elements)\n\t        // - inflated by given `opt.padding`\n\t        parentElement._fitToElements(Object.assign({ elements: siblingElements }, opt));\n\n\t        if (opt.deep) {\n\t            // `opt.deep = true` means \"fit all ancestors to their respective children\".\n\t            // As the last action of the fitting algorithm, recursively apply `fitParent()` on all ancestors.\n\t            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant (= this element), then go up.\n\t            parentElement.fitParent(opt);\n\t        }\n\n\t        this.stopBatch('fit-parent');\n\n\t        return this;\n\t    },\n\n\t    // Assumption: This element is part of a graph.\n\t    _fitToElements: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        var elementsBBox = this.graph.getCellsBBox(opt.elements);\n\t        // If no `opt.elements` were provided, do nothing.\n\t        if (!elementsBBox) { return; }\n\n\t        var expandOnly = opt.expandOnly;\n\t        var shrinkOnly = opt.shrinkOnly;\n\t        // This combination is meaningless, do nothing.\n\t        if (expandOnly && shrinkOnly) { return; }\n\n\t        // Calculate new size and position of this element based on:\n\t        // - union of bboxes of `opt.elements`\n\t        // - inflated by `opt.padding` (if not provided, all four properties = 0)\n\t        var x = elementsBBox.x;\n\t        var y = elementsBBox.y;\n\t        var width = elementsBBox.width;\n\t        var height = elementsBBox.height;\n\t        var ref = normalizeSides(opt.padding);\n\t        var left = ref.left;\n\t        var right = ref.right;\n\t        var top = ref.top;\n\t        var bottom = ref.bottom;\n\t        x -= left;\n\t        y -= top;\n\t        width += left + right;\n\t        height += bottom + top;\n\t        var resultBBox = new Rect(x, y, width, height);\n\n\t        if (expandOnly) {\n\t            // Non-shrinking is enforced by taking union of this element's current bbox with bbox calculated from `opt.elements`.\n\t            resultBBox = this.getBBox().union(resultBBox);\n\n\t        } else if (shrinkOnly) {\n\t            // Non-expansion is enforced by taking intersection of this element's current bbox with bbox calculated from `opt.elements`.\n\t            var intersectionBBox = this.getBBox().intersect(resultBBox);\n\t            // If all children are outside this element's current bbox, then `intersectionBBox` is `null` - does not make sense, do nothing.\n\t            if (!intersectionBBox) { return; }\n\n\t            resultBBox =  intersectionBBox;\n\t        }\n\n\t        // Set the new size and position of this element.\n\t        this.set({\n\t            position: { x: resultBBox.x, y: resultBBox.y },\n\t            size: { width: resultBBox.width, height: resultBBox.height }\n\t        }, opt);\n\t    },\n\n\t    // Rotate element by `angle` degrees, optionally around `origin` point.\n\t    // If `origin` is not provided, it is considered to be the center of the element.\n\t    // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n\t    // the difference from the previous angle.\n\t    rotate: function(angle, absolute, origin, opt) {\n\n\t        if (origin) {\n\n\t            var center = this.getBBox().center();\n\t            var size = this.get('size');\n\t            var position = this.get('position');\n\t            center.rotate(origin, this.get('angle') - angle);\n\t            var dx = center.x - size.width / 2 - position.x;\n\t            var dy = center.y - size.height / 2 - position.y;\n\t            this.startBatch('rotate', { angle: angle, absolute: absolute, origin: origin });\n\t            this.position(position.x + dx, position.y + dy, opt);\n\t            this.rotate(angle, absolute, null, opt);\n\t            this.stopBatch('rotate');\n\n\t        } else {\n\n\t            this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    angle: function() {\n\t        return normalizeAngle(this.get('angle') || 0);\n\t    },\n\n\t    getBBox: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        var ref = this;\n\t        var graph = ref.graph;\n\t        var attributes = ref.attributes;\n\t        var deep = opt.deep;\n\t        var rotate = opt.rotate;\n\n\t        if (deep && graph) {\n\t            // Get all the embedded elements using breadth first algorithm.\n\t            var elements = this.getEmbeddedCells({ deep: true, breadthFirst: true });\n\t            // Add the model itself.\n\t            elements.push(this);\n\t            // Note: the default of getCellsBBox() is rotate=true and can't be\n\t            // changed without a breaking change\n\t            return graph.getCellsBBox(elements, opt);\n\t        }\n\n\t        var angle = attributes.angle; if ( angle === void 0 ) angle = 0;\n\t        var attributes_position = attributes.position;\n\t        var x = attributes_position.x;\n\t        var y = attributes_position.y;\n\t        var attributes_size = attributes.size;\n\t        var width = attributes_size.width;\n\t        var height = attributes_size.height;\n\t        var bbox = new Rect(x, y, width, height);\n\t        if (rotate) {\n\t            bbox.rotateAroundCenter(angle);\n\t        }\n\t        return bbox;\n\t    },\n\n\t    getPointFromConnectedLink: function(link, endType) {\n\t        // Center of the model\n\t        var bbox = this.getBBox();\n\t        var center = bbox.center();\n\t        // Center of a port\n\t        var endDef = link.get(endType);\n\t        if (!endDef) { return center; }\n\t        var portId = endDef.port;\n\t        if (!portId || !this.hasPort(portId)) { return center; }\n\t        var portGroup = this.portProp(portId, ['group']);\n\t        var portsPositions = this.getPortsPositions(portGroup);\n\t        var portCenter = new Point(portsPositions[portId]).offset(bbox.origin());\n\t        var angle = this.angle();\n\t        if (angle) { portCenter.rotate(center, -angle); }\n\t        return portCenter;\n\t    }\n\t});\n\n\tassign(Element$1.prototype, elementPortPrototype);\n\n\tvar GraphCells = Backbone.Collection.extend({\n\n\t    initialize: function(models, opt) {\n\n\t        // Set the optional namespace where all model classes are defined.\n\t        if (opt.cellNamespace) {\n\t            this.cellNamespace = opt.cellNamespace;\n\t        } else {\n\t            /* eslint-disable no-undef */\n\t            this.cellNamespace = typeof joint !== 'undefined' && has$2(joint, 'shapes') ? joint.shapes : null;\n\t            /* eslint-enable no-undef */\n\t        }\n\n\n\t        this.graph = opt.graph;\n\t    },\n\n\t    model: function(attrs, opt) {\n\n\t        var collection = opt.collection;\n\t        var namespace = collection.cellNamespace;\n\n\t        // Find the model class in the namespace or use the default one.\n\t        var ModelClass = (attrs.type === 'link')\n\t            ? Link\n\t            : getByPath(namespace, attrs.type, '.') || Element$1;\n\n\t        var cell = new ModelClass(attrs, opt);\n\t        // Add a reference to the graph. It is necessary to do this here because this is the earliest place\n\t        // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.\n\t        if (!opt.dry) {\n\t            cell.graph = collection.graph;\n\t        }\n\n\t        return cell;\n\t    },\n\n\t    // `comparator` makes it easy to sort cells based on their `z` index.\n\t    comparator: function(model) {\n\n\t        return model.get('z') || 0;\n\t    }\n\t});\n\n\n\tvar Graph = Backbone.Model.extend({\n\n\t    initialize: function(attrs, opt) {\n\n\t        opt = opt || {};\n\n\t        // Passing `cellModel` function in the options object to graph allows for\n\t        // setting models based on attribute objects. This is especially handy\n\t        // when processing JSON graphs that are in a different than JointJS format.\n\t        var cells = new GraphCells([], {\n\t            model: opt.cellModel,\n\t            cellNamespace: opt.cellNamespace,\n\t            graph: this\n\t        });\n\t        Backbone.Model.prototype.set.call(this, 'cells', cells);\n\n\t        // Make all the events fired in the `cells` collection available.\n\t        // to the outside world.\n\t        cells.on('all', this.trigger, this);\n\n\t        // Backbone automatically doesn't trigger re-sort if models attributes are changed later when\n\t        // they're already in the collection. Therefore, we're triggering sort manually here.\n\t        this.on('change:z', this._sortOnChangeZ, this);\n\n\t        // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n\t        // for fast graph queries. All changes that affect the structure of the graph\n\t        // must be reflected in the `al` object. This object provides fast answers to\n\t        // questions such as \"what are the neighbours of this node\" or \"what\n\t        // are the sibling links of this link\".\n\n\t        // Outgoing edges per node. Note that we use a hash-table for the list\n\t        // of outgoing edges for a faster lookup.\n\t        // [nodeId] -> Object [edgeId] -> true\n\t        this._out = {};\n\t        // Ingoing edges per node.\n\t        // [nodeId] -> Object [edgeId] -> true\n\t        this._in = {};\n\t        // `_nodes` is useful for quick lookup of all the elements in the graph, without\n\t        // having to go through the whole cells array.\n\t        // [node ID] -> true\n\t        this._nodes = {};\n\t        // `_edges` is useful for quick lookup of all the links in the graph, without\n\t        // having to go through the whole cells array.\n\t        // [edgeId] -> true\n\t        this._edges = {};\n\n\t        this._batches = {};\n\n\t        cells.on('add', this._restructureOnAdd, this);\n\t        cells.on('remove', this._restructureOnRemove, this);\n\t        cells.on('reset', this._restructureOnReset, this);\n\t        cells.on('change:source', this._restructureOnChangeSource, this);\n\t        cells.on('change:target', this._restructureOnChangeTarget, this);\n\t        cells.on('remove', this._removeCell, this);\n\t    },\n\n\t    _sortOnChangeZ: function() {\n\n\t        this.get('cells').sort();\n\t    },\n\n\t    _restructureOnAdd: function(cell) {\n\n\t        if (cell.isLink()) {\n\t            this._edges[cell.id] = true;\n\t            var ref = cell.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\t            if (source.id) {\n\t                (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n\t            }\n\t            if (target.id) {\n\t                (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n\t            }\n\t        } else {\n\t            this._nodes[cell.id] = true;\n\t        }\n\t    },\n\n\t    _restructureOnRemove: function(cell) {\n\n\t        if (cell.isLink()) {\n\t            delete this._edges[cell.id];\n\t            var ref = cell.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\t            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n\t                delete this._out[source.id][cell.id];\n\t            }\n\t            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n\t                delete this._in[target.id][cell.id];\n\t            }\n\t        } else {\n\t            delete this._nodes[cell.id];\n\t        }\n\t    },\n\n\t    _restructureOnReset: function(cells) {\n\n\t        // Normalize into an array of cells. The original `cells` is GraphCells Backbone collection.\n\t        cells = cells.models;\n\n\t        this._out = {};\n\t        this._in = {};\n\t        this._nodes = {};\n\t        this._edges = {};\n\n\t        cells.forEach(this._restructureOnAdd, this);\n\t    },\n\n\t    _restructureOnChangeSource: function(link) {\n\n\t        var prevSource = link.previous('source');\n\t        if (prevSource.id && this._out[prevSource.id]) {\n\t            delete this._out[prevSource.id][link.id];\n\t        }\n\t        var source = link.attributes.source;\n\t        if (source.id) {\n\t            (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n\t        }\n\t    },\n\n\t    _restructureOnChangeTarget: function(link) {\n\n\t        var prevTarget = link.previous('target');\n\t        if (prevTarget.id && this._in[prevTarget.id]) {\n\t            delete this._in[prevTarget.id][link.id];\n\t        }\n\t        var target = link.get('target');\n\t        if (target.id) {\n\t            (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n\t        }\n\t    },\n\n\t    // Return all outbound edges for the node. Return value is an object\n\t    // of the form: [edgeId] -> true\n\t    getOutboundEdges: function(node) {\n\n\t        return (this._out && this._out[node]) || {};\n\t    },\n\n\t    // Return all inbound edges for the node. Return value is an object\n\t    // of the form: [edgeId] -> true\n\t    getInboundEdges: function(node) {\n\n\t        return (this._in && this._in[node]) || {};\n\t    },\n\n\t    toJSON: function() {\n\n\t        // Backbone does not recursively call `toJSON()` on attributes that are themselves models/collections.\n\t        // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n\t        var json = Backbone.Model.prototype.toJSON.apply(this, arguments);\n\t        json.cells = this.get('cells').toJSON();\n\t        return json;\n\t    },\n\n\t    fromJSON: function(json, opt) {\n\n\t        if (!json.cells) {\n\n\t            throw new Error('Graph JSON must contain cells array.');\n\t        }\n\n\t        return this.set(json, opt);\n\t    },\n\n\t    set: function(key, val, opt) {\n\n\t        var attrs;\n\n\t        // Handle both `key`, value and {key: value} style arguments.\n\t        if (typeof key === 'object') {\n\t            attrs = key;\n\t            opt = val;\n\t        } else {\n\t            (attrs = {})[key] = val;\n\t        }\n\n\t        // Make sure that `cells` attribute is handled separately via resetCells().\n\t        if (attrs.hasOwnProperty('cells')) {\n\t            this.resetCells(attrs.cells, opt);\n\t            attrs = omit(attrs, 'cells');\n\t        }\n\n\t        // The rest of the attributes are applied via original set method.\n\t        return Backbone.Model.prototype.set.call(this, attrs, opt);\n\t    },\n\n\t    clear: function(opt) {\n\n\t        opt = assign({}, opt, { clear: true });\n\n\t        var collection = this.get('cells');\n\n\t        if (collection.length === 0) { return this; }\n\n\t        this.startBatch('clear', opt);\n\n\t        // The elements come after the links.\n\t        var cells = collection.sortBy(function(cell) {\n\t            return cell.isLink() ? 1 : 2;\n\t        });\n\n\t        do {\n\n\t            // Remove all the cells one by one.\n\t            // Note that all the links are removed first, so it's\n\t            // safe to remove the elements without removing the connected\n\t            // links first.\n\t            cells.shift().remove(opt);\n\n\t        } while (cells.length > 0);\n\n\t        this.stopBatch('clear');\n\n\t        return this;\n\t    },\n\n\t    _prepareCell: function(cell, opt) {\n\n\t        var attrs;\n\t        if (cell instanceof Backbone.Model) {\n\t            attrs = cell.attributes;\n\t            if (!cell.graph && (!opt || !opt.dry)) {\n\t                // An element can not be member of more than one graph.\n\t                // A cell stops being the member of the graph after it's explicitly removed.\n\t                cell.graph = this;\n\t            }\n\t        } else {\n\t            // In case we're dealing with a plain JS object, we have to set the reference\n\t            // to the `graph` right after the actual model is created. This happens in the `model()` function\n\t            // of `joint.dia.GraphCells`.\n\t            attrs = cell;\n\t        }\n\n\t        if (!isString(attrs.type)) {\n\t            throw new TypeError('dia.Graph: cell type must be a string.');\n\t        }\n\n\t        return cell;\n\t    },\n\n\t    minZIndex: function() {\n\n\t        var firstCell = this.get('cells').first();\n\t        return firstCell ? (firstCell.get('z') || 0) : 0;\n\t    },\n\n\t    maxZIndex: function() {\n\n\t        var lastCell = this.get('cells').last();\n\t        return lastCell ? (lastCell.get('z') || 0) : 0;\n\t    },\n\n\t    addCell: function(cell, opt) {\n\n\t        if (Array.isArray(cell)) {\n\n\t            return this.addCells(cell, opt);\n\t        }\n\n\t        if (cell instanceof Backbone.Model) {\n\n\t            if (!cell.has('z')) {\n\t                cell.set('z', this.maxZIndex() + 1);\n\t            }\n\n\t        } else if (cell.z === undefined) {\n\n\t            cell.z = this.maxZIndex() + 1;\n\t        }\n\n\t        this.get('cells').add(this._prepareCell(cell, opt), opt || {});\n\n\t        return this;\n\t    },\n\n\t    addCells: function(cells, opt) {\n\n\t        if (cells.length === 0) { return this; }\n\n\t        cells = flattenDeep(cells);\n\t        opt.maxPosition = opt.position = cells.length - 1;\n\n\t        this.startBatch('add', opt);\n\t        cells.forEach(function(cell) {\n\t            this.addCell(cell, opt);\n\t            opt.position--;\n\t        }, this);\n\t        this.stopBatch('add', opt);\n\n\t        return this;\n\t    },\n\n\t    // When adding a lot of cells, it is much more efficient to\n\t    // reset the entire cells collection in one go.\n\t    // Useful for bulk operations and optimizations.\n\t    resetCells: function(cells, opt) {\n\n\t        var preparedCells = toArray(cells).map(function(cell) {\n\t            return this._prepareCell(cell, opt);\n\t        }, this);\n\t        this.get('cells').reset(preparedCells, opt);\n\n\t        return this;\n\t    },\n\n\t    removeCells: function(cells, opt) {\n\n\t        if (cells.length) {\n\n\t            this.startBatch('remove');\n\t            invoke(cells, 'remove', opt);\n\t            this.stopBatch('remove');\n\t        }\n\n\t        return this;\n\t    },\n\n\t    _removeCell: function(cell, collection, options) {\n\n\t        options = options || {};\n\n\t        if (!options.clear) {\n\t            // Applications might provide a `disconnectLinks` option set to `true` in order to\n\t            // disconnect links when a cell is removed rather then removing them. The default\n\t            // is to remove all the associated links.\n\t            if (options.disconnectLinks) {\n\n\t                this.disconnectLinks(cell, options);\n\n\t            } else {\n\n\t                this.removeLinks(cell, options);\n\t            }\n\t        }\n\t        // Silently remove the cell from the cells collection. Silently, because\n\t        // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n\t        // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n\t        // would be triggered on the graph model.\n\t        this.get('cells').remove(cell, { silent: true });\n\n\t        if (cell.graph === this) {\n\t            // Remove the element graph reference only if the cell is the member of this graph.\n\t            cell.graph = null;\n\t        }\n\t    },\n\n\t    // Get a cell by `id`.\n\t    getCell: function(id) {\n\n\t        return this.get('cells').get(id);\n\t    },\n\n\t    getCells: function() {\n\n\t        return this.get('cells').toArray();\n\t    },\n\n\t    getElements: function() {\n\n\t        return this.get('cells').filter(function (cell) { return cell.isElement(); });\n\t    },\n\n\t    getLinks: function() {\n\n\t        return this.get('cells').filter(function (cell) { return cell.isLink(); });\n\t    },\n\n\t    getFirstCell: function() {\n\n\t        return this.get('cells').first();\n\t    },\n\n\t    getLastCell: function() {\n\n\t        return this.get('cells').last();\n\t    },\n\n\t    // Get all inbound and outbound links connected to the cell `model`.\n\t    getConnectedLinks: function(model, opt) {\n\n\t        opt = opt || {};\n\n\t        var indirect = opt.indirect;\n\t        var inbound = opt.inbound;\n\t        var outbound = opt.outbound;\n\t        if ((inbound === undefined) && (outbound === undefined)) {\n\t            inbound = outbound = true;\n\t        }\n\n\t        // the final array of connected link models\n\t        var links = [];\n\t        // a hash table of connected edges of the form: [edgeId] -> true\n\t        // used for quick lookups to check if we already added a link\n\t        var edges = {};\n\n\t        if (outbound) {\n\t            addOutbounds(this, model);\n\t        }\n\t        if (inbound) {\n\t            addInbounds(this, model);\n\t        }\n\n\t        function addOutbounds(graph, model) {\n\t            forIn(graph.getOutboundEdges(model.id), function(_, edge) {\n\t                // skip links that were already added\n\t                // (those must be self-loop links)\n\t                // (because they are inbound and outbound edges of the same two elements)\n\t                if (edges[edge]) { return; }\n\t                var link = graph.getCell(edge);\n\t                links.push(link);\n\t                edges[edge] = true;\n\t                if (indirect) {\n\t                    if (inbound) { addInbounds(graph, link); }\n\t                    if (outbound) { addOutbounds(graph, link); }\n\t                }\n\t            }.bind(graph));\n\t            if (indirect && model.isLink()) {\n\t                var outCell = model.getTargetCell();\n\t                if (outCell && outCell.isLink()) {\n\t                    if (!edges[outCell.id]) {\n\t                        links.push(outCell);\n\t                        addOutbounds(graph, outCell);\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        function addInbounds(graph, model) {\n\t            forIn(graph.getInboundEdges(model.id), function(_, edge) {\n\t                // skip links that were already added\n\t                // (those must be self-loop links)\n\t                // (because they are inbound and outbound edges of the same two elements)\n\t                if (edges[edge]) { return; }\n\t                var link = graph.getCell(edge);\n\t                links.push(link);\n\t                edges[edge] = true;\n\t                if (indirect) {\n\t                    if (inbound) { addInbounds(graph, link); }\n\t                    if (outbound) { addOutbounds(graph, link); }\n\t                }\n\t            }.bind(graph));\n\t            if (indirect && model.isLink()) {\n\t                var inCell = model.getSourceCell();\n\t                if (inCell && inCell.isLink()) {\n\t                    if (!edges[inCell.id]) {\n\t                        links.push(inCell);\n\t                        addInbounds(graph, inCell);\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n\t        if (opt.deep) {\n\n\t            var embeddedCells = model.getEmbeddedCells({ deep: true });\n\n\t            // in the first round, we collect all the embedded elements\n\t            var embeddedElements = {};\n\t            embeddedCells.forEach(function(cell) {\n\t                if (cell.isElement()) {\n\t                    embeddedElements[cell.id] = true;\n\t                }\n\t            });\n\n\t            embeddedCells.forEach(function(cell) {\n\t                if (cell.isLink()) { return; }\n\t                if (outbound) {\n\t                    forIn(this.getOutboundEdges(cell.id), function(exists, edge) {\n\t                        if (!edges[edge]) {\n\t                            var edgeCell = this.getCell(edge);\n\t                            var ref = edgeCell.attributes;\n\t                            var source = ref.source;\n\t                            var target = ref.target;\n\t                            var sourceId = source.id;\n\t                            var targetId = target.id;\n\n\t                            // if `includeEnclosed` option is falsy, skip enclosed links\n\t                            if (!opt.includeEnclosed\n\t                                && (sourceId && embeddedElements[sourceId])\n\t                                && (targetId && embeddedElements[targetId])) {\n\t                                return;\n\t                            }\n\n\t                            links.push(this.getCell(edge));\n\t                            edges[edge] = true;\n\t                        }\n\t                    }.bind(this));\n\t                }\n\t                if (inbound) {\n\t                    forIn(this.getInboundEdges(cell.id), function(exists, edge) {\n\t                        if (!edges[edge]) {\n\t                            var edgeCell = this.getCell(edge);\n\t                            var ref = edgeCell.attributes;\n\t                            var source = ref.source;\n\t                            var target = ref.target;\n\t                            var sourceId = source.id;\n\t                            var targetId = target.id;\n\n\t                            // if `includeEnclosed` option is falsy, skip enclosed links\n\t                            if (!opt.includeEnclosed\n\t                                && (sourceId && embeddedElements[sourceId])\n\t                                && (targetId && embeddedElements[targetId])) {\n\t                                return;\n\t                            }\n\n\t                            links.push(this.getCell(edge));\n\t                            edges[edge] = true;\n\t                        }\n\t                    }.bind(this));\n\t                }\n\t            }, this);\n\t        }\n\n\t        return links;\n\t    },\n\n\t    getNeighbors: function(model, opt) {\n\n\t        opt || (opt = {});\n\n\t        var inbound = opt.inbound;\n\t        var outbound = opt.outbound;\n\t        if (inbound === undefined && outbound === undefined) {\n\t            inbound = outbound = true;\n\t        }\n\n\t        var neighbors = this.getConnectedLinks(model, opt).reduce(function(res, link) {\n\n\t            var ref = link.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\t            var loop = link.hasLoop(opt);\n\n\t            // Discard if it is a point, or if the neighbor was already added.\n\t            if (inbound && has$2(source, 'id') && !res[source.id]) {\n\n\t                var sourceElement = this.getCell(source.id);\n\t                if (sourceElement.isElement()) {\n\t                    if (loop || (sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model)))) {\n\t                        res[source.id] = sourceElement;\n\t                    }\n\t                }\n\t            }\n\n\t            // Discard if it is a point, or if the neighbor was already added.\n\t            if (outbound && has$2(target, 'id') && !res[target.id]) {\n\n\t                var targetElement = this.getCell(target.id);\n\t                if (targetElement.isElement()) {\n\t                    if (loop || (targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model)))) {\n\t                        res[target.id] = targetElement;\n\t                    }\n\t                }\n\t            }\n\n\t            return res;\n\t        }.bind(this), {});\n\n\t        if (model.isLink()) {\n\t            if (inbound) {\n\t                var sourceCell = model.getSourceCell();\n\t                if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n\t                    neighbors[sourceCell.id] = sourceCell;\n\t                }\n\t            }\n\t            if (outbound) {\n\t                var targetCell = model.getTargetCell();\n\t                if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n\t                    neighbors[targetCell.id] = targetCell;\n\t                }\n\t            }\n\t        }\n\n\t        return toArray(neighbors);\n\t    },\n\n\t    getCommonAncestor: function(/* cells */) {\n\n\t        var cellsAncestors = Array.from(arguments).map(function(cell) {\n\n\t            var ancestors = [];\n\t            var parentId = cell.get('parent');\n\n\t            while (parentId) {\n\n\t                ancestors.push(parentId);\n\t                parentId = this.getCell(parentId).get('parent');\n\t            }\n\n\t            return ancestors;\n\n\t        }, this);\n\n\t        cellsAncestors = cellsAncestors.sort(function(a, b) {\n\t            return a.length - b.length;\n\t        });\n\n\t        var commonAncestor = toArray(cellsAncestors.shift()).find(function(ancestor) {\n\t            return cellsAncestors.every(function(cellAncestors) {\n\t                return cellAncestors.includes(ancestor);\n\t            });\n\t        });\n\n\t        return this.getCell(commonAncestor);\n\t    },\n\n\t    // Find the whole branch starting at `element`.\n\t    // If `opt.deep` is `true`, take into account embedded elements too.\n\t    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n\t    getSuccessors: function(element, opt) {\n\n\t        opt = opt || {};\n\t        var res = [];\n\t        // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n\t        this.search(element, function(el) {\n\t            if (el !== element) {\n\t                res.push(el);\n\t            }\n\t        }, assign({}, opt, { outbound: true }));\n\t        return res;\n\t    },\n\n\t    cloneCells: cloneCells,\n\t    // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n\t    // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n\t    // Return a map of the form: [original cell ID] -> [clone].\n\t    cloneSubgraph: function(cells, opt) {\n\n\t        var subgraph = this.getSubgraph(cells, opt);\n\t        return this.cloneCells(subgraph);\n\t    },\n\n\t    // Return `cells` and all the connected links that connect cells in the `cells` array.\n\t    // If `opt.deep` is `true`, return all the cells including all their embedded cells\n\t    // and all the links that connect any of the returned cells.\n\t    // For example, for a single shallow element, the result is that very same element.\n\t    // For two elements connected with a link: `A --- L ---> B`, the result for\n\t    // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n\t    getSubgraph: function(cells, opt) {\n\n\t        opt = opt || {};\n\n\t        var subgraph = [];\n\t        // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n\t        var cellMap = {};\n\t        var elements = [];\n\t        var links = [];\n\n\t        toArray(cells).forEach(function(cell) {\n\t            if (!cellMap[cell.id]) {\n\t                subgraph.push(cell);\n\t                cellMap[cell.id] = cell;\n\t                if (cell.isLink()) {\n\t                    links.push(cell);\n\t                } else {\n\t                    elements.push(cell);\n\t                }\n\t            }\n\n\t            if (opt.deep) {\n\t                var embeds = cell.getEmbeddedCells({ deep: true });\n\t                embeds.forEach(function(embed) {\n\t                    if (!cellMap[embed.id]) {\n\t                        subgraph.push(embed);\n\t                        cellMap[embed.id] = embed;\n\t                        if (embed.isLink()) {\n\t                            links.push(embed);\n\t                        } else {\n\t                            elements.push(embed);\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t        });\n\n\t        links.forEach(function(link) {\n\t            // For links, return their source & target (if they are elements - not points).\n\t            var ref = link.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\t            if (source.id && !cellMap[source.id]) {\n\t                var sourceElement = this.getCell(source.id);\n\t                subgraph.push(sourceElement);\n\t                cellMap[sourceElement.id] = sourceElement;\n\t                elements.push(sourceElement);\n\t            }\n\t            if (target.id && !cellMap[target.id]) {\n\t                var targetElement = this.getCell(target.id);\n\t                subgraph.push(this.getCell(target.id));\n\t                cellMap[targetElement.id] = targetElement;\n\t                elements.push(targetElement);\n\t            }\n\t        }, this);\n\n\t        elements.forEach(function(element) {\n\t            // For elements, include their connected links if their source/target is in the subgraph;\n\t            var links = this.getConnectedLinks(element, opt);\n\t            links.forEach(function(link) {\n\t                var ref = link.attributes;\n\t                var source = ref.source;\n\t                var target = ref.target;\n\t                if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n\t                    subgraph.push(link);\n\t                    cellMap[link.id] = link;\n\t                }\n\t            });\n\t        }, this);\n\n\t        return subgraph;\n\t    },\n\n\t    // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n\t    // If `opt.deep` is `true`, take into account embedded elements too.\n\t    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n\t    getPredecessors: function(element, opt) {\n\n\t        opt = opt || {};\n\t        var res = [];\n\t        // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n\t        this.search(element, function(el) {\n\t            if (el !== element) {\n\t                res.push(el);\n\t            }\n\t        }, assign({}, opt, { inbound: true }));\n\t        return res;\n\t    },\n\n\t    // Perform search on the graph.\n\t    // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n\t    // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n\t    // If `opt.deep` is `true`, take into account embedded elements too.\n\t    // `iteratee` is a function of the form `function(element) {}`.\n\t    // If `iteratee` explicitly returns `false`, the searching stops.\n\t    search: function(element, iteratee, opt) {\n\n\t        opt = opt || {};\n\t        if (opt.breadthFirst) {\n\t            this.bfs(element, iteratee, opt);\n\t        } else {\n\t            this.dfs(element, iteratee, opt);\n\t        }\n\t    },\n\n\t    // Breadth-first search.\n\t    // If `opt.deep` is `true`, take into account embedded elements too.\n\t    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n\t    // `iteratee` is a function of the form `function(element, distance) {}`.\n\t    // where `element` is the currently visited element and `distance` is the distance of that element\n\t    // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n\t    // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n\t    // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n\t    // If `iteratee` explicitly returns `false`, the searching stops.\n\t    bfs: function(element, iteratee, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        var visited = {};\n\t        var distance = {};\n\t        var queue = [];\n\n\t        queue.push(element);\n\t        distance[element.id] = 0;\n\n\t        while (queue.length > 0) {\n\t            var next = queue.shift();\n\t            if (visited[next.id]) { continue; }\n\t            visited[next.id] = true;\n\t            if (iteratee.call(this, next, distance[next.id]) === false) { continue; }\n\t            var neighbors = this.getNeighbors(next, opt);\n\t            for (var i = 0, n = neighbors.length; i < n; i++) {\n\t                var neighbor = neighbors[i];\n\t                distance[neighbor.id] = distance[next.id] + 1;\n\t                queue.push(neighbor);\n\t            }\n\t        }\n\t    },\n\n\t    // Depth-first search.\n\t    // If `opt.deep` is `true`, take into account embedded elements too.\n\t    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n\t    // `iteratee` is a function of the form `function(element, distance) {}`.\n\t    // If `iteratee` explicitly returns `false`, the search stops.\n\t    dfs: function(element, iteratee, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        var visited = {};\n\t        var distance = {};\n\t        var queue = [];\n\n\t        queue.push(element);\n\t        distance[element.id] = 0;\n\n\t        while (queue.length > 0) {\n\t            var next = queue.pop();\n\t            if (visited[next.id]) { continue; }\n\t            visited[next.id] = true;\n\t            if (iteratee.call(this, next, distance[next.id]) === false) { continue; }\n\t            var neighbors = this.getNeighbors(next, opt);\n\t            var lastIndex = queue.length;\n\t            for (var i = 0, n = neighbors.length; i < n; i++) {\n\t                var neighbor = neighbors[i];\n\t                distance[neighbor.id] = distance[next.id] + 1;\n\t                queue.splice(lastIndex, 0, neighbor);\n\t            }\n\t        }\n\t    },\n\n\t    // Get all the roots of the graph. Time complexity: O(|V|).\n\t    getSources: function() {\n\n\t        var sources = [];\n\t        forIn(this._nodes, function(exists, node) {\n\t            if (!this._in[node] || isEmpty(this._in[node])) {\n\t                sources.push(this.getCell(node));\n\t            }\n\t        }.bind(this));\n\t        return sources;\n\t    },\n\n\t    // Get all the leafs of the graph. Time complexity: O(|V|).\n\t    getSinks: function() {\n\n\t        var sinks = [];\n\t        forIn(this._nodes, function(exists, node) {\n\t            if (!this._out[node] || isEmpty(this._out[node])) {\n\t                sinks.push(this.getCell(node));\n\t            }\n\t        }.bind(this));\n\t        return sinks;\n\t    },\n\n\t    // Return `true` if `element` is a root. Time complexity: O(1).\n\t    isSource: function(element) {\n\n\t        return !this._in[element.id] || isEmpty(this._in[element.id]);\n\t    },\n\n\t    // Return `true` if `element` is a leaf. Time complexity: O(1).\n\t    isSink: function(element) {\n\n\t        return !this._out[element.id] || isEmpty(this._out[element.id]);\n\t    },\n\n\t    // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n\t    isSuccessor: function(elementA, elementB) {\n\n\t        var isSuccessor = false;\n\t        this.search(elementA, function(element) {\n\t            if (element === elementB && element !== elementA) {\n\t                isSuccessor = true;\n\t                return false;\n\t            }\n\t        }, { outbound: true });\n\t        return isSuccessor;\n\t    },\n\n\t    // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n\t    isPredecessor: function(elementA, elementB) {\n\n\t        var isPredecessor = false;\n\t        this.search(elementA, function(element) {\n\t            if (element === elementB && element !== elementA) {\n\t                isPredecessor = true;\n\t                return false;\n\t            }\n\t        }, { inbound: true });\n\t        return isPredecessor;\n\t    },\n\n\t    // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n\t    // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n\t    // for more details.\n\t    // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n\t    // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n\t    isNeighbor: function(elementA, elementB, opt) {\n\n\t        opt = opt || {};\n\n\t        var inbound = opt.inbound;\n\t        var outbound = opt.outbound;\n\t        if ((inbound === undefined) && (outbound === undefined)) {\n\t            inbound = outbound = true;\n\t        }\n\n\t        var isNeighbor = false;\n\n\t        this.getConnectedLinks(elementA, opt).forEach(function(link) {\n\n\t            var ref = link.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\n\t            // Discard if it is a point.\n\t            if (inbound && has$2(source, 'id') && (source.id === elementB.id)) {\n\t                isNeighbor = true;\n\t                return false;\n\t            }\n\n\t            // Discard if it is a point, or if the neighbor was already added.\n\t            if (outbound && has$2(target, 'id') && (target.id === elementB.id)) {\n\t                isNeighbor = true;\n\t                return false;\n\t            }\n\t        });\n\n\t        return isNeighbor;\n\t    },\n\n\t    // Disconnect links connected to the cell `model`.\n\t    disconnectLinks: function(model, opt) {\n\n\t        this.getConnectedLinks(model).forEach(function(link) {\n\n\t            link.set((link.attributes.source.id === model.id ? 'source' : 'target'), { x: 0, y: 0 }, opt);\n\t        });\n\t    },\n\n\t    // Remove links connected to the cell `model` completely.\n\t    removeLinks: function(model, opt) {\n\n\t        invoke(this.getConnectedLinks(model), 'remove', opt);\n\t    },\n\n\t    // Find all elements at given point\n\t    findModelsFromPoint: function(p) {\n\t        return this.getElements().filter(function (el) { return el.getBBox({ rotate: true }).containsPoint(p); });\n\t    },\n\n\t    // Find all elements in given area\n\t    findModelsInArea: function(rect, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        var r = new Rect(rect);\n\t        var strict = opt.strict; if ( strict === void 0 ) strict = false;\n\t        var method = strict ? 'containsRect' : 'intersect';\n\t        return this.getElements().filter(function (el) { return r[method](el.getBBox({ rotate: true })); });\n\t    },\n\n\t    // Find all elements under the given element.\n\t    findModelsUnderElement: function(element, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        var searchBy = opt.searchBy; if ( searchBy === void 0 ) searchBy = 'bbox';\n\t        var bbox = element.getBBox().rotateAroundCenter(element.angle());\n\t        var elements = (searchBy === 'bbox')\n\t            ? this.findModelsInArea(bbox)\n\t            : this.findModelsFromPoint(getRectPoint(bbox, searchBy));\n\t        // don't account element itself or any of its descendants\n\t        return elements.filter(function (el) { return element.id !== el.id && !el.isEmbeddedIn(element); });\n\t    },\n\n\t    // Return bounding box of all elements.\n\t    getBBox: function() {\n\n\t        return this.getCellsBBox(this.getCells());\n\t    },\n\n\t    // Return the bounding box of all cells in array provided.\n\t    getCellsBBox: function(cells, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        var rotate = opt.rotate; if ( rotate === void 0 ) rotate = true;\n\t        return toArray(cells).reduce(function(memo, cell) {\n\t            var rect = cell.getBBox({ rotate: rotate });\n\t            if (!rect) { return memo; }\n\t            if (memo) {\n\t                return memo.union(rect);\n\t            }\n\t            return rect;\n\t        }, null);\n\t    },\n\n\t    translate: function(dx, dy, opt) {\n\n\t        // Don't translate cells that are embedded in any other cell.\n\t        var cells = this.getCells().filter(function(cell) {\n\t            return !cell.isEmbedded();\n\t        });\n\n\t        invoke(cells, 'translate', dx, dy, opt);\n\n\t        return this;\n\t    },\n\n\t    resize: function(width, height, opt) {\n\n\t        return this.resizeCells(width, height, this.getCells(), opt);\n\t    },\n\n\t    resizeCells: function(width, height, cells, opt) {\n\n\t        // `getBBox` method returns `null` if no elements provided.\n\t        // i.e. cells can be an array of links\n\t        var bbox = this.getCellsBBox(cells);\n\t        if (bbox) {\n\t            var sx = Math.max(width / bbox.width, 0);\n\t            var sy = Math.max(height / bbox.height, 0);\n\t            invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    startBatch: function(name, data) {\n\n\t        data = data || {};\n\t        this._batches[name] = (this._batches[name] || 0) + 1;\n\n\t        return this.trigger('batch:start', assign({}, data, { batchName: name }));\n\t    },\n\n\t    stopBatch: function(name, data) {\n\n\t        data = data || {};\n\t        this._batches[name] = (this._batches[name] || 0) - 1;\n\n\t        return this.trigger('batch:stop', assign({}, data, { batchName: name }));\n\t    },\n\n\t    hasActiveBatch: function(name) {\n\n\t        var batches = this._batches;\n\t        var names;\n\n\t        if (arguments.length === 0) {\n\t            names = Object.keys(batches);\n\t        } else if (Array.isArray(name)) {\n\t            names = name;\n\t        } else {\n\t            names = [name];\n\t        }\n\n\t        return names.some(function (batch) { return batches[batch] > 0; });\n\t    }\n\n\t}, {\n\n\t    validations: {\n\n\t        multiLinks: function(graph, link) {\n\n\t            // Do not allow multiple links to have the same source and target.\n\t            var ref = link.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\n\t            if (source.id && target.id) {\n\n\t                var sourceModel = link.getSourceCell();\n\t                if (sourceModel) {\n\n\t                    var connectedLinks = graph.getConnectedLinks(sourceModel, { outbound: true });\n\t                    var sameLinks = connectedLinks.filter(function(_link) {\n\n\t                        var ref = _link.attributes;\n\t                        var _source = ref.source;\n\t                        var _target = ref.target;\n\t                        return _source && _source.id === source.id &&\n\t                            (!_source.port || (_source.port === source.port)) &&\n\t                            _target && _target.id === target.id &&\n\t                            (!_target.port || (_target.port === target.port));\n\n\t                    });\n\n\t                    if (sameLinks.length > 1) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\n\t            return true;\n\t        },\n\n\t        linkPinning: function(_graph, link) {\n\t            var ref = link.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\t            return source.id && target.id;\n\t        }\n\t    }\n\n\t});\n\n\twrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);\n\n\tvar views = {};\n\n\tvar View = Backbone.View.extend({\n\n\t    options: {},\n\t    theme: null,\n\t    themeClassNamePrefix: addClassNamePrefix('theme-'),\n\t    requireSetThemeOverride: false,\n\t    defaultTheme: config.defaultTheme,\n\t    children: null,\n\t    childNodes: null,\n\n\t    DETACHABLE: true,\n\t    UPDATE_PRIORITY: 2,\n\t    FLAG_INSERT: 1<<30,\n\t    FLAG_REMOVE: 1<<29,\n\t    FLAG_INIT: 1<<28,\n\n\t    constructor: function(options) {\n\n\t        this.requireSetThemeOverride = options && !!options.theme;\n\t        this.options = assign({}, this.options, options);\n\n\t        Backbone.View.call(this, options);\n\t    },\n\n\t    initialize: function() {\n\n\t        views[this.cid] = this;\n\n\t        this.setTheme(this.options.theme || this.defaultTheme);\n\t        this.init();\n\t    },\n\n\t    unmount: function() {\n\t        if (this.svgElement) {\n\t            this.vel.remove();\n\t        } else {\n\t            this.$el.remove();\n\t        }\n\t    },\n\n\t    isMounted: function() {\n\t        return this.el.parentNode !== null;\n\t    },\n\n\t    renderChildren: function(children) {\n\t        children || (children = result(this, 'children'));\n\t        if (children) {\n\t            var isSVG = this.svgElement;\n\t            var namespace = V.namespace[isSVG ? 'svg' : 'xhtml'];\n\t            var doc = parseDOMJSON(children, namespace);\n\t            (isSVG ? this.vel : this.$el).empty().append(doc.fragment);\n\t            this.childNodes = doc.selectors;\n\t        }\n\t        return this;\n\t    },\n\n\t    findAttribute: function(attributeName, node) {\n\n\t        var currentNode = node;\n\n\t        while (currentNode && currentNode.nodeType === 1) {\n\t            var attributeValue = currentNode.getAttribute(attributeName);\n\t            // attribute found\n\t            if (attributeValue) { return attributeValue; }\n\t            // do not climb up the DOM\n\t            if (currentNode === this.el) { return null; }\n\t            // try parent node\n\t            currentNode = currentNode.parentNode;\n\t        }\n\n\t        return null;\n\t    },\n\n\t    // Override the Backbone `_ensureElement()` method in order to create an\n\t    // svg element (e.g., `<g>`) node that wraps all the nodes of the Cell view.\n\t    // Expose class name setter as a separate method.\n\t    _ensureElement: function() {\n\t        if (!this.el) {\n\t            var tagName = result(this, 'tagName');\n\t            var attrs = assign({}, result(this, 'attributes'));\n\t            var style = assign({}, result(this, 'style'));\n\t            if (this.id) { attrs.id = result(this, 'id'); }\n\t            this.setElement(this._createElement(tagName));\n\t            this._setAttributes(attrs);\n\t            this._setStyle(style);\n\t        } else {\n\t            this.setElement(result(this, 'el'));\n\t        }\n\t        this._ensureElClassName();\n\t    },\n\n\t    _setAttributes: function(attrs) {\n\t        if (this.svgElement) {\n\t            this.vel.attr(attrs);\n\t        } else {\n\t            this.$el.attr(attrs);\n\t        }\n\t    },\n\n\t    _setStyle: function(style) {\n\t        this.$el.css(style);\n\t    },\n\n\t    _createElement: function(tagName) {\n\t        if (this.svgElement) {\n\t            return document.createElementNS(V.namespace.svg, tagName);\n\t        } else {\n\t            return document.createElement(tagName);\n\t        }\n\t    },\n\n\t    // Utilize an alternative DOM manipulation API by\n\t    // adding an element reference wrapped in Vectorizer.\n\t    _setElement: function(el) {\n\t        this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);\n\t        this.el = this.$el[0];\n\t        if (this.svgElement) { this.vel = V(this.el); }\n\t    },\n\n\t    _ensureElClassName: function() {\n\t        var className = result(this, 'className');\n\t        if (!className) { return; }\n\t        var prefixedClassName = addClassNamePrefix(className);\n\t        // Note: className removal here kept for backwards compatibility only\n\t        if (this.svgElement) {\n\t            this.vel.removeClass(className).addClass(prefixedClassName);\n\t        } else {\n\t            this.$el.removeClass(className).addClass(prefixedClassName);\n\t        }\n\t    },\n\n\t    init: function() {\n\t        // Intentionally empty.\n\t        // This method is meant to be overridden.\n\t    },\n\n\t    onRender: function() {\n\t        // Intentionally empty.\n\t        // This method is meant to be overridden.\n\t    },\n\n\t    confirmUpdate: function() {\n\t        // Intentionally empty.\n\t        // This method is meant to be overridden.\n\t        return 0;\n\t    },\n\n\t    setTheme: function(theme, opt) {\n\n\t        opt = opt || {};\n\n\t        // Theme is already set, override is required, and override has not been set.\n\t        // Don't set the theme.\n\t        if (this.theme && this.requireSetThemeOverride && !opt.override) {\n\t            return this;\n\t        }\n\n\t        this.removeThemeClassName();\n\t        this.addThemeClassName(theme);\n\t        this.onSetTheme(this.theme/* oldTheme */, theme/* newTheme */);\n\t        this.theme = theme;\n\n\t        return this;\n\t    },\n\n\t    addThemeClassName: function(theme) {\n\n\t        theme = theme || this.theme;\n\t        if (!theme) { return this; }\n\n\t        var className = this.themeClassNamePrefix + theme;\n\n\t        if (this.svgElement) {\n\t            this.vel.addClass(className);\n\t        } else {\n\t            this.$el.addClass(className);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    removeThemeClassName: function(theme) {\n\n\t        theme = theme || this.theme;\n\n\t        var className = this.themeClassNamePrefix + theme;\n\n\t        if (this.svgElement) {\n\t            this.vel.removeClass(className);\n\t        } else {\n\t            this.$el.removeClass(className);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    onSetTheme: function(oldTheme, newTheme) {\n\t        // Intentionally empty.\n\t        // This method is meant to be overridden.\n\t    },\n\n\t    remove: function() {\n\n\t        this.onRemove();\n\t        this.undelegateDocumentEvents();\n\n\t        views[this.cid] = null;\n\n\t        Backbone.View.prototype.remove.apply(this, arguments);\n\n\t        return this;\n\t    },\n\n\t    onRemove: function() {\n\t        // Intentionally empty.\n\t        // This method is meant to be overridden.\n\t    },\n\n\t    getEventNamespace: function() {\n\t        // Returns a per-session unique namespace\n\t        return '.joint-event-ns-' + this.cid;\n\t    },\n\n\t    delegateElementEvents: function(element, events, data) {\n\t        if (!events) { return this; }\n\t        data || (data = {});\n\t        var eventNS = this.getEventNamespace();\n\t        for (var eventName in events) {\n\t            var method = events[eventName];\n\t            if (typeof method !== 'function') { method = this[method]; }\n\t            if (!method) { continue; }\n\t            $(element).on(eventName + eventNS, data, method.bind(this));\n\t        }\n\t        return this;\n\t    },\n\n\t    undelegateElementEvents: function(element) {\n\t        $(element).off(this.getEventNamespace());\n\t        return this;\n\t    },\n\n\t    delegateDocumentEvents: function(events, data) {\n\t        events || (events = result(this, 'documentEvents'));\n\t        return this.delegateElementEvents(document, events, data);\n\t    },\n\n\t    undelegateDocumentEvents: function() {\n\t        return this.undelegateElementEvents(document);\n\t    },\n\n\t    eventData: function(evt, data) {\n\t        if (!evt) { throw new Error('eventData(): event object required.'); }\n\t        var currentData = evt.data;\n\t        var key = '__' + this.cid + '__';\n\t        if (data === undefined) {\n\t            if (!currentData) { return {}; }\n\t            return currentData[key] || {};\n\t        }\n\t        currentData || (currentData = evt.data = {});\n\t        currentData[key] || (currentData[key] = {});\n\t        assign(currentData[key], data);\n\t        return this;\n\t    },\n\n\t    stopPropagation: function(evt) {\n\t        this.eventData(evt, { propagationStopped: true });\n\t        return this;\n\t    },\n\n\t    isPropagationStopped: function(evt) {\n\t        return !!this.eventData(evt).propagationStopped;\n\t    }\n\n\t}, {\n\n\t    extend: function() {\n\n\t        var args = Array.from(arguments);\n\n\t        // Deep clone the prototype and static properties objects.\n\t        // This prevents unexpected behavior where some properties are overwritten outside of this function.\n\t        var protoProps = args[0] && assign({}, args[0]) || {};\n\t        var staticProps = args[1] && assign({}, args[1]) || {};\n\n\t        // Need the real render method so that we can wrap it and call it later.\n\t        var renderFn = protoProps.render || (this.prototype && this.prototype.render) || null;\n\n\t        /*\n\t            Wrap the real render method so that:\n\t                .. `onRender` is always called.\n\t                .. `this` is always returned.\n\t        */\n\t        protoProps.render = function() {\n\n\t            if (typeof renderFn === 'function') {\n\t                // Call the original render method.\n\t                renderFn.apply(this, arguments);\n\t            }\n\n\t            if (this.render.__render__ === renderFn) {\n\t                // Should always call onRender() method.\n\t                // Should call it only once when renderFn is actual prototype method i.e. not the wrapper\n\t                this.onRender();\n\t            }\n\n\t            // Should always return itself.\n\t            return this;\n\t        };\n\n\t        protoProps.render.__render__ = renderFn;\n\n\t        return Backbone.View.extend.call(this, protoProps, staticProps);\n\t    }\n\t});\n\n\tvar DoubleTapEventName = 'dbltap';\n\tif ($.event && !(DoubleTapEventName in $.event.special)) {\n\t    var maxDelay = config.doubleTapInterval;\n\t    var minDelay = 30;\n\t    $.event.special[DoubleTapEventName] = {\n\t        bindType: 'touchend',\n\t        delegateType: 'touchend',\n\t        handle: function(event) {\n\t            var ref;\n\n\t            var args = [], len = arguments.length - 1;\n\t            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\t            var handleObj = event.handleObj;\n\t            var target = event.target;\n\t            var targetData  = $.data(target);\n\t            var now = new Date().getTime();\n\t            var delta = 'lastTouch' in targetData ? now - targetData.lastTouch : 0;\n\t            if (delta < maxDelay && delta > minDelay) {\n\t                targetData.lastTouch = null;\n\t                event.type = handleObj.origType;\n\t                // let jQuery handle the triggering of \"dbltap\" event handlers\n\t                (ref = handleObj.handler).call.apply(ref, [ this, event ].concat( args ));\n\t            } else {\n\t                targetData.lastTouch = now;\n\t            }\n\t        }\n\t    };\n\t}\n\n\tvar Listener = function Listener() {\n\t    var callbackArguments = [], len = arguments.length;\n\t    while ( len-- ) callbackArguments[ len ] = arguments[ len ];\n\n\t    this.callbackArguments = callbackArguments;\n\t};\n\n\tListener.prototype.listenTo = function listenTo (object, evt) {\n\t        var this$1 = this;\n\t        var args = [], len = arguments.length - 2;\n\t        while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];\n\n\t    var ref = this;\n\t        var callbackArguments = ref.callbackArguments;\n\t    // signature 1 - (object, eventHashMap, context)\n\t    if (V.isObject(evt)) {\n\t        var context = args[0]; if ( context === void 0 ) context = null;\n\t        Object.entries(evt).forEach(function (ref) {\n\t                var eventName = ref[0];\n\t                var cb = ref[1];\n\n\t            if (typeof cb !== 'function') { return; }\n\t            // Invoke the callback with callbackArguments passed first\n\t            if (context || callbackArguments.length > 0) { cb = cb.bind.apply(cb, [ context ].concat( callbackArguments )); }\n\t            Backbone.Events.listenTo.call(this$1, object, eventName, cb);\n\t        });\n\t    }\n\t    // signature 2 - (object, event, callback, context)\n\t    else if (typeof evt === 'string' && typeof args[0] === 'function') {\n\t        var cb = args[0];\n\t            var context$1 = args[1]; if ( context$1 === void 0 ) context$1 = null;\n\t        // Invoke the callback with callbackArguments passed first\n\t        if (context$1 || callbackArguments.length > 0) { cb = cb.bind.apply(cb, [ context$1 ].concat( callbackArguments )); }\n\t        Backbone.Events.listenTo.call(this, object, evt, cb);\n\t    }\n\t};\n\n\tListener.prototype.stopListening = function stopListening () {\n\t    Backbone.Events.stopListening.call(this);\n\t};\n\n\n\n\tvar index$1 = ({\n\t\tviews: views,\n\t\tView: View,\n\t\tListener: Listener\n\t});\n\n\tvar LayersNames = {\n\t    CELLS: 'cells',\n\t    BACK: 'back',\n\t    FRONT: 'front',\n\t    TOOLS: 'tools',\n\t    LABELS: 'labels'\n\t};\n\n\tvar PaperLayer = View.extend({\n\n\t    tagName: 'g',\n\t    svgElement: true,\n\t    pivotNodes: null,\n\t    defaultTheme: null,\n\n\t    options: {\n\t        name: ''\n\t    },\n\n\t    className: function() {\n\t        return addClassNamePrefix(((this.options.name) + \"-layer\"));\n\t    },\n\n\t    init: function() {\n\t        this.pivotNodes = {};\n\t    },\n\n\t    insertSortedNode: function(node, z) {\n\t        this.el.insertBefore(node, this.insertPivot(z));\n\t    },\n\n\t    insertNode: function(node) {\n\t        var ref = this;\n\t        var el = ref.el;\n\t        if (node.parentNode !== el) {\n\t            el.appendChild(node);\n\t        }\n\t    },\n\n\t    insertPivot: function(z) {\n\t        var ref = this;\n\t        var el = ref.el;\n\t        var pivotNodes = ref.pivotNodes;\n\t        z = +z;\n\t        z || (z = 0);\n\t        var pivotNode = pivotNodes[z];\n\t        if (pivotNode) { return pivotNode; }\n\t        pivotNode = pivotNodes[z] = document.createComment('z-index:' + (z + 1));\n\t        var neighborZ = -Infinity;\n\t        for (var currentZ in pivotNodes) {\n\t            currentZ = +currentZ;\n\t            if (currentZ < z && currentZ > neighborZ) {\n\t                neighborZ = currentZ;\n\t                if (neighborZ === z - 1) { continue; }\n\t            }\n\t        }\n\t        if (neighborZ !== -Infinity) {\n\t            var neighborPivot = pivotNodes[neighborZ];\n\t            // Insert After\n\t            el.insertBefore(pivotNode, neighborPivot.nextSibling);\n\t        } else {\n\t            // First Child\n\t            el.insertBefore(pivotNode, el.firstChild);\n\t        }\n\t        return pivotNode;\n\t    },\n\n\t    removePivots: function() {\n\t        var ref = this;\n\t        var el = ref.el;\n\t        var pivotNodes = ref.pivotNodes;\n\t        for (var z in pivotNodes) { el.removeChild(pivotNodes[z]); }\n\t        this.pivotNodes = {};\n\t    }\n\n\t});\n\n\tfunction toArray$1(obj) {\n\t    if (!obj) { return []; }\n\t    if (Array.isArray(obj)) { return obj; }\n\t    return [obj];\n\t}\n\n\tvar HighlighterView = View.extend({\n\n\t    tagName: 'g',\n\t    svgElement: true,\n\t    className: 'highlight',\n\n\t    HIGHLIGHT_FLAG: 1,\n\t    UPDATE_PRIORITY: 3,\n\t    DETACHABLE: false,\n\t    UPDATABLE: true,\n\t    MOUNTABLE: true,\n\n\t    cellView: null,\n\t    nodeSelector: null,\n\t    node: null,\n\t    updateRequested: false,\n\t    transformGroup: null,\n\t    detachedTransformGroup: null,\n\n\t    requestUpdate: function requestUpdate(cellView, nodeSelector) {\n\t        var paper = cellView.paper;\n\t        this.cellView = cellView;\n\t        this.nodeSelector = nodeSelector;\n\t        if (paper) {\n\t            this.updateRequested = true;\n\t            paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n\t        }\n\t    },\n\n\t    confirmUpdate: function confirmUpdate() {\n\t        // The cellView is now rendered/updated since it has a higher update priority.\n\t        this.updateRequested = false;\n\t        var ref = this;\n\t        var cellView = ref.cellView;\n\t        var nodeSelector = ref.nodeSelector;\n\t        this.update(cellView, nodeSelector);\n\t        this.mount();\n\t        this.transform();\n\t        return 0;\n\t    },\n\n\t    findNode: function findNode(cellView, nodeSelector) {\n\t        var assign, assign$1;\n\n\t        if ( nodeSelector === void 0 ) nodeSelector = null;\n\t        var el;\n\t        if (typeof nodeSelector === 'string') {\n\t            (assign = cellView.findBySelector(nodeSelector), el = assign[0]);\n\t        } else if (isPlainObject(nodeSelector)) {\n\t            var isLink = cellView.model.isLink();\n\t            var label = nodeSelector.label; if ( label === void 0 ) label = null;\n\t            var port = nodeSelector.port;\n\t            var selector = nodeSelector.selector;\n\t            if (isLink && label !== null) {\n\t                // Link Label Selector\n\t                el = cellView.findLabelNode(label, selector);\n\t            } else if (!isLink && port) {\n\t                // Element Port Selector\n\t                el = cellView.findPortNode(port, selector);\n\t            } else {\n\t                // Cell Selector\n\t                (assign$1 = cellView.findBySelector(selector), el = assign$1[0]);\n\t            }\n\t        } else if (nodeSelector) {\n\t            el = V.toNode(nodeSelector);\n\t            if (!(el instanceof SVGElement)) { el = null; }\n\t        }\n\t        return el ? el : null;\n\t    },\n\n\t    getNodeMatrix: function getNodeMatrix(cellView, node) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var layer = options.layer;\n\t        var rotatableNode = cellView.rotatableNode;\n\t        var nodeMatrix = cellView.getNodeMatrix(node);\n\t        if (rotatableNode) {\n\t            if (layer) {\n\t                if (rotatableNode.contains(node)) {\n\t                    return nodeMatrix;\n\t                }\n\t                // The node is outside of the rotatable group.\n\t                // Compensate the rotation set by transformGroup.\n\t                return cellView.getRootRotateMatrix().inverse().multiply(nodeMatrix);\n\t            } else {\n\t                return cellView.getNodeRotateMatrix(node).multiply(nodeMatrix);\n\t            }\n\t        }\n\t        return nodeMatrix;\n\t    },\n\n\t    mount: function mount() {\n\t        var ref = this;\n\t        var MOUNTABLE = ref.MOUNTABLE;\n\t        var cellView = ref.cellView;\n\t        var el = ref.el;\n\t        var options = ref.options;\n\t        var transformGroup = ref.transformGroup;\n\t        var detachedTransformGroup = ref.detachedTransformGroup;\n\t        if (!MOUNTABLE || transformGroup) { return; }\n\t        var cellViewRoot = cellView.vel;\n\t        var paper = cellView.paper;\n\t        var layerName = options.layer;\n\t        if (layerName) {\n\t            var vGroup;\n\t            if (detachedTransformGroup) {\n\t                vGroup = detachedTransformGroup;\n\t                this.detachedTransformGroup = null;\n\t            } else {\n\t                vGroup = V('g').addClass('highlight-transform').append(el);\n\t            }\n\t            this.transformGroup = vGroup;\n\t            paper.getLayerView(layerName).insertSortedNode(vGroup.node, options.z);\n\t        } else {\n\t            // TODO: prepend vs append\n\t            if (!el.parentNode || el.nextSibling) {\n\t                // Not appended yet or not the last child\n\t                cellViewRoot.append(el);\n\t            }\n\t        }\n\t    },\n\n\t    unmount: function unmount() {\n\t        var ref = this;\n\t        var MOUNTABLE = ref.MOUNTABLE;\n\t        var transformGroup = ref.transformGroup;\n\t        var vel = ref.vel;\n\t        if (!MOUNTABLE) { return; }\n\t        if (transformGroup) {\n\t            this.transformGroup = null;\n\t            this.detachedTransformGroup = transformGroup;\n\t            transformGroup.remove();\n\t        } else {\n\t            vel.remove();\n\t        }\n\t    },\n\n\t    transform: function transform() {\n\t        var ref = this;\n\t        var transformGroup = ref.transformGroup;\n\t        var cellView = ref.cellView;\n\t        var updateRequested = ref.updateRequested;\n\t        if (!transformGroup || cellView.model.isLink() || updateRequested) { return; }\n\t        var translateMatrix = cellView.getRootTranslateMatrix();\n\t        var rotateMatrix = cellView.getRootRotateMatrix();\n\t        var transformMatrix = translateMatrix.multiply(rotateMatrix);\n\t        transformGroup.attr('transform', V.matrixToTransformString(transformMatrix));\n\t    },\n\n\t    update: function update() {\n\t        var ref = this;\n\t        var prevNode = ref.node;\n\t        var cellView = ref.cellView;\n\t        var nodeSelector = ref.nodeSelector;\n\t        var updateRequested = ref.updateRequested;\n\t        var id = ref.id;\n\t        if (updateRequested) { return; }\n\t        var node = this.node = this.findNode(cellView, nodeSelector);\n\t        if (prevNode) {\n\t            this.unhighlight(cellView, prevNode);\n\t        }\n\t        if (node) {\n\t            this.highlight(cellView, node);\n\t            this.mount();\n\t        } else {\n\t            this.unmount();\n\t            cellView.notify('cell:highlight:invalid', id, this);\n\t        }\n\t    },\n\n\t    onRemove: function onRemove() {\n\t        var ref = this;\n\t        var node = ref.node;\n\t        var cellView = ref.cellView;\n\t        var id = ref.id;\n\t        var constructor = ref.constructor;\n\t        if (node) {\n\t            this.unhighlight(cellView, node);\n\t        }\n\t        this.unmount();\n\t        constructor._removeRef(cellView, id);\n\t    },\n\n\t    highlight: function highlight(_cellView, _node) {\n\t        // to be overridden\n\t    },\n\n\t    unhighlight: function unhighlight(_cellView, _node) {\n\t        // to be overridden\n\t    },\n\n\t    // Update Attributes\n\n\t    listenToUpdateAttributes: function listenToUpdateAttributes(cellView) {\n\t        var attributes = result(this, 'UPDATE_ATTRIBUTES');\n\t        if (!Array.isArray(attributes) || attributes.length === 0) { return; }\n\t        this.listenTo(cellView.model, 'change', this.onCellAttributeChange);\n\t    },\n\n\t    onCellAttributeChange: function onCellAttributeChange() {\n\t        var ref = this;\n\t        var cellView = ref.cellView;\n\t        if (!cellView) { return; }\n\t        var model = cellView.model;\n\t        var paper = cellView.paper;\n\t        var attributes = result(this, 'UPDATE_ATTRIBUTES');\n\t        if (!attributes.some(function (attribute) { return model.hasChanged(attribute); })) { return; }\n\t        paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n\t    }\n\n\t}, {\n\n\t    _views: {},\n\n\t    // Used internally by CellView highlight()\n\t    highlight: function(cellView, node, opt) {\n\t        var id = this.uniqueId(node, opt);\n\t        this.add(cellView, node, id, opt);\n\t    },\n\n\t    // Used internally by CellView unhighlight()\n\t    unhighlight: function(cellView, node, opt) {\n\t        var id = this.uniqueId(node, opt);\n\t        this.remove(cellView, id);\n\t    },\n\n\t    get: function get(cellView, id) {\n\t        if ( id === void 0 ) id = null;\n\n\t        var cid = cellView.cid;\n\t        var ref$2 = this;\n\t        var _views = ref$2._views;\n\t        var refs = _views[cid];\n\t        if (id === null) {\n\t            // all highlighters\n\t            var views = [];\n\t            if (!refs) { return views; }\n\t            for (var hid in refs) {\n\t                var ref = refs[hid];\n\t                if (ref instanceof this) {\n\t                    views.push(ref);\n\t                }\n\t            }\n\t            return views;\n\t        } else {\n\t            // single highlighter\n\t            if (!refs) { return null; }\n\t            if (id in refs) {\n\t                var ref$1 = refs[id];\n\t                if (ref$1 instanceof this) { return ref$1; }\n\t            }\n\t            return null;\n\t        }\n\t    },\n\n\t    add: function add(cellView, nodeSelector, id, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        if (!id) { throw new Error('dia.HighlighterView: An ID required.'); }\n\t        // Search the existing view amongst all the highlighters\n\t        var previousView = HighlighterView.get(cellView, id);\n\t        if (previousView) { previousView.remove(); }\n\t        var view = new this(opt);\n\t        view.id = id;\n\t        this._addRef(cellView, id, view);\n\t        view.requestUpdate(cellView, nodeSelector);\n\t        view.listenToUpdateAttributes(cellView);\n\t        return view;\n\t    },\n\n\t    _addRef: function _addRef(cellView, id, view) {\n\t        var cid = cellView.cid;\n\t        var ref = this;\n\t        var _views = ref._views;\n\t        var refs = _views[cid];\n\t        if (!refs) { refs = _views[cid] = {}; }\n\t        refs[id] = view;\n\t    },\n\n\t    _removeRef: function _removeRef(cellView, id) {\n\t        var cid = cellView.cid;\n\t        var ref = this;\n\t        var _views = ref._views;\n\t        var refs = _views[cid];\n\t        if (!refs) { return; }\n\t        if (id) { delete refs[id]; }\n\t        for (var _ in refs) { return; }\n\t        delete _views[cid];\n\t    },\n\n\t    remove: function remove(cellView, id) {\n\t        if ( id === void 0 ) id = null;\n\n\t        toArray$1(this.get(cellView, id)).forEach(function (view) {\n\t            view.remove();\n\t        });\n\t    },\n\n\t    removeAll: function removeAll(paper, id) {\n\t        if ( id === void 0 ) id = null;\n\n\t        var ref = this;\n\t        var _views = ref._views;\n\n\t        for (var cid in _views) {\n\t            for (var hid in _views[cid]) {\n\t                var view = _views[cid][hid];\n\n\t                if (view.cellView.paper === paper && view instanceof this && (id === null || hid === id)) {\n\t                    view.remove();\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    update: function update(cellView, id, dirty) {\n\t        if ( id === void 0 ) id = null;\n\t        if ( dirty === void 0 ) dirty = false;\n\n\t        toArray$1(this.get(cellView, id)).forEach(function (view) {\n\t            if (dirty || view.UPDATABLE) { view.update(); }\n\t        });\n\t    },\n\n\t    transform: function transform(cellView, id) {\n\t        if ( id === void 0 ) id = null;\n\n\t        toArray$1(this.get(cellView, id)).forEach(function (view) {\n\t            if (view.UPDATABLE) { view.transform(); }\n\t        });\n\t    },\n\n\t    unmount: function unmount(cellView, id) {\n\t        if ( id === void 0 ) id = null;\n\n\t        toArray$1(this.get(cellView, id)).forEach(function (view) { return view.unmount(); });\n\t    },\n\n\t    mount: function mount(cellView, id) {\n\t        if ( id === void 0 ) id = null;\n\n\t        toArray$1(this.get(cellView, id)).forEach(function (view) { return view.mount(); });\n\t    },\n\n\t    uniqueId: function uniqueId(node, opt) {\n\t        if ( opt === void 0 ) opt = '';\n\n\t        return V.ensureId(node) + JSON.stringify(opt);\n\t    }\n\n\t});\n\n\tvar HighlightingTypes = {\n\t    DEFAULT: 'default',\n\t    EMBEDDING: 'embedding',\n\t    CONNECTING: 'connecting',\n\t    MAGNET_AVAILABILITY: 'magnetAvailability',\n\t    ELEMENT_AVAILABILITY: 'elementAvailability'\n\t};\n\n\tvar Flags = {\n\t    TOOLS: 'TOOLS',\n\t};\n\n\t// CellView base view and controller.\n\t// --------------------------------------------\n\n\t// This is the base view and controller for `ElementView` and `LinkView`.\n\tvar CellView = View.extend({\n\n\t    tagName: 'g',\n\n\t    svgElement: true,\n\n\t    selector: 'root',\n\n\t    metrics: null,\n\n\t    className: function() {\n\n\t        var classNames = ['cell'];\n\t        var type = this.model.get('type');\n\n\t        if (type) {\n\n\t            type.toLowerCase().split('.').forEach(function(value, index, list) {\n\t                classNames.push('type-' + list.slice(0, index + 1).join('-'));\n\t            });\n\t        }\n\n\t        return classNames.join(' ');\n\t    },\n\n\t    _presentationAttributes: null,\n\t    _flags: null,\n\n\t    setFlags: function() {\n\t        var flags = {};\n\t        var attributes = {};\n\t        var shift = 0;\n\t        var i, n, label;\n\t        var presentationAttributes = result(this, 'presentationAttributes');\n\t        for (var attribute in presentationAttributes) {\n\t            if (!presentationAttributes.hasOwnProperty(attribute)) { continue; }\n\t            var labels = presentationAttributes[attribute];\n\t            if (!Array.isArray(labels)) { labels = [labels]; }\n\t            for (i = 0, n = labels.length; i < n; i++) {\n\t                label = labels[i];\n\t                var flag = flags[label];\n\t                if (!flag) {\n\t                    flag = flags[label] = 1<<(shift++);\n\t                }\n\t                attributes[attribute] |= flag;\n\t            }\n\t        }\n\t        var initFlag = result(this, 'initFlag');\n\t        if (!Array.isArray(initFlag)) { initFlag = [initFlag]; }\n\t        for (i = 0, n = initFlag.length; i < n; i++) {\n\t            label = initFlag[i];\n\t            if (!flags[label]) { flags[label] = 1<<(shift++); }\n\t        }\n\n\t        // 26 - 30 are reserved for paper flags\n\t        // 31+ overflows maximal number\n\t        if (shift > 25) { throw new Error('dia.CellView: Maximum number of flags exceeded.'); }\n\n\t        this._flags = flags;\n\t        this._presentationAttributes = attributes;\n\t    },\n\n\t    hasFlag: function(flag, label) {\n\t        return flag & this.getFlag(label);\n\t    },\n\n\t    removeFlag: function(flag, label) {\n\t        return flag ^ (flag & this.getFlag(label));\n\t    },\n\n\t    getFlag: function(label) {\n\t        var flags = this._flags;\n\t        if (!flags) { return 0; }\n\t        var flag = 0;\n\t        if (Array.isArray(label)) {\n\t            for (var i = 0, n = label.length; i < n; i++) { flag |= flags[label[i]]; }\n\t        } else {\n\t            flag |= flags[label];\n\t        }\n\t        return flag;\n\t    },\n\n\t    attributes: function() {\n\t        var cell = this.model;\n\t        return {\n\t            'model-id': cell.id,\n\t            'data-type': cell.attributes.type\n\t        };\n\t    },\n\n\t    constructor: function(options) {\n\n\t        // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n\t        // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n\t        // still be associated to the same object among all those clients. This is necessary for real-time\n\t        // collaboration mechanism.\n\t        options.id = options.id || guid(this);\n\n\t        View.call(this, options);\n\t    },\n\n\t    initialize: function() {\n\n\t        this.setFlags();\n\n\t        View.prototype.initialize.apply(this, arguments);\n\n\t        this.cleanNodesCache();\n\n\t        // Store reference to this to the <g> DOM element so that the view is accessible through the DOM tree.\n\t        this.$el.data('view', this);\n\n\t        this.startListening();\n\t    },\n\n\t    startListening: function() {\n\t        this.listenTo(this.model, 'change', this.onAttributesChange);\n\t    },\n\n\t    onAttributesChange: function(model, opt) {\n\t        var flag = model.getChangeFlag(this._presentationAttributes);\n\t        if (opt.updateHandled || !flag) { return; }\n\t        if (opt.dirty && this.hasFlag(flag, 'UPDATE')) { flag |= this.getFlag('RENDER'); }\n\t        // TODO: tool changes does not need to be sync\n\t        // Fix Segments tools\n\t        if (opt.tool) { opt.async = false; }\n\t        this.requestUpdate(flag, opt);\n\t    },\n\n\t    requestUpdate: function(flags, opt) {\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        if (paper && flags > 0) {\n\t            paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n\t        }\n\t    },\n\n\t    parseDOMJSON: function(markup, root) {\n\n\t        var doc = parseDOMJSON(markup);\n\t        var selectors = doc.selectors;\n\t        var groups = doc.groupSelectors;\n\t        for (var group in groups) {\n\t            if (selectors[group]) { throw new Error('dia.CellView: ambiguous group selector'); }\n\t            selectors[group] = groups[group];\n\t        }\n\t        if (root) {\n\t            var rootSelector = this.selector;\n\t            if (selectors[rootSelector]) { throw new Error('dia.CellView: ambiguous root selector.'); }\n\t            selectors[rootSelector] = root;\n\t        }\n\t        return { fragment: doc.fragment, selectors: selectors };\n\t    },\n\n\t    // Return `true` if cell link is allowed to perform a certain UI `feature`.\n\t    // Example: `can('vertexMove')`, `can('labelMove')`.\n\t    can: function(feature) {\n\n\t        var interactive = isFunction(this.options.interactive)\n\t            ? this.options.interactive(this)\n\t            : this.options.interactive;\n\n\t        return (isObject$1(interactive) && interactive[feature] !== false) ||\n\t            (isBoolean(interactive) && interactive !== false);\n\t    },\n\n\t    findBySelector: function(selector, root, selectors) {\n\n\t        root || (root = this.el);\n\t        selectors || (selectors = this.selectors);\n\n\t        // These are either descendants of `this.$el` of `this.$el` itself.\n\t        // `.` is a special selector used to select the wrapping `<g>` element.\n\t        if (!selector || selector === '.') { return [root]; }\n\t        if (selectors) {\n\t            var nodes = selectors[selector];\n\t            if (nodes) {\n\t                if (Array.isArray(nodes)) { return nodes; }\n\t                return [nodes];\n\t            }\n\t        }\n\n\t        // Maintaining backwards compatibility\n\t        // e.g. `circle:first` would fail with querySelector() call\n\t        if (config.useCSSSelectors) { return $(root).find(selector).toArray(); }\n\n\t        return [];\n\t    },\n\n\t    notify: function(eventName) {\n\n\t        if (this.paper) {\n\n\t            var args = Array.prototype.slice.call(arguments, 1);\n\n\t            // Trigger the event on both the element itself and also on the paper.\n\t            this.trigger.apply(this, [eventName].concat(args));\n\n\t            // Paper event handlers receive the view object as the first argument.\n\t            this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n\t        }\n\t    },\n\n\t    getBBox: function(opt) {\n\n\t        var bbox;\n\t        if (opt && opt.useModelGeometry) {\n\t            var model = this.model;\n\t            bbox = model.getBBox().bbox(model.angle());\n\t        } else {\n\t            bbox = this.getNodeBBox(this.el);\n\t        }\n\n\t        return this.paper.localToPaperRect(bbox);\n\t    },\n\n\t    getNodeBBox: function(magnet) {\n\n\t        var rect = this.getNodeBoundingRect(magnet);\n\t        var transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));\n\t        var magnetMatrix = this.getNodeMatrix(magnet);\n\t        return V.transformRect(rect, transformMatrix.multiply(magnetMatrix));\n\t    },\n\n\t    getNodeRotateMatrix: function getNodeRotateMatrix(node) {\n\t        if (!this.rotatableNode || this.rotatableNode.contains(node)) {\n\t            // Rotate transformation is applied to all nodes when no rotatableGroup\n\t            // is present or to nodes inside the rotatableGroup only.\n\t            return this.getRootRotateMatrix();\n\t        }\n\t        // Nodes outside the rotatable group\n\t        return V.createSVGMatrix();\n\t    },\n\n\t    getNodeUnrotatedBBox: function(magnet) {\n\n\t        var rect = this.getNodeBoundingRect(magnet);\n\t        var magnetMatrix = this.getNodeMatrix(magnet);\n\t        var translateMatrix = this.getRootTranslateMatrix();\n\t        return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n\t    },\n\n\t    getRootTranslateMatrix: function() {\n\n\t        var model = this.model;\n\t        var position = model.position();\n\t        var mt = V.createSVGMatrix().translate(position.x, position.y);\n\t        return mt;\n\t    },\n\n\t    getRootRotateMatrix: function() {\n\n\t        var mr = V.createSVGMatrix();\n\t        var model = this.model;\n\t        var angle = model.angle();\n\t        if (angle) {\n\t            var bbox = model.getBBox();\n\t            var cx = bbox.width / 2;\n\t            var cy = bbox.height / 2;\n\t            mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n\t        }\n\t        return mr;\n\t    },\n\n\t    _notifyHighlight: function(eventName, el, opt) {\n\t        var assign, assign$1;\n\n\t        if ( opt === void 0 ) opt = {};\n\t        var ref = this;\n\t        var rootNode = ref.el;\n\t        var node;\n\t        if (typeof el === 'string') {\n\t            (assign = this.findBySelector(el), node = assign[0], node = node === void 0 ? rootNode : node);\n\t        } else {\n\t            (assign$1 = this.$(el), node = assign$1[0], node = node === void 0 ? rootNode : node);\n\t        }\n\t        // set partial flag if the highlighted element is not the entire view.\n\t        opt.partial = (node !== rootNode);\n\t        // translate type flag into a type string\n\t        if (opt.type === undefined) {\n\t            var type;\n\t            switch (true) {\n\t                case opt.embedding:\n\t                    type = HighlightingTypes.EMBEDDING;\n\t                    break;\n\t                case opt.connecting:\n\t                    type = HighlightingTypes.CONNECTING;\n\t                    break;\n\t                case opt.magnetAvailability:\n\t                    type = HighlightingTypes.MAGNET_AVAILABILITY;\n\t                    break;\n\t                case opt.elementAvailability:\n\t                    type = HighlightingTypes.ELEMENT_AVAILABILITY;\n\t                    break;\n\t                default:\n\t                    type = HighlightingTypes.DEFAULT;\n\t                    break;\n\t            }\n\t            opt.type = type;\n\t        }\n\t        this.notify(eventName, node, opt);\n\t        return this;\n\t    },\n\n\t    highlight: function(el, opt) {\n\t        return this._notifyHighlight('cell:highlight', el, opt);\n\t    },\n\n\t    unhighlight: function(el, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        return this._notifyHighlight('cell:unhighlight', el, opt);\n\t    },\n\n\t    // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n\t    // an element found, return the root element of the cell view.\n\t    findMagnet: function(el) {\n\n\t        var root = this.el;\n\t        var magnet = this.$(el)[0];\n\t        if (!magnet) {\n\t            magnet = root;\n\t        }\n\n\t        do {\n\t            var magnetAttribute = magnet.getAttribute('magnet');\n\t            var isMagnetRoot = (magnet === root);\n\t            if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n\t                return magnet;\n\t            }\n\t            if (isMagnetRoot) {\n\t                // If the overall cell has set `magnet === false`, then return `undefined` to\n\t                // announce there is no magnet found for this cell.\n\t                // This is especially useful to set on cells that have 'ports'. In this case,\n\t                // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n\t                return undefined;\n\t            }\n\t            magnet = magnet.parentNode;\n\t        } while (magnet);\n\n\t        return undefined;\n\t    },\n\n\t    findProxyNode: function(el, type) {\n\t        el || (el = this.el);\n\t        var nodeSelector = el.getAttribute((type + \"-selector\"));\n\t        if (nodeSelector) {\n\t            var ref = this.findBySelector(nodeSelector);\n\t            var proxyNode = ref[0];\n\t            if (proxyNode) { return proxyNode; }\n\t        }\n\t        return el;\n\t    },\n\n\t    // Construct a unique selector for the `el` element within this view.\n\t    // `prevSelector` is being collected through the recursive call.\n\t    // No value for `prevSelector` is expected when using this method.\n\t    getSelector: function(el, prevSelector) {\n\n\t        var selector;\n\n\t        if (el === this.el) {\n\t            if (typeof prevSelector === 'string') { selector = '> ' + prevSelector; }\n\t            return selector;\n\t        }\n\n\t        if (el) {\n\n\t            var nthChild = V(el).index() + 1;\n\t            selector = el.tagName + ':nth-child(' + nthChild + ')';\n\n\t            if (prevSelector) {\n\t                selector += ' > ' + prevSelector;\n\t            }\n\n\t            selector = this.getSelector(el.parentNode, selector);\n\t        }\n\n\t        return selector;\n\t    },\n\n\t    addLinkFromMagnet: function(magnet, x, y) {\n\n\t        var paper = this.paper;\n\t        var graph = paper.model;\n\n\t        var link = paper.getDefaultLink(this, magnet);\n\t        link.set({\n\t            source: this.getLinkEnd(magnet, x, y, link, 'source'),\n\t            target: { x: x, y: y }\n\t        }).addTo(graph, {\n\t            async: false,\n\t            ui: true\n\t        });\n\n\t        return link.findView(paper);\n\t    },\n\n\t    getLinkEnd: function(magnet) {\n\t        var ref;\n\n\t        var args = [], len = arguments.length - 1;\n\t        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n\t        var model = this.model;\n\t        var id = model.id;\n\t        var port = this.findAttribute('port', magnet);\n\t        // Find a unique `selector` of the element under pointer that is a magnet.\n\t        var selector = magnet.getAttribute('joint-selector');\n\n\t        var end = { id: id };\n\t        if (selector != null) { end.magnet = selector; }\n\t        if (port != null) {\n\t            end.port = port;\n\t            if (!model.hasPort(port) && !selector) {\n\t                // port created via the `port` attribute (not API)\n\t                end.selector = this.getSelector(magnet);\n\t            }\n\t        } else if (selector == null && this.el !== magnet) {\n\t            end.selector = this.getSelector(magnet);\n\t        }\n\n\t        return (ref = this).customizeLinkEnd.apply(ref, [ end, magnet ].concat( args ));\n\t    },\n\n\t    customizeLinkEnd: function(end, magnet, x, y, link, endType) {\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var ref$1 = paper.options;\n\t        var connectionStrategy = ref$1.connectionStrategy;\n\t        if (typeof connectionStrategy === 'function') {\n\t            var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n\t            if (strategy) { return strategy; }\n\t        }\n\t        return end;\n\t    },\n\n\t    getMagnetFromLinkEnd: function(end) {\n\n\t        var root = this.el;\n\t        var port = end.port;\n\t        var selector = end.magnet;\n\t        var model = this.model;\n\t        var magnet;\n\t        if (port != null && model.isElement() && model.hasPort(port)) {\n\t            magnet = this.findPortNode(port, selector) || root;\n\t        } else {\n\t            if (!selector) { selector = end.selector; }\n\t            if (!selector && port != null) {\n\t                // link end has only `id` and `port` property referencing\n\t                // a port created via the `port` attribute (not API).\n\t                selector = '[port=\"' + port + '\"]';\n\t            }\n\t            magnet = this.findBySelector(selector, root, this.selectors)[0];\n\t        }\n\n\t        return this.findProxyNode(magnet, 'magnet');\n\t    },\n\n\t    dragLinkStart: function(evt, magnet, x, y) {\n\t        this.model.startBatch('add-link');\n\t        var linkView = this.addLinkFromMagnet(magnet, x, y);\n\t        // backwards compatibility events\n\t        linkView.notifyPointerdown(evt, x, y);\n\t        linkView.eventData(evt, linkView.startArrowheadMove('target', { whenNotAllowed: 'remove' }));\n\t        this.eventData(evt, { linkView: linkView });\n\t    },\n\n\t    dragLink: function(evt, x, y) {\n\t        var data = this.eventData(evt);\n\t        var linkView = data.linkView;\n\t        if (linkView) {\n\t            linkView.pointermove(evt, x, y);\n\t        } else {\n\t            var paper = this.paper;\n\t            var magnetThreshold = paper.options.magnetThreshold;\n\t            var currentTarget = this.getEventTarget(evt);\n\t            var targetMagnet = data.targetMagnet;\n\t            if (magnetThreshold === 'onleave') {\n\t                // magnetThreshold when the pointer leaves the magnet\n\t                if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) { return; }\n\t            } else {\n\t                // magnetThreshold defined as a number of movements\n\t                if (paper.eventData(evt).mousemoved <= magnetThreshold) { return; }\n\t            }\n\t            this.dragLinkStart(evt, targetMagnet, x, y);\n\t        }\n\t    },\n\n\t    dragLinkEnd: function(evt, x, y) {\n\t        var data = this.eventData(evt);\n\t        var linkView = data.linkView;\n\t        if (!linkView) { return; }\n\t        linkView.pointerup(evt, x, y);\n\t        this.model.stopBatch('add-link');\n\t    },\n\n\t    getAttributeDefinition: function(attrName) {\n\n\t        return this.model.constructor.getAttributeDefinition(attrName);\n\t    },\n\n\t    setNodeAttributes: function(node, attrs) {\n\n\t        if (!isEmpty(attrs)) {\n\t            if (node instanceof SVGElement) {\n\t                V(node).attr(attrs);\n\t            } else {\n\t                $(node).attr(attrs);\n\t            }\n\t        }\n\t    },\n\n\t    processNodeAttributes: function(node, attrs) {\n\n\t        var attrName, attrVal, def, i, n;\n\t        var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n\t        var relatives = [];\n\t        // divide the attributes between normal and special\n\t        for (attrName in attrs) {\n\t            if (!attrs.hasOwnProperty(attrName)) { continue; }\n\t            attrVal = attrs[attrName];\n\t            def = this.getAttributeDefinition(attrName);\n\t            if (def && (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, attrs, this))) {\n\t                if (isString(def.set)) {\n\t                    normalAttrs || (normalAttrs = {});\n\t                    normalAttrs[def.set] = attrVal;\n\t                }\n\t                if (attrVal !== null) {\n\t                    relatives.push(attrName, def);\n\t                }\n\t            } else {\n\t                normalAttrs || (normalAttrs = {});\n\t                normalAttrs[toKebabCase(attrName)] = attrVal;\n\t            }\n\t        }\n\n\t        // handle the rest of attributes via related method\n\t        // from the special attributes namespace.\n\t        for (i = 0, n = relatives.length; i < n; i+=2) {\n\t            attrName = relatives[i];\n\t            def = relatives[i+1];\n\t            attrVal = attrs[attrName];\n\t            if (isFunction(def.set)) {\n\t                setAttrs || (setAttrs = {});\n\t                setAttrs[attrName] = attrVal;\n\t            }\n\t            if (isFunction(def.position)) {\n\t                positionAttrs || (positionAttrs = {});\n\t                positionAttrs[attrName] = attrVal;\n\t            }\n\t            if (isFunction(def.offset)) {\n\t                offsetAttrs || (offsetAttrs = {});\n\t                offsetAttrs[attrName] = attrVal;\n\t            }\n\t        }\n\n\t        return {\n\t            raw: attrs,\n\t            normal: normalAttrs,\n\t            set: setAttrs,\n\t            position: positionAttrs,\n\t            offset: offsetAttrs\n\t        };\n\t    },\n\n\t    updateRelativeAttributes: function(node, attrs, refBBox, opt) {\n\n\t        opt || (opt = {});\n\n\t        var attrName, attrVal, def;\n\t        var rawAttrs = attrs.raw || {};\n\t        var nodeAttrs = attrs.normal || {};\n\t        var setAttrs = attrs.set;\n\t        var positionAttrs = attrs.position;\n\t        var offsetAttrs = attrs.offset;\n\n\t        for (attrName in setAttrs) {\n\t            attrVal = setAttrs[attrName];\n\t            def = this.getAttributeDefinition(attrName);\n\t            // SET - set function should return attributes to be set on the node,\n\t            // which will affect the node dimensions based on the reference bounding\n\t            // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n\t            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, rawAttrs, this);\n\t            if (isObject$1(setResult)) {\n\t                assign(nodeAttrs, setResult);\n\t            } else if (setResult !== undefined) {\n\t                nodeAttrs[attrName] = setResult;\n\t            }\n\t        }\n\n\t        if (node instanceof HTMLElement) {\n\t            // TODO: setting the `transform` attribute on HTMLElements\n\t            // via `node.style.transform = 'matrix(...)';` would introduce\n\t            // a breaking change (e.g. basic.TextBlock).\n\t            this.setNodeAttributes(node, nodeAttrs);\n\t            return;\n\t        }\n\n\t        // The final translation of the subelement.\n\t        var nodeTransform = nodeAttrs.transform;\n\t        var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n\t        var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n\t        if (nodeTransform) {\n\t            nodeAttrs = omit(nodeAttrs, 'transform');\n\t            nodeMatrix.e = nodeMatrix.f = 0;\n\t        }\n\n\t        // Calculate node scale determined by the scalable group\n\t        // only if later needed.\n\t        var sx, sy, translation;\n\t        if (positionAttrs || offsetAttrs) {\n\t            var nodeScale = this.getNodeScale(node, opt.scalableNode);\n\t            sx = nodeScale.sx;\n\t            sy = nodeScale.sy;\n\t        }\n\n\t        var positioned = false;\n\t        for (attrName in positionAttrs) {\n\t            attrVal = positionAttrs[attrName];\n\t            def = this.getAttributeDefinition(attrName);\n\t            // POSITION - position function should return a point from the\n\t            // reference bounding box. The default position of the node is x:0, y:0 of\n\t            // the reference bounding box or could be further specify by some\n\t            // SVG attributes e.g. `x`, `y`\n\t            translation = def.position.call(this, attrVal, refBBox.clone(), node, rawAttrs, this);\n\t            if (translation) {\n\t                nodePosition.offset(Point(translation).scale(sx, sy));\n\t                positioned || (positioned = true);\n\t            }\n\t        }\n\n\t        // The node bounding box could depend on the `size` set from the previous loop.\n\t        // Here we know, that all the size attributes have been already set.\n\t        this.setNodeAttributes(node, nodeAttrs);\n\n\t        var offseted = false;\n\t        if (offsetAttrs) {\n\t            // Check if the node is visible\n\t            var nodeBoundingRect = this.getNodeBoundingRect(node);\n\t            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n\t                var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n\t                for (attrName in offsetAttrs) {\n\t                    attrVal = offsetAttrs[attrName];\n\t                    def = this.getAttributeDefinition(attrName);\n\t                    // OFFSET - offset function should return a point from the element\n\t                    // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n\t                    // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n\t                    translation = def.offset.call(this, attrVal, nodeBBox, node, rawAttrs, this);\n\t                    if (translation) {\n\t                        nodePosition.offset(Point(translation).scale(sx, sy));\n\t                        offseted || (offseted = true);\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        // Do not touch node's transform attribute if there is no transformation applied.\n\t        if (nodeTransform !== undefined || positioned || offseted) {\n\t            // Round the coordinates to 1 decimal point.\n\t            nodePosition.round(1);\n\t            nodeMatrix.e = nodePosition.x;\n\t            nodeMatrix.f = nodePosition.y;\n\t            node.setAttribute('transform', V.matrixToTransformString(nodeMatrix));\n\t            // TODO: store nodeMatrix metrics?\n\t        }\n\t    },\n\n\t    getNodeScale: function(node, scalableNode) {\n\n\t        // Check if the node is a descendant of the scalable group.\n\t        var sx, sy;\n\t        if (scalableNode && scalableNode.contains(node)) {\n\t            var scale = scalableNode.scale();\n\t            sx = 1 / scale.sx;\n\t            sy = 1 / scale.sy;\n\t        } else {\n\t            sx = 1;\n\t            sy = 1;\n\t        }\n\n\t        return { sx: sx, sy: sy };\n\t    },\n\n\t    cleanNodesCache: function() {\n\t        this.metrics = {};\n\t    },\n\n\t    nodeCache: function(magnet) {\n\n\t        var metrics = this.metrics;\n\t        // Don't use cache? It most likely a custom view with overridden update.\n\t        if (!metrics) { return {}; }\n\t        var id = V.ensureId(magnet);\n\t        var value = metrics[id];\n\t        if (!value) { value = metrics[id] = {}; }\n\t        return value;\n\t    },\n\n\t    getNodeData: function(magnet) {\n\n\t        var metrics = this.nodeCache(magnet);\n\t        if (!metrics.data) { metrics.data = {}; }\n\t        return metrics.data;\n\t    },\n\n\t    getNodeBoundingRect: function(magnet) {\n\n\t        var metrics = this.nodeCache(magnet);\n\t        if (metrics.boundingRect === undefined) { metrics.boundingRect = V(magnet).getBBox(); }\n\t        return new Rect(metrics.boundingRect);\n\t    },\n\n\t    getNodeMatrix: function(magnet) {\n\n\t        var metrics = this.nodeCache(magnet);\n\t        if (metrics.magnetMatrix === undefined) {\n\t            var ref = this;\n\t            var rotatableNode = ref.rotatableNode;\n\t            var el = ref.el;\n\t            var target;\n\t            if (rotatableNode && rotatableNode.contains(magnet)) {\n\t                target = rotatableNode;\n\t            } else {\n\t                target = el;\n\t            }\n\t            metrics.magnetMatrix = V(magnet).getTransformToElement(target);\n\t        }\n\t        return V.createSVGMatrix(metrics.magnetMatrix);\n\t    },\n\n\t    getNodeShape: function(magnet) {\n\n\t        var metrics = this.nodeCache(magnet);\n\t        if (metrics.geometryShape === undefined) { metrics.geometryShape = V(magnet).toGeometryShape(); }\n\t        return metrics.geometryShape.clone();\n\t    },\n\n\t    isNodeConnection: function(node) {\n\t        return this.model.isLink() && (!node || node === this.el);\n\t    },\n\n\t    findNodesAttributes: function(attrs, root, selectorCache, selectors) {\n\n\t        var i, n, nodeAttrs, nodeId;\n\t        var nodesAttrs = {};\n\t        var mergeIds = [];\n\t        for (var selector in attrs) {\n\t            if (!attrs.hasOwnProperty(selector)) { continue; }\n\t            nodeAttrs = attrs[selector];\n\t            if (!isPlainObject(nodeAttrs)) { continue; } // Not a valid selector-attributes pair\n\t            var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n\t            for (i = 0, n = selected.length; i < n; i++) {\n\t                var node = selected[i];\n\t                nodeId = V.ensureId(node);\n\t                // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n\t                // groupSelector referencing a single node is not \"unique\"\n\t                var unique = (selectors && selectors[selector] === node);\n\t                var prevNodeAttrs = nodesAttrs[nodeId];\n\t                if (prevNodeAttrs) {\n\t                    // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n\t                    // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n\t                    if (!prevNodeAttrs.array) {\n\t                        mergeIds.push(nodeId);\n\t                        prevNodeAttrs.array = true;\n\t                        prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n\t                        prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n\t                    }\n\t                    var attributes = prevNodeAttrs.attributes;\n\t                    var selectedLength = prevNodeAttrs.selectedLength;\n\t                    if (unique) {\n\t                        // node referenced by `selector`\n\t                        attributes.unshift(nodeAttrs);\n\t                        selectedLength.unshift(-1);\n\t                    } else {\n\t                        // node referenced by `groupSelector`\n\t                        var sortIndex = sortedIndex(selectedLength, n);\n\t                        attributes.splice(sortIndex, 0, nodeAttrs);\n\t                        selectedLength.splice(sortIndex, 0, n);\n\t                    }\n\t                } else {\n\t                    nodesAttrs[nodeId] = {\n\t                        attributes: nodeAttrs,\n\t                        selectedLength: unique ? -1 : n,\n\t                        node: node,\n\t                        array: false\n\t                    };\n\t                }\n\t            }\n\t        }\n\n\t        for (i = 0, n = mergeIds.length; i < n; i++) {\n\t            nodeId = mergeIds[i];\n\t            nodeAttrs = nodesAttrs[nodeId];\n\t            nodeAttrs.attributes = merge.apply(void 0, [ {} ].concat( nodeAttrs.attributes.reverse() ));\n\t        }\n\n\t        return nodesAttrs;\n\t    },\n\n\t    getEventTarget: function(evt, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        var target = evt.target;\n\t        var type = evt.type;\n\t        var clientX = evt.clientX; if ( clientX === void 0 ) clientX = 0;\n\t        var clientY = evt.clientY; if ( clientY === void 0 ) clientY = 0;\n\t        if (\n\t            // Explicitly defined `fromPoint` option\n\t            opt.fromPoint ||\n\t            // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n\t            // It holds the element when a touchstart triggered.\n\t            type === 'touchmove' || type === 'touchend' ||\n\t            // Pointermove/Pointerup event with the pointer captured\n\t            ('pointerId' in evt && target.hasPointerCapture(evt.pointerId))\n\t        ) {\n\t            return document.elementFromPoint(clientX, clientY);\n\t        }\n\n\t        return target;\n\t    },\n\n\t    // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n\t    // unless `attrs` parameter was passed.\n\t    updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {\n\n\t        opt || (opt = {});\n\t        opt.rootBBox || (opt.rootBBox = Rect());\n\t        opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n\n\t        // Cache table for query results and bounding box calculation.\n\t        // Note that `selectorCache` needs to be invalidated for all\n\t        // `updateAttributes` calls, as the selectors might pointing\n\t        // to nodes designated by an attribute or elements dynamically\n\t        // created.\n\t        var selectorCache = {};\n\t        var bboxCache = {};\n\t        var relativeItems = [];\n\t        var relativeRefItems = [];\n\t        var item, node, nodeAttrs, nodeData, processedAttrs;\n\n\t        var roAttrs = opt.roAttributes;\n\t        var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n\t        // `nodesAttrs` are different from all attributes, when\n\t        // rendering only  attributes sent to this method.\n\t        var nodesAllAttrs = (roAttrs)\n\t            ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors)\n\t            : nodesAttrs;\n\n\t        for (var nodeId in nodesAttrs) {\n\t            nodeData = nodesAttrs[nodeId];\n\t            nodeAttrs = nodeData.attributes;\n\t            node = nodeData.node;\n\t            processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n\n\t            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset) {\n\t                // Set all the normal attributes right on the SVG/HTML element.\n\t                this.setNodeAttributes(node, processedAttrs.normal);\n\n\t            } else {\n\n\t                var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n\t                var refSelector = (nodeAllAttrs && (nodeAttrs.ref === undefined))\n\t                    ? nodeAllAttrs.ref\n\t                    : nodeAttrs.ref;\n\n\t                var refNode;\n\t                if (refSelector) {\n\t                    refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n\t                    if (!refNode) {\n\t                        throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n\t                    }\n\t                } else {\n\t                    refNode = null;\n\t                }\n\n\t                item = {\n\t                    node: node,\n\t                    refNode: refNode,\n\t                    processedAttributes: processedAttrs,\n\t                    allAttributes: nodeAllAttrs\n\t                };\n\n\t                if (refNode) {\n\t                    // If an element in the list is positioned relative to this one, then\n\t                    // we want to insert this one before it in the list.\n\t                    var itemIndex = relativeRefItems.findIndex(function(item) {\n\t                        return item.refNode === node;\n\t                    });\n\n\t                    if (itemIndex > -1) {\n\t                        relativeRefItems.splice(itemIndex, 0, item);\n\t                    } else {\n\t                        relativeRefItems.push(item);\n\t                    }\n\t                } else {\n\t                    // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n\t                    // The order of no-ref-items is not specified/important.\n\t                    relativeItems.push(item);\n\t                }\n\t            }\n\t        }\n\n\t        relativeItems.push.apply(relativeItems, relativeRefItems);\n\n\t        var rotatableMatrix;\n\t        for (var i = 0, n = relativeItems.length; i < n; i++) {\n\t            item = relativeItems[i];\n\t            node = item.node;\n\t            refNode = item.refNode;\n\n\t            // Find the reference element bounding box. If no reference was provided, we\n\t            // use the optional bounding box.\n\t            var vRotatable = V(opt.rotatableNode);\n\t            var refNodeId = refNode ? V.ensureId(refNode) : '';\n\t            var isRefNodeRotatable = !!vRotatable && !!refNode && vRotatable.contains(refNode);\n\t            var unrotatedRefBBox = bboxCache[refNodeId];\n\t            if (!unrotatedRefBBox) {\n\t                // Get the bounding box of the reference element relative to the `rotatable` `<g>` (without rotation)\n\t                // or to the root `<g>` element if no rotatable group present if reference node present.\n\t                // Uses the bounding box provided.\n\t                var transformationTarget = (isRefNodeRotatable) ? vRotatable : rootNode;\n\t                unrotatedRefBBox = bboxCache[refNodeId] = (refNode)\n\t                    ? V(refNode).getBBox({ target: transformationTarget })\n\t                    : opt.rootBBox;\n\t            }\n\n\t            if (roAttrs) {\n\t                // if there was a special attribute affecting the position amongst passed-in attributes\n\t                // we have to merge it with the rest of the element's attributes as they are necessary\n\t                // to update the position relatively (i.e `ref-x` && 'ref-dx')\n\t                processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n\t                this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n\n\t            } else {\n\t                processedAttrs = item.processedAttributes;\n\t            }\n\n\t            var refBBox = unrotatedRefBBox;\n\t            if (isRefNodeRotatable && !vRotatable.contains(node)) {\n\t                // if the referenced node is inside the rotatable group while the updated node is outside,\n\t                // we need to take the rotatable node transformation into account\n\t                if (!rotatableMatrix) { rotatableMatrix = V.transformStringToMatrix(vRotatable.attr('transform')); }\n\t                refBBox = V.transformRect(unrotatedRefBBox, rotatableMatrix);\n\t            }\n\n\t            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n\t        }\n\t    },\n\n\t    mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {\n\n\t        processedAttrs.set || (processedAttrs.set = {});\n\t        processedAttrs.position || (processedAttrs.position = {});\n\t        processedAttrs.offset || (processedAttrs.offset = {});\n\n\t        assign(processedAttrs.set, roProcessedAttrs.set);\n\t        assign(processedAttrs.position, roProcessedAttrs.position);\n\t        assign(processedAttrs.offset, roProcessedAttrs.offset);\n\n\t        // Handle also the special transform property.\n\t        var transform = processedAttrs.normal && processedAttrs.normal.transform;\n\t        if (transform !== undefined && roProcessedAttrs.normal) {\n\t            roProcessedAttrs.normal.transform = transform;\n\t        }\n\t        processedAttrs.normal = roProcessedAttrs.normal;\n\t    },\n\n\t    // Lifecycle methods\n\n\t    // Called when the view is attached to the DOM,\n\t    // as result of `cell.addTo(graph)` being called (isInitialMount === true)\n\t    // or `paper.options.viewport` returning `true` (isInitialMount === false).\n\t    onMount: function onMount(isInitialMount) {\n\t        if (isInitialMount) { return; }\n\t        this.mountTools();\n\t        HighlighterView.mount(this);\n\t    },\n\n\t    // Called when the view is detached from the DOM,\n\t    // as result of `paper.options.viewport` returning `false`.\n\t    onDetach: function onDetach() {\n\t        this.unmountTools();\n\t        HighlighterView.unmount(this);\n\t    },\n\n\t    // Called when the view is removed from the DOM\n\t    // as result of `cell.remove()`.\n\t    onRemove: function() {\n\t        this.removeTools();\n\t        this.removeHighlighters();\n\t    },\n\n\t    _toolsView: null,\n\n\t    hasTools: function(name) {\n\t        var toolsView = this._toolsView;\n\t        if (!toolsView) { return false; }\n\t        if (!name) { return true; }\n\t        return (toolsView.getName() === name);\n\t    },\n\n\t    addTools: function(toolsView) {\n\n\t        this.removeTools();\n\n\t        if (toolsView) {\n\t            this._toolsView = toolsView;\n\t            toolsView.configure({ relatedView: this });\n\t            toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n\t        }\n\t        return this;\n\t    },\n\n\t    unmountTools: function unmountTools() {\n\t        var toolsView = this._toolsView;\n\t        if (toolsView) { toolsView.unmount(); }\n\t        return this;\n\t    },\n\n\t    mountTools: function mountTools() {\n\t        var toolsView = this._toolsView;\n\t        // Prevent unnecessary re-appending of the tools.\n\t        if (toolsView && !toolsView.isMounted()) { toolsView.mount(); }\n\t        return this;\n\t    },\n\n\t    updateTools: function(opt) {\n\n\t        var toolsView = this._toolsView;\n\t        if (toolsView) { toolsView.update(opt); }\n\t        return this;\n\t    },\n\n\t    removeTools: function() {\n\n\t        var toolsView = this._toolsView;\n\t        if (toolsView) {\n\t            toolsView.remove();\n\t            this._toolsView = null;\n\t        }\n\t        return this;\n\t    },\n\n\t    hideTools: function() {\n\n\t        var toolsView = this._toolsView;\n\t        if (toolsView) { toolsView.hide(); }\n\t        return this;\n\t    },\n\n\t    showTools: function() {\n\n\t        var toolsView = this._toolsView;\n\t        if (toolsView) { toolsView.show(); }\n\t        return this;\n\t    },\n\n\t    onToolEvent: function(event) {\n\t        switch (event) {\n\t            case 'remove':\n\t                this.removeTools();\n\t                break;\n\t            case 'hide':\n\t                this.hideTools();\n\t                break;\n\t            case 'show':\n\t                this.showTools();\n\t                break;\n\t        }\n\t    },\n\n\t    removeHighlighters: function() {\n\t        HighlighterView.remove(this);\n\t    },\n\n\t    updateHighlighters: function(dirty) {\n\t        if ( dirty === void 0 ) dirty = false;\n\n\t        HighlighterView.update(this, null, dirty);\n\t    },\n\n\t    transformHighlighters: function() {\n\t        HighlighterView.transform(this);\n\t    },\n\n\t    // Interaction. The controller part.\n\t    // ---------------------------------\n\n\t    preventDefaultInteraction: function preventDefaultInteraction(evt) {\n\t        this.eventData(evt, { defaultInteractionPrevented: true  });\n\t    },\n\n\t    isDefaultInteractionPrevented: function isDefaultInteractionPrevented(evt) {\n\t        var ref = this.eventData(evt);\n\t        var defaultInteractionPrevented = ref.defaultInteractionPrevented; if ( defaultInteractionPrevented === void 0 ) defaultInteractionPrevented = false;\n\t        return defaultInteractionPrevented;\n\t    },\n\n\t    // Interaction is handled by the paper and delegated to the view in interest.\n\t    // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n\t    // If necessary, real coordinates can be obtained from the `evt` event object.\n\n\t    // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,\n\t    // i.e. `joint.dia.Element` and `joint.dia.Link`.\n\n\t    pointerdblclick: function(evt, x, y) {\n\n\t        this.notify('cell:pointerdblclick', evt, x, y);\n\t    },\n\n\t    pointerclick: function(evt, x, y) {\n\n\t        this.notify('cell:pointerclick', evt, x, y);\n\t    },\n\n\t    contextmenu: function(evt, x, y) {\n\n\t        this.notify('cell:contextmenu', evt, x, y);\n\t    },\n\n\t    pointerdown: function(evt, x, y) {\n\n\t        var ref = this;\n\t        var model = ref.model;\n\t        var graph = model.graph;\n\t        if (graph) {\n\t            model.startBatch('pointer');\n\t            this.eventData(evt, { graph: graph });\n\t        }\n\n\t        this.notify('cell:pointerdown', evt, x, y);\n\t    },\n\n\t    pointermove: function(evt, x, y) {\n\n\t        this.notify('cell:pointermove', evt, x, y);\n\t    },\n\n\t    pointerup: function(evt, x, y) {\n\n\t        var ref = this.eventData(evt);\n\t        var graph = ref.graph;\n\n\t        this.notify('cell:pointerup', evt, x, y);\n\n\t        if (graph) {\n\t            // we don't want to trigger event on model as model doesn't\n\t            // need to be member of collection anymore (remove)\n\t            graph.stopBatch('pointer', { cell: this.model });\n\t        }\n\t    },\n\n\t    mouseover: function(evt) {\n\n\t        this.notify('cell:mouseover', evt);\n\t    },\n\n\t    mouseout: function(evt) {\n\n\t        this.notify('cell:mouseout', evt);\n\t    },\n\n\t    mouseenter: function(evt) {\n\n\t        this.notify('cell:mouseenter', evt);\n\t    },\n\n\t    mouseleave: function(evt) {\n\n\t        this.notify('cell:mouseleave', evt);\n\t    },\n\n\t    mousewheel: function(evt, x, y, delta) {\n\n\t        this.notify('cell:mousewheel', evt, x, y, delta);\n\t    },\n\n\t    onevent: function(evt, eventName, x, y) {\n\n\t        this.notify(eventName, evt, x, y);\n\t    },\n\n\t    onmagnet: function() {\n\n\t        // noop\n\t    },\n\n\t    magnetpointerdblclick: function() {\n\n\t        // noop\n\t    },\n\n\t    magnetcontextmenu: function() {\n\n\t        // noop\n\t    },\n\n\t    checkMouseleave: function checkMouseleave(evt) {\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var model = ref.model;\n\t        if (paper.isAsync()) {\n\t            // Make sure the source/target views are updated before this view.\n\t            // It's not 100% bulletproof (see below) but it's a good enough solution for now.\n\t            // The connected cells could be links as well. In that case, we would\n\t            // need to recursively go through all the connected links and update\n\t            // their source/target views as well.\n\t            if (model.isLink()) {\n\t                // The `this.sourceView` and `this.targetView` might not be updated yet.\n\t                // We need to find the view by the model.\n\t                var sourceElement = model.getSourceElement();\n\t                if (sourceElement) {\n\t                    var sourceView = paper.findViewByModel(sourceElement);\n\t                    if (sourceView) { paper.dumpView(sourceView); }\n\t                }\n\t                var targetElement = model.getTargetElement();\n\t                if (targetElement) {\n\t                    var targetView = paper.findViewByModel(targetElement);\n\t                    if (targetView) { paper.dumpView(targetView); }\n\t                }\n\t            }\n\t            // Do the updates of the current view synchronously now\n\t            paper.dumpView(this);\n\t        }\n\t        var target = this.getEventTarget(evt, { fromPoint: true });\n\t        var view = paper.findView(target);\n\t        if (view === this) { return; }\n\t        // Leaving the current view\n\t        this.mouseleave(evt);\n\t        if (!view) { return; }\n\t        // Entering another view\n\t        view.mouseenter(evt);\n\t    },\n\n\t    setInteractivity: function(value) {\n\n\t        this.options.interactive = value;\n\t    }\n\t}, {\n\n\t    Flags: Flags,\n\n\t    Highlighting: HighlightingTypes,\n\n\t    addPresentationAttributes: function(presentationAttributes) {\n\t        return merge({}, result(this.prototype, 'presentationAttributes'), presentationAttributes, function(a, b) {\n\t            if (!a || !b) { return; }\n\t            if (typeof a === 'string') { a = [a]; }\n\t            if (typeof b === 'string') { b = [b]; }\n\t            if (Array.isArray(a) && Array.isArray(b)) { return uniq(a.concat(b)); }\n\t        });\n\t    }\n\t});\n\n\tvar Flags$1 = {\n\t    TOOLS: CellView.Flags.TOOLS,\n\t    UPDATE: 'UPDATE',\n\t    TRANSLATE: 'TRANSLATE',\n\t    RESIZE: 'RESIZE',\n\t    PORTS: 'PORTS',\n\t    ROTATE: 'ROTATE',\n\t    RENDER: 'RENDER'\n\t};\n\n\tvar DragActions = {\n\t    MOVE: 'move',\n\t    MAGNET: 'magnet',\n\t};\n\t// Element base view and controller.\n\t// -------------------------------------------\n\n\tvar ElementView = CellView.extend({\n\n\t    /**\n\t     * @abstract\n\t     */\n\t    _removePorts: function() {\n\t        // implemented in ports.js\n\t    },\n\n\t    /**\n\t     *\n\t     * @abstract\n\t     */\n\t    _renderPorts: function() {\n\t        // implemented in ports.js\n\t    },\n\n\t    className: function() {\n\n\t        var classNames = CellView.prototype.className.apply(this).split(' ');\n\n\t        classNames.push('element');\n\n\t        return classNames.join(' ');\n\t    },\n\n\t    initialize: function() {\n\n\t        CellView.prototype.initialize.apply(this, arguments);\n\n\t        this._initializePorts();\n\t    },\n\n\t    presentationAttributes: {\n\t        'attrs': [Flags$1.UPDATE],\n\t        'position': [Flags$1.TRANSLATE, Flags$1.TOOLS],\n\t        'size': [Flags$1.RESIZE, Flags$1.PORTS, Flags$1.TOOLS],\n\t        'angle': [Flags$1.ROTATE, Flags$1.TOOLS],\n\t        'markup': [Flags$1.RENDER],\n\t        'ports': [Flags$1.PORTS],\n\t    },\n\n\t    initFlag: [Flags$1.RENDER],\n\n\t    UPDATE_PRIORITY: 0,\n\n\t    confirmUpdate: function(flag, opt) {\n\n\t        var useCSSSelectors = config.useCSSSelectors;\n\t        if (this.hasFlag(flag, Flags$1.PORTS)) {\n\t            this._removePorts();\n\t            this._cleanPortsCache();\n\t        }\n\t        var transformHighlighters = false;\n\t        if (this.hasFlag(flag, Flags$1.RENDER)) {\n\t            this.render();\n\t            this.updateTools(opt);\n\t            this.updateHighlighters(true);\n\t            transformHighlighters = true;\n\t            flag = this.removeFlag(flag, [Flags$1.RENDER, Flags$1.UPDATE, Flags$1.RESIZE, Flags$1.TRANSLATE, Flags$1.ROTATE, Flags$1.PORTS, Flags$1.TOOLS]);\n\t        } else {\n\t            var updateHighlighters = false;\n\n\t            // Skip this branch if render is required\n\t            if (this.hasFlag(flag, Flags$1.RESIZE)) {\n\t                this.resize(opt);\n\t                updateHighlighters = true;\n\t                // Resize method is calling `update()` internally\n\t                flag = this.removeFlag(flag, [Flags$1.RESIZE, Flags$1.UPDATE]);\n\t                if (useCSSSelectors) {\n\t                    // `resize()` rendered the ports when useCSSSelectors are enabled\n\t                    flag = this.removeFlag(flag, Flags$1.PORTS);\n\t                }\n\t            }\n\t            if (this.hasFlag(flag, Flags$1.UPDATE)) {\n\t                this.update(this.model, null, opt);\n\t                flag = this.removeFlag(flag, Flags$1.UPDATE);\n\t                updateHighlighters = true;\n\t                if (useCSSSelectors) {\n\t                    // `update()` will render ports when useCSSSelectors are enabled\n\t                    flag = this.removeFlag(flag, Flags$1.PORTS);\n\t                }\n\t            }\n\t            if (this.hasFlag(flag, Flags$1.TRANSLATE)) {\n\t                this.translate();\n\t                flag = this.removeFlag(flag, Flags$1.TRANSLATE);\n\t                transformHighlighters = true;\n\t            }\n\t            if (this.hasFlag(flag, Flags$1.ROTATE)) {\n\t                this.rotate();\n\t                flag = this.removeFlag(flag, Flags$1.ROTATE);\n\t                transformHighlighters = true;\n\t            }\n\t            if (this.hasFlag(flag, Flags$1.PORTS)) {\n\t                this._renderPorts();\n\t                updateHighlighters = true;\n\t                flag = this.removeFlag(flag, Flags$1.PORTS);\n\t            }\n\n\t            if (updateHighlighters) {\n\t                this.updateHighlighters(false);\n\t            }\n\t        }\n\n\t        if (transformHighlighters) {\n\t            this.transformHighlighters();\n\t        }\n\n\t        if (this.hasFlag(flag, Flags$1.TOOLS)) {\n\t            this.updateTools(opt);\n\t            flag = this.removeFlag(flag, Flags$1.TOOLS);\n\t        }\n\n\t        return flag;\n\t    },\n\n\t    /**\n\t     * @abstract\n\t     */\n\t    _initializePorts: function() {\n\n\t    },\n\n\t    update: function(_, renderingOnlyAttrs) {\n\n\t        this.cleanNodesCache();\n\n\t        // When CSS selector strings are used, make sure no rule matches port nodes.\n\t        var useCSSSelectors = config.useCSSSelectors;\n\t        if (useCSSSelectors) { this._removePorts(); }\n\n\t        var model = this.model;\n\t        var modelAttrs = model.attr();\n\t        this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n\t            rootBBox: new Rect(model.size()),\n\t            selectors: this.selectors,\n\t            scalableNode: this.scalableNode,\n\t            rotatableNode: this.rotatableNode,\n\t            // Use rendering only attributes if they differs from the model attributes\n\t            roAttributes: (renderingOnlyAttrs === modelAttrs) ? null : renderingOnlyAttrs\n\t        });\n\n\t        if (useCSSSelectors) {\n\t            this._renderPorts();\n\t        }\n\t    },\n\n\t    rotatableSelector: 'rotatable',\n\t    scalableSelector: 'scalable',\n\t    scalableNode: null,\n\t    rotatableNode: null,\n\n\t    // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n\t    // default markup is not desirable.\n\t    renderMarkup: function() {\n\n\t        var element = this.model;\n\t        var markup = element.get('markup') || element.markup;\n\t        if (!markup) { throw new Error('dia.ElementView: markup required'); }\n\t        if (Array.isArray(markup)) { return this.renderJSONMarkup(markup); }\n\t        if (typeof markup === 'string') { return this.renderStringMarkup(markup); }\n\t        throw new Error('dia.ElementView: invalid markup');\n\t    },\n\n\t    renderJSONMarkup: function(markup) {\n\n\t        var doc = this.parseDOMJSON(markup, this.el);\n\t        var selectors = this.selectors = doc.selectors;\n\t        this.rotatableNode = V(selectors[this.rotatableSelector]) || null;\n\t        this.scalableNode = V(selectors[this.scalableSelector]) || null;\n\t        // Fragment\n\t        this.vel.append(doc.fragment);\n\t    },\n\n\t    renderStringMarkup: function(markup) {\n\n\t        var vel = this.vel;\n\t        vel.append(V(markup));\n\t        // Cache transformation groups\n\t        this.rotatableNode = vel.findOne('.rotatable');\n\t        this.scalableNode = vel.findOne('.scalable');\n\n\t        var selectors = this.selectors = {};\n\t        selectors[this.selector] = this.el;\n\t    },\n\n\t    render: function() {\n\n\t        this.vel.empty();\n\t        this.renderMarkup();\n\t        if (this.scalableNode) {\n\t            // Double update is necessary for elements with the scalable group only\n\t            // Note the resize() triggers the other `update`.\n\t            this.update();\n\t        }\n\t        this.resize();\n\t        if (this.rotatableNode) {\n\t            // Translate transformation is applied on `this.el` while the rotation transformation\n\t            // on `this.rotatableNode`\n\t            this.rotate();\n\t            this.translate();\n\t        } else {\n\t            this.updateTransformation();\n\t        }\n\t        if (!config.useCSSSelectors) { this._renderPorts(); }\n\t        return this;\n\t    },\n\n\t    resize: function(opt) {\n\n\t        if (this.scalableNode) { return this.sgResize(opt); }\n\t        if (this.model.attributes.angle) { this.rotate(); }\n\t        this.update();\n\t    },\n\n\t    translate: function() {\n\n\t        if (this.rotatableNode) { return this.rgTranslate(); }\n\t        this.updateTransformation();\n\t    },\n\n\t    rotate: function() {\n\n\t        if (this.rotatableNode) {\n\t            this.rgRotate();\n\t            // It's necessary to call the update for the nodes outside\n\t            // the rotatable group referencing nodes inside the group\n\t            this.update();\n\t            return;\n\t        }\n\t        this.updateTransformation();\n\t    },\n\n\t    updateTransformation: function() {\n\n\t        var transformation = this.getTranslateString();\n\t        var rotateString = this.getRotateString();\n\t        if (rotateString) { transformation += ' ' + rotateString; }\n\t        this.vel.attr('transform', transformation);\n\t    },\n\n\t    getTranslateString: function() {\n\n\t        var position = this.model.attributes.position;\n\t        return 'translate(' + position.x + ',' + position.y + ')';\n\t    },\n\n\t    getRotateString: function() {\n\t        var attributes = this.model.attributes;\n\t        var angle = attributes.angle;\n\t        if (!angle) { return null; }\n\t        var size = attributes.size;\n\t        return 'rotate(' + angle + ',' + (size.width / 2) + ',' + (size.height / 2) + ')';\n\t    },\n\n\t    // Rotatable & Scalable Group\n\t    // always slower, kept mainly for backwards compatibility\n\n\t    rgRotate: function() {\n\n\t        this.rotatableNode.attr('transform', this.getRotateString());\n\t    },\n\n\t    rgTranslate: function() {\n\n\t        this.vel.attr('transform', this.getTranslateString());\n\t    },\n\n\t    sgResize: function(opt) {\n\n\t        var model = this.model;\n\t        var angle = model.angle();\n\t        var size = model.size();\n\t        var scalable = this.scalableNode;\n\n\t        // Getting scalable group's bbox.\n\t        // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n\t        // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n\t        var recursive = false;\n\t        if (scalable.node.getElementsByTagName('path').length > 0) {\n\t            // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n\t            // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n\t            recursive = true;\n\t        }\n\t        var scalableBBox = scalable.getBBox({ recursive: recursive });\n\n\t        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n\t        // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n\t        var sx = (size.width / (scalableBBox.width || 1));\n\t        var sy = (size.height / (scalableBBox.height || 1));\n\t        scalable.attr('transform', 'scale(' + sx + ',' + sy + ')');\n\n\t        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n\t        // Order of transformations is significant but we want to reconstruct the object always in the order:\n\t        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n\t        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n\t        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n\t        // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n\t        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n\n\t        // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n\t        var rotatable = this.rotatableNode;\n\t        var rotation = rotatable && rotatable.attr('transform');\n\t        if (rotation) {\n\n\t            rotatable.attr('transform', rotation + ' rotate(' + (-angle) + ',' + (size.width / 2) + ',' + (size.height / 2) + ')');\n\t            var rotatableBBox = scalable.getBBox({ target: this.paper.cells });\n\n\t            // Store new x, y and perform rotate() again against the new rotation origin.\n\t            model.set('position', { x: rotatableBBox.x, y: rotatableBBox.y }, assign({ updateHandled: true }, opt));\n\t            this.translate();\n\t            this.rotate();\n\t        }\n\n\t        // Update must always be called on non-rotated element. Otherwise, relative positioning\n\t        // would work with wrong (rotated) bounding boxes.\n\t        this.update();\n\t    },\n\n\t    // Embedding mode methods.\n\t    // -----------------------\n\n\t    prepareEmbedding: function(data) {\n\t        if ( data === void 0 ) data = {};\n\n\n\t        var element = data.model || this.model;\n\t        var paper = data.paper || this.paper;\n\t        var graph = paper.model;\n\n\t        var initialZIndices = data.initialZIndices = {};\n\t        var embeddedCells = element.getEmbeddedCells({ deep: true });\n\t        var connectedLinks = graph.getConnectedLinks(element, { deep: true, includeEnclosed: true });\n\n\t        // Note: an embedded cell can be a connect link, but it's fine\n\t        // to iterate over the cell twice.\n\t        [\n\t            element ].concat( embeddedCells,\n\t            connectedLinks\n\t        ).forEach(function (cell) { return initialZIndices[cell.id] = cell.attributes.z; });\n\n\t        element.startBatch('to-front');\n\n\t        // Bring the model to the front with all his embeds.\n\t        element.toFront({ deep: true, ui: true });\n\n\t        // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n\t        // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n\t        var maxZ = graph.getElements().reduce(function (max, cell) { return Math.max(max, cell.attributes.z || 0); }, 0);\n\n\t        // Move to front also all the inbound and outbound links that are connected\n\t        // to any of the element descendant. If we bring to front only embedded elements,\n\t        // links connected to them would stay in the background.\n\t        connectedLinks.forEach(function (link) {\n\t            if (link.attributes.z <= maxZ) {\n\t                link.set('z', maxZ + 1, { ui: true });\n\t            }\n\t        });\n\n\t        element.stopBatch('to-front');\n\n\t        // Before we start looking for suitable parent we remove the current one.\n\t        var parentId = element.parent();\n\t        if (parentId) {\n\t            var parent = graph.getCell(parentId);\n\t            parent.unembed(element, { ui: true });\n\t            data.initialParentId = parentId;\n\t        } else {\n\t            data.initialParentId = null;\n\t        }\n\t    },\n\n\t    processEmbedding: function(data, evt, x, y) {\n\t        if ( data === void 0 ) data = {};\n\n\n\t        var model = data.model || this.model;\n\t        var paper = data.paper || this.paper;\n\t        var graph = paper.model;\n\t        var ref = paper.options;\n\t        var findParentBy = ref.findParentBy;\n\t        var frontParentOnly = ref.frontParentOnly;\n\t        var validateEmbedding = ref.validateEmbedding;\n\n\t        var candidates;\n\t        if (isFunction(findParentBy)) {\n\t            candidates = toArray(findParentBy.call(graph, this, evt, x, y));\n\t        } else if (findParentBy === 'pointer') {\n\t            candidates = toArray(graph.findModelsFromPoint({ x: x, y: y }));\n\t        } else {\n\t            candidates = graph.findModelsUnderElement(model, { searchBy: findParentBy });\n\t        }\n\n\t        candidates = candidates.filter(function (el) {\n\t            return (el instanceof Cell) && (model.id !== el.id) && !el.isEmbeddedIn(model);\n\t        });\n\n\t        if (frontParentOnly) {\n\t            // pick the element with the highest `z` index\n\t            candidates = candidates.slice(-1);\n\t        }\n\n\t        var newCandidateView = null;\n\t        var prevCandidateView = data.candidateEmbedView;\n\n\t        // iterate over all candidates starting from the last one (has the highest z-index).\n\t        for (var i = candidates.length - 1; i >= 0; i--) {\n\t            var candidate = candidates[i];\n\t            if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n\t                // candidate remains the same\n\t                newCandidateView = prevCandidateView;\n\t                break;\n\t            } else {\n\t                var view = candidate.findView(paper);\n\t                if (!isFunction(validateEmbedding) || validateEmbedding.call(paper, this, view)) {\n\t                    // flip to the new candidate\n\t                    newCandidateView = view;\n\t                    break;\n\t                }\n\t            }\n\t        }\n\n\t        if (newCandidateView && newCandidateView != prevCandidateView) {\n\t            // A new candidate view found. Highlight the new one.\n\t            this.clearEmbedding(data);\n\t            data.candidateEmbedView = newCandidateView.highlight(\n\t                newCandidateView.findProxyNode(null, 'container'),\n\t                { embedding: true }\n\t            );\n\t        }\n\n\t        if (!newCandidateView && prevCandidateView) {\n\t            // No candidate view found. Unhighlight the previous candidate.\n\t            this.clearEmbedding(data);\n\t        }\n\t    },\n\n\t    clearEmbedding: function(data) {\n\n\t        data || (data = {});\n\n\t        var candidateView = data.candidateEmbedView;\n\t        if (candidateView) {\n\t            // No candidate view found. Unhighlight the previous candidate.\n\t            candidateView.unhighlight(\n\t                candidateView.findProxyNode(null, 'container'),\n\t                { embedding: true }\n\t            );\n\t            data.candidateEmbedView = null;\n\t        }\n\t    },\n\n\t    finalizeEmbedding: function(data) {\n\t        if ( data === void 0 ) data = {};\n\n\n\t        var candidateView = data.candidateEmbedView;\n\t        var element = data.model || this.model;\n\t        var paper = data.paper || this.paper;\n\n\t        if (candidateView) {\n\n\t            // We finished embedding. Candidate view is chosen to become the parent of the model.\n\t            candidateView.model.embed(element, { ui: true });\n\t            candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), { embedding: true });\n\n\t            data.candidateEmbedView = null;\n\n\t        } else {\n\n\t            var ref = paper.options;\n\t            var validateUnembedding = ref.validateUnembedding;\n\t            var initialParentId = data.initialParentId;\n\t            // The element was originally embedded into another element.\n\t            // The interaction would unembed the element. Let's validate\n\t            // if the element can be unembedded.\n\t            if (\n\t                initialParentId &&\n\t                typeof validateUnembedding === 'function' &&\n\t                !validateUnembedding.call(paper, this)\n\t            ) {\n\t                this._disallowUnembed(data);\n\t                return;\n\t            }\n\t        }\n\n\t        paper.model.getConnectedLinks(element, { deep: true }).forEach(function (link) {\n\t            link.reparent({ ui: true });\n\t        });\n\t    },\n\n\t    _disallowUnembed: function(data) {\n\t        var model = data.model;\n\t        var whenNotAllowed = data.whenNotAllowed; if ( whenNotAllowed === void 0 ) whenNotAllowed = 'revert';\n\t        var element = model || this.model;\n\t        var paper = data.paper || this.paper;\n\t        var graph = paper.model;\n\t        switch (whenNotAllowed) {\n\t            case 'remove': {\n\t                element.remove({ ui: true });\n\t                break;\n\t            }\n\t            case 'revert': {\n\t                var initialParentId = data.initialParentId;\n\t                var initialPosition = data.initialPosition;\n\t                var initialZIndices = data.initialZIndices;\n\t                // Revert the element's position (and the position of its embedded cells if any)\n\t                if (initialPosition) {\n\t                    var x = initialPosition.x;\n\t                    var y = initialPosition.y;\n\t                    element.position(x, y, { deep: true, ui: true });\n\t                }\n\t                // Revert all the z-indices changed during the embedding\n\t                if (initialZIndices) {\n\t                    Object.keys(initialZIndices).forEach(function (id) {\n\t                        var cell = graph.getCell(id);\n\t                        if (cell) {\n\t                            cell.set('z', initialZIndices[id], { ui: true });\n\t                        }\n\t                    });\n\t                }\n\t                // Revert the original parent\n\t                var parent = graph.getCell(initialParentId);\n\t                if (parent) {\n\t                    parent.embed(element, { ui: true });\n\t                }\n\t                break;\n\t            }\n\t        }\n\t    },\n\n\t    getDelegatedView: function() {\n\n\t        var view = this;\n\t        var model = view.model;\n\t        var paper = view.paper;\n\n\t        while (view) {\n\t            if (model.isLink()) { break; }\n\t            if (!model.isEmbedded() || view.can('stopDelegation')) { return view; }\n\t            model = model.getParentCell();\n\t            view = paper.findViewByModel(model);\n\t        }\n\n\t        return null;\n\t    },\n\n\t    findProxyNode: function(el, type) {\n\t        el || (el = this.el);\n\t        var nodeSelector = el.getAttribute((type + \"-selector\"));\n\t        if (nodeSelector) {\n\t            var port = this.findAttribute('port', el);\n\t            if (port) {\n\t                var proxyPortNode = this.findPortNode(port, nodeSelector);\n\t                if (proxyPortNode) { return proxyPortNode; }\n\t            } else {\n\t                var ref = this.findBySelector(nodeSelector);\n\t                var proxyNode = ref[0];\n\t                if (proxyNode) { return proxyNode; }\n\t            }\n\t        }\n\t        return el;\n\t    },\n\n\t    // Interaction. The controller part.\n\t    // ---------------------------------\n\n\t    notifyPointerdown: function notifyPointerdown(evt, x, y) {\n\t        CellView.prototype.pointerdown.call(this, evt, x, y);\n\t        this.notify('element:pointerdown', evt, x, y);\n\t    },\n\n\t    notifyPointermove: function notifyPointermove(evt, x, y) {\n\t        CellView.prototype.pointermove.call(this, evt, x, y);\n\t        this.notify('element:pointermove', evt, x, y);\n\t    },\n\n\t    notifyPointerup: function notifyPointerup(evt, x, y) {\n\t        this.notify('element:pointerup', evt, x, y);\n\t        CellView.prototype.pointerup.call(this, evt, x, y);\n\t    },\n\n\t    pointerdblclick: function(evt, x, y) {\n\n\t        CellView.prototype.pointerdblclick.apply(this, arguments);\n\t        this.notify('element:pointerdblclick', evt, x, y);\n\t    },\n\n\t    pointerclick: function(evt, x, y) {\n\n\t        CellView.prototype.pointerclick.apply(this, arguments);\n\t        this.notify('element:pointerclick', evt, x, y);\n\t    },\n\n\t    contextmenu: function(evt, x, y) {\n\n\t        CellView.prototype.contextmenu.apply(this, arguments);\n\t        this.notify('element:contextmenu', evt, x, y);\n\t    },\n\n\t    pointerdown: function(evt, x, y) {\n\n\t        this.notifyPointerdown(evt, x, y);\n\t        this.dragStart(evt, x, y);\n\t    },\n\n\t    pointermove: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        var targetMagnet = data.targetMagnet;\n\t        var action = data.action;\n\t        var delegatedView = data.delegatedView;\n\n\t        if (targetMagnet) {\n\t            this.magnetpointermove(evt, targetMagnet, x, y);\n\t        }\n\n\t        switch (action) {\n\t            case DragActions.MAGNET:\n\t                this.dragMagnet(evt, x, y);\n\t                break;\n\t            case DragActions.MOVE:\n\t                (delegatedView || this).drag(evt, x, y);\n\t            // eslint: no-fallthrough=false\n\t            default:\n\t                if (data.preventPointerEvents) { break; }\n\t                this.notifyPointermove(evt, x, y);\n\t                break;\n\t        }\n\n\t        // Make sure the element view data is passed along.\n\t        // It could have been wiped out in the handlers above.\n\t        this.eventData(evt, data);\n\t    },\n\n\t    pointerup: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        var targetMagnet = data.targetMagnet;\n\t        var action = data.action;\n\t        var delegatedView = data.delegatedView;\n\n\t        if (targetMagnet) {\n\t            this.magnetpointerup(evt, targetMagnet, x, y);\n\t        }\n\n\t        switch (action) {\n\t            case DragActions.MAGNET:\n\t                this.dragMagnetEnd(evt, x, y);\n\t                break;\n\t            case DragActions.MOVE:\n\t                (delegatedView || this).dragEnd(evt, x, y);\n\t            // eslint: no-fallthrough=false\n\t            default:\n\t                if (data.preventPointerEvents) { break; }\n\t                this.notifyPointerup(evt, x, y);\n\t        }\n\n\t        if (targetMagnet) {\n\t            this.magnetpointerclick(evt, targetMagnet, x, y);\n\t        }\n\n\t        this.checkMouseleave(evt);\n\t    },\n\n\t    mouseover: function(evt) {\n\n\t        CellView.prototype.mouseover.apply(this, arguments);\n\t        this.notify('element:mouseover', evt);\n\t    },\n\n\t    mouseout: function(evt) {\n\n\t        CellView.prototype.mouseout.apply(this, arguments);\n\t        this.notify('element:mouseout', evt);\n\t    },\n\n\t    mouseenter: function(evt) {\n\n\t        CellView.prototype.mouseenter.apply(this, arguments);\n\t        this.notify('element:mouseenter', evt);\n\t    },\n\n\t    mouseleave: function(evt) {\n\n\t        CellView.prototype.mouseleave.apply(this, arguments);\n\t        this.notify('element:mouseleave', evt);\n\t    },\n\n\t    mousewheel: function(evt, x, y, delta) {\n\n\t        CellView.prototype.mousewheel.apply(this, arguments);\n\t        this.notify('element:mousewheel', evt, x, y, delta);\n\t    },\n\n\t    onmagnet: function(evt, x, y) {\n\n\t        var targetMagnet = evt.currentTarget;\n\t        this.magnetpointerdown(evt, targetMagnet, x, y);\n\t        this.eventData(evt, { targetMagnet: targetMagnet });\n\t        this.dragMagnetStart(evt, x, y);\n\t    },\n\n\t    magnetpointerdown: function(evt, magnet, x, y) {\n\n\t        this.notify('element:magnet:pointerdown', evt, magnet, x, y);\n\t    },\n\n\t    magnetpointermove: function(evt, magnet, x, y) {\n\n\t        this.notify('element:magnet:pointermove', evt, magnet, x, y);\n\t    },\n\n\t    magnetpointerup: function(evt, magnet, x, y) {\n\n\t        this.notify('element:magnet:pointerup', evt, magnet, x, y);\n\t    },\n\n\t    magnetpointerdblclick: function(evt, magnet, x, y) {\n\n\t        this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);\n\t    },\n\n\t    magnetcontextmenu: function(evt, magnet, x, y) {\n\n\t        this.notify('element:magnet:contextmenu', evt, magnet, x, y);\n\t    },\n\n\t    // Drag Start Handlers\n\n\t    dragStart: function(evt, x, y) {\n\n\t        if (this.isDefaultInteractionPrevented(evt)) { return; }\n\n\t        var view = this.getDelegatedView();\n\t        if (!view || !view.can('elementMove')) { return; }\n\n\t        this.eventData(evt, {\n\t            action: DragActions.MOVE,\n\t            delegatedView: view\n\t        });\n\n\t        var position = view.model.position();\n\t        view.eventData(evt, {\n\t            initialPosition: position,\n\t            pointerOffset: position.difference(x, y),\n\t            restrictedArea: this.paper.getRestrictedArea(view, x, y)\n\t        });\n\t    },\n\n\t    dragMagnetStart: function(evt, x, y) {\n\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var isPropagationAlreadyStopped = evt.isPropagationStopped();\n\t        if (isPropagationAlreadyStopped) {\n\t            // Special case when the propagation was already stopped\n\t            // on the `element:magnet:pointerdown` event.\n\t            // Do not trigger any `element:pointer*` events\n\t            // but still start the magnet dragging.\n\t            this.eventData(evt, { preventPointerEvents: true });\n\t        }\n\n\t        if (this.isDefaultInteractionPrevented(evt) || !this.can('addLinkFromMagnet')) {\n\t            // Stop the default action, which is to start dragging a link.\n\t            return;\n\t        }\n\n\t        var ref$1 = this.eventData(evt);\n\t        var targetMagnet = ref$1.targetMagnet; if ( targetMagnet === void 0 ) targetMagnet = evt.currentTarget;\n\t        evt.stopPropagation();\n\n\t        // Invalid (Passive) magnet. Start dragging the element.\n\t        if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {\n\t            if (isPropagationAlreadyStopped) {\n\t                // Do not trigger `element:pointerdown` and start element dragging\n\t                // if the propagation was stopped.\n\t                this.dragStart(evt, x, y);\n\t                // The `element:pointerdown` event is not triggered because\n\t                // of `preventPointerEvents` flag.\n\t            } else {\n\t                // We need to reset the action\n\t                // to `MOVE` so that the element is dragged.\n\t                this.pointerdown(evt, x, y);\n\t            }\n\t            return;\n\t        }\n\n\t        // Valid magnet. Start dragging a link.\n\t        if (paper.options.magnetThreshold <= 0) {\n\t            this.dragLinkStart(evt, targetMagnet, x, y);\n\t        }\n\t        this.eventData(evt, { action: DragActions.MAGNET });\n\t    },\n\n\t    // Drag Handlers\n\n\t    drag: function(evt, x, y) {\n\n\t        var paper = this.paper;\n\t        var grid = paper.options.gridSize;\n\t        var element = this.model;\n\t        var data = this.eventData(evt);\n\t        var pointerOffset = data.pointerOffset;\n\t        var restrictedArea = data.restrictedArea;\n\t        var embedding = data.embedding;\n\n\t        // Make sure the new element's position always snaps to the current grid\n\t        var elX = snapToGrid(x + pointerOffset.x, grid);\n\t        var elY = snapToGrid(y + pointerOffset.y, grid);\n\n\t        element.position(elX, elY, { restrictedArea: restrictedArea, deep: true, ui: true });\n\n\t        if (paper.options.embeddingMode) {\n\t            if (!embedding) {\n\t                // Prepare the element for embedding only if the pointer moves.\n\t                // We don't want to do unnecessary action with the element\n\t                // if an user only clicks/dblclicks on it.\n\t                this.prepareEmbedding(data);\n\t                embedding = true;\n\t            }\n\t            this.processEmbedding(data, evt, x, y);\n\t        }\n\n\t        this.eventData(evt, {\n\t            embedding: embedding\n\t        });\n\t    },\n\n\t    dragMagnet: function(evt, x, y) {\n\t        this.dragLink(evt, x, y);\n\t    },\n\n\t    // Drag End Handlers\n\n\t    dragEnd: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        if (data.embedding) { this.finalizeEmbedding(data); }\n\t    },\n\n\t    dragMagnetEnd: function(evt, x, y) {\n\t        this.dragLinkEnd(evt, x, y);\n\t    },\n\n\t    magnetpointerclick: function(evt, magnet, x, y) {\n\t        var paper = this.paper;\n\t        if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) { return; }\n\t        this.notify('element:magnet:pointerclick', evt, magnet, x, y);\n\t    }\n\n\t}, {\n\n\t    Flags: Flags$1,\n\t});\n\n\tassign(ElementView.prototype, elementViewPortPrototype);\n\n\t// Does not make any changes to vertices.\n\t// Returns the arguments that are passed to it, unchanged.\n\tvar normal = function(vertices, opt, linkView) {\n\n\t    return vertices;\n\t};\n\n\t// Routes the link always to/from a certain side\n\t//\n\t// Arguments:\n\t//   padding ... gap between the element and the first vertex. :: Default 40.\n\t//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n\t//\n\tvar oneSide = function(vertices, opt, linkView) {\n\n\t    var side = opt.side || 'bottom';\n\t    var padding = normalizeSides(opt.padding || 40);\n\n\t    // LinkView contains cached source an target bboxes.\n\t    // Note that those are Geometry rectangle objects.\n\t    var sourceBBox = linkView.sourceBBox;\n\t    var targetBBox = linkView.targetBBox;\n\t    var sourcePoint = sourceBBox.center();\n\t    var targetPoint = targetBBox.center();\n\n\t    var coordinate, dimension, direction;\n\n\t    switch (side) {\n\t        case 'bottom':\n\t            direction = 1;\n\t            coordinate = 'y';\n\t            dimension = 'height';\n\t            break;\n\t        case 'top':\n\t            direction = -1;\n\t            coordinate = 'y';\n\t            dimension = 'height';\n\t            break;\n\t        case 'left':\n\t            direction = -1;\n\t            coordinate = 'x';\n\t            dimension = 'width';\n\t            break;\n\t        case 'right':\n\t            direction = 1;\n\t            coordinate = 'x';\n\t            dimension = 'width';\n\t            break;\n\t        default:\n\t            throw new Error('Router: invalid side');\n\t    }\n\n\t    // move the points from the center of the element to outside of it.\n\t    sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n\t    targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);\n\n\t    // make link orthogonal (at least the first and last vertex).\n\t    if ((direction * (sourcePoint[coordinate] - targetPoint[coordinate])) > 0) {\n\t        targetPoint[coordinate] = sourcePoint[coordinate];\n\t    } else {\n\t        sourcePoint[coordinate] = targetPoint[coordinate];\n\t    }\n\n\t    return [sourcePoint].concat(vertices, targetPoint);\n\t};\n\n\t// bearing -> opposite bearing\n\tvar opposites = {\n\t    N: 'S',\n\t    S: 'N',\n\t    E: 'W',\n\t    W: 'E'\n\t};\n\n\t// bearing -> radians\n\tvar radians = {\n\t    N: -Math.PI / 2 * 3,\n\t    S: -Math.PI / 2,\n\t    E: 0,\n\t    W: Math.PI\n\t};\n\n\t// HELPERS //\n\n\t// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n\t// in the given box\n\tfunction freeJoin(p1, p2, bbox) {\n\n\t    var p = new Point(p1.x, p2.y);\n\t    if (bbox.containsPoint(p)) { p = new Point(p2.x, p1.y); }\n\t    // kept for reference\n\t    // if (bbox.containsPoint(p)) p = null;\n\n\t    return p;\n\t}\n\n\t// returns either width or height of a bbox based on the given bearing\n\tfunction getBBoxSize(bbox, bearing) {\n\n\t    return bbox[(bearing === 'W' || bearing === 'E') ? 'width' : 'height'];\n\t}\n\n\t// simple bearing method (calculates only orthogonal cardinals)\n\tfunction getBearing(from, to) {\n\n\t    if (from.x === to.x) { return (from.y > to.y) ? 'N' : 'S'; }\n\t    if (from.y === to.y) { return (from.x > to.x) ? 'W' : 'E'; }\n\t    return null;\n\t}\n\n\t// transform point to a rect\n\tfunction getPointBox(p) {\n\n\t    return new Rect(p.x, p.y, 0, 0);\n\t}\n\n\tfunction getPaddingBox(opt) {\n\n\t    // if both provided, opt.padding wins over opt.elementPadding\n\t    var sides = normalizeSides(opt.padding || opt.elementPadding || 20);\n\n\t    return {\n\t        x: -sides.left,\n\t        y: -sides.top,\n\t        width: sides.left + sides.right,\n\t        height: sides.top + sides.bottom\n\t    };\n\t}\n\n\t// return source bbox\n\tfunction getSourceBBox(linkView, opt) {\n\n\t    return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n\t}\n\n\t// return target bbox\n\tfunction getTargetBBox(linkView, opt) {\n\n\t    return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n\t}\n\n\t// return source anchor\n\tfunction getSourceAnchor(linkView, opt) {\n\n\t    if (linkView.sourceAnchor) { return linkView.sourceAnchor; }\n\n\t    // fallback: center of bbox\n\t    var sourceBBox = getSourceBBox(linkView, opt);\n\t    return sourceBBox.center();\n\t}\n\n\t// return target anchor\n\tfunction getTargetAnchor(linkView, opt) {\n\n\t    if (linkView.targetAnchor) { return linkView.targetAnchor; }\n\n\t    // fallback: center of bbox\n\t    var targetBBox = getTargetBBox(linkView, opt);\n\t    return targetBBox.center(); // default\n\t}\n\n\t// PARTIAL ROUTERS //\n\n\tfunction vertexVertex(from, to, bearing) {\n\n\t    var p1 = new Point(from.x, to.y);\n\t    var p2 = new Point(to.x, from.y);\n\t    var d1 = getBearing(from, p1);\n\t    var d2 = getBearing(from, p2);\n\t    var opposite = opposites[bearing];\n\n\t    var p = (d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))) ? p1 : p2;\n\n\t    return { points: [p], direction: getBearing(p, to) };\n\t}\n\n\tfunction elementVertex(from, to, fromBBox) {\n\n\t    var p = freeJoin(from, to, fromBBox);\n\n\t    return { points: [p], direction: getBearing(p, to) };\n\t}\n\n\tfunction vertexElement(from, to, toBBox, bearing) {\n\n\t    var route = {};\n\n\t    var points = [new Point(from.x, to.y), new Point(to.x, from.y)];\n\t    var freePoints = points.filter(function(pt) {\n\t        return !toBBox.containsPoint(pt);\n\t    });\n\t    var freeBearingPoints = freePoints.filter(function(pt) {\n\t        return getBearing(pt, from) !== bearing;\n\t    });\n\n\t    var p;\n\n\t    if (freeBearingPoints.length > 0) {\n\t        // Try to pick a point which bears the same direction as the previous segment.\n\n\t        p = freeBearingPoints.filter(function(pt) {\n\t            return getBearing(from, pt) === bearing;\n\t        }).pop();\n\t        p = p || freeBearingPoints[0];\n\n\t        route.points = [p];\n\t        route.direction = getBearing(p, to);\n\n\t    } else {\n\t        // Here we found only points which are either contained in the element or they would create\n\t        // a link segment going in opposite direction from the previous one.\n\t        // We take the point inside element and move it outside the element in the direction the\n\t        // route is going. Now we can join this point with the current end (using freeJoin).\n\n\t        p = difference(points, freePoints)[0];\n\n\t        var p2 = (new Point(to)).move(p, -getBBoxSize(toBBox, bearing) / 2);\n\t        var p1 = freeJoin(p2, from, toBBox);\n\n\t        route.points = [p1, p2];\n\t        route.direction = getBearing(p2, to);\n\t    }\n\n\t    return route;\n\t}\n\n\tfunction elementElement(from, to, fromBBox, toBBox) {\n\n\t    var route = elementVertex(to, from, toBBox);\n\t    var p1 = route.points[0];\n\n\t    if (fromBBox.containsPoint(p1)) {\n\n\t        route = elementVertex(from, to, fromBBox);\n\t        var p2 = route.points[0];\n\n\t        if (toBBox.containsPoint(p2)) {\n\n\t            var fromBorder = (new Point(from)).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n\t            var toBorder = (new Point(to)).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n\t            var mid = (new Line(fromBorder, toBorder)).midpoint();\n\n\t            var startRoute = elementVertex(from, mid, fromBBox);\n\t            var endRoute = vertexVertex(mid, to, startRoute.direction);\n\n\t            route.points = [startRoute.points[0], endRoute.points[0]];\n\t            route.direction = endRoute.direction;\n\t        }\n\t    }\n\n\t    return route;\n\t}\n\n\t// Finds route for situations where one element is inside the other.\n\t// Typically the route is directed outside the outer element first and\n\t// then back towards the inner element.\n\tfunction insideElement(from, to, fromBBox, toBBox, bearing) {\n\n\t    var route = {};\n\t    var boundary = fromBBox.union(toBBox).inflate(1);\n\n\t    // start from the point which is closer to the boundary\n\t    var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n\t    var start = reversed ? to : from;\n\t    var end = reversed ? from : to;\n\n\t    var p1, p2, p3;\n\n\t    if (bearing) {\n\t        // Points on circle with radius equals 'W + H` are always outside the rectangle\n\t        // with width W and height H if the center of that circle is the center of that rectangle.\n\t        p1 = Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n\t        p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n\n\t    } else {\n\t        p1 = boundary.pointNearestToPoint(start).move(start, 1);\n\t    }\n\n\t    p2 = freeJoin(p1, end, boundary);\n\n\t    if (p1.round().equals(p2.round())) {\n\t        p2 = Point.fromPolar(boundary.width + boundary.height, toRad(p1.theta(start)) + Math.PI / 2, end);\n\t        p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n\t        p3 = freeJoin(p1, p2, boundary);\n\t        route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n\n\t    } else {\n\t        route.points = reversed ? [p2, p1] : [p1, p2];\n\t    }\n\n\t    route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n\n\t    return route;\n\t}\n\n\t// MAIN ROUTER //\n\n\t// Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n\t// routing from source to target going through `vertices`.\n\tfunction orthogonal(vertices, opt, linkView) {\n\n\t    var sourceBBox = getSourceBBox(linkView, opt);\n\t    var targetBBox = getTargetBBox(linkView, opt);\n\n\t    var sourceAnchor = getSourceAnchor(linkView, opt);\n\t    var targetAnchor = getTargetAnchor(linkView, opt);\n\n\t    // if anchor lies outside of bbox, the bbox expands to include it\n\t    sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n\t    targetBBox = targetBBox.union(getPointBox(targetAnchor));\n\n\t    vertices = toArray(vertices).map(Point);\n\t    vertices.unshift(sourceAnchor);\n\t    vertices.push(targetAnchor);\n\n\t    var bearing; // bearing of previous route segment\n\n\t    var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n\t    for (var i = 0, max = vertices.length - 1; i < max; i++) {\n\n\t        var route = null;\n\n\t        var from = vertices[i];\n\t        var to = vertices[i + 1];\n\n\t        var isOrthogonal = !!getBearing(from, to);\n\n\t        if (i === 0) { // source\n\n\t            if (i + 1 === max) { // route source -> target\n\n\t                // Expand one of the elements by 1px to detect situations when the two\n\t                // elements are positioned next to each other with no gap in between.\n\t                if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {\n\t                    route = insideElement(from, to, sourceBBox, targetBBox);\n\n\t                } else if (!isOrthogonal) {\n\t                    route = elementElement(from, to, sourceBBox, targetBBox);\n\t                }\n\n\t            } else { // route source -> vertex\n\n\t                if (sourceBBox.containsPoint(to)) {\n\t                    route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n\n\t                } else if (!isOrthogonal) {\n\t                    route = elementVertex(from, to, sourceBBox);\n\t                }\n\t            }\n\n\t        } else if (i + 1 === max) { // route vertex -> target\n\n\t            // prevent overlaps with previous line segment\n\t            var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n\n\t            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n\t                route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n\n\t            } else if (!isOrthogonal) {\n\t                route = vertexElement(from, to, targetBBox, bearing);\n\t            }\n\n\t        } else if (!isOrthogonal) { // route vertex -> vertex\n\t            route = vertexVertex(from, to, bearing);\n\t        }\n\n\t        // applicable to all routes:\n\n\t        // set bearing for next iteration\n\t        if (route) {\n\t            Array.prototype.push.apply(orthogonalVertices, route.points);\n\t            bearing = route.direction;\n\n\t        } else {\n\t            // orthogonal route and not looped\n\t            bearing = getBearing(from, to);\n\t        }\n\n\t        // push `to` point to identified orthogonal vertices array\n\t        if (i + 1 < max) {\n\t            orthogonalVertices.push(to);\n\t        }\n\t    }\n\n\t    return orthogonalVertices;\n\t}\n\n\tvar config$1 = {\n\n\t    // size of the step to find a route (the grid of the manhattan pathfinder)\n\t    step: 10,\n\n\t    // the number of route finding loops that cause the router to abort\n\t    // returns fallback route instead\n\t    maximumLoops: 2000,\n\n\t    // the number of decimal places to round floating point coordinates\n\t    precision: 1,\n\n\t    // maximum change of direction\n\t    maxAllowedDirectionChange: 90,\n\n\t    // should the router use perpendicular linkView option?\n\t    // does not connect anchor of element but rather a point close-by that is orthogonal\n\t    // this looks much better\n\t    perpendicular: true,\n\n\t    // should the source and/or target not be considered as obstacles?\n\t    excludeEnds: [], // 'source', 'target'\n\n\t    // should certain types of elements not be considered as obstacles?\n\t    excludeTypes: ['basic.Text'],\n\n\t    // possible starting directions from an element\n\t    startDirections: ['top', 'right', 'bottom', 'left'],\n\n\t    // possible ending directions to an element\n\t    endDirections: ['top', 'right', 'bottom', 'left'],\n\n\t    // specify the directions used above and what they mean\n\t    directionMap: {\n\t        top: { x: 0, y: -1 },\n\t        right: { x: 1, y: 0 },\n\t        bottom: { x: 0, y: 1 },\n\t        left: { x: -1, y: 0 }\n\t    },\n\n\t    // cost of an orthogonal step\n\t    cost: function() {\n\n\t        return this.step;\n\t    },\n\n\t    // an array of directions to find next points on the route\n\t    // different from start/end directions\n\t    directions: function() {\n\n\t        var step = this.step;\n\t        var cost = this.cost();\n\n\t        return [\n\t            { offsetX: step, offsetY: 0, cost: cost },\n\t            { offsetX: -step, offsetY: 0, cost: cost },\n\t            { offsetX: 0, offsetY: step, cost: cost },\n\t            { offsetX: 0, offsetY: -step, cost: cost }\n\t        ];\n\t    },\n\n\t    // a penalty received for direction change\n\t    penalties: function() {\n\n\t        return {\n\t            0: 0,\n\t            45: this.step / 2,\n\t            90: this.step / 2\n\t        };\n\t    },\n\n\t    // padding applied on the element bounding boxes\n\t    paddingBox: function() {\n\n\t        var step = this.step;\n\n\t        return {\n\t            x: -step,\n\t            y: -step,\n\t            width: 2 * step,\n\t            height: 2 * step\n\t        };\n\t    },\n\n\t    // A function that determines whether a given point is an obstacle or not.\n\t    // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.\n\t    // (point: dia.Point) => boolean;\n\t    isPointObstacle: null,\n\n\t    // a router to use when the manhattan router fails\n\t    // (one of the partial routes returns null)\n\t    fallbackRouter: function(vertices, opt, linkView) {\n\n\t        if (!isFunction(orthogonal)) {\n\t            throw new Error('Manhattan requires the orthogonal router as default fallback.');\n\t        }\n\n\t        return orthogonal(vertices, assign({}, config$1, opt), linkView);\n\t    },\n\n\t    /* Deprecated */\n\t    // a simple route used in situations when main routing method fails\n\t    // (exceed max number of loop iterations, inaccessible)\n\t    fallbackRoute: function(from, to, opt) {\n\n\t        return null; // null result will trigger the fallbackRouter\n\n\t        // left for reference:\n\t        /*// Find an orthogonal route ignoring obstacles.\n\n\t        var point = ((opt.previousDirAngle || 0) % 180 === 0)\n\t                ? new g.Point(from.x, to.y)\n\t                : new g.Point(to.x, from.y);\n\n\t        return [point];*/\n\t    },\n\n\t    // if a function is provided, it's used to route the link while dragging an end\n\t    // i.e. function(from, to, opt) { return []; }\n\t    draggingRoute: null\n\t};\n\n\t// HELPER CLASSES //\n\n\t// Map of obstacles\n\t// Helper structure to identify whether a point lies inside an obstacle.\n\tfunction ObstacleMap(opt) {\n\n\t    this.map = {};\n\t    this.options = opt;\n\t    // tells how to divide the paper when creating the elements map\n\t    this.mapGridSize = 100;\n\t}\n\n\tObstacleMap.prototype.build = function(graph, link) {\n\n\t    var opt = this.options;\n\n\t    // source or target element could be excluded from set of obstacles\n\t    var excludedEnds = toArray(opt.excludeEnds).reduce(function(res, item) {\n\n\t        var end = link.get(item);\n\t        if (end) {\n\t            var cell = graph.getCell(end.id);\n\t            if (cell) {\n\t                res.push(cell);\n\t            }\n\t        }\n\n\t        return res;\n\t    }, []);\n\n\t    // Exclude any embedded elements from the source and the target element.\n\t    var excludedAncestors = [];\n\n\t    var source = graph.getCell(link.get('source').id);\n\t    if (source) {\n\t        excludedAncestors = union(excludedAncestors, source.getAncestors().map(function(cell) {\n\t            return cell.id;\n\t        }));\n\t    }\n\n\t    var target = graph.getCell(link.get('target').id);\n\t    if (target) {\n\t        excludedAncestors = union(excludedAncestors, target.getAncestors().map(function(cell) {\n\t            return cell.id;\n\t        }));\n\t    }\n\n\t    // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n\t    // in any obstacle?) (a simplified grid search).\n\t    // The paper is divided into smaller cells, where each holds information about which\n\t    // elements belong to it. When we query whether a point lies inside an obstacle we\n\t    // don't need to go through all obstacles, we check only those in a particular cell.\n\t    var mapGridSize = this.mapGridSize;\n\n\t    graph.getElements().reduce(function(map, element) {\n\n\t        var isExcludedType = toArray(opt.excludeTypes).includes(element.get('type'));\n\t        var isExcludedEnd = excludedEnds.find(function(excluded) {\n\t            return excluded.id === element.id;\n\t        });\n\t        var isExcludedAncestor = excludedAncestors.includes(element.id);\n\n\t        var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n\t        if (!isExcluded) {\n\t            var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n\n\t            var origin = bbox.origin().snapToGrid(mapGridSize);\n\t            var corner = bbox.corner().snapToGrid(mapGridSize);\n\n\t            for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n\t                for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n\t                    var gridKey = x + '@' + y;\n\t                    map[gridKey] = map[gridKey] || [];\n\t                    map[gridKey].push(bbox);\n\t                }\n\t            }\n\t        }\n\n\t        return map;\n\t    }, this.map);\n\n\t    return this;\n\t};\n\n\tObstacleMap.prototype.isPointAccessible = function(point) {\n\n\t    var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n\n\t    return toArray(this.map[mapKey]).every(function(obstacle) {\n\t        return !obstacle.containsPoint(point);\n\t    });\n\t};\n\n\t// Sorted Set\n\t// Set of items sorted by given value.\n\tfunction SortedSet() {\n\t    this.items = [];\n\t    this.hash = {};\n\t    this.values = {};\n\t    this.OPEN = 1;\n\t    this.CLOSE = 2;\n\t}\n\n\tSortedSet.prototype.add = function(item, value) {\n\n\t    if (this.hash[item]) {\n\t        // item removal\n\t        this.items.splice(this.items.indexOf(item), 1);\n\t    } else {\n\t        this.hash[item] = this.OPEN;\n\t    }\n\n\t    this.values[item] = value;\n\n\t    var index$1 = sortedIndex(this.items, item, function(i) {\n\t        return this.values[i];\n\t    }.bind(this));\n\n\t    this.items.splice(index$1, 0, item);\n\t};\n\n\tSortedSet.prototype.remove = function(item) {\n\n\t    this.hash[item] = this.CLOSE;\n\t};\n\n\tSortedSet.prototype.isOpen = function(item) {\n\n\t    return this.hash[item] === this.OPEN;\n\t};\n\n\tSortedSet.prototype.isClose = function(item) {\n\n\t    return this.hash[item] === this.CLOSE;\n\t};\n\n\tSortedSet.prototype.isEmpty = function() {\n\n\t    return this.items.length === 0;\n\t};\n\n\tSortedSet.prototype.pop = function() {\n\n\t    var item = this.items.shift();\n\t    this.remove(item);\n\t    return item;\n\t};\n\n\t// HELPERS //\n\n\t// return source bbox\n\tfunction getSourceBBox$1(linkView, opt) {\n\n\t    // expand by padding box\n\t    if (opt && opt.paddingBox) { return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox); }\n\n\t    return linkView.sourceBBox.clone();\n\t}\n\n\t// return target bbox\n\tfunction getTargetBBox$1(linkView, opt) {\n\n\t    // expand by padding box\n\t    if (opt && opt.paddingBox) { return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox); }\n\n\t    return linkView.targetBBox.clone();\n\t}\n\n\t// return source anchor\n\tfunction getSourceAnchor$1(linkView, opt) {\n\n\t    if (linkView.sourceAnchor) { return linkView.sourceAnchor; }\n\n\t    // fallback: center of bbox\n\t    var sourceBBox = getSourceBBox$1(linkView, opt);\n\t    return sourceBBox.center();\n\t}\n\n\t// return target anchor\n\tfunction getTargetAnchor$1(linkView, opt) {\n\n\t    if (linkView.targetAnchor) { return linkView.targetAnchor; }\n\n\t    // fallback: center of bbox\n\t    var targetBBox = getTargetBBox$1(linkView, opt);\n\t    return targetBBox.center(); // default\n\t}\n\n\t// returns a direction index from start point to end point\n\t// corrects for grid deformation between start and end\n\tfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n\n\t    var quadrant = 360 / numDirections;\n\t    var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n\t    var normalizedAngle = normalizeAngle(angleTheta + (quadrant / 2));\n\t    return quadrant * Math.floor(normalizedAngle / quadrant);\n\t}\n\n\t// helper function for getDirectionAngle()\n\t// corrects for grid deformation\n\t// (if a point is one grid steps away from another in both dimensions,\n\t// it is considered to be 45 degrees away, even if the real angle is different)\n\t// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\n\tfunction fixAngleEnd(start, end, grid, opt) {\n\n\t    var step = opt.step;\n\n\t    var diffX = end.x - start.x;\n\t    var diffY = end.y - start.y;\n\n\t    var gridStepsX = diffX / grid.x;\n\t    var gridStepsY = diffY / grid.y;\n\n\t    var distanceX = gridStepsX * step;\n\t    var distanceY = gridStepsY * step;\n\n\t    return new Point(start.x + distanceX, start.y + distanceY);\n\t}\n\n\t// return the change in direction between two direction angles\n\tfunction getDirectionChange(angle1, angle2) {\n\n\t    var directionChange = Math.abs(angle1 - angle2);\n\t    return (directionChange > 180) ? (360 - directionChange) : directionChange;\n\t}\n\n\t// fix direction offsets according to current grid\n\tfunction getGridOffsets(directions, grid, opt) {\n\n\t    var step = opt.step;\n\n\t    toArray(opt.directions).forEach(function(direction) {\n\n\t        direction.gridOffsetX = (direction.offsetX / step) * grid.x;\n\t        direction.gridOffsetY = (direction.offsetY / step) * grid.y;\n\t    });\n\t}\n\n\t// get grid size in x and y dimensions, adapted to source and target positions\n\tfunction getGrid(step, source, target) {\n\n\t    return {\n\t        source: source.clone(),\n\t        x: getGridDimension(target.x - source.x, step),\n\t        y: getGridDimension(target.y - source.y, step)\n\t    };\n\t}\n\n\t// helper function for getGrid()\n\tfunction getGridDimension(diff, step) {\n\n\t    // return step if diff = 0\n\t    if (!diff) { return step; }\n\n\t    var absDiff = Math.abs(diff);\n\t    var numSteps = Math.round(absDiff / step);\n\n\t    // return absDiff if less than one step apart\n\t    if (!numSteps) { return absDiff; }\n\n\t    // otherwise, return corrected step\n\t    var roundedDiff = numSteps * step;\n\t    var remainder = absDiff - roundedDiff;\n\t    var stepCorrection = remainder / numSteps;\n\n\t    return step + stepCorrection;\n\t}\n\n\t// return a clone of point snapped to grid\n\tfunction snapToGrid$1(point, grid) {\n\n\t    var source = grid.source;\n\n\t    var snappedX = snapToGrid(point.x - source.x, grid.x) + source.x;\n\t    var snappedY = snapToGrid(point.y - source.y, grid.y) + source.y;\n\n\t    return new Point(snappedX, snappedY);\n\t}\n\n\t// round the point to opt.precision\n\tfunction round$4(point, precision) {\n\n\t    return point.round(precision);\n\t}\n\n\t// snap to grid and then round the point\n\tfunction align(point, grid, precision) {\n\n\t    return round$4(snapToGrid$1(point.clone(), grid), precision);\n\t}\n\n\t// return a string representing the point\n\t// string is rounded in both dimensions\n\tfunction getKey(point) {\n\n\t    return point.clone().toString();\n\t}\n\n\t// return a normalized vector from given point\n\t// used to determine the direction of a difference of two points\n\tfunction normalizePoint(point) {\n\n\t    return new Point(\n\t        point.x === 0 ? 0 : Math.abs(point.x) / point.x,\n\t        point.y === 0 ? 0 : Math.abs(point.y) / point.y\n\t    );\n\t}\n\n\t// PATHFINDING //\n\n\t// reconstructs a route by concatenating points with their parents\n\tfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n\n\t    var route = [];\n\n\t    var prevDiff = normalizePoint(to.difference(tailPoint));\n\n\t    // tailPoint is assumed to be aligned already\n\t    var currentKey = getKey(tailPoint);\n\t    var parent = parents[currentKey];\n\n\t    var point;\n\t    while (parent) {\n\n\t        // point is assumed to be aligned already\n\t        point = points[currentKey];\n\n\t        var diff = normalizePoint(point.difference(parent));\n\t        if (!diff.equals(prevDiff)) {\n\t            route.unshift(point);\n\t            prevDiff = diff;\n\t        }\n\n\t        // parent is assumed to be aligned already\n\t        currentKey = getKey(parent);\n\t        parent = parents[currentKey];\n\t    }\n\n\t    // leadPoint is assumed to be aligned already\n\t    var leadPoint = points[currentKey];\n\n\t    var fromDiff = normalizePoint(leadPoint.difference(from));\n\t    if (!fromDiff.equals(prevDiff)) {\n\t        route.unshift(leadPoint);\n\t    }\n\n\t    return route;\n\t}\n\n\t// heuristic method to determine the distance between two points\n\tfunction estimateCost(from, endPoints) {\n\n\t    var min = Infinity;\n\n\t    for (var i = 0, len = endPoints.length; i < len; i++) {\n\t        var cost = from.manhattanDistance(endPoints[i]);\n\t        if (cost < min) { min = cost; }\n\t    }\n\n\t    return min;\n\t}\n\n\t// find points around the bbox taking given directions into account\n\t// lines are drawn from anchor in given directions, intersections recorded\n\t// if anchor is outside bbox, only those directions that intersect get a rect point\n\t// the anchor itself is returned as rect point (representing some directions)\n\t// (since those directions are unobstructed by the bbox)\n\tfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n\n\t    var precision = opt.precision;\n\t    var directionMap = opt.directionMap;\n\n\t    var anchorCenterVector = anchor.difference(bbox.center());\n\n\t    var keys = isObject$1(directionMap) ? Object.keys(directionMap) : [];\n\t    var dirList = toArray(directionList);\n\t    var rectPoints = keys.reduce(function(res, key) {\n\n\t        if (dirList.includes(key)) {\n\t            var direction = directionMap[key];\n\n\t            // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n\t            // even if anchor lies outside of bbox\n\t            var endpoint = new Point(\n\t                anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width),\n\t                anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height)\n\t            );\n\t            var intersectionLine = new Line(anchor, endpoint);\n\n\t            // get the farther intersection, in case there are two\n\t            // (that happens if anchor lies next to bbox)\n\t            var intersections = intersectionLine.intersect(bbox) || [];\n\t            var numIntersections = intersections.length;\n\t            var farthestIntersectionDistance;\n\t            var farthestIntersection = null;\n\t            for (var i = 0; i < numIntersections; i++) {\n\t                var currentIntersection = intersections[i];\n\t                var distance = anchor.squaredDistance(currentIntersection);\n\t                if ((farthestIntersectionDistance === undefined) || (distance > farthestIntersectionDistance)) {\n\t                    farthestIntersectionDistance = distance;\n\t                    farthestIntersection = currentIntersection;\n\t                }\n\t            }\n\n\t            // if an intersection was found in this direction, it is our rectPoint\n\t            if (farthestIntersection) {\n\t                var point = align(farthestIntersection, grid, precision);\n\n\t                // if the rectPoint lies inside the bbox, offset it by one more step\n\t                if (bbox.containsPoint(point)) {\n\t                    point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n\t                }\n\n\t                // then add the point to the result array\n\t                // aligned\n\t                res.push(point);\n\t            }\n\t        }\n\n\t        return res;\n\t    }, []);\n\n\t    // if anchor lies outside of bbox, add it to the array of points\n\t    if (!bbox.containsPoint(anchor)) {\n\t        // aligned\n\t        rectPoints.push(align(anchor, grid, precision));\n\t    }\n\n\t    return rectPoints;\n\t}\n\n\t// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n\t// rectangles get rect points assigned by getRectPoints()\n\tfunction findRoute(from, to, isPointObstacle, opt) {\n\n\t    var precision = opt.precision;\n\n\t    // Get grid for this route.\n\n\t    var sourceAnchor, targetAnchor;\n\n\t    if (from instanceof Rect) { // `from` is sourceBBox\n\t        sourceAnchor = round$4(getSourceAnchor$1(this, opt).clone(), precision);\n\t    } else {\n\t        sourceAnchor = round$4(from.clone(), precision);\n\t    }\n\n\t    if (to instanceof Rect) { // `to` is targetBBox\n\t        targetAnchor = round$4(getTargetAnchor$1(this, opt).clone(), precision);\n\t    } else {\n\t        targetAnchor = round$4(to.clone(), precision);\n\t    }\n\n\t    var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n\n\t    // Get pathfinding points.\n\n\t    var start, end; // aligned with grid by definition\n\t    var startPoints, endPoints; // assumed to be aligned with grid already\n\n\t    // set of points we start pathfinding from\n\t    if (from instanceof Rect) { // `from` is sourceBBox\n\t        start = sourceAnchor;\n\t        startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n\n\t    } else {\n\t        start = sourceAnchor;\n\t        startPoints = [start];\n\t    }\n\n\t    // set of points we want the pathfinding to finish at\n\t    if (to instanceof Rect) { // `to` is targetBBox\n\t        end = targetAnchor;\n\t        endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n\n\t    } else {\n\t        end = targetAnchor;\n\t        endPoints = [end];\n\t    }\n\n\t    // take into account only accessible rect points (those not under obstacles)\n\t    startPoints = startPoints.filter(function (p) { return !isPointObstacle(p); });\n\t    endPoints = endPoints.filter(function (p) { return !isPointObstacle(p); });\n\n\t    // Check that there is an accessible route point on both sides.\n\t    // Otherwise, use fallbackRoute().\n\t    if (startPoints.length > 0 && endPoints.length > 0) {\n\n\t        // The set of tentative points to be evaluated, initially containing the start points.\n\t        // Rounded to nearest integer for simplicity.\n\t        var openSet = new SortedSet();\n\t        // Keeps reference to actual points for given elements of the open set.\n\t        var points = {};\n\t        // Keeps reference to a point that is immediate predecessor of given element.\n\t        var parents = {};\n\t        // Cost from start to a point along best known path.\n\t        var costs = {};\n\n\t        for (var i = 0, n = startPoints.length; i < n; i++) {\n\t            // startPoint is assumed to be aligned already\n\t            var startPoint = startPoints[i];\n\n\t            var key = getKey(startPoint);\n\n\t            openSet.add(key, estimateCost(startPoint, endPoints));\n\t            points[key] = startPoint;\n\t            costs[key] = 0;\n\t        }\n\n\t        var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n\t        var isPathBeginning = (previousRouteDirectionAngle === undefined);\n\n\t        // directions\n\t        var direction, directionChange;\n\t        var directions = opt.directions;\n\t        getGridOffsets(directions, grid, opt);\n\n\t        var numDirections = directions.length;\n\n\t        var endPointsKeys = toArray(endPoints).reduce(function(res, endPoint) {\n\t            // endPoint is assumed to be aligned already\n\n\t            var key = getKey(endPoint);\n\t            res.push(key);\n\t            return res;\n\t        }, []);\n\n\t        // main route finding loop\n\t        var loopsRemaining = opt.maximumLoops;\n\t        while (!openSet.isEmpty() && loopsRemaining > 0) {\n\n\t            // remove current from the open list\n\t            var currentKey = openSet.pop();\n\t            var currentPoint = points[currentKey];\n\t            var currentParent = parents[currentKey];\n\t            var currentCost = costs[currentKey];\n\n\t            var isRouteBeginning = (currentParent === undefined); // undefined for route starts\n\t            var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n\t            var previousDirectionAngle;\n\t            if (!isRouteBeginning) { previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); } // a vertex on the route\n\t            else if (!isPathBeginning) { previousDirectionAngle = previousRouteDirectionAngle; } // beginning of route on the path\n\t            else if (!isStart) { previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); } // beginning of path, start rect point\n\t            else { previousDirectionAngle = null; } // beginning of path, source anchor or `from` point\n\n\t            // check if we reached any endpoint\n\t            var samePoints = startPoints.length === endPoints.length;\n\t            if (samePoints) {\n\t                for (var j = 0; j < startPoints.length; j++) {\n\t                    if (!startPoints[j].equals(endPoints[j])) {\n\t                        samePoints = false;\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            var skipEndCheck = (isRouteBeginning && samePoints);\n\t            if (!skipEndCheck && (endPointsKeys.indexOf(currentKey) >= 0)) {\n\t                opt.previousDirectionAngle = previousDirectionAngle;\n\t                return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n\t            }\n\n\t            // go over all possible directions and find neighbors\n\t            for (i = 0; i < numDirections; i++) {\n\t                direction = directions[i];\n\n\t                var directionAngle = direction.angle;\n\t                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n\n\t                // if the direction changed rapidly, don't use this point\n\t                // any direction is allowed for starting points\n\t                if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) { continue; }\n\n\t                var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n\t                var neighborKey = getKey(neighborPoint);\n\n\t                // Closed points from the openSet were already evaluated.\n\t                if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) { continue; }\n\n\t                // We can only enter end points at an acceptable angle.\n\t                if (endPointsKeys.indexOf(neighborKey) >= 0) { // neighbor is an end point\n\n\t                    var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n\t                    if (!isNeighborEnd) {\n\t                        var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n\t                        var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n\n\t                        if (endDirectionChange > opt.maxAllowedDirectionChange) { continue; }\n\t                    }\n\t                }\n\n\t                // The current direction is ok.\n\n\t                var neighborCost = direction.cost;\n\t                var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n\t                var costFromStart = currentCost + neighborCost + neighborPenalty;\n\n\t                if (!openSet.isOpen(neighborKey) || (costFromStart < costs[neighborKey])) {\n\t                    // neighbor point has not been processed yet\n\t                    // or the cost of the path from start is lower than previously calculated\n\n\t                    points[neighborKey] = neighborPoint;\n\t                    parents[neighborKey] = currentPoint;\n\t                    costs[neighborKey] = costFromStart;\n\t                    openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n\t                }\n\t            }\n\n\t            loopsRemaining--;\n\t        }\n\t    }\n\n\t    // no route found (`to` point either wasn't accessible or finding route took\n\t    // way too much calculation)\n\t    return opt.fallbackRoute.call(this, start, end, opt);\n\t}\n\n\t// resolve some of the options\n\tfunction resolveOptions(opt) {\n\n\t    opt.directions = result(opt, 'directions');\n\t    opt.penalties = result(opt, 'penalties');\n\t    opt.paddingBox = result(opt, 'paddingBox');\n\t    opt.padding = result(opt, 'padding');\n\n\t    if (opt.padding) {\n\t        // if both provided, opt.padding wins over opt.paddingBox\n\t        var sides = normalizeSides(opt.padding);\n\t        opt.paddingBox = {\n\t            x: -sides.left,\n\t            y: -sides.top,\n\t            width: sides.left + sides.right,\n\t            height: sides.top + sides.bottom\n\t        };\n\t    }\n\n\t    toArray(opt.directions).forEach(function(direction) {\n\n\t        var point1 = new Point(0, 0);\n\t        var point2 = new Point(direction.offsetX, direction.offsetY);\n\n\t        direction.angle = normalizeAngle(point1.theta(point2));\n\t    });\n\t}\n\n\t// initialization of the route finding\n\tfunction router(vertices, opt, linkView) {\n\n\t    resolveOptions(opt);\n\n\t    // enable/disable linkView perpendicular option\n\t    linkView.options.perpendicular = !!opt.perpendicular;\n\n\t    var sourceBBox = getSourceBBox$1(linkView, opt);\n\t    var targetBBox = getTargetBBox$1(linkView, opt);\n\n\t    var sourceAnchor = getSourceAnchor$1(linkView, opt);\n\t    //var targetAnchor = getTargetAnchor(linkView, opt);\n\n\t    // pathfinding\n\t    var isPointObstacle;\n\t    if (typeof opt.isPointObstacle === 'function') {\n\t        isPointObstacle = opt.isPointObstacle;\n\t    } else {\n\t        var map = new ObstacleMap(opt);\n\t        map.build(linkView.paper.model, linkView.model);\n\t        isPointObstacle = function (point) { return !map.isPointAccessible(point); };\n\t    }\n\n\t    var oldVertices = toArray(vertices).map(Point);\n\t    var newVertices = [];\n\t    var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n\n\t    // find a route by concatenating all partial routes (routes need to pass through vertices)\n\t    // source -> vertex[1] -> ... -> vertex[n] -> target\n\t    var to, from;\n\n\t    for (var i = 0, len = oldVertices.length; i <= len; i++) {\n\n\t        var partialRoute = null;\n\n\t        from = to || sourceBBox;\n\t        to = oldVertices[i];\n\n\t        if (!to) {\n\t            // this is the last iteration\n\t            // we ran through all vertices in oldVertices\n\t            // 'to' is not a vertex.\n\n\t            to = targetBBox;\n\n\t            // If the target is a point (i.e. it's not an element), we\n\t            // should use dragging route instead of main routing method if it has been provided.\n\t            var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n\n\t            if (isEndingAtPoint && isFunction(opt.draggingRoute)) {\n\t                // Make sure we are passing points only (not rects).\n\t                var dragFrom = (from === sourceBBox) ? sourceAnchor : from;\n\t                var dragTo = to.origin();\n\n\t                partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n\t            }\n\t        }\n\n\t        // if partial route has not been calculated yet use the main routing method to find one\n\t        partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);\n\n\t        if (partialRoute === null) { // the partial route cannot be found\n\t            return opt.fallbackRouter(vertices, opt, linkView);\n\t        }\n\n\t        var leadPoint = partialRoute[0];\n\n\t        // remove the first point if the previous partial route had the same point as last\n\t        if (leadPoint && leadPoint.equals(tailPoint)) { partialRoute.shift(); }\n\n\t        // save tailPoint for next iteration\n\t        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n\n\t        Array.prototype.push.apply(newVertices, partialRoute);\n\t    }\n\n\t    return newVertices;\n\t}\n\n\t// public function\n\tvar manhattan = function(vertices, opt, linkView) {\n\t    return router(vertices, assign({}, config$1, opt), linkView);\n\t};\n\n\tvar config$2 = {\n\n\t    maxAllowedDirectionChange: 45,\n\n\t    // cost of a diagonal step\n\t    diagonalCost: function() {\n\n\t        var step = this.step;\n\t        return Math.ceil(Math.sqrt(step * step << 1));\n\t    },\n\n\t    // an array of directions to find next points on the route\n\t    // different from start/end directions\n\t    directions: function() {\n\n\t        var step = this.step;\n\t        var cost = this.cost();\n\t        var diagonalCost = this.diagonalCost();\n\n\t        return [\n\t            { offsetX: step, offsetY: 0, cost: cost },\n\t            { offsetX: step, offsetY: step, cost: diagonalCost },\n\t            { offsetX: 0, offsetY: step, cost: cost },\n\t            { offsetX: -step, offsetY: step, cost: diagonalCost },\n\t            { offsetX: -step, offsetY: 0, cost: cost },\n\t            { offsetX: -step, offsetY: -step, cost: diagonalCost },\n\t            { offsetX: 0, offsetY: -step, cost: cost },\n\t            { offsetX: step, offsetY: -step, cost: diagonalCost }\n\t        ];\n\t    },\n\n\t    // a simple route used in situations when main routing method fails\n\t    // (exceed max number of loop iterations, inaccessible)\n\t    fallbackRoute: function(from, to, opt) {\n\n\t        // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n\t        var theta = from.theta(to);\n\n\t        var route = [];\n\n\t        var a = { x: to.x, y: from.y };\n\t        var b = { x: from.x, y: to.y };\n\n\t        if (theta % 180 > 90) {\n\t            var t = a;\n\t            a = b;\n\t            b = t;\n\t        }\n\n\t        var p1 = (theta % 90) < 45 ? a : b;\n\t        var l1 = new Line(from, p1);\n\n\t        var alpha = 90 * Math.ceil(theta / 90);\n\n\t        var p2 = Point.fromPolar(l1.squaredLength(), toRad(alpha + 135), p1);\n\t        var l2 = new Line(to, p2);\n\n\t        var intersectionPoint = l1.intersection(l2);\n\t        var point = intersectionPoint ? intersectionPoint : to;\n\n\t        var directionFrom = intersectionPoint ? point : from;\n\n\t        var quadrant = 360 / opt.directions.length;\n\t        var angleTheta = directionFrom.theta(to);\n\t        var normalizedAngle = normalizeAngle(angleTheta + (quadrant / 2));\n\t        var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n\n\t        opt.previousDirectionAngle = directionAngle;\n\n\t        if (point) { route.push(point.round()); }\n\t        route.push(to);\n\n\t        return route;\n\t    }\n\t};\n\n\t// public function\n\tvar metro = function(vertices, opt, linkView) {\n\n\t    if (!isFunction(manhattan)) {\n\t        throw new Error('Metro requires the manhattan router.');\n\t    }\n\n\t    return manhattan(vertices, assign({}, config$2, opt), linkView);\n\t};\n\n\tvar Directions = {\n\t    AUTO: 'auto',\n\t    LEFT: 'left',\n\t    RIGHT: 'right',\n\t    TOP: 'top',\n\t    BOTTOM: 'bottom',\n\t    ANCHOR_SIDE: 'anchor-side',\n\t    MAGNET_SIDE: 'magnet-side'\n\t};\n\n\tvar DEFINED_DIRECTIONS = [Directions.LEFT, Directions.RIGHT, Directions.TOP, Directions.BOTTOM];\n\n\tfunction getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {\n\t    var tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));\n\t    var roundedAngle = Math.round(tangent.angle() / 90) * 90;\n\n\t    switch (roundedAngle) {\n\t        case 0:\n\t        case 360:\n\t            return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n\t        case 90:\n\t            return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n\t        case 180:\n\t            return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n\t        case 270:\n\t            return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n\t    }\n\t}\n\n\tfunction rightAngleRouter(_vertices, opt, linkView) {\n\t    var margin = opt.margin || 20;\n\t    var sourceDirection = opt.sourceDirection; if ( sourceDirection === void 0 ) sourceDirection = Directions.AUTO;\n\t    var targetDirection = opt.targetDirection; if ( targetDirection === void 0 ) targetDirection = Directions.AUTO;\n\n\t    var sourceView = linkView.sourceView;\n\t    var targetView = linkView.targetView;\n\n\t    var isSourcePort = !!linkView.model.source().port;\n\t    var isTargetPort = !!linkView.model.target().port;\n\n\t    if (sourceDirection === Directions.AUTO) {\n\t        sourceDirection = isSourcePort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n\t    }\n\n\t    if (targetDirection === Directions.AUTO) {\n\t        targetDirection = isTargetPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n\t    }\n\n\t    var sourceBBox = linkView.sourceBBox;\n\t    var targetBBox = linkView.targetBBox;\n\t    var sourcePoint = linkView.sourceAnchor;\n\t    var targetPoint = linkView.targetAnchor;\n\t    var ref = sourceView && sourceView.model.isElement() ? Rect.fromRectUnion(sourceBBox, sourceView.model.getBBox()) : linkView.sourceAnchor;\n\t    var sx0 = ref.x;\n\t    var sy0 = ref.y;\n\t    var sourceWidth = ref.width; if ( sourceWidth === void 0 ) sourceWidth = 0;\n\t    var sourceHeight = ref.height; if ( sourceHeight === void 0 ) sourceHeight = 0;\n\n\t    var ref$1 = targetView && targetView.model.isElement() ? Rect.fromRectUnion(targetBBox, targetView.model.getBBox()) : linkView.targetAnchor;\n\t    var tx0 = ref$1.x;\n\t    var ty0 = ref$1.y;\n\t    var targetWidth = ref$1.width; if ( targetWidth === void 0 ) targetWidth = 0;\n\t    var targetHeight = ref$1.height; if ( targetHeight === void 0 ) targetHeight = 0;\n\n\t    var tx1 = tx0 + targetWidth;\n\t    var ty1 = ty0 + targetHeight;\n\t    var sx1 = sx0 + sourceWidth;\n\t    var sy1 = sy0 + sourceHeight;\n\n\t    // Key coordinates including the margin\n\t    var smx0 = sx0 - margin;\n\t    var smx1 = sx1 + margin;\n\t    var smy0 = sy0 - margin;\n\t    var smy1 = sy1 + margin;\n\t    var tmx0 = tx0 - margin;\n\t    var tmx1 = tx1 + margin;\n\t    var tmy0 = ty0 - margin;\n\t    var tmy1 = ty1 + margin;\n\n\t    var sourceOutsidePoint = sourcePoint.clone();\n\n\t    var sourceSide;\n\n\t    if (!sourceView) {\n\t        var sourceLinkAnchorBBox = new Rect(sx0, sy0, 0, 0);\n\t        sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);\n\t    } else if (sourceView.model.isLink()) {\n\t        sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);\n\t    } else if (sourceDirection === Directions.ANCHOR_SIDE) {\n\t        sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);\n\t    } else if (sourceDirection === Directions.MAGNET_SIDE) {\n\t        sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);\n\t    } else {\n\t        sourceSide = sourceDirection;\n\t    }\n\n\t    switch (sourceSide) {\n\t        case 'left':\n\t            sourceOutsidePoint.x = smx0;\n\t            break;\n\t        case 'right':\n\t            sourceOutsidePoint.x = smx1;\n\t            break;\n\t        case 'top':\n\t            sourceOutsidePoint.y = smy0;\n\t            break;\n\t        case 'bottom':\n\t            sourceOutsidePoint.y = smy1;\n\t            break;\n\t    }\n\t    var targetOutsidePoint = targetPoint.clone();\n\n\n\t    var targetSide;\n\n\n\t    if (!targetView) {\n\t        var targetLinkAnchorBBox = new Rect(tx0, ty0, 0, 0);\n\t        targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);\n\t    } else if (targetView.model.isLink()) {\n\t        targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);\n\t    } else if (targetDirection === Directions.ANCHOR_SIDE) {\n\t        targetSide = targetBBox.sideNearestToPoint(targetPoint);\n\t    } else if (targetDirection === Directions.MAGNET_SIDE) {\n\t        targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);\n\t    } else {\n\t        targetSide = targetDirection;\n\t    }\n\n\t    switch (targetSide) {\n\t        case 'left':\n\t            targetOutsidePoint.x = tmx0;\n\t            break;\n\t        case 'right':\n\t            targetOutsidePoint.x = tmx1;\n\t            break;\n\t        case 'top':\n\t            targetOutsidePoint.y = tmy0;\n\t            break;\n\t        case 'bottom':\n\t            targetOutsidePoint.y = tmy1;\n\t            break;\n\t    }\n\n\t    var sox = sourceOutsidePoint.x;\n\t    var soy = sourceOutsidePoint.y;\n\t    var tox = targetOutsidePoint.x;\n\t    var toy = targetOutsidePoint.y;\n\t    var tcx = (tx0 + tx1) / 2;\n\t    var tcy = (ty0 + ty1) / 2;\n\t    var scx = (sx0 + sx1) / 2;\n\t    var scy = (sy0 + sy1) / 2;\n\t    var middleOfVerticalSides = (scx < tcx ? (sx1 + tx0) : (tx1 + sx0)) / 2;\n\t    var middleOfHorizontalSides = (scy < tcy ? (sy1 + ty0) : (ty1 + sy0)) / 2;\n\n\t    if (sourceSide === 'left' && targetSide === 'right') {\n\t        if (smx0 <= tx1) {\n\t            var y = middleOfHorizontalSides;\n\t            if (sx1 <= tx0) {\n\t                if (ty1 >= smy0 && toy < soy) {\n\t                    y = Math.min(tmy0, smy0);\n\t                } else if (ty0 <= smy1 && toy >= soy) {\n\t                    y = Math.max(tmy1, smy1);\n\t                }\n\t            }\n\t            return [\n\t                { x: sox, y: soy },\n\t                { x: sox, y: y },\n\t                { x: tox, y: y },\n\t                { x: tox, y: toy }\n\t            ];\n\t        }\n\n\t        var x = (sox + tox) / 2;\n\t        return [\n\t            { x: x, y: soy },\n\t            { x: x, y: toy }\n\t        ];\n\t    } else if (sourceSide === 'right' && targetSide === 'left') {\n\t        if (smx1 >= tx0) {\n\t            var y$1 = middleOfHorizontalSides;\n\t            if (sox > tx1) {\n\t                if (ty1 >= smy0 && toy < soy) {\n\t                    y$1 = Math.min(tmy0, smy0);\n\t                } else if (ty0 <= smy1 && toy >= soy) {\n\t                    y$1 = Math.max(tmy1, smy1);\n\t                }\n\t            }\n\n\t            return [\n\t                { x: sox, y: soy },\n\t                { x: sox, y: y$1 },\n\t                { x: tox, y: y$1 },\n\t                { x: tox, y: toy }\n\t            ];\n\t        }\n\n\t        var x$1 = (sox + tox) / 2;\n\t        return [\n\t            { x: x$1, y: soy },\n\t            { x: x$1, y: toy }\n\t        ];\n\t    } else if (sourceSide === 'top' && targetSide === 'bottom') {\n\t        if (soy < toy) {\n\t            var x$2 = middleOfVerticalSides;\n\t            var y$2 = soy;\n\n\t            if (soy < ty0) {\n\t                if (tx1 >= smx0 && tox < sox) {\n\t                    x$2 = Math.min(tmx0, smx0);\n\t                } else if (tx0 <= smx1 && tox >= sox) {\n\t                    x$2 = Math.max(tmx1, smx1);\n\t                }\n\t            }\n\n\t            return [\n\t                { x: sox, y: y$2 },\n\t                { x: x$2, y: y$2 },\n\t                { x: x$2, y: toy },\n\t                { x: tox, y: toy }\n\t            ];\n\t        }\n\t        var y$3 = (soy + toy) / 2;\n\t        return [\n\t            { x: sox, y: y$3 },\n\t            { x: tox, y: y$3 }\n\t        ];\n\t    } else if (sourceSide === 'bottom' && targetSide === 'top') {\n\t        if (soy - margin > toy) {\n\t            var x$3 = middleOfVerticalSides;\n\t            var y$4 = soy;\n\n\t            if (soy > ty1) {\n\t                if (tx1 >= smx0 && tox < sox) {\n\t                    x$3 = Math.min(tmx0, smx0);\n\t                } else if (tx0 <= smx1 && tox >= sox) {\n\t                    x$3 = Math.max(tmx1, smx1);\n\t                }\n\t            }\n\n\t            return [\n\t                { x: sox, y: y$4 },\n\t                { x: x$3, y: y$4 },\n\t                { x: x$3, y: toy },\n\t                { x: tox, y: toy }\n\t            ];\n\t        }\n\t        var y$5 = (soy + toy) / 2;\n\t        return [\n\t            { x: sox, y: y$5 },\n\t            { x: tox, y: y$5 }\n\t        ];\n\t    } else if (sourceSide === 'top' && targetSide === 'top') {\n\t        var x$4;\n\t        var y1 = Math.min((sy1 + ty0) / 2, toy);\n\t        var y2 = Math.min((sy0 + ty1) / 2, soy);\n\n\t        if (toy < soy) {\n\t            if (sox >= tmx1 || sox <= tmx0) {\n\t                return [\n\t                    { x: sox, y: Math.min(soy,toy) },\n\t                    { x: tox, y: Math.min(soy,toy) }\n\t                ];\n\t            } else if (tox > sox) {\n\t                x$4 = Math.min(sox, tmx0);\n\t            } else {\n\t                x$4 = Math.max(sox, tmx1);\n\t            }\n\t        } else {\n\t            if (tox >= smx1 || tox <= smx0) {\n\t                return [\n\t                    { x: sox, y: Math.min(soy,toy) },\n\t                    { x: tox, y: Math.min(soy,toy) }\n\t                ];\n\t            } else if (tox >= sox) {\n\t                x$4 = Math.max(tox, smx1);\n\t            } else {\n\t                x$4 = Math.min(tox, smx0);\n\t            }\n\t        }\n\n\t        return [\n\t            { x: sox, y: y2 },\n\t            { x: x$4, y: y2 },\n\t            { x: x$4, y: y1 },\n\t            { x: tox, y: y1 }\n\t        ];\n\t    } else if (sourceSide === 'bottom' && targetSide === 'bottom') {\n\t        if (tx0 >= sox + margin || tx1 <= sox - margin) {\n\t            return [\n\t                { x: sox, y: Math.max(soy, toy) },\n\t                { x: tox, y: Math.max(soy, toy) }\n\t            ];\n\t        }\n\n\t        var x$5;\n\t        var y1$1;\n\t        var y2$1;\n\n\t        if (toy > soy) {\n\t            y1$1 = Math.max((sy1 + ty0) / 2, toy);\n\t            y2$1 = Math.max((sy1 + ty0) / 2, soy);\n\n\t            if (tox > sox) {\n\t                x$5 = Math.min(sox, tmx0);\n\t            } else {\n\t                x$5 = Math.max(sox, tmx1);\n\t            }\n\t        } else {\n\t            y1$1 = Math.max((sy0 + ty1) / 2, toy);\n\t            y2$1 = Math.max((sy0 + ty1) / 2, soy);\n\n\t            if (tox > sox) {\n\t                x$5 = Math.min(tox, smx0);\n\t            } else {\n\t                x$5 = Math.max(tox, smx1);\n\t            }\n\t        }\n\n\t        return [\n\t            { x: sox, y: y2$1 },\n\t            { x: x$5, y: y2$1 },\n\t            { x: x$5, y: y1$1 },\n\t            { x: tox, y: y1$1 }\n\t        ];\n\t    } else if (sourceSide === 'left' && targetSide === 'left') {\n\t        var y$6;\n\t        var x1 = Math.min((sx1 + tx0) / 2, tox);\n\t        var x2 = Math.min((sx0 + tx1) / 2, sox);\n\n\t        if (tox > sox) {\n\t            if (toy <= soy) {\n\t                y$6 = Math.min(smy0, toy);\n\t            } else {\n\t                y$6 = Math.max(smy1, toy);\n\t            }\n\t        } else {\n\t            if (toy >= soy) {\n\t                y$6 = Math.min(tmy0, soy);\n\t            } else {\n\t                y$6 = Math.max(tmy1, soy);\n\t            }\n\t        }\n\n\t        return [\n\t            { x: x2, y: soy },\n\t            { x: x2, y: y$6 },\n\t            { x: x1, y: y$6 },\n\t            { x: x1, y: toy }\n\t        ];\n\t    } else if (sourceSide === 'right' && targetSide === 'right') {\n\t        var y$7;\n\t        var x1$1 = Math.max((sx0 + tx1) / 2, tox);\n\t        var x2$1 = Math.max((sx1 + tx0) / 2, sox);\n\n\t        if (tox < sox) {\n\t            if (toy <= soy) {\n\t                y$7 = Math.min(smy0, toy);\n\t            } else {\n\t                y$7 = Math.max(smy1, toy);\n\t            }\n\t        } else {\n\t            if (toy >= soy) {\n\t                y$7 = Math.min(tmy0, soy);\n\t            } else {\n\t                y$7 = Math.max(tmy1, soy);\n\t            }\n\t        }\n\n\t        return [\n\t            { x: x2$1, y: soy },\n\t            { x: x2$1, y: y$7 },\n\t            { x: x1$1, y: y$7 },\n\t            { x: x1$1, y: toy }\n\t        ];\n\t    } else if (sourceSide === 'top' && targetSide === 'right') {\n\t        if (soy > toy) {\n\t            if (sox < tox) {\n\t                var y$8 = (sy0 + ty1) / 2;\n\t                if (y$8 > tcy && y$8 < tmy1 && sox < tmx0) {\n\t                    y$8 = tmy0;\n\t                }\n\t                return [\n\t                    { x: sox, y: y$8 },\n\t                    { x: tox, y: y$8 },\n\t                    { x: tox, y: toy }\n\t                ];\n\t            }\n\t            return [{ x: sox, y: toy }];\n\t        }\n\n\t        var x$6 = (sx0 + tx1) / 2;\n\n\t        if (sox > tox && sy1 >= toy) {\n\t            return [\n\t                { x: sox, y: soy },\n\t                { x: x$6, y: soy },\n\t                { x: x$6, y: toy }];\n\t        }\n\n\t        if (x$6 > smx0 && soy < ty1) {\n\t            var y$9 = Math.min(sy0, ty0) - margin;\n\t            var x$7 = Math.max(sx1, tx1) + margin;\n\t            return [\n\t                { x: sox, y: y$9 },\n\t                { x: x$7, y: y$9 },\n\t                { x: x$7, y: toy }\n\t            ];\n\t        }\n\t        return [\n\t            { x: sox, y: soy },\n\t            { x: x$6, y: soy },\n\t            { x: x$6, y: toy }\n\t        ];\n\t    } else if (sourceSide === 'top' && targetSide === 'left') {\n\t        if (soy > toy) {\n\t            if (sox > tox) {\n\t                var y$10 = (sy0 + ty1) / 2;\n\t                if (y$10 > tcy && y$10 < tmy1 && sox > tmx1) {\n\t                    y$10 = tmy0;\n\t                }\n\t                return [\n\t                    { x: sox, y: y$10 },\n\t                    { x: tox, y: y$10 },\n\t                    { x: tox, y: toy }\n\t                ];\n\t            }\n\t            return [{ x: sox, y: toy }];\n\t        }\n\n\t        var x$8 = (sx1 + tx0) / 2;\n\n\t        if (sox < tox && sy1 >= toy) {\n\t            return [\n\t                { x: sox, y: soy },\n\t                { x: x$8, y: soy },\n\t                { x: x$8, y: toy }];\n\t        }\n\n\t        if (x$8 < smx1 && soy < ty1) {\n\t            var y$11 = Math.min(sy0, ty0) - margin;\n\t            var x$9 = Math.min(sx0, tx0) - margin;\n\t            return [\n\t                { x: sox, y: y$11 },\n\t                { x: x$9, y: y$11 },\n\t                { x: x$9, y: toy }\n\t            ];\n\t        }\n\t        return [\n\t            { x: sox, y: soy },\n\t            { x: x$8, y: soy },\n\t            { x: x$8, y: toy }\n\t        ];\n\t    } else if (sourceSide === 'bottom' && targetSide === 'right') {\n\t        if (soy < toy) {\n\t            if (sox < tox) {\n\t                var y$12 = (sy1 + ty0) / 2;\n\t                if (y$12 < tcy && y$12 > tmy0 && sox < tmx0) {\n\t                    y$12 = tmy1;\n\t                }\n\t                return [\n\t                    { x: sox, y: y$12 },\n\t                    { x: tox, y: y$12 },\n\t                    { x: tox, y: toy }\n\t                ];\n\t            }\n\t            return [{ x: sox, y: toy }];\n\t        } else {\n\t            if (sx0 < tox) {\n\t                var y$13 = Math.max(sy1, ty1) + margin;\n\t                var x$10 = Math.max(sx1, tx1) + margin;\n\t                return [\n\t                    { x: sox, y: y$13 },\n\t                    { x: x$10, y: y$13 },\n\t                    { x: x$10, y: toy }\n\t                ];\n\t            }\n\t        }\n\n\t        var x$11 = middleOfVerticalSides;\n\n\t        return [\n\t            { x: sox, y: soy },\n\t            { x: x$11, y: soy },\n\t            { x: x$11, y: toy }\n\t        ];\n\t    } else if (sourceSide === 'bottom' && targetSide === 'left') {\n\t        if (soy < toy) {\n\t            if (sox > tox) {\n\t                var y$14 = (sy1 + ty0) / 2;\n\t                if (y$14 < tcy && y$14 > tmy0 && sox > tmx1) {\n\t                    y$14 = tmy1;\n\t                }\n\t                return [\n\t                    { x: sox, y: y$14 },\n\t                    { x: tox, y: y$14 },\n\t                    { x: tox, y: toy }\n\t                ];\n\t            }\n\t            return [{ x: sox, y: toy }];\n\t        } else {\n\t            if (sx1 > tox) {\n\t                var y$15 = Math.max(sy1, ty1) + margin;\n\t                var x$12 = Math.min(sx0, tx0) - margin;\n\t                return [\n\t                    { x: sox, y: y$15 },\n\t                    { x: x$12, y: y$15 },\n\t                    { x: x$12, y: toy }\n\t                ];\n\t            }\n\t        }\n\n\t        var x$13 = middleOfVerticalSides;\n\n\t        return [\n\t            { x: sox, y: soy },\n\t            { x: x$13, y: soy },\n\t            { x: x$13, y: toy }\n\t        ];\n\t    } else if (sourceSide === 'left' && targetSide === 'bottom') {\n\t        if (sox > tox && soy >= tmy1) {\n\t            return [{ x: tox, y: soy }];\n\t        }\n\n\t        if (sox >= tx1 && soy < toy) {\n\t            var x$14 = (sx1 + tx0) / 2;\n\t            return [\n\t                { x: x$14, y: soy },\n\t                { x: x$14, y: toy },\n\t                { x: tox, y: toy }\n\t            ];\n\t        }\n\n\t        if (tox < sx1 && ty1 <= sy0) {\n\t            var y$16 = (sy0 + ty1) / 2;\n\n\t            return [\n\t                { x: sox, y: soy },\n\t                { x: sox, y: y$16 },\n\t                { x: tox, y: y$16 }\n\t            ];\n\t        }\n\n\t        var x$15 = Math.min(tmx0, sox);\n\t        var y$17 = Math.max(sy1, ty1) + margin;\n\n\t        return [\n\t            { x: x$15, y: soy },\n\t            { x: x$15, y: y$17 },\n\t            { x: tox, y: y$17 }\n\t        ];\n\t    } else if (sourceSide === 'left' && targetSide === 'top') {\n\t        if (sox > tox && soy < tmy0) {\n\t            return [{ x: tox, y: soy }];\n\t        }\n\n\t        if (sox >= tx1) {\n\t            if (soy > toy) {\n\t                var x$16 = (sx0 + tx1) / 2;\n\t                return [\n\t                    { x: x$16, y: soy },\n\t                    { x: x$16, y: toy },\n\t                    { x: tox, y: toy }\n\t                ];\n\t            }\n\t        }\n\n\t        if (tox <= sx1 && toy > soy) {\n\t            var y$18 = (ty0 + sy1) / 2;\n\n\t            return [\n\t                { x: sox, y: soy },\n\t                { x: sox, y: y$18 },\n\t                { x: tox, y: y$18 } ];\n\t        }\n\n\t        var x$17 = toy < soy ? Math.min(sx0, tx0) - margin : smx0;\n\t        var y$19 = Math.min(sy0, ty0) - margin;\n\n\t        return [\n\t            { x: x$17, y: soy },\n\t            { x: x$17, y: y$19 },\n\t            { x: tox, y: y$19 }\n\t        ];\n\n\t    } else if (sourceSide === 'right' && targetSide === 'top') {\n\t        if (sox < tox && soy < tmy0) {\n\t            return [{ x: tox, y: soy }];\n\t        }\n\n\t        if (sx1 < tx0 && soy > toy) {\n\t            var x$18 = (sx1 + tx0) / 2;\n\t            return [\n\t                { x: x$18, y: soy },\n\t                { x: x$18, y: toy },\n\t                { x: tox, y: toy }\n\t            ];\n\t        }\n\n\t        if (tox < sox && ty0 > sy1) {\n\t            var y$20 = (sy1 + ty0) / 2;\n\n\t            return [\n\t                { x: sox, y: soy },\n\t                { x: sox, y: y$20 },\n\t                { x: tox, y: y$20 }\n\t            ];\n\t        }\n\n\t        var x$19 = Math.max(sx1, tx1) + margin;\n\t        var y$21 = Math.min(sy0, ty0) - margin;\n\t        return [\n\t            { x: x$19, y: soy },\n\t            { x: x$19, y: y$21 },\n\t            { x: tox, y: y$21 }\n\t        ];\n\t    } else if (sourceSide === 'right' && targetSide === 'bottom') {\n\t        if (sox < tox && soy >= tmy1) {\n\t            return [{ x: tox, y: soy }];\n\t        }\n\n\t        if (sox <= tx0 && soy < toy) {\n\t            var x$20 = (sx1 + tx0) / 2;\n\t            return [\n\t                { x: x$20, y: soy },\n\t                { x: x$20, y: toy },\n\t                { x: tox, y: toy }\n\t            ];\n\t        }\n\n\t        if (tox > sx0 && ty1 < sy0) {\n\t            var y$22 = (sy0 + ty1) / 2;\n\n\t            return [\n\t                { x: sox, y: soy },\n\t                { x: sox, y: y$22 },\n\t                { x: tox, y: y$22 }\n\t            ];\n\t        }\n\n\t        var x$21 = Math.max(tmx1, sox);\n\t        var y$23 = Math.max(sy1, ty1) + margin;\n\n\t        return [\n\t            { x: x$21, y: soy },\n\t            { x: x$21, y: y$23 },\n\t            { x: tox, y: y$23 }\n\t        ];\n\t    }\n\t}\n\n\trightAngleRouter.Directions = Directions;\n\n\tvar rightAngle = rightAngleRouter;\n\n\n\n\tvar routers = ({\n\t\tnormal: normal,\n\t\toneSide: oneSide,\n\t\torthogonal: orthogonal,\n\t\tmanhattan: manhattan,\n\t\tmetro: metro,\n\t\trightAngle: rightAngle\n\t});\n\n\tvar CornerTypes = {\n\t    POINT: 'point',\n\t    CUBIC: 'cubic',\n\t    LINE: 'line',\n\t    GAP: 'gap'\n\t};\n\n\tvar DEFINED_CORNER_TYPES = Object.values(CornerTypes);\n\n\tvar CORNER_RADIUS = 10;\n\tvar PRECISION = 1;\n\n\tvar straight = function(sourcePoint, targetPoint, routePoints, opt) {\n\t    if ( routePoints === void 0 ) routePoints = [];\n\t    if ( opt === void 0 ) opt = {};\n\n\n\t    var cornerType = opt.cornerType; if ( cornerType === void 0 ) cornerType = CornerTypes.POINT;\n\t    var cornerRadius = opt.cornerRadius; if ( cornerRadius === void 0 ) cornerRadius = CORNER_RADIUS;\n\t    var cornerPreserveAspectRatio = opt.cornerPreserveAspectRatio; if ( cornerPreserveAspectRatio === void 0 ) cornerPreserveAspectRatio = false;\n\t    var precision = opt.precision; if ( precision === void 0 ) precision = PRECISION;\n\t    var raw = opt.raw; if ( raw === void 0 ) raw = false;\n\n\t    if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) {\n\t        // unknown `cornerType` provided => error\n\t        throw new Error('Invalid `cornerType` provided to `straight` connector.');\n\t    }\n\n\t    var path;\n\n\t    if ((cornerType === CornerTypes.POINT) || !cornerRadius) {\n\t        // default option => normal connector\n\t        // simply connect all points with straight lines\n\t        var points = [sourcePoint].concat(routePoints).concat([targetPoint]);\n\t        var polyline = new Polyline(points);\n\t        path = new Path(polyline);\n\n\t    } else {\n\t        // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types\n\t        path = new Path();\n\n\t        // add initial gap segment = to source point\n\t        path.appendSegment(Path.createSegment('M', sourcePoint));\n\n\t        var nextDistance;\n\t        var routePointsLength = routePoints.length;\n\t        for (var i = 0; i < routePointsLength; i++) {\n\n\t            var curr = new Point(routePoints[i]);\n\t            var prev = (routePoints[i - 1] || sourcePoint);\n\t            var next = (routePoints[i + 1] || targetPoint);\n\t            var prevDistance = (nextDistance || (curr.distance(prev) / 2)); // try to re-use previously-computed `nextDistance`\n\t            nextDistance = (curr.distance(next) / 2);\n\n\t            var startMove = (void 0), endMove = (void 0);\n\t            if (!cornerPreserveAspectRatio) {\n\t                // `startMove` and `endMove` may be different\n\t                // (this happens when next or previous path point is closer than `2 * cornerRadius`)\n\t                startMove = -Math.min(cornerRadius, prevDistance);\n\t                endMove = -Math.min(cornerRadius, nextDistance);\n\t            } else {\n\t                // force `startMove` and `endMove` to be the same\n\t                startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);\n\t            }\n\n\t            // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):\n\t            // - find a point lying on the line `prev - startMove` such that...\n\t            // - ...the point lies `abs(startMove)` distance away from `curr`...\n\t            // - ...and its coordinates are rounded to whole numbers\n\t            var cornerStart = curr.clone().move(prev, startMove).round(precision);\n\t            var cornerEnd = curr.clone().move(next, endMove).round(precision);\n\n\t            // add in-between straight segment = from previous route point to corner start point\n\t            // (may have zero length)\n\t            path.appendSegment(Path.createSegment('L', cornerStart));\n\n\t            // add corner segment = from corner start point to corner end point\n\t            switch (cornerType) {\n\t                case CornerTypes.CUBIC: {\n\t                    // corner is rounded\n\t                    var _13 = (1 / 3);\n\t                    var _23 = (2 / 3);\n\t                    var control1 = new Point((_13 * cornerStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * cornerStart.y));\n\t                    var control2 = new Point((_13 * cornerEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * cornerEnd.y));\n\t                    path.appendSegment(Path.createSegment('C', control1, control2, cornerEnd));\n\t                    break;\n\t                }\n\t                case CornerTypes.LINE: {\n\t                    // corner has bevel\n\t                    path.appendSegment(Path.createSegment('L', cornerEnd));\n\t                    break;\n\t                }\n\t                case CornerTypes.GAP: {\n\t                    // corner has empty space\n\t                    path.appendSegment(Path.createSegment('M', cornerEnd));\n\t                    break;\n\t                }\n\t                // default: no segment is created\n\t            }\n\t        }\n\n\t        // add final straight segment = from last corner end point to target point\n\t        // (= or from start point to end point, if there are no route points)\n\t        // (may have zero length)\n\t        path.appendSegment(Path.createSegment('L', targetPoint));\n\t    }\n\n\t    return ((raw) ? path : path.serialize());\n\t};\n\n\t// default size of jump if not specified in options\n\tvar JUMP_SIZE = 5;\n\n\t// available jump types\n\t// first one taken as default\n\tvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n\t// default radius\n\tvar RADIUS = 0;\n\n\t// takes care of math. error for case when jump is too close to end of line\n\tvar CLOSE_PROXIMITY_PADDING = 1;\n\n\t// list of connector types not to jump over.\n\tvar IGNORED_CONNECTORS = ['smooth'];\n\n\t// internal constants for round segment\n\tvar _13 = 1 / 3;\n\tvar _23 = 2 / 3;\n\n\t/**\n\t * Transform start/end and route into series of lines\n\t * @param {g.point} sourcePoint start point\n\t * @param {g.point} targetPoint end point\n\t * @param {g.point[]} route optional list of route\n\t * @return {g.line[]} [description]\n\t */\n\tfunction createLines(sourcePoint, targetPoint, route) {\n\t    // make a flattened array of all points\n\t    var points = [].concat(sourcePoint, route, targetPoint);\n\t    return points.reduce(function(resultLines, point, idx) {\n\t        // if there is a next point, make a line with it\n\t        var nextPoint = points[idx + 1];\n\t        if (nextPoint != null) {\n\t            resultLines[idx] = line(point, nextPoint);\n\t        }\n\t        return resultLines;\n\t    }, []);\n\t}\n\n\tfunction setupUpdating(jumpOverLinkView) {\n\t    var paper = jumpOverLinkView.paper;\n\t    var updateList = paper._jumpOverUpdateList;\n\n\t    // first time setup for this paper\n\t    if (updateList == null) {\n\t        updateList = paper._jumpOverUpdateList = [];\n\t        var graph = paper.model;\n\t        graph.on('batch:stop', function() {\n\t            if (this.hasActiveBatch()) { return; }\n\t            updateJumpOver(paper);\n\t        });\n\t        graph.on('reset', function() {\n\t            updateList = paper._jumpOverUpdateList = [];\n\t        });\n\t    }\n\n\t    // add this link to a list so it can be updated when some other link is updated\n\t    if (updateList.indexOf(jumpOverLinkView) < 0) {\n\t        updateList.push(jumpOverLinkView);\n\n\t        // watch for change of connector type or removal of link itself\n\t        // to remove the link from a list of jump over connectors\n\t        jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function() {\n\t            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n\t        });\n\t    }\n\t}\n\n\t/**\n\t * Handler for a batch:stop event to force\n\t * update of all registered links with jump over connector\n\t * @param {object} batchEvent optional object with info about batch\n\t */\n\tfunction updateJumpOver(paper) {\n\t    var updateList = paper._jumpOverUpdateList;\n\t    for (var i = 0; i < updateList.length; i++) {\n\t        var linkView = updateList[i];\n\t        var updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n\t        linkView.requestUpdate(updateFlag);\n\t    }\n\t}\n\n\t/**\n\t * Utility function to collect all intersection points of a single\n\t * line against group of other lines.\n\t * @param {g.line} line where to find points\n\t * @param {g.line[]} crossCheckLines lines to cross\n\t * @return {g.point[]} list of intersection points\n\t */\n\tfunction findLineIntersections(line, crossCheckLines) {\n\t    return toArray(crossCheckLines).reduce(function(res, crossCheckLine) {\n\t        var intersection = line.intersection(crossCheckLine);\n\t        if (intersection) {\n\t            res.push(intersection);\n\t        }\n\t        return res;\n\t    }, []);\n\t}\n\n\t/**\n\t * Sorting function for list of points by their distance.\n\t * @param {g.point} p1 first point\n\t * @param {g.point} p2 second point\n\t * @return {number} squared distance between points\n\t */\n\tfunction sortPoints(p1, p2) {\n\t    return line(p1, p2).squaredLength();\n\t}\n\n\t/**\n\t * Split input line into multiple based on intersection points.\n\t * @param {g.line} line input line to split\n\t * @param {g.point[]} intersections points where to split the line\n\t * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n\t * @return {g.line[]} list of lines being split\n\t */\n\tfunction createJumps(line$1, intersections, jumpSize) {\n\t    return intersections.reduce(function(resultLines, point$1, idx) {\n\t        // skipping points that were merged with the previous line\n\t        // to make bigger arc over multiple lines that are close to each other\n\t        if (point$1.skip === true) {\n\t            return resultLines;\n\t        }\n\n\t        // always grab the last line from buffer and modify it\n\t        var lastLine = resultLines.pop() || line$1;\n\n\t        // calculate start and end of jump by moving by a given size of jump\n\t        var jumpStart = point(point$1).move(lastLine.start, -(jumpSize));\n\t        var jumpEnd = point(point$1).move(lastLine.start, +(jumpSize));\n\n\t        // now try to look at the next intersection point\n\t        var nextPoint = intersections[idx + 1];\n\t        if (nextPoint != null) {\n\t            var distance = jumpEnd.distance(nextPoint);\n\t            if (distance <= jumpSize) {\n\t                // next point is close enough, move the jump end by this\n\t                // difference and mark the next point to be skipped\n\t                jumpEnd = nextPoint.move(lastLine.start, distance);\n\t                nextPoint.skip = true;\n\t            }\n\t        } else {\n\t            // this block is inside of `else` as an optimization so the distance is\n\t            // not calculated when we know there are no other intersection points\n\t            var endDistance = jumpStart.distance(lastLine.end);\n\t            // if the end is too close to possible jump, draw remaining line instead of a jump\n\t            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n\t                resultLines.push(lastLine);\n\t                return resultLines;\n\t            }\n\t        }\n\n\t        var startDistance = jumpEnd.distance(lastLine.start);\n\t        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n\t            // if the start of line is too close to jump, draw that line instead of a jump\n\t            resultLines.push(lastLine);\n\t            return resultLines;\n\t        }\n\n\t        // finally create a jump line\n\t        var jumpLine = line(jumpStart, jumpEnd);\n\t        // it's just simple line but with a `isJump` property\n\t        jumpLine.isJump = true;\n\n\t        resultLines.push(\n\t            line(lastLine.start, jumpStart),\n\t            jumpLine,\n\t            line(jumpEnd, lastLine.end)\n\t        );\n\t        return resultLines;\n\t    }, []);\n\t}\n\n\t/**\n\t * Assemble `D` attribute of a SVG path by iterating given lines.\n\t * @param {g.line[]} lines source lines to use\n\t * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n\t * @param {number} radius the radius\n\t * @return {string}\n\t */\n\tfunction buildPath(lines, jumpSize, jumpType, radius) {\n\n\t    var path = new Path();\n\t    var segment;\n\n\t    // first move to the start of a first line\n\t    segment = Path.createSegment('M', lines[0].start);\n\t    path.appendSegment(segment);\n\n\t    // make a paths from lines\n\t    toArray(lines).forEach(function(line, index) {\n\n\t        if (line.isJump) {\n\t            var angle, diff;\n\n\t            var control1, control2;\n\n\t            if (jumpType === 'arc') { // approximates semicircle with 2 curves\n\t                angle = -90;\n\t                // determine rotation of arc based on difference between points\n\t                diff = line.start.difference(line.end);\n\t                // make sure the arc always points up (or right)\n\t                var xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n\t                if (xAxisRotate) { angle += 180; }\n\n\t                var midpoint = line.midpoint();\n\t                var centerLine = new Line(midpoint, line.end).rotate(midpoint, angle);\n\n\t                var halfLine;\n\n\t                // first half\n\t                halfLine = new Line(line.start, midpoint);\n\n\t                control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n\t                control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n\n\t                segment = Path.createSegment('C', control1, control2, centerLine.end);\n\t                path.appendSegment(segment);\n\n\t                // second half\n\t                halfLine = new Line(midpoint, line.end);\n\n\t                control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n\t                control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n\n\t                segment = Path.createSegment('C', control1, control2, line.end);\n\t                path.appendSegment(segment);\n\n\t            } else if (jumpType === 'gap') {\n\t                segment = Path.createSegment('M', line.end);\n\t                path.appendSegment(segment);\n\n\t            } else if (jumpType === 'cubic') { // approximates semicircle with 1 curve\n\t                angle = line.start.theta(line.end);\n\n\t                var xOffset = jumpSize * 0.6;\n\t                var yOffset = jumpSize * 1.35;\n\n\t                // determine rotation of arc based on difference between points\n\t                diff = line.start.difference(line.end);\n\t                // make sure the arc always points up (or right)\n\t                xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n\t                if (xAxisRotate) { yOffset *= -1; }\n\n\t                control1 = Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n\t                control2 = Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n\n\t                segment = Path.createSegment('C', control1, control2, line.end);\n\t                path.appendSegment(segment);\n\t            }\n\n\t        } else {\n\t            var nextLine = lines[index + 1];\n\t            if (radius == 0 || !nextLine || nextLine.isJump) {\n\t                segment = Path.createSegment('L', line.end);\n\t                path.appendSegment(segment);\n\t            } else {\n\t                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n\t            }\n\t        }\n\t    });\n\n\t    return path;\n\t}\n\n\tfunction buildRoundedSegment(offset, path, curr, prev, next) {\n\t    var prevDistance = curr.distance(prev) / 2;\n\t    var nextDistance = curr.distance(next) / 2;\n\n\t    var startMove = -Math.min(offset, prevDistance);\n\t    var endMove = -Math.min(offset, nextDistance);\n\n\t    var roundedStart = curr.clone().move(prev, startMove).round();\n\t    var roundedEnd = curr.clone().move(next, endMove).round();\n\n\t    var control1 = new Point((_13 * roundedStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedStart.y));\n\t    var control2 = new Point((_13 * roundedEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedEnd.y));\n\n\t    var segment;\n\t    segment = Path.createSegment('L', roundedStart);\n\t    path.appendSegment(segment);\n\n\t    segment = Path.createSegment('C', control1, control2, roundedEnd);\n\t    path.appendSegment(segment);\n\t}\n\n\t/**\n\t * Actual connector function that will be run on every update.\n\t * @param {g.point} sourcePoint start point of this link\n\t * @param {g.point} targetPoint end point of this link\n\t * @param {g.point[]} route of this link\n\t * @param {object} opt options\n\t * @property {number} size optional size of a jump arc\n\t * @return {string} created `D` attribute of SVG path\n\t */\n\tvar jumpover = function(sourcePoint, targetPoint, route, opt) { // eslint-disable-line max-params\n\n\t    setupUpdating(this);\n\n\t    var raw = opt.raw;\n\t    var jumpSize = opt.size || JUMP_SIZE;\n\t    var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n\t    var radius = opt.radius || RADIUS;\n\t    var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n\t    // grab the first jump type as a default if specified one is invalid\n\t    if (JUMP_TYPES.indexOf(jumpType) === -1) {\n\t        jumpType = JUMP_TYPES[0];\n\t    }\n\n\t    var paper = this.paper;\n\t    var graph = paper.model;\n\t    var allLinks = graph.getLinks();\n\n\t    // there is just one link, draw it directly\n\t    if (allLinks.length === 1) {\n\t        return buildPath(\n\t            createLines(sourcePoint, targetPoint, route),\n\t            jumpSize, jumpType, radius\n\t        );\n\t    }\n\n\t    var thisModel = this.model;\n\t    var thisIndex = allLinks.indexOf(thisModel);\n\t    var defaultConnector = paper.options.defaultConnector || {};\n\n\t    // not all links are meant to be jumped over.\n\t    var links = allLinks.filter(function(link, idx) {\n\n\t        var connector = link.get('connector') || defaultConnector;\n\n\t        // avoid jumping over links with connector type listed in `ignored connectors`.\n\t        if (toArray(ignoreConnectors).includes(connector.name)) {\n\t            return false;\n\t        }\n\t        // filter out links that are above this one and  have the same connector type\n\t        // otherwise there would double hoops for each intersection\n\t        if (idx > thisIndex) {\n\t            return connector.name !== 'jumpover';\n\t        }\n\t        return true;\n\t    });\n\n\t    // find views for all links\n\t    var linkViews = links.map(function(link) {\n\t        return paper.findViewByModel(link);\n\t    });\n\n\t    // create lines for this link\n\t    var thisLines = createLines(\n\t        sourcePoint,\n\t        targetPoint,\n\t        route\n\t    );\n\n\t    // create lines for all other links\n\t    var linkLines = linkViews.map(function(linkView) {\n\t        if (linkView == null) {\n\t            return [];\n\t        }\n\t        if (linkView === this) {\n\t            return thisLines;\n\t        }\n\t        return createLines(\n\t            linkView.sourcePoint,\n\t            linkView.targetPoint,\n\t            linkView.route\n\t        );\n\t    }, this);\n\n\t    // transform lines for this link by splitting with jump lines at\n\t    // points of intersection with other links\n\t    var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {\n\t        // iterate all links and grab the intersections with this line\n\t        // these are then sorted by distance so the line can be split more easily\n\n\t        var intersections = links.reduce(function(res, link, i) {\n\t            // don't intersection with itself\n\t            if (link !== thisModel) {\n\n\t                var lineIntersections = findLineIntersections(thisLine, linkLines[i]);\n\t                res.push.apply(res, lineIntersections);\n\t            }\n\t            return res;\n\t        }, []).sort(function(a, b) {\n\t            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n\t        });\n\n\t        if (intersections.length > 0) {\n\t            // split the line based on found intersection points\n\t            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n\t        } else {\n\t            // without any intersection the line goes uninterrupted\n\t            resultLines.push(thisLine);\n\t        }\n\t        return resultLines;\n\t    }, []);\n\n\t    var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n\t    return (raw) ? path : path.serialize();\n\t};\n\n\tvar normal$1 = function(sourcePoint, targetPoint, route, opt) {\n\t    if ( route === void 0 ) route = [];\n\t    if ( opt === void 0 ) opt = {};\n\n\n\t    var raw = opt.raw;\n\t    var localOpt = {\n\t        cornerType: 'point',\n\t        raw: raw\n\t    };\n\n\t    return straight(sourcePoint, targetPoint, route, localOpt);\n\t};\n\n\tvar CORNER_RADIUS$1 = 10;\n\tvar PRECISION$1 = 0;\n\n\tvar rounded = function(sourcePoint, targetPoint, route, opt) {\n\t    if ( route === void 0 ) route = [];\n\t    if ( opt === void 0 ) opt = {};\n\n\n\t    var radius = opt.radius; if ( radius === void 0 ) radius = CORNER_RADIUS$1;\n\t    var raw = opt.raw;\n\t    var localOpt = {\n\t        cornerType: 'cubic',\n\t        cornerRadius: radius,\n\t        precision: PRECISION$1,\n\t        raw: raw\n\t    };\n\n\t    return straight(sourcePoint, targetPoint, route, localOpt);\n\t};\n\n\tvar smooth = function(sourcePoint, targetPoint, route, opt) {\n\n\t    var raw = opt && opt.raw;\n\t    var path;\n\n\t    if (route && route.length !== 0) {\n\n\t        var points = [sourcePoint].concat(route).concat([targetPoint]);\n\t        var curves = Curve.throughPoints(points);\n\n\t        path = new Path(curves);\n\n\t    } else {\n\t        // if we have no route, use a default cubic bezier curve\n\t        // cubic bezier requires two control points\n\t        // the control points have `x` midway between source and target\n\t        // this produces an S-like curve\n\n\t        path = new Path();\n\n\t        var segment;\n\n\t        segment = Path.createSegment('M', sourcePoint);\n\t        path.appendSegment(segment);\n\n\t        if ((Math.abs(sourcePoint.x - targetPoint.x)) >= (Math.abs(sourcePoint.y - targetPoint.y))) {\n\t            var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n\n\t            segment = Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);\n\t            path.appendSegment(segment);\n\n\t        } else {\n\t            var controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n\n\t            segment = Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);\n\t            path.appendSegment(segment);\n\n\t        }\n\t    }\n\n\t    return (raw) ? path : path.serialize();\n\t};\n\n\tvar Directions$1 = {\n\t    AUTO: 'auto',\n\t    HORIZONTAL: 'horizontal',\n\t    VERTICAL: 'vertical',\n\t    CLOSEST_POINT: 'closest-point',\n\t    OUTWARDS: 'outwards'\n\t};\n\n\tvar TangentDirections = {\n\t    UP: 'up',\n\t    DOWN: 'down',\n\t    LEFT: 'left',\n\t    RIGHT: 'right',\n\t    AUTO: 'auto',\n\t    CLOSEST_POINT: 'closest-point',\n\t    OUTWARDS: 'outwards'\n\t};\n\n\tvar curve = function(sourcePoint, targetPoint, route, opt, linkView) {\n\t    if ( route === void 0 ) route = [];\n\t    if ( opt === void 0 ) opt = {};\n\n\t    var raw = Boolean(opt.raw);\n\t    // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.\n\t    // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.\n\t    // tension - a Catmull-Rom curve tension parameter.\n\t    // sourceTangent - a tangent vector along the curve at the sourcePoint.\n\t    // sourceDirection - a unit direction vector along the curve at the sourcePoint.\n\t    // targetTangent - a tangent vector along the curve at the targetPoint.\n\t    // targetDirection - a unit direction vector along the curve at the targetPoint.\n\t    // precision - a rounding precision for path values.\n\t    var direction = opt.direction; if ( direction === void 0 ) direction = Directions$1.AUTO;\n\t    var precision = opt.precision; if ( precision === void 0 ) precision = 3;\n\t    var options = {\n\t        coeff: opt.distanceCoefficient || 0.6,\n\t        angleTangentCoefficient: opt.angleTangentCoefficient || 80,\n\t        tau: opt.tension || 0.5,\n\t        sourceTangent: opt.sourceTangent ? new Point(opt.sourceTangent) : null,\n\t        targetTangent: opt.targetTangent ? new Point(opt.targetTangent) : null,\n\t        rotate: Boolean(opt.rotate)\n\t    };\n\t    if (typeof opt.sourceDirection === 'string')\n\t        { options.sourceDirection = opt.sourceDirection; }\n\t    else if (typeof opt.sourceDirection === 'number')\n\t        { options.sourceDirection = new Point(1, 0).rotate(null, opt.sourceDirection); }\n\t    else\n\t        { options.sourceDirection = opt.sourceDirection ? new Point(opt.sourceDirection).normalize() : null; }\n\n\t    if (typeof opt.targetDirection === 'string')\n\t        { options.targetDirection = opt.targetDirection; }\n\t    else if (typeof opt.targetDirection === 'number')\n\t        { options.targetDirection = new Point(1, 0).rotate(null, opt.targetDirection); }\n\t    else\n\t        { options.targetDirection = opt.targetDirection ? new Point(opt.targetDirection).normalize() : null; }\n\n\t    var completeRoute = [sourcePoint ].concat( route, [targetPoint]).map(function (p) { return new Point(p); });\n\n\t    // The calculation of a sourceTangent\n\t    var sourceTangent;\n\t    if (options.sourceTangent) {\n\t        sourceTangent = options.sourceTangent;\n\t    } else {\n\t        var sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);\n\t        var tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;\n\t        var pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();\n\t        var angle = angleBetweenVectors(sourceDirection, pointsVector);\n\t        if (angle > Math.PI / 4) {\n\t            var updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n\t            sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);\n\t        } else {\n\t            sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);\n\t        }\n\t    }\n\n\t    // The calculation of a targetTangent\n\t    var targetTangent;\n\t    if (options.targetTangent) {\n\t        targetTangent = options.targetTangent;\n\t    } else {\n\t        var targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);\n\t        var last = completeRoute.length - 1;\n\t        var tangentLength$1 = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;\n\t        var pointsVector$1 = completeRoute[last - 1].difference(completeRoute[last]).normalize();\n\t        var angle$1 = angleBetweenVectors(targetDirection, pointsVector$1);\n\t        if (angle$1 > Math.PI / 4) {\n\t            var updatedLength$1 = tangentLength$1 + (angle$1 - Math.PI / 4) * options.angleTangentCoefficient;\n\t            targetTangent = targetDirection.clone().scale(updatedLength$1, updatedLength$1);\n\t        } else {\n\t            targetTangent = targetDirection.clone().scale(tangentLength$1, tangentLength$1);\n\t        }\n\t    }\n\n\t    var catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);\n\t    var bezierCurves = catmullRomCurves.map(function (curve) { return catmullRomToBezier(curve, options); });\n\t    var path = new Path(bezierCurves).round(precision);\n\n\t    return (raw) ? path : path.serialize();\n\t};\n\tcurve.Directions = Directions$1;\n\tcurve.TangentDirections = TangentDirections;\n\n\tfunction getHorizontalSourceDirection(linkView, route, options) {\n\t    var sourceBBox = linkView.sourceBBox;\n\n\t    var sourceSide;\n\t    var rotation;\n\t    if (!linkView.sourceView) {\n\t        if (sourceBBox.x > route[1].x)\n\t            { sourceSide = 'right'; }\n\t        else\n\t            { sourceSide = 'left'; }\n\t    } else {\n\t        rotation = linkView.sourceView.model.angle();\n\t        if (options.rotate && rotation) {\n\t            var unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n\t            var sourcePoint = route[0].clone();\n\t            sourcePoint.rotate(sourceBBox.center(), rotation);\n\t            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n\t        } else {\n\t            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n\t        }\n\t    }\n\n\t    var direction;\n\t    switch (sourceSide) {\n\t        case 'left':\n\t            direction = new Point(-1, 0);\n\t            break;\n\t        case 'right':\n\t        default:\n\t            direction = new Point(1, 0);\n\t            break;\n\t    }\n\n\t    if (options.rotate && rotation) {\n\t        direction.rotate(null, -rotation);\n\t    }\n\n\t    return direction;\n\t}\n\n\tfunction getHorizontalTargetDirection(linkView, route, options) {\n\t    var targetBBox = linkView.targetBBox;\n\n\t    var targetSide;\n\t    var rotation;\n\t    if (!linkView.targetView) {\n\t        if (targetBBox.x > route[route.length - 2].x)\n\t            { targetSide = 'left'; }\n\t        else\n\t            { targetSide = 'right'; }\n\t    } else {\n\t        rotation = linkView.targetView.model.angle();\n\t        if (options.rotate && rotation) {\n\t            var unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n\t            var targetPoint = route[route.length - 1].clone();\n\t            targetPoint.rotate(targetBBox.center(), rotation);\n\t            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n\t        } else {\n\t            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n\t        }\n\t    }\n\n\t    var direction;\n\t    switch (targetSide) {\n\t        case 'left':\n\t            direction = new Point(-1, 0);\n\t            break;\n\t        case 'right':\n\t        default:\n\t            direction = new Point(1, 0);\n\t            break;\n\t    }\n\n\t    if (options.rotate && rotation) {\n\t        direction.rotate(null, -rotation);\n\t    }\n\n\t    return direction;\n\t}\n\n\tfunction getVerticalSourceDirection(linkView, route, options) {\n\t    var sourceBBox = linkView.sourceBBox;\n\n\t    var sourceSide;\n\t    var rotation;\n\t    if (!linkView.sourceView) {\n\t        if (sourceBBox.y > route[1].y)\n\t            { sourceSide = 'bottom'; }\n\t        else\n\t            { sourceSide = 'top'; }\n\t    } else {\n\t        rotation = linkView.sourceView.model.angle();\n\t        if (options.rotate && rotation) {\n\t            var unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n\t            var sourcePoint = route[0].clone();\n\t            sourcePoint.rotate(sourceBBox.center(), rotation);\n\t            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n\t        } else {\n\t            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n\t        }\n\t    }\n\n\t    var direction;\n\t    switch (sourceSide) {\n\t        case 'top':\n\t            direction = new Point(0, -1);\n\t            break;\n\t        case 'bottom':\n\t        default:\n\t            direction = new Point(0, 1);\n\t            break;\n\t    }\n\n\t    if (options.rotate && rotation) {\n\t        direction.rotate(null, -rotation);\n\t    }\n\n\t    return direction;\n\t}\n\n\tfunction getVerticalTargetDirection(linkView, route, options) {\n\t    var targetBBox = linkView.targetBBox;\n\n\t    var targetSide;\n\t    var rotation;\n\t    if (!linkView.targetView) {\n\t        if (targetBBox.y > route[route.length - 2].y)\n\t            { targetSide = 'top'; }\n\t        else\n\t            { targetSide = 'bottom'; }\n\t    } else {\n\t        rotation = linkView.targetView.model.angle();\n\t        if (options.rotate && rotation) {\n\t            var unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n\t            var targetPoint = route[route.length - 1].clone();\n\t            targetPoint.rotate(targetBBox.center(), rotation);\n\t            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n\t        } else {\n\t            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n\t        }\n\t    }\n\n\n\t    var direction;\n\t    switch (targetSide) {\n\t        case 'top':\n\t            direction = new Point(0, -1);\n\t            break;\n\t        case 'bottom':\n\t        default:\n\t            direction = new Point(0, 1);\n\t            break;\n\t    }\n\n\t    if (options.rotate && rotation) {\n\t        direction.rotate(null, -rotation);\n\t    }\n\n\t    return direction;\n\t}\n\n\tfunction getAutoSourceDirection(linkView, route, options) {\n\t    var sourceBBox = linkView.sourceBBox;\n\n\t    var sourceSide;\n\t    var rotation;\n\t    if (!linkView.sourceView) {\n\t        sourceSide = sourceBBox.sideNearestToPoint(route[1]);\n\t    } else {\n\t        rotation = linkView.sourceView.model.angle();\n\t        if (options.rotate && rotation) {\n\t            var unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n\t            var sourcePoint = route[0].clone();\n\t            sourcePoint.rotate(sourceBBox.center(), rotation);\n\t            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n\t        } else {\n\t            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n\t        }\n\t    }\n\n\t    var direction;\n\t    switch (sourceSide) {\n\t        case 'top':\n\t            direction = new Point(0, -1);\n\t            break;\n\t        case 'bottom':\n\t            direction = new Point(0, 1);\n\t            break;\n\t        case 'right':\n\t            direction = new Point(1, 0);\n\t            break;\n\t        case 'left':\n\t            direction = new Point(-1, 0);\n\t            break;\n\t    }\n\n\t    if (options.rotate && rotation) {\n\t        direction.rotate(null, -rotation);\n\t    }\n\n\t    return direction;\n\t}\n\n\tfunction getAutoTargetDirection(linkView, route, options) {\n\t    var targetBBox = linkView.targetBBox;\n\n\t    var targetSide;\n\t    var rotation;\n\t    if (!linkView.targetView) {\n\t        targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);\n\t    } else {\n\t        rotation = linkView.targetView.model.angle();\n\t        if (options.rotate && rotation) {\n\t            var unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n\t            var targetPoint = route[route.length - 1].clone();\n\t            targetPoint.rotate(targetBBox.center(), rotation);\n\t            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n\t        } else {\n\t            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n\t        }\n\t    }\n\n\t    var direction;\n\t    switch (targetSide) {\n\t        case 'top':\n\t            direction = new Point(0, -1);\n\t            break;\n\t        case 'bottom':\n\t            direction = new Point(0, 1);\n\t            break;\n\t        case 'right':\n\t            direction = new Point(1, 0);\n\t            break;\n\t        case 'left':\n\t            direction = new Point(-1, 0);\n\t            break;\n\t    }\n\n\t    if (options.rotate && rotation) {\n\t        direction.rotate(null, -rotation);\n\t    }\n\n\t    return direction;\n\t}\n\n\tfunction getClosestPointSourceDirection(linkView, route, options) {\n\t    return route[1].difference(route[0]).normalize();\n\t}\n\n\tfunction getClosestPointTargetDirection(linkView, route, options) {\n\t    var last = route.length - 1;\n\t    return route[last - 1].difference(route[last]).normalize();\n\t}\n\n\tfunction getOutwardsSourceDirection(linkView, route, options) {\n\t    var sourceBBox = linkView.sourceBBox;\n\t    var sourceCenter = sourceBBox.center();\n\t    return route[0].difference(sourceCenter).normalize();\n\t}\n\n\tfunction getOutwardsTargetDirection(linkView, route, options) {\n\t    var targetBBox = linkView.targetBBox;\n\t    var targetCenter = targetBBox.center();\n\t    return route[route.length - 1].difference(targetCenter).normalize();\n\t}\n\n\tfunction getSourceTangentDirection(linkView, route, direction, options) {\n\t    if (options.sourceDirection) {\n\t        switch (options.sourceDirection) {\n\t            case TangentDirections.UP:\n\t                return new Point(0, -1);\n\t            case TangentDirections.DOWN:\n\t                return new Point(0, 1);\n\t            case TangentDirections.LEFT:\n\t                return new Point(-1, 0);\n\t            case TangentDirections.RIGHT:\n\t                return new Point(1, 0);\n\t            case TangentDirections.AUTO:\n\t                return getAutoSourceDirection(linkView, route, options);\n\t            case TangentDirections.CLOSEST_POINT:\n\t                return getClosestPointSourceDirection(linkView, route, options);\n\t            case TangentDirections.OUTWARDS:\n\t                return getOutwardsSourceDirection(linkView, route, options);\n\t            default:\n\t                return options.sourceDirection;\n\t        }\n\t    }\n\n\t    switch (direction) {\n\t        case Directions$1.HORIZONTAL:\n\t            return getHorizontalSourceDirection(linkView, route, options);\n\t        case Directions$1.VERTICAL:\n\t            return getVerticalSourceDirection(linkView, route, options);\n\t        case Directions$1.CLOSEST_POINT:\n\t            return getClosestPointSourceDirection(linkView, route, options);\n\t        case Directions$1.OUTWARDS:\n\t            return getOutwardsSourceDirection(linkView, route, options);\n\t        case Directions$1.AUTO:\n\t        default:\n\t            return getAutoSourceDirection(linkView, route, options);\n\t    }\n\t}\n\n\tfunction getTargetTangentDirection(linkView, route, direction, options) {\n\t    if (options.targetDirection) {\n\t        switch (options.targetDirection) {\n\t            case TangentDirections.UP:\n\t                return new Point(0, -1);\n\t            case TangentDirections.DOWN:\n\t                return new Point(0, 1);\n\t            case TangentDirections.LEFT:\n\t                return new Point(-1, 0);\n\t            case TangentDirections.RIGHT:\n\t                return new Point(0, 1);\n\t            case TangentDirections.AUTO:\n\t                return getAutoTargetDirection(linkView, route, options);\n\t            case TangentDirections.CLOSEST_POINT:\n\t                return getClosestPointTargetDirection(linkView, route, options);\n\t            case TangentDirections.OUTWARDS:\n\t                return getOutwardsTargetDirection(linkView, route, options);\n\t            default:\n\t                return options.targetDirection;\n\t        }\n\t    }\n\n\t    switch (direction) {\n\t        case Directions$1.HORIZONTAL:\n\t            return getHorizontalTargetDirection(linkView, route, options);\n\t        case Directions$1.VERTICAL:\n\t            return getVerticalTargetDirection(linkView, route, options);\n\t        case Directions$1.CLOSEST_POINT:\n\t            return getClosestPointTargetDirection(linkView, route, options);\n\t        case Directions$1.OUTWARDS:\n\t            return getOutwardsTargetDirection(linkView, route, options);\n\t        case Directions$1.AUTO:\n\t        default:\n\t            return getAutoTargetDirection(linkView, route, options);\n\t    }\n\t}\n\n\tfunction rotateVector(vector, angle) {\n\t    var cos = Math.cos(angle);\n\t    var sin = Math.sin(angle);\n\t    var x = cos * vector.x - sin * vector.y;\n\t    var y = sin * vector.x + cos * vector.y;\n\t    vector.x = x;\n\t    vector.y = y;\n\t}\n\n\tfunction angleBetweenVectors(v1, v2) {\n\t    var cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n\t    if (cos < -1) { cos = -1; }\n\t    if (cos > 1) { cos = 1; }\n\t    return Math.acos(cos);\n\t}\n\n\tfunction determinant(v1, v2) {\n\t    return v1.x * v2.y - v1.y * v2.x;\n\t}\n\n\tfunction createCatmullRomCurves(points, sourceTangent, targetTangent, options) {\n\t    var tau = options.tau;\n\t    var coeff = options.coeff;\n\t    var distances = [];\n\t    var tangents = [];\n\t    var catmullRomCurves = [];\n\t    var n = points.length - 1;\n\n\t    for (var i = 0; i < n; i++) {\n\t        distances[i] = points[i].distance(points[i + 1]);\n\t    }\n\n\t    tangents[0] = sourceTangent;\n\t    tangents[n] = targetTangent;\n\n\t    // The calculation of tangents of vertices\n\t    for (var i$1 = 1; i$1 < n; i$1++) {\n\t        var tpPrev = (void 0);\n\t        var tpNext = (void 0);\n\t        if (i$1 === 1) {\n\t            tpPrev = points[i$1 - 1].clone().offset(tangents[i$1 - 1].x, tangents[i$1 - 1].y);\n\t        } else {\n\t            tpPrev = points[i$1 - 1].clone();\n\t        }\n\t        if (i$1 === n - 1) {\n\t            tpNext = points[i$1 + 1].clone().offset(tangents[i$1 + 1].x, tangents[i$1 + 1].y);\n\t        } else {\n\t            tpNext = points[i$1 + 1].clone();\n\t        }\n\t        var v1 = tpPrev.difference(points[i$1]).normalize();\n\t        var v2 = tpNext.difference(points[i$1]).normalize();\n\t        var vAngle = angleBetweenVectors(v1, v2);\n\n\t        var rot = (Math.PI - vAngle) / 2;\n\t        var t = (void 0);\n\t        var vectorDeterminant = determinant(v1, v2);\n\t        var pointsDeterminant = (void 0);\n\t        pointsDeterminant = determinant(points[i$1].difference(points[i$1 + 1]), points[i$1].difference(points[i$1 - 1]));\n\t        if (vectorDeterminant < 0) {\n\t            rot = -rot;\n\t        }\n\t        if ((vAngle < Math.PI / 2) && ((rot < 0 && pointsDeterminant < 0) || (rot > 0 && pointsDeterminant > 0))) {\n\t            rot = rot - Math.PI;\n\t        }\n\t        t = v2.clone();\n\t        rotateVector(t, rot);\n\n\t        var t1 = t.clone();\n\t        var t2 = t.clone();\n\t        var scaleFactor1 = distances[i$1 - 1] * coeff;\n\t        var scaleFactor2 = distances[i$1] * coeff;\n\t        t1.scale(scaleFactor1, scaleFactor1);\n\t        t2.scale(scaleFactor2, scaleFactor2);\n\n\t        tangents[i$1] = [t1, t2];\n\t    }\n\n\t    // The building of a Catmull-Rom curve based of tangents of points\n\t    for (var i$2 = 0; i$2 < n; i$2++) {\n\t        var p0 = (void 0);\n\t        var p3 = (void 0);\n\t        if (i$2 === 0) {\n\t            p0 = points[i$2 + 1].difference(tangents[i$2].x / tau, tangents[i$2].y / tau);\n\t        } else {\n\t            p0 = points[i$2 + 1].difference(tangents[i$2][1].x / tau, tangents[i$2][1].y / tau);\n\t        }\n\t        if (i$2 === n - 1) {\n\t            p3 = points[i$2].clone().offset(tangents[i$2 + 1].x / tau, tangents[i$2 + 1].y / tau);\n\t        } else {\n\t            p3 = points[i$2].difference(tangents[i$2 + 1][0].x / tau, tangents[i$2 + 1][0].y / tau);\n\t        }\n\n\t        catmullRomCurves[i$2] = [p0, points[i$2], points[i$2 + 1], p3];\n\t    }\n\t    return catmullRomCurves;\n\t}\n\n\t// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)\n\tfunction catmullRomToBezier(points, options) {\n\t    var tau = options.tau;\n\n\t    var bcp1 = new Point();\n\t    bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);\n\t    bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);\n\n\t    var bcp2 = new Point();\n\t    bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);\n\t    bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);\n\t    return new Curve(\n\t        points[1],\n\t        bcp1,\n\t        bcp2,\n\t        points[2]\n\t    );\n\t}\n\n\n\n\tvar connectors = ({\n\t\tstraight: straight,\n\t\tjumpover: jumpover,\n\t\tnormal: normal$1,\n\t\trounded: rounded,\n\t\tsmooth: smooth,\n\t\tcurve: curve\n\t});\n\n\tvar Flags$2 = {\n\t    TOOLS: CellView.Flags.TOOLS,\n\t    RENDER: 'RENDER',\n\t    UPDATE: 'UPDATE',\n\t    LEGACY_TOOLS: 'LEGACY_TOOLS',\n\t    LABELS: 'LABELS',\n\t    VERTICES: 'VERTICES',\n\t    SOURCE: 'SOURCE',\n\t    TARGET: 'TARGET',\n\t    CONNECTOR: 'CONNECTOR'\n\t};\n\n\t// Link base view and controller.\n\t// ----------------------------------------\n\n\tvar LinkView = CellView.extend({\n\n\t    className: function() {\n\n\t        var classNames = CellView.prototype.className.apply(this).split(' ');\n\n\t        classNames.push('link');\n\n\t        return classNames.join(' ');\n\t    },\n\n\t    options: {\n\n\t        shortLinkLength: 105,\n\t        doubleLinkTools: false,\n\t        longLinkLength: 155,\n\t        linkToolsOffset: 40,\n\t        doubleLinkToolsOffset: 65,\n\t        sampleInterval: 50\n\t    },\n\n\t    _labelCache: null,\n\t    _labelSelectors: null,\n\t    _markerCache: null,\n\t    _V: null,\n\t    _dragData: null, // deprecated\n\n\t    metrics: null,\n\t    decimalsRounding: 2,\n\n\t    initialize: function() {\n\n\t        CellView.prototype.initialize.apply(this, arguments);\n\n\t        // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n\t        // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n\t        // nodes in `updateLabelPosition()` in order to update the label positions.\n\t        this._labelCache = {};\n\n\t        // a cache of label selectors\n\t        this._labelSelectors = {};\n\n\t        // keeps markers bboxes and positions again for quicker access\n\t        this._markerCache = {};\n\n\t        // cache of default markup nodes\n\t        this._V = {};\n\n\t        // connection path metrics\n\t        this.cleanNodesCache();\n\t    },\n\n\t    presentationAttributes: {\n\t        markup: [Flags$2.RENDER],\n\t        attrs: [Flags$2.UPDATE],\n\t        router: [Flags$2.UPDATE],\n\t        connector: [Flags$2.CONNECTOR],\n\t        smooth: [Flags$2.UPDATE],\n\t        manhattan: [Flags$2.UPDATE],\n\t        toolMarkup: [Flags$2.LEGACY_TOOLS],\n\t        labels: [Flags$2.LABELS],\n\t        labelMarkup: [Flags$2.LABELS],\n\t        vertices: [Flags$2.VERTICES, Flags$2.UPDATE],\n\t        vertexMarkup: [Flags$2.VERTICES],\n\t        source: [Flags$2.SOURCE, Flags$2.UPDATE],\n\t        target: [Flags$2.TARGET, Flags$2.UPDATE]\n\t    },\n\n\t    initFlag: [Flags$2.RENDER, Flags$2.SOURCE, Flags$2.TARGET, Flags$2.TOOLS],\n\n\t    UPDATE_PRIORITY: 1,\n\n\t    confirmUpdate: function(flags, opt) {\n\n\t        opt || (opt = {});\n\n\t        if (this.hasFlag(flags, Flags$2.SOURCE)) {\n\t            if (!this.updateEndProperties('source')) { return flags; }\n\t            flags = this.removeFlag(flags, Flags$2.SOURCE);\n\t        }\n\n\t        if (this.hasFlag(flags, Flags$2.TARGET)) {\n\t            if (!this.updateEndProperties('target')) { return flags; }\n\t            flags = this.removeFlag(flags, Flags$2.TARGET);\n\t        }\n\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var sourceView = ref.sourceView;\n\t        var targetView = ref.targetView;\n\t        if (paper && ((sourceView && !paper.isViewMounted(sourceView)) || (targetView && !paper.isViewMounted(targetView)))) {\n\t            // Wait for the sourceView and targetView to be rendered\n\t            return flags;\n\t        }\n\n\t        if (this.hasFlag(flags, Flags$2.RENDER)) {\n\t            this.render();\n\t            this.updateHighlighters(true);\n\t            this.updateTools(opt);\n\t            flags = this.removeFlag(flags, [Flags$2.RENDER, Flags$2.UPDATE, Flags$2.VERTICES, Flags$2.LABELS, Flags$2.TOOLS, Flags$2.LEGACY_TOOLS, Flags$2.CONNECTOR]);\n\t            return flags;\n\t        }\n\n\t        var updateHighlighters = false;\n\n\t        if (this.hasFlag(flags, Flags$2.VERTICES)) {\n\t            this.renderVertexMarkers();\n\t            flags = this.removeFlag(flags, Flags$2.VERTICES);\n\t        }\n\n\t        var ref$1 = this;\n\t        var model = ref$1.model;\n\t        var attributes = model.attributes;\n\t        var updateLabels = this.hasFlag(flags, Flags$2.LABELS);\n\t        var updateLegacyTools = this.hasFlag(flags, Flags$2.LEGACY_TOOLS);\n\n\t        if (updateLabels) {\n\t            this.onLabelsChange(model, attributes.labels, opt);\n\t            flags = this.removeFlag(flags, Flags$2.LABELS);\n\t            updateHighlighters = true;\n\t        }\n\n\t        if (updateLegacyTools) {\n\t            this.renderTools();\n\t            flags = this.removeFlag(flags, Flags$2.LEGACY_TOOLS);\n\t        }\n\n\t        var updateAll = this.hasFlag(flags, Flags$2.UPDATE);\n\t        var updateConnector = this.hasFlag(flags, Flags$2.CONNECTOR);\n\t        if (updateAll || updateConnector) {\n\t            if (!updateAll) {\n\t                // Keep the current route and update the geometry\n\t                this.updatePath();\n\t                this.updateDOM();\n\t            } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n\t                // The link is being translated by an ancestor that will\n\t                // shift source point, target point and all vertices\n\t                // by an equal distance.\n\t                this.translate(opt.tx, opt.ty);\n\t            } else {\n\t                this.update();\n\t            }\n\t            this.updateTools(opt);\n\t            flags = this.removeFlag(flags, [Flags$2.UPDATE, Flags$2.TOOLS, Flags$2.CONNECTOR]);\n\t            updateLabels = false;\n\t            updateLegacyTools = false;\n\t            updateHighlighters = true;\n\t        }\n\n\t        if (updateLabels) {\n\t            this.updateLabelPositions();\n\t        }\n\n\t        if (updateLegacyTools) {\n\t            this.updateToolsPosition();\n\t        }\n\n\t        if (updateHighlighters) {\n\t            this.updateHighlighters();\n\t        }\n\n\t        if (this.hasFlag(flags, Flags$2.TOOLS)) {\n\t            this.updateTools(opt);\n\t            flags = this.removeFlag(flags, Flags$2.TOOLS);\n\t        }\n\n\t        return flags;\n\t    },\n\n\t    requestConnectionUpdate: function(opt) {\n\t        this.requestUpdate(this.getFlag(Flags$2.UPDATE), opt);\n\t    },\n\n\t    isLabelsRenderRequired: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        var previousLabels = this.model.previous('labels');\n\t        if (!previousLabels) { return true; }\n\n\t        // Here is an optimization for cases when we know, that change does\n\t        // not require re-rendering of all labels.\n\t        if (('propertyPathArray' in opt) && ('propertyValue' in opt)) {\n\t            // The label is setting by `prop()` method\n\t            var pathArray = opt.propertyPathArray || [];\n\t            var pathLength = pathArray.length;\n\t            if (pathLength > 1) {\n\t                // We are changing a single label here e.g. 'labels/0/position'\n\t                var labelExists = !!previousLabels[pathArray[1]];\n\t                if (labelExists) {\n\t                    if (pathLength === 2) {\n\t                        // We are changing the entire label. Need to check if the\n\t                        // markup is also being changed.\n\t                        return ('markup' in Object(opt.propertyValue));\n\t                    } else if (pathArray[2] !== 'markup') {\n\t                        // We are changing a label property but not the markup\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        return true;\n\t    },\n\n\t    onLabelsChange: function(_link, _labels, opt) {\n\n\t        // Note: this optimization works in async=false mode only\n\t        if (this.isLabelsRenderRequired(opt)) {\n\t            this.renderLabels();\n\t        } else {\n\t            this.updateLabels();\n\t        }\n\t    },\n\n\t    // Rendering.\n\t    // ----------\n\n\t    render: function() {\n\n\t        this.vel.empty();\n\t        this.unmountLabels();\n\t        this._V = {};\n\t        this.renderMarkup();\n\t        // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n\t        // returns zero values)\n\t        this.renderLabels();\n\t        this.update();\n\n\t        return this;\n\t    },\n\n\t    renderMarkup: function() {\n\n\t        var link = this.model;\n\t        var markup = link.get('markup') || link.markup;\n\t        if (!markup) { throw new Error('dia.LinkView: markup required'); }\n\t        if (Array.isArray(markup)) { return this.renderJSONMarkup(markup); }\n\t        if (typeof markup === 'string') { return this.renderStringMarkup(markup); }\n\t        throw new Error('dia.LinkView: invalid markup');\n\t    },\n\n\t    renderJSONMarkup: function(markup) {\n\n\t        var doc = this.parseDOMJSON(markup, this.el);\n\t        // Selectors\n\t        this.selectors = doc.selectors;\n\t        // Fragment\n\t        this.vel.append(doc.fragment);\n\t    },\n\n\t    renderStringMarkup: function(markup) {\n\n\t        // A special markup can be given in the `properties.markup` property. This might be handy\n\t        // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n\t        // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n\t        // of elements with special meaning though. Therefore, those classes should be preserved in any\n\t        // special markup passed in `properties.markup`.\n\t        var children = V(markup);\n\t        // custom markup may contain only one children\n\t        if (!Array.isArray(children)) { children = [children]; }\n\t        // Cache all children elements for quicker access.\n\t        var cache = this._V; // vectorized markup;\n\t        for (var i = 0, n = children.length; i < n; i++) {\n\t            var child = children[i];\n\t            var className = child.attr('class');\n\t            if (className) {\n\t                // Strip the joint class name prefix, if there is one.\n\t                className = removeClassNamePrefix(className);\n\t                cache[$.camelCase(className)] = child;\n\t            }\n\t        }\n\t        // partial rendering\n\t        this.renderTools();\n\t        this.renderVertexMarkers();\n\t        this.renderArrowheadMarkers();\n\t        this.vel.append(children);\n\t    },\n\n\t    _getLabelMarkup: function(labelMarkup) {\n\n\t        if (!labelMarkup) { return undefined; }\n\n\t        if (Array.isArray(labelMarkup)) { return this.parseDOMJSON(labelMarkup, null); }\n\t        if (typeof labelMarkup === 'string') { return this._getLabelStringMarkup(labelMarkup); }\n\t        throw new Error('dia.linkView: invalid label markup');\n\t    },\n\n\t    _getLabelStringMarkup: function(labelMarkup) {\n\n\t        var children = V(labelMarkup);\n\t        var fragment = document.createDocumentFragment();\n\n\t        if (!Array.isArray(children)) {\n\t            fragment.appendChild(children.node);\n\n\t        } else {\n\t            for (var i = 0, n = children.length; i < n; i++) {\n\t                var currentChild = children[i].node;\n\t                fragment.appendChild(currentChild);\n\t            }\n\t        }\n\n\t        return { fragment: fragment, selectors: {}}; // no selectors\n\t    },\n\n\t    // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n\t    // If it doesn't, add the <g /> container here.\n\t    _normalizeLabelMarkup: function(markup) {\n\n\t        if (!markup) { return undefined; }\n\n\t        var fragment = markup.fragment;\n\t        if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) { throw new Error('dia.LinkView: invalid label markup.'); }\n\n\t        var vNode;\n\t        var childNodes = fragment.childNodes;\n\n\t        if ((childNodes.length > 1) || childNodes[0].nodeName.toUpperCase() !== 'G') {\n\t            // default markup fragment is not wrapped in <g />\n\t            // add a <g /> container\n\t            vNode = V('g').append(fragment);\n\t        } else {\n\t            vNode = V(childNodes[0]);\n\t        }\n\n\t        vNode.addClass('label');\n\n\t        return { node: vNode.node, selectors: markup.selectors };\n\t    },\n\n\t    renderLabels: function() {\n\n\t        var cache = this._V;\n\t        var vLabels = cache.labels;\n\t        var labelCache = this._labelCache = {};\n\t        var labelSelectors = this._labelSelectors = {};\n\t        var model = this.model;\n\t        var labels = model.attributes.labels || [];\n\t        var labelsCount = labels.length;\n\n\t        if (labelsCount === 0) {\n\t            if (vLabels) { vLabels.remove(); }\n\t            return this;\n\t        }\n\n\t        if (vLabels) {\n\t            vLabels.empty();\n\t        }  else {\n\t            // there is no label container in the markup but some labels are defined\n\t            // add a <g class=\"labels\" /> container\n\t            vLabels = cache.labels = V('g').addClass('labels');\n\t            if (this.options.labelsLayer) {\n\t                vLabels.addClass(addClassNamePrefix(result(this, 'className')));\n\t                vLabels.attr('model-id', model.id);\n\t            }\n\t        }\n\n\t        for (var i = 0; i < labelsCount; i++) {\n\n\t            var label = labels[i];\n\t            var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n\t            var labelNode;\n\t            var selectors;\n\t            if (labelMarkup) {\n\n\t                labelNode = labelMarkup.node;\n\t                selectors = labelMarkup.selectors;\n\n\t            } else {\n\n\t                var builtinDefaultLabel =  model._builtins.defaultLabel;\n\t                var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n\t                var defaultLabel = model._getDefaultLabel();\n\t                var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n\t                var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n\n\t                labelNode = defaultMarkup.node;\n\t                selectors = defaultMarkup.selectors;\n\t            }\n\n\t            labelNode.setAttribute('label-idx', i); // assign label-idx\n\t            vLabels.append(labelNode);\n\t            labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n\t            var rootSelector = this.selector;\n\t            if (selectors[rootSelector]) { throw new Error('dia.LinkView: ambiguous label root selector.'); }\n\t            selectors[rootSelector] = labelNode;\n\n\t            labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n\t        }\n\t        if (!vLabels.parent()) {\n\t            this.mountLabels();\n\t        }\n\n\t        this.updateLabels();\n\n\t        return this;\n\t    },\n\n\t    mountLabels: function() {\n\t        var ref = this;\n\t        var el = ref.el;\n\t        var paper = ref.paper;\n\t        var model = ref.model;\n\t        var _V = ref._V;\n\t        var options = ref.options;\n\t        var vLabels = _V.labels;\n\t        if (!vLabels || !model.hasLabels()) { return; }\n\t        var node = vLabels.node;\n\t        if (options.labelsLayer) {\n\t            paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));\n\t        } else {\n\t            if (node.parentNode !== el) {\n\t                el.appendChild(node);\n\t            }\n\t        }\n\t    },\n\n\t    unmountLabels: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var _V = ref._V;\n\t        if (!_V) { return; }\n\t        var vLabels = _V.labels;\n\t        if (vLabels && options.labelsLayer) {\n\t            vLabels.remove();\n\t        }\n\t    },\n\n\t    findLabelNode: function(labelIndex, selector) {\n\t        var labelRoot = this._labelCache[labelIndex];\n\t        if (!labelRoot) { return null; }\n\t        var labelSelectors = this._labelSelectors[labelIndex];\n\t        var ref = this.findBySelector(selector, labelRoot, labelSelectors);\n\t        var node = ref[0]; if ( node === void 0 ) node = null;\n\t        return node;\n\t    },\n\n\n\t    // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)\n\t    // keep `undefined` or `null` because `{}` means something else\n\t    _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n\n\t        if (labelAttrs === null) { return null; }\n\t        if (labelAttrs === undefined) {\n\n\t            if (defaultLabelAttrs === null) { return null; }\n\t            if (defaultLabelAttrs === undefined) {\n\n\t                if (hasCustomMarkup) { return undefined; }\n\t                return builtinDefaultLabelAttrs;\n\t            }\n\n\t            if (hasCustomMarkup) { return defaultLabelAttrs; }\n\t            return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n\t        }\n\n\t        if (hasCustomMarkup) { return merge({}, defaultLabelAttrs, labelAttrs); }\n\t        return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n\t    },\n\n\t    // merge default label size into label size (no built-in default)\n\t    // keep `undefined` or `null` because `{}` means something else\n\t    _mergeLabelSize: function(labelSize, defaultLabelSize) {\n\n\t        if (labelSize === null) { return null; }\n\t        if (labelSize === undefined) {\n\n\t            if (defaultLabelSize === null) { return null; }\n\t            if (defaultLabelSize === undefined) { return undefined; }\n\n\t            return defaultLabelSize;\n\t        }\n\n\t        return merge({}, defaultLabelSize, labelSize);\n\t    },\n\n\t    updateLabels: function() {\n\n\t        if (!this._V.labels) { return this; }\n\n\t        var model = this.model;\n\t        var labels = model.get('labels') || [];\n\t        var canLabelMove = this.can('labelMove');\n\n\t        var builtinDefaultLabel = model._builtins.defaultLabel;\n\t        var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n\n\t        var defaultLabel = model._getDefaultLabel();\n\t        var defaultLabelMarkup = defaultLabel.markup;\n\t        var defaultLabelAttrs = defaultLabel.attrs;\n\t        var defaultLabelSize = defaultLabel.size;\n\n\t        for (var i = 0, n = labels.length; i < n; i++) {\n\n\t            var labelNode = this._labelCache[i];\n\t            labelNode.setAttribute('cursor', (canLabelMove ? 'move' : 'default'));\n\n\t            var selectors = this._labelSelectors[i];\n\n\t            var label = labels[i];\n\t            var labelMarkup = label.markup;\n\t            var labelAttrs = label.attrs;\n\t            var labelSize = label.size;\n\n\t            var attrs = this._mergeLabelAttrs(\n\t                (labelMarkup || defaultLabelMarkup),\n\t                labelAttrs,\n\t                defaultLabelAttrs,\n\t                builtinDefaultLabelAttrs\n\t            );\n\n\t            var size = this._mergeLabelSize(\n\t                labelSize,\n\t                defaultLabelSize\n\t            );\n\n\t            this.updateDOMSubtreeAttributes(labelNode, attrs, {\n\t                rootBBox: new Rect(size),\n\t                selectors: selectors\n\t            });\n\t        }\n\n\t        return this;\n\t    },\n\n\t    renderTools: function() {\n\n\t        if (!this._V.linkTools) { return this; }\n\n\t        // Tools are a group of clickable elements that manipulate the whole link.\n\t        // A good example of this is the remove tool that removes the whole link.\n\t        // Tools appear after hovering the link close to the `source` element/point of the link\n\t        // but are offset a bit so that they don't cover the `marker-arrowhead`.\n\n\t        var $tools = $(this._V.linkTools.node).empty();\n\t        var toolTemplate = template(this.model.get('toolMarkup') || this.model.toolMarkup);\n\t        var tool = V(toolTemplate());\n\n\t        $tools.append(tool.node);\n\n\t        // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.\n\t        this._toolCache = tool;\n\n\t        // If `doubleLinkTools` is enabled, we render copy of the tools on the other side of the\n\t        // link as well but only if the link is longer than `longLinkLength`.\n\t        if (this.options.doubleLinkTools) {\n\n\t            var tool2;\n\t            if (this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup) {\n\t                toolTemplate = template(this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup);\n\t                tool2 = V(toolTemplate());\n\t            } else {\n\t                tool2 = tool.clone();\n\t            }\n\n\t            $tools.append(tool2.node);\n\t            this._tool2Cache = tool2;\n\t        }\n\n\t        return this;\n\t    },\n\n\t    renderVertexMarkers: function() {\n\n\t        if (!this._V.markerVertices) { return this; }\n\n\t        var $markerVertices = $(this._V.markerVertices.node).empty();\n\n\t        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n\t        // if default styling (elements) are not desired. This makes it possible to use any\n\t        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n\t        var markupTemplate = template(this.model.get('vertexMarkup') || this.model.vertexMarkup);\n\n\t        this.model.vertices().forEach(function(vertex, idx) {\n\t            $markerVertices.append(V(markupTemplate(assign({ idx: idx }, vertex))).node);\n\t        });\n\n\t        return this;\n\t    },\n\n\t    renderArrowheadMarkers: function() {\n\n\t        // Custom markups might not have arrowhead markers. Therefore, jump of this function immediately if that's the case.\n\t        if (!this._V.markerArrowheads) { return this; }\n\n\t        var $markerArrowheads = $(this._V.markerArrowheads.node);\n\n\t        $markerArrowheads.empty();\n\n\t        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n\t        // if default styling (elements) are not desired. This makes it possible to use any\n\t        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n\t        var markupTemplate = template(this.model.get('arrowheadMarkup') || this.model.arrowheadMarkup);\n\n\t        this._V.sourceArrowhead = V(markupTemplate({ end: 'source' }));\n\t        this._V.targetArrowhead = V(markupTemplate({ end: 'target' }));\n\n\t        $markerArrowheads.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node);\n\n\t        return this;\n\t    },\n\n\t    // remove vertices that lie on (or nearly on) straight lines within the link\n\t    // return the number of removed points\n\t    removeRedundantLinearVertices: function(opt) {\n\n\t        var SIMPLIFY_THRESHOLD = 0.001;\n\n\t        var link = this.model;\n\t        var vertices = link.vertices();\n\t        var routePoints = [this.sourceAnchor ].concat( vertices, [this.targetAnchor]);\n\t        var numRoutePoints = routePoints.length;\n\n\t        // put routePoints into a polyline and try to simplify\n\t        var polyline = new Polyline(routePoints);\n\t        polyline.simplify({ threshold: SIMPLIFY_THRESHOLD });\n\t        var polylinePoints = polyline.points.map(function (point) { return (point.toJSON()); }); // JSON of points after simplification\n\t        var numPolylinePoints = polylinePoints.length; // number of points after simplification\n\n\t        // shortcut if simplification did not remove any redundant vertices:\n\t        if (numRoutePoints === numPolylinePoints) { return 0; }\n\n\t        // else: set simplified polyline points as link vertices\n\t        // remove first and last polyline points again (= source/target anchors)\n\t        link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n\t        return (numRoutePoints - numPolylinePoints);\n\t    },\n\n\t    updateDefaultConnectionPath: function() {\n\n\t        var cache = this._V;\n\n\t        if (cache.connection) {\n\t            cache.connection.attr('d', this.getSerializedConnection());\n\t        }\n\n\t        if (cache.connectionWrap) {\n\t            cache.connectionWrap.attr('d', this.getSerializedConnection());\n\t        }\n\n\t        if (cache.markerSource && cache.markerTarget) {\n\t            this._translateAndAutoOrientArrows(cache.markerSource, cache.markerTarget);\n\t        }\n\t    },\n\n\t    getEndView: function(type) {\n\t        switch (type) {\n\t            case 'source':\n\t                return this.sourceView || null;\n\t            case 'target':\n\t                return this.targetView || null;\n\t            default:\n\t                throw new Error('dia.LinkView: type parameter required.');\n\t        }\n\t    },\n\n\t    getEndAnchor: function(type) {\n\t        switch (type) {\n\t            case 'source':\n\t                return new Point(this.sourceAnchor);\n\t            case 'target':\n\t                return new Point(this.targetAnchor);\n\t            default:\n\t                throw new Error('dia.LinkView: type parameter required.');\n\t        }\n\t    },\n\n\t    getEndConnectionPoint: function(type) {\n\t        switch (type) {\n\t            case 'source':\n\t                return new Point(this.sourcePoint);\n\t            case 'target':\n\t                return new Point(this.targetPoint);\n\t            default:\n\t                throw new Error('dia.LinkView: type parameter required.');\n\t        }\n\t    },\n\n\t    getEndMagnet: function(type) {\n\t        switch (type) {\n\t            case 'source':\n\t                var sourceView = this.sourceView;\n\t                if (!sourceView) { break; }\n\t                return this.sourceMagnet || sourceView.el;\n\t            case 'target':\n\t                var targetView = this.targetView;\n\t                if (!targetView) { break; }\n\t                return this.targetMagnet || targetView.el;\n\t            default:\n\t                throw new Error('dia.LinkView: type parameter required.');\n\t        }\n\t        return null;\n\t    },\n\n\n\t    // Updating.\n\t    // ---------\n\n\t    update: function() {\n\t        this.updateRoute();\n\t        this.updatePath();\n\t        this.updateDOM();\n\t        return this;\n\t    },\n\n\t    translate: function(tx, ty) {\n\t        if ( tx === void 0 ) tx = 0;\n\t        if ( ty === void 0 ) ty = 0;\n\n\t        var ref = this;\n\t        var route = ref.route;\n\t        var path = ref.path;\n\t        if (!route || !path) { return; }\n\t        // translate the route\n\t        var polyline = new Polyline(route);\n\t        polyline.translate(tx, ty);\n\t        this.route = polyline.points;\n\t        // translate source and target connection and marker points.\n\t        this._translateConnectionPoints(tx, ty);\n\t        // translate the geometry path\n\t        path.translate(tx, ty);\n\t        this.updateDOM();\n\t    },\n\n\t    updateDOM: function updateDOM() {\n\t        var ref = this;\n\t        var el = ref.el;\n\t        var model = ref.model;\n\t        var selectors = ref.selectors;\n\t        this.cleanNodesCache();\n\t        // update SVG attributes defined by 'attrs/'.\n\t        this.updateDOMSubtreeAttributes(el, model.attr(), { selectors: selectors });\n\t        // legacy link path update\n\t        this.updateDefaultConnectionPath();\n\t        // update the label position etc.\n\t        this.updateLabelPositions();\n\t        this.updateToolsPosition();\n\t        this.updateArrowheadMarkers();\n\t        // *Deprecated*\n\t        // Local perpendicular flag (as opposed to one defined on paper).\n\t        // Could be enabled inside a connector/router. It's valid only\n\t        // during the update execution.\n\t        this.options.perpendicular = null;\n\t    },\n\n\t    updateRoute: function() {\n\t        var ref = this;\n\t        var model = ref.model;\n\t        var vertices = model.vertices();\n\t        // 1. Find Anchors\n\t        var anchors = this.findAnchors(vertices);\n\t        var sourceAnchor = this.sourceAnchor = anchors.source;\n\t        var targetAnchor = this.targetAnchor = anchors.target;\n\t        // 2. Find Route\n\t        var route = this.findRoute(vertices);\n\t        this.route = route;\n\t        // 3. Find Connection Points\n\t        var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n\t        this.sourcePoint = connectionPoints.source;\n\t        this.targetPoint = connectionPoints.target;\n\t    },\n\n\t    updatePath: function() {\n\t        var ref = this;\n\t        var route = ref.route;\n\t        var sourcePoint = ref.sourcePoint;\n\t        var targetPoint = ref.targetPoint;\n\t        // 3b. Find Marker Connection Point - Backwards Compatibility\n\t        var markerPoints = this.findMarkerPoints(route, sourcePoint, targetPoint);\n\t        // 4. Find Connection\n\t        var path = this.findPath(route, markerPoints.source || sourcePoint, markerPoints.target || targetPoint);\n\t        this.path = path;\n\t    },\n\n\t    findMarkerPoints: function(route, sourcePoint, targetPoint) {\n\n\t        var firstWaypoint = route[0];\n\t        var lastWaypoint = route[route.length - 1];\n\n\t        // Move the source point by the width of the marker taking into account\n\t        // its scale around x-axis. Note that scale is the only transform that\n\t        // makes sense to be set in `.marker-source` attributes object\n\t        // as all other transforms (translate/rotate) will be replaced\n\t        // by the `translateAndAutoOrient()` function.\n\t        var cache = this._markerCache;\n\t        // cache source and target points\n\t        var sourceMarkerPoint, targetMarkerPoint;\n\n\t        if (this._V.markerSource) {\n\n\t            cache.sourceBBox = cache.sourceBBox || this._V.markerSource.getBBox();\n\t            sourceMarkerPoint = Point(sourcePoint).move(\n\t                firstWaypoint || targetPoint,\n\t                cache.sourceBBox.width * this._V.markerSource.scale().sx * -1\n\t            ).round();\n\t        }\n\n\t        if (this._V.markerTarget) {\n\n\t            cache.targetBBox = cache.targetBBox || this._V.markerTarget.getBBox();\n\t            targetMarkerPoint = Point(targetPoint).move(\n\t                lastWaypoint || sourcePoint,\n\t                cache.targetBBox.width * this._V.markerTarget.scale().sx * -1\n\t            ).round();\n\t        }\n\n\t        // if there was no markup for the marker, use the connection point.\n\t        cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n\t        cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n\n\t        return {\n\t            source: sourceMarkerPoint,\n\t            target: targetMarkerPoint\n\t        };\n\t    },\n\n\t    findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {\n\n\t        var firstAnchor, secondAnchor;\n\t        var firstAnchorRef, secondAnchorRef;\n\t        var model = this.model;\n\t        var firstDef = model.get(firstEndType);\n\t        var secondDef = model.get(secondEndType);\n\t        var firstView = this.getEndView(firstEndType);\n\t        var secondView = this.getEndView(secondEndType);\n\t        var firstMagnet = this.getEndMagnet(firstEndType);\n\t        var secondMagnet = this.getEndMagnet(secondEndType);\n\n\t        // Anchor first\n\t        if (firstView) {\n\t            if (firstRef) {\n\t                firstAnchorRef = new Point(firstRef);\n\t            } else if (secondView) {\n\t                firstAnchorRef = secondMagnet;\n\t            } else {\n\t                firstAnchorRef = new Point(secondDef);\n\t            }\n\t            firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n\t        } else {\n\t            firstAnchor = new Point(firstDef);\n\t        }\n\n\t        // Anchor second\n\t        if (secondView) {\n\t            secondAnchorRef = new Point(secondRef || firstAnchor);\n\t            secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n\t        } else {\n\t            secondAnchor = new Point(secondDef);\n\t        }\n\n\t        var res = {};\n\t        res[firstEndType] = firstAnchor;\n\t        res[secondEndType] = secondAnchor;\n\t        return res;\n\t    },\n\n\t    findAnchors: function(vertices) {\n\n\t        var model = this.model;\n\t        var firstVertex = vertices[0];\n\t        var lastVertex = vertices[vertices.length - 1];\n\n\t        if (model.target().priority && !model.source().priority) {\n\t            // Reversed order\n\t            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n\t        }\n\n\t        // Usual order\n\t        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n\t    },\n\n\t    findConnectionPoints: function(route, sourceAnchor, targetAnchor) {\n\n\t        var firstWaypoint = route[0];\n\t        var lastWaypoint = route[route.length - 1];\n\t        var model = this.model;\n\t        var sourceDef = model.get('source');\n\t        var targetDef = model.get('target');\n\t        var sourceView = this.sourceView;\n\t        var targetView = this.targetView;\n\t        var paperOptions = this.paper.options;\n\t        var sourceMagnet, targetMagnet;\n\n\t        // Connection Point Source\n\t        var sourcePoint;\n\t        if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n\t            sourceMagnet = (this.sourceMagnet || sourceView.el);\n\t            var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n\t            var sourcePointRef = firstWaypoint || targetAnchor;\n\t            var sourceLine = new Line(sourcePointRef, sourceAnchor);\n\t            sourcePoint = this.getConnectionPoint(\n\t                sourceConnectionPointDef,\n\t                sourceView,\n\t                sourceMagnet,\n\t                sourceLine,\n\t                'source'\n\t            );\n\t        } else {\n\t            sourcePoint = sourceAnchor;\n\t        }\n\t        // Connection Point Target\n\t        var targetPoint;\n\t        if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n\t            targetMagnet = (this.targetMagnet || targetView.el);\n\t            var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n\t            var targetPointRef = lastWaypoint || sourceAnchor;\n\t            var targetLine = new Line(targetPointRef, targetAnchor);\n\t            targetPoint = this.getConnectionPoint(\n\t                targetConnectionPointDef,\n\t                targetView,\n\t                targetMagnet,\n\t                targetLine,\n\t                'target'\n\t            );\n\t        } else {\n\t            targetPoint = targetAnchor;\n\t        }\n\n\t        return {\n\t            source: sourcePoint,\n\t            target: targetPoint\n\t        };\n\t    },\n\n\t    getAnchor: function(anchorDef, cellView, magnet, ref, endType) {\n\n\t        var isConnection = cellView.isNodeConnection(magnet);\n\t        var paperOptions = this.paper.options;\n\t        if (!anchorDef) {\n\t            if (isConnection) {\n\t                anchorDef = paperOptions.defaultLinkAnchor;\n\t            } else {\n\t                if (paperOptions.perpendicularLinks || this.options.perpendicular) {\n\t                    // Backwards compatibility\n\t                    // If `perpendicularLinks` flag is set on the paper and there are vertices\n\t                    // on the link, then try to find a connection point that makes the link perpendicular\n\t                    // even though the link won't point to the center of the targeted object.\n\t                    anchorDef = { name: 'perpendicular' };\n\t                } else {\n\t                    anchorDef = paperOptions.defaultAnchor;\n\t                }\n\t            }\n\t        }\n\n\t        if (!anchorDef) { throw new Error('Anchor required.'); }\n\t        var anchorFn;\n\t        if (typeof anchorDef === 'function') {\n\t            anchorFn = anchorDef;\n\t        } else {\n\t            var anchorName = anchorDef.name;\n\t            var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n\t            anchorFn = paperOptions[anchorNamespace][anchorName];\n\t            if (typeof anchorFn !== 'function') { throw new Error('Unknown anchor: ' + anchorName); }\n\t        }\n\t        var anchor = anchorFn.call(\n\t            this,\n\t            cellView,\n\t            magnet,\n\t            ref,\n\t            anchorDef.args || {},\n\t            endType,\n\t            this\n\t        );\n\t        if (!anchor) { return new Point(); }\n\t        return anchor.round(this.decimalsRounding);\n\t    },\n\n\n\t    getConnectionPoint: function(connectionPointDef, view, magnet, line, endType) {\n\n\t        var connectionPoint;\n\t        var anchor = line.end;\n\t        var paperOptions = this.paper.options;\n\n\t        // Backwards compatibility\n\t        if (typeof paperOptions.linkConnectionPoint === 'function') {\n\t            var linkConnectionMagnet = (magnet === view.el) ? undefined : magnet;\n\t            connectionPoint = paperOptions.linkConnectionPoint(this, view, linkConnectionMagnet, line.start, endType);\n\t            if (connectionPoint) { return connectionPoint; }\n\t        }\n\n\t        if (!connectionPointDef) { return anchor; }\n\t        var connectionPointFn;\n\t        if (typeof connectionPointDef === 'function') {\n\t            connectionPointFn = connectionPointDef;\n\t        } else {\n\t            var connectionPointName = connectionPointDef.name;\n\t            connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n\t            if (typeof connectionPointFn !== 'function') { throw new Error('Unknown connection point: ' + connectionPointName); }\n\t        }\n\t        connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n\t        if (!connectionPoint) { return anchor; }\n\t        return connectionPoint.round(this.decimalsRounding);\n\t    },\n\n\t    _translateConnectionPoints: function(tx, ty) {\n\n\t        var cache = this._markerCache;\n\n\t        cache.sourcePoint.offset(tx, ty);\n\t        cache.targetPoint.offset(tx, ty);\n\t        this.sourcePoint.offset(tx, ty);\n\t        this.targetPoint.offset(tx, ty);\n\t        this.sourceAnchor.offset(tx, ty);\n\t        this.targetAnchor.offset(tx, ty);\n\t    },\n\n\t    // combine default label position with built-in default label position\n\t    _getDefaultLabelPositionProperty: function() {\n\n\t        var model = this.model;\n\n\t        var builtinDefaultLabel = model._builtins.defaultLabel;\n\t        var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n\n\t        var defaultLabel = model._getDefaultLabel();\n\t        var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n\n\t        return merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n\t    },\n\n\t    // if label position is a number, normalize it to a position object\n\t    // this makes sure that label positions can be merged properly\n\t    _normalizeLabelPosition: function(labelPosition) {\n\n\t        if (typeof labelPosition === 'number') { return { distance: labelPosition, offset: null, angle: 0, args: null }; }\n\t        return labelPosition;\n\t    },\n\n\t    // expects normalized position properties\n\t    // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`\n\t    _mergeLabelPositionProperty: function(normalizedLabelPosition, normalizedDefaultLabelPosition) {\n\n\t        if (normalizedLabelPosition === null) { return null; }\n\t        if (normalizedLabelPosition === undefined) {\n\n\t            if (normalizedDefaultLabelPosition === null) { return null; }\n\t            return normalizedDefaultLabelPosition;\n\t        }\n\n\t        return merge({}, normalizedDefaultLabelPosition, normalizedLabelPosition);\n\t    },\n\n\t    updateLabelPositions: function() {\n\n\t        if (!this._V.labels) { return this; }\n\n\t        var path = this.path;\n\t        if (!path) { return this; }\n\n\t        // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n\t        // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n\t        var model = this.model;\n\t        var labels = model.get('labels') || [];\n\t        if (!labels.length) { return this; }\n\n\t        var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n\n\t        for (var idx = 0, n = labels.length; idx < n; idx++) {\n\t            var labelNode = this._labelCache[idx];\n\t            if (!labelNode) { continue; }\n\t            var label = labels[idx];\n\t            var labelPosition = this._normalizeLabelPosition(label.position);\n\t            var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);\n\t            var transformationMatrix = this._getLabelTransformationMatrix(position);\n\t            labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));\n\t            this._cleanLabelMatrices(idx);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    _cleanLabelMatrices: function(index) {\n\t        // Clean magnetMatrix for all nodes of the label.\n\t        // Cached BoundingRect does not need to updated when the position changes\n\t        // TODO: this doesn't work for labels with XML String markups.\n\t        var ref = this;\n\t        var metrics = ref.metrics;\n\t        var _labelSelectors = ref._labelSelectors;\n\t        var selectors = _labelSelectors[index];\n\t        if (!selectors) { return; }\n\t        for (var selector in selectors) {\n\t            var ref$1 = selectors[selector];\n\t            var id = ref$1.id;\n\t            if (id && (id in metrics)) { delete metrics[id].magnetMatrix; }\n\t        }\n\t    },\n\n\t    updateToolsPosition: function() {\n\n\t        if (!this._V.linkTools) { return this; }\n\n\t        // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.\n\t        // Note that the offset is hardcoded here. The offset should be always\n\t        // more than the `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n\t        // this up all the time would be slow.\n\n\t        var scale = '';\n\t        var offset = this.options.linkToolsOffset;\n\t        var connectionLength = this.getConnectionLength();\n\n\t        // Firefox returns connectionLength=NaN in odd cases (for bezier curves).\n\t        // In that case we won't update tools position at all.\n\t        if (!Number.isNaN(connectionLength)) {\n\n\t            // If the link is too short, make the tools half the size and the offset twice as low.\n\t            if (connectionLength < this.options.shortLinkLength) {\n\t                scale = 'scale(.5)';\n\t                offset /= 2;\n\t            }\n\n\t            var toolPosition = this.getPointAtLength(offset);\n\n\t            this._toolCache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n\n\t            if (this.options.doubleLinkTools && connectionLength >= this.options.longLinkLength) {\n\n\t                var doubleLinkToolsOffset = this.options.doubleLinkToolsOffset || offset;\n\n\t                toolPosition = this.getPointAtLength(connectionLength - doubleLinkToolsOffset);\n\t                this._tool2Cache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n\t                this._tool2Cache.attr('visibility', 'visible');\n\n\t            } else if (this.options.doubleLinkTools) {\n\n\t                this._tool2Cache.attr('visibility', 'hidden');\n\t            }\n\t        }\n\n\t        return this;\n\t    },\n\n\t    updateArrowheadMarkers: function() {\n\n\t        if (!this._V.markerArrowheads) { return this; }\n\n\t        // getting bbox of an element with `display=\"none\"` in IE9 ends up with access violation\n\t        if ($.css(this._V.markerArrowheads.node, 'display') === 'none') { return this; }\n\n\t        var sx = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;\n\t        this._V.sourceArrowhead.scale(sx);\n\t        this._V.targetArrowhead.scale(sx);\n\n\t        this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead);\n\n\t        return this;\n\t    },\n\n\t    updateEndProperties: function(endType) {\n\n\t        var ref = this;\n\t        var model = ref.model;\n\t        var paper = ref.paper;\n\t        var endViewProperty = endType + \"View\";\n\t        var endDef = model.get(endType);\n\t        var endId = endDef && endDef.id;\n\n\t        if (!endId) {\n\t            // the link end is a point ~ rect 0x0\n\t            this[endViewProperty] = null;\n\t            this.updateEndMagnet(endType);\n\t            return true;\n\t        }\n\n\t        var endModel = paper.getModelById(endId);\n\t        if (!endModel) { throw new Error('LinkView: invalid ' + endType + ' cell.'); }\n\n\t        var endView = endModel.findView(paper);\n\t        if (!endView) {\n\t            // A view for a model should always exist\n\t            return false;\n\t        }\n\n\t        this[endViewProperty] = endView;\n\t        this.updateEndMagnet(endType);\n\t        return true;\n\t    },\n\n\t    updateEndMagnet: function(endType) {\n\n\t        var endMagnetProperty = endType + \"Magnet\";\n\t        var endView = this.getEndView(endType);\n\t        if (endView) {\n\t            var connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n\t            if (connectedMagnet === endView.el) { connectedMagnet = null; }\n\t            this[endMagnetProperty] = connectedMagnet;\n\t        } else {\n\t            this[endMagnetProperty] = null;\n\t        }\n\t    },\n\n\t    _translateAndAutoOrientArrows: function(sourceArrow, targetArrow) {\n\n\t        // Make the markers \"point\" to their sticky points being auto-oriented towards\n\t        // `targetPosition`/`sourcePosition`. And do so only if there is a markup for them.\n\t        var route = toArray(this.route);\n\t        if (sourceArrow) {\n\t            sourceArrow.translateAndAutoOrient(\n\t                this.sourcePoint,\n\t                route[0] || this.targetPoint,\n\t                this.paper.cells\n\t            );\n\t        }\n\n\t        if (targetArrow) {\n\t            targetArrow.translateAndAutoOrient(\n\t                this.targetPoint,\n\t                route[route.length - 1] || this.sourcePoint,\n\t                this.paper.cells\n\t            );\n\t        }\n\t    },\n\n\t    _getLabelPositionProperty: function(idx) {\n\n\t        return (this.model.label(idx).position || {});\n\t    },\n\n\t    _getLabelPositionAngle: function(idx) {\n\n\t        var labelPosition = this._getLabelPositionProperty(idx);\n\t        return (labelPosition.angle || 0);\n\t    },\n\n\t    _getLabelPositionArgs: function(idx) {\n\n\t        var labelPosition = this._getLabelPositionProperty(idx);\n\t        return labelPosition.args;\n\t    },\n\n\t    _getDefaultLabelPositionArgs: function() {\n\n\t        var defaultLabel = this.model._getDefaultLabel();\n\t        var defaultLabelPosition = defaultLabel.position || {};\n\t        return defaultLabelPosition.args;\n\t    },\n\n\t    // merge default label position args into label position args\n\t    // keep `undefined` or `null` because `{}` means something else\n\t    _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {\n\n\t        if (labelPositionArgs === null) { return null; }\n\t        if (labelPositionArgs === undefined) {\n\n\t            if (defaultLabelPositionArgs === null) { return null; }\n\t            return defaultLabelPositionArgs;\n\t        }\n\n\t        return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n\t    },\n\n\t    // Add default label at given position at end of `labels` array.\n\t    // Four signatures:\n\t    // - obj, obj = point, opt\n\t    // - obj, num, obj = point, angle, opt\n\t    // - num, num, obj = x, y, opt\n\t    // - num, num, num, obj = x, y, angle, opt\n\t    // Assigns relative coordinates by default:\n\t    // `opt.absoluteDistance` forces absolute coordinates.\n\t    // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n\t    // `opt.absoluteOffset` forces absolute coordinates for offset.\n\t    // Additional args:\n\t    // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n\t    // `opt.ensureLegibility` rotates labels so they are never upside-down.\n\t    addLabel: function(p1, p2, p3, p4) {\n\n\t        // normalize data from the four possible signatures\n\t        var localX;\n\t        var localY;\n\t        var localAngle = 0;\n\t        var localOpt;\n\t        if (typeof p1 !== 'number') {\n\t            // {x, y} object provided as first parameter\n\t            localX = p1.x;\n\t            localY = p1.y;\n\t            if (typeof p2 === 'number') {\n\t                // angle and opt provided as second and third parameters\n\t                localAngle = p2;\n\t                localOpt = p3;\n\t            } else {\n\t                // opt provided as second parameter\n\t                localOpt = p2;\n\t            }\n\t        } else {\n\t            // x and y provided as first and second parameters\n\t            localX = p1;\n\t            localY = p2;\n\t            if (typeof p3 === 'number') {\n\t                // angle and opt provided as third and fourth parameters\n\t                localAngle = p3;\n\t                localOpt = p4;\n\t            } else {\n\t                // opt provided as third parameter\n\t                localOpt = p3;\n\t            }\n\t        }\n\n\t        // merge label position arguments\n\t        var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n\t        var labelPositionArgs = localOpt;\n\t        var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n\t        // append label to labels array\n\t        var label = { position: this.getLabelPosition(localX, localY, localAngle, positionArgs) };\n\t        var idx = -1;\n\t        this.model.insertLabel(idx, label, localOpt);\n\t        return idx;\n\t    },\n\n\t    // Add a new vertex at calculated index to the `vertices` array.\n\t    addVertex: function(x, y, opt) {\n\n\t        // accept input in form `{ x, y }, opt` or `x, y, opt`\n\t        var isPointProvided = (typeof x !== 'number');\n\t        var localX = isPointProvided ? x.x : x;\n\t        var localY = isPointProvided ? x.y : y;\n\t        var localOpt = isPointProvided ? y : opt;\n\n\t        var vertex = { x: localX, y: localY };\n\t        var idx = this.getVertexIndex(localX, localY);\n\t        this.model.insertVertex(idx, vertex, localOpt);\n\t        return idx;\n\t    },\n\n\t    // Send a token (an SVG element, usually a circle) along the connection path.\n\t    // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n\t    // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n\t    // `opt.directon` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n\t    // `opt.connection` is an optional selector to the connection path.\n\t    // `callback` is optional and is a function to be called once the token reaches the target.\n\t    sendToken: function(token, opt, callback) {\n\n\t        function onAnimationEnd(vToken, callback) {\n\t            return function() {\n\t                vToken.remove();\n\t                if (typeof callback === 'function') {\n\t                    callback();\n\t                }\n\t            };\n\t        }\n\n\t        var duration, isReversed, selector;\n\t        if (isObject$1(opt)) {\n\t            duration = opt.duration;\n\t            isReversed = (opt.direction === 'reverse');\n\t            selector = opt.connection;\n\t        } else {\n\t            // Backwards compatibility\n\t            duration = opt;\n\t            isReversed = false;\n\t            selector = null;\n\t        }\n\n\t        duration = duration || 1000;\n\n\t        var animationAttributes = {\n\t            dur: duration + 'ms',\n\t            repeatCount: 1,\n\t            calcMode: 'linear',\n\t            fill: 'freeze'\n\t        };\n\n\t        if (isReversed) {\n\t            animationAttributes.keyPoints = '1;0';\n\t            animationAttributes.keyTimes = '0;1';\n\t        }\n\n\t        var vToken = V(token);\n\t        var connection;\n\t        if (typeof selector === 'string') {\n\t            // Use custom connection path.\n\t            connection = this.findBySelector(selector, this.el, this.selectors)[0];\n\t        } else {\n\t            // Select connection path automatically.\n\t            var cache = this._V;\n\t            connection = (cache.connection) ? cache.connection.node : this.el.querySelector('path');\n\t        }\n\n\t        if (!(connection instanceof SVGPathElement)) {\n\t            throw new Error('dia.LinkView: token animation requires a valid connection path.');\n\t        }\n\n\t        vToken\n\t            .appendTo(this.paper.cells)\n\t            .animateAlongPath(animationAttributes, connection);\n\n\t        setTimeout(onAnimationEnd(vToken, callback), duration);\n\t    },\n\n\t    findRoute: function(vertices) {\n\n\t        vertices || (vertices = []);\n\n\t        var namespace = this.paper.options.routerNamespace || routers;\n\t        var router = this.model.router();\n\t        var defaultRouter = this.paper.options.defaultRouter;\n\n\t        if (!router) {\n\t            if (defaultRouter) { router = defaultRouter; }\n\t            else { return vertices.map(Point); } // no router specified\n\t        }\n\n\t        var routerFn = isFunction(router) ? router : namespace[router.name];\n\t        if (!isFunction(routerFn)) {\n\t            throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n\t        }\n\n\t        var args = router.args || {};\n\n\t        var route = routerFn.call(\n\t            this, // context\n\t            vertices, // vertices\n\t            args, // options\n\t            this // linkView\n\t        );\n\n\t        if (!route) { return vertices.map(Point); }\n\t        return route;\n\t    },\n\n\t    // Return the `d` attribute value of the `<path>` element representing the link\n\t    // between `source` and `target`.\n\t    findPath: function(route, sourcePoint, targetPoint) {\n\n\t        var namespace = this.paper.options.connectorNamespace || connectors;\n\t        var connector = this.model.connector();\n\t        var defaultConnector = this.paper.options.defaultConnector;\n\n\t        if (!connector) {\n\t            connector = defaultConnector || {};\n\t        }\n\n\t        var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n\t        if (!isFunction(connectorFn)) {\n\t            throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n\t        }\n\n\t        var args = clone(connector.args || {});\n\t        args.raw = true; // Request raw g.Path as the result.\n\n\t        var path = connectorFn.call(\n\t            this, // context\n\t            sourcePoint, // start point\n\t            targetPoint, // end point\n\t            route, // vertices\n\t            args, // options\n\t            this // linkView\n\t        );\n\n\t        if (typeof path === 'string') {\n\t            // Backwards compatibility for connectors not supporting `raw` option.\n\t            path = new Path(V.normalizePathData(path));\n\t        }\n\n\t        return path;\n\t    },\n\n\t    // Public API.\n\t    // -----------\n\n\t    getConnection: function() {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.clone();\n\t    },\n\n\t    getSerializedConnection: function() {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        var metrics = this.metrics;\n\t        if (metrics.hasOwnProperty('data')) { return metrics.data; }\n\t        var data = path.serialize();\n\t        metrics.data = data;\n\t        return data;\n\t    },\n\n\t    getConnectionSubdivisions: function() {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        var metrics = this.metrics;\n\t        if (metrics.hasOwnProperty('segmentSubdivisions')) { return metrics.segmentSubdivisions; }\n\t        var subdivisions = path.getSegmentSubdivisions();\n\t        metrics.segmentSubdivisions = subdivisions;\n\t        return subdivisions;\n\t    },\n\n\t    getConnectionLength: function() {\n\n\t        var path = this.path;\n\t        if (!path) { return 0; }\n\n\t        var metrics = this.metrics;\n\t        if (metrics.hasOwnProperty('length')) { return metrics.length; }\n\t        var length = path.length({ segmentSubdivisions: this.getConnectionSubdivisions() });\n\t        metrics.length = length;\n\t        return length;\n\t    },\n\n\t    getPointAtLength: function(length) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.pointAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    getPointAtRatio: function(ratio) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\t        if (isPercentage(ratio)) { ratio = parseFloat(ratio) / 100; }\n\t        return path.pointAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    getTangentAtLength: function(length) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.tangentAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    getTangentAtRatio: function(ratio) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.tangentAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    getClosestPoint: function(point) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.closestPoint(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    getClosestPointLength: function(point) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.closestPointLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    getClosestPointRatio: function(point) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.closestPointNormalizedLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    // Get label position object based on two provided coordinates, x and y.\n\t    // (Used behind the scenes when user moves labels around.)\n\t    // Two signatures:\n\t    // - num, num, obj = x, y, options\n\t    // - num, num, num, obj = x, y, angle, options\n\t    // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n\t    // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n\t    // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n\t    getLabelPosition: function(x, y, p3, p4) {\n\n\t        var position = {};\n\n\t        // normalize data from the two possible signatures\n\t        var localAngle = 0;\n\t        var localOpt;\n\t        if (typeof p3 === 'number') {\n\t            // angle and opt provided as third and fourth argument\n\t            localAngle = p3;\n\t            localOpt = p4;\n\t        } else {\n\t            // opt provided as third argument\n\t            localOpt = p3;\n\t        }\n\n\t        // save localOpt as `args` of the position object that is passed along\n\t        if (localOpt) { position.args = localOpt; }\n\n\t        // identify distance/offset settings\n\t        var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n\t        var isDistanceAbsoluteReverse = (localOpt && localOpt.absoluteDistance && localOpt.reverseDistance); // non-reverse by default\n\t        var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n\n\t        // find closest point t\n\t        var path = this.path;\n\t        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n\t        var labelPoint = new Point(x, y);\n\t        var t = path.closestPointT(labelPoint, pathOpt);\n\n\t        // DISTANCE:\n\t        var labelDistance = path.lengthAtT(t, pathOpt);\n\t        if (isDistanceRelative) { labelDistance = (labelDistance / this.getConnectionLength()) || 0; } // fix to prevent NaN for 0 length\n\t        if (isDistanceAbsoluteReverse) { labelDistance = (-1 * (this.getConnectionLength() - labelDistance)) || 1; } // fix for end point (-0 => 1)\n\t        position.distance = labelDistance;\n\n\t        // OFFSET:\n\t        // use absolute offset if:\n\t        // - opt.absoluteOffset is true,\n\t        // - opt.absoluteOffset is not true but there is no tangent\n\t        var tangent;\n\t        if (!isOffsetAbsolute) { tangent = path.tangentAtT(t); }\n\t        var labelOffset;\n\t        if (tangent) {\n\t            labelOffset = tangent.pointOffset(labelPoint);\n\t        } else {\n\t            var closestPoint = path.pointAtT(t);\n\t            var labelOffsetDiff = labelPoint.difference(closestPoint);\n\t            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };\n\t        }\n\t        position.offset = labelOffset;\n\n\t        // ANGLE:\n\t        position.angle = localAngle;\n\n\t        return position;\n\t    },\n\n\t    _getLabelTransformationMatrix: function(labelPosition) {\n\n\t        var labelDistance;\n\t        var labelAngle = 0;\n\t        var args = {};\n\t        if (typeof labelPosition === 'number') {\n\t            labelDistance = labelPosition;\n\t        } else if (typeof labelPosition.distance === 'number') {\n\t            args = labelPosition.args || {};\n\t            labelDistance = labelPosition.distance;\n\t            labelAngle = labelPosition.angle || 0;\n\t        } else {\n\t            throw new Error('dia.LinkView: invalid label position distance.');\n\t        }\n\n\t        var isDistanceRelative = ((labelDistance > 0) && (labelDistance <= 1));\n\n\t        var labelOffset = 0;\n\t        var labelOffsetCoordinates = { x: 0, y: 0 };\n\t        if (labelPosition.offset) {\n\t            var positionOffset = labelPosition.offset;\n\t            if (typeof positionOffset === 'number') { labelOffset = positionOffset; }\n\t            if (positionOffset.x) { labelOffsetCoordinates.x = positionOffset.x; }\n\t            if (positionOffset.y) { labelOffsetCoordinates.y = positionOffset.y; }\n\t        }\n\n\t        var isOffsetAbsolute = ((labelOffsetCoordinates.x !== 0) || (labelOffsetCoordinates.y !== 0) || labelOffset === 0);\n\n\t        var isKeepGradient = args.keepGradient;\n\t        var isEnsureLegibility = args.ensureLegibility;\n\n\t        var path = this.path;\n\t        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n\n\t        var distance = isDistanceRelative ? (labelDistance * this.getConnectionLength()) : labelDistance;\n\t        var tangent = path.tangentAtLength(distance, pathOpt);\n\n\t        var translation;\n\t        var angle = labelAngle;\n\t        if (tangent) {\n\t            if (isOffsetAbsolute) {\n\t                translation = tangent.start.clone();\n\t                translation.offset(labelOffsetCoordinates);\n\t            } else {\n\t                var normal = tangent.clone();\n\t                normal.rotate(tangent.start, -90);\n\t                normal.setLength(labelOffset);\n\t                translation = normal.end;\n\t            }\n\n\t            if (isKeepGradient) {\n\t                angle = (tangent.angle() + labelAngle);\n\t                if (isEnsureLegibility) {\n\t                    angle = normalizeAngle(((angle + 90) % 180) - 90);\n\t                }\n\t            }\n\n\t        } else {\n\t            // fallback - the connection has zero length\n\t            translation = path.start.clone();\n\t            if (isOffsetAbsolute) { translation.offset(labelOffsetCoordinates); }\n\t        }\n\n\t        return V.createSVGMatrix()\n\t            .translate(translation.x, translation.y)\n\t            .rotate(angle);\n\t    },\n\n\t    getLabelCoordinates: function(labelPosition) {\n\n\t        var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n\t        return new Point(transformationMatrix.e, transformationMatrix.f);\n\t    },\n\n\t    getVertexIndex: function(x, y) {\n\n\t        var model = this.model;\n\t        var vertices = model.vertices();\n\n\t        var vertexLength = this.getClosestPointLength(new Point(x, y));\n\n\t        var idx = 0;\n\t        for (var n = vertices.length; idx < n; idx++) {\n\t            var currentVertex = vertices[idx];\n\t            var currentVertexLength = this.getClosestPointLength(currentVertex);\n\t            if (vertexLength < currentVertexLength) { break; }\n\t        }\n\n\t        return idx;\n\t    },\n\n\t    // Interaction. The controller part.\n\t    // ---------------------------------\n\n\t    notifyPointerdown: function notifyPointerdown(evt, x, y) {\n\t        CellView.prototype.pointerdown.call(this, evt, x, y);\n\t        this.notify('link:pointerdown', evt, x, y);\n\t    },\n\n\t    notifyPointermove: function notifyPointermove(evt, x, y) {\n\t        CellView.prototype.pointermove.call(this, evt, x, y);\n\t        this.notify('link:pointermove', evt, x, y);\n\t    },\n\n\t    notifyPointerup: function notifyPointerup(evt, x, y) {\n\t        this.notify('link:pointerup', evt, x, y);\n\t        CellView.prototype.pointerup.call(this, evt, x, y);\n\t    },\n\n\t    pointerdblclick: function(evt, x, y) {\n\n\t        CellView.prototype.pointerdblclick.apply(this, arguments);\n\t        this.notify('link:pointerdblclick', evt, x, y);\n\t    },\n\n\t    pointerclick: function(evt, x, y) {\n\n\t        CellView.prototype.pointerclick.apply(this, arguments);\n\t        this.notify('link:pointerclick', evt, x, y);\n\t    },\n\n\t    contextmenu: function(evt, x, y) {\n\n\t        CellView.prototype.contextmenu.apply(this, arguments);\n\t        this.notify('link:contextmenu', evt, x, y);\n\t    },\n\n\t    pointerdown: function(evt, x, y) {\n\n\t        this.notifyPointerdown(evt, x, y);\n\n\t        // Backwards compatibility for the default markup\n\t        var className = evt.target.getAttribute('class');\n\t        switch (className) {\n\n\t            case 'marker-vertex':\n\t                this.dragVertexStart(evt, x, y);\n\t                return;\n\n\t            case 'marker-vertex-remove':\n\t            case 'marker-vertex-remove-area':\n\t                this.dragVertexRemoveStart(evt, x, y);\n\t                return;\n\n\t            case 'marker-arrowhead':\n\t                this.dragArrowheadStart(evt, x, y);\n\t                return;\n\n\t            case 'connection':\n\t            case 'connection-wrap':\n\t                this.dragConnectionStart(evt, x, y);\n\t                return;\n\n\t            case 'marker-source':\n\t            case 'marker-target':\n\t                return;\n\t        }\n\n\t        this.dragStart(evt, x, y);\n\t    },\n\n\t    pointermove: function(evt, x, y) {\n\n\t        // Backwards compatibility\n\t        var dragData = this._dragData;\n\t        if (dragData) { this.eventData(evt, dragData); }\n\n\t        var data = this.eventData(evt);\n\t        switch (data.action) {\n\n\t            case 'vertex-move':\n\t                this.dragVertex(evt, x, y);\n\t                break;\n\n\t            case 'label-move':\n\t                this.dragLabel(evt, x, y);\n\t                break;\n\n\t            case 'arrowhead-move':\n\t                this.dragArrowhead(evt, x, y);\n\t                break;\n\n\t            case 'move':\n\t                this.drag(evt, x, y);\n\t                break;\n\t        }\n\n\t        // Backwards compatibility\n\t        if (dragData) { assign(dragData, this.eventData(evt)); }\n\n\t        this.notifyPointermove(evt, x, y);\n\t    },\n\n\t    pointerup: function(evt, x, y) {\n\n\t        // Backwards compatibility\n\t        var dragData = this._dragData;\n\t        if (dragData) {\n\t            this.eventData(evt, dragData);\n\t            this._dragData = null;\n\t        }\n\n\t        var data = this.eventData(evt);\n\t        switch (data.action) {\n\n\t            case 'vertex-move':\n\t                this.dragVertexEnd(evt, x, y);\n\t                break;\n\n\t            case 'label-move':\n\t                this.dragLabelEnd(evt, x, y);\n\t                break;\n\n\t            case 'arrowhead-move':\n\t                this.dragArrowheadEnd(evt, x, y);\n\t                break;\n\n\t            case 'move':\n\t                this.dragEnd(evt, x, y);\n\t        }\n\n\t        this.notifyPointerup(evt, x, y);\n\t        this.checkMouseleave(evt);\n\t    },\n\n\t    mouseover: function(evt) {\n\n\t        CellView.prototype.mouseover.apply(this, arguments);\n\t        this.notify('link:mouseover', evt);\n\t    },\n\n\t    mouseout: function(evt) {\n\n\t        CellView.prototype.mouseout.apply(this, arguments);\n\t        this.notify('link:mouseout', evt);\n\t    },\n\n\t    mouseenter: function(evt) {\n\n\t        CellView.prototype.mouseenter.apply(this, arguments);\n\t        this.notify('link:mouseenter', evt);\n\t    },\n\n\t    mouseleave: function(evt) {\n\n\t        CellView.prototype.mouseleave.apply(this, arguments);\n\t        this.notify('link:mouseleave', evt);\n\t    },\n\n\t    mousewheel: function(evt, x, y, delta) {\n\n\t        CellView.prototype.mousewheel.apply(this, arguments);\n\t        this.notify('link:mousewheel', evt, x, y, delta);\n\t    },\n\n\t    onevent: function(evt, eventName, x, y) {\n\n\t        // Backwards compatibility\n\t        var linkTool = V(evt.target).findParentByClass('link-tool', this.el);\n\t        if (linkTool) {\n\t            // No further action to be executed\n\t            evt.stopPropagation();\n\n\t            // Allow `interactive.useLinkTools=false`\n\t            if (this.can('useLinkTools')) {\n\t                if (eventName === 'remove') {\n\t                    // Built-in remove event\n\t                    this.model.remove({ ui: true });\n\t                    // Do not trigger link pointerdown\n\t                    return;\n\n\t                } else {\n\t                    // link:options and other custom events inside the link tools\n\t                    this.notify(eventName, evt, x, y);\n\t                }\n\t            }\n\n\t            this.notifyPointerdown(evt, x, y);\n\t            this.paper.delegateDragEvents(this, evt.data);\n\n\t        } else {\n\t            CellView.prototype.onevent.apply(this, arguments);\n\t        }\n\t    },\n\n\t    onlabel: function(evt, x, y) {\n\n\t        this.notifyPointerdown(evt, x, y);\n\n\t        this.dragLabelStart(evt, x, y);\n\n\t        var stopPropagation = this.eventData(evt).stopPropagation;\n\t        if (stopPropagation) { evt.stopPropagation(); }\n\t    },\n\n\t    // Drag Start Handlers\n\n\t    dragConnectionStart: function(evt, x, y) {\n\n\t        if (!this.can('vertexAdd')) { return; }\n\n\t        // Store the index at which the new vertex has just been placed.\n\t        // We'll be update the very same vertex position in `pointermove()`.\n\t        var vertexIdx = this.addVertex({ x: x, y: y }, { ui: true });\n\t        this.eventData(evt, {\n\t            action: 'vertex-move',\n\t            vertexIdx: vertexIdx\n\t        });\n\t    },\n\n\t    dragLabelStart: function(evt, x, y) {\n\n\t        if (this.can('labelMove')) {\n\n\t            if (this.isDefaultInteractionPrevented(evt)) { return; }\n\n\t            var labelNode = evt.currentTarget;\n\t            var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n\n\t            var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n\t            var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));\n\t            var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);\n\n\t            var coords = this.getLabelCoordinates(position);\n\t            var dx = coords.x - x; // how much needs to be added to cursor x to get to label x\n\t            var dy = coords.y - y; // how much needs to be added to cursor y to get to label y\n\n\t            var positionAngle = this._getLabelPositionAngle(labelIdx);\n\t            var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n\t            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n\t            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n\t            this.eventData(evt, {\n\t                action: 'label-move',\n\t                labelIdx: labelIdx,\n\t                dx: dx,\n\t                dy: dy,\n\t                positionAngle: positionAngle,\n\t                positionArgs: positionArgs,\n\t                stopPropagation: true\n\t            });\n\n\t        } else {\n\n\t            // Backwards compatibility:\n\t            // If labels can't be dragged no default action is triggered.\n\t            this.eventData(evt, { stopPropagation: true });\n\t        }\n\n\t        this.paper.delegateDragEvents(this, evt.data);\n\t    },\n\n\t    dragVertexStart: function(evt, x, y) {\n\n\t        if (!this.can('vertexMove')) { return; }\n\n\t        var vertexNode = evt.target;\n\t        var vertexIdx = parseInt(vertexNode.getAttribute('idx'), 10);\n\t        this.eventData(evt, {\n\t            action: 'vertex-move',\n\t            vertexIdx: vertexIdx\n\t        });\n\t    },\n\n\t    dragVertexRemoveStart: function(evt, x, y) {\n\n\t        if (!this.can('vertexRemove')) { return; }\n\n\t        var removeNode = evt.target;\n\t        var vertexIdx = parseInt(removeNode.getAttribute('idx'), 10);\n\t        this.model.removeVertex(vertexIdx);\n\t    },\n\n\t    dragArrowheadStart: function(evt, x, y) {\n\n\t        if (!this.can('arrowheadMove')) { return; }\n\n\t        var arrowheadNode = evt.target;\n\t        var arrowheadType = arrowheadNode.getAttribute('end');\n\t        var data = this.startArrowheadMove(arrowheadType, { ignoreBackwardsCompatibility: true });\n\n\t        this.eventData(evt, data);\n\t    },\n\n\t    dragStart: function(evt, x, y) {\n\n\t        if (this.isDefaultInteractionPrevented(evt)) { return; }\n\n\t        if (!this.can('linkMove')) { return; }\n\n\t        this.eventData(evt, {\n\t            action: 'move',\n\t            dx: x,\n\t            dy: y\n\t        });\n\t    },\n\n\t    // Drag Handlers\n\t    dragLabel: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        var label = { position: this.getLabelPosition((x + data.dx), (y + data.dy), data.positionAngle, data.positionArgs) };\n\t        if (this.paper.options.snapLabels) { delete label.position.offset; }\n\t        // The `touchmove' events are not fired\n\t        // when the original event target is removed from the DOM.\n\t        // The labels are currently re-rendered completely when only\n\t        // the position changes. This is why we need to make sure that\n\t        // the label is updated synchronously.\n\t        // TODO: replace `touchmove` with `pointermove` (breaking change).\n\t        var setOptions = { ui: true };\n\t        if (this.paper.isAsync() && evt.type === 'touchmove') {\n\t            setOptions.async = false;\n\t        }\n\t        this.model.label(data.labelIdx, label, setOptions);\n\t    },\n\n\t    dragVertex: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        this.model.vertex(data.vertexIdx, { x: x, y: y }, { ui: true });\n\t    },\n\n\t    dragArrowhead: function(evt, x, y) {\n\t        if (this.paper.options.snapLinks) {\n\t            var isSnapped = this._snapArrowhead(evt, x, y);\n\t            if (!isSnapped && this.paper.options.snapLinksSelf) {\n\t                this._snapArrowheadSelf(evt, x, y);\n\t            }\n\t        } else {\n\t            if (this.paper.options.snapLinksSelf) {\n\t                this._snapArrowheadSelf(evt, x, y);\n\t            } else {\n\t                this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n\t            }\n\t        }\n\t    },\n\n\t    drag: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        this.model.translate(x - data.dx, y - data.dy, { ui: true });\n\t        this.eventData(evt, {\n\t            dx: x,\n\t            dy: y\n\t        });\n\t    },\n\n\t    // Drag End Handlers\n\n\t    dragLabelEnd: function() {\n\t        // noop\n\t    },\n\n\t    dragVertexEnd: function() {\n\t        // noop\n\t    },\n\n\t    dragArrowheadEnd: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        var paper = this.paper;\n\n\t        if (paper.options.snapLinks) {\n\t            this._snapArrowheadEnd(data);\n\t        } else {\n\t            this._connectArrowheadEnd(data, x, y);\n\t        }\n\n\t        if (!paper.linkAllowed(this)) {\n\t            // If the changed link is not allowed, revert to its previous state.\n\t            this._disallow(data);\n\t        } else {\n\t            this._finishEmbedding(data);\n\t            this._notifyConnectEvent(data, evt);\n\t        }\n\n\t        this._afterArrowheadMove(data);\n\t    },\n\n\t    dragEnd: function() {\n\t        // noop\n\t    },\n\n\t    _disallow: function(data) {\n\n\t        switch (data.whenNotAllowed) {\n\n\t            case 'remove':\n\t                this.model.remove({ ui: true });\n\t                break;\n\n\t            case 'revert':\n\t            default:\n\t                this.model.set(data.arrowhead, data.initialEnd, { ui: true });\n\t                break;\n\t        }\n\t    },\n\n\t    _finishEmbedding: function(data) {\n\n\t        // Reparent the link if embedding is enabled\n\t        if (this.paper.options.embeddingMode && this.model.reparent()) {\n\t            // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n\t            data.z = null;\n\t        }\n\t    },\n\n\t    _notifyConnectEvent: function(data, evt) {\n\n\t        var arrowhead = data.arrowhead;\n\t        var initialEnd = data.initialEnd;\n\t        var currentEnd = this.model.prop(arrowhead);\n\t        var endChanged = currentEnd && !Link.endsEqual(initialEnd, currentEnd);\n\t        if (endChanged) {\n\t            var paper = this.paper;\n\t            if (initialEnd.id) {\n\t                this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n\t            }\n\t            if (currentEnd.id) {\n\t                this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n\t            }\n\t        }\n\t    },\n\n\t    _snapToPoints: function(snapPoint, points, radius) {\n\t        var closestPointX = null;\n\t        var closestDistanceX = Infinity;\n\n\t        var closestPointY = null;\n\t        var closestDistanceY = Infinity;\n\n\t        var x = snapPoint.x;\n\t        var y = snapPoint.y;\n\n\t        for (var i = 0; i < points.length; i++) {\n\t            var distX = Math.abs(points[i].x - snapPoint.x);\n\t            if (distX < closestDistanceX) {\n\t                closestDistanceX = distX;\n\t                closestPointX = points[i];\n\t            }\n\n\t            var distY = Math.abs(points[i].y - snapPoint.y);\n\t            if (distY < closestDistanceY) {\n\t                closestDistanceY = distY;\n\t                closestPointY = points[i];\n\t            }\n\t        }\n\n\t        if (closestDistanceX < radius) {\n\t            x = closestPointX.x;\n\t        }\n\t        if (closestDistanceY < radius) {\n\t            y = closestPointY.y;\n\t        }\n\n\t        return { x: x, y: y };\n\t    },\n\n\t    _snapArrowheadSelf: function(evt, x, y) {\n\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var model = ref.model;\n\t        var ref$1 = paper.options;\n\t        var snapLinksSelf = ref$1.snapLinksSelf;\n\t        var data = this.eventData(evt);\n\t        var radius = snapLinksSelf.radius || 20;\n\n\t        var anchor = this.getEndAnchor(data.arrowhead === 'source' ? 'target' : 'source');\n\t        var vertices = model.vertices();\n\t        var points = [anchor ].concat( vertices);\n\n\t        var snapPoint = this._snapToPoints({ x: x, y: y }, points, radius);\n\n\t        this._connectArrowhead(document.elementFromPoint(snapPoint.x, snapPoint.y), snapPoint.x, snapPoint.y, this.eventData(evt));\n\t    },\n\n\t    _snapArrowhead: function(evt, x, y) {\n\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var ref$1 = paper.options;\n\t        var snapLinks = ref$1.snapLinks;\n\t        var connectionStrategy = ref$1.connectionStrategy;\n\t        var data = this.eventData(evt);\n\t        var isSnapped = false;\n\t        // checking view in close area of the pointer\n\n\t        var r = snapLinks.radius || 50;\n\t        var viewsInArea = paper.findViewsInArea({ x: x - r, y: y - r, width: 2 * r, height: 2 * r });\n\n\t        var prevClosestView = data.closestView || null;\n\t        var prevClosestMagnet = data.closestMagnet || null;\n\t        var prevMagnetProxy = data.magnetProxy || null;\n\n\t        data.closestView = data.closestMagnet = data.magnetProxy = null;\n\n\t        var minDistance = Number.MAX_VALUE;\n\t        var pointer = new Point(x, y);\n\n\t        viewsInArea.forEach(function(view) {\n\t            var candidates = [];\n\t            // skip connecting to the element in case '.': { magnet: false } attribute present\n\t            if (view.el.getAttribute('magnet') !== 'false') {\n\t                candidates.push({\n\t                    bbox: view.model.getBBox(),\n\t                    magnet: view.el\n\t                });\n\t            }\n\n\t            view.$('[magnet]').toArray().forEach(function (magnet) {\n\t                candidates.push({\n\t                    bbox: view.getNodeBBox(magnet),\n\t                    magnet: magnet\n\t                });\n\t            });\n\n\t            candidates.forEach(function (candidate) {\n\t                var magnet = candidate.magnet;\n\t                var bbox = candidate.bbox;\n\t                // find distance from the center of the model to pointer coordinates\n\t                var distance = bbox.center().squaredDistance(pointer);\n\t                // the connection is looked up in a circle area by `distance < r`\n\t                if (distance < minDistance) {\n\t                    var isAlreadyValidated = prevClosestMagnet === magnet;\n\t                    if (isAlreadyValidated || paper.options.validateConnection.apply(\n\t                        paper, data.validateConnectionArgs(view, (view.el === magnet) ? null : magnet)\n\t                    )) {\n\t                        minDistance = distance;\n\t                        data.closestView = view;\n\t                        data.closestMagnet = magnet;\n\t                    }\n\t                }\n\t            });\n\n\t        }, this);\n\n\t        var end;\n\t        var magnetProxy = null;\n\t        var closestView = data.closestView;\n\t        var closestMagnet = data.closestMagnet;\n\t        if (closestMagnet) {\n\t            magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n\t        }\n\t        var endType = data.arrowhead;\n\t        var newClosestMagnet = (prevClosestMagnet !== closestMagnet);\n\t        if (prevClosestView && newClosestMagnet) {\n\t            prevClosestView.unhighlight(prevMagnetProxy, {\n\t                connecting: true,\n\t                snapping: true\n\t            });\n\t        }\n\n\t        if (closestView) {\n\t            var prevEnd = data.prevEnd;\n\t            var prevX = data.prevX;\n\t            var prevY = data.prevY;\n\t            data.prevX = x;\n\t            data.prevY = y;\n\t            isSnapped = true;\n\n\t            if (!newClosestMagnet)  {\n\t                if (typeof connectionStrategy !== 'function' || (prevX === x && prevY === y)) {\n\t                    // the magnet has not changed and the link's end does not depend on the x and y\n\t                    return isSnapped;\n\t                }\n\t            }\n\n\t            end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n\t            if (!newClosestMagnet && isEqual(prevEnd, end)) {\n\t                // the source/target json has not changed\n\t                return isSnapped;\n\t            }\n\n\t            data.prevEnd = end;\n\n\t            if (newClosestMagnet) {\n\t                closestView.highlight(magnetProxy, {\n\t                    connecting: true,\n\t                    snapping: true\n\t                });\n\t            }\n\n\t        } else {\n\n\t            end = { x: x, y: y };\n\t        }\n\n\t        this.model.set(endType, end || { x: x, y: y }, { ui: true });\n\n\t        if (prevClosestView) {\n\t            this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n\t        }\n\t        if (closestView) {\n\t            this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n\t        }\n\n\t        return isSnapped;\n\t    },\n\n\t    _snapArrowheadEnd: function(data) {\n\n\t        // Finish off link snapping.\n\t        // Everything except view unhighlighting was already done on pointermove.\n\t        var closestView = data.closestView;\n\t        var closestMagnet = data.closestMagnet;\n\t        if (closestView && closestMagnet) {\n\n\t            closestView.unhighlight(data.magnetProxy, { connecting: true, snapping: true });\n\t            data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n\t        }\n\n\t        data.closestView = data.closestMagnet = null;\n\t    },\n\n\t    _connectArrowhead: function(target, x, y, data) {\n\n\t        // checking views right under the pointer\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var model = ref.model;\n\n\t        if (data.eventTarget !== target) {\n\t            // Unhighlight the previous view under pointer if there was one.\n\t            if (data.magnetProxy) {\n\t                data.viewUnderPointer.unhighlight(data.magnetProxy, {\n\t                    connecting: true\n\t                });\n\t            }\n\n\t            var viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n\t            if (viewUnderPointer) {\n\t                // If we found a view that is under the pointer, we need to find the closest\n\t                // magnet based on the real target element of the event.\n\t                var magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n\t                var magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n\n\t                if (magnetUnderPointer && this.paper.options.validateConnection.apply(\n\t                    paper,\n\t                    data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer)\n\t                )) {\n\t                    // If there was no magnet found, do not highlight anything and assume there\n\t                    // is no view under pointer we're interested in reconnecting to.\n\t                    // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n\t                    if (magnetProxy) {\n\t                        viewUnderPointer.highlight(magnetProxy, {\n\t                            connecting: true\n\t                        });\n\t                    }\n\t                } else {\n\t                    // This type of connection is not valid. Disregard this magnet.\n\t                    data.magnetUnderPointer = null;\n\t                    data.magnetProxy = null;\n\t                }\n\t            } else {\n\t                // Make sure we'll unset previous magnet.\n\t                data.magnetUnderPointer = null;\n\t                data.magnetProxy = null;\n\t            }\n\t        }\n\n\t        data.eventTarget = target;\n\n\t        model.set(data.arrowhead, { x: x, y: y }, { ui: true });\n\t    },\n\n\t    _connectArrowheadEnd: function(data, x, y) {\n\t        if ( data === void 0 ) data = {};\n\n\n\t        var ref = this;\n\t        var model = ref.model;\n\t        var viewUnderPointer = data.viewUnderPointer;\n\t        var magnetUnderPointer = data.magnetUnderPointer;\n\t        var magnetProxy = data.magnetProxy;\n\t        var arrowhead = data.arrowhead;\n\n\t        if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) { return; }\n\n\t        viewUnderPointer.unhighlight(magnetProxy, { connecting: true });\n\n\t        // The link end is taken from the magnet under the pointer, not the proxy.\n\t        var end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n\t        model.set(arrowhead, end, { ui: true });\n\t    },\n\n\t    _beforeArrowheadMove: function(data) {\n\n\t        data.z = this.model.get('z');\n\t        this.model.toFront();\n\n\t        // Let the pointer propagate through the link view elements so that\n\t        // the `evt.target` is another element under the pointer, not the link itself.\n\t        var style = this.el.style;\n\t        data.pointerEvents = style.pointerEvents;\n\t        style.pointerEvents = 'none';\n\n\t        if (this.paper.options.markAvailable) {\n\t            this._markAvailableMagnets(data);\n\t        }\n\t    },\n\n\t    _afterArrowheadMove: function(data) {\n\n\t        if (data.z !== null) {\n\t            this.model.set('z', data.z, { ui: true });\n\t            data.z = null;\n\t        }\n\n\t        // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n\t        this.el.style.pointerEvents = data.pointerEvents;\n\n\t        if (this.paper.options.markAvailable) {\n\t            this._unmarkAvailableMagnets(data);\n\t        }\n\t    },\n\n\t    _createValidateConnectionArgs: function(arrowhead) {\n\t        // It makes sure the arguments for validateConnection have the following form:\n\t        // (source view, source magnet, target view, target magnet and link view)\n\t        var args = [];\n\n\t        args[4] = arrowhead;\n\t        args[5] = this;\n\n\t        var oppositeArrowhead;\n\t        var i = 0;\n\t        var j = 0;\n\n\t        if (arrowhead === 'source') {\n\t            i = 2;\n\t            oppositeArrowhead = 'target';\n\t        } else {\n\t            j = 2;\n\t            oppositeArrowhead = 'source';\n\t        }\n\n\t        var end = this.model.get(oppositeArrowhead);\n\n\t        if (end.id) {\n\t            var view = args[i] = this.paper.findViewByModel(end.id);\n\t            var magnet = view.getMagnetFromLinkEnd(end);\n\t            if (magnet === view.el) { magnet = undefined; }\n\t            args[i + 1] = magnet;\n\t        }\n\n\t        function validateConnectionArgs(cellView, magnet) {\n\t            args[j] = cellView;\n\t            args[j + 1] = cellView.el === magnet ? undefined : magnet;\n\t            return args;\n\t        }\n\n\t        return validateConnectionArgs;\n\t    },\n\n\t    _markAvailableMagnets: function(data) {\n\n\t        function isMagnetAvailable(view, magnet) {\n\t            var paper = view.paper;\n\t            var validate = paper.options.validateConnection;\n\t            return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n\t        }\n\n\t        var paper = this.paper;\n\t        var elements = paper.model.getCells();\n\t        data.marked = {};\n\n\t        for (var i = 0, n = elements.length; i < n; i++) {\n\t            var view = elements[i].findView(paper);\n\n\t            if (!view) {\n\t                continue;\n\t            }\n\n\t            var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n\t            if (view.el.getAttribute('magnet') !== 'false') {\n\t                // Element wrapping group is also a magnet\n\t                magnets.push(view.el);\n\t            }\n\n\t            var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n\n\t            if (availableMagnets.length > 0) {\n\t                // highlight all available magnets\n\t                for (var j = 0, m = availableMagnets.length; j < m; j++) {\n\t                    view.highlight(availableMagnets[j], { magnetAvailability: true });\n\t                }\n\t                // highlight the entire view\n\t                view.highlight(null, { elementAvailability: true });\n\n\t                data.marked[view.model.id] = availableMagnets;\n\t            }\n\t        }\n\t    },\n\n\t    _unmarkAvailableMagnets: function(data) {\n\n\t        var markedKeys = Object.keys(data.marked);\n\t        var id;\n\t        var markedMagnets;\n\n\t        for (var i = 0, n = markedKeys.length; i < n; i++) {\n\t            id = markedKeys[i];\n\t            markedMagnets = data.marked[id];\n\n\t            var view = this.paper.findViewByModel(id);\n\t            if (view) {\n\t                for (var j = 0, m = markedMagnets.length; j < m; j++) {\n\t                    view.unhighlight(markedMagnets[j], { magnetAvailability: true });\n\t                }\n\t                view.unhighlight(null, { elementAvailability: true });\n\t            }\n\t        }\n\n\t        data.marked = null;\n\t    },\n\n\t    startArrowheadMove: function(end, opt) {\n\n\t        opt || (opt = {});\n\n\t        // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n\t        // move without need to click on the actual arrowhead dom element.\n\t        var data = {\n\t            action: 'arrowhead-move',\n\t            arrowhead: end,\n\t            whenNotAllowed: opt.whenNotAllowed || 'revert',\n\t            initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n\t            initialEnd: clone(this.model.get(end)),\n\t            validateConnectionArgs: this._createValidateConnectionArgs(end)\n\t        };\n\n\t        this._beforeArrowheadMove(data);\n\n\t        if (opt.ignoreBackwardsCompatibility !== true) {\n\t            this._dragData = data;\n\t        }\n\n\t        return data;\n\t    },\n\n\t    // Lifecycle methods\n\n\t    onMount: function() {\n\t        CellView.prototype.onMount.apply(this, arguments);\n\t        this.mountLabels();\n\t    },\n\n\t    onDetach: function() {\n\t        CellView.prototype.onDetach.apply(this, arguments);\n\t        this.unmountLabels();\n\t    },\n\n\t    onRemove: function() {\n\t        CellView.prototype.onRemove.apply(this, arguments);\n\t        this.unmountLabels();\n\t    }\n\n\t}, {\n\n\t    Flags: Flags$2,\n\t});\n\n\tObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n\n\t    enumerable: true,\n\n\t    get: function() {\n\t        var sourceView = this.sourceView;\n\t        if (!sourceView) {\n\t            var sourceDef = this.model.source();\n\t            return new Rect(sourceDef.x, sourceDef.y);\n\t        }\n\t        var sourceMagnet = this.sourceMagnet;\n\t        if (sourceView.isNodeConnection(sourceMagnet)) {\n\t            return new Rect(this.sourceAnchor);\n\t        }\n\t        return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n\t    }\n\n\t});\n\n\tObject.defineProperty(LinkView.prototype, 'targetBBox', {\n\n\t    enumerable: true,\n\n\t    get: function() {\n\t        var targetView = this.targetView;\n\t        if (!targetView) {\n\t            var targetDef = this.model.target();\n\t            return new Rect(targetDef.x, targetDef.y);\n\t        }\n\t        var targetMagnet = this.targetMagnet;\n\t        if (targetView.isNodeConnection(targetMagnet)) {\n\t            return new Rect(this.targetAnchor);\n\t        }\n\t        return targetView.getNodeBBox(targetMagnet || targetView.el);\n\t    }\n\t});\n\n\tvar stroke = HighlighterView.extend({\n\n\t    tagName: 'path',\n\t    className: 'highlight-stroke',\n\t    attributes: {\n\t        'pointer-events': 'none',\n\t        'vector-effect': 'non-scaling-stroke',\n\t        'fill': 'none'\n\t    },\n\n\t    options: {\n\t        padding: 3,\n\t        rx: 0,\n\t        ry: 0,\n\t        useFirstSubpath: false,\n\t        attrs: {\n\t            'stroke-width': 3,\n\t            'stroke': '#FEB663'\n\t        }\n\t    },\n\n\t    getPathData: function getPathData(cellView, node) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var useFirstSubpath = options.useFirstSubpath;\n\t        var d;\n\t        try {\n\t            var vNode = V(node);\n\t            d = vNode.convertToPathData().trim();\n\t            if (vNode.tagName() === 'PATH' && useFirstSubpath) {\n\t                var secondSubpathIndex = d.search(/.M/i) + 1;\n\t                if (secondSubpathIndex > 0) {\n\t                    d = d.substr(0, secondSubpathIndex);\n\t                }\n\t            }\n\t        } catch (error) {\n\t            // Failed to get path data from magnet element.\n\t            // Draw a rectangle around the node instead.\n\t            var nodeBBox = cellView.getNodeBoundingRect(node);\n\t            d = V.rectToPath(assign({}, options, nodeBBox.toJSON()));\n\t        }\n\t        return d;\n\t    },\n\n\t    highlightConnection: function highlightConnection(cellView) {\n\t        this.vel.attr('d', cellView.getSerializedConnection());\n\t    },\n\n\t    highlightNode: function highlightNode(cellView, node) {\n\t        var ref = this;\n\t        var vel = ref.vel;\n\t        var options = ref.options;\n\t        var padding = options.padding;\n\t        var layer = options.layer;\n\t        var highlightMatrix = this.getNodeMatrix(cellView, node);\n\t        // Add padding to the highlight element.\n\t        if (padding) {\n\t            if (!layer && node === cellView.el) {\n\t                // If the highlighter is appended to the cellView\n\t                // and we measure the size of the cellView wrapping group\n\t                // it's necessary to remove the highlighter first\n\t                vel.remove();\n\t            }\n\t            var nodeBBox = cellView.getNodeBoundingRect(node);\n\t            var cx = nodeBBox.x + (nodeBBox.width / 2);\n\t            var cy = nodeBBox.y + (nodeBBox.height / 2);\n\t            nodeBBox = V.transformRect(nodeBBox, highlightMatrix);\n\t            var width = Math.max(nodeBBox.width, 1);\n\t            var height = Math.max(nodeBBox.height, 1);\n\t            var sx = (width + padding) / width;\n\t            var sy = (height + padding) / height;\n\t            var paddingMatrix = V.createSVGMatrix({\n\t                a: sx,\n\t                b: 0,\n\t                c: 0,\n\t                d: sy,\n\t                e: cx - sx * cx,\n\t                f: cy - sy * cy\n\t            });\n\t            highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n\t        }\n\t        vel.attr({\n\t            'd': this.getPathData(cellView, node),\n\t            'transform': V.matrixToTransformString(highlightMatrix)\n\t        });\n\t    },\n\n\t    highlight: function highlight(cellView, node) {\n\t        var ref = this;\n\t        var vel = ref.vel;\n\t        var options = ref.options;\n\t        vel.attr(options.attrs);\n\t        if (cellView.isNodeConnection(node)) {\n\t            this.highlightConnection(cellView);\n\t        } else {\n\t            this.highlightNode(cellView, node);\n\t        }\n\t    }\n\n\t});\n\n\tvar MASK_CLIP = 20;\n\n\tfunction forEachDescendant(vel, fn) {\n\t    var descendants = vel.children();\n\t    while (descendants.length > 0) {\n\t        var descendant = descendants.shift();\n\t        if (fn(descendant)) {\n\t            descendants.push.apply(descendants, descendant.children());\n\t        }\n\t    }\n\t}\n\n\tvar mask = HighlighterView.extend({\n\n\t    tagName: 'rect',\n\t    className: 'highlight-mask',\n\t    attributes: {\n\t        'pointer-events': 'none'\n\t    },\n\n\t    options: {\n\t        padding: 3,\n\t        maskClip: MASK_CLIP,\n\t        deep: false,\n\t        attrs: {\n\t            'stroke': '#FEB663',\n\t            'stroke-width': 3,\n\t            'stroke-linecap': 'butt',\n\t            'stroke-linejoin': 'miter',\n\t        }\n\t    },\n\n\t    VISIBLE: 'white',\n\t    INVISIBLE: 'black',\n\n\t    MASK_ROOT_ATTRIBUTE_BLACKLIST: [\n\t        'marker-start',\n\t        'marker-end',\n\t        'marker-mid',\n\t        'transform',\n\t        'stroke-dasharray',\n\t        'class' ],\n\n\t    MASK_CHILD_ATTRIBUTE_BLACKLIST: [\n\t        'stroke',\n\t        'fill',\n\t        'stroke-width',\n\t        'stroke-opacity',\n\t        'stroke-dasharray',\n\t        'fill-opacity',\n\t        'marker-start',\n\t        'marker-end',\n\t        'marker-mid',\n\t        'class' ],\n\n\t    // TODO: change the list to a function callback\n\t    MASK_REPLACE_TAGS: [\n\t        'FOREIGNOBJECT',\n\t        'IMAGE',\n\t        'USE',\n\t        'TEXT',\n\t        'TSPAN',\n\t        'TEXTPATH'\n\t    ],\n\n\t    // TODO: change the list to a function callback\n\t    MASK_REMOVE_TAGS: [\n\t        'TEXT',\n\t        'TSPAN',\n\t        'TEXTPATH'\n\t    ],\n\n\t    transformMaskChild: function transformMaskChild(cellView, childEl) {\n\t        var ref = this;\n\t        var MASK_CHILD_ATTRIBUTE_BLACKLIST = ref.MASK_CHILD_ATTRIBUTE_BLACKLIST;\n\t        var MASK_REPLACE_TAGS = ref.MASK_REPLACE_TAGS;\n\t        var MASK_REMOVE_TAGS = ref.MASK_REMOVE_TAGS;\n\t        var childTagName = childEl.tagName();\n\t        // Do not include the element in the mask's image\n\t        if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n\t            childEl.remove();\n\t            return false;\n\t        }\n\t        // Replace the element with a rectangle\n\t        if (MASK_REPLACE_TAGS.includes(childTagName)) {\n\t            // Note: clone() method does not change the children ids\n\t            var originalChild = cellView.vel.findOne((\"#\" + (childEl.id)));\n\t            if (originalChild) {\n\t                var originalNode = originalChild.node;\n\t                var childBBox = cellView.getNodeBoundingRect(originalNode);\n\t                if (cellView.model.isElement()) {\n\t                    childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n\t                }\n\t                var replacement = V('rect', childBBox.toJSON());\n\t                var ref$1 = childBBox.center();\n\t                var ox = ref$1.x;\n\t                var oy = ref$1.y;\n\t                var ref$2 = originalChild.rotate();\n\t                var angle = ref$2.angle;\n\t                var cx = ref$2.cx; if ( cx === void 0 ) cx = ox;\n\t                var cy = ref$2.cy; if ( cy === void 0 ) cy = oy;\n\t                if (angle) { replacement.rotate(angle, cx, cy); }\n\t                // Note: it's not important to keep the same sibling index since all subnodes are filled\n\t                childEl.parent().append(replacement);\n\t            }\n\t            childEl.remove();\n\t            return false;\n\t        }\n\t        // Keep the element, but clean it from certain attributes\n\t        MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(function (attrName) {\n\t            if (attrName === 'fill' && childEl.attr('fill') === 'none') { return; }\n\t            childEl.removeAttr(attrName);\n\t        });\n\t        return true;\n\t    },\n\n\t    transformMaskRoot: function transformMaskRoot(_cellView, rootEl) {\n\t        var ref = this;\n\t        var MASK_ROOT_ATTRIBUTE_BLACKLIST = ref.MASK_ROOT_ATTRIBUTE_BLACKLIST;\n\t        MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(function (attrName) {\n\t            rootEl.removeAttr(attrName);\n\t        });\n\t    },\n\n\t    getMaskShape: function getMaskShape(cellView, vel) {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var MASK_REPLACE_TAGS = ref.MASK_REPLACE_TAGS;\n\t        var deep = options.deep;\n\t        var tagName = vel.tagName();\n\t        var maskRoot;\n\t        if (tagName === 'G') {\n\t            if (!deep) { return null; }\n\t            maskRoot = vel.clone();\n\t            forEachDescendant(maskRoot, function (maskChild) { return this$1.transformMaskChild(cellView, maskChild); });\n\t        } else {\n\t            if (MASK_REPLACE_TAGS.includes(tagName)) { return null; }\n\t            maskRoot = vel.clone();\n\t        }\n\t        this.transformMaskRoot(cellView, maskRoot);\n\t        return maskRoot;\n\t    },\n\n\t    getMaskId: function getMaskId() {\n\t        return (\"highlight-mask-\" + (this.cid));\n\t    },\n\n\t    getMask: function getMask(cellView, vNode) {\n\n\t        var ref = this;\n\t        var VISIBLE = ref.VISIBLE;\n\t        var INVISIBLE = ref.INVISIBLE;\n\t        var options = ref.options;\n\t        var padding = options.padding;\n\t        var attrs = options.attrs;\n\n\t        var strokeWidth = ('stroke-width' in attrs) ? attrs['stroke-width'] : 1;\n\t        var hasNodeFill = vNode.attr('fill') !== 'none';\n\t        var magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n\t        if (isNaN(magnetStrokeWidth)) { magnetStrokeWidth = 1; }\n\t        // stroke of the invisible shape\n\t        var minStrokeWidth = magnetStrokeWidth + padding * 2;\n\t        // stroke of the visible shape\n\t        var maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n\t        var maskEl = this.getMaskShape(cellView, vNode);\n\t        if (!maskEl) {\n\t            var nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n\t            // Make sure the rect is visible\n\t            nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n\t            maskEl =  V('rect', nodeBBox.toJSON());\n\t        }\n\t        maskEl.attr(attrs);\n\t        return V('mask', {\n\t            'id': this.getMaskId()\n\t        }).append([\n\t            maskEl.clone().attr({\n\t                'fill': hasNodeFill ? VISIBLE : 'none',\n\t                'stroke': VISIBLE,\n\t                'stroke-width': maxStrokeWidth\n\t            }),\n\t            maskEl.clone().attr({\n\t                'fill': hasNodeFill ? INVISIBLE : 'none',\n\t                'stroke': INVISIBLE,\n\t                'stroke-width': minStrokeWidth\n\t            })\n\t        ]);\n\t    },\n\n\t    removeMask: function removeMask(paper) {\n\t        var maskNode = paper.svg.getElementById(this.getMaskId());\n\t        if (maskNode) {\n\t            paper.defs.removeChild(maskNode);\n\t        }\n\t    },\n\n\t    addMask: function addMask(paper, maskEl) {\n\t        paper.defs.appendChild(maskEl.node);\n\t    },\n\n\t    highlight: function highlight(cellView, node) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var vel = ref.vel;\n\t        var padding = options.padding;\n\t        var attrs = options.attrs;\n\t        var maskClip = options.maskClip; if ( maskClip === void 0 ) maskClip = MASK_CLIP;\n\t        var layer = options.layer;\n\t        var color = ('stroke' in attrs) ? attrs['stroke'] : '#000000';\n\t        if (!layer && node === cellView.el) {\n\t            // If the highlighter is appended to the cellView\n\t            // and we measure the size of the cellView wrapping group\n\t            // it's necessary to remove the highlighter first\n\t            vel.remove();\n\t        }\n\t        var highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n\t        var highlightMatrix = this.getNodeMatrix(cellView, node);\n\t        var maskEl = this.getMask(cellView, V(node));\n\t        this.addMask(cellView.paper, maskEl);\n\t        vel.attr(highlighterBBox.toJSON());\n\t        vel.attr({\n\t            'transform': V.matrixToTransformString(highlightMatrix),\n\t            'mask': (\"url(#\" + (maskEl.id) + \")\"),\n\t            'fill': color\n\t        });\n\t    },\n\n\t    unhighlight: function unhighlight(cellView) {\n\t        this.removeMask(cellView.paper);\n\t    }\n\n\t});\n\n\tvar opacity = HighlighterView.extend({\n\n\t    UPDATABLE: false,\n\t    MOUNTABLE: false,\n\n\t    opacityClassName: addClassNamePrefix('highlight-opacity'),\n\n\t    highlight: function(_cellView, node) {\n\t        V(node).addClass(this.opacityClassName);\n\t    },\n\n\t    unhighlight: function(_cellView, node) {\n\t        V(node).removeClass(this.opacityClassName);\n\t    }\n\n\t});\n\n\tvar className = addClassNamePrefix('highlighted');\n\n\tvar addClass = HighlighterView.extend({\n\n\t    UPDATABLE: false,\n\t    MOUNTABLE: false,\n\n\t    options: {\n\t        className: className\n\t    },\n\n\t    highlight: function(_cellView, node) {\n\t        V(node).addClass(this.options.className);\n\t    },\n\n\t    unhighlight: function(_cellView, node) {\n\t        V(node).removeClass(this.options.className);\n\t    }\n\n\t}, {\n\t    // Backwards Compatibility\n\t    className: className\n\t});\n\n\tvar Directions$2 = {\n\t    ROW: 'row',\n\t    COLUMN: 'column'\n\t};\n\n\tvar list = HighlighterView.extend({\n\n\t    tagName: 'g',\n\t    MOUNTABLE: true,\n\t    UPDATE_ATTRIBUTES: function() {\n\t        return [this.options.attribute];\n\t    },\n\n\t    _prevItems: null,\n\n\t    highlight: function highlight(elementView, node) {\n\t        var this$1 = this;\n\n\t        var element = elementView.model;\n\t        var ref = this.options;\n\t        var attribute = ref.attribute;\n\t        var size = ref.size; if ( size === void 0 ) size = 20;\n\t        var gap = ref.gap; if ( gap === void 0 ) gap = 5;\n\t        var direction = ref.direction; if ( direction === void 0 ) direction = Directions$2.ROW;\n\t        if (!attribute) { throw new Error('List: attribute is required'); }\n\t        var normalizedSize = (typeof size === 'number') ? { width: size, height: size } : size;\n\t        var isRowDirection = (direction === Directions$2.ROW);\n\t        var itemWidth = isRowDirection ? normalizedSize.width : normalizedSize.height;\n\t        var items = element.get(attribute);\n\t        if (!Array.isArray(items)) { items = []; }\n\t        var prevItems = this._prevItems || [];\n\t        var comparison = items.map(function (item, index) { return isEqual(prevItems[index], items[index]); });\n\t        if (prevItems.length !== items.length || comparison.some(function (unchanged) { return !unchanged; })) {\n\t            var prevEls = this.vel.children();\n\t            var itemsEls = items.map(function (item, index) {\n\t                var prevEl = (index in prevEls) ? prevEls[index].node : null;\n\t                if (comparison[index]) { return prevEl; }\n\t                var itemEl = this$1.createListItem(item, normalizedSize, prevEl);\n\t                if (!itemEl) { return null; }\n\t                if (!(itemEl instanceof SVGElement)) { throw new Error('List: item must be an SVGElement'); }\n\t                itemEl.dataset.index = index;\n\t                itemEl.dataset.attribute = attribute;\n\t                var offset = index * (itemWidth + gap);\n\t                itemEl.setAttribute('transform', (isRowDirection)\n\t                    ? (\"translate(\" + offset + \", 0)\")\n\t                    : (\"translate(0, \" + offset + \")\")\n\t                );\n\t                return itemEl;\n\t            });\n\t            this.vel.empty().append(itemsEls);\n\t            this._prevItems = items;\n\t        }\n\t        var itemsCount = items.length;\n\t        var length = (itemsCount === 0)\n\t            ? 0\n\t            : (itemsCount * itemWidth + (itemsCount - 1) * gap);\n\t        var listSize = (isRowDirection)\n\t            ? { width: length, height: normalizedSize.height }\n\t            : { width: normalizedSize.width, height: length };\n\n\t        this.position(element, listSize);\n\t    },\n\n\t    position: function position(element, listSize) {\n\t        var ref = this;\n\t        var vel = ref.vel;\n\t        var options = ref.options;\n\t        var margin = options.margin; if ( margin === void 0 ) margin = 5;\n\t        var position = options.position; if ( position === void 0 ) position = 'top-left';\n\t        var ref$1 = element.size();\n\t        var width = ref$1.width;\n\t        var height = ref$1.height;\n\t        var ref$2 = normalizeSides(margin);\n\t        var left = ref$2.left;\n\t        var right = ref$2.right;\n\t        var top = ref$2.top;\n\t        var bottom = ref$2.bottom;\n\t        var bbox = new Rect(left, top, width - (left + right), height - (top + bottom));\n\t        var ref$3 = getRectPoint(bbox, position);\n\t        var x = ref$3.x;\n\t        var y = ref$3.y;\n\t        // x\n\t        switch (position) {\n\t            case Positions.CENTER:\n\t            case Positions.TOP:\n\t            case Positions.BOTTOM: {\n\t                x -= listSize.width / 2;\n\t                break;\n\t            }\n\t            case Positions.RIGHT:\n\t            case Positions.BOTTOM_RIGHT:\n\t            case Positions.TOP_RIGHT: {\n\t                x -= listSize.width;\n\t                break;\n\t            }\n\t        }\n\t        // y\n\t        switch (position) {\n\t            case Positions.CENTER:\n\t            case Positions.RIGHT:\n\t            case Positions.LEFT: {\n\t                y -= listSize.height / 2;\n\t                break;\n\t            }\n\t            case Positions.BOTTOM:\n\t            case Positions.BOTTOM_RIGHT:\n\t            case Positions.BOTTOM_LEFT: {\n\t                y -= listSize.height;\n\t                break;\n\t            }\n\t        }\n\t        vel.attr('transform', (\"translate(\" + x + \", \" + y + \")\"));\n\t    }\n\t}, {\n\t    Directions: Directions$2,\n\t    Positions: Positions\n\t});\n\n\n\n\tvar highlighters = ({\n\t\tstroke: stroke,\n\t\tmask: mask,\n\t\topacity: opacity,\n\t\taddClass: addClass,\n\t\tlist: list\n\t});\n\n\tfunction connectionRatio(view, _magnet, _refPoint, opt) {\n\n\t    var ratio = ('ratio' in opt) ? opt.ratio : 0.5;\n\t    return view.getPointAtRatio(ratio);\n\t}\n\n\tfunction connectionLength(view, _magnet, _refPoint, opt) {\n\n\t    var length = ('length' in opt) ? opt.length : 20;\n\t    return view.getPointAtLength(length);\n\t}\n\n\tfunction _connectionPerpendicular(view, _magnet, refPoint, opt) {\n\n\t    var OFFSET = 1e6;\n\t    var path = view.getConnection();\n\t    var segmentSubdivisions = view.getConnectionSubdivisions();\n\t    var verticalLine = new Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n\t    var horizontalLine = new Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n\t    var verticalIntersections = verticalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n\t    var horizontalIntersections = horizontalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n\t    var intersections = [];\n\t    if (verticalIntersections) { Array.prototype.push.apply(intersections, verticalIntersections); }\n\t    if (horizontalIntersections) { Array.prototype.push.apply(intersections, horizontalIntersections); }\n\t    if (intersections.length > 0) { return refPoint.chooseClosest(intersections); }\n\t    if ('fallbackAt' in opt) {\n\t        return getPointAtLink(view, opt.fallbackAt);\n\t    }\n\t    return connectionClosest(view, _magnet, refPoint, opt);\n\t}\n\n\tfunction _connectionClosest(view, _magnet, refPoint, _opt) {\n\n\t    var closestPoint = view.getClosestPoint(refPoint);\n\t    if (!closestPoint) { return new Point(); }\n\t    return closestPoint;\n\t}\n\n\tfunction resolveRef(fn) {\n\t    return function(view, magnet, ref, opt) {\n\t        if (ref instanceof Element) {\n\t            var refView = this.paper.findView(ref);\n\t            var refPoint;\n\t            if (refView) {\n\t                if (refView.isNodeConnection(ref)) {\n\t                    var distance = ('fixedAt' in opt) ? opt.fixedAt : '50%';\n\t                    refPoint = getPointAtLink(refView, distance);\n\t                } else {\n\t                    refPoint = refView.getNodeBBox(ref).center();\n\t                }\n\t            } else {\n\t                // Something went wrong\n\t                refPoint = new Point();\n\t            }\n\t            return fn.call(this, view, magnet, refPoint, opt);\n\t        }\n\t        return fn.apply(this, arguments);\n\t    };\n\t}\n\n\tfunction getPointAtLink(view, value) {\n\t    var parsedValue = parseFloat(value);\n\t    if (isPercentage(value)) {\n\t        return view.getPointAtRatio(parsedValue / 100);\n\t    } else {\n\t        return view.getPointAtLength(parsedValue);\n\t    }\n\t}\n\tvar connectionPerpendicular = resolveRef(_connectionPerpendicular);\n\tvar connectionClosest = resolveRef(_connectionClosest);\n\n\tvar linkAnchors = ({\n\t\tresolveRef: resolveRef,\n\t\tconnectionRatio: connectionRatio,\n\t\tconnectionLength: connectionLength,\n\t\tconnectionPerpendicular: connectionPerpendicular,\n\t\tconnectionClosest: connectionClosest\n\t});\n\n\tfunction offsetPoint(p1, p2, offset) {\n\t    if (isPlainObject(offset)) {\n\t        var x = offset.x;\n\t        var y = offset.y;\n\t        if (isFinite(y)) {\n\t            var line =  new Line(p2, p1);\n\t            var ref = line.parallel(y);\n\t            var start = ref.start;\n\t            var end = ref.end;\n\t            p2 = start;\n\t            p1 = end;\n\t        }\n\t        offset = x;\n\t    }\n\t    if (!isFinite(offset)) { return p1; }\n\t    var length = p1.distance(p2);\n\t    if (offset === 0 && length > 0) { return p1; }\n\t    return p1.move(p2, -Math.min(offset, length - 1));\n\t}\n\n\tfunction stroke$1(magnet) {\n\n\t    var stroke = magnet.getAttribute('stroke-width');\n\t    if (stroke === null) { return 0; }\n\t    return parseFloat(stroke) || 0;\n\t}\n\n\tfunction alignLine(line, type, offset) {\n\t    if ( offset === void 0 ) offset = 0;\n\n\t    var coordinate, a, b, direction;\n\t    var start = line.start;\n\t    var end = line.end;\n\t    switch (type) {\n\t        case 'left':\n\t            coordinate = 'x';\n\t            a = end;\n\t            b = start;\n\t            direction = -1;\n\t            break;\n\t        case 'right':\n\t            coordinate = 'x';\n\t            a = start;\n\t            b = end;\n\t            direction = 1;\n\t            break;\n\t        case 'top':\n\t            coordinate = 'y';\n\t            a = end;\n\t            b = start;\n\t            direction = -1;\n\t            break;\n\t        case 'bottom':\n\t            coordinate = 'y';\n\t            a = start;\n\t            b = end;\n\t            direction = 1;\n\t            break;\n\t        default:\n\t            return;\n\t    }\n\t    if (start[coordinate] < end[coordinate]) {\n\t        a[coordinate] = b[coordinate];\n\t    } else {\n\t        b[coordinate] = a[coordinate];\n\t    }\n\t    if (isFinite(offset)) {\n\t        a[coordinate] += direction * offset;\n\t        b[coordinate] += direction * offset;\n\t    }\n\t}\n\n\t// Connection Points\n\n\tfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n\t    var offset = opt.offset;\n\t    var alignOffset = opt.alignOffset;\n\t    var align = opt.align;\n\t    if (align) { alignLine(line, align, alignOffset); }\n\t    return offsetPoint(line.end, line.start, offset);\n\t}\n\n\tfunction bboxIntersection(line, view, magnet, opt) {\n\n\t    var bbox = view.getNodeBBox(magnet);\n\t    if (opt.stroke) { bbox.inflate(stroke$1(magnet) / 2); }\n\t    var intersections = line.intersect(bbox);\n\t    var cp = (intersections)\n\t        ? line.start.chooseClosest(intersections)\n\t        : line.end;\n\t    return offsetPoint(cp, line.start, opt.offset);\n\t}\n\n\tfunction rectangleIntersection(line, view, magnet, opt) {\n\n\t    var angle = view.model.angle();\n\t    if (angle === 0) {\n\t        return bboxIntersection(line, view, magnet, opt);\n\t    }\n\n\t    var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n\t    if (opt.stroke) { bboxWORotation.inflate(stroke$1(magnet) / 2); }\n\t    var center = bboxWORotation.center();\n\t    var lineWORotation = line.clone().rotate(center, angle);\n\t    var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n\t    var cp = (intersections)\n\t        ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle)\n\t        : line.end;\n\t    return offsetPoint(cp, line.start, opt.offset);\n\t}\n\n\tfunction findShapeNode(magnet) {\n\t    if (!magnet) { return null; }\n\t    var node = magnet;\n\t    do {\n\t        var tagName = node.tagName;\n\t        if (typeof tagName !== 'string') { return null; }\n\t        tagName = tagName.toUpperCase();\n\t        if (tagName === 'G') {\n\t            node = node.firstElementChild;\n\t        } else if (tagName === 'TITLE') {\n\t            node = node.nextElementSibling;\n\t        } else { break; }\n\t    } while (node);\n\t    return node;\n\t}\n\n\tvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\n\tvar BNDR_SHAPE_BBOX = 'shapeBBox';\n\n\tfunction boundaryIntersection(line, view, magnet, opt) {\n\n\t    var node, intersection;\n\t    var selector = opt.selector;\n\t    var anchor = line.end;\n\n\t    if (typeof selector === 'string') {\n\t        node = view.findBySelector(selector)[0];\n\t    } else if (selector === false) {\n\t        node = magnet;\n\t    } else if (Array.isArray(selector)) {\n\t        node = getByPath(magnet, selector);\n\t    } else {\n\t        node = findShapeNode(magnet);\n\t    }\n\n\t    if (!V.isSVGGraphicsElement(node)) {\n\t        if (node === magnet || !V.isSVGGraphicsElement(magnet)) { return anchor; }\n\t        node = magnet;\n\t    }\n\n\t    var localShape = view.getNodeShape(node);\n\t    var magnetMatrix = view.getNodeMatrix(node);\n\t    var translateMatrix = view.getRootTranslateMatrix();\n\t    var rotateMatrix = view.getRootRotateMatrix();\n\t    var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n\t    var localMatrix = targetMatrix.inverse();\n\t    var localLine = V.transformLine(line, localMatrix);\n\t    var localRef = localLine.start.clone();\n\t    var data = view.getNodeData(node);\n\n\t    if (opt.insideout === false) {\n\t        if (!data[BNDR_SHAPE_BBOX]) { data[BNDR_SHAPE_BBOX] = localShape.bbox(); }\n\t        var localBBox = data[BNDR_SHAPE_BBOX];\n\t        if (localBBox.containsPoint(localRef)) { return anchor; }\n\t    }\n\n\t    // Caching segment subdivisions for paths\n\t    var pathOpt;\n\t    if (localShape instanceof Path) {\n\t        var precision = opt.precision || 2;\n\t        if (!data[BNDR_SUBDIVISIONS]) { data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({ precision: precision }); }\n\t        pathOpt = {\n\t            precision: precision,\n\t            segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n\t        };\n\t    }\n\n\t    if (opt.extrapolate === true) { localLine.setLength(1e6); }\n\n\t    intersection = localLine.intersect(localShape, pathOpt);\n\t    if (intersection) {\n\t        // More than one intersection\n\t        if (V.isArray(intersection)) { intersection = localRef.chooseClosest(intersection); }\n\t    } else if (opt.sticky === true) {\n\t        // No intersection, find the closest point instead\n\t        if (localShape instanceof Rect) {\n\t            intersection = localShape.pointNearestToPoint(localRef);\n\t        } else if (localShape instanceof Ellipse) {\n\t            intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n\t        } else {\n\t            intersection = localShape.closestPoint(localRef, pathOpt);\n\t        }\n\t    }\n\n\t    var cp = (intersection) ? V.transformPoint(intersection, targetMatrix) : anchor;\n\t    var cpOffset = opt.offset || 0;\n\t    if (opt.stroke) { cpOffset += stroke$1(node) / 2; }\n\n\t    return offsetPoint(cp, line.start, cpOffset);\n\t}\n\n\tvar anchor = anchorConnectionPoint;\n\tvar bbox = bboxIntersection;\n\tvar rectangle = rectangleIntersection;\n\tvar boundary = boundaryIntersection;\n\n\tvar connectionPoints = ({\n\t\tanchor: anchor,\n\t\tbbox: bbox,\n\t\trectangle: rectangle,\n\t\tboundary: boundary\n\t});\n\n\tfunction bboxWrapper(method) {\n\n\t    return function(view, magnet, ref, opt) {\n\n\t        var rotate = !!opt.rotate;\n\t        var bbox = (rotate) ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n\t        var anchor = bbox[method]();\n\n\t        var dx = opt.dx;\n\t        if (dx) {\n\t            var dxPercentage = isPercentage(dx);\n\t            dx = parseFloat(dx);\n\t            if (isFinite(dx)) {\n\t                if (dxPercentage) {\n\t                    dx /= 100;\n\t                    dx *= bbox.width;\n\t                }\n\t                anchor.x += dx;\n\t            }\n\t        }\n\n\t        var dy = opt.dy;\n\t        if (dy) {\n\t            var dyPercentage = isPercentage(dy);\n\t            dy = parseFloat(dy);\n\t            if (isFinite(dy)) {\n\t                if (dyPercentage) {\n\t                    dy /= 100;\n\t                    dy *= bbox.height;\n\t                }\n\t                anchor.y += dy;\n\t            }\n\t        }\n\n\t        return (rotate) ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;\n\t    };\n\t}\n\n\tfunction _perpendicular(view, magnet, refPoint, opt) {\n\n\t    var angle = view.model.angle();\n\t    var bbox = view.getNodeBBox(magnet);\n\t    var anchor = bbox.center();\n\t    var topLeft = bbox.origin();\n\t    var bottomRight = bbox.corner();\n\n\t    var padding = opt.padding;\n\t    if (!isFinite(padding)) { padding = 0; }\n\n\t    if ((topLeft.y + padding) <= refPoint.y && refPoint.y <= (bottomRight.y - padding)) {\n\t        var dy = (refPoint.y - anchor.y);\n\t        anchor.x += (angle === 0 || angle === 180) ? 0 : dy * 1 / Math.tan(toRad(angle));\n\t        anchor.y += dy;\n\t    } else if ((topLeft.x + padding) <= refPoint.x && refPoint.x <= (bottomRight.x - padding)) {\n\t        var dx = (refPoint.x - anchor.x);\n\t        anchor.y += (angle === 90 || angle === 270) ? 0 : dx * Math.tan(toRad(angle));\n\t        anchor.x += dx;\n\t    }\n\n\t    return anchor;\n\t}\n\n\tfunction _midSide(view, magnet, refPoint, opt) {\n\n\t    var rotate = !!opt.rotate;\n\t    var bbox, angle, center;\n\t    if (rotate) {\n\t        bbox = view.getNodeUnrotatedBBox(magnet);\n\t        center = view.model.getBBox().center();\n\t        angle = view.model.angle();\n\t    } else {\n\t        bbox = view.getNodeBBox(magnet);\n\t    }\n\n\t    var padding = opt.padding;\n\t    if (isFinite(padding)) { bbox.inflate(padding); }\n\n\t    if (rotate) { refPoint.rotate(center, angle); }\n\n\t    var side = bbox.sideNearestToPoint(refPoint);\n\t    var anchor;\n\t    switch (side) {\n\t        case 'left':\n\t            anchor = bbox.leftMiddle();\n\t            break;\n\t        case 'right':\n\t            anchor = bbox.rightMiddle();\n\t            break;\n\t        case 'top':\n\t            anchor = bbox.topMiddle();\n\t            break;\n\t        case 'bottom':\n\t            anchor = bbox.bottomMiddle();\n\t            break;\n\t    }\n\n\t    return (rotate) ? anchor.rotate(center, -angle) : anchor;\n\t}\n\n\t// Can find anchor from model, when there is no selector or the link end\n\t// is connected to a port\n\tfunction _modelCenter(view, _magnet, _refPoint, opt, endType) {\n\t    return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n\t}\n\n\t//joint.anchors\n\tvar center = bboxWrapper('center');\n\tvar top$2 = bboxWrapper('topMiddle');\n\tvar bottom$2 = bboxWrapper('bottomMiddle');\n\tvar left$2 = bboxWrapper('leftMiddle');\n\tvar right$2 = bboxWrapper('rightMiddle');\n\tvar topLeft = bboxWrapper('origin');\n\tvar topRight = bboxWrapper('topRight');\n\tvar bottomLeft = bboxWrapper('bottomLeft');\n\tvar bottomRight = bboxWrapper('corner');\n\tvar perpendicular = resolveRef(_perpendicular);\n\tvar midSide = resolveRef(_midSide);\n\tvar modelCenter = _modelCenter;\n\n\tvar anchors = ({\n\t\tcenter: center,\n\t\ttop: top$2,\n\t\tbottom: bottom$2,\n\t\tleft: left$2,\n\t\tright: right$2,\n\t\ttopLeft: topLeft,\n\t\ttopRight: topRight,\n\t\tbottomLeft: bottomLeft,\n\t\tbottomRight: bottomRight,\n\t\tperpendicular: perpendicular,\n\t\tmidSide: midSide,\n\t\tmodelCenter: modelCenter\n\t});\n\n\tvar sortingTypes = {\n\t    NONE: 'sorting-none',\n\t    APPROX: 'sorting-approximate',\n\t    EXACT: 'sorting-exact'\n\t};\n\n\tvar WHEEL_CAP = 50;\n\tvar WHEEL_WAIT_MS = 20;\n\tvar MOUNT_BATCH_SIZE = 1000;\n\tvar UPDATE_BATCH_SIZE = Infinity;\n\tvar MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER\n\n\tvar HighlightingTypes$1 = CellView.Highlighting;\n\n\tvar defaultHighlighting = {};\n\tdefaultHighlighting[HighlightingTypes$1.DEFAULT] = {\n\t        name: 'stroke',\n\t        options: {\n\t            padding: 3\n\t        }\n\t    };\n\tdefaultHighlighting[HighlightingTypes$1.MAGNET_AVAILABILITY] = {\n\t        name: 'addClass',\n\t        options: {\n\t            className: 'available-magnet'\n\t        }\n\t    };\n\tdefaultHighlighting[HighlightingTypes$1.ELEMENT_AVAILABILITY] = {\n\t        name: 'addClass',\n\t        options: {\n\t            className: 'available-cell'\n\t        }\n\t    };\n\n\tvar defaultLayers = [{\n\t    name: LayersNames.BACK,\n\t}, {\n\t    name: LayersNames.CELLS,\n\t}, {\n\t    name: LayersNames.LABELS,\n\t}, {\n\t    name: LayersNames.FRONT\n\t}, {\n\t    name: LayersNames.TOOLS\n\t}];\n\n\tvar Paper = View.extend({\n\n\t    className: 'paper',\n\n\t    options: {\n\n\t        width: 800,\n\t        height: 600,\n\t        origin: { x: 0, y: 0 }, // x,y coordinates in top-left corner\n\t        gridSize: 1,\n\t        // Whether or not to draw the grid lines on the paper's DOM element.\n\t        // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\n\t        drawGrid: false,\n\t        // If not set, the size of the visual grid is the same as the `gridSize`.\n\t        drawGridSize: null,\n\n\t        // Whether or not to draw the background on the paper's DOM element.\n\t        // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\n\t        background: false,\n\n\t        perpendicularLinks: false,\n\t        elementView: ElementView,\n\t        linkView: LinkView,\n\t        snapLabels: false, // false, true\n\t        snapLinks: false, // false, true, { radius: value }\n\t        snapLinksSelf: false, // false, true, { radius: value }\n\n\t        // Should the link labels be rendered into its own layer?\n\t        // `false` - the labels are part of the links\n\t        // `true` - the labels are appended to LayersName.LABELS\n\t        // [LayersName] - the labels are appended to the layer specified\n\t        labelsLayer: false,\n\n\t        // When set to FALSE, an element may not have more than 1 link with the same source and target element.\n\t        multiLinks: true,\n\n\t        // For adding custom guard logic.\n\t        guard: function(evt, view) {\n\n\t            // FALSE means the event isn't guarded.\n\t            return false;\n\t        },\n\n\t        highlighting: defaultHighlighting,\n\n\t        // Prevent the default context menu from being displayed.\n\t        preventContextMenu: true,\n\n\t        // Prevent the default action for blank:pointer<action>.\n\t        preventDefaultBlankAction: true,\n\n\t        // Prevent the default action for cell:pointer<action>.\n\t        preventDefaultViewAction: true,\n\n\t        // Restrict the translation of elements by given bounding box.\n\t        // Option accepts a boolean:\n\t        //  true - the translation is restricted to the paper area\n\t        //  false - no restrictions\n\t        // A method:\n\t        // restrictTranslate: function(elementView) {\n\t        //     var parentId = elementView.model.get('parent');\n\t        //     return parentId && this.model.getCell(parentId).getBBox();\n\t        // },\n\t        // Or a bounding box:\n\t        // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\n\t        restrictTranslate: false,\n\n\t        // Marks all available magnets with 'available-magnet' class name and all available cells with\n\t        // 'available-cell' class name. Marks them when dragging a link is started and unmark\n\t        // when the dragging is stopped.\n\t        markAvailable: false,\n\n\t        // Defines what link model is added to the graph after an user clicks on an active magnet.\n\t        // Value could be the Backbone.model or a function returning the Backbone.model\n\t        // defaultLink: function(elementView, magnet) { return condition ? new customLink1() : new customLink2() }\n\t        defaultLink: new Link,\n\n\t        // A connector that is used by links with no connector defined on the model.\n\t        // e.g. { name: 'rounded', args: { radius: 5 }} or a function\n\t        defaultConnector: { name: 'normal' },\n\n\t        // A router that is used by links with no router defined on the model.\n\t        // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\n\t        defaultRouter: { name: 'normal' },\n\n\t        defaultAnchor: { name: 'center' },\n\n\t        defaultLinkAnchor: { name: 'connectionRatio' },\n\n\t        defaultConnectionPoint: { name: 'bbox' },\n\n\t        /* CONNECTING */\n\n\t        connectionStrategy: null,\n\n\t        // Check whether to add a new link to the graph when user clicks on an a magnet.\n\t        validateMagnet: function(_cellView, magnet, _evt) {\n\t            return magnet.getAttribute('magnet') !== 'passive';\n\t        },\n\n\t        // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\n\t        // being changed.\n\t        validateConnection: function(cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {\n\t            return (end === 'target' ? cellViewT : cellViewS) instanceof ElementView;\n\t        },\n\n\t        /* EMBEDDING */\n\n\t        // Enables embedding. Re-parent the dragged element with elements under it and makes sure that\n\t        // all links and elements are visible taken the level of embedding into account.\n\t        embeddingMode: false,\n\n\t        // Check whether to allow or disallow the element embedding while an element being translated.\n\t        validateEmbedding: function(childView, parentView) {\n\t            // by default all elements can be in relation child-parent\n\t            return true;\n\t        },\n\n\t        // Check whether to allow or disallow an embedded element to be unembedded / to become a root.\n\t        validateUnembedding: function(childView) {\n\t            // by default all elements can become roots\n\t            return true;\n\t        },\n\n\t        // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\n\t        // The cell with the highest z-index (visually on the top) will be chosen.\n\t        findParentBy: 'bbox', // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'\n\n\t        // If enabled only the element on the very front is taken into account for the embedding.\n\t        // If disabled the elements under the dragged view are tested one by one\n\t        // (from front to back) until a valid parent found.\n\t        frontParentOnly: true,\n\n\t        // Interactive flags. See online docs for the complete list of interactive flags.\n\t        interactive: {\n\t            labelMove: false\n\t        },\n\n\t        // When set to true the links can be pinned to the paper.\n\t        // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\n\t        linkPinning: true,\n\n\t        // Custom validation after an interaction with a link ends.\n\t        // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)\n\t        // (linkView, paper) => boolean\n\t        allowLink: null,\n\n\t        // Allowed number of mousemove events after which the pointerclick event will be still triggered.\n\t        clickThreshold: 0,\n\n\t        // Number of required mousemove events before the first pointermove event will be triggered.\n\t        moveThreshold: 0,\n\n\t        // Number of required mousemove events before a link is created out of the magnet.\n\t        // Or string `onleave` so the link is created when the pointer leaves the magnet\n\t        magnetThreshold: 0,\n\n\t        // Rendering Options\n\n\t        sorting: sortingTypes.EXACT,\n\n\t        frozen: false,\n\n\t        autoFreeze: false,\n\n\t        // no docs yet\n\t        onViewUpdate: function(view, flag, priority, opt, paper) {\n\t            // Do not update connected links when:\n\t            // 1. the view was just inserted (added to the graph and rendered)\n\t            // 2. the view was just mounted (added back to the paper by viewport function)\n\t            // 3. the change was marked as `isolate`.\n\t            // 4. the view model was just removed from the graph\n\t            if ((flag & (view.FLAG_INSERT | view.FLAG_REMOVE)) || opt.mounting || opt.isolate) { return; }\n\t            paper.requestConnectedLinksUpdate(view, priority, opt);\n\t        },\n\n\t        // no docs yet\n\t        onViewPostponed: function(view, flag, paper) {\n\t            return paper.forcePostponedViewUpdate(view, flag);\n\t        },\n\n\t        beforeRender: null, // function(opt, paper) { },\n\n\t        afterRender: null, // function(stats, opt, paper) {\n\n\t        viewport: null,\n\n\t        // Default namespaces\n\n\t        cellViewNamespace: null,\n\n\t        routerNamespace: null,\n\n\t        connectorNamespace: null,\n\n\t        highlighterNamespace: highlighters,\n\n\t        anchorNamespace: anchors,\n\n\t        linkAnchorNamespace: linkAnchors,\n\n\t        connectionPointNamespace: connectionPoints,\n\n\t        overflow: false\n\t    },\n\n\t    events: {\n\t        'dblclick': 'pointerdblclick',\n\t        'dbltap': 'pointerdblclick',\n\t        'contextmenu': 'contextmenu',\n\t        'mousedown': 'pointerdown',\n\t        'touchstart': 'pointerdown',\n\t        'mouseover': 'mouseover',\n\t        'mouseout': 'mouseout',\n\t        'mouseenter': 'mouseenter',\n\t        'mouseleave': 'mouseleave',\n\t        'wheel': 'mousewheel',\n\t        'mouseenter .joint-cell': 'mouseenter',\n\t        'mouseleave .joint-cell': 'mouseleave',\n\t        'mouseenter .joint-tools': 'mouseenter',\n\t        'mouseleave .joint-tools': 'mouseleave',\n\t        'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',\n\t        'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',\n\t        'mousedown .joint-link .label': 'onlabel', // interaction with link label\n\t        'touchstart .joint-link .label': 'onlabel',\n\t        'dragstart .joint-cell image': 'onImageDragStart' // firefox fix\n\t    },\n\n\t    documentEvents: {\n\t        'mousemove': 'pointermove',\n\t        'touchmove': 'pointermove',\n\t        'mouseup': 'pointerup',\n\t        'touchend': 'pointerup',\n\t        'touchcancel': 'pointerup'\n\t    },\n\n\t    svg: null,\n\t    viewport: null,\n\t    defs: null,\n\t    tools: null,\n\t    $background: null,\n\t    layers: null,\n\t    $grid: null,\n\t    $document: null,\n\n\t    // For storing the current transformation matrix (CTM) of the paper's viewport.\n\t    _viewportMatrix: null,\n\t    // For verifying whether the CTM is up-to-date. The viewport transform attribute\n\t    // could have been manipulated directly.\n\t    _viewportTransformString: null,\n\t    // Updates data (priorities, unmounted views etc.)\n\t    _updates: null,\n\t    // Paper Layers\n\t    _layers: null,\n\n\t    SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],\n\t    UPDATE_DELAYING_BATCHES: ['translate'],\n\t    // If you interact with these elements,\n\t    // the default interaction such as `element move` is prevented.\n\t    FORM_CONTROL_TAG_NAMES: ['TEXTAREA', 'INPUT', 'BUTTON', 'SELECT', 'OPTION'] ,\n\t    // If you interact with these elements, the events are not propagated to the paper\n\t    // i.e. paper events such as `element:pointerdown` are not triggered.\n\t    GUARDED_TAG_NAMES: [\n\t        // Guard <select> for consistency. When you click on it:\n\t        // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open\n\t        // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).\n\t        //          on close. However, if you open and then close by clicking elsewhere on the page,\n\t        //           no other event is triggered.\n\t        // Safari: when you open it, it triggers `pointerdown`. That's it.\n\t        'SELECT' ],\n\t    MIN_SCALE: 1e-6,\n\n\t    init: function() {\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var el = ref.el;\n\t        if (!options.cellViewNamespace) {\n\t            /* eslint-disable no-undef */\n\t            options.cellViewNamespace = typeof joint !== 'undefined' && has$2(joint, 'shapes') ? joint.shapes : null;\n\t            /* eslint-enable no-undef */\n\t        }\n\n\t        var model = this.model = options.model || new Graph;\n\n\t        // Layers (SVGGroups)\n\t        this._layers = {};\n\n\t        this.setGrid(options.drawGrid);\n\t        this.cloneOptions();\n\t        this.render();\n\t        this._setDimensions();\n\t        this.startListening();\n\n\t        // Hash of all cell views.\n\t        this._views = {};\n\n\t        // Mouse wheel events buffer\n\t        this._mw_evt_buffer = {\n\t            event: null,\n\t            deltas: [],\n\t        };\n\n\t        // Reference to the paper owner document\n\t        this.$document = $(el.ownerDocument);\n\t        // Render existing cells in the graph\n\t        this.resetViews(model.attributes.cells.models);\n\t        // Start the Rendering Loop\n\t        if (!this.isFrozen() && this.isAsync()) { this.updateViewsAsync(); }\n\t    },\n\n\t    _resetUpdates: function() {\n\t        return this._updates = {\n\t            id: null,\n\t            priorities: [{}, {}, {}],\n\t            unmountedCids: [],\n\t            mountedCids: [],\n\t            unmounted: {},\n\t            mounted: {},\n\t            count: 0,\n\t            keyFrozen: false,\n\t            freezeKey: null,\n\t            sort: false,\n\t            disabled: false,\n\t            idle: false\n\t        };\n\t    },\n\n\t    startListening: function() {\n\t        var model = this.model;\n\t        this.listenTo(model, 'add', this.onCellAdded)\n\t            .listenTo(model, 'remove', this.onCellRemoved)\n\t            .listenTo(model, 'change', this.onCellChange)\n\t            .listenTo(model, 'reset', this.onGraphReset)\n\t            .listenTo(model, 'sort', this.onGraphSort)\n\t            .listenTo(model, 'batch:stop', this.onGraphBatchStop);\n\t        this.on('cell:highlight', this.onCellHighlight)\n\t            .on('cell:unhighlight', this.onCellUnhighlight)\n\t            .on('scale translate', this.update);\n\t    },\n\n\t    onCellAdded: function(cell, _, opt) {\n\t        var position = opt.position;\n\t        if (this.isAsync() || !isNumber(position)) {\n\t            this.renderView(cell, opt);\n\t        } else {\n\t            if (opt.maxPosition === position) { this.freeze({ key: 'addCells' }); }\n\t            this.renderView(cell, opt);\n\t            if (position === 0) { this.unfreeze({ key: 'addCells' }); }\n\t        }\n\t    },\n\n\t    onCellRemoved: function(cell, _, opt) {\n\t        var view = this.findViewByModel(cell);\n\t        if (view) { this.requestViewUpdate(view, view.FLAG_REMOVE, view.UPDATE_PRIORITY, opt); }\n\t    },\n\n\t    onCellChange: function(cell, opt) {\n\t        if (cell === this.model.attributes.cells) { return; }\n\t        if (cell.hasChanged('z') && this.options.sorting === sortingTypes.APPROX) {\n\t            var view = this.findViewByModel(cell);\n\t            if (view) { this.requestViewUpdate(view, view.FLAG_INSERT, view.UPDATE_PRIORITY, opt); }\n\t        }\n\t    },\n\n\t    onGraphReset: function(collection, opt) {\n\t        this.resetLayers();\n\t        this.resetViews(collection.models, opt);\n\t    },\n\n\t    onGraphSort: function() {\n\t        if (this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES)) { return; }\n\t        this.sortViews();\n\t    },\n\n\t    onGraphBatchStop: function(data) {\n\t        if (this.isFrozen()) { return; }\n\t        var name = data && data.batchName;\n\t        var graph = this.model;\n\t        if (!this.isAsync()) {\n\t            var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;\n\t            if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {\n\t                this.updateViews(data);\n\t            }\n\t        }\n\t        var sortDelayingBatches = this.SORT_DELAYING_BATCHES;\n\t        if (sortDelayingBatches.includes(name) && !graph.hasActiveBatch(sortDelayingBatches)) {\n\t            this.sortViews();\n\t        }\n\t    },\n\n\t    cloneOptions: function() {\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var defaultConnector = options.defaultConnector;\n\t        var defaultRouter = options.defaultRouter;\n\t        var defaultConnectionPoint = options.defaultConnectionPoint;\n\t        var defaultAnchor = options.defaultAnchor;\n\t        var defaultLinkAnchor = options.defaultLinkAnchor;\n\t        var origin = options.origin;\n\t        var highlighting = options.highlighting;\n\t        var cellViewNamespace = options.cellViewNamespace;\n\t        var interactive = options.interactive;\n\n\t        // Default cellView namespace for ES5\n\t        /* eslint-disable no-undef */\n\t        if (!cellViewNamespace && typeof joint !== 'undefined' && has$2(joint, 'shapes')) {\n\t            options.cellViewNamespace = joint.shapes;\n\t        }\n\t        /* eslint-enable no-undef */\n\n\t        // Here if a function was provided, we can not clone it, as this would result in loosing the function.\n\t        // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.\n\t        if (!isFunction(defaultConnector)) {\n\t            options.defaultConnector = cloneDeep(defaultConnector);\n\t        }\n\t        if (!isFunction(defaultRouter)) {\n\t            options.defaultRouter = cloneDeep(defaultRouter);\n\t        }\n\t        if (!isFunction(defaultConnectionPoint)) {\n\t            options.defaultConnectionPoint = cloneDeep(defaultConnectionPoint);\n\t        }\n\t        if (!isFunction(defaultAnchor)) {\n\t            options.defaultAnchor = cloneDeep(defaultAnchor);\n\t        }\n\t        if (!isFunction(defaultLinkAnchor)) {\n\t            options.defaultLinkAnchor = cloneDeep(defaultLinkAnchor);\n\t        }\n\t        if (isPlainObject(interactive)) {\n\t            options.interactive = assign({}, interactive);\n\t        }\n\t        if (isPlainObject(highlighting)) {\n\t            // Return the default highlighting options into the user specified options.\n\t            options.highlighting = defaultsDeep({}, highlighting, defaultHighlighting);\n\t        }\n\t        options.origin = assign({}, origin);\n\t    },\n\n\t    children: function() {\n\t        var ns = V.namespace;\n\t        return [{\n\t            namespaceURI: ns.xhtml,\n\t            tagName: 'div',\n\t            className: addClassNamePrefix('paper-background'),\n\t            selector: 'background'\n\t        }, {\n\t            namespaceURI: ns.xhtml,\n\t            tagName: 'div',\n\t            className: addClassNamePrefix('paper-grid'),\n\t            selector: 'grid'\n\t        }, {\n\t            namespaceURI: ns.svg,\n\t            tagName: 'svg',\n\t            attributes: {\n\t                'width': '100%',\n\t                'height': '100%',\n\t                'xmlns:xlink': ns.xlink\n\t            },\n\t            selector: 'svg',\n\t            children: [{\n\t                // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\n\t                // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).\n\t                tagName: 'defs',\n\t                selector: 'defs'\n\t            }, {\n\t                tagName: 'g',\n\t                className: addClassNamePrefix('layers'),\n\t                selector: 'layers'\n\t            }]\n\t        }];\n\t    },\n\n\t    hasLayerView: function hasLayerView(layerName) {\n\t        return  (layerName in this._layers);\n\t    },\n\n\t    getLayerView: function getLayerView(layerName) {\n\t        var ref = this;\n\t        var _layers = ref._layers;\n\t        if (layerName in _layers) { return _layers[layerName]; }\n\t        throw new Error((\"dia.Paper: Unknown layer \\\"\" + layerName + \"\\\"\"));\n\t    },\n\n\t    getLayerNode: function getLayerNode(layerName) {\n\t        return this.getLayerView(layerName).el;\n\t    },\n\n\t    render: function() {\n\n\t        this.renderChildren();\n\t        var ref = this;\n\t        var childNodes = ref.childNodes;\n\t        var options = ref.options;\n\t        var svg = childNodes.svg;\n\t        var defs = childNodes.defs;\n\t        var layers = childNodes.layers;\n\t        var background = childNodes.background;\n\t        var grid = childNodes.grid;\n\n\t        svg.style.overflow = options.overflow ? 'visible' : 'hidden';\n\n\t        this.svg = svg;\n\t        this.defs = defs;\n\t        this.layers = layers;\n\t        this.$background = $(background);\n\t        this.$grid = $(grid);\n\n\t        this.renderLayers();\n\n\t        V.ensureId(svg);\n\n\t        if (options.background) {\n\t            this.drawBackground(options.background);\n\t        }\n\n\t        if (options.drawGrid) {\n\t            this.drawGrid();\n\t        }\n\n\t        return this;\n\t    },\n\n\t    renderLayers: function(layers) {\n\t        var this$1 = this;\n\t        if ( layers === void 0 ) layers = defaultLayers;\n\n\t        this.removeLayers();\n\t        // TODO: Layers to be read from the graph `layers` attribute\n\t        layers.forEach(function (ref) {\n\t            var name = ref.name;\n\t            var sorted = ref.sorted;\n\n\t            var layerView = new PaperLayer({ name: name });\n\t            this$1.layers.appendChild(layerView.el);\n\t            this$1._layers[name] = layerView;\n\t        });\n\t        // Throws an exception if doesn't exist\n\t        var cellsLayerView = this.getLayerView(LayersNames.CELLS);\n\t        var toolsLayerView = this.getLayerView(LayersNames.TOOLS);\n\t        var labelsLayerView = this.getLayerView(LayersNames.LABELS);\n\t        // backwards compatibility\n\t        this.tools = toolsLayerView.el;\n\t        this.cells = this.viewport = cellsLayerView.el;\n\t        // user-select: none;\n\t        cellsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n\t        labelsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n\t    },\n\n\t    removeLayers: function() {\n\t        var ref = this;\n\t        var _layers = ref._layers;\n\t        Object.keys(_layers).forEach(function (name) {\n\t            _layers[name].remove();\n\t            delete _layers[name];\n\t        });\n\t    },\n\n\t    resetLayers: function() {\n\t        var ref = this;\n\t        var _layers = ref._layers;\n\t        Object.keys(_layers).forEach(function (name) {\n\t            _layers[name].removePivots();\n\t        });\n\t    },\n\n\t    update: function() {\n\n\t        if (this.options.drawGrid) {\n\t            this.drawGrid();\n\t        }\n\n\t        if (this._background) {\n\t            this.updateBackgroundImage(this._background);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    matrix: function(ctm) {\n\n\t        var viewport = this.layers;\n\n\t        // Getter:\n\t        if (ctm === undefined) {\n\n\t            var transformString = viewport.getAttribute('transform');\n\n\t            if ((this._viewportTransformString || null) === transformString) {\n\t                // It's ok to return the cached matrix. The transform attribute has not changed since\n\t                // the matrix was stored.\n\t                ctm = this._viewportMatrix;\n\t            } else {\n\t                // The viewport transform attribute has changed. Measure the matrix and cache again.\n\t                ctm = viewport.getCTM();\n\t                this._viewportMatrix = ctm;\n\t                this._viewportTransformString = transformString;\n\t            }\n\n\t            // Clone the cached current transformation matrix.\n\t            // If no matrix previously stored the identity matrix is returned.\n\t            return V.createSVGMatrix(ctm);\n\t        }\n\n\t        // Setter:\n\t        ctm = V.createSVGMatrix(ctm);\n\t        var ctmString = V.matrixToTransformString(ctm);\n\t        viewport.setAttribute('transform', ctmString);\n\n\t        this._viewportMatrix = ctm;\n\t        this._viewportTransformString = viewport.getAttribute('transform');\n\n\t        return this;\n\t    },\n\n\t    clientMatrix: function() {\n\n\t        return V.createSVGMatrix(this.cells.getScreenCTM());\n\t    },\n\n\t    requestConnectedLinksUpdate: function(view, priority, opt) {\n\t        if (view instanceof CellView) {\n\t            var model = view.model;\n\t            var links = this.model.getConnectedLinks(model);\n\t            for (var j = 0, n = links.length; j < n; j++) {\n\t                var link = links[j];\n\t                var linkView = this.findViewByModel(link);\n\t                if (!linkView) { continue; }\n\t                var flagLabels = ['UPDATE'];\n\t                if (link.getTargetCell() === model) { flagLabels.push('TARGET'); }\n\t                if (link.getSourceCell() === model) { flagLabels.push('SOURCE'); }\n\t                var nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);\n\t                this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);\n\t            }\n\t        }\n\t    },\n\n\t    forcePostponedViewUpdate: function(view, flag) {\n\t        if (!view || !(view instanceof CellView)) { return false; }\n\t        var model = view.model;\n\t        if (model.isElement()) { return false; }\n\t        if ((flag & view.getFlag(['SOURCE', 'TARGET'])) === 0) {\n\t            var dumpOptions = { silent: true };\n\t            // LinkView is waiting for the target or the source cellView to be rendered\n\t            // This can happen when the cells are not in the viewport.\n\t            var sourceFlag = 0;\n\t            var sourceView = this.findViewByModel(model.getSourceCell());\n\t            if (sourceView && !this.isViewMounted(sourceView)) {\n\t                sourceFlag = this.dumpView(sourceView, dumpOptions);\n\t                view.updateEndMagnet('source');\n\t            }\n\t            var targetFlag = 0;\n\t            var targetView = this.findViewByModel(model.getTargetCell());\n\t            if (targetView && !this.isViewMounted(targetView)) {\n\t                targetFlag = this.dumpView(targetView, dumpOptions);\n\t                view.updateEndMagnet('target');\n\t            }\n\t            if (sourceFlag === 0 && targetFlag === 0) {\n\t                // If leftover flag is 0, all view updates were done.\n\t                return !this.dumpView(view, dumpOptions);\n\t            }\n\t        }\n\t        return false;\n\t    },\n\n\t    requestViewUpdate: function(view, flag, priority, opt) {\n\t        opt || (opt = {});\n\t        this.scheduleViewUpdate(view, flag, priority, opt);\n\t        var isAsync = this.isAsync();\n\t        if (this.isFrozen() || (isAsync && opt.async !== false)) { return; }\n\t        if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) { return; }\n\t        var stats = this.updateViews(opt);\n\t        if (isAsync) { this.notifyAfterRender(stats, opt); }\n\t    },\n\n\t    scheduleViewUpdate: function(view, type, priority, opt) {\n\t        var ref = this;\n\t        var updates = ref._updates;\n\t        var options = ref.options;\n\t        if (updates.idle) {\n\t            if (options.autoFreeze) {\n\t                updates.idle = false;\n\t                this.unfreeze();\n\t            }\n\t        }\n\t        var FLAG_REMOVE = view.FLAG_REMOVE;\n\t        var FLAG_INSERT = view.FLAG_INSERT;\n\t        var UPDATE_PRIORITY = view.UPDATE_PRIORITY;\n\t        var cid = view.cid;\n\t        var priorityUpdates = updates.priorities[priority];\n\t        if (!priorityUpdates) { priorityUpdates = updates.priorities[priority] = {}; }\n\t        // Move higher priority updates to this priority\n\t        if (priority > UPDATE_PRIORITY) {\n\t            // Not the default priority for this view. It's most likely a link view\n\t            // connected to another link view, which triggered the update.\n\t            // TODO: If there is an update scheduled with a lower priority already, we should\n\t            // change the requested priority to the lowest one. Does not seem to be critical\n\t            // right now, as it \"only\" results in multiple updates on the same view.\n\t            for (var i = priority - 1; i >= UPDATE_PRIORITY; i--) {\n\t                var prevPriorityUpdates = updates.priorities[i];\n\t                if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) { continue; }\n\t                priorityUpdates[cid] |= prevPriorityUpdates[cid];\n\t                delete prevPriorityUpdates[cid];\n\t            }\n\t        }\n\t        var currentType = priorityUpdates[cid] || 0;\n\t        // Prevent cycling\n\t        if ((currentType & type) === type) { return; }\n\t        if (!currentType) { updates.count++; }\n\t        if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {\n\t            // When a view is removed we need to remove the insert flag as this is a reinsert\n\t            priorityUpdates[cid] ^= FLAG_INSERT;\n\t        } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {\n\t            // When a view is added we need to remove the remove flag as this is view was previously removed\n\t            priorityUpdates[cid] ^= FLAG_REMOVE;\n\t        }\n\t        priorityUpdates[cid] |= type;\n\t        var viewUpdateFn = options.onViewUpdate;\n\t        if (typeof viewUpdateFn === 'function') { viewUpdateFn.call(this, view, type, priority, opt || {}, this); }\n\t    },\n\n\t    dumpViewUpdate: function(view) {\n\t        if (!view) { return 0; }\n\t        var updates = this._updates;\n\t        var cid = view.cid;\n\t        var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];\n\t        var flag = this.registerMountedView(view) | priorityUpdates[cid];\n\t        delete priorityUpdates[cid];\n\t        return flag;\n\t    },\n\n\t    dumpView: function(view, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        var flag = this.dumpViewUpdate(view);\n\t        if (!flag) { return 0; }\n\t        var shouldNotify = !opt.silent;\n\t        if (shouldNotify) { this.notifyBeforeRender(opt); }\n\t        var leftover = this.updateView(view, flag, opt);\n\t        if (shouldNotify) {\n\t            var stats = { updated: 1, priority: view.UPDATE_PRIORITY };\n\t            this.notifyAfterRender(stats, opt);\n\t        }\n\t        return leftover;\n\t    },\n\n\t    updateView: function(view, flag, opt) {\n\t        if (!view) { return 0; }\n\t        var FLAG_REMOVE = view.FLAG_REMOVE;\n\t        var FLAG_INSERT = view.FLAG_INSERT;\n\t        var FLAG_INIT = view.FLAG_INIT;\n\t        var model = view.model;\n\t        if (view instanceof CellView) {\n\t            if (flag & FLAG_REMOVE) {\n\t                this.removeView(model);\n\t                return 0;\n\t            }\n\t            if (flag & FLAG_INSERT) {\n\t                var isInitialInsert = !!(flag & FLAG_INIT);\n\t                if (isInitialInsert) {\n\t                    flag ^= FLAG_INIT;\n\t                }\n\t                this.insertView(view, isInitialInsert);\n\t                flag ^= FLAG_INSERT;\n\t            }\n\t        }\n\t        if (!flag) { return 0; }\n\t        return view.confirmUpdate(flag, opt || {});\n\t    },\n\n\t    requireView: function(model, opt) {\n\t        var view = this.findViewByModel(model);\n\t        if (!view) { return null; }\n\t        this.dumpView(view, opt);\n\t        return view;\n\t    },\n\n\t    registerUnmountedView: function(view) {\n\t        var cid = view.cid;\n\t        var updates = this._updates;\n\t        if (cid in updates.unmounted) { return 0; }\n\t        var flag = updates.unmounted[cid] |= view.FLAG_INSERT;\n\t        updates.unmountedCids.push(cid);\n\t        delete updates.mounted[cid];\n\t        return flag;\n\t    },\n\n\t    registerMountedView: function(view) {\n\t        var cid = view.cid;\n\t        var updates = this._updates;\n\t        if (cid in updates.mounted) { return 0; }\n\t        updates.mounted[cid] = true;\n\t        updates.mountedCids.push(cid);\n\t        var flag = updates.unmounted[cid] || 0;\n\t        delete updates.unmounted[cid];\n\t        return flag;\n\t    },\n\n\t    isViewMounted: function(view) {\n\t        if (!view) { return false; }\n\t        var cid = view.cid;\n\t        var updates = this._updates;\n\t        return (cid in updates.mounted);\n\t    },\n\n\t    dumpViews: function(opt) {\n\t        var passingOpt = defaults({}, opt, { viewport: null });\n\t        this.checkViewport(passingOpt);\n\t        this.updateViews(passingOpt);\n\t    },\n\n\t    // Synchronous views update\n\t    updateViews: function(opt) {\n\t        this.notifyBeforeRender(opt);\n\t        var batchStats;\n\t        var updateCount = 0;\n\t        var batchCount = 0;\n\t        var priority = MIN_PRIORITY;\n\t        do {\n\t            batchCount++;\n\t            batchStats = this.updateViewsBatch(opt);\n\t            updateCount += batchStats.updated;\n\t            priority = Math.min(batchStats.priority, priority);\n\t        } while (!batchStats.empty);\n\t        var stats = { updated: updateCount, batches: batchCount, priority: priority };\n\t        this.notifyAfterRender(stats, opt);\n\t        return stats;\n\t    },\n\n\t    hasScheduledUpdates: function() {\n\t        var priorities = this._updates.priorities;\n\t        var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n\t        var i = priorityIndexes.length;\n\t        while (i > 0 && i--) {\n\t            // a faster way how to check if an object is empty\n\t            for (var _key in priorities[priorityIndexes[i]]) { return true; }\n\t        }\n\t        return false;\n\t    },\n\n\t    updateViewsAsync: function(opt, data) {\n\t        opt || (opt = {});\n\t        data || (data = { processed: 0, priority: MIN_PRIORITY });\n\t        var ref = this;\n\t        var updates = ref._updates;\n\t        var options = ref.options;\n\t        var id = updates.id;\n\t        if (id) {\n\t            cancelFrame(id);\n\t            if (data.processed === 0 && this.hasScheduledUpdates()) {\n\t                this.notifyBeforeRender(opt);\n\t            }\n\t            var stats = this.updateViewsBatch(opt);\n\t            var passingOpt = defaults({}, opt, {\n\t                mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,\n\t                unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted\n\t            });\n\t            var checkStats = this.checkViewport(passingOpt);\n\t            var unmountCount = checkStats.unmounted;\n\t            var mountCount = checkStats.mounted;\n\t            var processed = data.processed;\n\t            var total = updates.count;\n\t            if (stats.updated > 0) {\n\t                // Some updates have been just processed\n\t                processed += stats.updated + stats.unmounted;\n\t                stats.processed = processed;\n\t                data.priority = Math.min(stats.priority, data.priority);\n\t                if (stats.empty && mountCount === 0) {\n\t                    stats.unmounted += unmountCount;\n\t                    stats.mounted += mountCount;\n\t                    stats.priority = data.priority;\n\t                    this.notifyAfterRender(stats, opt);\n\t                    data.processed = 0;\n\t                    data.priority = MIN_PRIORITY;\n\t                    updates.count = 0;\n\t                } else {\n\t                    data.processed = processed;\n\t                }\n\t            } else {\n\t                if (!updates.idle) {\n\t                    if (options.autoFreeze) {\n\t                        this.freeze();\n\t                        updates.idle = true;\n\t                        this.trigger('render:idle', opt);\n\t                    }\n\t                }\n\t            }\n\t            // Progress callback\n\t            var progressFn = opt.progress;\n\t            if (total && typeof progressFn === 'function') {\n\t                progressFn.call(this, stats.empty, processed, total, stats, this);\n\t            }\n\t            // The current frame could have been canceled in a callback\n\t            if (updates.id !== id) { return; }\n\t        }\n\t        if (updates.disabled) {\n\t            throw new Error('dia.Paper: can not unfreeze the paper after it was removed');\n\t        }\n\t        updates.id = nextFrame(this.updateViewsAsync, this, opt, data);\n\t    },\n\n\t    notifyBeforeRender: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        var beforeFn = opt.beforeRender;\n\t        if (typeof beforeFn !== 'function') {\n\t            beforeFn = this.options.beforeRender;\n\t            if (typeof beforeFn !== 'function') { return; }\n\t        }\n\t        beforeFn.call(this, opt, this);\n\t    },\n\n\t    notifyAfterRender: function(stats, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        var afterFn = opt.afterRender;\n\t        if (typeof afterFn !== 'function') {\n\t            afterFn = this.options.afterRender;\n\t        }\n\t        if (typeof afterFn === 'function') {\n\t            afterFn.call(this, stats, opt, this);\n\t        }\n\t        this.trigger('render:done', stats, opt);\n\t    },\n\n\t    updateViewsBatch: function(opt) {\n\t        opt || (opt = {});\n\t        var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;\n\t        var updates = this._updates;\n\t        var updateCount = 0;\n\t        var postponeCount = 0;\n\t        var unmountCount = 0;\n\t        var mountCount = 0;\n\t        var maxPriority = MIN_PRIORITY;\n\t        var empty = true;\n\t        var options = this.options;\n\t        var priorities = updates.priorities;\n\t        var viewportFn = 'viewport' in opt ? opt.viewport : options.viewport;\n\t        if (typeof viewportFn !== 'function') { viewportFn = null; }\n\t        var postponeViewFn = options.onViewPostponed;\n\t        if (typeof postponeViewFn !== 'function') { postponeViewFn = null; }\n\t        var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n\t        main: for (var i = 0, n = priorityIndexes.length; i < n; i++) {\n\t            var priority = +priorityIndexes[i];\n\t            var priorityUpdates = priorities[priority];\n\t            for (var cid in priorityUpdates) {\n\t                if (updateCount >= batchSize) {\n\t                    empty = false;\n\t                    break main;\n\t                }\n\t                var view = views[cid];\n\t                if (!view) {\n\t                    // This should not occur\n\t                    delete priorityUpdates[cid];\n\t                    continue;\n\t                }\n\t                var currentFlag = priorityUpdates[cid];\n\t                if ((currentFlag & view.FLAG_REMOVE) === 0) {\n\t                    // We should never check a view for viewport if we are about to remove the view\n\t                    var isDetached = cid in updates.unmounted;\n\t                    if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, !isDetached, this)) {\n\t                        // Unmount View\n\t                        if (!isDetached) {\n\t                            this.registerUnmountedView(view);\n\t                            this.detachView(view);\n\t                        }\n\t                        updates.unmounted[cid] |= currentFlag;\n\t                        delete priorityUpdates[cid];\n\t                        unmountCount++;\n\t                        continue;\n\t                    }\n\t                    // Mount View\n\t                    if (isDetached) {\n\t                        currentFlag |= view.FLAG_INSERT;\n\t                        mountCount++;\n\t                    }\n\t                    currentFlag |= this.registerMountedView(view);\n\t                }\n\t                var leftoverFlag = this.updateView(view, currentFlag, opt);\n\t                if (leftoverFlag > 0) {\n\t                    // View update has not finished completely\n\t                    priorityUpdates[cid] = leftoverFlag;\n\t                    if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {\n\t                        postponeCount++;\n\t                        empty = false;\n\t                        continue;\n\t                    }\n\t                }\n\t                if (maxPriority > priority) { maxPriority = priority; }\n\t                updateCount++;\n\t                delete priorityUpdates[cid];\n\t            }\n\t        }\n\t        return {\n\t            priority: maxPriority,\n\t            updated: updateCount,\n\t            postponed: postponeCount,\n\t            unmounted: unmountCount,\n\t            mounted: mountCount,\n\t            empty: empty\n\t        };\n\t    },\n\n\t    getUnmountedViews: function() {\n\t        var updates = this._updates;\n\t        var unmountedCids = Object.keys(updates.unmounted);\n\t        var n = unmountedCids.length;\n\t        var unmountedViews = new Array(n);\n\t        for (var i = 0; i < n; i++) {\n\t            unmountedViews[i] = views[unmountedCids[i]];\n\t        }\n\t        return unmountedViews;\n\t    },\n\n\t    getMountedViews: function() {\n\t        var updates = this._updates;\n\t        var mountedCids = Object.keys(updates.mounted);\n\t        var n = mountedCids.length;\n\t        var mountedViews = new Array(n);\n\t        for (var i = 0; i < n; i++) {\n\t            mountedViews[i] = views[mountedCids[i]];\n\t        }\n\t        return mountedViews;\n\t    },\n\n\t    checkUnmountedViews: function(viewportFn, opt) {\n\t        opt || (opt  = {});\n\t        var mountCount = 0;\n\t        if (typeof viewportFn !== 'function') { viewportFn = null; }\n\t        var batchSize = 'mountBatchSize' in opt ? opt.mountBatchSize : Infinity;\n\t        var updates = this._updates;\n\t        var unmountedCids = updates.unmountedCids;\n\t        var unmounted = updates.unmounted;\n\t        for (var i = 0, n = Math.min(unmountedCids.length, batchSize); i < n; i++) {\n\t            var cid = unmountedCids[i];\n\t            if (!(cid in unmounted)) { continue; }\n\t            var view = views[cid];\n\t            if (!view) { continue; }\n\t            if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, false, this)) {\n\t                // Push at the end of all unmounted ids, so this can be check later again\n\t                unmountedCids.push(cid);\n\t                continue;\n\t            }\n\t            mountCount++;\n\t            var flag = this.registerMountedView(view);\n\t            if (flag) { this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, { mounting: true }); }\n\t        }\n\t        // Get rid of views, that have been mounted\n\t        unmountedCids.splice(0, i);\n\t        return mountCount;\n\t    },\n\n\t    checkMountedViews: function(viewportFn, opt) {\n\t        opt || (opt = {});\n\t        var unmountCount = 0;\n\t        if (typeof viewportFn !== 'function') { return unmountCount; }\n\t        var batchSize = 'unmountBatchSize' in opt ? opt.unmountBatchSize : Infinity;\n\t        var updates = this._updates;\n\t        var mountedCids = updates.mountedCids;\n\t        var mounted = updates.mounted;\n\t        for (var i = 0, n = Math.min(mountedCids.length, batchSize); i < n; i++) {\n\t            var cid = mountedCids[i];\n\t            if (!(cid in mounted)) { continue; }\n\t            var view = views[cid];\n\t            if (!view) { continue; }\n\t            if (!view.DETACHABLE || viewportFn.call(this, view, true, this)) {\n\t                // Push at the end of all mounted ids, so this can be check later again\n\t                mountedCids.push(cid);\n\t                continue;\n\t            }\n\t            unmountCount++;\n\t            var flag = this.registerUnmountedView(view);\n\t            if (flag) { this.detachView(view); }\n\t        }\n\t        // Get rid of views, that have been unmounted\n\t        mountedCids.splice(0, i);\n\t        return unmountCount;\n\t    },\n\n\t    checkViewport: function(opt) {\n\t        var passingOpt = defaults({}, opt, {\n\t            mountBatchSize: Infinity,\n\t            unmountBatchSize: Infinity\n\t        });\n\t        var viewportFn = 'viewport' in passingOpt ? passingOpt.viewport : this.options.viewport;\n\t        var unmountedCount = this.checkMountedViews(viewportFn, passingOpt);\n\t        if (unmountedCount > 0) {\n\t            // Do not check views, that have been just unmounted and pushed at the end of the cids array\n\t            var unmountedCids = this._updates.unmountedCids;\n\t            passingOpt.mountBatchSize = Math.min(unmountedCids.length - unmountedCount, passingOpt.mountBatchSize);\n\t        }\n\t        var mountedCount = this.checkUnmountedViews(viewportFn, passingOpt);\n\t        return {\n\t            mounted: mountedCount,\n\t            unmounted: unmountedCount\n\t        };\n\t    },\n\n\t    freeze: function(opt) {\n\t        opt || (opt = {});\n\t        var updates = this._updates;\n\t        var key = opt.key;\n\t        var isFrozen = this.options.frozen;\n\t        var freezeKey = updates.freezeKey;\n\t        if (key && key !== freezeKey)  {\n\t            // key passed, but the paper is already freezed with another key\n\t            if (isFrozen && freezeKey) { return; }\n\t            updates.freezeKey = key;\n\t            updates.keyFrozen = isFrozen;\n\t        }\n\t        this.options.frozen = true;\n\t        var id = updates.id;\n\t        updates.id = null;\n\t        if (this.isAsync() && id) { cancelFrame(id); }\n\t    },\n\n\t    unfreeze: function(opt) {\n\t        opt || (opt = {});\n\t        var updates = this._updates;\n\t        var key = opt.key;\n\t        var freezeKey = updates.freezeKey;\n\t        // key passed, but the paper is already freezed with another key\n\t        if (key && freezeKey && key !== freezeKey) { return; }\n\t        updates.freezeKey = null;\n\t        // key passed, but the paper is already freezed\n\t        if (key && key === freezeKey && updates.keyFrozen) { return; }\n\t        if (this.isAsync()) {\n\t            this.freeze();\n\t            this.updateViewsAsync(opt);\n\t        } else {\n\t            this.updateViews(opt);\n\t        }\n\t        this.options.frozen = updates.keyFrozen = false;\n\t        if (updates.sort) {\n\t            this.sortViews();\n\t            updates.sort = false;\n\t        }\n\t    },\n\n\t    isAsync: function() {\n\t        return !!this.options.async;\n\t    },\n\n\t    isFrozen: function() {\n\t        return !!this.options.frozen;\n\t    },\n\n\t    isExactSorting: function() {\n\t        return this.options.sorting === sortingTypes.EXACT;\n\t    },\n\n\t    onRemove: function() {\n\n\t        this.freeze();\n\t        this._updates.disabled = true;\n\t        //clean up all DOM elements/views to prevent memory leaks\n\t        this.removeLayers();\n\t        this.removeViews();\n\t    },\n\n\t    getComputedSize: function() {\n\n\t        var options = this.options;\n\t        var w = options.width;\n\t        var h = options.height;\n\t        if (!isNumber(w)) { w = this.el.clientWidth; }\n\t        if (!isNumber(h)) { h = this.el.clientHeight; }\n\t        return { width: w, height: h };\n\t    },\n\n\t    setDimensions: function(width, height) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var currentWidth = options.width;\n\t        var currentHeight = options.height;\n\t        var w = (width === undefined) ? currentWidth : width;\n\t        var h = (height === undefined) ? currentHeight : height;\n\t        if (currentWidth === w && currentHeight === h) { return; }\n\t        options.width = w;\n\t        options.height = h;\n\t        this._setDimensions();\n\t        var computedSize = this.getComputedSize();\n\t        this.trigger('resize', computedSize.width, computedSize.height);\n\t    },\n\n\t    _setDimensions: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var w = options.width;\n\t        var h = options.height;\n\t        if (isNumber(w)) { w = Math.round(w); }\n\t        if (isNumber(h)) { h = Math.round(h); }\n\t        this.$el.css({\n\t            width: (w === null) ? '' : w,\n\t            height: (h === null) ? '' : h\n\t        });\n\t    },\n\n\t    setOrigin: function(ox, oy) {\n\t        return this.translate(ox || 0, oy || 0);\n\t    },\n\n\t    // Expand/shrink the paper to fit the content.\n\t    // Alternatively signature function(opt)\n\t    fitToContent: function(gridWidth, gridHeight, padding, opt) {\n\n\t        if (isObject$1(gridWidth)) {\n\t            // first parameter is an option object\n\t            opt = gridWidth;\n\t        } else {\n\t            // Support for a deprecated signature\n\t            opt = assign({ gridWidth: gridWidth, gridHeight: gridHeight, padding: padding }, opt);\n\t        }\n\n\t        var ref = this.getFitToContentArea(opt);\n\t        var x = ref.x;\n\t        var y = ref.y;\n\t        var width = ref.width;\n\t        var height = ref.height;\n\t        var ref$1 = this.scale();\n\t        var sx = ref$1.sx;\n\t        var sy = ref$1.sy;\n\n\t        this.setOrigin(-x * sx, -y * sy);\n\t        this.setDimensions(width * sx, height * sy);\n\n\t        return new Rect(x, y, width, height);\n\t    },\n\n\t    getFitToContentArea: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        // Calculate the paper size to accommodate all the graph's elements.\n\n\t        var gridWidth = opt.gridWidth || 1;\n\t        var gridHeight = opt.gridHeight || 1;\n\t        var padding = normalizeSides(opt.padding || 0);\n\n\t        var minWidth = Math.max(opt.minWidth || 0, gridWidth);\n\t        var minHeight = Math.max(opt.minHeight || 0, gridHeight);\n\t        var maxWidth = opt.maxWidth || Number.MAX_VALUE;\n\t        var maxHeight = opt.maxHeight || Number.MAX_VALUE;\n\t        var newOrigin = opt.allowNewOrigin;\n\n\t        var area = ('contentArea' in opt) ? new Rect(opt.contentArea) : this.getContentArea(opt);\n\t        var ref = this.scale();\n\t        var sx = ref.sx;\n\t        var sy = ref.sy;\n\t        area.x *= sx;\n\t        area.y *= sy;\n\t        area.width *= sx;\n\t        area.height *= sy;\n\n\t        var calcWidth = Math.ceil((area.width + area.x) / gridWidth);\n\t        var calcHeight = Math.ceil((area.height + area.y) / gridHeight);\n\t        if (!opt.allowNegativeBottomRight) {\n\t            calcWidth = Math.max(calcWidth, 1);\n\t            calcHeight = Math.max(calcHeight, 1);\n\t        }\n\t        calcWidth *= gridWidth;\n\t        calcHeight *= gridHeight;\n\n\t        var tx = 0;\n\t        if ((newOrigin === 'negative' && area.x < 0) || (newOrigin === 'positive' && area.x >= 0) || newOrigin === 'any') {\n\t            tx = Math.ceil(-area.x / gridWidth) * gridWidth;\n\t            tx += padding.left;\n\t            calcWidth += tx;\n\t        }\n\n\t        var ty = 0;\n\t        if ((newOrigin === 'negative' && area.y < 0) || (newOrigin === 'positive' && area.y >= 0) || newOrigin === 'any') {\n\t            ty = Math.ceil(-area.y / gridHeight) * gridHeight;\n\t            ty += padding.top;\n\t            calcHeight += ty;\n\t        }\n\n\t        calcWidth += padding.right;\n\t        calcHeight += padding.bottom;\n\n\t        // Make sure the resulting width and height are greater than minimum.\n\t        calcWidth = Math.max(calcWidth, minWidth);\n\t        calcHeight = Math.max(calcHeight, minHeight);\n\n\t        // Make sure the resulting width and height are lesser than maximum.\n\t        calcWidth = Math.min(calcWidth, maxWidth);\n\t        calcHeight = Math.min(calcHeight, maxHeight);\n\n\t        return new Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);\n\t    },\n\n\t    transformToFitContent: function(opt) {\n\t        opt || (opt = {});\n\n\t        var contentBBox, contentLocalOrigin;\n\t        if ('contentArea' in opt) {\n\t            var contentArea = opt.contentArea;\n\t            contentBBox = this.localToPaperRect(contentArea);\n\t            contentLocalOrigin = new Point(contentArea);\n\t        } else {\n\t            contentBBox = this.getContentBBox(opt);\n\t            contentLocalOrigin = this.paperToLocalPoint(contentBBox);\n\t        }\n\n\t        if (!contentBBox.width || !contentBBox.height) { return; }\n\n\t        defaults(opt, {\n\t            padding: 0,\n\t            preserveAspectRatio: true,\n\t            scaleGrid: null,\n\t            minScale: 0,\n\t            maxScale: Number.MAX_VALUE,\n\t            verticalAlign: 'top',\n\t            horizontalAlign: 'left',\n\t            //minScaleX\n\t            //minScaleY\n\t            //maxScaleX\n\t            //maxScaleY\n\t            //fittingBBox\n\t        });\n\n\t        var padding = normalizeSides(opt.padding);\n\n\t        var minScaleX = opt.minScaleX || opt.minScale;\n\t        var maxScaleX = opt.maxScaleX || opt.maxScale;\n\t        var minScaleY = opt.minScaleY || opt.minScale;\n\t        var maxScaleY = opt.maxScaleY || opt.maxScale;\n\n\t        var fittingBBox;\n\t        if (opt.fittingBBox) {\n\t            fittingBBox = opt.fittingBBox;\n\t        } else {\n\t            var currentTranslate = this.translate();\n\t            var computedSize = this.getComputedSize();\n\t            fittingBBox = {\n\t                x: currentTranslate.tx,\n\t                y: currentTranslate.ty,\n\t                width: computedSize.width,\n\t                height: computedSize.height\n\t            };\n\t        }\n\n\t        fittingBBox = new Rect(fittingBBox).moveAndExpand({\n\t            x: padding.left,\n\t            y: padding.top,\n\t            width: -padding.left - padding.right,\n\t            height: -padding.top - padding.bottom\n\t        });\n\n\t        var currentScale = this.scale();\n\n\t        var newSx = fittingBBox.width / contentBBox.width * currentScale.sx;\n\t        var newSy = fittingBBox.height / contentBBox.height * currentScale.sy;\n\n\t        if (opt.preserveAspectRatio) {\n\t            newSx = newSy = Math.min(newSx, newSy);\n\t        }\n\n\t        // snap scale to a grid\n\t        if (opt.scaleGrid) {\n\n\t            var gridSize = opt.scaleGrid;\n\n\t            newSx = gridSize * Math.floor(newSx / gridSize);\n\t            newSy = gridSize * Math.floor(newSy / gridSize);\n\t        }\n\n\t        // scale min/max boundaries\n\t        newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\n\t        newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\n\n\t        var scaleDiff = {\n\t            x: newSx / currentScale.sx,\n\t            y: newSy / currentScale.sy\n\t        };\n\n\t        var origin = this.options.origin;\n\t        var newOx = fittingBBox.x - contentLocalOrigin.x * newSx - origin.x;\n\t        var newOy = fittingBBox.y - contentLocalOrigin.y * newSy - origin.y;\n\n\t        switch (opt.verticalAlign) {\n\t            case 'middle':\n\t                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;\n\t                break;\n\t            case 'bottom':\n\t                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);\n\t                break;\n\t            case 'top':\n\t            default:\n\t                break;\n\t        }\n\n\t        switch (opt.horizontalAlign) {\n\t            case 'middle':\n\t                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;\n\t                break;\n\t            case 'right':\n\t                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);\n\t                break;\n\t            case 'left':\n\t            default:\n\t                break;\n\t        }\n\n\t        this.scale(newSx, newSy);\n\t        this.translate(newOx, newOy);\n\t    },\n\n\t    scaleContentToFit: function(opt) {\n\t        this.transformToFitContent(opt);\n\t    },\n\n\t    // Return the dimensions of the content area in local units (without transformations).\n\t    getContentArea: function(opt) {\n\n\t        if (opt && opt.useModelGeometry) {\n\t            return this.model.getBBox() || new Rect();\n\t        }\n\n\t        return V(this.cells).getBBox();\n\t    },\n\n\t    // Return the dimensions of the content bbox in the paper units (as it appears on screen).\n\t    getContentBBox: function(opt) {\n\n\t        return this.localToPaperRect(this.getContentArea(opt));\n\t    },\n\n\t    // Returns a geometry rectangle representing the entire\n\t    // paper area (coordinates from the left paper border to the right one\n\t    // and the top border to the bottom one).\n\t    getArea: function() {\n\n\t        return this.paperToLocalRect(this.getComputedSize());\n\t    },\n\n\t    getRestrictedArea: function() {\n\t        var args = [], len = arguments.length;\n\t        while ( len-- ) args[ len ] = arguments[ len ];\n\n\n\t        var ref = this.options;\n\t        var restrictTranslate = ref.restrictTranslate;\n\n\t        var restrictedArea;\n\t        if (isFunction(restrictTranslate)) {\n\t            // A method returning a bounding box\n\t            restrictedArea = restrictTranslate.apply(this, args);\n\t        } else if (restrictTranslate === true) {\n\t            // The paper area\n\t            restrictedArea = this.getArea();\n\t        } else if (!restrictTranslate) {\n\t            // falsy value\n\t            restrictedArea = null;\n\t        } else {\n\t            // any other value\n\t            restrictedArea = new Rect(restrictTranslate);\n\t        }\n\n\t        return restrictedArea;\n\t    },\n\n\t    createViewForModel: function(cell) {\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        // A class taken from the paper options.\n\t        var optionalViewClass;\n\n\t        // A default basic class (either dia.ElementView or dia.LinkView)\n\t        var defaultViewClass;\n\n\t        // A special class defined for this model in the corresponding namespace.\n\t        // e.g. joint.shapes.basic.Rect searches for joint.shapes.basic.RectView\n\t        var namespace = options.cellViewNamespace;\n\t        var type = cell.get('type') + 'View';\n\t        var namespaceViewClass = getByPath(namespace, type, '.');\n\n\t        if (cell.isLink()) {\n\t            optionalViewClass = options.linkView;\n\t            defaultViewClass = LinkView;\n\t        } else {\n\t            optionalViewClass = options.elementView;\n\t            defaultViewClass = ElementView;\n\t        }\n\n\t        // a) the paper options view is a class (deprecated)\n\t        //  1. search the namespace for a view\n\t        //  2. if no view was found, use view from the paper options\n\t        // b) the paper options view is a function\n\t        //  1. call the function from the paper options\n\t        //  2. if no view was return, search the namespace for a view\n\t        //  3. if no view was found, use the default\n\t        var ViewClass = (optionalViewClass.prototype instanceof Backbone.View)\n\t            ? namespaceViewClass || optionalViewClass\n\t            : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\n\n\t        return new ViewClass({\n\t            model: cell,\n\t            interactive: options.interactive,\n\t            labelsLayer: options.labelsLayer === true ? LayersNames.LABELS : options.labelsLayer\n\t        });\n\t    },\n\n\t    removeView: function(cell) {\n\n\t        var id = cell.id;\n\t        var ref = this;\n\t        var _views = ref._views;\n\t        var _updates = ref._updates;\n\t        var view = _views[id];\n\t        if (view) {\n\t            var cid = view.cid;\n\t            var mounted = _updates.mounted;\n\t            var unmounted = _updates.unmounted;\n\t            view.remove();\n\t            delete _views[id];\n\t            delete mounted[cid];\n\t            delete unmounted[cid];\n\t        }\n\t        return view;\n\t    },\n\n\t    renderView: function(cell, opt) {\n\n\t        var id = cell.id;\n\t        var views = this._views;\n\t        var view, flag;\n\t        var create = true;\n\t        if (id in views) {\n\t            view = views[id];\n\t            if (view.model === cell) {\n\t                flag = view.FLAG_INSERT;\n\t                create = false;\n\t            } else {\n\t                // The view for this `id` already exist.\n\t                // The cell is a new instance of the model with identical id\n\t                // We simply remove the existing view and create a new one\n\t                this.removeView(cell);\n\t            }\n\t        }\n\t        if (create) {\n\t            view = views[id] = this.createViewForModel(cell);\n\t            view.paper = this;\n\t            flag = this.registerUnmountedView(view) | this.FLAG_INIT | view.getFlag(result(view, 'initFlag'));\n\t        }\n\t        this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);\n\t        return view;\n\t    },\n\n\t    onImageDragStart: function() {\n\t        // This is the only way to prevent image dragging in Firefox that works.\n\t        // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\n\n\t        return false;\n\t    },\n\n\t    resetViews: function(cells, opt) {\n\t        opt || (opt = {});\n\t        cells || (cells = []);\n\t        this._resetUpdates();\n\t        // clearing views removes any event listeners\n\t        this.removeViews();\n\t        // Allows to unfreeze normally while in the idle state using autoFreeze option\n\t        var key = this.options.autoFreeze ? null : 'reset';\n\t        this.freeze({ key: key });\n\t        for (var i = 0, n = cells.length; i < n; i++) {\n\t            this.renderView(cells[i], opt);\n\t        }\n\t        this.unfreeze({ key: key });\n\t        this.sortViews();\n\t    },\n\n\t    removeViews: function() {\n\n\t        invoke(this._views, 'remove');\n\n\t        this._views = {};\n\t    },\n\n\t    sortViews: function() {\n\n\t        if (!this.isExactSorting()) {\n\t            // noop\n\t            return;\n\t        }\n\t        if (this.isFrozen()) {\n\t            // sort views once unfrozen\n\t            this._updates.sort = true;\n\t            return;\n\t        }\n\t        this.sortViewsExact();\n\t    },\n\n\t    sortViewsExact: function() {\n\n\t        // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\n\t        // associated model `z` attribute.\n\n\t        var $cells = $(this.cells).children('[model-id]');\n\t        var cells = this.model.get('cells');\n\n\t        sortElements($cells, function(a, b) {\n\t            var cellA = cells.get(a.getAttribute('model-id'));\n\t            var cellB = cells.get(b.getAttribute('model-id'));\n\t            var zA = cellA.attributes.z || 0;\n\t            var zB = cellB.attributes.z || 0;\n\t            return (zA === zB) ? 0 : (zA < zB) ? -1 : 1;\n\t        });\n\t    },\n\n\t    insertView: function(view, isInitialInsert) {\n\t        var layerView = this.getLayerView(LayersNames.CELLS);\n\t        var el = view.el;\n\t        var model = view.model;\n\t        switch (this.options.sorting) {\n\t            case sortingTypes.APPROX:\n\t                layerView.insertSortedNode(el, model.get('z'));\n\t                break;\n\t            case sortingTypes.EXACT:\n\t            default:\n\t                layerView.insertNode(el);\n\t                break;\n\t        }\n\t        view.onMount(isInitialInsert);\n\t    },\n\n\t    detachView: function detachView(view) {\n\t        view.unmount();\n\t        view.onDetach();\n\t    },\n\n\t    scale: function(sx, sy, ox, oy) {\n\n\t        // getter\n\t        if (sx === undefined) {\n\t            return V.matrixToScale(this.matrix());\n\t        }\n\n\t        // setter\n\t        if (sy === undefined) {\n\t            sy = sx;\n\t        }\n\t        if (ox === undefined) {\n\t            ox = 0;\n\t            oy = 0;\n\t        }\n\n\t        var translate = this.translate();\n\n\t        if (ox || oy || translate.tx || translate.ty) {\n\t            var newTx = translate.tx - ox * (sx - 1);\n\t            var newTy = translate.ty - oy * (sy - 1);\n\t            this.translate(newTx, newTy);\n\t        }\n\n\t        sx = Math.max(sx || 0, this.MIN_SCALE);\n\t        sy = Math.max(sy || 0, this.MIN_SCALE);\n\n\t        var ctm = this.matrix();\n\t        ctm.a = sx;\n\t        ctm.d = sy;\n\n\t        this.matrix(ctm);\n\n\t        this.trigger('scale', sx, sy, ox, oy);\n\n\t        return this;\n\t    },\n\n\t    // Experimental - do not use in production.\n\t    rotate: function(angle, cx, cy) {\n\n\t        // getter\n\t        if (angle === undefined) {\n\t            return V.matrixToRotate(this.matrix());\n\t        }\n\n\t        // setter\n\n\t        // If the origin is not set explicitely, rotate around the center. Note that\n\t        // we must use the plain bounding box (`this.el.getBBox()` instead of the one that gives us\n\t        // the real bounding box (`bbox()`) including transformations).\n\t        if (cx === undefined) {\n\t            var bbox = this.cells.getBBox();\n\t            cx = bbox.width / 2;\n\t            cy = bbox.height / 2;\n\t        }\n\n\t        var ctm = this.matrix().translate(cx, cy).rotate(angle).translate(-cx, -cy);\n\t        this.matrix(ctm);\n\n\t        return this;\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        // getter\n\t        if (tx === undefined) {\n\t            return V.matrixToTranslate(this.matrix());\n\t        }\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var origin = options.origin;\n\t        var drawGrid = options.drawGrid;\n\n\t        // setter\n\t        tx || (tx = 0);\n\t        ty || (ty = 0);\n\n\t        var ctm = this.matrix();\n\t        if (ctm.e === tx && ctm.f === ty) { return this; }\n\t        ctm.e = tx;\n\t        ctm.f = ty;\n\n\t        this.matrix(ctm);\n\n\t        var ref$1 = this.translate();\n\t        var ox = ref$1.tx;\n\t        var oy = ref$1.ty;\n\t        origin.x = ox;\n\t        origin.y = oy;\n\n\t        this.trigger('translate', ox, oy);\n\n\t        if (drawGrid) {\n\t            this.drawGrid();\n\t        }\n\n\t        return this;\n\t    },\n\n\t    // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\n\t    // be a selector or a jQuery object.\n\t    findView: function($el) {\n\n\t        var el = isString($el)\n\t            ? this.cells.querySelector($el)\n\t            : $el instanceof $ ? $el[0] : $el;\n\n\t        var id = this.findAttribute('model-id', el);\n\t        if (id) { return this._views[id]; }\n\n\t        return undefined;\n\t    },\n\n\t    // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.\n\t    findViewByModel: function(cell) {\n\n\t        var id = (isString(cell) || isNumber(cell)) ? cell : (cell && cell.id);\n\n\t        return this._views[id];\n\t    },\n\n\t    // Find all views at given point\n\t    findViewsFromPoint: function(p) {\n\n\t        p = new Point(p);\n\n\t        var views = this.model.getElements().map(this.findViewByModel, this);\n\n\t        return views.filter(function(view) {\n\t            return view && view.vel.getBBox({ target: this.cells }).containsPoint(p);\n\t        }, this);\n\t    },\n\n\t    // Find all views in given area\n\t    findViewsInArea: function(rect, opt) {\n\n\t        opt = defaults(opt || {}, { strict: false });\n\t        rect = new Rect(rect);\n\n\t        var views = this.model.getElements().map(this.findViewByModel, this);\n\t        var method = opt.strict ? 'containsRect' : 'intersect';\n\n\t        return views.filter(function(view) {\n\t            return view && rect[method](view.vel.getBBox({ target: this.cells }));\n\t        }, this);\n\t    },\n\n\t    removeTools: function() {\n\t        this.dispatchToolsEvent('remove');\n\t        return this;\n\t    },\n\n\t    hideTools: function() {\n\t        this.dispatchToolsEvent('hide');\n\t        return this;\n\t    },\n\n\t    showTools: function() {\n\t        this.dispatchToolsEvent('show');\n\t        return this;\n\t    },\n\n\t    dispatchToolsEvent: function(event) {\n\t        var ref;\n\n\t        var args = [], len = arguments.length - 1;\n\t        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\t        if (typeof event !== 'string') { return; }\n\t        (ref = this).trigger.apply(ref, [ 'tools:event', event ].concat( args ));\n\t    },\n\n\n\t    getModelById: function(id) {\n\n\t        return this.model.getCell(id);\n\t    },\n\n\t    snapToGrid: function(x, y) {\n\n\t        // Convert global coordinates to the local ones of the `viewport`. Otherwise,\n\t        // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\n\t        return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\n\t    },\n\n\t    localToPaperPoint: function(x, y) {\n\t        // allow `x` to be a point and `y` undefined\n\t        var localPoint = new Point(x, y);\n\t        var paperPoint = V.transformPoint(localPoint, this.matrix());\n\t        return paperPoint;\n\t    },\n\n\t    localToPaperRect: function(x, y, width, height) {\n\t        // allow `x` to be a rectangle and rest arguments undefined\n\t        var localRect = new Rect(x, y, width, height);\n\t        var paperRect = V.transformRect(localRect, this.matrix());\n\t        return paperRect;\n\t    },\n\n\t    paperToLocalPoint: function(x, y) {\n\t        // allow `x` to be a point and `y` undefined\n\t        var paperPoint = new Point(x, y);\n\t        var localPoint = V.transformPoint(paperPoint, this.matrix().inverse());\n\t        return localPoint;\n\t    },\n\n\t    paperToLocalRect: function(x, y, width, height) {\n\t        // allow `x` to be a rectangle and rest arguments undefined\n\t        var paperRect = new Rect(x, y, width, height);\n\t        var localRect = V.transformRect(paperRect, this.matrix().inverse());\n\t        return localRect;\n\t    },\n\n\t    localToClientPoint: function(x, y) {\n\t        // allow `x` to be a point and `y` undefined\n\t        var localPoint = new Point(x, y);\n\t        var clientPoint = V.transformPoint(localPoint, this.clientMatrix());\n\t        return clientPoint;\n\t    },\n\n\t    localToClientRect: function(x, y, width, height) {\n\t        // allow `x` to be a point and `y` undefined\n\t        var localRect = new Rect(x, y, width, height);\n\t        var clientRect = V.transformRect(localRect, this.clientMatrix());\n\t        return clientRect;\n\t    },\n\n\t    // Transform client coordinates to the paper local coordinates.\n\t    // Useful when you have a mouse event object and you'd like to get coordinates\n\t    // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\n\t    // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\n\t    clientToLocalPoint: function(x, y) {\n\t        // allow `x` to be a point and `y` undefined\n\t        var clientPoint = new Point(x, y);\n\t        var localPoint = V.transformPoint(clientPoint, this.clientMatrix().inverse());\n\t        return localPoint;\n\t    },\n\n\t    clientToLocalRect: function(x, y, width, height) {\n\t        // allow `x` to be a point and `y` undefined\n\t        var clientRect = new Rect(x, y, width, height);\n\t        var localRect = V.transformRect(clientRect, this.clientMatrix().inverse());\n\t        return localRect;\n\t    },\n\n\t    localToPagePoint: function(x, y) {\n\n\t        return this.localToPaperPoint(x, y).offset(this.pageOffset());\n\t    },\n\n\t    localToPageRect: function(x, y, width, height) {\n\n\t        return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());\n\t    },\n\n\t    pageToLocalPoint: function(x, y) {\n\n\t        var pagePoint = new Point(x, y);\n\t        var paperPoint = pagePoint.difference(this.pageOffset());\n\t        return this.paperToLocalPoint(paperPoint);\n\t    },\n\n\t    pageToLocalRect: function(x, y, width, height) {\n\n\t        var pageOffset = this.pageOffset();\n\t        var paperRect = new Rect(x, y, width, height);\n\t        paperRect.x -= pageOffset.x;\n\t        paperRect.y -= pageOffset.y;\n\t        return this.paperToLocalRect(paperRect);\n\t    },\n\n\t    clientOffset: function() {\n\n\t        var clientRect = this.svg.getBoundingClientRect();\n\t        return new Point(clientRect.left, clientRect.top);\n\t    },\n\n\t    pageOffset: function() {\n\n\t        return this.clientOffset().offset(window.scrollX, window.scrollY);\n\t    },\n\n\t    linkAllowed: function(linkView) {\n\n\t        if (!(linkView instanceof LinkView)) {\n\t            throw new Error('Must provide a linkView.');\n\t        }\n\n\t        var link = linkView.model;\n\t        var paperOptions = this.options;\n\t        var graph = this.model;\n\t        var ns = graph.constructor.validations;\n\n\t        if (!paperOptions.multiLinks) {\n\t            if (!ns.multiLinks.call(this, graph, link)) { return false; }\n\t        }\n\n\t        if (!paperOptions.linkPinning) {\n\t            // Link pinning is not allowed and the link is not connected to the target.\n\t            if (!ns.linkPinning.call(this, graph, link)) { return false; }\n\t        }\n\n\t        if (typeof paperOptions.allowLink === 'function') {\n\t            if (!paperOptions.allowLink.call(this, linkView, this)) { return false; }\n\t        }\n\n\t        return true;\n\t    },\n\n\t    getDefaultLink: function(cellView, magnet) {\n\n\t        return isFunction(this.options.defaultLink)\n\t        // default link is a function producing link model\n\t            ? this.options.defaultLink.call(this, cellView, magnet)\n\t        // default link is the Backbone model\n\t            : this.options.defaultLink.clone();\n\t    },\n\n\t    // Cell highlighting.\n\t    // ------------------\n\n\t    resolveHighlighter: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        var highlighterDef = opt.highlighter;\n\t        var type = opt.type;\n\t        var ref = this.options;\n\t        var highlighting = ref.highlighting;\n\t        var highlighterNamespace = ref.highlighterNamespace;\n\n\t        /*\n\t            Expecting opt.highlighter to have the following structure:\n\t            {\n\t                name: 'highlighter-name',\n\t                options: {\n\t                    some: 'value'\n\t                }\n\t            }\n\t        */\n\t        if (highlighterDef === undefined) {\n\n\t            // Is highlighting disabled?\n\t            if (!highlighting) { return false; }\n\t            // check for built-in types\n\t            if (type) {\n\t                highlighterDef = highlighting[type];\n\t                // Is a specific type highlight disabled?\n\t                if (highlighterDef === false) { return false; }\n\t            }\n\t            if (!highlighterDef) {\n\t                // Type not defined use default highlight\n\t                highlighterDef = highlighting['default'];\n\t            }\n\t        }\n\n\t        // Do nothing if opt.highlighter is falsy.\n\t        // This allows the case to not highlight cell(s) in certain cases.\n\t        // For example, if you want to NOT highlight when embedding elements\n\t        // or use a custom highlighter.\n\t        if (!highlighterDef) { return false; }\n\n\t        // Allow specifying a highlighter by name.\n\t        if (isString(highlighterDef)) {\n\t            highlighterDef = {\n\t                name: highlighterDef\n\t            };\n\t        }\n\n\t        var name = highlighterDef.name;\n\t        var highlighter = highlighterNamespace[name];\n\n\t        // Highlighter validation\n\t        if (!highlighter) {\n\t            throw new Error('Unknown highlighter (\"' + name + '\")');\n\t        }\n\t        if (typeof highlighter.highlight !== 'function') {\n\t            throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\n\t        }\n\t        if (typeof highlighter.unhighlight !== 'function') {\n\t            throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\n\t        }\n\n\t        return {\n\t            highlighter: highlighter,\n\t            options: highlighterDef.options || {},\n\t            name: name\n\t        };\n\t    },\n\n\t    onCellHighlight: function(cellView, magnetEl, opt) {\n\t        var highlighterDescriptor = this.resolveHighlighter(opt);\n\t        if (!highlighterDescriptor) { return; }\n\t        var highlighter = highlighterDescriptor.highlighter;\n\t        var options = highlighterDescriptor.options;\n\t        highlighter.highlight(cellView, magnetEl, options);\n\t    },\n\n\t    onCellUnhighlight: function(cellView, magnetEl, opt) {\n\t        var highlighterDescriptor = this.resolveHighlighter(opt);\n\t        if (!highlighterDescriptor) { return; }\n\t        var highlighter = highlighterDescriptor.highlighter;\n\t        var options = highlighterDescriptor.options;\n\t        highlighter.unhighlight(cellView, magnetEl, options);\n\t    },\n\n\t    // Interaction.\n\t    // ------------\n\n\t    pointerdblclick: function(evt) {\n\n\t        evt.preventDefault();\n\n\t        // magnetpointerdblclick can stop propagation\n\n\t        evt = normalizeEvent(evt);\n\n\t        var view = this.findView(evt.target);\n\t        if (this.guard(evt, view)) { return; }\n\n\t        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n\t        if (view) {\n\t            view.pointerdblclick(evt, localPoint.x, localPoint.y);\n\n\t        } else {\n\t            this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);\n\t        }\n\t    },\n\n\t    pointerclick: function(evt) {\n\n\t        // magnetpointerclick can stop propagation\n\n\t        var data = this.eventData(evt);\n\t        // Trigger event only if mouse has not moved.\n\t        if (data.mousemoved <= this.options.clickThreshold) {\n\n\t            evt = normalizeEvent(evt);\n\n\t            var view = this.findView(evt.target);\n\t            if (this.guard(evt, view)) { return; }\n\n\t            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n\t            if (view) {\n\t                view.pointerclick(evt, localPoint.x, localPoint.y);\n\n\t            } else {\n\t                this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);\n\t            }\n\t        }\n\t    },\n\n\t    contextmenu: function(evt) {\n\n\t        if (this.options.preventContextMenu) { evt.preventDefault(); }\n\n\t        if (this.contextMenuFired) {\n\t            this.contextMenuFired = false;\n\t            return;\n\t        }\n\n\t        evt = normalizeEvent(evt);\n\n\t        this.contextMenuTrigger(evt);\n\t    },\n\n\t    contextMenuTrigger: function(evt) {\n\t        var view = this.findView(evt.target);\n\t        if (this.guard(evt, view)) { return; }\n\n\t        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n\t        if (view) {\n\t            view.contextmenu(evt, localPoint.x, localPoint.y);\n\n\t        } else {\n\t            this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);\n\t        }\n\t    },\n\n\t    pointerdown: function(evt) {\n\n\t        evt = normalizeEvent(evt);\n\n\t        var target = evt.target;\n\t        var button = evt.button;\n\t        var view = this.findView(target);\n\t        var isContextMenu = (button === 2);\n\n\t        if (view) {\n\n\t            if (!isContextMenu && this.guard(evt, view)) { return; }\n\n\t            var isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);\n\n\t            if (this.options.preventDefaultViewAction && !isTargetFormNode) {\n\t                // If the target is a form element, we do not want to prevent the default action.\n\t                // For example, we want to be able to select text in a text input or\n\t                // to be able to click on a checkbox.\n\t                evt.preventDefault();\n\t            }\n\n\t            if (isTargetFormNode) {\n\t                // If the target is a form element, we do not want to start dragging the element.\n\t                // For example, we want to be able to select text by dragging the mouse.\n\t                view.preventDefaultInteraction(evt);\n\t            }\n\n\t            var rootViewEl = view.el;\n\n\t            // Custom event\n\t            var eventNode = target.closest('[event]');\n\t            if (eventNode && rootViewEl !== eventNode && view.el.contains(eventNode)) {\n\t                var eventEvt = normalizeEvent($.Event(evt.originalEvent, {\n\t                    data: evt.data,\n\t                    // Originally the event listener was attached to the event element.\n\t                    currentTarget: eventNode\n\t                }));\n\t                this.onevent(eventEvt);\n\t                if (eventEvt.isDefaultPrevented()) {\n\t                    evt.preventDefault();\n\t                }\n\t                // `onevent` can stop propagation\n\t                if (eventEvt.isPropagationStopped()) { return; }\n\t                evt.data = eventEvt.data;\n\t            }\n\n\t            // Element magnet\n\t            var magnetNode = target.closest('[magnet]');\n\t            if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {\n\t                var magnetEvt = normalizeEvent($.Event(evt.originalEvent, {\n\t                    data: evt.data,\n\t                    // Originally the event listener was attached to the magnet element.\n\t                    currentTarget: magnetNode\n\t                }));\n\t                this.onmagnet(magnetEvt);\n\t                if (magnetEvt.isDefaultPrevented()) {\n\t                    evt.preventDefault();\n\t                }\n\t                // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed\n\t                if (magnetEvt.isPropagationStopped()) {\n\t                    // `magnet:pointermove` and `magnet:pointerup` events must be fired\n\t                    if (isContextMenu) { return; }\n\t                    this.delegateDragEvents(view, magnetEvt.data);\n\t                    return;\n\t                }\n\t                evt.data = magnetEvt.data;\n\t            }\n\t        }\n\n\t        if (isContextMenu) {\n\t            this.contextMenuFired = true;\n\t            var contextmenuEvt = $.Event(evt.originalEvent, { type: 'contextmenu', data: evt.data });\n\t            this.contextMenuTrigger(contextmenuEvt);\n\t        } else {\n\t            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t            if (view) {\n\t                view.pointerdown(evt, localPoint.x, localPoint.y);\n\t            } else {\n\t                if (this.options.preventDefaultBlankAction) {\n\t                    evt.preventDefault();\n\t                }\n\t                this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);\n\t            }\n\n\t            this.delegateDragEvents(view, evt.data);\n\t        }\n\n\t    },\n\n\t    pointermove: function(evt) {\n\n\t        // mouse moved counter\n\t        var data = this.eventData(evt);\n\t        if (!data.mousemoved) {\n\t            data.mousemoved = 0;\n\t            // Make sure that events like `mouseenter` and `mouseleave` are\n\t            // not triggered while the user is dragging a cellView.\n\t            this.undelegateEvents();\n\t            // Note: the events are undelegated after the first `pointermove` event.\n\t            // Not on `pointerdown` to make sure that `dbltap` is recognized.\n\t        }\n\n\t        var mousemoved = ++data.mousemoved;\n\n\t        if (mousemoved <= this.options.moveThreshold) { return; }\n\n\t        evt = normalizeEvent(evt);\n\n\t        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n\t        var view = data.sourceView;\n\t        if (view) {\n\t            view.pointermove(evt, localPoint.x, localPoint.y);\n\t        } else {\n\t            this.trigger('blank:pointermove', evt, localPoint.x, localPoint.y);\n\t        }\n\n\t        this.eventData(evt, data);\n\t    },\n\n\t    pointerup: function(evt) {\n\n\t        this.undelegateDocumentEvents();\n\n\t        var normalizedEvt = normalizeEvent(evt);\n\n\t        var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n\n\t        var view = this.eventData(evt).sourceView;\n\t        if (view) {\n\t            view.pointerup(normalizedEvt, localPoint.x, localPoint.y);\n\t        } else {\n\t            this.trigger('blank:pointerup', normalizedEvt, localPoint.x, localPoint.y);\n\t        }\n\n\t        if (!normalizedEvt.isPropagationStopped()) {\n\t            this.pointerclick($.Event(evt.originalEvent, { type: 'click', data: evt.data }));\n\t        }\n\n\t        evt.stopImmediatePropagation();\n\t        this.delegateEvents();\n\t    },\n\n\t    mouseover: function(evt) {\n\n\t        evt = normalizeEvent(evt);\n\n\t        var view = this.findView(evt.target);\n\t        if (this.guard(evt, view)) { return; }\n\n\t        if (view) {\n\t            view.mouseover(evt);\n\n\t        } else {\n\t            if (this.el === evt.target) { return; } // prevent border of paper from triggering this\n\t            this.trigger('blank:mouseover', evt);\n\t        }\n\t    },\n\n\t    mouseout: function(evt) {\n\n\t        evt = normalizeEvent(evt);\n\n\t        var view = this.findView(evt.target);\n\t        if (this.guard(evt, view)) { return; }\n\n\t        if (view) {\n\t            view.mouseout(evt);\n\n\t        } else {\n\t            if (this.el === evt.target) { return; } // prevent border of paper from triggering this\n\t            this.trigger('blank:mouseout', evt);\n\t        }\n\t    },\n\n\t    mouseenter: function(evt) {\n\n\t        evt = normalizeEvent(evt);\n\n\t        var target = evt.target;\n\t        var relatedTarget = evt.relatedTarget;\n\t        var currentTarget = evt.currentTarget;\n\t        var view = this.findView(target);\n\t        if (this.guard(evt, view)) { return; }\n\t        var relatedView = this.findView(relatedTarget);\n\t        if (view) {\n\t            if (relatedView === view) {\n\t                // Mouse left a cell tool\n\t                return;\n\t            }\n\t            view.mouseenter(evt);\n\t            if (this.el.contains(relatedTarget)) {\n\t                // The pointer remains inside the paper.\n\t                return;\n\t            }\n\t        }\n\t        if (relatedView) {\n\t            return;\n\t        }\n\t        // prevent double `mouseenter` event if the `relatedTarget` is outside the paper\n\t        // (mouseenter method would be fired twice)\n\t        if (currentTarget === this.el) {\n\t            // `paper` (more descriptive), not `blank`\n\t            this.trigger('paper:mouseenter', evt);\n\t        }\n\t    },\n\n\t    mouseleave: function(evt) {\n\n\t        evt = normalizeEvent(evt);\n\n\t        var target = evt.target;\n\t        var relatedTarget = evt.relatedTarget;\n\t        var currentTarget = evt.currentTarget;\n\t        var view = this.findView(target);\n\t        if (this.guard(evt, view)) { return; }\n\t        var relatedView = this.findView(relatedTarget);\n\t        if (view) {\n\t            if (relatedView === view) {\n\t                // Mouse entered a cell tool\n\t                return;\n\t            }\n\t            view.mouseleave(evt);\n\t            if (this.el.contains(relatedTarget)) {\n\t                // The pointer has exited a cellView. The pointer is still inside of the paper.\n\t                return;\n\t            }\n\t        }\n\t        if (relatedView) {\n\t            // The pointer has entered a new cellView\n\t            return;\n\t        }\n\t        // prevent double `mouseleave` event if the `relatedTarget` is outside the paper\n\t        // (mouseleave method would be fired twice)\n\t        if (currentTarget === this.el) {\n\t            // There is no cellView under the pointer, nor the blank area of the paper\n\t            this.trigger('paper:mouseleave', evt);\n\t        }\n\t    },\n\n\t    _processMouseWheelEvtBuf: debounce(function() {\n\t        var ref = this._mw_evt_buffer;\n\t        var event = ref.event;\n\t        var deltas = ref.deltas;\n\t        var deltaY = deltas.reduce(function (acc, deltaY) { return acc + cap(deltaY, WHEEL_CAP); }, 0);\n\n\t        var scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom\n\t        var ref$1 = this.clientToLocalPoint(event.clientX, event.clientY);\n\t        var x = ref$1.x;\n\t        var y = ref$1.y;\n\t        this.trigger('paper:pinch', event, x, y, scale);\n\n\t        this._mw_evt_buffer = {\n\t            event: null,\n\t            deltas: [],\n\t        };\n\t    }, WHEEL_WAIT_MS, { maxWait: WHEEL_WAIT_MS }),\n\n\t    mousewheel: function(evt) {\n\n\t        evt = normalizeEvent(evt);\n\n\t        var view = this.findView(evt.target);\n\t        if (this.guard(evt, view)) { return; }\n\n\t        var originalEvent = evt.originalEvent;\n\t        var localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);\n\t        var ref = normalizeWheel(originalEvent);\n\t        var deltaX = ref.deltaX;\n\t        var deltaY = ref.deltaY;\n\n\t        var pinchHandlers = this._events['paper:pinch'];\n\n\t        // Touchpad devices will send a fake CTRL press when a pinch is performed\n\t        //\n\t        // We also check if there are any subscribers to paper:pinch event. If there are none,\n\t        // just skip the entire block of code (we don't want to blindly call\n\t        // .preventDefault() if we really don't have to).\n\t        if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {\n\t            // This is a pinch gesture, it's safe to assume that we must call .preventDefault()\n\t            originalEvent.preventDefault();\n\t            this._mw_evt_buffer.event = originalEvent;\n\t            this._mw_evt_buffer.deltas.push(deltaY);\n\t            this._processMouseWheelEvtBuf();\n\t        } else {\n\t            var delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));\n\t            if (view) {\n\t                view.mousewheel(evt, localPoint.x, localPoint.y, delta);\n\n\t            } else {\n\t                this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);\n\t            }\n\n\t            this.trigger('paper:pan', evt, deltaX, deltaY);\n\t        }\n\t    },\n\n\t    onevent: function(evt) {\n\n\t        var eventNode = evt.currentTarget;\n\t        var eventName = eventNode.getAttribute('event');\n\t        if (eventName) {\n\t            var view = this.findView(eventNode);\n\t            if (view) {\n\n\t                evt = normalizeEvent(evt);\n\t                if (this.guard(evt, view)) { return; }\n\n\t                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t                view.onevent(evt, eventName, localPoint.x, localPoint.y);\n\t            }\n\t        }\n\t    },\n\n\t    magnetEvent: function(evt, handler) {\n\n\t        var magnetNode = evt.currentTarget;\n\t        var magnetValue = magnetNode.getAttribute('magnet');\n\t        if (magnetValue) {\n\t            var view = this.findView(magnetNode);\n\t            if (view) {\n\t                evt = normalizeEvent(evt);\n\t                if (this.guard(evt, view)) { return; }\n\t                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t                handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);\n\t            }\n\t        }\n\t    },\n\n\t    onmagnet: function(evt) {\n\n\t        if (evt.button === 2) {\n\t            this.contextMenuFired = true;\n\t            this.magnetContextMenuFired = true;\n\t            var contextmenuEvt = $.Event(evt.originalEvent, {\n\t                type: 'contextmenu',\n\t                data: evt.data,\n\t                currentTarget: evt.currentTarget,\n\t            });\n\t            this.magnetContextMenuTrigger(contextmenuEvt);\n\t            if (contextmenuEvt.isPropagationStopped()) {\n\t                evt.stopPropagation();\n\t            }\n\t        } else {\n\t            this.magnetEvent(evt, function(view, evt, _, x, y) {\n\t                view.onmagnet(evt, x, y);\n\t            });\n\t        }\n\t    },\n\n\t    magnetpointerdblclick: function(evt) {\n\n\t        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n\t            view.magnetpointerdblclick(evt, magnet, x, y);\n\t        });\n\t    },\n\n\t    magnetcontextmenu: function(evt) {\n\t        if (this.options.preventContextMenu) { evt.preventDefault(); }\n\n\t        if (this.magnetContextMenuFired) {\n\t            this.magnetContextMenuFired = false;\n\t            return;\n\t        }\n\n\t        this.magnetContextMenuTrigger(evt);\n\t    },\n\n\t    magnetContextMenuTrigger: function(evt) {\n\t        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n\t            view.magnetcontextmenu(evt, magnet, x, y);\n\t        });\n\t    },\n\n\t    onlabel: function(evt) {\n\n\t        var labelNode = evt.currentTarget;\n\t        var view = this.findView(labelNode);\n\t        if (view) {\n\n\t            evt = normalizeEvent(evt);\n\t            if (this.guard(evt, view)) { return; }\n\n\t            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t            view.onlabel(evt, localPoint.x, localPoint.y);\n\t        }\n\t    },\n\n\t    getPointerArgs: function getPointerArgs(evt) {\n\t        var normalizedEvt = normalizeEvent(evt);\n\t        var ref = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n\t        var x = ref.x;\n\t        var y = ref.y;\n\t        return [normalizedEvt, x, y];\n\t    },\n\n\t    delegateDragEvents: function(view, data) {\n\n\t        data || (data = {});\n\t        this.eventData({ data: data }, { sourceView: view || null, mousemoved: 0 });\n\t        this.delegateDocumentEvents(null, data);\n\t    },\n\n\t    // Guard the specified event. If the event should be ignored, guard returns `true`.\n\t    // Otherwise, it returns `false`.\n\t    guard: function(evt, view) {\n\n\t        if (evt.type === 'mousedown' && evt.button === 2) {\n\t            // handled as `contextmenu` type\n\t            return true;\n\t        }\n\n\t        if (this.options.guard && this.options.guard(evt, view)) {\n\t            return true;\n\t        }\n\n\t        if (evt.data && evt.data.guarded !== undefined) {\n\t            return evt.data.guarded;\n\t        }\n\n\t        var target = evt.target;\n\n\t        if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {\n\t            return true;\n\t        }\n\n\t        if (view && view.model && (view.model instanceof Cell)) {\n\t            return false;\n\t        }\n\n\t        if (this.svg === target || this.el === target || $.contains(this.svg, target)) {\n\t            return false;\n\t        }\n\n\t        return true;    // Event guarded. Paper should not react on it in any way.\n\t    },\n\n\t    setGridSize: function(gridSize) {\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        options.gridSize = gridSize;\n\n\t        if (options.drawGrid && !options.drawGridSize) {\n\t            // Do not redraw the grid if the `drawGridSize` is set.\n\t            this.drawGrid();\n\t        }\n\n\t        return this;\n\t    },\n\n\t    clearGrid: function() {\n\n\t        if (this.$grid) {\n\t            this.$grid.css('backgroundImage', 'none');\n\t        }\n\t        return this;\n\t    },\n\n\t    _getGridRefs: function() {\n\n\t        if (!this._gridCache) {\n\n\t            this._gridCache = {\n\t                root: V('svg', { width: '100%', height: '100%' }, V('defs')),\n\t                patterns: {},\n\t                add: function(id, vel) {\n\t                    V(this.root.node.childNodes[0]).append(vel);\n\t                    this.patterns[id] = vel;\n\t                    this.root.append(V('rect', { width: '100%', height: '100%', fill: 'url(#' + id + ')' }));\n\t                },\n\t                get: function(id) {\n\t                    return this.patterns[id];\n\t                },\n\t                exist: function(id) {\n\t                    return this.patterns[id] !== undefined;\n\t                }\n\t            };\n\t        }\n\n\t        return this._gridCache;\n\t    },\n\n\t    setGrid: function(drawGrid) {\n\n\t        this.clearGrid();\n\n\t        this._gridCache = null;\n\t        this._gridSettings = [];\n\n\t        var optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\n\t        optionsList.forEach(function(item) {\n\t            this._gridSettings.push.apply(this._gridSettings, this._resolveDrawGridOption(item));\n\t        }, this);\n\t        return this;\n\t    },\n\n\t    _resolveDrawGridOption: function(opt) {\n\n\t        var namespace = this.constructor.gridPatterns;\n\t        if (isString(opt) && Array.isArray(namespace[opt])) {\n\t            return namespace[opt].map(function(item) {\n\t                return assign({}, item);\n\t            });\n\t        }\n\n\t        var options = opt || { args: [{}] };\n\t        var isArray = Array.isArray(options);\n\t        var name = options.name;\n\n\t        if (!isArray && !name && !options.markup) {\n\t            name = 'dot';\n\t        }\n\n\t        if (name && Array.isArray(namespace[name])) {\n\t            var pattern = namespace[name].map(function(item) {\n\t                return assign({}, item);\n\t            });\n\n\t            var args = Array.isArray(options.args) ? options.args : [options.args || {}];\n\n\t            defaults(args[0], omit(opt, 'args'));\n\t            for (var i = 0; i < args.length; i++) {\n\t                if (pattern[i]) {\n\t                    assign(pattern[i], args[i]);\n\t                }\n\t            }\n\t            return pattern;\n\t        }\n\n\t        return isArray ? options : [options];\n\t    },\n\n\t    drawGrid: function(opt) {\n\n\t        var gridSize = this.options.drawGridSize || this.options.gridSize;\n\t        if (gridSize <= 1) {\n\t            return this.clearGrid();\n\t        }\n\n\t        var localOptions = Array.isArray(opt) ? opt : [opt];\n\n\t        var ctm = this.matrix();\n\t        var refs = this._getGridRefs();\n\n\t        this._gridSettings.forEach(function(gridLayerSetting, index) {\n\n\t            var id = 'pattern_' + index;\n\t            var options = merge(gridLayerSetting, localOptions[index], {\n\t                sx: ctm.a || 1,\n\t                sy: ctm.d || 1,\n\t                ox: ctm.e || 0,\n\t                oy: ctm.f || 0\n\t            });\n\n\t            options.width = gridSize * (ctm.a || 1) * (options.scaleFactor || 1);\n\t            options.height = gridSize * (ctm.d || 1) * (options.scaleFactor || 1);\n\n\t            if (!refs.exist(id)) {\n\t                refs.add(id, V('pattern', { id: id, patternUnits: 'userSpaceOnUse' }, V(options.markup)));\n\t            }\n\n\t            var patternDefVel = refs.get(id);\n\n\t            if (isFunction(options.update)) {\n\t                options.update(patternDefVel.node.childNodes[0], options);\n\t            }\n\n\t            var x = options.ox % options.width;\n\t            if (x < 0) { x += options.width; }\n\n\t            var y = options.oy % options.height;\n\t            if (y < 0) { y += options.height; }\n\n\t            patternDefVel.attr({\n\t                x: x,\n\t                y: y,\n\t                width: options.width,\n\t                height: options.height\n\t            });\n\t        });\n\n\t        var patternUri = new XMLSerializer().serializeToString(refs.root.node);\n\t        patternUri = 'url(data:image/svg+xml;base64,' + btoa(patternUri) + ')';\n\n\t        this.$grid.css('backgroundImage', patternUri);\n\n\t        return this;\n\t    },\n\n\t    updateBackgroundImage: function(opt) {\n\n\t        opt = opt || {};\n\n\t        var backgroundPosition = opt.position || 'center';\n\t        var backgroundSize = opt.size || 'auto auto';\n\n\t        var currentScale = this.scale();\n\t        var currentTranslate = this.translate();\n\n\t        // backgroundPosition\n\t        if (isObject$1(backgroundPosition)) {\n\t            var x = currentTranslate.tx + (currentScale.sx * (backgroundPosition.x || 0));\n\t            var y = currentTranslate.ty + (currentScale.sy * (backgroundPosition.y || 0));\n\t            backgroundPosition = x + 'px ' + y + 'px';\n\t        }\n\n\t        // backgroundSize\n\t        if (isObject$1(backgroundSize)) {\n\t            backgroundSize = new Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\n\t            backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';\n\t        }\n\n\t        this.$background.css({\n\t            backgroundSize: backgroundSize,\n\t            backgroundPosition: backgroundPosition\n\t        });\n\t    },\n\n\t    drawBackgroundImage: function(img, opt) {\n\n\t        // Clear the background image if no image provided\n\t        if (!(img instanceof HTMLImageElement)) {\n\t            this.$background.css('backgroundImage', '');\n\t            return;\n\t        }\n\n\t        if (!this._background || this._background.id !== opt.id) {\n\t            // Draw only the last image requested (see drawBackground())\n\t            return;\n\t        }\n\n\t        opt = opt || {};\n\n\t        var backgroundImage;\n\t        var backgroundSize = opt.size;\n\t        var backgroundRepeat = opt.repeat || 'no-repeat';\n\t        var backgroundOpacity = opt.opacity || 1;\n\t        var backgroundQuality = Math.abs(opt.quality) || 1;\n\t        var backgroundPattern = this.constructor.backgroundPatterns[camelCase(backgroundRepeat)];\n\n\t        if (isFunction(backgroundPattern)) {\n\t            // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\n\t            img.width *= backgroundQuality;\n\t            img.height *= backgroundQuality;\n\t            var canvas = backgroundPattern(img, opt);\n\t            if (!(canvas instanceof HTMLCanvasElement)) {\n\t                throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');\n\t            }\n\n\t            backgroundImage = canvas.toDataURL('image/png');\n\t            backgroundRepeat = 'repeat';\n\t            if (isObject$1(backgroundSize)) {\n\t                // recalculate the tile size if an object passed in\n\t                backgroundSize.width *= canvas.width / img.width;\n\t                backgroundSize.height *= canvas.height / img.height;\n\t            } else if (backgroundSize === undefined) {\n\t                // calculate the tile size if no provided\n\t                opt.size = {\n\t                    width: canvas.width / backgroundQuality,\n\t                    height: canvas.height / backgroundQuality\n\t                };\n\t            }\n\t        } else {\n\t            // backgroundRepeat:\n\t            // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\n\t            backgroundImage = img.src;\n\t            if (backgroundSize === undefined) {\n\t                // pass the image size for  the backgroundSize if no size provided\n\t                opt.size = {\n\t                    width: img.width,\n\t                    height: img.height\n\t                };\n\t            }\n\t        }\n\n\t        this.$background.css({\n\t            opacity: backgroundOpacity,\n\t            backgroundRepeat: backgroundRepeat,\n\t            backgroundImage: 'url(' + backgroundImage + ')'\n\t        });\n\n\t        this.updateBackgroundImage(opt);\n\t    },\n\n\t    updateBackgroundColor: function(color) {\n\n\t        this.$el.css('backgroundColor', color || '');\n\t    },\n\n\t    drawBackground: function(opt) {\n\n\t        opt = opt || {};\n\n\t        this.updateBackgroundColor(opt.color);\n\n\t        if (opt.image) {\n\t            opt = this._background = cloneDeep(opt);\n\t            guid(opt);\n\t            var img = document.createElement('img');\n\t            img.onload = this.drawBackgroundImage.bind(this, img, opt);\n\t            img.src = opt.image;\n\t        } else {\n\t            this.drawBackgroundImage(null);\n\t            this._background = null;\n\t        }\n\n\t        return this;\n\t    },\n\n\t    setInteractivity: function(value) {\n\n\t        this.options.interactive = value;\n\n\t        invoke(this._views, 'setInteractivity', value);\n\t    },\n\n\t    // Paper definitions.\n\t    // ------------------\n\n\t    isDefined: function(defId) {\n\n\t        return !!this.svg.getElementById(defId);\n\t    },\n\n\t    defineFilter: function(filter$1) {\n\n\t        if (!isObject$1(filter$1)) {\n\t            throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');\n\t        }\n\n\t        var filterId = filter$1.id;\n\t        var name = filter$1.name;\n\t        // Generate a hash code from the stringified filter definition. This gives us\n\t        // a unique filter ID for different definitions.\n\t        if (!filterId) {\n\t            filterId = name + this.svg.id + hashCode(JSON.stringify(filter$1));\n\t        }\n\t        // If the filter already exists in the document,\n\t        // we're done and we can just use it (reference it using `url()`).\n\t        // If not, create one.\n\t        if (!this.isDefined(filterId)) {\n\n\t            var namespace = filter;\n\t            var filterSVGString = namespace[name] && namespace[name](filter$1.args || {});\n\t            if (!filterSVGString) {\n\t                throw new Error('Non-existing filter ' + name);\n\t            }\n\n\t            // Set the filter area to be 3x the bounding box of the cell\n\t            // and center the filter around the cell.\n\t            var filterAttrs = assign({\n\t                filterUnits: 'objectBoundingBox',\n\t                x: -1,\n\t                y: -1,\n\t                width: 3,\n\t                height: 3\n\t            }, filter$1.attrs, {\n\t                id: filterId\n\t            });\n\n\t            V(filterSVGString, filterAttrs).appendTo(this.defs);\n\t        }\n\n\t        return filterId;\n\t    },\n\n\t    defineGradient: function(gradient) {\n\t        if (!isObject$1(gradient)) {\n\t            throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');\n\t        }\n\t        var ref = this;\n\t        var svg = ref.svg;\n\t        var defs = ref.defs;\n\t        var type = gradient.type;\n\t        var id = gradient.id; if ( id === void 0 ) id = type + svg.id + hashCode(JSON.stringify(gradient));\n\t        var stops = gradient.stops;\n\t        var attrs = gradient.attrs; if ( attrs === void 0 ) attrs = {};\n\t        // If the gradient already exists in the document,\n\t        // we're done and we can just use it (reference it using `url()`).\n\t        if (this.isDefined(id)) { return id; }\n\t        // If not, create one.\n\t        var stopVEls = toArray(stops).map(function (ref) {\n\t            var offset = ref.offset;\n\t            var color = ref.color;\n\t            var opacity = ref.opacity;\n\n\t            return V('stop').attr({\n\t                'offset': offset,\n\t                'stop-color': color,\n\t                'stop-opacity': Number.isFinite(opacity) ? opacity : 1\n\t            });\n\t        });\n\t        var gradientVEl = V(type, attrs, stopVEls);\n\t        gradientVEl.id = id;\n\t        gradientVEl.appendTo(defs);\n\t        return id;\n\t    },\n\n\t    definePattern: function(pattern) {\n\t        if (!isObject$1(pattern)) {\n\t            throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.');\n\t        }\n\t        var ref = this;\n\t        var svg = ref.svg;\n\t        var defs = ref.defs;\n\t        var id = pattern.id; if ( id === void 0 ) id = svg.id + hashCode(JSON.stringify(pattern));\n\t        var markup = pattern.markup;\n\t        var attrs = pattern.attrs; if ( attrs === void 0 ) attrs = {};\n\t        if (!markup) {\n\t            throw new TypeError('dia.Paper: definePattern() requires markup.');\n\t        }\n\t        // If the gradient already exists in the document,\n\t        // we're done and we can just use it (reference it using `url()`).\n\t        if (this.isDefined(id)) { return id; }\n\t        // If not, create one.\n\t        var patternVEl = V('pattern', {\n\t            patternUnits: 'userSpaceOnUse'\n\t        });\n\t        patternVEl.id = id;\n\t        patternVEl.attr(attrs);\n\t        if (typeof markup === 'string') {\n\t            patternVEl.append(V(markup));\n\t        } else {\n\t            var ref$1 = parseDOMJSON(markup);\n\t            var fragment = ref$1.fragment;\n\t            patternVEl.append(fragment);\n\t        }\n\t        patternVEl.appendTo(defs);\n\t        return id;\n\t    },\n\n\t    defineMarker: function(marker) {\n\t        if (!isObject$1(marker)) {\n\t            throw new TypeError('dia.Paper: defineMarker() requires the first argument to be an object.');\n\t        }\n\t        var ref = this;\n\t        var svg = ref.svg;\n\t        var defs = ref.defs;\n\t        var id = marker.id; if ( id === void 0 ) id = svg.id + hashCode(JSON.stringify(marker));\n\t        var markup = marker.markup;\n\t        var attrs = marker.attrs; if ( attrs === void 0 ) attrs = {};\n\t        var markerUnits = marker.markerUnits; if ( markerUnits === void 0 ) markerUnits = 'userSpaceOnUse';\n\t        // If the marker already exists in the document,\n\t        // we're done and we can just use it (reference it using `url()`).\n\t        if (this.isDefined(id)) { return id; }\n\t        // If not, create one.\n\t        var markerVEl = V('marker', {\n\t            orient: 'auto',\n\t            overflow: 'visible',\n\t            markerUnits: markerUnits\n\t        });\n\t        markerVEl.id = id;\n\t        markerVEl.attr(attrs);\n\t        var markerContentVEl;\n\t        if (markup) {\n\t            var markupVEl;\n\t            if (typeof markup === 'string') {\n\t                // Marker object has a `markup` property of type string.\n\t                // - Construct V from the provided string.\n\t                markupVEl = V(markup);\n\t                // `markupVEl` is now either a single VEl, or an array of VEls.\n\t                // - Coerce it to an array.\n\t                markupVEl = (Array.isArray(markupVEl) ? markupVEl : [markupVEl]);\n\t            } else {\n\t                // Marker object has a `markup` property of type object.\n\t                // - Construct V from the object by parsing it as DOM JSON.\n\t                var ref$1 = parseDOMJSON(markup);\n\t                var fragment = ref$1.fragment;\n\t                markupVEl = V(fragment).children();\n\t            }\n\t            // `markupVEl` is an array with one or more VEls inside.\n\t            // - If there are multiple VEls, wrap them in a newly-constructed <g> element\n\t            if (markupVEl.length > 1) {\n\t                markerContentVEl = V('g').append(markupVEl);\n\t            } else {\n\t                markerContentVEl = markupVEl[0];\n\t            }\n\t        } else {\n\t            // Marker object is a flat structure.\n\t            // - Construct a new V of type `marker.type`.\n\t            var type = marker.type; if ( type === void 0 ) type = 'path';\n\t            markerContentVEl = V(type);\n\t        }\n\t        // `markerContentVEl` is a single VEl.\n\t        // Assign additional attributes to it (= context attributes + marker attributes):\n\t        // - Attribute values are taken from non-special properties of `marker`.\n\t        var markerAttrs = omit(marker, 'type', 'id', 'markup', 'attrs', 'markerUnits');\n\t        var markerAttrsKeys = Object.keys(markerAttrs);\n\t        markerAttrsKeys.forEach(function (key) {\n\t            var value = markerAttrs[key];\n\t            var markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority\n\t            if (markupValue == null) {\n\t                // Default logic:\n\t                markerContentVEl.attr(key, value);\n\t            } else {\n\t                // Properties with special logic should be added as cases to this switch block:\n\t                switch(key) {\n\t                    case 'transform':\n\t                        // - Prepend `transform` to existing value.\n\t                        markerContentVEl.attr(key, (value + ' ' + markupValue));\n\t                        break;\n\t                }\n\t            }\n\t        });\n\t        markerContentVEl.appendTo(markerVEl);\n\t        markerVEl.appendTo(defs);\n\t        return id;\n\t    }\n\n\t}, {\n\n\t    sorting: sortingTypes,\n\n\t    Layers: LayersNames,\n\n\t    backgroundPatterns: {\n\n\t        flipXy: function(img) {\n\t            // d b\n\t            // q p\n\n\t            var canvas = document.createElement('canvas');\n\t            var imgWidth = img.width;\n\t            var imgHeight = img.height;\n\n\t            canvas.width = 2 * imgWidth;\n\t            canvas.height = 2 * imgHeight;\n\n\t            var ctx = canvas.getContext('2d');\n\t            // top-left image\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t            // xy-flipped bottom-right image\n\t            ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t            // x-flipped top-right image\n\t            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t            // y-flipped bottom-left image\n\t            ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n\t            return canvas;\n\t        },\n\n\t        flipX: function(img) {\n\t            // d b\n\t            // d b\n\n\t            var canvas = document.createElement('canvas');\n\t            var imgWidth = img.width;\n\t            var imgHeight = img.height;\n\n\t            canvas.width = imgWidth * 2;\n\t            canvas.height = imgHeight;\n\n\t            var ctx = canvas.getContext('2d');\n\t            // left image\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t            // flipped right image\n\t            ctx.translate(2 * imgWidth, 0);\n\t            ctx.scale(-1, 1);\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n\t            return canvas;\n\t        },\n\n\t        flipY: function(img) {\n\t            // d d\n\t            // q q\n\n\t            var canvas = document.createElement('canvas');\n\t            var imgWidth = img.width;\n\t            var imgHeight = img.height;\n\n\t            canvas.width = imgWidth;\n\t            canvas.height = imgHeight * 2;\n\n\t            var ctx = canvas.getContext('2d');\n\t            // top image\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t            // flipped bottom image\n\t            ctx.translate(0, 2 * imgHeight);\n\t            ctx.scale(1, -1);\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n\t            return canvas;\n\t        },\n\n\t        watermark: function(img, opt) {\n\t            //   d\n\t            // d\n\n\t            opt = opt || {};\n\n\t            var imgWidth = img.width;\n\t            var imgHeight = img.height;\n\n\t            var canvas = document.createElement('canvas');\n\t            canvas.width = imgWidth * 3;\n\t            canvas.height = imgHeight * 3;\n\n\t            var ctx = canvas.getContext('2d');\n\t            var angle = isNumber(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\n\t            var radians = toRad(angle);\n\t            var stepX = canvas.width / 4;\n\t            var stepY = canvas.height / 4;\n\n\t            for (var i = 0; i < 4; i++) {\n\t                for (var j = 0; j < 4; j++) {\n\t                    if ((i + j) % 2 > 0) {\n\t                        // reset the current transformations\n\t                        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);\n\t                        ctx.rotate(radians);\n\t                        ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\n\t                    }\n\t                }\n\t            }\n\n\t            return canvas;\n\t        }\n\t    },\n\n\t    gridPatterns: {\n\t        dot: [{\n\t            color: '#AAAAAA',\n\t            thickness: 1,\n\t            markup: 'rect',\n\t            update: function(el, opt) {\n\t                V(el).attr({\n\t                    width: opt.thickness * opt.sx,\n\t                    height: opt.thickness * opt.sy,\n\t                    fill: opt.color\n\t                });\n\t            }\n\t        }],\n\t        fixedDot: [{\n\t            color: '#AAAAAA',\n\t            thickness: 1,\n\t            markup: 'rect',\n\t            update: function(el, opt) {\n\t                var size = opt.sx <= 1 ? opt.thickness * opt.sx : opt.thickness;\n\t                V(el).attr({ width: size, height: size, fill: opt.color });\n\t            }\n\t        }],\n\t        mesh: [{\n\t            color: '#AAAAAA',\n\t            thickness: 1,\n\t            markup: 'path',\n\t            update: function(el, opt) {\n\n\t                var d;\n\t                var width = opt.width;\n\t                var height = opt.height;\n\t                var thickness = opt.thickness;\n\n\t                if (width - thickness >= 0 && height - thickness >= 0) {\n\t                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n\t                } else {\n\t                    d = 'M 0 0 0 0';\n\t                }\n\n\t                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n\t            }\n\t        }],\n\t        doubleMesh: [{\n\t            color: '#AAAAAA',\n\t            thickness: 1,\n\t            markup: 'path',\n\t            update: function(el, opt) {\n\n\t                var d;\n\t                var width = opt.width;\n\t                var height = opt.height;\n\t                var thickness = opt.thickness;\n\n\t                if (width - thickness >= 0 && height - thickness >= 0) {\n\t                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n\t                } else {\n\t                    d = 'M 0 0 0 0';\n\t                }\n\n\t                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n\t            }\n\t        }, {\n\t            color: '#000000',\n\t            thickness: 3,\n\t            scaleFactor: 4,\n\t            markup: 'path',\n\t            update: function(el, opt) {\n\n\t                var d;\n\t                var width = opt.width;\n\t                var height = opt.height;\n\t                var thickness = opt.thickness;\n\n\t                if (width - thickness >= 0 && height - thickness >= 0) {\n\t                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n\t                } else {\n\t                    d = 'M 0 0 0 0';\n\t                }\n\n\t                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n\t            }\n\t        }]\n\t    }\n\t});\n\n\tvar ToolView = View.extend({\n\t    name: null,\n\t    tagName: 'g',\n\t    className: 'tool',\n\t    svgElement: true,\n\t    _visible: true,\n\n\t    init: function() {\n\t        var name = this.name;\n\t        if (name) { this.vel.attr('data-tool-name', name); }\n\t    },\n\n\t    configure: function(view, toolsView) {\n\t        this.relatedView = view;\n\t        this.paper = view.paper;\n\t        this.parentView = toolsView;\n\t        this.simulateRelatedView(this.el);\n\t        // Delegate events in case the ToolView was removed from the DOM and reused.\n\t        this.delegateEvents();\n\t        return this;\n\t    },\n\n\t    simulateRelatedView: function(el) {\n\t        if (el) { el.setAttribute('model-id', this.relatedView.model.id); }\n\t    },\n\n\t    getName: function() {\n\t        return this.name;\n\t    },\n\n\t    show: function() {\n\t        this.el.style.display = '';\n\t        this._visible = true;\n\t    },\n\n\t    hide: function() {\n\t        this.el.style.display = 'none';\n\t        this._visible = false;\n\t    },\n\n\t    isVisible: function() {\n\t        return !!this._visible;\n\t    },\n\n\t    focus: function() {\n\t        var opacity = this.options.focusOpacity;\n\t        if (isFinite(opacity)) { this.el.style.opacity = opacity; }\n\t        this.parentView.focusTool(this);\n\t    },\n\n\t    blur: function() {\n\t        this.el.style.opacity = '';\n\t        this.parentView.blurTool(this);\n\t    },\n\n\t    update: function() {\n\t        // to be overridden\n\t    },\n\n\t    guard: function(evt) {\n\t        // Let the context-menu event bubble up to the relatedView\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var relatedView = ref.relatedView;\n\t        if (!paper || !relatedView) { return true; }\n\t        return paper.guard(evt, relatedView);\n\t    }\n\t});\n\n\tvar ToolsView = View.extend({\n\t    tagName: 'g',\n\t    className: 'tools',\n\t    svgElement: true,\n\t    tools: null,\n\t    isRendered: false,\n\t    options: {\n\t        tools: null,\n\t        relatedView: null,\n\t        name: null,\n\t        // layer?: LayersNames.TOOLS\n\t        // z?: number\n\t    },\n\n\t    configure: function(options) {\n\t        options = assign(this.options, options);\n\t        var tools = options.tools;\n\t        if (!Array.isArray(tools)) { return this; }\n\t        var relatedView = options.relatedView;\n\t        if (!(relatedView instanceof CellView)) { return this; }\n\t        var views = this.tools = [];\n\t        for (var i = 0, n = tools.length; i < n; i++) {\n\t            var tool = tools[i];\n\t            if (!(tool instanceof ToolView)) { continue; }\n\t            tool.configure(relatedView, this);\n\t            this.vel.append(tool.el);\n\t            views.push(tool);\n\t        }\n\t        this.isRendered = false;\n\t        relatedView.requestUpdate(relatedView.getFlag('TOOLS'));\n\t        return this;\n\t    },\n\n\t    getName: function() {\n\t        return this.options.name;\n\t    },\n\n\t    update: function(opt) {\n\n\t        opt || (opt = {});\n\t        var tools = this.tools;\n\t        if (!tools) { return this; }\n\t        var isRendered = this.isRendered;\n\t        for (var i = 0, n = tools.length; i < n; i++) {\n\t            var tool = tools[i];\n\t            if (!isRendered) {\n\t                // First update executes render()\n\t                tool.render();\n\t            } else if (opt.tool !== tool.cid && tool.isVisible()) {\n\t                tool.update();\n\t            }\n\t        }\n\t        if (!this.isMounted()) {\n\t            this.mount();\n\t        }\n\t        if (!isRendered) {\n\t            // Make sure tools are visible (if they were hidden and the tool removed)\n\t            this.blurTool();\n\t            this.isRendered = true;\n\t        }\n\t        return this;\n\t    },\n\n\t    focusTool: function(focusedTool) {\n\n\t        var tools = this.tools;\n\t        if (!tools) { return this; }\n\t        for (var i = 0, n = tools.length; i < n; i++) {\n\t            var tool = tools[i];\n\t            if (focusedTool === tool) {\n\t                tool.show();\n\t            } else {\n\t                tool.hide();\n\t            }\n\t        }\n\t        return this;\n\t    },\n\n\t    blurTool: function(blurredTool) {\n\t        var tools = this.tools;\n\t        if (!tools) { return this; }\n\t        for (var i = 0, n = tools.length; i < n; i++) {\n\t            var tool = tools[i];\n\t            if (tool !== blurredTool && !tool.isVisible()) {\n\t                tool.show();\n\t                tool.update();\n\t            }\n\t        }\n\t        return this;\n\t    },\n\n\t    hide: function() {\n\t        return this.focusTool(null);\n\t    },\n\n\t    show: function() {\n\t        return this.blurTool(null);\n\t    },\n\n\t    onRemove: function() {\n\t        var tools = this.tools;\n\t        if (!tools) { return this; }\n\t        for (var i = 0, n = tools.length; i < n; i++) {\n\t            tools[i].remove();\n\t        }\n\t        this.tools = null;\n\t    },\n\n\t    mount: function() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var el = ref.el;\n\t        var relatedView = options.relatedView;\n\t        var layer = options.layer; if ( layer === void 0 ) layer = LayersNames.TOOLS;\n\t        var z = options.z;\n\t        if (relatedView) {\n\t            if (layer) {\n\t                relatedView.paper.getLayerView(layer).insertSortedNode(el, z);\n\t            } else {\n\t                relatedView.el.appendChild(el);\n\t            }\n\t        }\n\t        return this;\n\t    },\n\n\t    isMounted: function() {\n\t        return this.el.parentNode !== null;\n\t    }\n\n\t});\n\n\n\n\tvar index$2 = ({\n\t\tGraph: Graph,\n\t\tattributes: attributes,\n\t\tLayersNames: LayersNames,\n\t\tPaperLayer: PaperLayer,\n\t\tCell: Cell,\n\t\tCellView: CellView,\n\t\tElement: Element$1,\n\t\tElementView: ElementView,\n\t\tLink: Link,\n\t\tLinkView: LinkView,\n\t\tPaper: Paper,\n\t\tToolView: ToolView,\n\t\tToolsView: ToolsView,\n\t\tHighlighterView: HighlighterView\n\t});\n\n\tvar DirectedGraph = {\n\n\t    exportElement: function(element) {\n\n\t        // The width and height of the element.\n\t        return element.size();\n\t    },\n\n\t    exportLink: function(link) {\n\n\t        var labelSize = link.get('labelSize') || {};\n\t        var edge = {\n\t            // The number of ranks to keep between the source and target of the edge.\n\t            minLen: link.get('minLen') || 1,\n\t            // The weight to assign edges. Higher weight edges are generally\n\t            // made shorter and straighter than lower weight edges.\n\t            weight: link.get('weight') || 1,\n\t            // Where to place the label relative to the edge.\n\t            // l = left, c = center r = right.\n\t            labelpos: link.get('labelPosition') || 'c',\n\t            // How many pixels to move the label away from the edge.\n\t            // Applies only when labelpos is l or r.\n\t            labeloffset: link.get('labelOffset') || 0,\n\t            // The width of the edge label in pixels.\n\t            width: labelSize.width || 0,\n\t            // The height of the edge label in pixels.\n\t            height: labelSize.height || 0\n\t        };\n\n\t        return edge;\n\t    },\n\n\t    importElement: function(opt, v, gl) {\n\n\t        var element = this.getCell(v);\n\t        var glNode = gl.node(v);\n\n\t        if (opt.setPosition) {\n\t            opt.setPosition(element, glNode);\n\t        } else {\n\t            element.set('position', {\n\t                x: glNode.x - glNode.width / 2,\n\t                y: glNode.y - glNode.height / 2\n\t            });\n\t        }\n\t    },\n\n\t    importLink: function(opt, edgeObj, gl) {\n\n\t        var SIMPLIFY_THRESHOLD = 0.001;\n\n\t        var link = this.getCell(edgeObj.name);\n\t        var glEdge = gl.edge(edgeObj);\n\t        var points = glEdge.points || [];\n\t        var polyline = new Polyline(points);\n\n\t        // check the `setLinkVertices` here for backwards compatibility\n\t        if (opt.setVertices || opt.setLinkVertices) {\n\t            if (isFunction(opt.setVertices)) {\n\t                opt.setVertices(link, points);\n\t            } else {\n\t                // simplify the `points` polyline\n\t                polyline.simplify({ threshold: SIMPLIFY_THRESHOLD });\n\t                var polylinePoints = polyline.points.map(function (point) { return (point.toJSON()); }); // JSON of points after simplification\n\t                var numPolylinePoints = polylinePoints.length; // number of points after simplification\n\t                // set simplified polyline points as link vertices\n\t                // remove first and last polyline points (= source/target sonnectionPoints)\n\t                link.set('vertices', polylinePoints.slice(1, numPolylinePoints - 1));\n\t            }\n\t        }\n\n\t        if (opt.setLabels && ('x' in glEdge) && ('y' in glEdge)) {\n\t            var labelPosition = { x: glEdge.x, y: glEdge.y };\n\t            if (isFunction(opt.setLabels)) {\n\t                opt.setLabels(link, labelPosition, points);\n\t            } else {\n\t                // convert the absolute label position to a relative position\n\t                // towards the closest point on the edge\n\t                var length = polyline.closestPointLength(labelPosition);\n\t                var closestPoint = polyline.pointAtLength(length);\n\t                var distance = (length / polyline.length());\n\t                var offset = new Point(labelPosition).difference(closestPoint).toJSON();\n\t                link.label(0, {\n\t                    position: {\n\t                        distance: distance,\n\t                        offset: offset\n\t                    }\n\t                });\n\t            }\n\t        }\n\t    },\n\n\t    layout: function(graphOrCells, opt) {\n\n\t        var graph;\n\n\t        if (graphOrCells instanceof Graph) {\n\t            graph = graphOrCells;\n\t        } else {\n\t            // Reset cells in dry mode so the graph reference is not stored on the cells.\n\t            // `sort: false` to prevent elements to change their order based on the z-index\n\t            graph = (new Graph()).resetCells(graphOrCells, { dry: true, sort: false });\n\t        }\n\n\t        // This is not needed anymore.\n\t        graphOrCells = null;\n\n\t        opt = defaults(opt || {}, {\n\t            resizeClusters: true,\n\t            clusterPadding: 10,\n\t            exportElement: this.exportElement,\n\t            exportLink: this.exportLink\n\t        });\n\n\t        /* eslint-disable no-undef */\n\t        var dagreUtil = opt.dagre || (typeof dagre !== 'undefined' ? dagre : undefined);\n\t        /* eslint-enable no-undef */\n\n\t        if (dagreUtil === undefined) { throw new Error('The the \"dagre\" utility is a mandatory dependency.'); }\n\n\t        // create a graphlib.Graph that represents the joint.dia.Graph\n\t        // var glGraph = graph.toGraphLib({\n\t        var glGraph = DirectedGraph.toGraphLib(graph, {\n\t            graphlib: opt.graphlib,\n\t            directed: true,\n\t            // We are about to use edge naming feature.\n\t            multigraph: true,\n\t            // We are able to layout graphs with embeds.\n\t            compound: true,\n\t            setNodeLabel: opt.exportElement,\n\t            setEdgeLabel: opt.exportLink,\n\t            setEdgeName: function(link) {\n\t                // Graphlib edges have no ids. We use edge name property\n\t                // to store and retrieve ids instead.\n\t                return link.id;\n\t            }\n\t        });\n\n\t        var glLabel = {};\n\t        var marginX = opt.marginX || 0;\n\t        var marginY = opt.marginY || 0;\n\n\t        // Dagre layout accepts options as lower case.\n\t        // Direction for rank nodes. Can be TB, BT, LR, or RL\n\t        if (opt.rankDir) { glLabel.rankdir = opt.rankDir; }\n\t        // Alignment for rank nodes. Can be UL, UR, DL, or DR\n\t        if (opt.align) { glLabel.align = opt.align; }\n\t        // Number of pixels that separate nodes horizontally in the layout.\n\t        if (opt.nodeSep) { glLabel.nodesep = opt.nodeSep; }\n\t        // Number of pixels that separate edges horizontally in the layout.\n\t        if (opt.edgeSep) { glLabel.edgesep = opt.edgeSep; }\n\t        // Number of pixels between each rank in the layout.\n\t        if (opt.rankSep) { glLabel.ranksep = opt.rankSep; }\n\t        // Type of algorithm to assign a rank to each node in the input graph.\n\t        // Possible values: network-simplex, tight-tree or longest-path\n\t        if (opt.ranker) { glLabel.ranker = opt.ranker; }\n\t        // Number of pixels to use as a margin around the left and right of the graph.\n\t        if (marginX) { glLabel.marginx = marginX; }\n\t        // Number of pixels to use as a margin around the top and bottom of the graph.\n\t        if (marginY) { glLabel.marginy = marginY; }\n\n\t        // Set the option object for the graph label.\n\t        glGraph.setGraph(glLabel);\n\n\t        // Executes the layout.\n\t        dagreUtil.layout(glGraph, { debugTiming: !!opt.debugTiming });\n\n\t        // Wrap all graph changes into a batch.\n\t        graph.startBatch('layout');\n\n\t        DirectedGraph.fromGraphLib(glGraph, {\n\t            importNode: this.importElement.bind(graph, opt),\n\t            importEdge: this.importLink.bind(graph, opt)\n\t        });\n\n\t        // // Update the graph.\n\t        // graph.fromGraphLib(glGraph, {\n\t        //     importNode: this.importElement.bind(graph, opt),\n\t        //     importEdge: this.importLink.bind(graph, opt)\n\t        // });\n\n\t        if (opt.resizeClusters) {\n\t            // Resize and reposition cluster elements (parents of other elements)\n\t            // to fit their children.\n\t            // 1. filter clusters only\n\t            // 2. map id on cells\n\t            // 3. sort cells by their depth (the deepest first)\n\t            // 4. resize cell to fit their direct children only.\n\t            var clusters = glGraph.nodes()\n\t                .filter(function(v) { return glGraph.children(v).length > 0; })\n\t                .map(graph.getCell.bind(graph))\n\t                .sort(function(aCluster, bCluster) {\n\t                    return bCluster.getAncestors().length - aCluster.getAncestors().length;\n\t                });\n\n\t            invoke(clusters, 'fitToChildren', { padding: opt.clusterPadding });\n\t        }\n\n\t        graph.stopBatch('layout');\n\n\t        // Width and height of the graph extended by margins.\n\t        var glSize = glGraph.graph();\n\t        // Return the bounding box of the graph after the layout.\n\t        return new Rect(\n\t            marginX,\n\t            marginY,\n\t            Math.abs(glSize.width - 2 * marginX),\n\t            Math.abs(glSize.height - 2 * marginY)\n\t        );\n\t    },\n\n\t    fromGraphLib: function(glGraph, opt) {\n\n\t        opt = opt || {};\n\n\t        var importNode = opt.importNode || noop;\n\t        var importEdge = opt.importEdge || noop;\n\t        var graph = (this instanceof Graph) ? this : new Graph;\n\n\t        // Import all nodes.\n\t        glGraph.nodes().forEach(function(node) {\n\t            importNode.call(graph, node, glGraph, graph, opt);\n\t        });\n\n\t        // Import all edges.\n\t        glGraph.edges().forEach(function(edge) {\n\t            importEdge.call(graph, edge, glGraph, graph, opt);\n\t        });\n\n\t        return graph;\n\t    },\n\n\t    // Create new graphlib graph from existing JointJS graph.\n\t    toGraphLib: function(graph, opt) {\n\n\t        opt = opt || {};\n\n\t        /* eslint-disable no-undef */\n\t        var graphlibUtil = opt.graphlib || (typeof graphlib !== 'undefined' ? graphlib : undefined);\n\t        /* eslint-enable no-undef */\n\n\t        if (graphlibUtil === undefined) { throw new Error('The the \"graphlib\" utility is a mandatory dependency.'); }\n\n\t        var glGraphType = pick(opt, 'directed', 'compound', 'multigraph');\n\t        var glGraph = new graphlibUtil.Graph(glGraphType);\n\t        var setNodeLabel = opt.setNodeLabel || noop;\n\t        var setEdgeLabel = opt.setEdgeLabel || noop;\n\t        var setEdgeName = opt.setEdgeName || noop;\n\t        var collection = graph.get('cells');\n\n\t        for (var i = 0, n = collection.length; i < n; i++) {\n\n\t            var cell = collection.at(i);\n\t            if (cell.isLink()) {\n\n\t                var source = cell.get('source');\n\t                var target = cell.get('target');\n\n\t                // Links that end at a point are ignored.\n\t                if (!source.id || !target.id) { break; }\n\n\t                // Note that if we are creating a multigraph we can name the edges. If\n\t                // we try to name edges on a non-multigraph an exception is thrown.\n\t                glGraph.setEdge(source.id, target.id, setEdgeLabel(cell), setEdgeName(cell));\n\n\t            } else {\n\n\t                glGraph.setNode(cell.id, setNodeLabel(cell));\n\n\t                // For the compound graphs we have to take embeds into account.\n\t                if (glGraph.isCompound() && cell.has('parent')) {\n\t                    var parentId = cell.get('parent');\n\t                    if (collection.has(parentId)) {\n\t                        // Make sure the parent cell is included in the graph (this can\n\t                        // happen when the layout is run on part of the graph only).\n\t                        glGraph.setParent(cell.id, parentId);\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        return glGraph;\n\t    }\n\t};\n\n\tGraph.prototype.toGraphLib = function(opt) {\n\n\t    return DirectedGraph.toGraphLib(this, opt);\n\t};\n\n\tGraph.prototype.fromGraphLib = function(glGraph, opt) {\n\n\t    return DirectedGraph.fromGraphLib.call(this, glGraph, opt);\n\t};\n\n\tvar env = {\n\n\t    _results: {},\n\n\t    _tests: {\n\n\t        svgforeignobject: function() {\n\t            return !!document.createElementNS &&\n\t                /SVGForeignObject/.test(({}).toString.call(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')));\n\t        }\n\t    },\n\n\t    addTest: function(name, fn) {\n\n\t        return this._tests[name] = fn;\n\t    },\n\n\t    test: function(name) {\n\n\t        var fn = this._tests[name];\n\n\t        if (!fn) {\n\t            throw new Error('Test not defined (\"' + name + '\"). Use `joint.env.addTest(name, fn) to add a new test.`');\n\t        }\n\n\t        var result = this._results[name];\n\n\t        if (typeof result !== 'undefined') {\n\t            return result;\n\t        }\n\n\t        try {\n\t            result = fn();\n\t        } catch (error) {\n\t            result = false;\n\t        }\n\n\t        // Cache the test result.\n\t        this._results[name] = result;\n\n\t        return result;\n\t    }\n\t};\n\n\tvar Generic = Element$1.define('basic.Generic', {\n\t    attrs: {\n\t        '.': { fill: '#ffffff', stroke: 'none' }\n\t    }\n\t});\n\n\tvar Rect$1 = Generic.define('basic.Rect', {\n\t    attrs: {\n\t        'rect': {\n\t            fill: '#ffffff',\n\t            stroke: '#000000',\n\t            width: 100,\n\t            height: 60\n\t        },\n\t        'text': {\n\t            fill: '#000000',\n\t            text: '',\n\t            'font-size': 14,\n\t            'ref-x': .5,\n\t            'ref-y': .5,\n\t            'text-anchor': 'middle',\n\t            'y-alignment': 'middle',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect/></g><text/></g>'\n\t});\n\n\tvar TextView = ElementView.extend({\n\n\t    presentationAttributes: ElementView.addPresentationAttributes({\n\t        // The element view is not automatically re-scaled to fit the model size\n\t        // when the attribute 'attrs' is changed.\n\t        attrs: ['SCALE']\n\t    }),\n\n\t    confirmUpdate: function() {\n\t        var flags = ElementView.prototype.confirmUpdate.apply(this, arguments);\n\t        if (this.hasFlag(flags, 'SCALE')) {\n\t            this.resize();\n\t            flags = this.removeFlag(flags, 'SCALE');\n\t        }\n\t        return flags;\n\t    }\n\t});\n\n\tvar Text = Generic.define('basic.Text', {\n\t    attrs: {\n\t        'text': {\n\t            'font-size': 18,\n\t            fill: '#000000'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><text/></g></g>',\n\t});\n\n\tvar Circle = Generic.define('basic.Circle', {\n\t    size: { width: 60, height: 60 },\n\t    attrs: {\n\t        'circle': {\n\t            fill: '#ffffff',\n\t            stroke: '#000000',\n\t            r: 30,\n\t            cx: 30,\n\t            cy: 30\n\t        },\n\t        'text': {\n\t            'font-size': 14,\n\t            text: '',\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-y': .5,\n\t            'y-alignment': 'middle',\n\t            fill: '#000000',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle/></g><text/></g>',\n\t});\n\n\tvar Ellipse$1 = Generic.define('basic.Ellipse', {\n\t    size: { width: 60, height: 40 },\n\t    attrs: {\n\t        'ellipse': {\n\t            fill: '#ffffff',\n\t            stroke: '#000000',\n\t            rx: 30,\n\t            ry: 20,\n\t            cx: 30,\n\t            cy: 20\n\t        },\n\t        'text': {\n\t            'font-size': 14,\n\t            text: '',\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-y': .5,\n\t            'y-alignment': 'middle',\n\t            fill: '#000000',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><ellipse/></g><text/></g>',\n\t});\n\n\tvar Polygon$1 = Generic.define('basic.Polygon', {\n\t    size: { width: 60, height: 40 },\n\t    attrs: {\n\t        'polygon': {\n\t            fill: '#ffffff',\n\t            stroke: '#000000'\n\t        },\n\t        'text': {\n\t            'font-size': 14,\n\t            text: '',\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-dy': 20,\n\t            'y-alignment': 'middle',\n\t            fill: '#000000',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon/></g><text/></g>',\n\t});\n\n\tvar Polyline$1 = Generic.define('basic.Polyline', {\n\t    size: { width: 60, height: 40 },\n\t    attrs: {\n\t        'polyline': {\n\t            fill: '#ffffff',\n\t            stroke: '#000000'\n\t        },\n\t        'text': {\n\t            'font-size': 14,\n\t            text: '',\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-dy': 20,\n\t            'y-alignment': 'middle',\n\t            fill: '#000000',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polyline/></g><text/></g>',\n\t});\n\n\tvar Image = Generic.define('basic.Image', {\n\t    attrs: {\n\t        'text': {\n\t            'font-size': 14,\n\t            text: '',\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-dy': 20,\n\t            'y-alignment': 'middle',\n\t            fill: '#000000',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><image/></g><text/></g>',\n\t});\n\n\tvar Path$1 = Generic.define('basic.Path', {\n\t    size: { width: 60, height: 60 },\n\t    attrs: {\n\t        'path': {\n\t            fill: '#ffffff',\n\t            stroke: '#000000'\n\t        },\n\t        'text': {\n\t            'font-size': 14,\n\t            text: '',\n\t            'text-anchor': 'middle',\n\t            'ref': 'path',\n\t            'ref-x': .5,\n\t            'ref-dy': 10,\n\t            fill: '#000000',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><path/></g><text/></g>',\n\t});\n\n\tvar Rhombus = Path$1.define('basic.Rhombus', {\n\t    attrs: {\n\t        'path': {\n\t            d: 'M 30 0 L 60 30 30 60 0 30 z'\n\t        },\n\t        'text': {\n\t            'ref-y': .5,\n\t            'ref-dy': null,\n\t            'y-alignment': 'middle'\n\t        }\n\t    }\n\t});\n\n\tvar svgForeignObjectSupported = env.test('svgforeignobject');\n\n\tvar TextBlock = Generic.define('basic.TextBlock', {\n\t    // see joint.css for more element styles\n\t    attrs: {\n\t        rect: {\n\t            fill: '#ffffff',\n\t            stroke: '#000000',\n\t            width: 80,\n\t            height: 100\n\t        },\n\t        text: {\n\t            fill: '#000000',\n\t            'font-size': 14,\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        },\n\t        '.content': {\n\t            text: '',\n\t            'ref-x': .5,\n\t            'ref-y': .5,\n\t            'y-alignment': 'middle',\n\t            'x-alignment': 'middle'\n\t        }\n\t    },\n\n\t    content: ''\n\t}, {\n\t    markup: [\n\t        '<g class=\"rotatable\">',\n\t        '<g class=\"scalable\"><rect/></g>',\n\t        svgForeignObjectSupported\n\t            ? '<foreignObject class=\"fobj\"><body xmlns=\"http://www.w3.org/1999/xhtml\"><div class=\"content\"/></body></foreignObject>'\n\t            : '<text class=\"content\"/>',\n\t        '</g>'\n\t    ].join(''),\n\n\t    initialize: function() {\n\n\t        this.listenTo(this, 'change:size', this.updateSize);\n\t        this.listenTo(this, 'change:content', this.updateContent);\n\t        this.updateSize(this, this.get('size'));\n\t        this.updateContent(this, this.get('content'));\n\t        Generic.prototype.initialize.apply(this, arguments);\n\t    },\n\n\t    updateSize: function(cell, size) {\n\n\t        // Selector `foreignObject' doesn't work across all browsers, we're using class selector instead.\n\t        // We have to clone size as we don't want attributes.div.style to be same object as attributes.size.\n\t        this.attr({\n\t            '.fobj': assign({}, size),\n\t            div: {\n\t                style: assign({}, size)\n\t            }\n\t        });\n\t    },\n\n\t    updateContent: function(cell, content) {\n\n\t        if (svgForeignObjectSupported) {\n\n\t            // Content element is a <div> element.\n\t            this.attr({\n\t                '.content': {\n\t                    html: sanitizeHTML(content)\n\t                }\n\t            });\n\n\t        } else {\n\n\t            // Content element is a <text> element.\n\t            // SVG elements don't have innerHTML attribute.\n\t            this.attr({\n\t                '.content': {\n\t                    text: content\n\t                }\n\t            });\n\t        }\n\t    },\n\n\t    // Here for backwards compatibility:\n\t    setForeignObjectSize: function() {\n\n\t        this.updateSize.apply(this, arguments);\n\t    },\n\n\t    // Here for backwards compatibility:\n\t    setDivContent: function() {\n\n\t        this.updateContent.apply(this, arguments);\n\t    }\n\t});\n\n\t// TextBlockView implements the fallback for IE when no foreignObject exists and\n\t// the text needs to be manually broken.\n\tvar TextBlockView = ElementView.extend({\n\n\t    presentationAttributes: svgForeignObjectSupported\n\t        ? ElementView.prototype.presentationAttributes\n\t        : ElementView.addPresentationAttributes({\n\t            content: ['CONTENT'],\n\t            size: ['CONTENT']\n\t        }),\n\n\t    initFlag: ['RENDER', 'CONTENT'],\n\n\t    confirmUpdate: function() {\n\t        var flags = ElementView.prototype.confirmUpdate.apply(this, arguments);\n\t        if (this.hasFlag(flags, 'CONTENT')) {\n\t            this.updateContent(this.model);\n\t            flags = this.removeFlag(flags, 'CONTENT');\n\t        }\n\t        return flags;\n\t    },\n\n\t    update: function(_, renderingOnlyAttrs) {\n\n\t        var model = this.model;\n\n\t        if (!svgForeignObjectSupported) {\n\n\t            // Update everything but the content first.\n\t            var noTextAttrs = omit(renderingOnlyAttrs || model.get('attrs'), '.content');\n\t            ElementView.prototype.update.call(this, model, noTextAttrs);\n\n\t            if (!renderingOnlyAttrs || has$2(renderingOnlyAttrs, '.content')) {\n\t                // Update the content itself.\n\t                this.updateContent(model, renderingOnlyAttrs);\n\t            }\n\n\t        } else {\n\n\t            ElementView.prototype.update.call(this, model, renderingOnlyAttrs);\n\t        }\n\t    },\n\n\t    updateContent: function(cell, renderingOnlyAttrs) {\n\n\t        // Create copy of the text attributes\n\t        var textAttrs = merge({}, (renderingOnlyAttrs || cell.get('attrs'))['.content']);\n\n\t        textAttrs = omit(textAttrs, 'text');\n\n\t        // Break the content to fit the element size taking into account the attributes\n\t        // set on the model.\n\t        var text = breakText(cell.get('content'), cell.get('size'), textAttrs, {\n\t            // measuring sandbox svg document\n\t            svgDocument: this.paper.svg\n\t        });\n\n\t        // Create a new attrs with same structure as the model attrs { text: { *textAttributes* }}\n\t        var attrs = setByPath({}, '.content', textAttrs, '/');\n\n\t        // Replace text attribute with the one we just processed.\n\t        attrs['.content'].text = text;\n\n\t        // Update the view using renderingOnlyAttributes parameter.\n\t        ElementView.prototype.update.call(this, cell, attrs);\n\t    }\n\t});\n\n\tvar basic = ({\n\t\tGeneric: Generic,\n\t\tRect: Rect$1,\n\t\tTextView: TextView,\n\t\tText: Text,\n\t\tCircle: Circle,\n\t\tEllipse: Ellipse$1,\n\t\tPolygon: Polygon$1,\n\t\tPolyline: Polyline$1,\n\t\tImage: Image,\n\t\tPath: Path$1,\n\t\tRhombus: Rhombus,\n\t\tTextBlock: TextBlock,\n\t\tTextBlockView: TextBlockView\n\t});\n\n\t// ELEMENTS\n\n\tvar Rectangle = Element$1.define('standard.Rectangle', {\n\t    attrs: {\n\t        body: {\n\t            refWidth: '100%',\n\t            refHeight: '100%',\n\t            strokeWidth: 2,\n\t            stroke: '#000000',\n\t            fill: '#FFFFFF'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'rect',\n\t        selector: 'body',\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar Circle$1 = Element$1.define('standard.Circle', {\n\t    attrs: {\n\t        body: {\n\t            refCx: '50%',\n\t            refCy: '50%',\n\t            refR: '50%',\n\t            strokeWidth: 2,\n\t            stroke: '#333333',\n\t            fill: '#FFFFFF'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'circle',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar Ellipse$2 = Element$1.define('standard.Ellipse', {\n\t    attrs: {\n\t        body: {\n\t            refCx: '50%',\n\t            refCy: '50%',\n\t            refRx: '50%',\n\t            refRy: '50%',\n\t            strokeWidth: 2,\n\t            stroke: '#333333',\n\t            fill: '#FFFFFF'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'ellipse',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar Path$2 = Element$1.define('standard.Path', {\n\t    attrs: {\n\t        body: {\n\t            refD: 'M 0 0 L 10 0 10 10 0 10 Z',\n\t            strokeWidth: 2,\n\t            stroke: '#333333',\n\t            fill: '#FFFFFF'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'path',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar Polygon$2 = Element$1.define('standard.Polygon', {\n\t    attrs: {\n\t        body: {\n\t            refPoints: '0 0 10 0 10 10 0 10',\n\t            strokeWidth: 2,\n\t            stroke: '#333333',\n\t            fill: '#FFFFFF'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'polygon',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar Polyline$2 = Element$1.define('standard.Polyline', {\n\t    attrs: {\n\t        body: {\n\t            refPoints: '0 0 10 0 10 10 0 10 0 0',\n\t            strokeWidth: 2,\n\t            stroke: '#333333',\n\t            fill: '#FFFFFF'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'polyline',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar Image$1 = Element$1.define('standard.Image', {\n\t    attrs: {\n\t        image: {\n\t            refWidth: '100%',\n\t            refHeight: '100%',\n\t            // xlinkHref: '[URL]'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'top',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '100%',\n\t            refY2: 10,\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'image',\n\t        selector: 'image'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar BorderedImage = Element$1.define('standard.BorderedImage', {\n\t    attrs: {\n\t        border: {\n\t            refWidth: '100%',\n\t            refHeight: '100%',\n\t            stroke: '#333333',\n\t            strokeWidth: 2\n\t        },\n\t        background: {\n\t            refWidth: -1,\n\t            refHeight: -1,\n\t            x: 0.5,\n\t            y: 0.5,\n\t            fill: '#FFFFFF'\n\t        },\n\t        image: {\n\t            // xlinkHref: '[URL]'\n\t            refWidth: -1,\n\t            refHeight: -1,\n\t            x: 0.5,\n\t            y: 0.5\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'top',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '100%',\n\t            refY2: 10,\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'rect',\n\t        selector: 'background',\n\t        attributes: {\n\t            'stroke': 'none'\n\t        }\n\t    }, {\n\t        tagName: 'image',\n\t        selector: 'image'\n\t    }, {\n\t        tagName: 'rect',\n\t        selector: 'border',\n\t        attributes: {\n\t            'fill': 'none'\n\t        }\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar EmbeddedImage = Element$1.define('standard.EmbeddedImage', {\n\t    attrs: {\n\t        body: {\n\t            refWidth: '100%',\n\t            refHeight: '100%',\n\t            stroke: '#333333',\n\t            fill: '#FFFFFF',\n\t            strokeWidth: 2\n\t        },\n\t        image: {\n\t            // xlinkHref: '[URL]'\n\t            refWidth: '30%',\n\t            refHeight: -20,\n\t            x: 10,\n\t            y: 10,\n\t            preserveAspectRatio: 'xMidYMin'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'top',\n\t            textAnchor: 'left',\n\t            refX: '30%',\n\t            refX2: 20, // 10 + 10\n\t            refY: 10,\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'rect',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'image',\n\t        selector: 'image'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar InscribedImage = Element$1.define('standard.InscribedImage', {\n\t    attrs: {\n\t        border: {\n\t            refRx: '50%',\n\t            refRy: '50%',\n\t            refCx: '50%',\n\t            refCy: '50%',\n\t            stroke: '#333333',\n\t            strokeWidth: 2\n\t        },\n\t        background: {\n\t            refRx: '50%',\n\t            refRy: '50%',\n\t            refCx: '50%',\n\t            refCy: '50%',\n\t            fill: '#FFFFFF'\n\t        },\n\t        image: {\n\t            // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%\n\t            refWidth: '68%',\n\t            refHeight: '68%',\n\t            // The image offset is calculated as (100% - 68%) / 2\n\t            refX: '16%',\n\t            refY: '16%',\n\t            preserveAspectRatio: 'xMidYMid'\n\t            // xlinkHref: '[URL]'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'top',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '100%',\n\t            refY2: 10,\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'ellipse',\n\t        selector: 'background'\n\t    }, {\n\t        tagName: 'image',\n\t        selector: 'image'\n\t    }, {\n\t        tagName: 'ellipse',\n\t        selector: 'border',\n\t        attributes: {\n\t            'fill': 'none'\n\t        }\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar HeaderedRectangle = Element$1.define('standard.HeaderedRectangle', {\n\t    attrs: {\n\t        body: {\n\t            refWidth: '100%',\n\t            refHeight: '100%',\n\t            strokeWidth: 2,\n\t            stroke: '#000000',\n\t            fill: '#FFFFFF'\n\t        },\n\t        header: {\n\t            refWidth: '100%',\n\t            height: 30,\n\t            strokeWidth: 2,\n\t            stroke: '#000000',\n\t            fill: '#FFFFFF'\n\t        },\n\t        headerText: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: 15,\n\t            fontSize: 16,\n\t            fill: '#333333'\n\t        },\n\t        bodyText: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            refY2: 15,\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'rect',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'rect',\n\t        selector: 'header'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'headerText'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'bodyText'\n\t    }]\n\t});\n\n\tvar CYLINDER_TILT = 10;\n\n\tvar Cylinder = Element$1.define('standard.Cylinder', {\n\t    attrs: {\n\t        body: {\n\t            lateralArea: CYLINDER_TILT,\n\t            fill: '#FFFFFF',\n\t            stroke: '#333333',\n\t            strokeWidth: 2\n\t        },\n\t        top: {\n\t            refCx: '50%',\n\t            cy: CYLINDER_TILT,\n\t            refRx: '50%',\n\t            ry: CYLINDER_TILT,\n\t            fill: '#FFFFFF',\n\t            stroke: '#333333',\n\t            strokeWidth: 2\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '100%',\n\t            refY2: 15,\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'path',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'ellipse',\n\t        selector: 'top'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }],\n\n\t    topRy: function(t, opt) {\n\t        // getter\n\t        if (t === undefined) { return this.attr('body/lateralArea'); }\n\n\t        // setter\n\t        var isPercentageSetter = isPercentage(t);\n\n\t        var bodyAttrs = { lateralArea: t };\n\t        var topAttrs = isPercentageSetter\n\t            ? { refCy: t, refRy: t, cy: null, ry: null }\n\t            : { refCy: null, refRy: null, cy: t, ry: t };\n\n\t        return this.attr({ body: bodyAttrs, top: topAttrs }, opt);\n\t    }\n\n\t}, {\n\t    attributes: {\n\t        lateralArea: {\n\t            set: function(t, refBBox) {\n\t                var isPercentageSetter = isPercentage(t);\n\t                if (isPercentageSetter) { t = parseFloat(t) / 100; }\n\n\t                var x = refBBox.x;\n\t                var y = refBBox.y;\n\t                var w = refBBox.width;\n\t                var h = refBBox.height;\n\n\t                // curve control point variables\n\t                var rx = w / 2;\n\t                var ry = isPercentageSetter ? (h * t) : t;\n\n\t                var kappa = V.KAPPA;\n\t                var cx = kappa * rx;\n\t                var cy = kappa * (isPercentageSetter ? (h * t) : t);\n\n\t                // shape variables\n\t                var xLeft = x;\n\t                var xCenter = x + (w / 2);\n\t                var xRight = x + w;\n\n\t                var ySideTop = y + ry;\n\t                var yCurveTop = ySideTop - ry;\n\t                var ySideBottom = y + h - ry;\n\t                var yCurveBottom = y + h;\n\n\t                // return calculated shape\n\t                var data = [\n\t                    'M', xLeft, ySideTop,\n\t                    'L', xLeft, ySideBottom,\n\t                    'C', x, (ySideBottom + cy), (xCenter - cx), yCurveBottom, xCenter, yCurveBottom,\n\t                    'C', (xCenter + cx), yCurveBottom, xRight, (ySideBottom + cy), xRight, ySideBottom,\n\t                    'L', xRight, ySideTop,\n\t                    'C', xRight, (ySideTop - cy), (xCenter + cx), yCurveTop, xCenter, yCurveTop,\n\t                    'C', (xCenter - cx), yCurveTop, xLeft, (ySideTop - cy), xLeft, ySideTop,\n\t                    'Z'\n\t                ];\n\t                return { d: data.join(' ') };\n\t            }\n\t        }\n\t    }\n\t});\n\n\tvar foLabelMarkup = {\n\t    tagName: 'foreignObject',\n\t    selector: 'foreignObject',\n\t    attributes: {\n\t        'overflow': 'hidden'\n\t    },\n\t    children: [{\n\t        tagName: 'div',\n\t        namespaceURI: 'http://www.w3.org/1999/xhtml',\n\t        selector: 'label',\n\t        style: {\n\t            width: '100%',\n\t            height: '100%',\n\t            position: 'static',\n\t            backgroundColor: 'transparent',\n\t            textAlign: 'center',\n\t            margin: 0,\n\t            padding: '0px 5px',\n\t            boxSizing: 'border-box',\n\t            display: 'flex',\n\t            alignItems: 'center',\n\t            justifyContent: 'center'\n\t        }\n\t    }]\n\t};\n\n\tvar svgLabelMarkup = {\n\t    tagName: 'text',\n\t    selector: 'label',\n\t    attributes: {\n\t        'text-anchor': 'middle'\n\t    }\n\t};\n\n\tvar labelMarkup = (env.test('svgforeignobject')) ? foLabelMarkup : svgLabelMarkup;\n\n\tvar TextBlock$1 = Element$1.define('standard.TextBlock', {\n\t    attrs: {\n\t        body: {\n\t            refWidth: '100%',\n\t            refHeight: '100%',\n\t            stroke: '#333333',\n\t            fill: '#ffffff',\n\t            strokeWidth: 2\n\t        },\n\t        foreignObject: {\n\t            refWidth: '100%',\n\t            refHeight: '100%'\n\t        },\n\t        label: {\n\t            style: {\n\t                fontSize: 14\n\t            }\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'rect',\n\t        selector: 'body'\n\t    }, labelMarkup]\n\t}, {\n\t    attributes: {\n\t        text: {\n\t            set: function(text, refBBox, node, attrs) {\n\t                if (node instanceof HTMLElement) {\n\t                    node.textContent = text;\n\t                } else {\n\t                    // No foreign object\n\t                    var style = attrs.style || {};\n\t                    var wrapValue = { text: text, width: -5, height: '100%' };\n\t                    var wrapAttrs = assign({ textVerticalAnchor: 'middle' }, style);\n\t                    attributes.textWrap.set.call(this, wrapValue, refBBox, node, wrapAttrs);\n\t                    return { fill: style.color || null };\n\t                }\n\t            },\n\t            position: function(text, refBBox, node) {\n\t                // No foreign object\n\t                if (node instanceof SVGElement) { return refBBox.center(); }\n\t            }\n\t        }\n\t    }\n\t});\n\n\t// LINKS\n\n\tvar Link$1 = Link.define('standard.Link', {\n\t    attrs: {\n\t        line: {\n\t            connection: true,\n\t            stroke: '#333333',\n\t            strokeWidth: 2,\n\t            strokeLinejoin: 'round',\n\t            targetMarker: {\n\t                'type': 'path',\n\t                'd': 'M 10 -5 0 0 10 5 z'\n\t            }\n\t        },\n\t        wrapper: {\n\t            connection: true,\n\t            strokeWidth: 10,\n\t            strokeLinejoin: 'round'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'path',\n\t        selector: 'wrapper',\n\t        attributes: {\n\t            'fill': 'none',\n\t            'cursor': 'pointer',\n\t            'stroke': 'transparent',\n\t            'stroke-linecap': 'round'\n\t        }\n\t    }, {\n\t        tagName: 'path',\n\t        selector: 'line',\n\t        attributes: {\n\t            'fill': 'none',\n\t            'pointer-events': 'none'\n\t        }\n\t    }]\n\t});\n\n\tvar DoubleLink = Link.define('standard.DoubleLink', {\n\t    attrs: {\n\t        line: {\n\t            connection: true,\n\t            stroke: '#DDDDDD',\n\t            strokeWidth: 4,\n\t            strokeLinejoin: 'round',\n\t            targetMarker: {\n\t                type: 'path',\n\t                stroke: '#000000',\n\t                d: 'M 10 -3 10 -10 -2 0 10 10 10 3'\n\t            }\n\t        },\n\t        outline: {\n\t            connection: true,\n\t            stroke: '#000000',\n\t            strokeWidth: 6,\n\t            strokeLinejoin: 'round'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'path',\n\t        selector: 'outline',\n\t        attributes: {\n\t            'fill': 'none'\n\t        }\n\t    }, {\n\t        tagName: 'path',\n\t        selector: 'line',\n\t        attributes: {\n\t            'fill': 'none'\n\t        }\n\t    }]\n\t});\n\n\tvar ShadowLink = Link.define('standard.ShadowLink', {\n\t    attrs: {\n\t        line: {\n\t            connection: true,\n\t            stroke: '#FF0000',\n\t            strokeWidth: 20,\n\t            strokeLinejoin: 'round',\n\t            targetMarker: {\n\t                'type': 'path',\n\t                'stroke': 'none',\n\t                'd': 'M 0 -10 -10 0 0 10 z'\n\t            },\n\t            sourceMarker: {\n\t                'type': 'path',\n\t                'stroke': 'none',\n\t                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n\t            }\n\t        },\n\t        shadow: {\n\t            connection: true,\n\t            refX: 3,\n\t            refY: 6,\n\t            stroke: '#000000',\n\t            strokeOpacity: 0.2,\n\t            strokeWidth: 20,\n\t            strokeLinejoin: 'round',\n\t            targetMarker: {\n\t                'type': 'path',\n\t                'd': 'M 0 -10 -10 0 0 10 z',\n\t                'stroke': 'none'\n\t            },\n\t            sourceMarker: {\n\t                'type': 'path',\n\t                'stroke': 'none',\n\t                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n\t            }\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'path',\n\t        selector: 'shadow',\n\t        attributes: {\n\t            'fill': 'none'\n\t        }\n\t    }, {\n\t        tagName: 'path',\n\t        selector: 'line',\n\t        attributes: {\n\t            'fill': 'none'\n\t        }\n\t    }]\n\t});\n\n\tvar standard = ({\n\t\tRectangle: Rectangle,\n\t\tCircle: Circle$1,\n\t\tEllipse: Ellipse$2,\n\t\tPath: Path$2,\n\t\tPolygon: Polygon$2,\n\t\tPolyline: Polyline$2,\n\t\tImage: Image$1,\n\t\tBorderedImage: BorderedImage,\n\t\tEmbeddedImage: EmbeddedImage,\n\t\tInscribedImage: InscribedImage,\n\t\tHeaderedRectangle: HeaderedRectangle,\n\t\tCylinder: Cylinder,\n\t\tTextBlock: TextBlock$1,\n\t\tLink: Link$1,\n\t\tDoubleLink: DoubleLink,\n\t\tShadowLink: ShadowLink\n\t});\n\n\t/**\n\t * @deprecated use the port api instead\n\t */\n\tvar Model = Generic.define('devs.Model', {\n\t    inPorts: [],\n\t    outPorts: [],\n\t    size: {\n\t        width: 80,\n\t        height: 80\n\t    },\n\t    attrs: {\n\t        '.': {\n\t            magnet: false\n\t        },\n\t        '.label': {\n\t            text: 'Model',\n\t            'ref-x': .5,\n\t            'ref-y': 10,\n\t            'font-size': 18,\n\t            'text-anchor': 'middle',\n\t            fill: '#000'\n\t        },\n\t        '.body': {\n\t            'ref-width': '100%',\n\t            'ref-height': '100%',\n\t            stroke: '#000'\n\t        }\n\t    },\n\t    ports: {\n\t        groups: {\n\t            'in': {\n\t                position: {\n\t                    name: 'left'\n\t                },\n\t                attrs: {\n\t                    '.port-label': {\n\t                        fill: '#000'\n\t                    },\n\t                    '.port-body': {\n\t                        fill: '#fff',\n\t                        stroke: '#000',\n\t                        r: 10,\n\t                        magnet: true\n\t                    }\n\t                },\n\t                label: {\n\t                    position: {\n\t                        name: 'left',\n\t                        args: {\n\t                            y: 10\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            'out': {\n\t                position: {\n\t                    name: 'right'\n\t                },\n\t                attrs: {\n\t                    '.port-label': {\n\t                        fill: '#000'\n\t                    },\n\t                    '.port-body': {\n\t                        fill: '#fff',\n\t                        stroke: '#000',\n\t                        r: 10,\n\t                        magnet: true\n\t                    }\n\t                },\n\t                label: {\n\t                    position: {\n\t                        name: 'right',\n\t                        args: {\n\t                            y: 10\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><rect class=\"body\"/><text class=\"label\"/></g>',\n\t    portMarkup: '<circle class=\"port-body\"/>',\n\t    portLabelMarkup: '<text class=\"port-label\"/>',\n\n\t    initialize: function() {\n\n\t        Generic.prototype.initialize.apply(this, arguments);\n\n\t        this.on('change:inPorts change:outPorts', this.updatePortItems, this);\n\t        this.updatePortItems();\n\t    },\n\n\t    updatePortItems: function(model, changed, opt) {\n\n\t        // Make sure all ports are unique.\n\t        var inPorts = uniq(this.get('inPorts'));\n\t        var outPorts = difference(uniq(this.get('outPorts')), inPorts);\n\n\t        var inPortItems = this.createPortItems('in', inPorts);\n\t        var outPortItems = this.createPortItems('out', outPorts);\n\n\t        this.prop('ports/items', inPortItems.concat(outPortItems), assign({ rewrite: true }, opt));\n\t    },\n\n\t    createPortItem: function(group, port) {\n\n\t        return {\n\t            id: port,\n\t            group: group,\n\t            attrs: {\n\t                '.port-label': {\n\t                    text: port\n\t                }\n\t            }\n\t        };\n\t    },\n\n\t    createPortItems: function(group, ports) {\n\n\t        return toArray(ports).map(this.createPortItem.bind(this, group));\n\t    },\n\n\t    _addGroupPort: function(port, group, opt) {\n\n\t        var ports = this.get(group);\n\t        return this.set(group, Array.isArray(ports) ? ports.concat(port) : [port], opt);\n\t    },\n\n\t    addOutPort: function(port, opt) {\n\n\t        return this._addGroupPort(port, 'outPorts', opt);\n\t    },\n\n\t    addInPort: function(port, opt) {\n\n\t        return this._addGroupPort(port, 'inPorts', opt);\n\t    },\n\n\t    _removeGroupPort: function(port, group, opt) {\n\n\t        return this.set(group, without(this.get(group), port), opt);\n\t    },\n\n\t    removeOutPort: function(port, opt) {\n\n\t        return this._removeGroupPort(port, 'outPorts', opt);\n\t    },\n\n\t    removeInPort: function(port, opt) {\n\n\t        return this._removeGroupPort(port, 'inPorts', opt);\n\t    },\n\n\t    _changeGroup: function(group, properties, opt) {\n\n\t        return this.prop('ports/groups/' + group, isObject$1(properties) ? properties : {}, opt);\n\t    },\n\n\t    changeInGroup: function(properties, opt) {\n\n\t        return this._changeGroup('in', properties, opt);\n\t    },\n\n\t    changeOutGroup: function(properties, opt) {\n\n\t        return this._changeGroup('out', properties, opt);\n\t    }\n\t});\n\n\tvar Atomic = Model.define('devs.Atomic', {\n\t    size: {\n\t        width: 80,\n\t        height: 80\n\t    },\n\t    attrs: {\n\t        '.label': {\n\t            text: 'Atomic'\n\t        }\n\t    }\n\t});\n\n\tvar Coupled = Model.define('devs.Coupled', {\n\t    size: {\n\t        width: 200,\n\t        height: 300\n\t    },\n\t    attrs: {\n\t        '.label': {\n\t            text: 'Coupled'\n\t        }\n\t    }\n\t});\n\n\tvar Link$2 = Link.define('devs.Link', {\n\t    attrs: {\n\t        '.connection': {\n\t            'stroke-width': 2\n\t        }\n\t    }\n\t});\n\n\tvar devs = ({\n\t\tModel: Model,\n\t\tAtomic: Atomic,\n\t\tCoupled: Coupled,\n\t\tLink: Link$2\n\t});\n\n\tvar Gate = Generic.define('logic.Gate', {\n\t    size: { width: 80, height: 40 },\n\t    attrs: {\n\t        '.': { magnet: false },\n\t        '.body': { width: 100, height: 50 },\n\t        circle: { r: 7, stroke: 'black', fill: 'transparent', 'stroke-width': 2 }\n\t    }\n\t}, {\n\t    operation: function() {\n\t        return true;\n\t    }\n\t});\n\n\tvar IO = Gate.define('logic.IO', {\n\t    size: { width: 60, height: 30 },\n\t    attrs: {\n\t        '.body': { fill: 'white', stroke: 'black', 'stroke-width': 2 },\n\t        '.wire': { ref: '.body', 'ref-y': .5, stroke: 'black' },\n\t        text: {\n\t            fill: 'black',\n\t            ref: '.body', 'ref-x': .5, 'ref-y': .5, 'y-alignment': 'middle',\n\t            'text-anchor': 'middle',\n\t            'font-weight': 'bold',\n\t            'font-variant': 'small-caps',\n\t            'text-transform': 'capitalize',\n\t            'font-size': '14px'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"body\"/></g><path class=\"wire\"/><circle/><text/></g>',\n\t});\n\n\tvar Input = IO.define('logic.Input', {\n\t    attrs: {\n\t        '.wire': { 'ref-dx': 0, d: 'M 0 0 L 23 0' },\n\t        circle: { ref: '.body', 'ref-dx': 30, 'ref-y': 0.5, magnet: true, 'class': 'output', port: 'out' },\n\t        text: { text: 'input' }\n\t    }\n\t});\n\n\tvar Output = IO.define('logic.Output', {\n\t    attrs: {\n\t        '.wire': { 'ref-x': 0, d: 'M 0 0 L -23 0' },\n\t        circle: { ref: '.body', 'ref-x': -30, 'ref-y': 0.5, magnet: 'passive', 'class': 'input', port: 'in' },\n\t        text: { text: 'output' }\n\t    }\n\t});\n\n\tvar Gate11 = Gate.define('logic.Gate11', {\n\t    attrs: {\n\t        '.input': { ref: '.body', 'ref-x': -2, 'ref-y': 0.5, magnet: 'passive', port: 'in' },\n\t        '.output': { ref: '.body', 'ref-dx': 2, 'ref-y': 0.5, magnet: true, port: 'out' }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><image class=\"body\"/></g><circle class=\"input\"/><circle class=\"output\"/></g>',\n\t});\n\n\tvar Gate21 = Gate.define('logic.Gate21', {\n\t    attrs: {\n\t        '.input1': { ref: '.body', 'ref-x': -2, 'ref-y': 0.3, magnet: 'passive', port: 'in1' },\n\t        '.input2': { ref: '.body', 'ref-x': -2, 'ref-y': 0.7, magnet: 'passive', port: 'in2' },\n\t        '.output': { ref: '.body', 'ref-dx': 2, 'ref-y': 0.5, magnet: true, port: 'out' }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><image class=\"body\"/></g><circle class=\"input input1\"/><circle  class=\"input input2\"/><circle class=\"output\"/></g>',\n\t});\n\n\tvar Repeater = Gate11.define('logic.Repeater', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzIuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICA8L2c+Cjwvc3ZnPgo=' }}\n\t}, {\n\t    operation: function(input) {\n\t        return input;\n\t    }\n\t});\n\n\tvar Not = Gate11.define('logic.Not', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzkuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDI2NzEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzYiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA4MCwyNSBBIDQsNCAwIDEgMSA3MiwyNSBBIDQsNCAwIDEgMSA4MCwyNSB6IgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEsMCkiIC8+CiAgPC9nPgo8L3N2Zz4K' }}\n\t}, {\n\t    operation: function(input) {\n\t        return !input;\n\t    }\n\t});\n\n\tvar Or = Gate21.define('logic.Or', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik9SIEFOU0kuc3ZnIgogICBpbmtzY2FwZTpvdXRwdXRfZXh0ZW5zaW9uPSJvcmcuaW5rc2NhcGUub3V0cHV0LnN2Zy5pbmtzY2FwZSI+CiAgPGRlZnMKICAgICBpZD0iZGVmczQiPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTAgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjcxNCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iMSA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMC41IDogMC4zMzMzMzMzMyA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODA2IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODE5IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjM3Mi4wNDcyNCA6IDM1MC43ODczOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI3NDQuMDk0NDggOiA1MjYuMTgxMDkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzc3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49Ijc1IDogNDAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTUwIDogNjAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDYwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTMyNzUiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNTAgOiAzMy4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTAwIDogNTAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTU1MzMiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzIgOiAyMS4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNjQgOiAzMiA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMzIgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjU1NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDE2LjY2NjY2NyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDI1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAyNSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iNCIKICAgICBpbmtzY2FwZTpjeD0iMTEzLjAwMDM5IgogICAgIGlua3NjYXBlOmN5PSIxMi44OTM3MzEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImcyNTYwIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTpncmlkLWJib3g9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1wb2ludHM9InRydWUiCiAgICAgZ3JpZHRvbGVyYW5jZT0iMTAwMDAiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxMzk5IgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9Ijg3NCIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMzciCiAgICAgaW5rc2NhcGU6d2luZG93LXk9Ii00IgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNzAsMjUgYyAyMCwwIDI1LDAgMjUsMCIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMSwxNSA1LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzIsMzUgNSwzNSIKICAgICAgIGlkPSJwYXRoMzk0NCIgLz4KICAgIDxnCiAgICAgICBpZD0iZzI1NjAiCiAgICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI2LjUsLTM5LjUpIj4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICA8L2c+Cjwvc3ZnPgo=' }}\n\t}, {\n\t    operation: function(input1, input2) {\n\t        return input1 || input2;\n\t    }\n\t});\n\n\tvar And = Gate21.define('logic.And', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IkFORCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI4IgogICAgIGlua3NjYXBlOmN4PSI1Ni42OTgzNDgiCiAgICAgaW5rc2NhcGU6Y3k9IjI1LjMyNjg5OSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZvbnQtc2l6ZTptZWRpdW07Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDt0ZXh0LWluZGVudDowO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6bm9ybWFsO2xldHRlci1zcGFjaW5nOm5vcm1hbDt3b3JkLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7ZGlyZWN0aW9uOmx0cjtibG9jay1wcm9ncmVzc2lvbjp0Yjt3cml0aW5nLW1vZGU6bHItdGI7dGV4dC1hbmNob3I6c3RhcnQ7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDozO21hcmtlcjpub25lO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGU7Zm9udC1mYW1pbHk6Qml0c3RyZWFtIFZlcmEgU2FuczstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkJpdHN0cmVhbSBWZXJhIFNhbnMiCiAgICAgICBkPSJNIDMwLDUgTCAzMCw2LjQyODU3MTQgTCAzMCw0My41NzE0MjkgTCAzMCw0NSBMIDMxLjQyODU3MSw0NSBMIDUwLjQ3NjE5LDQ1IEMgNjEuNzQ0MDk4LDQ1IDcwLjQ3NjE5LDM1Ljk5OTk1NSA3MC40NzYxOSwyNSBDIDcwLjQ3NjE5LDE0LjAwMDA0NSA2MS43NDQwOTksNS4wMDAwMDAyIDUwLjQ3NjE5LDUgQyA1MC40NzYxOSw1IDUwLjQ3NjE5LDUgMzEuNDI4NTcxLDUgTCAzMCw1IHogTSAzMi44NTcxNDMsNy44NTcxNDI5IEMgNDAuODM0MjY0LDcuODU3MTQyOSA0NS45MTgzNjgsNy44NTcxNDI5IDQ4LjA5NTIzOCw3Ljg1NzE0MjkgQyA0OS4yODU3MTQsNy44NTcxNDI5IDQ5Ljg4MDk1Miw3Ljg1NzE0MjkgNTAuMTc4NTcxLDcuODU3MTQyOSBDIDUwLjMyNzM4MSw3Ljg1NzE0MjkgNTAuNDA5MjI3LDcuODU3MTQyOSA1MC40NDY0MjksNy44NTcxNDI5IEMgNTAuNDY1MDI5LDcuODU3MTQyOSA1MC40NzE1NDMsNy44NTcxNDI5IDUwLjQ3NjE5LDcuODU3MTQyOSBDIDYwLjIzNjg1Myw3Ljg1NzE0MyA2Ny4xNDI4NTcsMTUuNDk3MDk4IDY3LjE0Mjg1NywyNSBDIDY3LjE0Mjg1NywzNC41MDI5MDIgNTkuNzYwNjYyLDQyLjE0Mjg1NyA1MCw0Mi4xNDI4NTcgTCAzMi44NTcxNDMsNDIuMTQyODU3IEwgMzIuODU3MTQzLDcuODU3MTQyOSB6IgogICAgICAgaWQ9InBhdGgyODg0IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2NjY2NzY2NjY3Nzc3NzY2NjIiAvPgogIDwvZz4KPC9zdmc+Cg==' }}\n\n\t}, {\n\t    operation: function(input1, input2) {\n\t        return input1 && input2;\n\t    }\n\t});\n\n\tvar Nor = Gate21.define('logic.Nor', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjEiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjY3NzY0NCIKICAgICBpbmtzY2FwZTpjeT0iMjIuMTAyMzQ0IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjM3IgogICAgIGlua3NjYXBlOndpbmRvdy15PSItNCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc5LDI1IEMgOTksMjUgOTUsMjUgOTUsMjUiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHNvZGlwb2RpOnR5cGU9ImFyYyIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgICBpZD0icGF0aDI2MDQiCiAgICAgICAgIHNvZGlwb2RpOmN4PSI3NSIKICAgICAgICAgc29kaXBvZGk6Y3k9IjI1IgogICAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgICAgc29kaXBvZGk6cnk9IjQiCiAgICAgICAgIGQ9Ik0gNzksMjUgQSA0LDQgMCAxIDEgNzEsMjUgQSA0LDQgMCAxIDEgNzksMjUgeiIKICAgICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTI2LjUsMzkuNSkiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K' }}\n\t}, {\n\t    operation: function(input1, input2) {\n\t        return !(input1 || input2);\n\t    }\n\t});\n\n\tvar Nand = Gate21.define('logic.Nand', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5BTkQgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iMTYiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjI4MzMwNyIKICAgICBpbmtzY2FwZTpjeT0iMTYuNDQyODQzIgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzksMjUgQyA5MS44LDI1IDk1LDI1IDk1LDI1IgogICAgICAgaWQ9InBhdGgzMDU5IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMxLDE1IDUsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMiwzNSA1LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MzttYXJrZXI6bm9uZTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlO2ZvbnQtZmFtaWx5OkJpdHN0cmVhbSBWZXJhIFNhbnM7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpCaXRzdHJlYW0gVmVyYSBTYW5zIgogICAgICAgZD0iTSAzMCw1IEwgMzAsNi40Mjg1NzE0IEwgMzAsNDMuNTcxNDI5IEwgMzAsNDUgTCAzMS40Mjg1NzEsNDUgTCA1MC40NzYxOSw0NSBDIDYxLjc0NDA5OCw0NSA3MC40NzYxOSwzNS45OTk5NTUgNzAuNDc2MTksMjUgQyA3MC40NzYxOSwxNC4wMDAwNDUgNjEuNzQ0MDk5LDUuMDAwMDAwMiA1MC40NzYxOSw1IEMgNTAuNDc2MTksNSA1MC40NzYxOSw1IDMxLjQyODU3MSw1IEwgMzAsNSB6IE0gMzIuODU3MTQzLDcuODU3MTQyOSBDIDQwLjgzNDI2NCw3Ljg1NzE0MjkgNDUuOTE4MzY4LDcuODU3MTQyOSA0OC4wOTUyMzgsNy44NTcxNDI5IEMgNDkuMjg1NzE0LDcuODU3MTQyOSA0OS44ODA5NTIsNy44NTcxNDI5IDUwLjE3ODU3MSw3Ljg1NzE0MjkgQyA1MC4zMjczODEsNy44NTcxNDI5IDUwLjQwOTIyNyw3Ljg1NzE0MjkgNTAuNDQ2NDI5LDcuODU3MTQyOSBDIDUwLjQ2NTAyOSw3Ljg1NzE0MjkgNTAuNDcxNTQzLDcuODU3MTQyOSA1MC40NzYxOSw3Ljg1NzE0MjkgQyA2MC4yMzY4NTMsNy44NTcxNDMgNjcuMTQyODU3LDE1LjQ5NzA5OCA2Ny4xNDI4NTcsMjUgQyA2Ny4xNDI4NTcsMzQuNTAyOTAyIDU5Ljc2MDY2Miw0Mi4xNDI4NTcgNTAsNDIuMTQyODU3IEwgMzIuODU3MTQzLDQyLjE0Mjg1NyBMIDMyLjg1NzE0Myw3Ljg1NzE0MjkgeiIKICAgICAgIGlkPSJwYXRoMjg4NCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2Njc2NjY2Nzc3Nzc2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDQwMDgiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg==' }}\n\t}, {\n\t    operation: function(input1, input2) {\n\t        return !(input1 && input2);\n\t    }\n\t});\n\n\tvar Xor = Gate21.define('logic.Xor', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhPUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjUuNjU2ODU0MiIKICAgICBpbmtzY2FwZTpjeD0iMjUuOTM4MTE2IgogICAgIGlua3NjYXBlOmN5PSIxNy4yMzAwNSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzAuMzg1NzE3LDE1IEwgNC45OTk5OTk4LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5NzY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEuMzYyMDkxLDM1IEwgNC45OTk5OTk4LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPGcKICAgICAgIGlkPSJnMjU2MCIKICAgICAgIGlua3NjYXBlOmxhYmVsPSJMYXllciAxIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYuNSwtMzkuNSkiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM1MTYiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi4yNSw4MS41MDAwMDUgQyAtMy44NDczNzQsODQuMTQ0NDA1IC00LjUsODQuNTAwMDA1IC00LjUsODQuNTAwMDA1IEwgLTguMTU2MjUsODQuNTAwMDA1IEwgLTYuMTU2MjUsODIuMDYyNTA1IEMgLTYuMTU2MjUsODIuMDYyNTA1IC0wLjUsNzUuMDYyNDUxIC0wLjUsNjQuNSBDIC0wLjUsNTMuOTM3NTQ5IC02LjE1NjI1LDQ2LjkzNzUgLTYuMTU2MjUsNDYuOTM3NSBMIC04LjE1NjI1LDQ0LjUgTCAtNC41LDQ0LjUgQyAtMy43MTg3NSw0NS40Mzc1IC0zLjA3ODEyNSw0Ni4xNTYyNSAtMi4yODEyNSw0Ny41IEMgLTAuNDA4NTMxLDUwLjU5OTgxNSAyLjUsNTYuNTI2NjQ2IDIuNSw2NC41IEMgMi41LDcyLjQ1MDY1IC0wLjM5NjY5Nyw3OC4zNzk0MjUgLTIuMjUsODEuNTAwMDA1IHoiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY3NjY2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K' }}\n\t}, {\n\t    operation: function(input1, input2) {\n\t        return (!input1 || input2) && (input1 || !input2);\n\t    }\n\t});\n\n\tvar Xnor = Gate21.define('logic.Xnor', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhOT1IgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNTU3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTYuNjY2NjY3IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDI1IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI0IgogICAgIGlua3NjYXBlOmN4PSI5NS43MjM2NiIKICAgICBpbmtzY2FwZTpjeT0iLTI2Ljc3NTAyMyIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjAwMDAwMDI0O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc4LjMzMzMzMiwyNSBDIDkxLjY2NjY2NiwyNSA5NSwyNSA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMC4zODU3MTcsMTUgTCA0Ljk5OTk5OTgsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk3NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMS4zNjIwOTEsMzUgTCA0Ljk5OTk5OTgsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMzUxNiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjI1LDgxLjUwMDAwNSBDIC0zLjg0NzM3NCw4NC4xNDQ0MDUgLTQuNSw4NC41MDAwMDUgLTQuNSw4NC41MDAwMDUgTCAtOC4xNTYyNSw4NC41MDAwMDUgTCAtNi4xNTYyNSw4Mi4wNjI1MDUgQyAtNi4xNTYyNSw4Mi4wNjI1MDUgLTAuNSw3NS4wNjI0NTEgLTAuNSw2NC41IEMgLTAuNSw1My45Mzc1NDkgLTYuMTU2MjUsNDYuOTM3NSAtNi4xNTYyNSw0Ni45Mzc1IEwgLTguMTU2MjUsNDQuNSBMIC00LjUsNDQuNSBDIC0zLjcxODc1LDQ1LjQzNzUgLTMuMDc4MTI1LDQ2LjE1NjI1IC0yLjI4MTI1LDQ3LjUgQyAtMC40MDg1MzEsNTAuNTk5ODE1IDIuNSw1Ni41MjY2NDYgMi41LDY0LjUgQyAyLjUsNzIuNDUwNjUgLTAuMzk2Njk3LDc4LjM3OTQyNSAtMi4yNSw4MS41MDAwMDUgeiIKICAgICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2Njc2NjY2NzYyIgLz4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDM1NTEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg==' }}\n\t}, {\n\t    operation: function(input1, input2) {\n\t        return (!input1 || !input2) && (input1 || input2);\n\t    }\n\t});\n\n\tvar Wire = Link.define('logic.Wire', {\n\t    attrs: {\n\t        '.connection': { 'stroke-width': 2 },\n\t        '.marker-vertex': { r: 7 }\n\t    },\n\n\t    router: { name: 'orthogonal' },\n\t    connector: { name: 'rounded', args: { radius: 10 }}\n\t}, {\n\t    arrowheadMarkup: [\n\t        '<g class=\"marker-arrowhead-group marker-arrowhead-group-<%= end %>\">',\n\t        '<circle class=\"marker-arrowhead\" end=\"<%= end %>\" r=\"7\"/>',\n\t        '</g>'\n\t    ].join(''),\n\n\t    vertexMarkup: [\n\t        '<g class=\"marker-vertex-group\" transform=\"translate(<%= x %>, <%= y %>)\">',\n\t        '<circle class=\"marker-vertex\" idx=\"<%= idx %>\" r=\"10\" />',\n\t        '<g class=\"marker-vertex-remove-group\">',\n\t        '<path class=\"marker-vertex-remove-area\" idx=\"<%= idx %>\" d=\"M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z\" transform=\"translate(5, -33)\"/>',\n\t        '<path class=\"marker-vertex-remove\" idx=\"<%= idx %>\" transform=\"scale(.8) translate(9.5, -37)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\">',\n\t        '<title>Remove vertex.</title>',\n\t        '</path>',\n\t        '</g>',\n\t        '</g>'\n\t    ].join('')\n\t});\n\n\tvar logic = ({\n\t\tGate: Gate,\n\t\tIO: IO,\n\t\tInput: Input,\n\t\tOutput: Output,\n\t\tGate11: Gate11,\n\t\tGate21: Gate21,\n\t\tRepeater: Repeater,\n\t\tNot: Not,\n\t\tOr: Or,\n\t\tAnd: And,\n\t\tNor: Nor,\n\t\tNand: Nand,\n\t\tXor: Xor,\n\t\tXnor: Xnor,\n\t\tWire: Wire\n\t});\n\n\tvar KingWhite = Generic.define('chess.KingWhite', {\n\t    size: { width: 42, height: 38 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\"><path      d=\"M 22.5,11.63 L 22.5,6\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path      d=\"M 20,8 L 25,8\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path      d=\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\"      style=\"fill:#ffffff; stroke:#000000; stroke-linecap:butt; stroke-linejoin:miter;\" />    <path      d=\"M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z \"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 11.5,30 C 17,27 27,27 32.5,30\"      style=\"fill:none; stroke:#000000;\" />    <path      d=\"M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5\"      style=\"fill:none; stroke:#000000;\" />    <path      d=\"M 11.5,37 C 17,34 27,34 32.5,37\"      style=\"fill:none; stroke:#000000;\" />  </g></g></g>'\n\t});\n\n\tvar KingBlack = Generic.define('chess.KingBlack', {\n\t    size: { width: 42, height: 38 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path       d=\"M 22.5,11.63 L 22.5,6\"       style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\"       id=\"path6570\" />    <path       d=\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\"       style=\"fill:#000000;fill-opacity:1; stroke-linecap:butt; stroke-linejoin:miter;\" />    <path       d=\"M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z \"       style=\"fill:#000000; stroke:#000000;\" />    <path       d=\"M 20,8 L 25,8\"       style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path       d=\"M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.51,26.6 L 22.5,24.5 C 20,18 9.906,14 6.997,19.85 C 4.5,25.5 11.85,28.85 11.85,28.85\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 11.5,30 C 17,27 27,27 32.5,30 M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5 M 11.5,37 C 17,34 27,34 32.5,37\"       style=\"fill:none; stroke:#ffffff;\" />  </g></g></g>'\n\t});\n\n\tvar QueenWhite = Generic.define('chess.QueenWhite', {\n\t    size: { width: 42, height: 38 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(-1,-1)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(15.5,-5.5)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(32,-1)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(7,-4.5)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(24,-4)\" />    <path      d=\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38,14 L 31,25 L 31,11 L 25.5,24.5 L 22.5,9.5 L 19.5,24.5 L 14,10.5 L 14,25 L 7,14 L 9,26 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11.5,30 C 15,29 30,29 33.5,30\"      style=\"fill:none;\" />    <path      d=\"M 12,33.5 C 18,32.5 27,32.5 33,33.5\"      style=\"fill:none;\" />  </g></g></g>'\n\t});\n\n\tvar QueenBlack = Generic.define('chess.QueenBlack', {\n\t    size: { width: 42, height: 38 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#000000; stroke:none;\">      <circle cx=\"6\"    cy=\"12\" r=\"2.75\" />      <circle cx=\"14\"   cy=\"9\"  r=\"2.75\" />      <circle cx=\"22.5\" cy=\"8\"  r=\"2.75\" />      <circle cx=\"31\"   cy=\"9\"  r=\"2.75\" />      <circle cx=\"39\"   cy=\"12\" r=\"2.75\" />    </g>    <path       d=\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\"       style=\"stroke-linecap:butt; stroke:#000000;\" />    <path       d=\"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z\"       style=\"stroke-linecap:butt;\" />    <path       d=\"M 11,38.5 A 35,35 1 0 0 34,38.5\"       style=\"fill:none; stroke:#000000; stroke-linecap:butt;\" />    <path       d=\"M 11,29 A 35,35 1 0 1 34,29\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 12.5,31.5 L 32.5,31.5\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 11.5,34.5 A 35,35 1 0 0 33.5,34.5\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 10.5,37.5 A 35,35 1 0 0 34.5,37.5\"       style=\"fill:none; stroke:#ffffff;\" />  </g></g></g>'\n\t});\n\n\tvar RookWhite = Generic.define('chess.RookWhite', {\n\t    size: { width: 32, height: 34 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14\"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 34,14 L 31,17 L 14,17 L 11,14\" />    <path      d=\"M 31,17 L 31,29.5 L 14,29.5 L 14,17\"      style=\"stroke-linecap:butt; stroke-linejoin:miter;\" />    <path      d=\"M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5\" />    <path      d=\"M 11,14 L 34,14\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />  </g></g></g>'\n\t});\n\n\tvar RookBlack = Generic.define('chess.RookBlack', {\n\t    size: { width: 32, height: 34 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z \"      style=\"stroke-linecap:butt;stroke-linejoin:miter;\" />    <path      d=\"M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,35.5 L 33,35.5 L 33,35.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 13,31.5 L 32,31.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 14,29.5 L 31,29.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 14,16.5 L 31,16.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 11,14 L 34,14\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />  </g></g></g>'\n\t});\n\n\tvar BishopWhite = Generic.define('chess.BishopWhite', {\n\t    size: { width: 38, height: 38 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#ffffff; stroke:#000000; stroke-linecap:butt;\">       <path        d=\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z\" />      <path        d=\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" />      <path        d=\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" />    </g>    <path      d=\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />  </g></g></g>'\n\t});\n\n\tvar BishopBlack = Generic.define('chess.BishopBlack', {\n\t    size: { width: 38, height: 38 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#000000; stroke:#000000; stroke-linecap:butt;\">       <path        d=\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z\" />      <path        d=\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" />      <path        d=\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" />    </g>    <path       d=\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\"       style=\"fill:none; stroke:#ffffff; stroke-linejoin:miter;\" />  </g></g></g>'\n\t});\n\n\tvar KnightWhite = Generic.define('chess.KnightWhite', {\n\t    size: { width: 38, height: 37 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\"      transform=\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\"      style=\"fill:#000000; stroke:#000000;\" />  </g></g></g>'\n\t});\n\n\tvar KnightBlack = Generic.define('chess.KnightBlack', {\n\t    size: { width: 38, height: 37 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\"      style=\"fill:#ffffff; stroke:#ffffff;\" />    <path      d=\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\"      transform=\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\"      style=\"fill:#ffffff; stroke:#ffffff;\" />    <path      d=\"M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z \"      style=\"fill:#ffffff; stroke:none;\" />  </g></g></g>'\n\t});\n\n\tvar PawnWhite = Generic.define('chess.PawnWhite', {\n\t    size: { width: 28, height: 33 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><path d=\"M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z \"  style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\" /></g></g>'\n\t});\n\n\tvar PawnBlack = Generic.define('chess.PawnBlack', {\n\t    size: { width: 28, height: 33 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><path d=\"M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z \"  style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\" /></g></g>'\n\t});\n\n\tvar chess = ({\n\t\tKingWhite: KingWhite,\n\t\tKingBlack: KingBlack,\n\t\tQueenWhite: QueenWhite,\n\t\tQueenBlack: QueenBlack,\n\t\tRookWhite: RookWhite,\n\t\tRookBlack: RookBlack,\n\t\tBishopWhite: BishopWhite,\n\t\tBishopBlack: BishopBlack,\n\t\tKnightWhite: KnightWhite,\n\t\tKnightBlack: KnightBlack,\n\t\tPawnWhite: PawnWhite,\n\t\tPawnBlack: PawnBlack\n\t});\n\n\tvar Entity = Element$1.define('erd.Entity', {\n\t    size: { width: 150, height: 60 },\n\t    attrs: {\n\t        '.outer': {\n\t            fill: '#2ECC71', stroke: '#27AE60', 'stroke-width': 2,\n\t            points: '100,0 100,60 0,60 0,0'\n\t        },\n\t        '.inner': {\n\t            fill: '#2ECC71', stroke: '#27AE60', 'stroke-width': 2,\n\t            points: '95,5 95,55 5,55 5,5',\n\t            display: 'none'\n\t        },\n\t        text: {\n\t            text: 'Entity',\n\t            'font-family': 'Arial', 'font-size': 14,\n\t            'ref-x': .5, 'ref-y': .5,\n\t            'y-alignment': 'middle', 'text-anchor': 'middle'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon class=\"outer\"/><polygon class=\"inner\"/></g><text/></g>',\n\t});\n\n\tvar WeakEntity = Entity.define('erd.WeakEntity', {\n\t    attrs: {\n\t        '.inner': { display: 'auto' },\n\t        text: { text: 'Weak Entity' }\n\t    }\n\t});\n\n\tvar Relationship = Element$1.define('erd.Relationship', {\n\t    size: { width: 80, height: 80 },\n\t    attrs: {\n\t        '.outer': {\n\t            fill: '#3498DB', stroke: '#2980B9', 'stroke-width': 2,\n\t            points: '40,0 80,40 40,80 0,40'\n\t        },\n\t        '.inner': {\n\t            fill: '#3498DB', stroke: '#2980B9', 'stroke-width': 2,\n\t            points: '40,5 75,40 40,75 5,40',\n\t            display: 'none'\n\t        },\n\t        text: {\n\t            text: 'Relationship',\n\t            'font-family': 'Arial', 'font-size': 12,\n\t            'ref-x': .5, 'ref-y': .5,\n\t            'y-alignment': 'middle', 'text-anchor': 'middle'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon class=\"outer\"/><polygon class=\"inner\"/></g><text/></g>',\n\t});\n\n\tvar IdentifyingRelationship = Relationship.define('erd.IdentifyingRelationship', {\n\t    attrs: {\n\t        '.inner': { display: 'auto' },\n\t        text: { text: 'Identifying' }\n\t    }\n\t});\n\n\tvar Attribute = Element$1.define('erd.Attribute', {\n\t    size: { width: 100, height: 50 },\n\t    attrs: {\n\t        'ellipse': {\n\t            transform: 'translate(50, 25)'\n\t        },\n\t        '.outer': {\n\t            stroke: '#D35400', 'stroke-width': 2,\n\t            cx: 0, cy: 0, rx: 50, ry: 25,\n\t            fill: '#E67E22'\n\t        },\n\t        '.inner': {\n\t            stroke: '#D35400', 'stroke-width': 2,\n\t            cx: 0, cy: 0, rx: 45, ry: 20,\n\t            fill: '#E67E22', display: 'none'\n\t        },\n\t        text: {\n\t            'font-family': 'Arial', 'font-size': 14,\n\t            'ref-x': .5, 'ref-y': .5,\n\t            'y-alignment': 'middle', 'text-anchor': 'middle'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><ellipse class=\"outer\"/><ellipse class=\"inner\"/></g><text/></g>',\n\t});\n\n\tvar Multivalued = Attribute.define('erd.Multivalued', {\n\t    attrs: {\n\t        '.inner': { display: 'block' },\n\t        text: { text: 'multivalued' }\n\t    }\n\t});\n\n\tvar Derived = Attribute.define('erd.Derived', {\n\t    attrs: {\n\t        '.outer': { 'stroke-dasharray': '3,5' },\n\t        text: { text: 'derived' }\n\t    }\n\t});\n\n\tvar Key = Attribute.define('erd.Key', {\n\t    attrs: {\n\t        ellipse: { 'stroke-width': 4 },\n\t        text: { text: 'key', 'font-weight': '800', 'text-decoration': 'underline' }\n\t    }\n\t});\n\n\tvar Normal = Attribute.define('erd.Normal', {\n\t    attrs: { text: { text: 'Normal' }}\n\t});\n\n\tvar ISA = Element$1.define('erd.ISA', {\n\t    type: 'erd.ISA',\n\t    size: { width: 100, height: 50 },\n\t    attrs: {\n\t        polygon: {\n\t            points: '0,0 50,50 100,0',\n\t            fill: '#F1C40F', stroke: '#F39C12', 'stroke-width': 2\n\t        },\n\t        text: {\n\t            text: 'ISA', 'font-size': 18,\n\t            'ref-x': .5, 'ref-y': .3,\n\t            'y-alignment': 'middle', 'text-anchor': 'middle'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon/></g><text/></g>',\n\t});\n\n\tvar Line$1 = Link.define('erd.Line', {}, {\n\t    cardinality: function(value) {\n\t        this.set('labels', [{ position: -20, attrs: { text: { dy: -8, text: value }}}]);\n\t    }\n\t});\n\n\tvar erd = ({\n\t\tEntity: Entity,\n\t\tWeakEntity: WeakEntity,\n\t\tRelationship: Relationship,\n\t\tIdentifyingRelationship: IdentifyingRelationship,\n\t\tAttribute: Attribute,\n\t\tMultivalued: Multivalued,\n\t\tDerived: Derived,\n\t\tKey: Key,\n\t\tNormal: Normal,\n\t\tISA: ISA,\n\t\tLine: Line$1\n\t});\n\n\tvar State = Circle.define('fsa.State', {\n\t    attrs: {\n\t        circle: { 'stroke-width': 3 },\n\t        text: { 'font-weight': '800' }\n\t    }\n\t});\n\n\tvar StartState = Element$1.define('fsa.StartState', {\n\t    size: { width: 20, height: 20 },\n\t    attrs: {\n\t        circle: {\n\t            transform: 'translate(10, 10)',\n\t            r: 10,\n\t            fill: '#000000'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle/></g></g>',\n\t});\n\n\tvar EndState = Element$1.define('fsa.EndState', {\n\t    size: { width: 20, height: 20 },\n\t    attrs: {\n\t        '.outer': {\n\t            transform: 'translate(10, 10)',\n\t            r: 10,\n\t            fill: '#ffffff',\n\t            stroke: '#000000'\n\t        },\n\n\t        '.inner': {\n\t            transform: 'translate(10, 10)',\n\t            r: 6,\n\t            fill: '#000000'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"outer\"/><circle class=\"inner\"/></g></g>',\n\t});\n\n\tvar Arrow = Link.define('fsa.Arrow', {\n\t    attrs: { '.marker-target': { d: 'M 10 0 L 0 5 L 10 10 z' }},\n\t    smooth: true\n\t});\n\n\tvar fsa = ({\n\t\tState: State,\n\t\tStartState: StartState,\n\t\tEndState: EndState,\n\t\tArrow: Arrow\n\t});\n\n\tvar Member = Element$1.define('org.Member', {\n\t    size: { width: 180, height: 70 },\n\t    attrs: {\n\t        rect: { width: 170, height: 60 },\n\n\t        '.card': {\n\t            fill: '#FFFFFF', stroke: '#000000', 'stroke-width': 2,\n\t            'pointer-events': 'visiblePainted', rx: 10, ry: 10\n\t        },\n\n\t        image: {\n\t            width: 48, height: 48,\n\t            ref: '.card', 'ref-x': 10, 'ref-y': 5\n\t        },\n\n\t        '.rank': {\n\t            'text-decoration': 'underline',\n\t            ref: '.card', 'ref-x': 0.9, 'ref-y': 0.2,\n\t            'font-family': 'Courier New', 'font-size': 14,\n\t            'text-anchor': 'end'\n\t        },\n\n\t        '.name': {\n\t            'font-weight': '800',\n\t            ref: '.card', 'ref-x': 0.9, 'ref-y': 0.6,\n\t            'font-family': 'Courier New', 'font-size': 14,\n\t            'text-anchor': 'end'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"card\"/><image/></g><text class=\"rank\"/><text class=\"name\"/></g>',\n\t});\n\n\tvar Arrow$1 = Link.define('org.Arrow', {\n\t    source: { selector: '.card' }, target: { selector: '.card' },\n\t    attrs: { '.connection': { stroke: '#585858', 'stroke-width': 3 }},\n\t    z: -1\n\t});\n\n\tvar org = ({\n\t\tMember: Member,\n\t\tArrow: Arrow$1\n\t});\n\n\tvar Place = Generic.define('pn.Place', {\n\t    size: { width: 50, height: 50 },\n\t    attrs: {\n\t        '.root': {\n\t            r: 25,\n\t            fill: '#ffffff',\n\t            stroke: '#000000',\n\t            transform: 'translate(25, 25)'\n\t        },\n\t        '.label': {\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-y': -20,\n\t            ref: '.root',\n\t            fill: '#000000',\n\t            'font-size': 12\n\t        },\n\t        '.tokens > circle': {\n\t            fill: '#000000',\n\t            r: 5\n\t        },\n\t        '.tokens.one > circle': { transform: 'translate(25, 25)' },\n\n\t        '.tokens.two > circle:nth-child(1)': { transform: 'translate(19, 25)' },\n\t        '.tokens.two > circle:nth-child(2)': { transform: 'translate(31, 25)' },\n\n\t        '.tokens.three > circle:nth-child(1)': { transform: 'translate(18, 29)' },\n\t        '.tokens.three > circle:nth-child(2)': { transform: 'translate(25, 19)' },\n\t        '.tokens.three > circle:nth-child(3)': { transform: 'translate(32, 29)' },\n\n\t        '.tokens.alot > text': {\n\t            transform: 'translate(25, 18)',\n\t            'text-anchor': 'middle',\n\t            fill: '#000000'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"root\"/><g class=\"tokens\" /></g><text class=\"label\"/></g>',\n\t});\n\n\tvar PlaceView = ElementView.extend({\n\n\t    presentationAttributes: ElementView.addPresentationAttributes({\n\t        tokens: ['TOKENS']\n\t    }),\n\n\t    initFlag: ElementView.prototype.initFlag.concat(['TOKENS']),\n\n\t    confirmUpdate: function() {\n\t        var ref;\n\n\t        var args = [], len = arguments.length;\n\t        while ( len-- ) args[ len ] = arguments[ len ];\n\t        var flags = (ref = ElementView.prototype.confirmUpdate).call.apply(ref, [ this ].concat( args ));\n\t        if (this.hasFlag(flags, 'TOKENS')) {\n\t            this.renderTokens();\n\t            this.update();\n\t            flags = this.removeFlag(flags, 'TOKENS');\n\t        }\n\t        return flags;\n\t    },\n\n\t    renderTokens: function() {\n\n\t        var vTokens = this.vel.findOne('.tokens').empty();\n\t        ['one', 'two', 'three', 'alot'].forEach(function(className) {\n\t            vTokens.removeClass(className);\n\t        });\n\n\t        var tokens = this.model.get('tokens');\n\t        if (!tokens) { return; }\n\n\t        switch (tokens) {\n\n\t            case 1:\n\t                vTokens.addClass('one');\n\t                vTokens.append(V('circle'));\n\t                break;\n\n\t            case 2:\n\t                vTokens.addClass('two');\n\t                vTokens.append([V('circle'), V('circle')]);\n\t                break;\n\n\t            case 3:\n\t                vTokens.addClass('three');\n\t                vTokens.append([V('circle'), V('circle'), V('circle')]);\n\t                break;\n\n\t            default:\n\t                vTokens.addClass('alot');\n\t                vTokens.append(V('text').text(tokens + ''));\n\t                break;\n\t        }\n\t    }\n\t});\n\n\tvar Transition = Generic.define('pn.Transition', {\n\t    size: { width: 12, height: 50 },\n\t    attrs: {\n\t        'rect': {\n\t            width: 12,\n\t            height: 50,\n\t            fill: '#000000',\n\t            stroke: '#000000'\n\t        },\n\t        '.label': {\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-y': -20,\n\t            ref: 'rect',\n\t            fill: '#000000',\n\t            'font-size': 12\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"root\"/></g></g><text class=\"label\"/>',\n\t});\n\n\tvar Link$3 = Link.define('pn.Link', {\n\t    attrs: { '.marker-target': { d: 'M 10 0 L 0 5 L 10 10 z' }}\n\t});\n\n\tvar pn = ({\n\t\tPlace: Place,\n\t\tPlaceView: PlaceView,\n\t\tTransition: Transition,\n\t\tLink: Link$3\n\t});\n\n\tvar Class = Generic.define('uml.Class', {\n\t    attrs: {\n\t        rect: { 'width': 200 },\n\n\t        '.uml-class-name-rect': { 'stroke': 'black', 'stroke-width': 2, 'fill': '#3498db' },\n\t        '.uml-class-attrs-rect': { 'stroke': 'black', 'stroke-width': 2, 'fill': '#2980b9' },\n\t        '.uml-class-methods-rect': { 'stroke': 'black', 'stroke-width': 2, 'fill': '#2980b9' },\n\n\t        '.uml-class-name-text': {\n\t            'ref': '.uml-class-name-rect',\n\t            'ref-y': .5,\n\t            'ref-x': .5,\n\t            'text-anchor': 'middle',\n\t            'y-alignment': 'middle',\n\t            'font-weight': 'bold',\n\t            'fill': 'black',\n\t            'font-size': 12,\n\t            'font-family': 'Times New Roman'\n\t        },\n\t        '.uml-class-attrs-text': {\n\t            'ref': '.uml-class-attrs-rect', 'ref-y': 5, 'ref-x': 5,\n\t            'fill': 'black', 'font-size': 12, 'font-family': 'Times New Roman'\n\t        },\n\t        '.uml-class-methods-text': {\n\t            'ref': '.uml-class-methods-rect', 'ref-y': 5, 'ref-x': 5,\n\t            'fill': 'black', 'font-size': 12, 'font-family': 'Times New Roman'\n\t        }\n\t    },\n\n\t    name: [],\n\t    attributes: [],\n\t    methods: []\n\t}, {\n\t    markup: [\n\t        '<g class=\"rotatable\">',\n\t        '<g class=\"scalable\">',\n\t        '<rect class=\"uml-class-name-rect\"/><rect class=\"uml-class-attrs-rect\"/><rect class=\"uml-class-methods-rect\"/>',\n\t        '</g>',\n\t        '<text class=\"uml-class-name-text\"/><text class=\"uml-class-attrs-text\"/><text class=\"uml-class-methods-text\"/>',\n\t        '</g>'\n\t    ].join(''),\n\n\t    initialize: function() {\n\n\t        this.on('change:name change:attributes change:methods', function() {\n\t            this.updateRectangles();\n\t            this.trigger('uml-update');\n\t        }, this);\n\n\t        this.updateRectangles();\n\n\t        Generic.prototype.initialize.apply(this, arguments);\n\t    },\n\n\t    getClassName: function() {\n\t        return this.get('name');\n\t    },\n\n\t    updateRectangles: function() {\n\n\t        var attrs = this.get('attrs');\n\n\t        var rects = [\n\t            { type: 'name', text: this.getClassName() },\n\t            { type: 'attrs', text: this.get('attributes') },\n\t            { type: 'methods', text: this.get('methods') }\n\t        ];\n\n\t        var offsetY = 0;\n\n\t        rects.forEach(function(rect) {\n\n\t            var lines = Array.isArray(rect.text) ? rect.text : [rect.text];\n\t            var rectHeight = lines.length * 20 + 20;\n\n\t            attrs['.uml-class-' + rect.type + '-text'].text = lines.join('\\n');\n\t            attrs['.uml-class-' + rect.type + '-rect'].height = rectHeight;\n\t            attrs['.uml-class-' + rect.type + '-rect'].transform = 'translate(0,' + offsetY + ')';\n\n\t            offsetY += rectHeight;\n\t        });\n\t    }\n\n\t});\n\n\tvar ClassView = ElementView.extend({\n\n\t    initialize: function() {\n\n\t        ElementView.prototype.initialize.apply(this, arguments);\n\n\t        this.listenTo(this.model, 'uml-update', function() {\n\t            this.update();\n\t            this.resize();\n\t        });\n\t    }\n\t});\n\n\tvar Abstract = Class.define('uml.Abstract', {\n\t    attrs: {\n\t        '.uml-class-name-rect': { fill: '#e74c3c' },\n\t        '.uml-class-attrs-rect': { fill: '#c0392b' },\n\t        '.uml-class-methods-rect': { fill: '#c0392b' }\n\t    }\n\t}, {\n\n\t    getClassName: function() {\n\t        return ['<<Abstract>>', this.get('name')];\n\t    }\n\n\t});\n\tvar AbstractView = ClassView;\n\n\tvar Interface = Class.define('uml.Interface', {\n\t    attrs: {\n\t        '.uml-class-name-rect': { fill: '#f1c40f' },\n\t        '.uml-class-attrs-rect': { fill: '#f39c12' },\n\t        '.uml-class-methods-rect': { fill: '#f39c12' }\n\t    }\n\t}, {\n\t    getClassName: function() {\n\t        return ['<<Interface>>', this.get('name')];\n\t    }\n\t});\n\tvar InterfaceView = ClassView;\n\n\tvar Generalization = Link.define('uml.Generalization', {\n\t    attrs: { '.marker-target': { d: 'M 20 0 L 0 10 L 20 20 z', fill: 'white' }}\n\t});\n\n\tvar Implementation = Link.define('uml.Implementation', {\n\t    attrs: {\n\t        '.marker-target': { d: 'M 20 0 L 0 10 L 20 20 z', fill: 'white' },\n\t        '.connection': { 'stroke-dasharray': '3,3' }\n\t    }\n\t});\n\n\tvar Aggregation = Link.define('uml.Aggregation', {\n\t    attrs: { '.marker-target': { d: 'M 40 10 L 20 20 L 0 10 L 20 0 z', fill: 'white' }}\n\t});\n\n\tvar Composition = Link.define('uml.Composition', {\n\t    attrs: { '.marker-target': { d: 'M 40 10 L 20 20 L 0 10 L 20 0 z', fill: 'black' }}\n\t});\n\n\tvar Association = Link.define('uml.Association');\n\n\t// Statechart\n\n\tvar State$1 = Generic.define('uml.State', {\n\t    attrs: {\n\t        '.uml-state-body': {\n\t            'width': 200, 'height': 200, 'rx': 10, 'ry': 10,\n\t            'fill': '#ecf0f1', 'stroke': '#bdc3c7', 'stroke-width': 3\n\t        },\n\t        '.uml-state-separator': {\n\t            'stroke': '#bdc3c7', 'stroke-width': 2\n\t        },\n\t        '.uml-state-name': {\n\t            'ref': '.uml-state-body', 'ref-x': .5, 'ref-y': 5, 'text-anchor': 'middle',\n\t            'fill': '#000000', 'font-family': 'Courier New', 'font-size': 14\n\t        },\n\t        '.uml-state-events': {\n\t            'ref': '.uml-state-separator', 'ref-x': 5, 'ref-y': 5,\n\t            'fill': '#000000', 'font-family': 'Courier New', 'font-size': 14\n\t        }\n\t    },\n\n\t    name: 'State',\n\t    events: []\n\n\t}, {\n\t    markup: [\n\t        '<g class=\"rotatable\">',\n\t        '<g class=\"scalable\">',\n\t        '<rect class=\"uml-state-body\"/>',\n\t        '</g>',\n\t        '<path class=\"uml-state-separator\"/>',\n\t        '<text class=\"uml-state-name\"/>',\n\t        '<text class=\"uml-state-events\"/>',\n\t        '</g>'\n\t    ].join(''),\n\n\t    initialize: function() {\n\n\t        this.on({\n\t            'change:name': this.updateName,\n\t            'change:events': this.updateEvents,\n\t            'change:size': this.updatePath\n\t        }, this);\n\n\t        this.updateName();\n\t        this.updateEvents();\n\t        this.updatePath();\n\n\t        Generic.prototype.initialize.apply(this, arguments);\n\t    },\n\n\t    updateName: function() {\n\n\t        this.attr('.uml-state-name/text', this.get('name'));\n\t    },\n\n\t    updateEvents: function() {\n\n\t        this.attr('.uml-state-events/text', this.get('events').join('\\n'));\n\t    },\n\n\t    updatePath: function() {\n\n\t        var d = 'M 0 20 L ' + this.get('size').width + ' 20';\n\n\t        // We are using `silent: true` here because updatePath() is meant to be called\n\t        // on resize and there's no need to to update the element twice (`change:size`\n\t        // triggers also an update).\n\t        this.attr('.uml-state-separator/d', d, { silent: true });\n\t    }\n\t});\n\n\tvar StartState$1 = Circle.define('uml.StartState', {\n\t    type: 'uml.StartState',\n\t    attrs: { circle: { 'fill': '#34495e', 'stroke': '#2c3e50', 'stroke-width': 2, 'rx': 1 }}\n\t});\n\n\tvar EndState$1 = Generic.define('uml.EndState', {\n\t    size: { width: 20, height: 20 },\n\t    attrs: {\n\t        'circle.outer': {\n\t            transform: 'translate(10, 10)',\n\t            r: 10,\n\t            fill: '#ffffff',\n\t            stroke: '#2c3e50'\n\t        },\n\n\t        'circle.inner': {\n\t            transform: 'translate(10, 10)',\n\t            r: 6,\n\t            fill: '#34495e'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"outer\"/><circle class=\"inner\"/></g></g>',\n\t});\n\n\tvar Transition$1 = Link.define('uml.Transition', {\n\t    attrs: {\n\t        '.marker-target': { d: 'M 10 0 L 0 5 L 10 10 z', fill: '#34495e', stroke: '#2c3e50' },\n\t        '.connection': { stroke: '#2c3e50' }\n\t    }\n\t});\n\n\tvar uml = ({\n\t\tClass: Class,\n\t\tClassView: ClassView,\n\t\tAbstract: Abstract,\n\t\tAbstractView: AbstractView,\n\t\tInterface: Interface,\n\t\tInterfaceView: InterfaceView,\n\t\tGeneralization: Generalization,\n\t\tImplementation: Implementation,\n\t\tAggregation: Aggregation,\n\t\tComposition: Composition,\n\t\tAssociation: Association,\n\t\tState: State$1,\n\t\tStartState: StartState$1,\n\t\tEndState: EndState$1,\n\t\tTransition: Transition$1\n\t});\n\n\n\n\tvar index$3 = ({\n\t\tbasic: basic,\n\t\tstandard: standard,\n\t\tdevs: devs,\n\t\tlogic: logic,\n\t\tchess: chess,\n\t\terd: erd,\n\t\tfsa: fsa,\n\t\torg: org,\n\t\tpn: pn,\n\t\tuml: uml\n\t});\n\n\tfunction abs2rel(absolute, max) {\n\n\t    if (max === 0) { return '0%'; }\n\t    // round to 3 decimal places\n\t    var dp = 1000;\n\t    var relative = Math.round(absolute / max * 100 * dp) / dp;\n\t    return (relative + \"%\");\n\t}\n\n\tfunction pin(relative) {\n\n\t    return function(end, view, magnet, coords) {\n\t        var fn = (view.isNodeConnection(magnet)) ? pinnedLinkEnd : pinnedElementEnd;\n\t        return fn(relative, end, view, magnet, coords);\n\t    };\n\t}\n\n\tfunction pinnedElementEnd(relative, end, view, magnet, coords) {\n\n\t    var angle = view.model.angle();\n\t    var bbox = view.getNodeUnrotatedBBox(magnet);\n\t    var origin = view.model.getBBox().center();\n\t    coords.rotate(origin, angle);\n\t    var dx = coords.x - bbox.x;\n\t    var dy = coords.y - bbox.y;\n\n\t    if (relative) {\n\t        dx = abs2rel(dx, bbox.width);\n\t        dy = abs2rel(dy, bbox.height);\n\t    }\n\n\t    end.anchor = {\n\t        name: 'topLeft',\n\t        args: {\n\t            dx: dx,\n\t            dy: dy,\n\t            rotate: true\n\t        }\n\t    };\n\n\t    return end;\n\t}\n\n\tfunction pinnedLinkEnd(relative, end, view, _magnet, coords) {\n\n\t    var connection = view.getConnection();\n\t    if (!connection) { return end; }\n\t    var length = connection.closestPointLength(coords);\n\t    if (relative) {\n\t        var totalLength = connection.length();\n\t        end.anchor = {\n\t            name: 'connectionRatio',\n\t            args: {\n\t                ratio: length / totalLength\n\t            }\n\t        };\n\t    } else {\n\t        end.anchor = {\n\t            name: 'connectionLength',\n\t            args: {\n\t                length: length\n\t            }\n\t        };\n\t    }\n\t    return end;\n\t}\n\n\tvar useDefaults = noop;\n\tvar pinAbsolute = pin(false);\n\tvar pinRelative = pin(true);\n\n\tvar index$4 = ({\n\t\tuseDefaults: useDefaults,\n\t\tpinAbsolute: pinAbsolute,\n\t\tpinRelative: pinRelative\n\t});\n\n\t// Vertex Handles\n\tvar VertexHandle = View.extend({\n\t    tagName: 'circle',\n\t    svgElement: true,\n\t    className: 'marker-vertex',\n\t    events: {\n\t        mousedown: 'onPointerDown',\n\t        touchstart: 'onPointerDown',\n\t        dblclick: 'onDoubleClick',\n\t        dbltap: 'onDoubleClick'\n\t    },\n\t    documentEvents: {\n\t        mousemove: 'onPointerMove',\n\t        touchmove: 'onPointerMove',\n\t        mouseup: 'onPointerUp',\n\t        touchend: 'onPointerUp',\n\t        touchcancel: 'onPointerUp'\n\t    },\n\t    attributes: {\n\t        'r': 6,\n\t        'fill': '#33334F',\n\t        'stroke': '#FFFFFF',\n\t        'stroke-width': 2,\n\t        'cursor': 'move'\n\t    },\n\t    position: function(x, y) {\n\t        var ref = this;\n\t        var vel = ref.vel;\n\t        var options = ref.options;\n\t        var scale = options.scale;\n\t        var matrix = V.createSVGMatrix().translate(x, y);\n\t        if (scale) { matrix = matrix.scale(scale); }\n\t        vel.transform(matrix, { absolute: true });\n\t    },\n\t    onPointerDown: function(evt) {\n\t        if (this.options.guard(evt)) { return; }\n\t        evt.stopPropagation();\n\t        evt.preventDefault();\n\t        this.options.paper.undelegateEvents();\n\t        this.delegateDocumentEvents(null, evt.data);\n\t        this.trigger('will-change', this, evt);\n\t    },\n\t    onPointerMove: function(evt) {\n\t        this.trigger('changing', this, evt);\n\t    },\n\t    onDoubleClick: function(evt) {\n\t        this.trigger('remove', this, evt);\n\t    },\n\t    onPointerUp: function(evt) {\n\t        this.trigger('changed', this, evt);\n\t        this.undelegateDocumentEvents();\n\t        this.options.paper.delegateEvents();\n\t    }\n\t});\n\n\tvar Vertices = ToolView.extend({\n\t    name: 'vertices',\n\t    options: {\n\t        handleClass: VertexHandle,\n\t        snapRadius: 20,\n\t        redundancyRemoval: true,\n\t        vertexAdding: true,\n\t        stopPropagation: true,\n\t        scale: null\n\t    },\n\t    children: [{\n\t        tagName: 'path',\n\t        selector: 'connection',\n\t        className: 'joint-vertices-path',\n\t        attributes: {\n\t            'fill': 'none',\n\t            'stroke': 'transparent',\n\t            'stroke-width': 10,\n\t            'cursor': 'cell'\n\t        }\n\t    }],\n\t    handles: null,\n\t    events: {\n\t        'mousedown .joint-vertices-path': 'onPathPointerDown',\n\t        'touchstart .joint-vertices-path': 'onPathPointerDown'\n\t    },\n\t    onRender: function() {\n\t        if (this.options.vertexAdding) {\n\t            this.renderChildren();\n\t            this.updatePath();\n\t        }\n\t        this.resetHandles();\n\t        this.renderHandles();\n\t        return this;\n\t    },\n\t    update: function() {\n\t        var relatedView = this.relatedView;\n\t        var vertices = relatedView.model.vertices();\n\t        if (vertices.length === this.handles.length) {\n\t            this.updateHandles();\n\t        } else {\n\t            this.resetHandles();\n\t            this.renderHandles();\n\t        }\n\t        if (this.options.vertexAdding) {\n\t            this.updatePath();\n\t        }\n\t        return this;\n\t    },\n\t    resetHandles: function() {\n\t        var handles = this.handles;\n\t        this.handles = [];\n\t        this.stopListening();\n\t        if (!Array.isArray(handles)) { return; }\n\t        for (var i = 0, n = handles.length; i < n; i++) {\n\t            handles[i].remove();\n\t        }\n\t    },\n\t    renderHandles: function() {\n\t        var this$1 = this;\n\n\t        var relatedView = this.relatedView;\n\t        var vertices = relatedView.model.vertices();\n\t        for (var i = 0, n = vertices.length; i < n; i++) {\n\t            var vertex = vertices[i];\n\t            var handle = new (this.options.handleClass)({\n\t                index: i,\n\t                paper: this.paper,\n\t                scale: this.options.scale,\n\t                guard: function (evt) { return this$1.guard(evt); }\n\t            });\n\t            handle.render();\n\t            handle.position(vertex.x, vertex.y);\n\t            this.simulateRelatedView(handle.el);\n\t            handle.vel.appendTo(this.el);\n\t            this.handles.push(handle);\n\t            this.startHandleListening(handle);\n\t        }\n\t    },\n\t    updateHandles: function() {\n\t        var relatedView = this.relatedView;\n\t        var vertices = relatedView.model.vertices();\n\t        for (var i = 0, n = vertices.length; i < n; i++) {\n\t            var vertex = vertices[i];\n\t            var handle = this.handles[i];\n\t            if (!handle) { return; }\n\t            handle.position(vertex.x, vertex.y);\n\t        }\n\t    },\n\t    updatePath: function() {\n\t        var connection = this.childNodes.connection;\n\t        if (connection) { connection.setAttribute('d', this.relatedView.getSerializedConnection()); }\n\t    },\n\t    startHandleListening: function(handle) {\n\t        var relatedView = this.relatedView;\n\t        if (relatedView.can('vertexMove')) {\n\t            this.listenTo(handle, 'will-change', this.onHandleWillChange);\n\t            this.listenTo(handle, 'changing', this.onHandleChanging);\n\t            this.listenTo(handle, 'changed', this.onHandleChanged);\n\t        }\n\t        if (relatedView.can('vertexRemove')) {\n\t            this.listenTo(handle, 'remove', this.onHandleRemove);\n\t        }\n\t    },\n\t    getNeighborPoints: function(index) {\n\t        var linkView = this.relatedView;\n\t        var vertices = linkView.model.vertices();\n\t        var prev = (index > 0) ? vertices[index - 1] : linkView.sourceAnchor;\n\t        var next = (index < vertices.length - 1) ? vertices[index + 1] : linkView.targetAnchor;\n\t        return {\n\t            prev: new Point(prev),\n\t            next: new Point(next)\n\t        };\n\t    },\n\t    onHandleWillChange: function(_handle, evt) {\n\t        this.focus();\n\t        var ref = this;\n\t        var relatedView = ref.relatedView;\n\t        var options = ref.options;\n\t        relatedView.model.startBatch('vertex-move', { ui: true, tool: this.cid });\n\t        if (!options.stopPropagation) { relatedView.notifyPointerdown.apply(relatedView, relatedView.paper.getPointerArgs(evt)); }\n\t    },\n\t    onHandleChanging: function(handle, evt) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var linkView = ref.relatedView;\n\t        var index = handle.options.index;\n\t        var ref$1 = linkView.paper.getPointerArgs(evt);\n\t        var normalizedEvent = ref$1[0];\n\t        var x = ref$1[1];\n\t        var y = ref$1[2];\n\t        var vertex = { x: x, y: y };\n\t        this.snapVertex(vertex, index);\n\t        linkView.model.vertex(index, vertex, { ui: true, tool: this.cid });\n\t        handle.position(vertex.x, vertex.y);\n\t        if (!options.stopPropagation) { linkView.notifyPointermove(normalizedEvent, x, y); }\n\t    },\n\t    onHandleChanged: function(_handle, evt) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var linkView = ref.relatedView;\n\t        if (options.vertexAdding) { this.updatePath(); }\n\t        if (!options.redundancyRemoval) { return; }\n\t        var verticesRemoved = linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n\t        if (verticesRemoved) { this.render(); }\n\t        this.blur();\n\t        linkView.model.stopBatch('vertex-move', { ui: true, tool: this.cid });\n\t        if (this.eventData(evt).vertexAdded) {\n\t            linkView.model.stopBatch('vertex-add', { ui: true, tool: this.cid });\n\t        }\n\t        var ref$1 = linkView.paper.getPointerArgs(evt);\n\t        var normalizedEvt = ref$1[0];\n\t        var x = ref$1[1];\n\t        var y = ref$1[2];\n\t        if (!options.stopPropagation) { linkView.notifyPointerup(normalizedEvt, x, y); }\n\t        linkView.checkMouseleave(normalizedEvt);\n\t    },\n\t    snapVertex: function(vertex, index) {\n\t        var snapRadius = this.options.snapRadius;\n\t        if (snapRadius > 0) {\n\t            var neighbors = this.getNeighborPoints(index);\n\t            var prev = neighbors.prev;\n\t            var next = neighbors.next;\n\t            if (Math.abs(vertex.x - prev.x) < snapRadius) {\n\t                vertex.x = prev.x;\n\t            } else if (Math.abs(vertex.x - next.x) < snapRadius) {\n\t                vertex.x = next.x;\n\t            }\n\t            if (Math.abs(vertex.y - prev.y) < snapRadius) {\n\t                vertex.y = neighbors.prev.y;\n\t            } else if (Math.abs(vertex.y - next.y) < snapRadius) {\n\t                vertex.y = next.y;\n\t            }\n\t        }\n\t    },\n\t    onHandleRemove: function(handle, evt) {\n\t        var index$1 = handle.options.index;\n\t        var linkView = this.relatedView;\n\t        linkView.model.removeVertex(index$1, { ui: true });\n\t        if (this.options.vertexAdding) { this.updatePath(); }\n\t        linkView.checkMouseleave(normalizeEvent(evt));\n\t    },\n\t    onPathPointerDown: function(evt) {\n\t        if (this.guard(evt)) { return; }\n\t        evt.stopPropagation();\n\t        evt.preventDefault();\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var vertex = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY).toJSON();\n\t        var relatedView = this.relatedView;\n\t        relatedView.model.startBatch('vertex-add', { ui: true, tool: this.cid });\n\t        var index$1 = relatedView.getVertexIndex(vertex.x, vertex.y);\n\t        this.snapVertex(vertex, index$1);\n\t        relatedView.model.insertVertex(index$1, vertex, { ui: true, tool: this.cid });\n\t        this.update();\n\t        var handle = this.handles[index$1];\n\t        this.eventData(normalizedEvent, { vertexAdded: true });\n\t        handle.onPointerDown(normalizedEvent);\n\t    },\n\t    onRemove: function() {\n\t        this.resetHandles();\n\t    }\n\t}, {\n\t    VertexHandle: VertexHandle // keep as class property\n\t});\n\n\tfunction getViewBBox(view, useModelGeometry) {\n\t    var model = view.model;\n\t    if (useModelGeometry) { return model.getBBox(); }\n\t    return (model.isLink()) ? view.getConnection().bbox() : view.getNodeUnrotatedBBox(view.el);\n\t}\n\n\tfunction getAnchor(coords, view, magnet) {\n\t    // take advantage of an existing logic inside of the\n\t    // pin relative connection strategy\n\t    var end = pinRelative.call(\n\t        this.paper,\n\t        {},\n\t        view,\n\t        magnet,\n\t        coords,\n\t        this.model\n\t    );\n\t    return end.anchor;\n\t}\n\n\tfunction snapAnchor(coords, view, magnet, type, relatedView, toolView) {\n\t    var snapRadius = toolView.options.snapRadius;\n\t    var isSource = (type === 'source');\n\t    var refIndex = (isSource ? 0 : -1);\n\t    var ref = this.model.vertex(refIndex) || this.getEndAnchor(isSource ? 'target' : 'source');\n\t    if (ref) {\n\t        if (Math.abs(ref.x - coords.x) < snapRadius) { coords.x = ref.x; }\n\t        if (Math.abs(ref.y - coords.y) < snapRadius) { coords.y = ref.y; }\n\t    }\n\t    return coords;\n\t}\n\n\tvar SegmentHandle = View.extend({\n\t    tagName: 'g',\n\t    svgElement: true,\n\t    className: 'marker-segment',\n\t    events: {\n\t        mousedown: 'onPointerDown',\n\t        touchstart: 'onPointerDown'\n\t    },\n\t    documentEvents: {\n\t        mousemove: 'onPointerMove',\n\t        touchmove: 'onPointerMove',\n\t        mouseup: 'onPointerUp',\n\t        touchend: 'onPointerUp',\n\t        touchcancel: 'onPointerUp'\n\t    },\n\t    children: [{\n\t        tagName: 'line',\n\t        selector: 'line',\n\t        attributes: {\n\t            'stroke': '#33334F',\n\t            'stroke-width': 2,\n\t            'fill': 'none',\n\t            'pointer-events': 'none'\n\t        }\n\t    }, {\n\t        tagName: 'rect',\n\t        selector: 'handle',\n\t        attributes: {\n\t            'width': 20,\n\t            'height': 8,\n\t            'x': -10,\n\t            'y': -4,\n\t            'rx': 4,\n\t            'ry': 4,\n\t            'fill': '#33334F',\n\t            'stroke': '#FFFFFF',\n\t            'stroke-width': 2\n\t        }\n\t    }],\n\t    onRender: function() {\n\t        this.renderChildren();\n\t    },\n\t    position: function(x, y, angle, view) {\n\t        var ref = this.options;\n\t        var scale = ref.scale;\n\t        var matrix = V.createSVGMatrix().translate(x, y).rotate(angle);\n\t        if (scale) { matrix = matrix.scale(scale); }\n\n\t        var handle = this.childNodes.handle;\n\t        handle.setAttribute('transform', V.matrixToTransformString(matrix));\n\t        handle.setAttribute('cursor', (angle % 180 === 0) ? 'row-resize' : 'col-resize');\n\n\t        var viewPoint = view.getClosestPoint(new Point(x, y));\n\t        var line = this.childNodes.line;\n\t        line.setAttribute('x1', x);\n\t        line.setAttribute('y1', y);\n\t        line.setAttribute('x2', viewPoint.x);\n\t        line.setAttribute('y2', viewPoint.y);\n\t    },\n\t    onPointerDown: function(evt) {\n\t        if (this.options.guard(evt)) { return; }\n\t        this.trigger('change:start', this, evt);\n\t        evt.stopPropagation();\n\t        evt.preventDefault();\n\t        this.options.paper.undelegateEvents();\n\t        this.delegateDocumentEvents(null, evt.data);\n\t    },\n\t    onPointerMove: function(evt) {\n\t        this.trigger('changing', this, evt);\n\t    },\n\t    onPointerUp: function(evt) {\n\t        this.undelegateDocumentEvents();\n\t        this.options.paper.delegateEvents();\n\t        this.trigger('change:end', this, evt);\n\t    },\n\t    show: function() {\n\t        this.el.style.display = '';\n\t    },\n\t    hide: function() {\n\t        this.el.style.display = 'none';\n\t    }\n\t});\n\n\tvar Segments = ToolView.extend({\n\t    name: 'segments',\n\t    precision: .5,\n\t    options: {\n\t        handleClass: SegmentHandle,\n\t        segmentLengthThreshold: 40,\n\t        redundancyRemoval: true,\n\t        anchor: getAnchor,\n\t        snapRadius: 10,\n\t        snapHandle: true,\n\t        stopPropagation: true\n\t    },\n\t    handles: null,\n\t    onRender: function() {\n\t        this.resetHandles();\n\t        var relatedView = this.relatedView;\n\t        var vertices = relatedView.model.vertices();\n\t        vertices.unshift(relatedView.sourcePoint);\n\t        vertices.push(relatedView.targetPoint);\n\t        for (var i = 0, n = vertices.length; i < n - 1; i++) {\n\t            var vertex = vertices[i];\n\t            var nextVertex = vertices[i + 1];\n\t            var handle = this.renderHandle(vertex, nextVertex);\n\t            this.simulateRelatedView(handle.el);\n\t            this.handles.push(handle);\n\t            handle.options.index = i;\n\t        }\n\t        return this;\n\t    },\n\t    renderHandle: function(vertex, nextVertex) {\n\t        var this$1 = this;\n\n\t        var handle = new (this.options.handleClass)({\n\t            paper: this.paper,\n\t            scale: this.options.scale,\n\t            guard: function (evt) { return this$1.guard(evt); }\n\t        });\n\t        handle.render();\n\t        this.updateHandle(handle, vertex, nextVertex);\n\t        handle.vel.appendTo(this.el);\n\t        this.startHandleListening(handle);\n\t        return handle;\n\t    },\n\t    update: function() {\n\t        this.render();\n\t        return this;\n\t    },\n\t    startHandleListening: function(handle) {\n\t        this.listenTo(handle, 'change:start', this.onHandleChangeStart);\n\t        this.listenTo(handle, 'changing', this.onHandleChanging);\n\t        this.listenTo(handle, 'change:end', this.onHandleChangeEnd);\n\t    },\n\t    resetHandles: function() {\n\t        var handles = this.handles;\n\t        this.handles = [];\n\t        this.stopListening();\n\t        if (!Array.isArray(handles)) { return; }\n\t        for (var i = 0, n = handles.length; i < n; i++) {\n\t            handles[i].remove();\n\t        }\n\t    },\n\t    shiftHandleIndexes: function(value) {\n\t        var handles = this.handles;\n\t        for (var i = 0, n = handles.length; i < n; i++) { handles[i].options.index += value; }\n\t    },\n\t    resetAnchor: function(type, anchor) {\n\t        var relatedModel = this.relatedView.model;\n\t        if (anchor) {\n\t            relatedModel.prop([type, 'anchor'], anchor, {\n\t                rewrite: true,\n\t                ui: true,\n\t                tool: this.cid\n\t            });\n\t        } else {\n\t            relatedModel.removeProp([type, 'anchor'], {\n\t                ui: true,\n\t                tool: this.cid\n\t            });\n\t        }\n\t    },\n\t    snapHandle: function(handle, position, data) {\n\n\t        var index = handle.options.index;\n\t        var linkView = this.relatedView;\n\t        var link = linkView.model;\n\t        var vertices = link.vertices();\n\t        var axis = handle.options.axis;\n\t        var prev = vertices[index - 2] || data.sourceAnchor;\n\t        var next = vertices[index + 1] || data.targetAnchor;\n\t        var snapRadius = this.options.snapRadius;\n\t        if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n\t            position[axis] = prev[axis];\n\t        } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n\t            position[axis] = next[axis];\n\t        }\n\t        return position;\n\t    },\n\n\t    onHandleChanging: function(handle, evt) {\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var data = this.eventData(evt);\n\t        var relatedView = this.relatedView;\n\t        var paper = relatedView.paper;\n\t        var index$1 = handle.options.index - 1;\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t        var position = this.snapHandle(handle, coords.clone(), data);\n\t        var axis = handle.options.axis;\n\t        var offset = (this.options.snapHandle) ? 0 : (coords[axis] - position[axis]);\n\t        var link = relatedView.model;\n\t        var vertices = cloneDeep(link.vertices());\n\t        var anchorFn = this.options.anchor;\n\t        if (typeof anchorFn !== 'function') { anchorFn = null; }\n\n\t        var handleIndex = handle.options.index;\n\n\t        var vertexPoints = [relatedView.sourcePoint.clone() ].concat( vertices, [relatedView.targetPoint.clone()]);\n\t        var indexOffset = 0;\n\n\t        // check if vertex before handle vertex exists\n\t        if (handleIndex - 1 >= 0) {\n\t            var v1 = vertexPoints[handleIndex - 1];\n\t            var v2 = vertexPoints[handleIndex];\n\n\t            var theta = new Line(v1, v2).vector().theta();\n\n\t            // check only non-orthogonal segments\n\t            if (theta % 90 !== 0) {\n\t                vertices.splice(handleIndex - 1, 0, data.originalVertices[handleIndex - 1]);\n\t                indexOffset++;\n\t                this.shiftHandleIndexes(1);\n\t            }\n\t        }\n\n\t        var vertex = vertices[index$1 + indexOffset];\n\t        var nextVertex = vertices[index$1 + 1 + indexOffset];\n\n\t        // check if vertex after handle vertex exists\n\t        if (handleIndex + 2 < vertexPoints.length) {\n\t            var v1$1 = vertexPoints[handleIndex + 1];\n\t            var v2$1 = vertexPoints[handleIndex + 2];\n\n\t            var theta$1 = new Line(v1$1, v2$1).vector().theta();\n\n\t            // check only non-orthogonal segments\n\t            if (theta$1 % 90 !== 0) {\n\t                var isSingleVertex = data.originalVertices.length === 1;\n\t                var origVIndex = isSingleVertex ? 0 : handleIndex;\n\t                var additionalOffset = data.firstHandleShifted && !isSingleVertex ? 1 : 0;\n\t                var nextVIndex = 1 + indexOffset;\n\t                vertices.splice(handleIndex + nextVIndex, 0, data.originalVertices[origVIndex - additionalOffset]);\n\t            }\n\t        }\n\n\t        // First Segment\n\t        var sourceView = relatedView.sourceView;\n\t        var sourceBBox = relatedView.sourceBBox;\n\t        var changeSourceAnchor = false;\n\t        var deleteSourceAnchor = false;\n\t        if (!vertex) {\n\t            vertex = relatedView.sourceAnchor.toJSON();\n\t            vertex[axis] = position[axis];\n\t            if (sourceBBox.containsPoint(vertex)) {\n\t                vertex[axis] = position[axis];\n\t                changeSourceAnchor = true;\n\t            } else {\n\t                // we left the area of the source magnet for the first time\n\t                vertices.unshift(vertex);\n\t                this.shiftHandleIndexes(1);\n\t                data.firstHandleShifted = true;\n\t                deleteSourceAnchor = true;\n\t            }\n\t        } else if (index$1 === 0) {\n\t            if (sourceBBox.containsPoint(vertex)) {\n\t                vertices.shift();\n\t                this.shiftHandleIndexes(-1);\n\t                changeSourceAnchor = true;\n\t            } else {\n\t                vertex[axis] = position[axis];\n\t                deleteSourceAnchor = true;\n\t            }\n\t        } else {\n\t            vertex[axis] = position[axis];\n\t        }\n\n\t        if (anchorFn && sourceView) {\n\t            if (changeSourceAnchor) {\n\t                var sourceAnchorPosition = data.sourceAnchor.clone();\n\t                sourceAnchorPosition[axis] = position[axis];\n\t                var sourceAnchor = anchorFn.call(relatedView, sourceAnchorPosition, sourceView, relatedView.sourceMagnet || sourceView.el, 'source', relatedView);\n\t                this.resetAnchor('source', sourceAnchor);\n\t            }\n\t            if (deleteSourceAnchor) {\n\t                this.resetAnchor('source', data.sourceAnchorDef);\n\t            }\n\t        }\n\n\t        // Last segment\n\t        var targetView = relatedView.targetView;\n\t        var targetBBox = relatedView.targetBBox;\n\t        var changeTargetAnchor = false;\n\t        var deleteTargetAnchor = false;\n\t        if (!nextVertex) {\n\t            nextVertex = relatedView.targetAnchor.toJSON();\n\t            nextVertex[axis] = position[axis];\n\t            if (targetBBox.containsPoint(nextVertex)) {\n\t                changeTargetAnchor = true;\n\t            } else {\n\t                // we left the area of the target magnet for the first time\n\t                vertices.push(nextVertex);\n\t                deleteTargetAnchor = true;\n\t            }\n\t        } else if (index$1 === vertices.length - 2) {\n\t            if (targetBBox.containsPoint(nextVertex)) {\n\t                vertices.pop();\n\t                changeTargetAnchor = true;\n\t            } else {\n\t                nextVertex[axis] = position[axis];\n\t                deleteTargetAnchor = true;\n\t            }\n\t        } else {\n\t            nextVertex[axis] = position[axis];\n\t        }\n\n\t        if (anchorFn && targetView) {\n\t            if (changeTargetAnchor) {\n\t                var targetAnchorPosition = data.targetAnchor.clone();\n\t                targetAnchorPosition[axis] = position[axis];\n\t                var targetAnchor = anchorFn.call(relatedView, targetAnchorPosition, targetView, relatedView.targetMagnet || targetView.el, 'target', relatedView);\n\t                this.resetAnchor('target', targetAnchor);\n\t            }\n\t            if (deleteTargetAnchor) {\n\t                this.resetAnchor('target', data.targetAnchorDef);\n\t            }\n\t        }\n\t        link.vertices(vertices, { ui: true, tool: this.cid });\n\t        this.updateHandle(handle, vertex, nextVertex, offset);\n\t        if (!options.stopPropagation) { relatedView.notifyPointermove(normalizedEvent, coords.x, coords.y); }\n\t    },\n\t    onHandleChangeStart: function(handle, evt) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var handles = ref.handles;\n\t        var linkView = ref.relatedView;\n\t        var model = linkView.model;\n\t        var paper = linkView.paper;\n\t        var index$1 = handle.options.index;\n\t        if (!Array.isArray(handles)) { return; }\n\t        for (var i = 0, n = handles.length; i < n; i++) {\n\t            if (i !== index$1) { handles[i].hide(); }\n\t        }\n\t        this.focus();\n\t        this.eventData(evt, {\n\t            sourceAnchor: linkView.sourceAnchor.clone(),\n\t            targetAnchor: linkView.targetAnchor.clone(),\n\t            sourceAnchorDef: clone(model.prop(['source', 'anchor'])),\n\t            targetAnchorDef: clone(model.prop(['target', 'anchor'])),\n\t            originalVertices: cloneDeep(model.vertices()),\n\t            firstHandleShifted: false\n\t        });\n\t        model.startBatch('segment-move', { ui: true, tool: this.cid });\n\t        if (!options.stopPropagation) { linkView.notifyPointerdown.apply(linkView, paper.getPointerArgs(evt)); }\n\t    },\n\t    onHandleChangeEnd: function(_handle, evt) {\n\t        var ref= this;\n\t        var options = ref.options;\n\t        var linkView = ref.relatedView;\n\t        var paper = linkView.paper;\n\t        var model = linkView.model;\n\t        if (options.redundancyRemoval) {\n\t            linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n\t        }\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t        this.render();\n\t        this.blur();\n\t        model.stopBatch('segment-move', { ui: true, tool: this.cid });\n\t        if (!options.stopPropagation) { linkView.notifyPointerup(normalizedEvent, coords.x, coords.y); }\n\t        linkView.checkMouseleave(normalizedEvent);\n\t    },\n\t    updateHandle: function(handle, vertex, nextVertex, offset) {\n\t        var vertical = Math.abs(vertex.x - nextVertex.x) < this.precision;\n\t        var horizontal = Math.abs(vertex.y - nextVertex.y) < this.precision;\n\t        if (vertical || horizontal) {\n\t            var segmentLine = new Line(vertex, nextVertex);\n\t            var length = segmentLine.length();\n\t            if (length < this.options.segmentLengthThreshold) {\n\t                handle.hide();\n\t            } else {\n\t                var position = segmentLine.midpoint();\n\t                var axis = (vertical) ? 'x' : 'y';\n\t                position[axis] += offset || 0;\n\t                var angle = segmentLine.vector().vectorAngle(new Point(1, 0));\n\t                handle.position(position.x, position.y, angle, this.relatedView);\n\t                handle.show();\n\t                handle.options.axis = axis;\n\t            }\n\t        } else {\n\t            handle.hide();\n\t        }\n\t    },\n\t    onRemove: function() {\n\t        this.resetHandles();\n\t    }\n\t}, {\n\t    SegmentHandle: SegmentHandle // keep as class property\n\t});\n\n\t// End Markers\n\tvar Arrowhead = ToolView.extend({\n\t    tagName: 'path',\n\t    xAxisVector: new Point(1, 0),\n\t    events: {\n\t        mousedown: 'onPointerDown',\n\t        touchstart: 'onPointerDown'\n\t    },\n\t    documentEvents: {\n\t        mousemove: 'onPointerMove',\n\t        touchmove: 'onPointerMove',\n\t        mouseup: 'onPointerUp',\n\t        touchend: 'onPointerUp',\n\t        touchcancel: 'onPointerUp'\n\t    },\n\t    options: {\n\t        scale: null\n\t    },\n\t    onRender: function() {\n\t        this.update();\n\t    },\n\t    update: function() {\n\t        var ratio = this.ratio;\n\t        var view = this.relatedView;\n\t        var tangent = view.getTangentAtRatio(ratio);\n\t        var position, angle;\n\t        if (tangent) {\n\t            position = tangent.start;\n\t            angle = tangent.vector().vectorAngle(this.xAxisVector) || 0;\n\t        } else {\n\t            position = view.getPointAtRatio(ratio);\n\t            angle = 0;\n\t        }\n\t        if (!position) { return this; }\n\t        var matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle);\n\t        var ref = this.options;\n\t        var scale = ref.scale;\n\t        if (scale) { matrix = matrix.scale(scale); }\n\t        this.vel.transform(matrix, { absolute: true });\n\t        return this;\n\t    },\n\t    onPointerDown: function(evt) {\n\t        if (this.guard(evt)) { return; }\n\t        evt.stopPropagation();\n\t        evt.preventDefault();\n\t        var relatedView = this.relatedView;\n\t        relatedView.model.startBatch('arrowhead-move', { ui: true, tool: this.cid });\n\t        if (relatedView.can('arrowheadMove')) {\n\t            relatedView.startArrowheadMove(this.arrowheadType);\n\t            this.delegateDocumentEvents();\n\t            relatedView.paper.undelegateEvents();\n\t        }\n\t        this.focus();\n\t        this.el.style.pointerEvents = 'none';\n\t    },\n\t    onPointerMove: function(evt) {\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var coords = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t        this.relatedView.pointermove(normalizedEvent, coords.x, coords.y);\n\t    },\n\t    onPointerUp: function(evt) {\n\t        this.undelegateDocumentEvents();\n\t        var relatedView = this.relatedView;\n\t        var paper = relatedView.paper;\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t        relatedView.pointerup(normalizedEvent, coords.x, coords.y);\n\t        paper.delegateEvents();\n\t        this.blur();\n\t        this.el.style.pointerEvents = '';\n\t        relatedView.model.stopBatch('arrowhead-move', { ui: true, tool: this.cid });\n\t    }\n\t});\n\n\tvar TargetArrowhead = Arrowhead.extend({\n\t    name: 'target-arrowhead',\n\t    ratio: 1,\n\t    arrowheadType: 'target',\n\t    attributes: {\n\t        'd': 'M -10 -8 10 0 -10 8 Z',\n\t        'fill': '#33334F',\n\t        'stroke': '#FFFFFF',\n\t        'stroke-width': 2,\n\t        'cursor': 'move',\n\t        'class': 'target-arrowhead'\n\t    }\n\t});\n\n\tvar SourceArrowhead = Arrowhead.extend({\n\t    name: 'source-arrowhead',\n\t    ratio: 0,\n\t    arrowheadType: 'source',\n\t    attributes: {\n\t        'd': 'M 10 -8 -10 0 10 8 Z',\n\t        'fill': '#33334F',\n\t        'stroke': '#FFFFFF',\n\t        'stroke-width': 2,\n\t        'cursor': 'move',\n\t        'class': 'source-arrowhead'\n\t    }\n\t});\n\n\tvar Boundary = ToolView.extend({\n\t    name: 'boundary',\n\t    tagName: 'rect',\n\t    options: {\n\t        padding: 10,\n\t        useModelGeometry: false,\n\t    },\n\t    attributes: {\n\t        'fill': 'none',\n\t        'stroke': '#33334F',\n\t        'stroke-width': .5,\n\t        'stroke-dasharray': '5, 5',\n\t        'pointer-events': 'none'\n\t    },\n\t    onRender: function() {\n\t        this.update();\n\t    },\n\t    update: function() {\n\t        var ref = this;\n\t        var view = ref.relatedView;\n\t        var options = ref.options;\n\t        var vel = ref.vel;\n\t        var useModelGeometry = options.useModelGeometry;\n\t        var rotate = options.rotate;\n\t        var padding = normalizeSides(options.padding);\n\t        var bbox = getViewBBox(view, useModelGeometry).moveAndExpand({\n\t            x: -padding.left,\n\t            y: -padding.top,\n\t            width: padding.left + padding.right,\n\t            height: padding.top + padding.bottom\n\t        });\n\t        var model = view.model;\n\t        if (model.isElement()) {\n\t            var angle = model.angle();\n\t            if (angle) {\n\t                if (rotate) {\n\t                    var origin = model.getBBox().center();\n\t                    vel.rotate(angle, origin.x, origin.y, { absolute: true });\n\t                } else {\n\t                    bbox = bbox.bbox(angle);\n\t                }\n\t            }\n\t        }\n\t        vel.attr(bbox.toJSON());\n\t        return this;\n\t    }\n\t});\n\n\tvar Anchor = ToolView.extend({\n\t    tagName: 'g',\n\t    type: null,\n\t    children: [{\n\t        tagName: 'circle',\n\t        selector: 'anchor',\n\t        attributes: {\n\t            'cursor': 'pointer'\n\t        }\n\t    }, {\n\t        tagName: 'rect',\n\t        selector: 'area',\n\t        attributes: {\n\t            'pointer-events': 'none',\n\t            'fill': 'none',\n\t            'stroke': '#33334F',\n\t            'stroke-dasharray': '2,4',\n\t            'rx': 5,\n\t            'ry': 5\n\t        }\n\t    }],\n\t    events: {\n\t        mousedown: 'onPointerDown',\n\t        touchstart: 'onPointerDown',\n\t        dblclick: 'onPointerDblClick',\n\t        dbltap: 'onPointerDblClick'\n\t    },\n\t    documentEvents: {\n\t        mousemove: 'onPointerMove',\n\t        touchmove: 'onPointerMove',\n\t        mouseup: 'onPointerUp',\n\t        touchend: 'onPointerUp',\n\t        touchcancel: 'onPointerUp'\n\t    },\n\t    options: {\n\t        snap: snapAnchor,\n\t        anchor: getAnchor,\n\t        scale: null,\n\t        resetAnchor: true,\n\t        customAnchorAttributes: {\n\t            'stroke-width': 4,\n\t            'stroke': '#33334F',\n\t            'fill': '#FFFFFF',\n\t            'r': 5\n\t        },\n\t        defaultAnchorAttributes: {\n\t            'stroke-width': 2,\n\t            'stroke': '#FFFFFF',\n\t            'fill': '#33334F',\n\t            'r': 6\n\t        },\n\t        areaPadding: 6,\n\t        snapRadius: 10,\n\t        restrictArea: true,\n\t        redundancyRemoval: true\n\t    },\n\t    onRender: function() {\n\t        this.renderChildren();\n\t        this.toggleArea(false);\n\t        this.update();\n\t    },\n\t    update: function() {\n\t        var type = this.type;\n\t        var relatedView = this.relatedView;\n\t        var view = relatedView.getEndView(type);\n\t        if (view) {\n\t            this.updateAnchor();\n\t            this.updateArea();\n\t            this.el.style.display = '';\n\t        } else {\n\t            this.el.style.display = 'none';\n\t        }\n\t        return this;\n\t    },\n\t    updateAnchor: function() {\n\t        var childNodes = this.childNodes;\n\t        if (!childNodes) { return; }\n\t        var anchorNode = childNodes.anchor;\n\t        if (!anchorNode) { return; }\n\t        var relatedView = this.relatedView;\n\t        var type = this.type;\n\t        var position = relatedView.getEndAnchor(type);\n\t        var options = this.options;\n\t        var customAnchor = relatedView.model.prop([type, 'anchor']);\n\t        var transformString =  \"translate(\" + (position.x) + \",\" + (position.y) + \")\";\n\t        if (options.scale) {\n\t            transformString += \" scale(\" + (options.scale) + \")\";\n\t        }\n\t        anchorNode.setAttribute('transform', transformString);\n\t        var anchorAttributes = (customAnchor) ? options.customAnchorAttributes : options.defaultAnchorAttributes;\n\t        for (var attrName in anchorAttributes) {\n\t            anchorNode.setAttribute(attrName, anchorAttributes[attrName]);\n\t        }\n\t    },\n\t    updateArea: function() {\n\t        var childNodes = this.childNodes;\n\t        if (!childNodes) { return; }\n\t        var areaNode = childNodes.area;\n\t        if (!areaNode) { return; }\n\t        var relatedView = this.relatedView;\n\t        var type = this.type;\n\t        var view = relatedView.getEndView(type);\n\t        var model = view.model;\n\t        var magnet = relatedView.getEndMagnet(type);\n\t        var padding = this.options.areaPadding;\n\t        if (!isFinite(padding)) { padding = 0; }\n\t        var bbox, angle, center;\n\t        if (view.isNodeConnection(magnet)) {\n\t            bbox = view.getNodeBBox(magnet);\n\t            angle = 0;\n\t            center = bbox.center();\n\t        } else {\n\t            bbox = view.getNodeUnrotatedBBox(magnet);\n\t            angle = model.angle();\n\t            center = bbox.center();\n\t            if (angle) { center.rotate(model.getBBox().center(), -angle); }\n\t            // TODO: get the link's magnet rotation into account\n\t        }\n\t        bbox.inflate(padding);\n\t        areaNode.setAttribute('x', -bbox.width / 2);\n\t        areaNode.setAttribute('y', -bbox.height / 2);\n\t        areaNode.setAttribute('width', bbox.width);\n\t        areaNode.setAttribute('height', bbox.height);\n\t        areaNode.setAttribute('transform', 'translate(' + center.x + ',' + center.y + ') rotate(' + angle + ')');\n\t    },\n\t    toggleArea: function(visible) {\n\t        var childNodes = this.childNodes;\n\t        if (!childNodes) { return; }\n\t        var areaNode = childNodes.area;\n\t        if (!areaNode) { return; }\n\t        areaNode.style.display = (visible) ? '' : 'none';\n\t    },\n\t    onPointerDown: function(evt) {\n\t        if (this.guard(evt)) { return; }\n\t        evt.stopPropagation();\n\t        evt.preventDefault();\n\t        this.paper.undelegateEvents();\n\t        this.delegateDocumentEvents();\n\t        this.focus();\n\t        this.toggleArea(this.options.restrictArea);\n\t        this.relatedView.model.startBatch('anchor-move', { ui: true, tool: this.cid });\n\t    },\n\t    resetAnchor: function(anchor) {\n\t        var type = this.type;\n\t        var relatedModel = this.relatedView.model;\n\t        if (anchor) {\n\t            relatedModel.prop([type, 'anchor'], anchor, {\n\t                rewrite: true,\n\t                ui: true,\n\t                tool: this.cid\n\t            });\n\t        } else {\n\t            relatedModel.removeProp([type, 'anchor'], {\n\t                ui: true,\n\t                tool: this.cid\n\t            });\n\t        }\n\t    },\n\t    onPointerMove: function(evt) {\n\n\t        var relatedView = this.relatedView;\n\t        var type = this.type;\n\t        var view = relatedView.getEndView(type);\n\t        var model = view.model;\n\t        var magnet = relatedView.getEndMagnet(type);\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var coords = this.paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n\t        var snapFn = this.options.snap;\n\t        if (typeof snapFn === 'function') {\n\t            coords = snapFn.call(relatedView, coords, view, magnet, type, relatedView, this);\n\t            coords = new Point(coords);\n\t        }\n\n\t        if (this.options.restrictArea) {\n\t            if (view.isNodeConnection(magnet)) {\n\t                // snap coords to the link's connection\n\t                var pointAtConnection = view.getClosestPoint(coords);\n\t                if (pointAtConnection) { coords = pointAtConnection; }\n\t            } else {\n\t                // snap coords within node bbox\n\t                var bbox = view.getNodeUnrotatedBBox(magnet);\n\t                var angle = model.angle();\n\t                var origin = model.getBBox().center();\n\t                var rotatedCoords = coords.clone().rotate(origin, angle);\n\t                if (!bbox.containsPoint(rotatedCoords)) {\n\t                    coords = bbox.pointNearestToPoint(rotatedCoords).rotate(origin, -angle);\n\t                }\n\t            }\n\t        }\n\n\t        var anchor;\n\t        var anchorFn = this.options.anchor;\n\t        if (typeof anchorFn === 'function') {\n\t            anchor = anchorFn.call(relatedView, coords, view, magnet, type, relatedView);\n\t        }\n\n\t        this.resetAnchor(anchor);\n\t        this.update();\n\t    },\n\n\t    onPointerUp: function(evt) {\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        this.paper.delegateEvents();\n\t        this.undelegateDocumentEvents();\n\t        this.blur();\n\t        this.toggleArea(false);\n\t        var linkView = this.relatedView;\n\t        if (this.options.redundancyRemoval) { linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid }); }\n\t        linkView.checkMouseleave(normalizedEvent);\n\t        linkView.model.stopBatch('anchor-move', { ui: true, tool: this.cid });\n\t    },\n\n\t    onPointerDblClick: function() {\n\t        var anchor = this.options.resetAnchor;\n\t        if (anchor === false) { return; } // reset anchor disabled\n\t        if (anchor === true) { anchor = null; } // remove the current anchor\n\t        this.resetAnchor(cloneDeep(anchor));\n\t        this.update();\n\t    }\n\t});\n\n\tvar SourceAnchor = Anchor.extend({\n\t    name: 'source-anchor',\n\t    type: 'source'\n\t});\n\n\tvar TargetAnchor = Anchor.extend({\n\t    name: 'target-anchor',\n\t    type: 'target'\n\t});\n\n\tvar Button = ToolView.extend({\n\t    name: 'button',\n\t    events: {\n\t        'mousedown': 'onPointerDown',\n\t        'touchstart': 'onPointerDown'\n\t    },\n\t    options: {\n\t        distance: 0,\n\t        offset: 0,\n\t        scale: null,\n\t        rotate: false\n\t    },\n\t    onRender: function() {\n\t        this.renderChildren(this.options.markup);\n\t        this.update();\n\t    },\n\t    update: function() {\n\t        this.position();\n\t        return this;\n\t    },\n\t    position: function() {\n\t        var ref = this;\n\t        var vel = ref.vel;\n\t        vel.transform(this.getCellMatrix(), { absolute: true });\n\t    },\n\t    getCellMatrix: function getCellMatrix() {\n\t        return this.relatedView.model.isLink() ? this.getLinkMatrix() : this.getElementMatrix();\n\t    },\n\t    getElementMatrix: function getElementMatrix() {\n\t        var ref = this;\n\t        var view = ref.relatedView;\n\t        var options = ref.options;\n\t        var x = options.x; if ( x === void 0 ) x = 0;\n\t        var y = options.y; if ( y === void 0 ) y = 0;\n\t        var offset = options.offset; if ( offset === void 0 ) offset = {};\n\t        var useModelGeometry = options.useModelGeometry;\n\t        var rotate = options.rotate;\n\t        var scale = options.scale;\n\t        var bbox = getViewBBox(view, useModelGeometry);\n\t        var angle = view.model.angle();\n\t        if (!rotate) { bbox = bbox.bbox(angle); }\n\t        var offsetX = offset.x; if ( offsetX === void 0 ) offsetX = 0;\n\t        var offsetY = offset.y; if ( offsetY === void 0 ) offsetY = 0;\n\t        if (isPercentage(x)) {\n\t            x = parseFloat(x) / 100 * bbox.width;\n\t        } else if (isCalcAttribute(x)) {\n\t            x = Number(evalCalcAttribute(x, bbox));\n\t        }\n\t        if (isPercentage(y)) {\n\t            y = parseFloat(y) / 100 * bbox.height;\n\t        } else if (isCalcAttribute(y)) {\n\t            y = Number(evalCalcAttribute(y, bbox));\n\t        }\n\t        var matrix = V.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n\t        if (rotate) { matrix = matrix.rotate(angle); }\n\t        matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);\n\t        if (scale) { matrix = matrix.scale(scale); }\n\t        return matrix;\n\t    },\n\t    getLinkMatrix: function getLinkMatrix() {\n\t        var ref = this;\n\t        var view = ref.relatedView;\n\t        var options = ref.options;\n\t        var offset = options.offset; if ( offset === void 0 ) offset = 0;\n\t        var distance = options.distance; if ( distance === void 0 ) distance = 0;\n\t        var rotate = options.rotate;\n\t        var scale = options.scale;\n\t        var tangent, position, angle;\n\t        if (isPercentage(distance)) {\n\t            tangent = view.getTangentAtRatio(parseFloat(distance) / 100);\n\t        } else {\n\t            tangent = view.getTangentAtLength(distance);\n\t        }\n\t        if (tangent) {\n\t            position = tangent.start;\n\t            angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;\n\t        } else {\n\t            position = view.getConnection().start;\n\t            angle = 0;\n\t        }\n\t        var matrix = V.createSVGMatrix()\n\t            .translate(position.x, position.y)\n\t            .rotate(angle)\n\t            .translate(0, offset);\n\t        if (!rotate) { matrix = matrix.rotate(-angle); }\n\t        if (scale) { matrix = matrix.scale(scale); }\n\t        return matrix;\n\t    },\n\t    onPointerDown: function(evt) {\n\t        if (this.guard(evt)) { return; }\n\t        evt.stopPropagation();\n\t        evt.preventDefault();\n\t        var actionFn = this.options.action;\n\t        if (typeof actionFn === 'function') {\n\t            actionFn.call(this.relatedView, evt, this.relatedView, this);\n\t        }\n\t    }\n\t});\n\n\tvar Remove = Button.extend({\n\t    children: [{\n\t        tagName: 'circle',\n\t        selector: 'button',\n\t        attributes: {\n\t            'r': 7,\n\t            'fill': '#FF1D00',\n\t            'cursor': 'pointer'\n\t        }\n\t    }, {\n\t        tagName: 'path',\n\t        selector: 'icon',\n\t        attributes: {\n\t            'd': 'M -3 -3 3 3 M -3 3 3 -3',\n\t            'fill': 'none',\n\t            'stroke': '#FFFFFF',\n\t            'stroke-width': 2,\n\t            'pointer-events': 'none'\n\t        }\n\t    }],\n\t    options: {\n\t        distance: 60,\n\t        offset: 0,\n\t        action: function(evt, view, tool) {\n\t            view.model.remove({ ui: true, tool: tool.cid });\n\t        }\n\t    }\n\t});\n\n\tvar Connect = Button.extend({\n\t    name: 'connect',\n\t    documentEvents: {\n\t        mousemove: 'drag',\n\t        touchmove: 'drag',\n\t        mouseup: 'dragend',\n\t        touchend: 'dragend',\n\t        touchcancel: 'dragend'\n\t    },\n\t    children: [{\n\t        tagName: 'circle',\n\t        selector: 'button',\n\t        attributes: {\n\t            'r': 7,\n\t            'fill': '#333333',\n\t            'cursor': 'pointer'\n\t        }\n\t    }, {\n\t        tagName: 'path',\n\t        selector: 'icon',\n\t        attributes: {\n\t            'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',\n\t            'fill': '#FFFFFF',\n\t            'stroke': 'none',\n\t            'stroke-width': 2,\n\t            'pointer-events': 'none'\n\t        }\n\t    }],\n\t    options: {\n\t        distance: 80,\n\t        offset: 0,\n\t        magnet: function (view) { return view.el; },\n\t        action: function (evt, _view, tool) { return tool.dragstart(evt); },\n\t    },\n\t    getMagnetNode: function() {\n\t        var assign;\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var relatedView = ref.relatedView;\n\t        var magnet = options.magnet;\n\t        var magnetNode;\n\t        switch (typeof magnet) {\n\t            case 'function': {\n\t                magnetNode = magnet.call(this, relatedView, this);\n\t                break;\n\t            }\n\t            case 'string': {\n\t                (assign = relatedView.findBySelector(magnet), magnetNode = assign[0]);\n\t                break;\n\t            }\n\t            default: {\n\t                magnetNode = magnet;\n\t                break;\n\t            }\n\t        }\n\t        if (!magnetNode) { magnetNode = relatedView.el; }\n\t        if (magnetNode instanceof SVGElement) { return magnetNode; }\n\t        throw new Error('Connect: magnet must be an SVGElement');\n\t    },\n\t    dragstart: function(evt) {\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var relatedView = ref.relatedView;\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var ref$1 = paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n\t        var x = ref$1.x;\n\t        var y = ref$1.y;\n\t        relatedView.dragLinkStart(normalizedEvent, this.getMagnetNode(), x, y);\n\t        paper.undelegateEvents();\n\t        this.delegateDocumentEvents(null, normalizedEvent.data);\n\t        this.focus();\n\t    },\n\t    drag: function(evt) {\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var relatedView = ref.relatedView;\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var ref$1 = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t        var x = ref$1.x;\n\t        var y = ref$1.y;\n\t        relatedView.dragLink(normalizedEvent, x, y);\n\t    },\n\t    dragend: function(evt) {\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var relatedView = ref.relatedView;\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var ref$1 = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t        var x = ref$1.x;\n\t        var y = ref$1.y;\n\t        relatedView.dragLinkEnd(normalizedEvent, x, y);\n\t        this.undelegateDocumentEvents();\n\t        paper.delegateEvents();\n\t        this.blur();\n\t        relatedView.checkMouseleave(normalizedEvent);\n\t    }\n\t});\n\n\tvar HoverConnect = Connect.extend({\n\n\t    name: 'hover-connect',\n\n\t    defaultMarkup: [\n\t        {\n\t            tagName: 'circle',\n\t            attributes: {\n\t                'r': 7,\n\t                'fill': '#333333',\n\t                'cursor': 'pointer'\n\t            }\n\t        },\n\t        {\n\t            tagName: 'path',\n\t            attributes: {\n\t                'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',\n\t                'fill': '#FFFFFF',\n\t                'stroke': 'none',\n\t                'stroke-width': 2\n\t            }\n\t        }\n\t    ],\n\n\t    children: function children() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var defaultMarkup = ref.defaultMarkup;\n\t        return [\n\t            {\n\t                tagName: 'path',\n\t                selector: 'track',\n\t                attributes: {\n\t                    'fill': 'none',\n\t                    'stroke': 'transparent',\n\t                    'stroke-width': options.trackWidth || 15,\n\t                    'cursor': 'pointer'\n\t                }\n\t            },\n\t            {\n\t                tagName: 'g',\n\t                selector: 'button',\n\t                attributes: {\n\t                    'pointer-events': 'none',\n\t                    'display': 'none'\n\t                },\n\t                children: options.markup || defaultMarkup\n\t            }\n\t        ];\n\t    },\n\n\t    events: Object.assign({\n\t        mousemove: 'onMousemove',\n\t        mouseenter: 'onMouseenter',\n\t        mouseleave: 'onMouseleave'\n\t    }, Connect.prototype.events),\n\n\t    onRender: function() {\n\t        this.renderChildren();\n\t        this.update();\n\t    },\n\n\t    trackPath: null,\n\n\t    update: function update() {\n\t        var ref = this;\n\t        var childNodes = ref.childNodes;\n\t        this.trackPath = this.getTrackPath();\n\t        Connect.prototype.update.apply(this, arguments);\n\t        childNodes.track.setAttribute(\n\t            'd',\n\t            this.trackPath.serialize()\n\t        );\n\t    },\n\n\t    position: function position() {\n\t        var ref = this;\n\t        var el = ref.el;\n\t        var childNodes = ref.childNodes;\n\t        childNodes.button.setAttribute(\n\t            'transform',\n\t            V.matrixToTransformString(this.getButtonMatrix())\n\t        );\n\t        el.setAttribute(\n\t            'transform',\n\t            V.matrixToTransformString(this.getTrackMatrix())\n\t        );\n\t    },\n\n\t    getButtonMatrix: function getButtonMatrix() {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var trackPath = ref.trackPath;\n\t        var offset = options.offset; if ( offset === void 0 ) offset = 0;\n\t        var distance = options.distance; if ( distance === void 0 ) distance = 0;\n\t        var rotate = options.rotate;\n\t        var scale = options.scale;\n\t        var tangent, position, angle;\n\t        if (isPercentage(distance)) {\n\t            tangent = trackPath.tangentAtRatio(parseFloat(distance) / 100);\n\t        } else {\n\t            tangent = trackPath.tangentAtLength(distance);\n\t        }\n\t        if (tangent) {\n\t            position = tangent.start;\n\t            angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;\n\t        } else {\n\t            position = trackPath.start;\n\t            angle = 0;\n\t        }\n\t        var matrix = V.createSVGMatrix()\n\t            .translate(position.x, position.y)\n\t            .rotate(angle)\n\t            .translate(0, offset);\n\t        if (!rotate) { matrix = matrix.rotate(-angle); }\n\t        if (scale) { matrix = matrix.scale(scale); }\n\t        return matrix;\n\t    },\n\n\t    getTrackPath: function getTrackPath() {\n\t        return this.relatedView.getConnection();\n\t    },\n\n\t    getTrackMatrix: function getTrackMatrix() {\n\t        return V.createSVGMatrix();\n\t    },\n\n\t    getTrackRatioFromEvent: function getTrackRatioFromEvent(evt) {\n\t        var ref = this;\n\t        var relatedView = ref.relatedView;\n\t        var trackPath = ref.trackPath;\n\t        var localPoint = relatedView.paper.clientToLocalPoint(evt.clientX, evt.clientY);\n\t        var trackPoint = V.transformPoint(localPoint, this.getTrackMatrix().inverse());\n\t        return trackPath.closestPointLength(trackPoint);\n\t    },\n\n\t    canShowButton: function canShowButton() {\n\t        // Has been the paper events undelegated? If so, we can't show the button.\n\t        // TODO: add a method to the paper to check if the events are delegated.\n\t        return $._data(this.paper.el, 'events');\n\t    },\n\n\t    showButton: function showButton() {\n\t        this.childNodes.button.style.display = 'block';\n\t    },\n\n\t    hideButton: function hideButton() {\n\t        this.childNodes.button.style.display = '';\n\t    },\n\n\t    onMousemove: function onMousemove(evt) {\n\t        var ref = this;\n\t        var trackPath = ref.trackPath;\n\t        if (!trackPath) { return; }\n\t        var ref$1 = this;\n\t        var options = ref$1.options;\n\t        options.distance = this.getTrackRatioFromEvent(evt);\n\t        this.position();\n\t    },\n\n\t    onMouseenter: function onMouseenter() {\n\t        if (!this.canShowButton()) { return; }\n\t        this.showButton();\n\t    },\n\n\t    onMouseleave: function onMouseleave() {\n\t        this.hideButton();\n\t    }\n\t});\n\n\n\n\tvar index$5 = ({\n\t\tVertices: Vertices,\n\t\tSegments: Segments,\n\t\tTargetArrowhead: TargetArrowhead,\n\t\tSourceArrowhead: SourceArrowhead,\n\t\tBoundary: Boundary,\n\t\tSourceAnchor: SourceAnchor,\n\t\tTargetAnchor: TargetAnchor,\n\t\tButton: Button,\n\t\tRemove: Remove,\n\t\tConnect: Connect,\n\t\tHoverConnect: HoverConnect\n\t});\n\n\tvar Control = ToolView.extend({\n\t    tagName: 'g',\n\t    children: [{\n\t        tagName: 'circle',\n\t        selector: 'handle',\n\t        attributes: {\n\t            'cursor': 'pointer',\n\t            'stroke-width': 2,\n\t            'stroke': '#FFFFFF',\n\t            'fill': '#33334F',\n\t            'r': 6\n\t        }\n\t    }, {\n\t        tagName: 'rect',\n\t        selector: 'extras',\n\t        attributes: {\n\t            'pointer-events': 'none',\n\t            'fill': 'none',\n\t            'stroke': '#33334F',\n\t            'stroke-dasharray': '2,4',\n\t            'rx': 5,\n\t            'ry': 5\n\t        }\n\t    }],\n\t    events: {\n\t        mousedown: 'onPointerDown',\n\t        touchstart: 'onPointerDown',\n\t        dblclick: 'onPointerDblClick',\n\t        dbltap: 'onPointerDblClick'\n\t    },\n\t    documentEvents: {\n\t        mousemove: 'onPointerMove',\n\t        touchmove: 'onPointerMove',\n\t        mouseup: 'onPointerUp',\n\t        touchend: 'onPointerUp',\n\t        touchcancel: 'onPointerUp'\n\t    },\n\t    options: {\n\t        handleAttributes: null,\n\t        selector: 'root',\n\t        padding: 6,\n\t        scale: null\n\t    },\n\n\t    getPosition: function() {\n\t        // To be overridden\n\t    },\n\t    setPosition: function() {\n\t        // To be overridden\n\t    },\n\t    resetPosition: function() {\n\t        // To be overridden\n\t    },\n\t    onRender: function() {\n\t        this.renderChildren();\n\t        this.toggleExtras(false);\n\t        this.update();\n\t    },\n\t    update: function() {\n\t        var ref = this.childNodes;\n\t        var handle = ref.handle;\n\t        var extras = ref.extras;\n\t        if (handle) {\n\t            this.updateHandle(handle);\n\t        } else {\n\t            throw new Error('Control: markup selector `handle` is required');\n\t        }\n\t        if (extras) {\n\t            this.updateExtras(extras);\n\t        }\n\t        return this;\n\t    },\n\t    updateHandle: function(handleNode) {\n\t        var ref = this;\n\t        var relatedView = ref.relatedView;\n\t        var options = ref.options;\n\t        var model = relatedView.model;\n\t        var relativePos = this.getPosition(relatedView, this);\n\t        var absolutePos = model.getAbsolutePointFromRelative(relativePos);\n\t        var handleAttributes = options.handleAttributes;\n\t        var scale = options.scale;\n\t        var transformString =  \"translate(\" + (absolutePos.x) + \",\" + (absolutePos.y) + \")\";\n\t        if (scale) {\n\t            transformString += \" scale(\" + scale + \")\";\n\t        }\n\t        handleNode.setAttribute('transform', transformString);\n\t        if (handleAttributes) {\n\t            for (var attrName in handleAttributes) {\n\t                handleNode.setAttribute(attrName, handleAttributes[attrName]);\n\t            }\n\t        }\n\t    },\n\t    updateExtras: function(extrasNode) {\n\t        var ref = this;\n\t        var relatedView = ref.relatedView;\n\t        var options = ref.options;\n\t        var ref$1 = this.options;\n\t        var selector = ref$1.selector;\n\t        if (!selector) {\n\t            this.toggleExtras(false);\n\t            return;\n\t        }\n\t        var ref$2 = relatedView.findBySelector(selector);\n\t        var magnet = ref$2[0];\n\t        if (!magnet) { throw new Error('Control: invalid selector.'); }\n\t        var padding = options.padding;\n\t        if (!isFinite(padding)) { padding = 0; }\n\t        var bbox = relatedView.getNodeUnrotatedBBox(magnet);\n\t        var model = relatedView.model;\n\t        var angle = model.angle();\n\t        var center = bbox.center();\n\t        if (angle) { center.rotate(model.getBBox().center(), -angle); }\n\t        bbox.inflate(padding);\n\t        extrasNode.setAttribute('x', -bbox.width / 2);\n\t        extrasNode.setAttribute('y', -bbox.height / 2);\n\t        extrasNode.setAttribute('width', bbox.width);\n\t        extrasNode.setAttribute('height', bbox.height);\n\t        extrasNode.setAttribute('transform', (\"translate(\" + (center.x) + \",\" + (center.y) + \") rotate(\" + angle + \")\"));\n\t    },\n\t    toggleExtras: function(visible) {\n\t        var ref = this.childNodes;\n\t        var extras = ref.extras;\n\t        if (!extras) { return; }\n\t        extras.style.display = (visible) ? '' : 'none';\n\t    },\n\t    onPointerDown: function(evt) {\n\t        var ref = this;\n\t        var relatedView = ref.relatedView;\n\t        var paper = ref.paper;\n\t        if (this.guard(evt)) { return; }\n\t        evt.stopPropagation();\n\t        evt.preventDefault();\n\t        paper.undelegateEvents();\n\t        this.delegateDocumentEvents();\n\t        this.focus();\n\t        this.toggleExtras(true);\n\t        relatedView.model.startBatch('control-move', { ui: true, tool: this.cid });\n\t    },\n\t    onPointerMove: function(evt) {\n\t        var ref = this;\n\t        var relatedView = ref.relatedView;\n\t        var paper = ref.paper;\n\t        var model = relatedView.model;\n\t        var ref$1 = normalizeEvent(evt);\n\t        var clientX = ref$1.clientX;\n\t        var clientY = ref$1.clientY;\n\t        var coords = paper.clientToLocalPoint(clientX, clientY);\n\t        var relativeCoords = model.getRelativePointFromAbsolute(coords);\n\t        this.setPosition(relatedView, relativeCoords, this);\n\t        this.update();\n\t    },\n\t    onPointerUp: function(_evt) {\n\t        var ref = this;\n\t        var relatedView = ref.relatedView;\n\t        var paper = ref.paper;\n\t        paper.delegateEvents();\n\t        this.undelegateDocumentEvents();\n\t        this.blur();\n\t        this.toggleExtras(false);\n\t        relatedView.model.stopBatch('control-move', { ui: true, tool: this.cid });\n\t    },\n\t    onPointerDblClick: function() {\n\t        var ref = this;\n\t        var relatedView = ref.relatedView;\n\t        this.resetPosition(relatedView, this);\n\t        this.update();\n\t    }\n\n\t});\n\n\tvar HoverConnect$1 = HoverConnect.extend({\n\n\t    getTrackPath: function getTrackPath() {\n\t        var ref = this;\n\t        var view = ref.relatedView;\n\t        var options = ref.options;\n\t        var useModelGeometry = options.useModelGeometry;\n\t        var trackPath = options.trackPath; if ( trackPath === void 0 ) trackPath = 'M 0 0 H calc(w) V calc(h) H 0 Z';\n\t        if (typeof trackPath === 'function') {\n\t            trackPath = trackPath.call(this, view);\n\t        }\n\t        if (isCalcAttribute(trackPath)) {\n\t            var bbox = getViewBBox(view, useModelGeometry);\n\t            trackPath = evalCalcAttribute(trackPath, bbox);\n\t        }\n\t        return new Path(V.normalizePathData(trackPath));\n\t    },\n\n\t    getTrackMatrix: function getTrackMatrix() {\n\t        var ref = this;\n\t        var view = ref.relatedView;\n\t        var options = ref.options;\n\t        var useModelGeometry = options.useModelGeometry;\n\t        var rotate = options.rotate;\n\t        var bbox = getViewBBox(view, useModelGeometry);\n\t        var angle = view.model.angle();\n\t        if (!rotate) { bbox = bbox.bbox(angle); }\n\t        var matrix = V.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n\t        if (rotate) { matrix = matrix.rotate(angle); }\n\t        matrix = matrix.translate(- bbox.width / 2, - bbox.height / 2);\n\t        return matrix;\n\t    }\n\n\t});\n\n\n\n\tvar index$6 = ({\n\t\tButton: Button,\n\t\tRemove: Remove,\n\t\tConnect: Connect,\n\t\tBoundary: Boundary,\n\t\tHoverConnect: HoverConnect$1,\n\t\tControl: Control\n\t});\n\n\tvar version = \"3.7.1\";\n\n\tvar Vectorizer = V;\n\tvar layout = { PortLabel: PortLabel, Port: Port };\n\tvar setTheme = function(theme, opt) {\n\n\t    opt = opt || {};\n\n\t    invoke(views, 'setTheme', theme, opt);\n\n\t    // Update the default theme on the view prototype.\n\t    View.prototype.defaultTheme = theme;\n\t};\n\n\tvar layout$1 = { DirectedGraph: DirectedGraph, PortLabel: PortLabel, Port: Port };\n\n\t// export empty namespaces - backward compatibility\n\tvar format$1 = {};\n\tvar ui = {};\n\n\texports.V = V;\n\texports.Vectorizer = Vectorizer;\n\texports.anchors = anchors;\n\texports.config = config;\n\texports.connectionPoints = connectionPoints;\n\texports.connectionStrategies = index$4;\n\texports.connectors = connectors;\n\texports.dia = index$2;\n\texports.elementTools = index$6;\n\texports.env = env;\n\texports.format = format$1;\n\texports.g = g;\n\texports.highlighters = highlighters;\n\texports.layout = layout$1;\n\texports.linkAnchors = linkAnchors;\n\texports.linkTools = index$5;\n\texports.mvc = index$1;\n\texports.routers = routers;\n\texports.setTheme = setTheme;\n\texports.shapes = index$3;\n\texports.ui = ui;\n\texports.util = index;\n\texports.version = version;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\nif (typeof joint !== 'undefined') { var g = joint.g, V = joint.V, Vectorizer = joint.V; }\n"],"names":["$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","factory","root","define","amd","_","$","exports1","Backbone","e","_listening","previousBackbone","slice","Array","prototype","VERSION","noConflict","emulateHTTP","emulateJSON","Events","eventSplitter","eventsApi","iteratee","events","name","callback","opts","names","i","context","keys","length","test","split","on","_events","onApi","ctx","listening","listeners","_listeners","interop","listenTo","obj","_listenId","uniqueId","listeningTo","_listeningTo","Listening","error","tryCatchOn","options","handlers","count","push","off","offApi","stopListening","ids","isEmpty","cleanup","remaining","j","handler","_callback","once","onceMap","bind","listenToOnce","map","offer","apply","arguments","trigger","Math","max","args","triggerApi","objEvents","allEvents","all","triggerEvents","concat","ev","l","a1","a2","a3","listener","unbind","extend","Model","attributes","attrs","preinitialize","cid","cidPrefix","collection","parse","defaults","result","set","changed","initialize","validationError","idAttribute","toJSON","clone","sync","get","attr","escape","has","matches","key","val","_validate","unset","silent","changes","changing","_changing","_previousAttributes","current","prev","isEqual","prevId","_pending","clear","hasChanged","changedAttributes","diff","old","previous","previousAttributes","fetch","model","success","resp","serverAttrs","wrapError","save","wait","validate","method","isNew","patch","xhr","destroy","defer","url","base","urlError","replace","encodeURIComponent","constructor","isValid","Collection","models","comparator","_reset","reset","setOptions","add","remove","merge","addOptions","splice","array","insert","at","min","tail","singular","isArray","removed","_removeModels","added","merged","_isModel","toAdd","toMerge","toRemove","modelMap","sort","sortable","sortAttr","isString","existing","_prepareModel","_addReference","orderChanged","some","m","index","_removeReference","previousModels","pop","unshift","shift","_byId","modelId","where","first","findWhere","isFunction","sortBy","pluck","create","callbackOpts","_forwardPristineError","values","CollectionIterator","ITERATOR_VALUES","ITERATOR_KEYS","entries","ITERATOR_KEYSVALUES","indexOf","_onModelEvent","event","$$iterator","Symbol","iterator","kind","_collection","_kind","_index","next","value","done","View","pick","viewOptions","_ensureElement","delegateEventSplitter","tagName","selector","$el","find","render","_removeElement","setElement","element","undelegateEvents","_setElement","delegateEvents","el","match","delegate","eventName","undelegate","_createElement","document","createElement","className","_setAttributes","addMethod","attribute","cb","defaultVal","addUnderscoreMethods","Class","methods","each","instance","isObject","modelMatcher","matcher","forEach","collect","reduce","foldl","inject","reduceRight","foldr","detect","filter","select","reject","every","any","include","includes","contains","invoke","toArray","size","head","take","initial","rest","drop","last","without","difference","shuffle","lastIndexOf","chain","sample","partition","groupBy","countBy","indexBy","findIndex","findLastIndex","pairs","invert","omit","config","Base","mixin","mappings","functions","memo","type","methodMap","params","dataType","data","contentType","JSON","stringify","_method","beforeSend","setRequestHeader","processData","textStatus","errorThrown","ajax","Router","routes","_bindRoutes","optionalParam","namedParam","splatParam","escapeRegExp","route","isRegExp","_routeToRegExp","router","history","fragment","_extractParameters","execute","navigate","RegExp","optional","exec","param","decodeURIComponent","History","checkUrl","location","routeStripper","rootStripper","pathStripper","started","interval","atRoot","path","pathname","getSearch","matchRoot","rootPath","decodeFragment","decodeURI","href","getHash","window1","getPath","charAt","getFragment","_usePushState","_wantsHashChange","start","_trailingSlash","trailingSlash","hashChange","_hasHashChange","documentMode","_useHashChange","_wantsPushState","pushState","_hasPushState","iframe","src","style","display","tabIndex","body","iWindow","insertBefore","firstChild","contentWindow","open","close","hash","addEventListener","attachEvent","_checkUrlInterval","setInterval","loadUrl","stop","removeEventListener","detachEvent","removeChild","clearInterval","decodedFragment","title","assign","_updateHash","protoProps","staticProps","child","parent","__super__","hasOwnProperty","Iterable","NAME","IteratorConstructor","DEFAULT","IS_SET","FORCED","CurrentIteratorPrototype","getIterationMethod","TO_STRING_TAG","INCORRECT_VALUES_NAME","IterablePrototype","nativeIterator","defaultIterator","anyNativeIterator","descriptor","caf","client","widthFn","heightFn","has$1","activeXDocument","IteratorPrototype","PrototypeOfArrayIteratorPrototype","arrayIterator","commonjsGlobal","createCommonjsModule","fn","check","it","global_1","Function","fails","descriptors","Object","defineProperty","nativePropertyIsEnumerable","propertyIsEnumerable","getOwnPropertyDescriptor","objectPropertyIsEnumerable","f","NASHORN_BUG","V","enumerable","createPropertyDescriptor","bitmap","configurable","writable","toString","classofRaw","indexedObject","requireObjectCoercible","undefined","TypeError","toIndexedObject","toPrimitive","input","PREFERRED_STRING","valueOf","hasOwnProperty$1","document$1","EXISTS","documentCreateElement","ie8DomDefine","a","nativeGetOwnPropertyDescriptor","objectGetOwnPropertyDescriptor","O","P","anObject","String","nativeDefineProperty","objectDefineProperty","Attributes","createNonEnumerableProperty","object","setGlobal","SHARED","store","functionToString","sharedStore","inspectSource","WeakMap","nativeWeakMap","shared","version","mode","copyright","postfix","random","uid","sharedKey","hiddenKeys","WeakMap$1","store$1","state","wmget","wmhas","wmset","metadata","facade","STATE","internalState","enforce","getterFor","TYPE","redefine","getInternalState","enforceInternalState","TEMPLATE","unsafe","simple","noTargetGet","source","join","aFunction","variable","getBuiltIn","namespace","ceil","floor","toInteger","argument","isNaN","toLength","min$1","toAbsoluteIndex","integer","createMethod","IS_INCLUDES","$this","fromIndex","arrayIncludes","objectKeysInternal","enumBugKeys","hiddenKeys$1","objectGetOwnPropertyNames","getOwnPropertyNames","objectGetOwnPropertySymbols","getOwnPropertySymbols","ownKeys","copyConstructorProperties","target","replacement","isForced","feature","detection","normalize","POLYFILL","NATIVE","string","toLowerCase","getOwnPropertyDescriptor$1","_export","targetProperty","sourceProperty","TARGET","GLOBAL","STATIC","stat","isForced_1","forced","sham","nativeSymbol","useSymbolAsUid","WellKnownSymbolsStore","Symbol$1","createWellKnownSymbol","withoutSetter","wellKnownSymbol","objectKeys","objectDefineProperties","defineProperties","Properties","html","PROTOTYPE","SCRIPT","IE_PROTO","EmptyConstructor","scriptTag","content","LT","NullProtoObjectViaActiveX","write","temp","parentWindow","NullProtoObjectViaIFrame","iframeDocument","appendChild","F","NullProtoObject","domain","ActiveXObject","objectCreate","UNSCOPABLES","ArrayPrototype","addToUnscopables","cache","thrower","arrayMethodUsesToLength","METHOD_NAME","ACCESSORS","argument0","argument1","$includes","proto","aFunction$1","functionBindContext","that","b","c","entryUnbind","CONSTRUCTOR","METHOD","toObject","arg","SPECIES","arraySpeciesCreate","originalArray","C","createMethod$1","IS_MAP","IS_FILTER","IS_SOME","IS_EVERY","IS_FIND_INDEX","IS_FILTER_OUT","NO_HOLES","callbackfn","specificCreate","self1","boundFunction","arrayIteration","filterOut","$find","FIND","SKIPS_HOLES","USES_TO_LENGTH$1","createMethod$2","CONVERT_TO_STRING","pos","second","S","position","charCodeAt","stringMultibyte","codeAt","correctPrototypeGetter","getPrototypeOf","IE_PROTO$1","ObjectPrototype","objectGetPrototypeOf","ITERATOR","BUGGY_SAFARI_ITERATORS","iteratorsCore","defineProperty$1","setToStringTag","TAG","iterators","IteratorPrototype$1","returnThis$1","createIteratorConstructor","aPossiblePrototype","objectSetPrototypeOf","setPrototypeOf","setter","CORRECT_SETTER","__proto__","IteratorPrototype$2","BUGGY_SAFARI_ITERATORS$1","ITERATOR$1","KEYS","VALUES","ENTRIES","returnThis$2","STRING_ITERATOR","setInternalState","iterated","point","KIND","iteratorClose","returnMethod","callWithSafeIterationClosing","ITERATOR$2","ArrayPrototype$1","createProperty","propertyKey","TO_STRING_TAG$1","toStringTagSupport","TO_STRING_TAG$2","CORRECT_ARGUMENTS","tryGet","classof","tag","callee","ITERATOR$3","getIteratorMethod","ITERATOR$4","SAFE_CLOSING","called","iteratorWithReturn","from","checkCorrectnessOfIteration","SKIP_CLOSING","ITERATION_SUPPORT","iterable","arrayLike","step","argumentsLength","mapfn","mapping","iteratorMethod","$findIndex","FIND_INDEX","SKIPS_HOLES$1","USES_TO_LENGTH$2","chars","InvalidCharacterError","message","btoa","block","charCode","str","idx","output","atob","bs","buffer","bc","fromCharCode","number","Number","globalIsFinite","isFinite","MATCH","isRegexp","notARegexp","MATCH$1","correctIsRegexpLogic","regexp","error1","error2","searchString","getOwnPropertyDescriptor$2","nativeStartsWith","startsWith","min$2","CORRECT_IS_REGEXP_LOGIC","search","subarray","end","set_","offset","n","TypedArray","arg1","byteLength","Uint8Array","Uint32Array","Int32Array","props","x","y","width","height","minimum","maximum","diagonal","propsList","numberPattern","findSpacesRegex","parseExpressionRegExp","throwInvalid","expression","isCalcAttribute","calcStart","calcStartOffset","evalCalcAttribute","attributeValue","refBBox","startSearchIndex","calcIndex","calcEndIndex","brackets","findClosingBracket","calcValue","evalCalcExpression","bbox","lastIndex","multiply","property","divide","sqrt","parseFloat","evalAddExpression","addExpression","substr","round","floor$1","PI","normalizeAngle","angle","snapToGrid","gridSize","toDeg","rad","toRad","deg","over360","cos","sin","atan2","bearing","p","q","lat1","lat2","lon1","dLon","lon2","brng","bearings","parseInt","squaredLength","x0","y0","x1","y1","types","Point","Line","Ellipse","Rect","Polyline","Polygon","Curve","Path","abs","cos$1","sin$1","min$3","max$1","atan2$1","round$1","pow","PI$1","xy","fromPolar","distance","origin","x2","y2","chooseClosest","points","closest","minSqrDistance","Infinity","sqrDistance","squaredDistance","adhereToRect","r","containsPoint","angleBetween","p1","p2","equals","NaN","theta","changeInAngle","dx","dy","ref","cross","dot","lerp","t","magnitude","manhattanDistance","move","scale","reflection","rotate","cosAngle","sinAngle","precision","sx","sy","gx","gy","toPolar","o","serialize","update","vectorAngle","zero","translate","max$2","min$4","horizontalPoint","left","top","right","bottom","closestPoint","pointAt","closestPointNormalizedLength","closestPointLength","product","vector","cpNormalizedLength","closestPointTangent","tangentAt","divideAt","ratio","dividerPoint","divideAtLength","pointAtLength","intersect","shape","opt","intersectionWithLine","intersection","line","pt1Dir","pt2Dir","det","deltaPt","alpha","beta","isDifferentiable","midpoint","parallel","eRef","sRef","fromStart","lineLength","pointOffset","determinant","setLength","currentLength","scaleFactor","tangentStart","tangentLine","tangentAtLength","tx","ty","sqrt$1","round$2","pow$1","fromRect","rect","center","normalizedDistance","ellipse","inflate","intersections","rx","ry","dir","mDir","mDiff","d","ta","tb","intersectionWithLineFromCenterToPoint","pointNearestToPoint","mSquared","tangentTheta","q1","q3","abs$1","cos$2","sin$2","min$5","max$3","round$3","pow$2","w","h","parsePoints","svgString","trimmedString","trim","coords","numCoords","clonePoints","numPoints","newPoints","convexHull","startPoint","currentPointRecord","currentPoint","lastHullPointRecord","lastHullPoint","secondLastHullPointRecord","secondLastHullPoint","lowestHullIndex","sortedPointRecords","entry","record1","record2","sortOutput","startPointRecord","insidePoints","hullPointRecords","correctTurnFound","crossProduct","indexOfLowestHullIndexRecord","currentHullIndex","hullPointRecordsReordered","newFirstChunk","newSecondChunk","hullPoints","fromEllipse","fromPointUnion","minX","minY","maxX","maxY","len","fromRectUnion","rects","mX","mY","rotateAroundCenter","st","ct","bottomLeft","bottomLine","bottomRight","bottomMiddle","containsRect","r0","r1","w0","h0","w1","h1","corner","mr","nr","myOrigin","myCorner","rOrigin","rCorner","pt","rectLines","topLine","rightLine","leftLine","dedupeArr","sides","connector","topLeft","leftMiddle","maxRectScaleToFit","sx1","sx2","sx3","sx4","sy1","sy2","sy3","sy4","ox","oy","p3","topRight","p4","maxRectUniformScaleToFit","moveAndExpand","newx","newy","newwidth","newheight","sideNearestToPoint","rightMiddle","distToLeft","distToRight","distToTop","distToBottom","side","topMiddle","union","cpLength","lengthPoints","cp","startIndex","endIndex","numIntersections","segment","ray","rayEnd","xDifference","otherPoints","otherPoint","l2","int","polylineLength","lastPoint","simplify","threshold","currentIndex","firstIndex","middleIndex","firstPoint","middlePoint","closestPointDistance","chord","lastValidLine","abs$2","sqrt$2","min$6","max$4","pow$3","controlPoint1","controlPoint2","arguments$1","inheritedProperty","throughPoints","getFirstControlPoints","rhs","tmp","controlPoints","getCurveControlPoints","knots","firstControlPoints","secondControlPoints","curves","t1","t2","b2ac","sqrtb2ac","mt","x3","y3","tvalues","bounds","jlen","X","Y","pointAtT","closestPointT","PRECISION","subdivisions","getSubdivisions","localOpt","lengthAtT","investigatedSubdivision","investigatedSubdivisionStartT","investigatedSubdivisionEndT","distFromStart","distFromEnd","chordLength","minSumDist","subdivisionSize","currentSubdivision","startDist","endDist","sumDist","precisionRatio","startPrecisionRatio","endPrecisionRatio","hasRequiredPrecision","hasMinimalStartDistance","hasMinimalEndDistance","hasMinimalDistance","divided","startDist1","endDist1","sumDist1","startDist2","endDist2","tangentAtT","polyline","toPolyline","divideAtT","tAt","tAtLength","dividerPoints","getSkeletonPoints","startControl1","startControlPoint1","startControl2","startControlPoint2","divider","dividerControl1","dividerControlPoint1","dividerControl2","dividerControlPoint2","endpointDistance","control1","control2","midpoint1","midpoint2","midpoint3","subControl1","subControl2","previousLength","minIterations","iteration","newSubdivisions","numSubdivisions","numNewSubdivisions","currentNewSubdivision","observedPrecisionRatio","subCurve","skeletonPoints","curveLength","baselinePointDistFromStart","baselinePointDistFromEnd","newBaselinePointDistFromStart","newBaselinePointDistFromEnd","baseline1Length","baseline2Length","toPoints","segments","acc","isSegment","appendSegment","previousObj","createSegment","applyToNew","argsArray","pathData","commands","numCommands","command","argRe","segmentConstructor","segmentTypes","currentSegment","numSegments","previousSegment","currentArg","prepareSegment","isVisible","segmentBBox","lastSegment","segmentSubdivisions","getSegmentSubdivisions","minSquaredDistance","segmentClosestPointT","segmentClosestPoint","segmentIndex","polylines","toPolylines","numPolylines","pathLength","dividedSegmentIndex","lastValidSegment","lastValidSegmentIndex","getSegment","pathCopy","replaceSegment","divisionStartIndex","divisionMidIndex","divisionEndIndex","removeSegment","movetoEnd","insertSegment","secondPathSegmentIndexConversion","originalSegment","subpathStartSegment","convertedSegment","otherSegments","otherSegment","getSubpaths","validatedPath","subpaths","isSubpathStart","nextSegment","polylineIntersection","tValue","precisison","lastVisibleSegment","updateSubpathStart","updateSubpathStartSegment","removedSegment","replacedSegment","segmentAt","segmentIndexAt","segmentAtLength","segmentIndexAtLength","lastVisibleSegmentIndex","partialPoints","currentSegmentSubdivisions","subdivisionPoints","curve","segmentPrototype","Lineto","outputArray","segmentCoords","segmentPoint","linetoPrototype","Curveto","segmentPoints","curvetoPrototype","c1","c2","Moveto","movetoPrototype","Closepath","closepathPrototype","L","M","Z","z","regexSupportedData","isDataSupported","lineWithLine","line1","line2","x4","y4","s1x","s1y","s2x","s2y","s3x","s3y","s","ellipseWithLine","rex","rey","xe","ye","rex_2","rey_2","A","B","D","ellipseWithEllipse","ellipse1","ellipse2","sinW1","cosW1","sinW2","cosW2","sinW1s","cosW1s","sinW2s","cosW2s","a1s","b1s","a2s","b2s","A1","A2","B1","B2","C1","C2","D1","D2","E1","E2","F1","F2","l3","l0","l1","delta1","delta2","delta3","e1","e2","det3","det2","dP","rectWithLine","rectWithEllipse","rectWithRect","polygonWithEllipse","rect1","rect2","polylineWithLine","_polylineWithLine","interior","polylineWithEllipse","_polylineWithEllipse","polylineWithRect","_polylineWithRect","polylineWithPolyline","polyline1","polyline2","_polylineWithPolyline","polygonWithLine","polygon","polygonWithRect","polygonWithPolyline","polygonWithPolygon","polygon1","polygon2","_polylineWithPolygon","pathWithLine","pathOpt","subpath","ref$1","pathWithEllipse","pathWithRect","pathWithPolygon","pathWithPolyline","_pathWithPolyline","pathWithPath","path1","path2","pathOpt1","pathOpt2","thisPoints","thisPolyline","g","exists","shape1","shape2","shape1opt","shape2opt","linear","range","domainSpan","rangeSpan","bezier","curveThroughPoints","console","warn","getCurveDivider","p0","getInversionSolver","SVGAngle","ns","svg","xmlns","xml","xlink","xhtml","math","children","isV","node","createSvgDocument","svgDoc","childNodes","arrayOfVels","childNode","importNode","createElementNS","ensureId","setAttributes","append","VPrototype","getTransformToElement","isSVGGraphicsElement","targetCTM","toNode","getScreenCTM","nodeCTM","inverse","createSVGMatrix","transform","matrix","isUndefined","transformStringToMatrix","absolute","matrixToTransformString","svgTransform","createSVGTransform","baseVal","appendItem","transformAttr","parseTransformString","newTx","newTy","newTranslate","cx","cy","newAngle","newScale","withoutTransformations","box","ownerSVGElement","getBBox","clientLeft","clientTop","clientWidth","clientHeight","transformRect","recursive","outputBBox","childBBox","currentChild","emRegex","convertEmToPx","em","fontSize","numerical","text","sanitizeText","rh","displayEmpty","eol","textPath","verticalAnchor","textVerticalAnchor","namedVerticalAnchor","iai","includeAnnotationIndices","annotations","defaultLineHeight","lineHeight","autoLineHeight","empty","doc","containerNode","createTextPathNode","vel","textPathElement","linkedPath","appendTo","defs","createDocumentFragment","lines","linesMetrics","lastI","annotatedY","lineMetrics","lineClassName","lineNode","lineAnnotations","annotateString","iLineHeight","annotateTextLine","baseSize","maxFontSize","fontMetrics","lastJ","annotation","annotationAttrs","vTSpan","tspanNode","textContent","annotationClass","addClass","createTextNode","lineNodeStyle","fillOpacity","strokeOpacity","findAnnotationsAtIndex","lineFontSize","fs","setAttribute","calculateDY","alignment","baseSizePx","flMaxFont","rLineHeights","lineHeightPx","llMaxFont","removeAttr","qualifiedName","qualifyAttr","hasAttributeNS","local","removeAttributeNS","hasAttribute","removeAttribute","getAttribute","attrName","normalizePath","normalizePathData","parentNode","els","prepend","before","SVGSVGElement","toUpperCase","defsNode","getElementsByTagName","cloneNode","findOne","found","querySelector","vels","nodes","querySelectorAll","nodeType","previousSibling","findParentByClass","terminator","hasClass","bup","compareDocumentPosition","toLocalPoint","createSVGPoint","globalPoint","matrixTransform","globalToLocalMatrix","translateCenterToPoint","translateAndAutoOrient","reference","translateToOrigin","setTranslate","rotateAroundOrigin","setRotate","translateFromOrigin","finalPosition","ctm","setMatrix","animateAlongPath","animateMotion","mpath","beginElement","documentElement","animation","animators","animationID","id2anim","targets","getTargets","animator","Animator","noHTMLWhitespaceRegex","getTokenList","classList","removeClass","toggleClass","tokens","toggle","getTotalLength","samples","getPointAtLength","convertToPath","convertToPathData","convertLineToPathData","convertPolygonToPathData","convertPolylineToPathData","convertEllipseToPathData","convertCircleToPathData","convertRectToPathData","toGeometryShape","getPointsFromSvgNode","findIntersection","gRect","rectMatrix","rectMatrixComponents","decomposeMatrix","resetRotation","rotation","spot","gp","refDistance","pathNode","minDistance","closestSamples","centerDistance","setAttributeNS","XMLString","parseXML","async","createSVGStyle","stylesheet","createCDATASection","implementation","createDocument","idCounter","nodeName","parser","DOMParser","parseFromString","combinedKey","transformSeparatorRegex","transformRegex","transformFunctionRegex","transformTranslateRegex","transformRotateRegex","transformScaleRegex","transformationMatrix","transformMatches","numMatches","transformFunctionMatch","transformMatch","transformFunction","scaleNonUniform","skewX","skewY","separator","decomposedMatrix","translateX","translateY","scaleX","scaleY","transformations","translateMatch","rotateMatch","scaleMatch","deltaTransformPoint","px","py","matrixToScale","matrixToRotate","matrixToTranslate","isVElement","SVGElement","svgDocument","svgMatrix","component","SVGMatrix","createSVGTransformFromMatrix","corner1","corner2","corner3","corner4","transformPoint","transformLine","transformPolyline","inPoints","outPoints","styleToObject","styleString","ret","styles","pair","createSlicePathData","innerRadius","outerRadius","startAngle","endAngle","a0","da","df","c0","s0","s1","mergeAttrs","batch","item","compacted","findAnnotationsBetweenIndexes","shiftAnnotations","svgPointsToPath","nodePoints","numberOfItems","getItem","KAPPA","circle","cd","cdx","cdy","rectToPath","topRx","bottomRx","topRy","bottomRy","spaces","pathCommand","pathValues","tan","asin","q2c","ax","ay","_13","_23","pathToAbsolute","pathArray","parsePathString","pathString","paramCounts","v","res","mx","my","ii","pa0","jj","pa","kk","k","bx","by","qx","qy","pcoms","pfirst","pcom","processPath","nx","ny","T","Q","a2c","large_arc_flag","sweep_flag","_120","f1","f2","rx2","ry2","toFixed","f2old","x2old","y2old","s2","hx","hy","m1","m2","m3","m4","newres","fixArc","pp","pi","seg","seglen","useCSSSelectors","classNamePrefix","defaultTheme","doubleTapInterval","argsTag","arrayTag","boolTag","dateTag","errorTag","mapTag","numberTag","objectTag","regexpTag","setTag","stringTag","symbolTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","CLONEABLE_TAGS","rsAstralRange","rsDingbatRange","rsLowerRange","rsUpperRange","rsBreakRange","rsMathOpRange","rsApos","rsBreak","rsCombo","rsLower","rsMisc","rsFitz","rsNonAstral","rsRegional","rsSurrPair","rsUpper","rsMiscLower","rsOptContrLower","rsOptContrUpper","reOptMod","rsModifier","rsOptVar","rsOptJoin","rsSeq","rsEmoji","reUnicodeWords","rsMiscUpper","rsDigit","HASH_UNDEFINED","reTypedTag","reUnicode","reIsDeepProp","reIsPlainProp","reEscapeChar","rePropName","reIsUint","hasUnicodeWord","reAsciiWord","hasUnicode","stringToArray","keys$1","isArrayLike","arrayLikeKeys","baseKeys","isPrototype","inherited","isArr","isArg","isObjectLike","getTag","isType","isTypedArray","skipIndexes","isIndex","assocIndexOf","eq","other","isIterateeCall","isObject$1","Ctor","assignValue","objValue","copyObject","isSymbol","initCloneArray","copyArray","cloneArrayBuffer","arrayBuffer","cloneTypedArray","typedArray","isDeep","byteOffset","cloneRegExp","initCloneObject","getSymbols","symbols","symbol","initCloneByTag","Constructor","dataView","getAllKeys","getSymbolsIn","getAllKeysIn","getMapData","__data__","isKeyable","equalObjects","equalFunc","stack","compared","skipCtor","objProps","objLength","othProps","objStacked","othStacked","othValue","objCtor","othCtor","baseIsEqual","baseIsEqualDeep","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","Stack","equalArrays","equalByTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","compareUnordered","arrLength","arrStacked","seen","SetCache","returned","loop","arrValue","othIndex","cacheHas","predicate","compareArrayBufferTag","convert","mapToArray","setToArray","stacked","isKey","stringToPath","quote","subString","castPath","get$1","toKey","isCommon","valuesLength","outer","computed","valuesIndex","arrays","othLength","caches","maxLength","baseClone","isFlat","isFull","customizer","isFunc","copySymbolsIn","subValue","keysFunc","keysIn","set$1","nested","newValue","MAX_SAFE_INTEGER","toPlainObject","safeGet","createAssigner","assigner","isMerge","sources","guard","baseMerge","srcIndex","forIn","srcValue","baseMergeDeep","assignMergeValue","mergeFunc","isTyped","isPlainObject","isArguments","baseEach","baseFor","createSet","Set","customDefaultsMerge","matchesStrictComparable","hasIn","hasPath","baseHasIn","baseIteratee","matchData","getMatchData","baseIsMatch","noCustomizer","getIteratee","arrayReduce","accumulator","initAccum","baseReduce","eachFunc","isFlattenable","isConcatSpreadable","basePickBy","paths","hasFunc","castSlice","upperFirst","strSymbols","chr","trailing","ListCache","delete","LARGE_ARRAY_SIZE","MapCache","Hash","Map","isBoolean","isNumber","supplement","propsLength","propsIndex","deepSupplement","invokeProperty","func","sortedIndex","low","high","valIsNaN","valIsNull","valIsSymbol","valIsUndefined","mid","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","uniq","seenIndex","cloneDeep","debounce","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","useRaf","requestAnimationFrame","invokeFunc","time","thisArg","startTimer","pendingFunc","cancelAnimationFrame","setTimeout","shouldInvoke","timeSinceLastCall","timeSinceLastInvoke","timerExpired","timeWaiting","Date","now","trailingEdge","debounced","isInvoking","cancel","cancelTimer","clearTimeout","flush","pending","iteratees","orders","criteriaIndex","eachIndex","flat","criteria","baseSortBy","comparer","compareMultiple","objCriteria","othCriteria","ordersLength","order","cmpFn","valIsDefined","valIsReflexive","flattenDeep","baseFlatten","depth","isStrict","has$2","defaultValue","camelCase","pattern","words","word","prefix","addClassNamePrefix","_className","removeClassNamePrefix","parseDOMJSON","json","selectors","groupSelectors","svgNamespace","parseNode","siblingsDef","nodeDef","textNode","namespaceURI","wrapper","css","nodeSelector","nodeGroups","groupSelector","nodeGroup","group","childrenDef","hashCode","getByPath","delimiter","isGetSafe","setByPath","diver","value$1","unsetByPath","flattenObject","delim","shouldGoDeeper","flatObject","flatKey","uuid","guid","toKebabCase","normalizeEvent","evt","normalized","originalEvent","touch","changedTouches","useElement","correspondingUseElement","normalizeWheel","sX","sY","pX","pY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","deltaX","deltaY","deltaMode","shiftKey","spinX","spinY","cap","nextFrame","raf","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","lastTime","currTime","getTime","timeToCall","cancelFrame","webkitCancelAnimationFrame","webkitCancelRequestAnimationFrame","msCancelAnimationFrame","msCancelRequestAnimationFrame","oCancelAnimationFrame","oCancelRequestAnimationFrame","mozCancelAnimationFrame","mozCancelRequestAnimationFrame","isPercentage","parseCssNumeric","restrictUnits","validUnitExp","unit","getLineHeight","heightValue","textElement","breakText","textSpan","opacity","preserveSpaces","hyphen","maxLineCount","full","isEol","eolWords","splitWordWithEOL","jl","getComputedTextLength","substring","hyphenIndex","lastL","lastLineWithOmission","lastChar","ellipsis","lastLine","sanitizeHTML","parseHTML","currentNode","currentAttribute","attrValue","downloadBlob","blob","fileName","navigator","msSaveBlob","URL","createObjectURL","link","download","click","revokeObjectURL","dataUriToBlob","dataUri","decodedString","firstCommaIndex","dataTypeString","mimeString","unescape","ia","Blob","sortElements","elements","$elements","placements","sortElement","nextSibling","normalizeSides","vertical","horizontal","timing","quad","cubic","inout","t3","exponential","bounce","reverse","reflect","clamp","back","elastic","interpolate","hexColor","ca","ra","rd","ga","gd","ba","bd","ma","mb","u","outline","margin","template","color","highlight","blur","stdDeviation","dropShadow","grayscale","amount","sepia","saturate","hueRotate","amount2","brightness","contrast","regex","attrArray","_attr","noop","cloneCells","cells","cloneMap","cell","isLink","prop","embeds","newEmbeds","embed","validProperties","validPropertiesList","setWrapper","dimension","isValuePercentage","positionWrapper","delta","valuePercentage","refOrigin","offsetWrapper","nodeBBox","shapeWrapper","shapeConstructor","cacheName","resetOffset","$node","cachedShape","shapeBBox","shapeOrigin","fitScale","dWrapper","pointsWrapper","atConnectionWrapper","zeroVector","tangent","setIfChangedWrapper","isTextInUse","_value","_node","isLinkView","contextMarker","marker","stroke","setPaintURL","def","paper","definePattern","defineGradient","attributesNS","xlinkShow","xlinkRole","xlinkType","xlinkArcrole","xlinkTitle","xlinkActuate","xmlSpace","xmlBase","xmlLang","preserveAspectRatio","requiredExtension","requiredFeatures","systemLanguage","externalResourcesRequired","xlinkHref","qualify","defineFilter","fill","sourceMarker","defineMarker","targetMarker","vertexMarker","_text","textWrap","textAttrs","fontSizeAttr","textHash","pathSelector","findBySelector","SVGPathElement","wrappedText","breakTextFn","fontWeight","fontFamily","letterSpacing","firstElementChild","titleNode","port","properties","option","selected","refX","refY","refDx","refDy","refWidth","refHeight","refRx","refRy","refRInscribed","refRCircumscribed","rValue","diagonalLength","refCx","refCy","xAlignment","yAlignment","refDResetOffset","refDKeepOffset","refPointsResetOffset","refPointsKeepOffset","connection","stubs","getConnectionLength","getConnection","getConnectionSubdivisions","sourceParts","targetParts","getSerializedConnection","atConnectionLengthKeepGradient","atConnectionLengthIgnoreGradient","atConnectionRatioKeepGradient","atConnectionRatioIgnoreGradient","refR","refD","refPoints","atConnectionLength","atConnectionRatio","strokeWidth","refX2","refY2","refWidth2","refHeight2","Cell","defaultAttrs","finalAttrs","defaultAttr","value2","name2","getIdAttribute","generateId","_transitionIds","_scheduledTransitionIds","processPorts","previousPorts","ports","removedPorts","graph","inboundLinks","getConnectedLinks","inbound","outboundLinks","outbound","startBatch","parentCell","getParentCell","unembed","embeddedCells","getEmbeddedCells","stopBatch","toFront","deep","breadthFirst","sortedCells","maxZ","maxZIndex","shouldUpdate","toBack","minZIndex","this$1","canEmbed","isEmbedded","_embedCells","_unembedCells","isEmbeddedIn","batchName","parentId","getCell","getAncestors","ancestors","queue","cellId","_isString","pathArrayLength","options$1","propertyPath","propertyValue","propertyPathArray","rewrite","initializer","prevProperty","pathItem","isArrayIndex","baseAttributes","removeProp","dirty","nestedPath","transition","interpolatingFunction","initialId","duration","delay","timingFunction","valueFunction","firstFrameTime","runtime","progress","transitionId","stopPendingTransitions","getTransitions","stopScheduledTransitions","transitions","transitionIds","stopTransitions","addTo","addCell","findView","findViewByModel","isElement","getChangeFlag","flag","getPointFromConnectedLink","getPointRotatedAroundCenter","getAbsolutePointFromRelative","getRelativePointFromAbsolute","getAttributeDefinition","defNS","globalDefNS","defaultsDeep","joint","shapes","wrapWith","wrappers","Positions","TOP","RIGHT","BOTTOM","LEFT","TOP_LEFT","TOP_RIGHT","BOTTOM_LEFT","BOTTOM_RIGHT","CENTER","getRectPoint","portTransformAttrs","trans","lineLayout","elBBox","argTransform","ellipseLayout","stepFn","compensateRotation","dr","argPoint","Port","transformation","ellipseSpread","stepAngle","labelAttributes","opt1","opt2","outsideLayout","portPosition","autoOrient","textAnchor","getBBoxAngles","orientAngle","labelText","tl","bl","br","insideLayout","bBoxAngles","radialLayout","portCenterOffset","PortLabel","manual","_portPosition","_elBBox","outsideOriented","outside","insideOriented","inside","radial","radialOriented","Link","markup","toolMarkup","doubleToolMarkup","vertexMarkup","arrowheadMarkup","defaultLabel","labelMarkup","_builtins","pointerEvents","disconnect","setSource","setOpt","setTarget","isRouterProvided","localRouter","isConnectorProvided","localConnector","label","labels","hasLabels","insertLabel","appendLabel","removeLabel","vertex","vertices","setVertex","_normalizeVertex","setVertices","insertVertex","removeVertex","translateBy","applyToPoints","getSourcePoint","sourceCell","getSourceCell","getTargetPoint","targetCell","getTargetCell","getPolyline","reparent","newParent","getSourceElement","getTargetElement","prevParent","getCommonAncestor","hasLoop","sourceId","targetId","sourceElement","targetElement","visited","getRelationshipAncestor","connectionAncestor","isRelationshipEmbeddedIn","ancestor","_getDefaultLabel","endsEqual","portsEqual","PortData","clonedData","groups","portLayoutNamespace","portLabelLayoutNamespace","_init","getPorts","getGroup","getPortsByGroup","groupName","getGroupPortsMetrics","groupPosition","groupPositionName","groupArgs","portsArgs","groupPortTransformations","portTransformation","portId","labelTransformation","_getPortLabelLayout","portAttrs","portSize","labelSize","labelPosition","_evaluateGroup","items","_evaluatePort","_getPosition","_getLabel","evaluated","_createPositionNode","_getZIndex","setDefault","positionName","setDefaults","Element$1","_initializePorts","_refreshPorts","parentPosition","isSetter","parentRelative","restrictedArea","elementPosition","newPosition","translatedPosition","currentSize","resize","direction","quadrant","imageFixedPoint","radius","atan","scaledBBox","fitEmbeds","fitToChildren","childElements","_fitToElements","fitParent","parentElement","siblingElements","elementsBBox","getCellsBBox","expandOnly","shrinkOnly","padding","resultBBox","intersectionBBox","attributes_position","attributes_size","endType","endDef","hasPort","portGroup","portProp","portsPositions","getPortsPositions","portCenter","_createPortData","_processRemovedPort","currentItemsMap","hasPorts","getPortIndex","getGroupPorts","getPort","portsMetrics","_portSettingsData","positions","metrics","_isValidPortId","addPort","insertPort","index$1","_validatePorts","portsAttr","errorMessages","generatePortId","addPorts","removePort","removePorts","portsForRemoval","newPorts","this","currentPorts","rp","rpId","prevPortData","curPortData","prevPort","curPort","GraphCells","cellNamespace","dry","Graph","cellModel","_sortOnChangeZ","_out","_in","_nodes","_edges","_batches","_restructureOnAdd","_restructureOnRemove","_restructureOnReset","_restructureOnChangeSource","_restructureOnChangeTarget","_removeCell","prevSource","prevTarget","getOutboundEdges","getInboundEdges","fromJSON","resetCells","_prepareCell","firstCell","lastCell","addCells","maxPosition","preparedCells","removeCells","disconnectLinks","removeLinks","getCells","getElements","getLinks","getFirstCell","getLastCell","indirect","links","edges","addOutbounds","edge","addInbounds","outCell","inCell","embeddedElements","edgeCell","includeEnclosed","getNeighbors","neighbors","cellsAncestors","commonAncestor","cellAncestors","getSuccessors","cloneSubgraph","subgraph","getSubgraph","cellMap","getPredecessors","bfs","dfs","neighbor","getSources","getSinks","sinks","isSource","isSink","isSuccessor","elementA","elementB","isPredecessor","isNeighbor","findModelsFromPoint","findModelsInArea","strict","findModelsUnderElement","searchBy","resizeCells","hasActiveBatch","batches","validations","multiLinks","sourceModel","sameLinks","connectedLinks","_link","_source","_target","linkPinning","_graph","views","theme","themeClassNamePrefix","requireSetThemeOverride","DETACHABLE","UPDATE_PRIORITY","FLAG_INSERT","FLAG_REMOVE","FLAG_INIT","setTheme","unmount","svgElement","isMounted","renderChildren","isSVG","findAttribute","attributeName","_setStyle","_ensureElClassName","prefixedClassName","onRender","confirmUpdate","override","removeThemeClassName","addThemeClassName","onSetTheme","oldTheme","newTheme","onRemove","undelegateDocumentEvents","getEventNamespace","delegateElementEvents","eventNS","undelegateElementEvents","delegateDocumentEvents","eventData","currentData","stopPropagation","propagationStopped","isPropagationStopped","renderFn","__render__","DoubleTapEventName","special","maxDelay","bindType","delegateType","handle","handleObj","targetData","lastTouch","origType","Listener","callbackArguments","context$1","LayersNames","CELLS","BACK","FRONT","TOOLS","LABELS","PaperLayer","pivotNodes","insertSortedNode","insertPivot","insertNode","pivotNode","createComment","neighborZ","currentZ","neighborPivot","removePivots","toArray$1","HighlighterView","HIGHLIGHT_FLAG","UPDATABLE","MOUNTABLE","cellView","updateRequested","transformGroup","detachedTransformGroup","requestUpdate","requestViewUpdate","mount","findNode","findLabelNode","findPortNode","assign$1","getNodeMatrix","layer","rotatableNode","nodeMatrix","getRootRotateMatrix","getNodeRotateMatrix","vGroup","cellViewRoot","layerName","getLayerView","translateMatrix","getRootTranslateMatrix","rotateMatrix","transformMatrix","prevNode","unhighlight","notify","_removeRef","_cellView","listenToUpdateAttributes","onCellAttributeChange","_views","refs","ref$2","hid","previousView","view","_addRef","removeAll","HighlightingTypes","EMBEDDING","CONNECTING","MAGNET_AVAILABILITY","ELEMENT_AVAILABILITY","CellView","classNames","list","_presentationAttributes","_flags","setFlags","flags","presentationAttributes","initFlag","hasFlag","getFlag","removeFlag","cleanNodesCache","startListening","onAttributesChange","updateHandled","tool","rootSelector","can","interactive","useModelGeometry","getNodeBBox","localToPaperRect","magnet","getNodeBoundingRect","magnetMatrix","getNodeUnrotatedBBox","_notifyHighlight","rootNode","partial","embedding","connecting","magnetAvailability","elementAvailability","findMagnet","magnetAttribute","isMagnetRoot","findProxyNode","proxyNode","getSelector","prevSelector","nthChild","addLinkFromMagnet","getDefaultLink","getLinkEnd","ui","customizeLinkEnd","connectionStrategy","strategy","getMagnetFromLinkEnd","dragLinkStart","linkView","notifyPointerdown","startArrowheadMove","whenNotAllowed","dragLink","pointermove","magnetThreshold","currentTarget","getEventTarget","targetMagnet","mousemoved","dragLinkEnd","pointerup","setNodeAttributes","processNodeAttributes","attrVal","normalAttrs","setAttrs","positionAttrs","offsetAttrs","relatives","raw","normal","updateRelativeAttributes","translation","rawAttrs","nodeAttrs","setResult","HTMLElement","nodeTransform","nodePosition","nodeScale","getNodeScale","scalableNode","positioned","offseted","nodeBoundingRect","nodeCache","getNodeData","boundingRect","getNodeShape","geometryShape","isNodeConnection","findNodesAttributes","selectorCache","nodeId","nodesAttrs","mergeIds","unique","prevNodeAttrs","selectedLength","sortIndex","clientX","clientY","fromPoint","hasPointerCapture","pointerId","elementFromPoint","updateDOMSubtreeAttributes","rootBBox","rotatableMatrix","bboxCache","relativeItems","relativeRefItems","roAttrs","roAttributes","nodesAllAttrs","nodeData","processedAttrs","refNode","nodeAllAttrs","refSelector","processedAttributes","allAttributes","itemIndex","vRotatable","refNodeId","isRefNodeRotatable","unrotatedRefBBox","transformationTarget","mergeProcessedAttributes","roProcessedAttrs","onMount","isInitialMount","mountTools","onDetach","unmountTools","removeTools","removeHighlighters","_toolsView","hasTools","toolsView","getName","addTools","configure","relatedView","onToolEvent","updateTools","hideTools","hide","showTools","show","updateHighlighters","transformHighlighters","preventDefaultInteraction","defaultInteractionPrevented","isDefaultInteractionPrevented","pointerdblclick","pointerclick","contextmenu","pointerdown","mouseover","mouseout","mouseenter","mouseleave","mousewheel","onevent","onmagnet","magnetpointerdblclick","magnetcontextmenu","checkMouseleave","isAsync","sourceView","dumpView","targetView","setInteractivity","Flags","Highlighting","addPresentationAttributes","Flags$1","UPDATE","TRANSLATE","RESIZE","PORTS","ROTATE","RENDER","DragActions","MOVE","MAGNET","ElementView","_removePorts","_renderPorts","_cleanPortsCache","renderingOnlyAttrs","modelAttrs","rotatableSelector","scalableSelector","renderMarkup","renderJSONMarkup","renderStringMarkup","updateTransformation","sgResize","rgTranslate","rgRotate","getTranslateString","rotateString","getRotateString","scalable","scalableBBox","rotatable","rotatableBBox","prepareEmbedding","initialZIndices","initialParentId","processEmbedding","candidates","findParentBy","frontParentOnly","validateEmbedding","newCandidateView","prevCandidateView","candidateEmbedView","candidate","clearEmbedding","candidateView","finalizeEmbedding","validateUnembedding","_disallowUnembed","initialPosition","getDelegatedView","proxyPortNode","notifyPointermove","notifyPointerup","dragStart","action","delegatedView","magnetpointermove","dragMagnet","drag","preventPointerEvents","magnetpointerup","dragMagnetEnd","dragEnd","magnetpointerclick","magnetpointerdown","dragMagnetStart","pointerOffset","getRestrictedArea","isPropagationAlreadyStopped","validateMagnet","grid","elX","elY","embeddingMode","clickThreshold","portContainerMarkup","portMarkup","portLabelMarkup","_portElementsCache","elementReferences","elem","_getContainerElement","portsGropsByZ","withoutZKey","portElement","_getPortElement","groupNames","_appendPorts","_updatePorts","containerElement","portElements","_createPortElement","portCache","portContentElement","portRoot","portSelectors","_updatePortGroup","groupsNames","labelElement","labelSelectors","portContainerSelectors","portContainerElement","_getPortMarkup","portDoc","portFragment","labelMarkupDef","_getPortLabelMarkup","childCount","portRootSelector","labelRootSelector","labelTextSelector","labelNode","labelTextNode","portLabelElement","portLabelSelectors","portContentSelectors","elementBBox","cached","applyPortTransform","transformData","initialAngle","opposites","N","E","W","radians","freeJoin","getBBoxSize","getBearing","to","getPointBox","getPaddingBox","elementPadding","getSourceBBox","sourceBBox","getTargetBBox","targetBBox","vertexVertex","d1","d2","opposite","elementVertex","fromBBox","insideElement","toBBox","boundary","reversed","orthogonal","sourceAnchor","targetAnchor","orthogonalVertices","isOrthogonal","elementElement","fromBorder","toBorder","startRoute","endRoute","isOrthogonalLoop","vertexElement","freePoints","freeBearingPoints","config$1","maximumLoops","maxAllowedDirectionChange","perpendicular","excludeEnds","excludeTypes","startDirections","endDirections","directionMap","cost","directions","offsetX","offsetY","penalties","paddingBox","isPointObstacle","fallbackRouter","fallbackRoute","draggingRoute","ObstacleMap","mapGridSize","SortedSet","OPEN","CLOSE","getSourceBBox$1","getTargetBBox$1","getSourceAnchor$1","getDirectionAngle","numDirections","diffX","diffY","gridStepsX","gridStepsY","normalizedAngle","angleTheta","getDirectionChange","angle1","angle2","directionChange","getGridDimension","absDiff","numSteps","remainder","round$4","align","snappedX","snappedY","getKey","normalizePoint","estimateCost","endPoints","getRectPoints","anchor","directionList","anchorCenterVector","dirList","rectPoints","farthestIntersectionDistance","endpoint","intersectionLine","farthestIntersection","currentIntersection","findRoute","getTargetAnchor$1","startPoints","openSet","parents","costs","previousRouteDirectionAngle","previousDirectionAngle","isPathBeginning","getGridOffsets","gridOffsetX","gridOffsetY","endPointsKeys","endPoint","loopsRemaining","currentKey","currentParent","currentCost","isRouteBeginning","isStart","samePoints","reconstructRoute","tailPoint","prevDiff","leadPoint","fromDiff","directionAngle","neighborPoint","neighborKey","isClose","endDirectionChange","costFromStart","isOpen","build","excludedEnds","excludedAncestors","isExcludedType","isExcludedEnd","excluded","isExcludedAncestor","gridKey","isPointAccessible","mapKey","obstacle","manhattan","resolveOptions","point1","point2","oldVertices","newVertices","partialRoute","isEndingAtPoint","dragFrom","dragTo","config$2","diagonalCost","intersectionPoint","directionFrom","Directions","AUTO","ANCHOR_SIDE","MAGNET_SIDE","DEFINED_DIRECTIONS","getDirectionForLinkConnection","linkOrigin","connectionPoint","getTangentAtLength","getClosestPointLength","rightAngleRouter","_vertices","sourceDirection","targetDirection","isSourcePort","isTargetPort","sourcePoint","targetPoint","sx0","sy0","sourceWidth","sourceHeight","tx0","ty0","targetWidth","targetHeight","tx1","ty1","smx0","smx1","smy0","smy1","tmx0","tmx1","tmy0","tmy1","sourceOutsidePoint","sourceSide","sourceLinkAnchorBBox","targetOutsidePoint","targetSide","targetLinkAnchorBBox","sox","soy","tox","toy","tcy","middleOfVerticalSides","scx","middleOfHorizontalSides","scy","y$1","x$1","x$2","y$3","x$3","y$5","x$4","y1$1","y2$1","x$5","y$6","y$7","x1$1","x2$1","y$8","x$6","y$9","x$7","y$10","x$8","y$11","x$9","y$12","y$13","x$10","y$14","y$15","x$12","x$14","y$16","x$15","y$17","x$16","y$18","x$17","y$19","x$18","y$20","x$19","y$21","x$20","y$22","x$21","y$23","routers","oneSide","coordinate","metro","rightAngle","CornerTypes","POINT","CUBIC","LINE","GAP","DEFINED_CORNER_TYPES","straight","routePoints","cornerType","cornerRadius","cornerPreserveAspectRatio","nextDistance","routePointsLength","curr","prevDistance","startMove","endMove","cornerStart","cornerEnd","JUMP_TYPES","IGNORED_CONNECTORS","createLines","resultLines","nextPoint","sortPoints","buildPath","jumpSize","jumpType","isJump","halfLine","xAxisRotate","centerLine","xOffset","yOffset","roundedStart","roundedEnd","nextLine","Directions$1","HORIZONTAL","VERTICAL","CLOSEST_POINT","OUTWARDS","TangentDirections","UP","DOWN","sourceTangent","targetTangent","Boolean","coeff","distanceCoefficient","angleTangentCoefficient","tau","tension","completeRoute","getSourceTangentDirection","getAutoSourceDirection","getClosestPointSourceDirection","getOutwardsSourceDirection","getHorizontalSourceDirection","unrotatedBBox","getVerticalSourceDirection","tangentLength","angleBetweenVectors","updatedLength","getTargetTangentDirection","getAutoTargetDirection","getClosestPointTargetDirection","getOutwardsTargetDirection","getHorizontalTargetDirection","getVerticalTargetDirection","tangentLength$1","angle$1","updatedLength$1","bezierCurves","catmullRomCurves","createCatmullRomCurves","distances","tangents","i$1","tpPrev","tpNext","v1","v2","vAngle","rot","vectorDeterminant","pointsDeterminant","rotateVector","scaleFactor1","scaleFactor2","i$2","bcp1","bcp2","sourceCenter","targetCenter","acos","connectors","jumpover","setupUpdating","jumpOverLinkView","updateList","_jumpOverUpdateList","updateJumpOver","updateFlag","CONNECTOR","jump","ignoreConnectors","allLinks","thisModel","thisIndex","defaultConnector","linkViews","thisLines","linkLines","thisLine","lineIntersections","crossCheckLine","point$1","skip","jumpStart","jumpEnd","endDistance","startDistance","jumpLine","rounded","smooth","controlPointX","controlPointY","Flags$2","LEGACY_TOOLS","VERTICES","SOURCE","LinkView","shortLinkLength","doubleLinkTools","longLinkLength","linkToolsOffset","doubleLinkToolsOffset","sampleInterval","_labelCache","_labelSelectors","_markerCache","_V","_dragData","decimalsRounding","updateEndProperties","isViewMounted","renderVertexMarkers","updateLabels","updateLegacyTools","onLabelsChange","renderTools","updateAll","updateConnector","updatePath","updateDOM","updateLabelPositions","updateToolsPosition","requestConnectionUpdate","isLabelsRenderRequired","previousLabels","_labels","renderLabels","unmountLabels","renderArrowheadMarkers","_getLabelMarkup","_getLabelStringMarkup","_normalizeLabelMarkup","vNode","DocumentFragment","hasChildNodes","vLabels","labelCache","labelsCount","labelsLayer","builtinDefaultLabel","builtinDefaultLabelMarkup","defaultMarkup","defaultLabelMarkup","mountLabels","labelIndex","labelRoot","_mergeLabelAttrs","hasCustomMarkup","labelAttrs","defaultLabelAttrs","builtinDefaultLabelAttrs","_mergeLabelSize","defaultLabelSize","canLabelMove","linkTools","tool2","$tools","toolTemplate","_toolCache","_tool2Cache","markerVertices","$markerVertices","markupTemplate","markerArrowheads","$markerArrowheads","sourceArrowhead","targetArrowhead","removeRedundantLinearVertices","numRoutePoints","polylinePoints","numPolylinePoints","updateDefaultConnectionPath","connectionWrap","markerSource","markerTarget","_translateAndAutoOrientArrows","getEndView","getEndAnchor","getEndConnectionPoint","getEndMagnet","sourceMagnet","updateRoute","_translateConnectionPoints","updateArrowheadMarkers","anchors","findAnchors","connectionPoints","findConnectionPoints","markerPoints","findMarkerPoints","findPath","sourceMarkerPoint","targetMarkerPoint","firstWaypoint","lastWaypoint","findAnchorsOrdered","firstEndType","firstRef","secondEndType","secondRef","firstAnchor","secondAnchor","firstAnchorRef","secondAnchorRef","firstDef","secondDef","firstView","secondView","firstMagnet","secondMagnet","getAnchor","firstVertex","lastVertex","priority","sourceDef","targetDef","paperOptions","sourceConnectionPointDef","defaultConnectionPoint","sourcePointRef","sourceLine","getConnectionPoint","targetConnectionPointDef","targetPointRef","targetLine","anchorDef","anchorFn","isConnection","defaultLinkAnchor","perpendicularLinks","defaultAnchor","anchorName","connectionPointDef","connectionPointFn","linkConnectionPoint","linkConnectionMagnet","connectionPointName","connectionPointNamespace","_getDefaultLabelPositionProperty","builtinDefaultLabelPosition","_normalizeLabelPosition","_mergeLabelPositionProperty","normalizedLabelPosition","normalizedDefaultLabelPosition","defaultLabelPosition","_getLabelTransformationMatrix","_cleanLabelMatrices","connectionLength","toolPosition","endViewProperty","endId","updateEndMagnet","endModel","getModelById","endView","endMagnetProperty","connectedMagnet","sourceArrow","targetArrow","_getLabelPositionProperty","_getLabelPositionAngle","_getLabelPositionArgs","_getDefaultLabelPositionArgs","_mergeLabelPositionArgs","labelPositionArgs","defaultLabelPositionArgs","addLabel","localX","localY","localAngle","positionArgs","getLabelPosition","addVertex","isPointProvided","getVertexIndex","sendToken","token","isReversed","animationAttributes","dur","repeatCount","calcMode","keyPoints","keyTimes","vToken","routerNamespace","defaultRouter","routerFn","connectorNamespace","connectorFn","getPointAtRatio","getTangentAtRatio","getClosestPoint","getClosestPointRatio","labelOffset","isDistanceRelative","absoluteDistance","isDistanceAbsoluteReverse","reverseDistance","isOffsetAbsolute","absoluteOffset","labelPoint","labelDistance","labelOffsetDiff","labelAngle","labelOffsetCoordinates","positionOffset","isKeepGradient","keepGradient","isEnsureLegibility","ensureLegibility","getLabelCoordinates","vertexLength","currentVertex","dragVertexStart","dragVertexRemoveStart","dragArrowheadStart","dragConnectionStart","dragData","dragVertex","dragLabel","dragArrowhead","dragVertexEnd","dragLabelEnd","dragArrowheadEnd","delegateDragEvents","onlabel","dragLabelStart","vertexIdx","labelIdx","initialLabelPosition","positionAngle","vertexNode","removeNode","arrowheadType","arrowheadNode","ignoreBackwardsCompatibility","snapLabels","snapLinks","_snapArrowhead","snapLinksSelf","_snapArrowheadSelf","_connectArrowhead","_snapArrowheadEnd","_connectArrowheadEnd","linkAllowed","_finishEmbedding","_notifyConnectEvent","_disallow","_afterArrowheadMove","arrowhead","initialEnd","currentEnd","initialMagnet","magnetUnderPointer","_snapToPoints","snapPoint","closestPointX","closestDistanceX","closestPointY","closestDistanceY","distX","distY","isSnapped","viewsInArea","findViewsInArea","prevClosestView","closestView","prevClosestMagnet","closestMagnet","prevMagnetProxy","magnetProxy","MAX_VALUE","pointer","isAlreadyValidated","validateConnection","validateConnectionArgs","newClosestMagnet","snapping","prevEnd","prevX","prevY","eventTarget","viewUnderPointer","_beforeArrowheadMove","markAvailable","_markAvailableMagnets","_unmarkAvailableMagnets","_createValidateConnectionArgs","oppositeArrowhead","isMagnetAvailable","marked","magnets","availableMagnets","markedMagnets","markedKeys","useFirstSubpath","getPathData","secondSubpathIndex","highlightConnection","highlightNode","highlightMatrix","paddingMatrix","mask","maskClip","VISIBLE","INVISIBLE","MASK_ROOT_ATTRIBUTE_BLACKLIST","MASK_CHILD_ATTRIBUTE_BLACKLIST","MASK_REPLACE_TAGS","MASK_REMOVE_TAGS","transformMaskChild","childEl","childTagName","originalChild","originalNode","transformMaskRoot","rootEl","getMaskShape","maskRoot","forEachDescendant","descendants","descendant","maskChild","getMaskId","getMask","hasNodeFill","magnetStrokeWidth","minStrokeWidth","maskEl","removeMask","maskNode","getElementById","addMask","highlighterBBox","opacityClassName","Directions$2","ROW","COLUMN","UPDATE_ATTRIBUTES","_prevItems","elementView","gap","normalizedSize","isRowDirection","itemWidth","prevItems","comparison","unchanged","prevEls","itemsEls","prevEl","itemEl","createListItem","dataset","itemsCount","listSize","ref$3","highlighters","resolveRef","Element","refPoint","refView","getPointAtLink","fixedAt","parsedValue","connectionPerpendicular","_magnet","verticalLine","horizontalLine","verticalIntersections","horizontalIntersections","fallbackAt","connectionClosest","_opt","linkAnchors","connectionRatio","_refPoint","offsetPoint","stroke$1","bboxIntersection","BNDR_SUBDIVISIONS","BNDR_SHAPE_BBOX","_view","alignOffset","alignLine","rectangle","bboxWORotation","lineWORotation","findShapeNode","nextElementSibling","localShape","targetMatrix","localMatrix","localLine","localRef","insideout","localBBox","extrapolate","sticky","cpOffset","bboxWrapper","dxPercentage","dyPercentage","midSide","modelCenter","sortingTypes","NONE","APPROX","EXACT","UPDATE_BATCH_SIZE","HighlightingTypes$1","defaultHighlighting","defaultLayers","Paper","drawGrid","drawGridSize","background","highlighting","preventContextMenu","preventDefaultBlankAction","preventDefaultViewAction","restrictTranslate","defaultLink","_evt","cellViewS","_magnetS","cellViewT","_magnetT","_linkView","childView","parentView","labelMove","allowLink","moveThreshold","sorting","frozen","autoFreeze","onViewUpdate","mounting","isolate","requestConnectedLinksUpdate","onViewPostponed","forcePostponedViewUpdate","beforeRender","afterRender","viewport","cellViewNamespace","highlighterNamespace","anchorNamespace","linkAnchorNamespace","overflow","documentEvents","tools","$background","layers","$grid","$document","_viewportMatrix","_viewportTransformString","_updates","_layers","SORT_DELAYING_BATCHES","UPDATE_DELAYING_BATCHES","FORM_CONTROL_TAG_NAMES","GUARDED_TAG_NAMES","MIN_SCALE","setGrid","cloneOptions","_setDimensions","_mw_evt_buffer","deltas","ownerDocument","resetViews","isFrozen","updateViewsAsync","_resetUpdates","priorities","unmountedCids","mountedCids","unmounted","mounted","keyFrozen","freezeKey","disabled","idle","onCellAdded","onCellRemoved","onCellChange","onGraphReset","onGraphSort","onGraphBatchStop","onCellHighlight","onCellUnhighlight","renderView","freeze","unfreeze","resetLayers","sortViews","updateDelayingBatches","updateViews","sortDelayingBatches","hasLayerView","getLayerNode","renderLayers","drawBackground","removeLayers","sorted","layerView","cellsLayerView","toolsLayerView","labelsLayerView","_background","updateBackgroundImage","transformString","getCTM","ctmString","clientMatrix","flagLabels","nextPriority","scheduleViewUpdate","dumpOptions","sourceFlag","targetFlag","stats","notifyAfterRender","updates","priorityUpdates","prevPriorityUpdates","currentType","viewUpdateFn","dumpViewUpdate","registerMountedView","shouldNotify","notifyBeforeRender","leftover","updateView","updated","removeView","isInitialInsert","insertView","requireView","registerUnmountedView","dumpViews","passingOpt","checkViewport","batchStats","updateCount","batchCount","updateViewsBatch","hasScheduledUpdates","priorityIndexes","_key","processed","mountBatchSize","MOUNT_BATCH_SIZE","unmountBatchSize","checkStats","unmountCount","mountCount","total","progressFn","beforeFn","afterFn","batchSize","postponeCount","maxPriority","viewportFn","postponeViewFn","main","currentFlag","isDetached","detachView","leftoverFlag","postponed","getUnmountedViews","unmountedViews","getMountedViews","mountedViews","checkUnmountedViews","checkMountedViews","unmountedCount","isExactSorting","removeViews","getComputedSize","setDimensions","currentWidth","currentHeight","computedSize","setOrigin","fitToContent","gridWidth","gridHeight","getFitToContentArea","minWidth","minHeight","maxWidth","maxHeight","newOrigin","allowNewOrigin","area","contentArea","getContentArea","calcWidth","calcHeight","allowNegativeBottomRight","transformToFitContent","contentBBox","contentLocalOrigin","fittingBBox","getContentBBox","paperToLocalPoint","scaleGrid","minScale","maxScale","verticalAlign","horizontalAlign","minScaleX","maxScaleX","minScaleY","maxScaleY","currentTranslate","currentScale","newSx","newSy","scaleDiff","newOx","newOy","scaleContentToFit","getArea","paperToLocalRect","createViewForModel","optionalViewClass","defaultViewClass","namespaceViewClass","onImageDragStart","sortViewsExact","$cells","cellA","cellB","zA","zB","findViewsFromPoint","dispatchToolsEvent","clientToLocalPoint","localToPaperPoint","localPoint","localRect","paperPoint","paperRect","localToClientPoint","localToClientRect","clientPoint","clientToLocalRect","clientRect","localToPagePoint","pageOffset","localToPageRect","pageToLocalPoint","pagePoint","pageToLocalRect","clientOffset","getBoundingClientRect","scrollX","scrollY","resolveHighlighter","highlighterDef","highlighter","magnetEl","highlighterDescriptor","preventDefault","contextMenuFired","contextMenuTrigger","button","isContextMenu","isTargetFormNode","rootViewEl","eventNode","eventEvt","Event","isDefaultPrevented","magnetNode","magnetEvt","contextmenuEvt","normalizedEvt","stopImmediatePropagation","relatedTarget","_processMouseWheelEvtBuf","pinchHandlers","ctrlKey","magnetEvent","magnetContextMenuFired","magnetContextMenuTrigger","getPointerArgs","guarded","setGridSize","clearGrid","_getGridRefs","_gridCache","patterns","exist","_gridSettings","optionsList","_resolveDrawGridOption","gridPatterns","localOptions","gridLayerSetting","patternUnits","patternDefVel","patternUri","XMLSerializer","serializeToString","backgroundPosition","backgroundSize","drawBackgroundImage","img","HTMLImageElement","backgroundImage","backgroundRepeat","repeat","backgroundOpacity","backgroundQuality","quality","backgroundPattern","backgroundPatterns","canvas","HTMLCanvasElement","toDataURL","updateBackgroundColor","image","onload","isDefined","defId","filter$1","filterId","filterSVGString","filterUnits","gradient","stops","stopVEls","gradientVEl","patternVEl","markerContentVEl","markupVEl","markerUnits","markerVEl","orient","markerAttrs","markerAttrsKeys","markupValue","Layers","flipXy","imgWidth","imgHeight","getContext","drawImage","setTransform","flipX","flipY","watermark","watermarkAngle","stepX","stepY","thickness","fixedDot","mesh","doubleMesh","ToolView","_visible","simulateRelatedView","focus","focusOpacity","focusTool","blurTool","ToolsView","isRendered","focusedTool","blurredTool","DirectedGraph","exportElement","exportLink","minLen","weight","labelpos","labeloffset","importElement","gl","glNode","setPosition","importLink","edgeObj","glEdge","setLinkVertices","setLabels","layout","graphOrCells","dagreUtil","resizeClusters","clusterPadding","dagre","glGraph","toGraphLib","graphlib","directed","multigraph","compound","setNodeLabel","setEdgeLabel","setEdgeName","glLabel","marginX","marginY","rankDir","rankdir","nodeSep","nodesep","edgeSep","edgesep","rankSep","ranksep","ranker","marginx","marginy","setGraph","debugTiming","fromGraphLib","importEdge","clusters","aCluster","bCluster","glSize","graphlibUtil","glGraphType","setEdge","setNode","isCompound","setParent","env","_results","_tests","svgforeignobject","addTest","Generic","Rect$1","TextView","Text","Circle","Ellipse$1","Polygon$1","Polyline$1","Image","Path$1","Rhombus","svgForeignObjectSupported","TextBlock","updateSize","updateContent","div","setForeignObjectSize","setDivContent","TextBlockView","noTextAttrs","Rectangle","Circle$1","Ellipse$2","Path$2","Polygon$2","Polyline$2","Image$1","BorderedImage","border","EmbeddedImage","InscribedImage","HeaderedRectangle","header","headerText","bodyText","Cylinder","lateralArea","topAttrs","isPercentageSetter","kappa","xCenter","xRight","ySideTop","yCurveTop","ySideBottom","yCurveBottom","backgroundColor","textAlign","boxSizing","alignItems","justifyContent","TextBlock$1","foreignObject","wrapAttrs","Link$1","strokeLinejoin","DoubleLink","ShadowLink","shadow","inPorts","outPorts","updatePortItems","inPortItems","createPortItems","outPortItems","createPortItem","_addGroupPort","addOutPort","addInPort","_removeGroupPort","removeOutPort","removeInPort","_changeGroup","changeInGroup","changeOutGroup","Atomic","Coupled","Link$2","Gate","operation","IO","Input","Output","Gate11","Gate21","Repeater","Not","Or","input1","input2","And","Nor","Nand","Xor","Xnor","Wire","KingWhite","KingBlack","QueenWhite","QueenBlack","RookWhite","RookBlack","BishopWhite","BishopBlack","KnightWhite","KnightBlack","PawnWhite","PawnBlack","Entity","WeakEntity","Relationship","IdentifyingRelationship","Attribute","Multivalued","Derived","Key","Normal","ISA","Line$1","cardinality","State","StartState","EndState","Arrow","Member","Arrow$1","Place","PlaceView","renderTokens","vTokens","Transition","Link$3","updateRectangles","getClassName","rectHeight","ClassView","Abstract","Interface","Generalization","Implementation","Aggregation","Composition","Association","State$1","updateName","updateEvents","StartState$1","EndState$1","Transition$1","abs2rel","relative","pin","totalLength","pinAbsolute","pinRelative","VertexHandle","mousedown","touchstart","dblclick","dbltap","mousemove","touchmove","mouseup","touchend","touchcancel","onPointerDown","onPointerMove","onDoubleClick","onPointerUp","Vertices","handleClass","snapRadius","redundancyRemoval","vertexAdding","handles","resetHandles","renderHandles","updateHandles","startHandleListening","onHandleWillChange","onHandleChanging","onHandleChanged","onHandleRemove","getNeighborPoints","_handle","normalizedEvent","snapVertex","vertexAdded","onPathPointerDown","getViewBBox","SegmentHandle","viewPoint","Segments","segmentLengthThreshold","snapHandle","nextVertex","renderHandle","updateHandle","onHandleChangeStart","onHandleChangeEnd","shiftHandleIndexes","resetAnchor","relatedModel","handleIndex","vertexPoints","indexOffset","originalVertices","v1$1","v2$1","theta$1","isSingleVertex","origVIndex","additionalOffset","firstHandleShifted","nextVIndex","changeSourceAnchor","deleteSourceAnchor","sourceAnchorPosition","sourceAnchorDef","changeTargetAnchor","deleteTargetAnchor","targetAnchorPosition","targetAnchorDef","segmentLine","Arrowhead","xAxisVector","TargetArrowhead","SourceArrowhead","Boundary","Anchor","snap","toolView","refIndex","customAnchorAttributes","defaultAnchorAttributes","areaPadding","restrictArea","toggleArea","updateAnchor","updateArea","anchorNode","customAnchor","anchorAttributes","areaNode","visible","snapFn","pointAtConnection","rotatedCoords","onPointerDblClick","SourceAnchor","TargetAnchor","Button","getCellMatrix","getLinkMatrix","getElementMatrix","actionFn","Remove","Connect","dragstart","getMagnetNode","dragend","HoverConnect","trackWidth","trackPath","getTrackPath","track","getButtonMatrix","getTrackMatrix","tangentAtRatio","getTrackRatioFromEvent","trackPoint","canShowButton","_data","showButton","hideButton","onMousemove","onMouseenter","onMouseleave","Control","handleAttributes","getPosition","resetPosition","toggleExtras","extras","updateExtras","handleNode","relativePos","absolutePos","extrasNode","relativeCoords","HoverConnect$1","Vectorizer","connectionStrategies","useDefaults","dia","elementTools","format","mvc","basic","standard","devs","logic","chess","erd","fsa","org","pn","uml","AbstractView","InterfaceView","util","shapePerimeterConnectionPoint","downloadDataUri","imageToDataUri","modernHandler","status","reader","FileReader","onerror","readAsDataURL","response","legacyHandler","bytes","suffix","meta","Uint8ToString","u8a","XMLHttpRequest","responseType","send","getElementBBox","clientBBox","strokeWidthX","strokeWidthY","pageXOffset","offsetLeft","pageYOffset","offsetTop","setAttributesBySelector","$element","addBack","specifier","locale","currency","decimal","thousands","grouping","re","sign","zfill","comma","zcomma","negative","fullSuffix","after","formatGroup","formatString","fieldDelimiterIndex","pieceFormattedString","formatSpec","fieldName","fieldDelimiter","endPlaceholder","formattedStringArray","toPrecision","toExponential","log","LN10","prefixes","toggleFullScreen","topDocument","prefixedResult","propName","deepMixin","mapped","bindAll","methodNames","strings","expressions","svgParts","part","parseFromSVGString","markupString","xmldocument","document1","buildNode","markupNode","stylesObject","nameString","getPropertyValue","selectorAttribute","getNamedItem","removeNamedItem","groupSelectorAttribute","Node","TEXT_NODE","trimmedText","ELEMENT_NODE","nodeAttribute"],"version":3,"file":"client.2f082e59.js.map"}