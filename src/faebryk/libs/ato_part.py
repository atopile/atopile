# This file is part of the faebryk project
# SPDX-License-Identifier: MIT

import datetime
import logging
import re
from copy import deepcopy
from dataclasses import dataclass, field
from pathlib import Path
from textwrap import dedent
from typing import Self

from more_itertools import first

import faebryk.library._F as F
from faebryk.libs.kicad.fileformats_common import ChecksumMismatch, PropertyNotSet
from faebryk.libs.kicad.fileformats_latest import (
    C_kicad_footprint_file,
    C_kicad_model_file,
)
from faebryk.libs.kicad.fileformats_sch import C_kicad_sym_file
from faebryk.libs.util import compare_dataclasses

logger = logging.getLogger(__name__)


@dataclass(kw_only=True)
class AtoPart:
    @dataclass(kw_only=True)
    class AutoGenerated:
        system: str = Path(__file__).stem
        date: datetime.datetime = field(
            default_factory=lambda: datetime.datetime.now(datetime.timezone.utc)
        )
        source: str | None
        checksum: str | None = None

    identifier: str
    path: Path
    mfn: tuple[str, str]
    fp: C_kicad_footprint_file
    symbol: C_kicad_sym_file
    model: C_kicad_model_file | None
    auto_generated: AutoGenerated | None

    @property
    def fp_path(self) -> Path:
        return self.path / f"{self.fp.footprint.base_name}.kicad_mod"

    @property
    def sym_path(self) -> Path:
        return (
            self.path
            / f"{first(self.symbol.kicad_symbol_lib.symbols.values()).name}.kicad_sym"
        )

    @property
    def ato_path(self) -> Path:
        return self.path / (self.path.name + ".ato")

    @property
    def model_path(self) -> Path:
        if not self.model:
            raise ValueError("Model is not set")
        return self.path / self.model.filename

    def __post_init__(self):
        self.fp = deepcopy(self.fp)
        self.fp.footprint.name = f"{self.identifier}:{self.fp.footprint.base_name}"

        self.symbol = deepcopy(self.symbol)

        if self.model:
            # TODO: do this the proper way
            from atopile.config import config as Gcfg

            prjroot = Gcfg.build.paths.fp_lib_table.parent
            self.fp.footprint.models[0].path = Path(
                "${KIPRJMOD}"
            ) / self.model_path.relative_to(prjroot, walk_up=True)

    def compare(self, other: Self) -> dict:
        return compare_dataclasses(
            self,
            other,
            skip_keys=(
                "path",
                "uuid",
                "date",
                "checksum",
            ),
        )

    def dump(self):
        self.path.mkdir(parents=True, exist_ok=True)

        # refresh checksums
        self.fp.footprint.set_checksum()
        first(self.symbol.kicad_symbol_lib.symbols.values()).set_checksum()

        self.fp.dumps(self.fp_path)
        self.symbol.dumps(self.sym_path)
        if self.model:
            self.model.dumps(self.model_path)

        def _format_template_args(args: dict) -> str:
            return "<" + ", ".join(f'{k}="{v}"' for k, v in args.items()) + ">"
            # TODO parser doesnt support newline atm
            # args_str = (
            #    "<\n"
            #    + indent(",\n".join(f'{k}="{v}"' for k, v in args.items()), " " * 4*2)
            #    + "    >"
            # )

        # TODO use the pycodegen lib
        ato_template = dedent(
            "\n".join(
                """
            #pragma experiment("TRAITS")
            import is_atomic_part
            import is_auto_generated

            component {identifier}:
                trait is_atomic_part{atomic_args_str}

                # This trait marks this file as auto-generated
                # If you want to manually change it, remove the trait
                trait is_auto_generated{auto_args_str}
            """.splitlines()[1:]
            )
        )

        atomic_args = {
            "manufacturer": self.mfn[0],
            "partnumber": self.mfn[1],
            "footprint": self.fp_path.name,
            "symbol": self.sym_path.name,
            **({"model": self.model_path.name} if self.model else {}),
        }

        assert self.auto_generated is not None

        auto_args = {
            "system": self.auto_generated.system,
            **(
                {"source": self.auto_generated.source}
                if self.auto_generated.source
                else {}
            ),
            "date": self.auto_generated.date.isoformat(),
            "checksum": F.is_auto_generated.CHECKSUM_PLACEHOLDER,
        }

        ato = ato_template.format(
            identifier=self.identifier,
            atomic_args_str=_format_template_args(atomic_args),
            auto_args_str=_format_template_args(auto_args),
        )

        ato = F.is_auto_generated.set_checksum(ato)

        self.ato_path.write_text(ato)

        # TODO remove test
        self.load(self.path)

    def verify_checksum(self, ato_file_contents: str):
        from faebryk.library.is_auto_generated import _FileManuallyModified

        if not self.auto_generated:
            return
        assert self.auto_generated.checksum is not None

        # check ato
        F.is_auto_generated.verify(self.auto_generated.checksum, ato_file_contents)

        fp = self.fp.footprint
        symbol = first(self.symbol.kicad_symbol_lib.symbols.values())

        # check fp & symbol
        for obj, t_name in ((fp, "Footprint"), (symbol, "Symbol")):
            try:
                obj.verify_checksum()
            except PropertyNotSet:
                raise _FileManuallyModified(
                    f"{t_name} has no checksum."
                    "But part is auto-generated. This is not allowed."
                )
            except ChecksumMismatch:
                raise _FileManuallyModified(
                    f"{t_name} has a checksum mismatch. "
                    "But part is auto-generated. This is not allowed. "
                )

        # TODO verify model

    @classmethod
    def load(cls, path: Path) -> Self:
        """
        Looks for ato manifest in the given directory.
        If found, loads the manifest and returns an AtoPart object.
        """

        # TODO consider using the parser

        ato_path = path / (path.name + ".ato")
        ato = ato_path.read_text("utf-8")

        def _parse_trait(trait: str, required: list[str]) -> dict:
            valid_ato = re.sub(r"#.*", "", ato)
            args_match = re.search(rf"trait {trait}<(.+?)>", valid_ato, re.DOTALL)
            if not args_match:
                raise ValueError(f"Invalid ATO file: Could not find {trait} trait")
            matches = [
                # only strings supported
                re.match(r'^(\w+)\s*=\s*"(.*?)"$', arg.strip())
                for arg in args_match.group(1).split(",")
            ]
            args = {match.group(1): match.group(2) for match in matches if match}
            missing = [arg for arg in required if arg not in args]
            if missing:
                raise ValueError(
                    f"Invalid ATO file: Missing required arguments for trait"
                    f" {trait}: {missing}"
                )
            return args

        atomic_args = _parse_trait(
            "is_atomic_part", ["footprint", "symbol", "manufacturer", "partnumber"]
        )
        try:
            auto_args = _parse_trait(
                "is_auto_generated", ["system", "date", "checksum"]
            )
        except ValueError:
            auto_args = None

        fp = C_kicad_footprint_file.loads(path / atomic_args["footprint"])
        symbol = C_kicad_sym_file.loads(path / atomic_args["symbol"])
        model = (
            C_kicad_model_file.loads(path / atomic_args["model"])
            if "model" in atomic_args
            else None
        )
        mfn_pn = atomic_args["manufacturer"], atomic_args["partnumber"]

        auto_generated = None
        if auto_args is not None:
            auto_generated = AtoPart.AutoGenerated(
                system=auto_args["system"],
                date=datetime.datetime.fromisoformat(auto_args["date"]),
                source=auto_args["source"] if "source" in auto_args else None,
                checksum=auto_args["checksum"],
            )

        out = cls(
            identifier=path.name,
            path=path,
            mfn=mfn_pn,
            fp=fp,
            symbol=symbol,
            model=model,
            auto_generated=auto_generated,
        )

        out.verify_checksum(ato)

        return out
