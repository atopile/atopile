# This file is part of the faebryk project
# SPDX-License-Identifier: MIT

import logging
import re
from copy import deepcopy
from dataclasses import dataclass
from pathlib import Path
from textwrap import dedent
from typing import Self

from more_itertools import first

from faebryk.libs.kicad.fileformats_latest import (
    C_kicad_footprint_file,
    C_kicad_model_file,
)
from faebryk.libs.kicad.fileformats_sch import C_kicad_sym_file
from faebryk.libs.util import compare_dataclasses

logger = logging.getLogger(__name__)


@dataclass
class AtoPart:
    identifier: str
    path: Path
    mfn: tuple[str, str]
    fp: C_kicad_footprint_file
    symbol: C_kicad_sym_file
    model: C_kicad_model_file | None

    @property
    def fp_path(self) -> Path:
        return self.path / f"{self.fp.footprint.base_name}.kicad_mod"

    @property
    def sym_path(self) -> Path:
        return (
            self.path
            / f"{first(self.symbol.kicad_symbol_lib.symbols.values()).name}.kicad_sym"
        )

    @property
    def ato_path(self) -> Path:
        return self.path / (self.path.name + ".ato")

    @property
    def model_path(self) -> Path:
        if not self.model:
            raise ValueError("Model is not set")
        return self.path / self.model.filename

    def __post_init__(self):
        self.fp = deepcopy(self.fp)
        self.fp.footprint.name = f"{self.identifier}:{self.fp.footprint.base_name}"
        if self.model:
            # TODO: do this the proper way
            from atopile.config import config as Gcfg

            prjroot = Gcfg.build.paths.fp_lib_table.parent
            self.fp.footprint.models[0].path = Path(
                "${KIPRJMOD}"
            ) / self.model_path.relative_to(prjroot, walk_up=True)

    def compare(self, other: Self) -> dict:
        return compare_dataclasses(self, other, skip_keys=("path", "uuid"))

    def dump(self):
        self.path.mkdir(parents=True, exist_ok=True)

        self.fp.dumps(self.fp_path)
        self.symbol.dumps(self.sym_path)
        if self.model:
            self.model.dumps(self.model_path)

        args = {
            "manufacturer": self.mfn[0],
            "partnumber": self.mfn[1],
            "footprint": self.fp_path.name,
            "symbol": self.sym_path.name,
        }

        if self.model:
            args["model"] = self.model_path.name

        # TODO parser doesnt support newline atm
        # args_str = (
        #    "<\n"
        #    + indent(",\n".join(f'{k}="{v}"' for k, v in args.items()), " " * 4 * 2)
        #    + "    >"
        # )
        args_str = "<" + ", ".join(f'{k}="{v}"' for k, v in args.items()) + ">"

        # TODO use the pycodegen lib
        ato = dedent(
            "\n".join(
                """
            # This file is automatically generated
            #pragma experiment("TRAITS")
            import is_atomic_part

            component {identifier}:
                trait is_atomic_part{args_str}
            """.splitlines()[1:]
            )
        ).format(identifier=self.identifier, args_str=args_str)

        self.ato_path.write_text(dedent(ato))

        # TODO remove test
        self.load(self.path)

    @classmethod
    def load(cls, path: Path) -> Self:
        """
        Looks for ato manifest in the given directory.
        If found, loads the manifest and returns an AtoPart object.
        """
        # TODO consider using the parser

        ato_path = path / (path.name + ".ato")
        ato = ato_path.read_text("utf-8")

        args_match = re.search(r"trait is_atomic_part<(.+?)>", ato, re.DOTALL)
        if not args_match:
            raise ValueError("Invalid ATO file: Could not find is_atomic_part trait")
        matches = [
            # only strings supported
            re.match(r'^(\w+)\s*=\s*"(.*?)"$', arg.strip())
            for arg in args_match.group(1).split(",")
        ]
        args = {match.group(1): match.group(2) for match in matches if match}

        required = ["footprint", "symbol", "manufacturer", "partnumber"]
        missing = [arg for arg in required if arg not in args]
        if missing:
            raise ValueError(f"Invalid ATO file: Missing required arguments: {missing}")

        fp = C_kicad_footprint_file.loads(path / args["footprint"])
        symbol = C_kicad_sym_file.loads(path / args["symbol"])
        model = (
            C_kicad_model_file.loads(path / args["model"]) if "model" in args else None
        )
        mfn_pn = args["manufacturer"], args["partnumber"]

        return cls(
            identifier=path.name,
            path=path,
            mfn=mfn_pn,
            fp=fp,
            symbol=symbol,
            model=model,
        )
