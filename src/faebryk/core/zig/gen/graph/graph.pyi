# This file is part of the faebryk project
# SPDX-License-Identifier: MIT

# This file is auto-generated by zig.
# Do not edit this file directly; edit the corresponding
# Zig file instead.

from enum import Enum  # noqa: F401
from typing import Any  # noqa: F401

# Dirty hack to not error in ruff check
type Allocator = Any

class Attribute:
    identifier: str
    value: Any

    def __init__(self, *, identifier: str, value: Any) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...

class DynamicAttributes:
    values: dict[str, Any]

    def __init__(self, *, values: dict[str, Any]) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...

class GraphReferenceCounter:
    ref_count: int
    parent: Any
    allocator: Allocator

    def __init__(
        self, *, ref_count: int, parent: Any, allocator: Allocator
    ) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...
    def inc(self, *, arg_0: GraphView) -> None: ...
    def dec(self, *, arg_0: GraphView) -> None: ...

class UUID:
    def __init__(self) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...

class Node:
    uuid: int
    dynamic: DynamicAttributes
    _ref_count: GraphReferenceCounter

    def __init__(
        self,
        *,
        uuid: int,
        dynamic: DynamicAttributes,
        _ref_count: GraphReferenceCounter,
    ) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...
    def deinit(self) -> None: ...
    def equals(self, *, arg_0: Node) -> bool: ...
    def visit_attributes(self, *, arg_0: Any, arg_1: Any) -> None: ...

class Edge:
    source: Node
    target: Node
    uuid: int
    edge_type: int
    directional: bool | None
    name: str | None
    dynamic: DynamicAttributes
    _ref_count: GraphReferenceCounter

    def __init__(
        self,
        *,
        source: Node,
        target: Node,
        uuid: int,
        edge_type: int,
        directional: bool | None,
        name: str | None,
        dynamic: DynamicAttributes,
        _ref_count: GraphReferenceCounter,
    ) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...
    def deinit(self) -> None: ...
    def is_instance(self, *, arg_0: int) -> bool: ...

class BoundNodeReference:
    node: Node
    g: GraphView

    def __init__(self, *, node: Node, g: GraphView) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...

class BoundEdgeReference:
    edge: Edge
    g: GraphView

    def __init__(self, *, edge: Edge, g: GraphView) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...

class GraphView:
    base: GraphView | None
    allocator: Allocator
    nodes: list[Node]
    edges: list[Edge]
    neighbors: dict[Node, list[Edge]]
    neighbor_by_type: dict[Node, dict[int, list[Edge]]]

    def __init__(
        self,
        *,
        base: GraphView | None,
        allocator: Allocator,
        nodes: list[Node],
        edges: list[Edge],
        neighbors: dict[Node, list[Edge]],
        neighbor_by_type: dict[Node, dict[int, list[Edge]]],
    ) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...
    def deinit(self) -> None: ...
    def insert_node(self, *, arg_0: Node) -> BoundNodeReference: ...
    def insert_edge(self, *, arg_0: Edge) -> BoundEdgeReference: ...
    def get_edges(self, *, arg_0: Node) -> list[Edge] | None: ...
    def get_edges_of_type(self, *, arg_0: Node, arg_1: int) -> list[Edge] | None: ...
