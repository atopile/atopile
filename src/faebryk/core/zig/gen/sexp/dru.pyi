# This file is part of the faebryk project
# SPDX-License-Identifier: MIT

# This file is auto-generated by zig.
# Do not edit this file directly; edit the corresponding
# Zig file instead.

from enum import Enum, IntEnum  # noqa: F401
from typing import Any  # noqa: F401

# Dirty hack to not error in ruff check
type Allocator = Any

class E_severity(str, Enum):
    ERROR = "error"
    WARNING = "warning"
    IGNORE = "ignore"
    EXCLUSION = "exclusion"

class E_constraint_type(str, Enum):
    ANNULAR_WIDTH = "annular_width"
    ASSERTION = "assertion"
    BRIDGED_MASK = "bridged_mask"
    CLEARANCE = "clearance"
    CONNECTION_WIDTH = "connection_width"
    COURTYARD_CLEARANCE = "courtyard_clearance"
    CREEPAGE = "creepage"
    DIFF_PAIR_GAP = "diff_pair_gap"
    DIFF_PAIR_UNCOUPLED = "diff_pair_uncoupled"
    DISALLOW = "disallow"
    EDGE_CLEARANCE = "edge_clearance"
    HOLE_CLEARANCE = "hole_clearance"
    HOLE_SIZE = "hole_size"
    HOLE_TO_HOLE = "hole_to_hole"
    LENGTH = "length"
    MIN_RESOLVED_SPOKES = "min_resolved_spokes"
    PHYSICAL_CLEARANCE = "physical_clearance"
    PHYSICAL_HOLE_CLEARANCE = "physical_hole_clearance"
    SILK_CLEARANCE = "silk_clearance"
    SKEW = "skew"
    SOLDER_MASK_EXPANSION = "solder_mask_expansion"
    SOLDER_PASTE_ABS_MARGIN = "solder_paste_abs_margin"
    SOLDER_PASTE_REL_MARGIN = "solder_paste_rel_margin"
    TEXT_HEIGHT = "text_height"
    TEXT_THICKNESS = "text_thickness"
    THERMAL_RELIEF_GAP = "thermal_relief_gap"
    THERMAL_SPOKE_WIDTH = "thermal_spoke_width"
    TRACK_ANGLE = "track_angle"
    TRACK_SEGMENT_LENGTH = "track_segment_length"
    TRACK_WIDTH = "track_width"
    VIA_COUNT = "via_count"
    VIA_DANGLING = "via_dangling"
    VIA_DIAMETER = "via_diameter"
    ZONE_CONNECTION = "zone_connection"

class E_zone_connection_type(str, Enum):
    SOLID = "solid"
    THERMAL_RELIEFS = "thermal_reliefs"
    NONE = "none"

class E_disallow_type(str, Enum):
    TRACK = "track"
    VIA = "via"
    THROUGH_VIA = "through_via"
    BLIND_VIA = "blind_via"
    MICRO_VIA = "micro_via"
    BURIED_VIA = "buried_via"
    PAD = "pad"
    ZONE = "zone"
    TEXT = "text"
    GRAPHIC = "graphic"
    HOLE = "hole"
    FOOTPRINT = "footprint"

class Expression:
    expression: str

    def __init__(self, *, expression: str) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...

class ValueWithUnit:
    value: float
    unit: str | None

    def __init__(self, *, value: float, unit: str | None = ...) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...

class Constraint:
    constraint_type: E_constraint_type
    min: ValueWithUnit | None
    opt: ValueWithUnit | None
    max: ValueWithUnit | None
    disallow_types: list[E_disallow_type]
    zone_connection_type: E_zone_connection_type | None
    assertion_expr: str | None
    spokes_count: int | None
    within_diff_pairs: bool

    def __init__(
        self,
        *,
        constraint_type: E_constraint_type,
        min: ValueWithUnit | None = ...,
        opt: ValueWithUnit | None = ...,
        max: ValueWithUnit | None = ...,
        disallow_types: list[E_disallow_type] = ...,
        zone_connection_type: E_zone_connection_type | None = ...,
        assertion_expr: str | None = ...,
        spokes_count: int | None = ...,
        within_diff_pairs: bool = ...,
    ) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...

class Rule:
    name: str
    severity: E_severity | None
    layer: str | None
    condition: Expression | None
    constraints: list[Constraint]

    def __init__(
        self,
        *,
        name: str,
        severity: E_severity | None = ...,
        layer: str | None = ...,
        condition: Expression | None = ...,
        constraints: list[Constraint] = ...,
    ) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...

class KicadDru:
    version: int
    rules: list[Rule]

    def __init__(self, *, version: int = ..., rules: list[Rule] = ...) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...

class DruFile:
    kicad_dru: KicadDru

    def __init__(self, *, kicad_dru: KicadDru) -> None: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def __field_names__() -> list[str]: ...
    def __zig_address__(self) -> int: ...
    @staticmethod
    def loads(*, arg_0: Allocator, arg_1: Any) -> DruFile: ...
    @staticmethod
    def dumps(*, arg_0: DruFile, arg_1: Allocator, arg_2: Any) -> None: ...
    def free(self, *, arg_0: Allocator) -> None: ...

# Module-level functions
def loads(data: str) -> DruFile: ...
def dumps(obj: DruFile) -> str: ...
