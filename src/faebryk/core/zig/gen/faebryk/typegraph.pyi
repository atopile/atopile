# This file is part of the faebryk project
# SPDX-License-Identifier: MIT

# This file is auto-generated by zig.
# Do not edit this file directly; edit the corresponding
# Zig file instead.

# Re-export EdgeTraversal from the actual implementation
from faebryk.core.edge_traversal import EdgeTraversal as EdgeTraversal
from faebryk.core.zig.gen.faebryk.edgebuilder import EdgeCreationAttributes
from faebryk.core.zig.gen.faebryk.nodebuilder import NodeCreationAttributes
from faebryk.core.zig.gen.graph.graph import BoundNode, GraphView, Literal

class TypeGraphPathError(ValueError):
    """Raised when mount-aware path resolution fails inside the Zig TypeGraph."""

    kind: str
    path: list[str]
    failing_segment: str
    failing_segment_index: int
    index_value: int | None

class TypeGraph:
    @staticmethod
    def create(*, g: GraphView) -> "TypeGraph": ...
    @staticmethod
    def of(*, node: BoundNode) -> "TypeGraph": ...
    @staticmethod
    def of_type(*, type_node: BoundNode) -> "TypeGraph | None": ...
    @staticmethod
    def of_instance(*, instance_node: BoundNode) -> "TypeGraph | None": ...
    def add_type(self, *, identifier: str) -> BoundNode:
        """Create and register a new type node.

        Raises:
            ValueError: If a type with this name already exists.
        """
        ...

    def add_make_child(
        self,
        *,
        type_node: BoundNode,
        child_type: BoundNode,
        identifier: str | None,
        node_attributes: NodeCreationAttributes | None = ...,
        mount_reference: BoundNode | None = ...,
    ) -> BoundNode: ...
    def add_make_child_deferred(
        self,
        *,
        type_node: BoundNode,
        child_type_identifier: str,
        identifier: str | None,
        node_attributes: NodeCreationAttributes | None = ...,
        mount_reference: BoundNode | None = ...,
    ) -> BoundNode: ...
    def get_make_child_type_reference(self, *, make_child: BoundNode) -> BoundNode: ...

    class MakeChildNode:
        @staticmethod
        def build(*, value: str | None = ...) -> NodeCreationAttributes: ...

    def debug_add_reference(
        self, *, type_node: BoundNode, path: list[str | EdgeTraversal]
    ) -> BoundNode: ...
    def add_reference(
        self, *, type_node: BoundNode, path: list[str | EdgeTraversal]
    ) -> BoundNode: ...
    def add_make_link(
        self,
        *,
        type_node: BoundNode,
        lhs_reference: BoundNode,
        rhs_reference: BoundNode,
        edge_attributes: EdgeCreationAttributes,
    ) -> BoundNode: ...
    def ensure_child_reference(
        self,
        *,
        type_node: BoundNode,
        path: list[str | EdgeTraversal],
        validate: bool = ...,
    ) -> BoundNode:
        """Create a reference path for traversing the instance graph.

        Path items can be:
          - str: Composition edge (parent-child relationship)
          - EdgeTraversal: Custom edge type (Trait, Pointer, etc.)

        Example:
            # Composition-only path (backwards compatible)
            tg.ensure_child_reference(type_node=t, path=["child1", "child2"])

            # Mixed path with different edge types
            tg.ensure_child_reference(type_node=t, path=[
                "resistor",
                EdgeTraversal.trait("can_bridge"),
                EdgeTraversal.pointer("in_"),
            ])
        """
        ...

    def collect_pointer_members(
        self,
        *,
        type_node: BoundNode,
        container_path: list[str],
    ) -> list[tuple[str | None, BoundNode]]: ...
    def collect_make_children(
        self,
        *,
        type_node: BoundNode,
    ) -> list[tuple[str | None, BoundNode]]: ...
    def collect_make_links(
        self,
        *,
        type_node: BoundNode,
    ) -> list[tuple[BoundNode, tuple[str, ...], tuple[str, ...]]]: ...
    def debug_get_mount_chain(
        self,
        *,
        make_child: BoundNode,
    ) -> list[str]: ...
    def get_reference_path(
        self,
        *,
        reference: BoundNode,
    ) -> tuple[str, ...]: ...
    def instantiate(
        self, *, type_identifier: str, attributes: dict[str, Literal]
    ) -> BoundNode: ...
    def instantiate_node(
        self, *, type_node: BoundNode, attributes: dict[str, Literal]
    ) -> BoundNode: ...
    def reference_resolve(
        self, *, reference_node: BoundNode, base_node: BoundNode
    ) -> BoundNode | None: ...
    def get_graph_view(self) -> GraphView: ...
    def get_self_node(self) -> BoundNode: ...
    def get_type_by_name(self, *, type_identifier: str) -> BoundNode | None: ...
    @staticmethod
    def get_type_name(*, type_node: BoundNode) -> str: ...
    def get_or_create_type(self, *, type_identifier: str) -> BoundNode: ...
    def get_type_subgraph(self) -> GraphView: ...
    def get_type_instance_overview(self) -> list[tuple[str, int]]: ...
    @staticmethod
    def get_subgraph_of_node(*, start_node: BoundNode) -> GraphView: ...
