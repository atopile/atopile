import importlib.util
import logging
import sys
from pathlib import Path
from types import ModuleType

from faebryk.libs.util import (
    ConfigFlagString,
    FileChangedWatcher,
    debug_perf,
    get_python_lib,
    global_lock,
    is_editable_install,
    run_live,
)

logger = logging.getLogger(__name__)

_thisfile = Path(__file__)
_thisdir = _thisfile.parent
_build_dir = _thisdir / "zig-out" / "lib"
_pyi_dir = _build_dir / "gen"

RELEASEMODE = ConfigFlagString("ZIG_RELEASEMODE", default="Debug")


@debug_perf
def compile_zig():
    from faebryk.libs.header import formatted_file_contents, get_header

    zig_cmd = [sys.executable, "-m", "ziglang"]
    python_lib = get_python_lib()

    # TODO: consider doing it per file (not super useful)
    pyi_watcher = FileChangedWatcher(
        _pyi_dir, method=FileChangedWatcher.CheckMethod.HASH
    )

    # Use zig build system with Python configuration
    cmd = [
        *zig_cmd,
        "build",
        "python-ext",
        f"-Doptimize={RELEASEMODE.value}",
        f"-Dpython-include={python_lib.include_path}",
        f"-Dpython-lib={python_lib.name}",
        *([f"-Dpython-lib-dir={python_lib.dir_path}"] if python_lib.dir_path else []),
    ]

    logger.info(f"Building with command: {' '.join(cmd)}")
    with global_lock(_build_dir / "lock", timeout_s=60):
        run_live(cmd, cwd=Path(__file__).parent)

    # Process all generated pyi files
    # only if any change in the pyi, formatting is expensive
    if pyi_watcher.has_changed():
        for pyi_source in _pyi_dir.rglob("*/*.pyi"):
            # Copy to source directory with proper formatting
            pyi_out = _thisdir / pyi_source.relative_to(_build_dir)
            # TODO run in parallel
            # TODO use faster formatter
            pyi_out.parent.mkdir(parents=True, exist_ok=True)
            pyi_out.write_text(
                formatted_file_contents(
                    get_header()
                    + "\n"
                    + "# This file is auto-generated by zig.\n"
                    + "# Do not edit this file directly; edit the corresponding\n"
                    + "# Zig file instead.\n\n"
                    + pyi_source.read_text(encoding="utf-8"),
                    is_pyi=True,
                ),
                encoding="utf-8",
            )
            run_live(
                [sys.executable, "-m", "ruff", "check", "--fix", pyi_out],
                stdout=logger.debug,
                stderr=logger.error,
            )


def _load_module(path: list[str], module: ModuleType):
    _module_path = ".".join(path)
    sys.modules[_module_path] = module
    for name in dir(module):
        if name.startswith("_"):
            continue
        obj = getattr(module, name)
        path_ = path + [name]
        if isinstance(obj, ModuleType):
            _load_module(path_, obj)


def load():
    # Insert at beginning to override any installed version
    spec = importlib.util.spec_from_file_location("pyzig", _build_dir / "pyzig.so")
    assert spec and spec.loader

    # Import from the local build directory, not from installed package
    pyzig = importlib.util.module_from_spec(spec)
    sys.modules["pyzig_local"] = pyzig  # Use different name to avoid conflicts
    spec.loader.exec_module(pyzig)


# Fallback to editable build-on-import
if is_editable_install():
    compile_zig()
    load()
    import pyzig_local  # type: ignore

    _load_module(["faebryk", "core", "zig"], pyzig_local)
else:
    import pyzig

    _load_module(["faebryk", "core", "zig"], pyzig)
