from typing import Any

from faebryk.core.zig.gen.faebryk.typegraph import TypeGraph
from faebryk.core.zig.gen.graph.graph import BoundNode, GraphView

class String:
    @staticmethod
    def create_instance(*, g: GraphView, tg: TypeGraph, value: str) -> "String": ...
    @staticmethod
    def bind_instance(*, instance: BoundNode) -> "String": ...
    def get_value(self) -> str: ...
    def get_instance(self) -> BoundNode: ...

class Strings:
    @staticmethod
    def MakeChild(*values: str) -> Any: ...
    @staticmethod
    def MakeChild_SetSuperset(ref: Any, *values: str) -> Any: ...
    @staticmethod
    def _type_identifier() -> str: ...
    @staticmethod
    def bind_typegraph(*, tg: TypeGraph) -> "StringsBoundType": ...
    @staticmethod
    def create_instance(*, g: GraphView, tg: TypeGraph) -> "Strings": ...
    @staticmethod
    def bind_instance(*, instance: BoundNode) -> "Strings": ...
    @property
    def is_literal(self) -> Any: ...
    def get_instance(self) -> BoundNode: ...
    def setup_from_values(self, *, values: list[str]) -> "Strings": ...
    def get_values(self) -> list[str]: ...
    def is_singleton(self) -> bool: ...
    def get_single(self) -> str: ...
    def is_empty(self) -> bool: ...
    def any(self) -> str: ...
    def op_setic_equals(self, *, other: "Strings") -> bool: ...
    def op_setic_is_subset_of(self, *, other: "Strings") -> bool: ...
    def uncertainty_equals(self, *, other: "Strings") -> "Booleans": ...
    def op_intersect_intervals(self, *, other: "Strings") -> "Strings": ...
    def op_union_intervals(self, *, other: "Strings") -> "Strings": ...
    def op_symmetric_difference_intervals(self, *, other: "Strings") -> "Strings": ...
    def pretty_str(self) -> str: ...
    def serialize(self) -> dict: ...
    @staticmethod
    def deserialize(*, data: dict, g: GraphView, tg: TypeGraph) -> "Strings": ...

class StringsBoundType:
    def create_instance(self, *, g: GraphView) -> "Strings": ...
    def get_or_create_type(self) -> BoundNode: ...

class Counts:
    @staticmethod
    def _type_identifier() -> str: ...
    @staticmethod
    def bind_typegraph(*, tg: TypeGraph) -> "CountsBoundType": ...
    @staticmethod
    def create_instance(*, g: GraphView, tg: TypeGraph) -> "Counts": ...
    @staticmethod
    def bind_instance(*, instance: BoundNode) -> "Counts": ...
    def get_instance(self) -> BoundNode: ...
    def setup_from_values(self, *, values: list[int]) -> "Counts": ...
    def get_values(self) -> list[int]: ...
    def is_singleton(self) -> bool: ...
    def get_single(self) -> int: ...
    def is_empty(self) -> bool: ...
    def any(self) -> int: ...
    def op_setic_equals(self, *, other: "Counts") -> bool: ...
    def op_setic_is_subset_of(self, *, other: "Counts") -> bool: ...
    def uncertainty_equals(self, *, other: "Counts") -> "Booleans": ...
    def op_intersect_intervals(self, *, other: "Counts") -> "Counts": ...
    def op_union_intervals(self, *, other: "Counts") -> "Counts": ...
    def op_symmetric_difference_intervals(self, *, other: "Counts") -> "Counts": ...
    def serialize(self) -> dict: ...
    @staticmethod
    def deserialize(*, data: dict, g: GraphView, tg: TypeGraph) -> "Counts": ...

class CountsBoundType:
    def create_instance(self, *, g: GraphView) -> "Counts": ...
    def get_or_create_type(self) -> BoundNode: ...

class Interval:
    min: float
    max: float

class Numbers: ...

class Booleans:
    @staticmethod
    def _type_identifier() -> str: ...
    @staticmethod
    def bind_typegraph(*, tg: TypeGraph) -> "BooleansBoundType": ...
    @staticmethod
    def create_instance(*, g: GraphView, tg: TypeGraph) -> "Booleans": ...
    @staticmethod
    def bind_instance(*, instance: BoundNode) -> "Booleans": ...
    def get_instance(self) -> BoundNode: ...
    def setup_from_values(self, *, values: list[bool]) -> "Booleans": ...
    def get_values(self) -> list[bool]: ...
    def is_singleton(self) -> bool: ...
    def get_single(self) -> bool: ...
    def is_empty(self) -> bool: ...
    def any(self) -> bool: ...
    def op_setic_equals(self, *, other: "Booleans") -> bool: ...
    def op_setic_is_subset_of(self, *, other: "Booleans") -> bool: ...
    def uncertainty_equals(self, *, other: "Booleans") -> "Booleans": ...
    def op_intersect_intervals(self, *, other: "Booleans") -> "Booleans": ...
    def op_union_intervals(self, *, other: "Booleans") -> "Booleans": ...
    def op_symmetric_difference_intervals(self, *, other: "Booleans") -> "Booleans": ...
    def serialize(self) -> dict: ...
    @staticmethod
    def deserialize(*, data: dict, g: GraphView, tg: TypeGraph) -> "Booleans": ...

class BooleansBoundType:
    def create_instance(self, *, g: GraphView) -> "Booleans": ...
    def get_or_create_type(self) -> BoundNode: ...
