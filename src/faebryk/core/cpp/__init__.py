# This file is part of the faebryk project
# SPDX-License-Identifier: MIT

import json
import logging
from importlib.metadata import Distribution

logger = logging.getLogger(__name__)


# Check if installed as editable
def is_editable_install():
    distro = Distribution.from_name("faebryk")
    return (
        json.loads(distro.read_text("direct_url.json") or "")
        .get("dir_info", {})
        .get("editable", False)
    )


def compile_and_load():
    """
    Forces C++ to compile into faebryk_core_cpp_editable module which is then loaded
    into _cpp.
    """
    import os
    import platform
    import shutil
    import sys
    from pathlib import Path

    from faebryk.libs.header import formatted_file_contents, get_header
    from faebryk.libs.util import run_live

    _thisfile = Path(__file__)
    _thisdir = _thisfile.parent
    _cmake_dir = _thisdir
    _build_dir = _cmake_dir / "build"
    pyi_source = _build_dir / "faebryk_core_cpp_editable.pyi"

    date_files = [pyi_source]
    dates = {k: os.path.getmtime(k) if k.exists() else 0 for k in date_files}

    # check for cmake binary existing
    if not shutil.which("cmake"):
        raise RuntimeError(
            "cmake not found, needed for compiling c++ code in editable mode"
        )

    # Force recompile
    # subprocess.run(["rm", "-rf", str(build_dir)], check=True)

    other_flags = []

    # On OSx we've had some issues with building for the right architecture
    if sys.platform == "darwin":  # macOS
        arch = platform.machine()
        if arch in ["arm64", "x86_64"]:
            other_flags += [f"-DCMAKE_OSX_ARCHITECTURES={arch}"]

    run_live(
        [
            "cmake",
            "-S",
            str(_cmake_dir),
            "-B",
            str(_build_dir),
            "-DEDITABLE=1",
            "-DPython_EXECUTABLE=" + sys.executable,
            *other_flags,
        ],
        logger=logger,
    )
    run_live(
        [
            "cmake",
            "--build",
            str(_build_dir),
        ],
        logger=logger,
    )

    if not _build_dir.exists():
        raise RuntimeError("build directory not found")

    # add build dir to sys path
    sys.path.append(str(_build_dir))

    modified = {k for k, v in dates.items() if os.path.getmtime(k) > v}

    # move autogenerated type stub file to source directory
    if pyi_source in modified:
        pyi_out = _thisfile.with_suffix(".pyi")
        pyi_out.write_text(
            formatted_file_contents(
                get_header()
                + "\n"
                + "# This file is auto-generated by nanobind.\n"
                + "# Do not edit this file directly; edit the corresponding\n"
                + "# C++ file instead."
                + pyi_source.read_text(),
                is_pyi=True,
            )
        )


# Re-export c++ with type hints provided by __init__.pyi
if is_editable_install():
    logger.warning("faebryk is installed as editable package, compiling c++ code")
    compile_and_load()
    from faebryk_core_cpp_editable import *  # type: ignore # noqa: E402, F403
else:
    from faebryk_core_cpp import *  # type: ignore # noqa: E402, F403
