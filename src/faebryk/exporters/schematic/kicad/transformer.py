# This file is part of the faebryk project
# SPDX-License-Identifier: MIT

import hashlib
import logging
import math
import pprint
from copy import deepcopy
from dataclasses import is_dataclass
from functools import singledispatchmethod
from itertools import chain
from os import PathLike
from pathlib import Path
from typing import Any, List, Protocol, Unpack

import rich
import rich.table

import faebryk.library._F as F
from faebryk.core.graphinterface import Graph
from faebryk.core.module import Module
from faebryk.core.node import Node

# import numpy as np
# from shapely import Polygon
from faebryk.exporters.schematic.kicad.skidl import gen_schematic as skidl_sch
from faebryk.exporters.schematic.kicad.skidl import node as skidl_node
from faebryk.exporters.schematic.kicad.skidl import shims
from faebryk.libs.exceptions import FaebrykException
from faebryk.libs.geometry.basic import Geometry
from faebryk.libs.kicad.fileformats import (
    C_kicad_fp_lib_table_file,
)
from faebryk.libs.kicad.fileformats import (
    gen_uuid as _gen_uuid,
)
from faebryk.libs.kicad.fileformats_common import C_effects, C_pts, C_wh, C_xy, C_xyr
from faebryk.libs.kicad.fileformats_sch import (
    UUID,
    C_arc,
    C_circle,
    C_kicad_sch_file,
    C_kicad_sym_file,
    C_lib_symbol,
    C_polyline,
    C_property,
    C_rect,
    C_stroke,
)
from faebryk.libs.kicad.paths import GLOBAL_FP_DIR_PATH, GLOBAL_FP_LIB_PATH
from faebryk.libs.sexp.dataclass_sexp import dataclass_dfs
from faebryk.libs.util import (
    FuncDict,
    KeyErrorNotFound,
    cast_assert,
    find,
    not_none,
    once,
)

logger = logging.getLogger(__name__)


SCH = C_kicad_sch_file.C_kicad_sch

Geom = C_polyline | C_arc | C_rect | C_circle
Font = C_effects.C_font

Point = Geometry.Point
Point2D = Geometry.Point2D

Justify = C_effects.C_justify.E_justify


class _HasUUID(Protocol):
    uuid: UUID


class _HasPropertys(Protocol):
    propertys: dict[str, C_property]


def mm_to_mil(mm: float) -> float:
    return mm * 1000 / 25.4


# TODO: consider common transformer base
class Transformer:
    class has_linked_sch_symbol(F.Symbol.TraitT.decless()):
        def __init__(self, symbol: SCH.C_symbol_instance) -> None:
            super().__init__()
            self.symbol = symbol

    class has_linked_sch_pins(F.Symbol.Pin.TraitT.decless()):
        def __init__(
            self,
            pins: list[SCH.C_symbol_instance.C_pin],
            symbol: SCH.C_symbol_instance,
        ) -> None:
            super().__init__()
            self.symbol = symbol
            self.pins = pins

    def __init__(
        self, sch: SCH, graph: Graph, app: Module, cleanup: bool = True
    ) -> None:
        self.sch = sch
        self.graph = graph
        self.app = app
        self._symbol_files_index: dict[str, Path] = {}

        self.missing_symbols: list[F.Symbol] = []

        self.dimensions = None

        FONT_SCALE_MM = 1.27
        FONT = Font(
            size=C_wh(FONT_SCALE_MM, FONT_SCALE_MM),
        )
        self.font = FONT

        if cleanup:
            self.cleanup()
        self.attach()

    def attach(self):
        """This function matches and binds symbols to their symbols"""
        # reference (eg. C3) to symbol (eg. "Capacitor_SMD:C_0402")
        sch_symbols = {
            (f.propertys["Reference"].value, f.lib_id): f for f in self.sch.symbols
        }
        for node, sym_trait in self.graph.nodes_with_trait(F.Symbol.has_symbol):
            if not node.has_trait(F.has_overriden_name):
                # These names are typically generated by the netlist transformer
                logger.warning(f"Symbol {sym_trait.reference} has no overriden name")
                continue

            f_symbol = sym_trait.reference

            if not f_symbol.has_trait(F.Symbol.has_kicad_symbol):
                # KiCAD symbols are typically generated by the lcsc picker
                logger.warning(f"Symbol {f_symbol} has no kicad symbol")
                # TODO: generate a bug instead of skipping
                continue

            sym_ref = node.get_trait(F.has_overriden_name).get_name()
            sym_name = f_symbol.get_trait(F.Symbol.has_kicad_symbol).symbol_name

            if (sym_ref, sym_name) not in sch_symbols:
                self.missing_symbols.append(f_symbol)
                continue

            self.attach_symbol(f_symbol, sch_symbols[(sym_ref, sym_name)])

        # Log what we were able to attach
        attached = {
            n: t.symbol
            for n, t in self.graph.nodes_with_trait(self.has_linked_sch_symbol)
        }
        logger.debug(f"Attached: {pprint.pformat(attached)}")
        logger.debug(f"Missing: {pprint.pformat(self.missing_symbols)}")

    def cleanup(self):
        """Remove everything we generated in the past."""

        def _filter(obj) -> bool:
            if self.check_mark(obj):
                logger.debug(f"Removing marked {obj.uuid}")
                return True
            return False

        self.sch.symbols = list(filter(_filter, self.sch.symbols))
        self.sch.wires = list(filter(_filter, self.sch.wires))

    def attach_symbol(self, f_symbol: F.Symbol, sym_inst: SCH.C_symbol_instance):
        """Bind the module and symbol together on the graph"""
        f_symbol.add(self.has_linked_sch_symbol(sym_inst))

        # Attach the pins on the symbol to the module interface
        for pin in sym_inst.pins:
            f_symbol.pins[pin.name].add(
                Transformer.has_linked_sch_pins([pin], sym_inst)
            )

    def index_symbol_files(
        self, fp_lib_tables: PathLike | list[PathLike], load_globals: bool = True
    ) -> None:
        if isinstance(fp_lib_tables, (str, Path)):
            fp_lib_table_paths = [Path(fp_lib_tables)]
        else:
            fp_lib_table_paths = [Path(p) for p in fp_lib_tables]

        # non-local lib, search in kicad global lib
        if load_globals:
            fp_lib_table_paths += [GLOBAL_FP_LIB_PATH]

        for lib_path in fp_lib_table_paths:
            for lib in C_kicad_fp_lib_table_file.loads(lib_path).fp_lib_table.libs:
                resolved_lib_dir = Path(
                    lib.uri.replace("${KIPRJMOD}", str(lib_path.parent)).replace(
                        "${KICAD8_FOOTPRINT_DIR}", str(GLOBAL_FP_DIR_PATH)
                    )
                )

                # HACK: paths typically look like .../libs/footprints/xyz.pretty
                # we actually want the .../libs/ part of it, so we'll just knock
                # off the last two directories
                resolved_lib_dir = resolved_lib_dir.parent.parent

                for path in resolved_lib_dir.glob("*.kicad_sym"):
                    if path.stem not in self._symbol_files_index:
                        self._symbol_files_index[path.stem] = path

    @staticmethod
    def flipped[T](input_list: list[tuple[T, int]]) -> list[tuple[T, int]]:
        return [(x, (y + 180) % 360) for x, y in reversed(input_list)]

    # Getter ---------------------------------------------------------------------------
    @classmethod
    def get_symbol(cls, cmp: Node) -> F.Symbol:
        return not_none(cmp.get_trait(cls.has_linked_sch_symbol)).symbol

    def get_all_symbols(self) -> List[tuple[Module, F.Symbol]]:
        return [
            (cast_assert(Module, cmp), t.symbol)
            for cmp, t in self.graph.nodes_with_trait(self.has_linked_sch_symbol)
        ]

    @once
    def get_symbol_file(self, lib_name: str) -> C_kicad_sym_file:
        # primary caching handled by @once
        if lib_name not in self._symbol_files_index:
            raise FaebrykException(f"Symbol file {lib_name} not found")

        path = self._symbol_files_index[lib_name]
        return C_kicad_sym_file.loads(path)

    @staticmethod
    def get_sub_syms(
        lib_sym: C_lib_symbol,
        unit: int | None,
        body_style: int = 1,
    ) -> list[C_lib_symbol.C_symbol]:
        """
        This is purely based on naming convention.
        There are two suffixed numbers on the end: <name>_<x>_<y>, eg "LED_0_1"
        The first number is the "unit" and the second is "body style"
        Index 0 for either unit or body-style indicates "draw for all"

        References:
        - ^1 Parser:
            https://gitlab.com/kicad/code/kicad/-/blob/b043f334de6183595fda935175d2e2635daa379c/eeschema/sch_io/kicad_sexpr/sch_io_kicad_sexpr_parser.cpp#L455-476
        - ^2 Note on unit index meanings:
            https://gitlab.com/kicad/code/kicad/-/blob/2c99bc6c6d0f548f590d4681e20868e8ddb5b9c7/eeschema/eeschema_jobs_handler.cpp#L702
        """

        # kept body_style as an arg because I expect it will come up sooner than I like
        # apparently body_style == 2 is comes from some option "de morgen?"
        # don't need it now, but leaving this here for some poor sod later
        if body_style != 1:
            raise NotImplementedError("Only body style 1 is supported")

        sub_syms: list[C_lib_symbol.C_symbol] = []
        for name, sym in lib_sym.symbols.items():
            _, sub_sym_unit, sub_sym_body_style = name.split("_")
            sub_sym_unit = int(sub_sym_unit)
            sub_sym_body_style = int(sub_sym_body_style)

            if sub_sym_unit == unit or sub_sym_unit == 0 or unit is None:
                if sub_sym_body_style == body_style or sub_sym_body_style == 0:
                    sub_syms.append(sym)

        return sub_syms

    @staticmethod
    def get_unit_count(lib_sym: C_lib_symbol) -> int:
        return max(int(name.split("_")[1]) for name in lib_sym.symbols.keys()) or 1

    # Marking -------------------------------------------------------------------------
    """
    There are two methods to mark objects in the schematic:
    1. For items with propertys, add a property with a hash of the contents of
        itself, minus the mark property. This is used to detect changes to things
        such as position that the user may have nudged externally.
    2. For items without propertys, generate the uuid with the mark.

    Anything generated by this transformer is marked.
    """

    MARK_NAME = "faebryk_mark"

    @classmethod
    def _get_hash_contents(cls, obj_to_hash: Any) -> dict[tuple[str, ...], Any]:
        """
        Helper to get the contents of an object which belongs in it's mark
        This is a separate function for validation purposes
        """
        content_to_hash = {}

        for obj, _, name_path in dataclass_dfs(obj_to_hash):
            # Covnert the name path to a tuple, so it's hashable
            name_path = tuple(name_path)

            # Skip certain unstable things (like the mark we're about to add)
            if isinstance(obj, C_property) and obj.name == cls.MARK_NAME:
                continue

            if f"['{cls.MARK_NAME}']" in name_path:
                continue

            if name_path and name_path[-1] == ".uuid":
                continue

            # Skip collections, their children will be added if relevant
            if isinstance(obj, (list, dict, tuple)) or is_dataclass(obj):
                continue

            # Tweak properties to be more stable
            # Convert all numbers to 2 decimal place floating points
            if isinstance(obj, (int, float)):
                obj = round(float(obj), 2)

            content_to_hash[name_path] = obj

        return dict(sorted(content_to_hash.items(), key=lambda x: x[0]))

    @classmethod
    def hash_contents(cls, obj_to_hash: Any) -> str:
        """Hash the contents of an object, minus the mark"""
        content_to_hash = cls._get_hash_contents(obj_to_hash)

        hasher = hashlib.blake2b()
        for name, value in content_to_hash.items():
            hasher.update(f"{name}: {value}".encode())

        return hasher.hexdigest()

    @classmethod
    def check_mark(cls, obj: _HasUUID | _HasPropertys) -> bool:
        """
        Return True if an object is validly marked

        Items that have the capacity to be marked
        via propertys are only considered marked
        if they have the property and it's valid,
        despite their uuid
        """
        if hasattr(obj, "propertys"):
            if cls.MARK_NAME in obj.propertys:
                prop = obj.propertys[cls.MARK_NAME]
                assert isinstance(prop, C_property)
                return prop.value == cls.hash_contents(obj)

            return False

        if hasattr(obj, "uuid"):
            assert isinstance(obj.uuid, str)
            suffix = cls.hash_contents(obj).encode().hex()
            uuid = obj.uuid.replace("-", "")
            return uuid == suffix[: len(uuid)]

        return False

    @classmethod
    def _mark[R: _HasUUID | _HasPropertys](cls, obj: R) -> R:
        """Mark the property if possible, otherwise ensure the uuid is marked"""

        hashed_contents = cls.hash_contents(obj)

        if hasattr(obj, "propertys"):
            obj.propertys[cls.MARK_NAME] = C_property(
                name=cls.MARK_NAME,
                value=hashed_contents,
                effects=C_effects(hide=True)
            )
            return obj

        elif hasattr(obj, "uuid"):
            obj.uuid = _gen_uuid(hashed_contents)

        else:
            raise TypeError(f"Object {obj} has no propertys or uuid")

        return obj

    @classmethod
    def mark[R: _HasUUID | _HasPropertys](cls, obj: R) -> R:
        """Mark the property if possible, otherwise ensure the uuid is marked"""

        # If there's already a valid mark, do nothing
        # This is important to maintain consistent UUID marking
        if cls.check_mark(obj):
            return obj

        return cls._mark(obj)

    # Insert ---------------------------------------------------------------------------

    def insert_wire(
        self,
        coords: list[Geometry.Point2D],
        stroke: C_stroke | None = None,
    ):
        """Insert a wire with points at all the coords"""
        for section in zip(coords[:-1], coords[1:]):
            self.sch.wires.append(
                SCH.C_wire(
                    pts=C_pts(xys=[C_xy(*coord) for coord in section]),
                    stroke=stroke or C_stroke(),
                    uuid=_gen_uuid(),
                )
            )

    def insert_junction(
        self,
        coord: Geometry.Point2D,
    ):
        self.sch.junctions.append(
            SCH.C_junction(
                at=C_xy(coord[0], coord[1]),
            )
        )

    @staticmethod
    def _build_justify(
        justify: Justify | list[Justify] | None,
    ) -> list[C_effects.C_justify.E_justify]:
        """
        Without any alignment, the text defaults to center alignment,
        which beyond looking shit, also locks rotation to 0 or 90 degrees

        Weird!
        """
        if justify is None:
            justify = [C_effects.C_justify.E_justify.right]
        elif isinstance(justify, Justify):
            justify = [justify]

        return [C_effects.C_justify(justifys=just) for just in justify]

    def insert_text(
        self,
        text: str,
        at: C_xyr,
        font: Font | None = None,
        text_alignment: Justify | list[Justify] | None = None,
    ):
        if font is None:
            font = self.font

        justifys = self._build_justify(text_alignment)

        self.sch.texts.append(
            SCH.C_text(
                text=text,
                at=at,
                effects=C_effects(
                    font=font,
                    justifys=justifys,
                ),
                uuid=_gen_uuid(),
            )
        )

    def insert_global_label(
        self,
        text: str,
        shape: SCH.C_global_label.E_shape,
        at: C_xyr,
        font: Font | None = None,
        text_alignment: Justify | list[Justify] | None = None,
    ):
        if font is None:
            font = self.font

        # The rotation dictates the text alignment
        # If the alignment is wrong, the rotation is sacrificed
        if 0 < at.r <= 90:
            text_alignment = [C_effects.C_justify.E_justify.left]
        else:
            text_alignment = [C_effects.C_justify.E_justify.right]

        justifys = self._build_justify(text_alignment)

        self.sch.global_labels.append(
            SCH.C_global_label(
                shape=shape,
                text=text,
                at=at,
                effects=C_effects(
                    font=font,
                    justifys=justifys,
                ),
                uuid=_gen_uuid(),
            )
        )

    def _ensure_lib_symbol(
        self,
        lib_id: str,
    ) -> C_lib_symbol:
        """Ensure a symbol is in the schematic library, and return it"""
        if lib_id in self.sch.lib_symbols.symbols:
            return self.sch.lib_symbols.symbols[lib_id]

        lib_name, symbol_name = lib_id.split(":")
        lib_sym = deepcopy(
            self.get_symbol_file(lib_name).kicad_symbol_lib.symbols[symbol_name]
        )
        lib_sym.name = lib_id
        self.sch.lib_symbols.symbols[lib_id] = lib_sym
        return lib_sym

    def insert_symbol(
        self,
        module: Module,
        at: Point2D | None = None,
        rotation: int | None = None,
    ):
        if at is None:
            at = (0, 0)

        if rotation is None:
            rotation = 0

        # Symbols are attached to modules earlier in the pipeline
        # Typically, by the picker (lcsc.py), but plausibly by a library component
        symbol = module.get_trait(F.Symbol.has_symbol).reference

        # Ensure lib symbol is in sch
        lib_id = symbol.get_trait(F.Symbol.has_kicad_symbol).symbol_name
        lib_sym = self._ensure_lib_symbol(lib_id)

        # insert all units
        if self.get_unit_count(lib_sym) > 1:
            # problems today:
            # - F.Symbol -> Module mapping
            # - has_linked_sch_symbol mapping is currently 1:1
            # - has_kicad_symbol mapping is currently 1:1
            raise NotImplementedError("Multiple units not implemented")

        for unit_key in range(self.get_unit_count(lib_sym)):
            unit_objs = self.get_sub_syms(lib_sym, unit_key)

            pins = []
            for subunit in unit_objs:
                for pin in subunit.pins:
                    pins.append(
                        SCH.C_symbol_instance.C_pin(
                            name=pin.number.number,
                            uuid=_gen_uuid(),
                        )
                    )

            unit_instance = SCH.C_symbol_instance(
                lib_id=lib_id,
                unit=unit_key,
                at=C_xyr(at[0], at[1], rotation),
                in_bom=True,
                on_board=True,
                pins=pins,
                uuid=_gen_uuid(),
            )

            # It's one of ours, until it's modified in KiCAD
            self.mark(unit_instance)

            # Add a C_property for the reference based on the override name
            if reference_name := module.get_trait(F.has_overriden_name).get_name():
                unit_instance.propertys["Reference"] = C_property(
                    name="Reference",
                    value=reference_name,
                )
            else:
                # TODO: handle not having an overriden name better
                raise ValueError(f"Module {module} has no overriden name")

            self.attach_symbol(symbol, unit_instance)

            self.sch.symbols.append(unit_instance)

    # Bounding boxes ----------------------------------------------------------------
    type BoundingBox = tuple[Geometry.Point2D, Geometry.Point2D]

    @singledispatchmethod
    @staticmethod
    def get_bbox(obj) -> BoundingBox | None:
        """
        Get the bounding box of the object in it's reference frame
        This means that for things like pins, which know their own position,
        the bbox returned will include the offset of the pin.
        """
        raise NotImplementedError(f"Don't know how to get bbox for {type(obj)}")

    @get_bbox.register
    @staticmethod
    def _(obj: C_arc) -> BoundingBox:
        return Geometry.bbox(
            list(
                chain.from_iterable(
                    Geometry.approximate_arc(
                        (obj.start.x, obj.start.y),
                        (obj.mid.x, obj.mid.y),
                        (obj.end.x, obj.end.y),
                    )
                )
            ),
            tolerance=obj.stroke.width,
        )

    @get_bbox.register
    @staticmethod
    def _(obj: C_polyline) -> BoundingBox | None:
        if len(obj.pts.xys) == 0:
            return None

        return Geometry.bbox(
            [(pt.x, pt.y) for pt in obj.pts.xys],
            tolerance=obj.stroke.width,
        )

    @get_bbox.register
    @staticmethod
    def _(obj: C_rect) -> BoundingBox | None:
        return Geometry.bbox(
            [
                (obj.start.x, obj.start.y),
                (obj.end.x, obj.end.y),
            ],
            tolerance=obj.stroke.width,
        )

    @get_bbox.register
    @staticmethod
    def _(obj: C_circle) -> BoundingBox:
        radius = Geometry.distance_euclid(obj.center, obj.end)
        return Geometry.bbox(
            (obj.center.x - radius, obj.center.y - radius),
            (obj.center.x + radius, obj.center.y + radius),
            tolerance=obj.stroke.width,
        )

    @get_bbox.register
    @staticmethod
    def _(obj: C_lib_symbol.C_symbol.C_pin) -> BoundingBox:
        # TODO: include the name and number in the bbox
        start = (obj.at.x, obj.at.y)
        end = Geometry.rotate(start, [(obj.at.x + obj.length, obj.at.y)], obj.at.r)[0]
        return Geometry.bbox([start, end])

    @get_bbox.register
    @classmethod
    def _(cls, obj: C_lib_symbol.C_symbol) -> BoundingBox | None:
        all_geos = list(
            chain(
                obj.arcs,
                obj.polylines,
                obj.circles,
                obj.rectangles,
                obj.pins,
            )
        )

        bboxes = []
        for geo in all_geos:
            if (new_bboxes := cls.get_bbox(geo)) is not None:
                bboxes.extend(new_bboxes)

        if len(bboxes) == 0:
            return None

        return Geometry.bbox(bboxes)

    @get_bbox.register
    @classmethod
    def _(cls, obj: C_lib_symbol) -> BoundingBox:
        sub_points = list(
            chain.from_iterable(
                bboxes
                for unit in obj.symbols.values()
                if (bboxes := cls.get_bbox(unit)) is not None
            )
        )
        assert len(sub_points) > 0
        return Geometry.bbox(sub_points)

    @get_bbox.register
    @classmethod
    def _(cls, obj: list) -> BoundingBox:
        return Geometry.bbox(
            list(chain.from_iterable(cls.get_bbox(item) for item in obj))
        )

    def _add_missing_symbols(self):
        """
        Add symbols to the schematic that are missing based on the fab graph
        """
        for f_symbol in self.missing_symbols:
            self.insert_symbol(f_symbol.represents)
        self.missing_symbols = []

    def _build_shim_circuit(self) -> shims.Circuit:
        """Does what it says on the tin."""
        # TODO: add existing wire locations
        from faebryk.exporters.schematic.kicad.skidl.geometry import BBox, Point

        # 1.1 create hollow circuits to append to
        circuit = shims.Circuit()
        circuit.parts = []
        circuit.nets = []

        # 1.2 create maps to short-cut access between fab and sch
        sch_to_fab_pin_map: FuncDict[
            SCH.C_symbol_instance.C_pin, F.Symbol.Pin | None
        ] = FuncDict()
        sch_to_fab_sym_map: FuncDict[SCH.C_symbol_instance, F.Symbol | None] = (
            FuncDict()
        )
        # for each sch_symbol / (fab_symbol | None) pair, create a shim part
        # we need to shim sym object which aren't even in the graph to avoid colliding
        for _, f_sym_trait in self.graph.nodes_with_trait(F.Symbol.has_symbol):
            if sch_sym_trait := f_sym_trait.reference.try_get_trait(
                Transformer.has_linked_sch_symbol
            ):
                sch_to_fab_sym_map[sch_sym_trait.symbol] = f_sym_trait.reference
        for sch_sym in self.sch.symbols:
            f_symbol = sch_to_fab_sym_map.setdefault(sch_sym, None)
            for sch_pin in sch_sym.pins:
                sch_to_fab_pin_map[sch_pin] = (
                    f_symbol.pins.get(sch_pin.name) if f_symbol else None
                )

        # 2. create shim objects
        # 2.1 make nets
        sch_to_shim_pin_map: FuncDict[SCH.C_symbol_instance.C_pin, shims.Pin] = (
            FuncDict()
        )
        fab_nets = self.graph.nodes_of_type(F.Net)
        for net in fab_nets:
            shim_net = shims.Net()
            shim_net.name = net.get_trait(F.has_overriden_name).get_name()
            shim_net.netio = ""  # TODO:
            shim_net.stub = False  # TODO:
            shim_net._is_implicit = not net.get_trait(
                F.has_overriden_name
            ).is_explicit()

            # make partial net-oriented pins
            shim_net.pins = []
            for mif in net.get_connected_interfaces():
                if has_fab_pin := mif.try_get_trait(F.Symbol.Pin.has_pin):
                    if has_sch_pin := has_fab_pin.reference.try_get_trait(
                        Transformer.has_linked_sch_pins
                    ):
                        for sch_pin in has_sch_pin.pins:
                            shim_pin = shims.Pin()
                            shim_pin.net = shim_net
                            shim_net.pins.append(shim_pin)
                            sch_to_shim_pin_map[sch_pin] = shim_pin

            # set is_connected for all pins on net if len(net.pins) > 0
            is_connected = len(shim_net.pins) > 0
            for pin in shim_net.pins:
                pin._is_connected = is_connected

            circuit.nets.append(shim_net)

        # 2.2 make parts
        def _hierarchy(module: Module) -> str:
            """
            Make a string representation of the module's hierarchy
            using the best name for each part we have.

            NOTE: The hierarchy is used to determine whether parts
            live in the same module.
            - Top level should be unnamed, eg ""
            - Subsequent levels should be named and dot-separated
            - Part's ref should not be included at the end eg, don't do "led.U1"
            """

            def _best_name(module: Module) -> str:
                if name_trait := module.try_get_trait(F.has_overriden_name):
                    return name_trait.get_name()
                return module.get_name()

            # skip the root module, because it's name is just "*"
            hierarchy = [h[0] for h in module.get_hierarchy()][1:-1]
            return "." + ".".join(_best_name(n) for n in hierarchy)

        # for each sch_symbol, create a shim part
        for sch_sym, f_symbol in sch_to_fab_sym_map.items():
            lib_sym = self._ensure_lib_symbol(sch_sym.lib_id)
            sch_lib_symbol_units = self.get_sub_syms(lib_sym, sch_sym.unit)
            shim_part = shims.Part()
            shim_part.ref = sch_sym.propertys["Reference"].value
            # if we don't have a fab symbol, place the part at the top of the hierarchy
            shim_part.hierarchy = _hierarchy(f_symbol.represents) if f_symbol else ""
            # TODO: what's the ato analog?
            # TODO: should this desc
            shim_part.symtx = ""
            shim_part.unit = {}  # TODO: support units
            shim_part.fab_symbol = f_symbol
            shim_part.sch_symbol = sch_sym
            shim_part.bare_bbox = BBox(
                *[
                    Point(mm_to_mil(pts[0]), mm_to_mil(pts[1]))
                    for pts in Transformer.get_bbox(sch_lib_symbol_units)
                ]
            )
            shim_part.pins = []

            # 2.3 finish making pins, this time from a part-orientation
            all_sch_lib_pins = [p for u in sch_lib_symbol_units for p in u.pins]

            if logger.isEnabledFor(logging.DEBUG):
                logger.debug(
                    f"Symbol {sch_sym.propertys['Reference'].value=} {sch_sym.uuid=}"
                )
                pins = rich.table.Table("pin.name=", "pin.number=")
                for pin in all_sch_lib_pins:
                    pins.add_row(pin.name.name, pin.number.number)
                rich.print(pins)

            for sch_pin in sch_sym.pins:
                fab_pin = sch_to_fab_pin_map[sch_pin]

                if logger.isEnabledFor(logging.DEBUG):
                    logger.debug(f"Pin {sch_pin.name=} {fab_pin=}")

                try:
                    lib_sch_pin = find(
                        all_sch_lib_pins,
                        lambda x: str(x.number.number) == str(sch_pin.name),
                    )
                except KeyErrorNotFound:
                    # KiCAD seems to make a full duplication of all the symbol objects
                    # despite not displaying them unless they're relevant to the current
                    # unit. Do our best to make sure it's at least a pin the symbol
                    # overall has (ignoring the unit)
                    lib_sym_pins_all_units = [
                        p.number.number
                        for sym in self.get_sub_syms(lib_sym, None)
                        for p in sym.pins
                    ]
                    if sch_pin.name in lib_sym_pins_all_units:
                        continue
                    raise ValueError(
                        f"Pin {sch_pin.name} not found in any unit of"
                        f" symbol {sch_sym.propertys['Reference'].value}"
                    )

                assert isinstance(lib_sch_pin, C_lib_symbol.C_symbol.C_pin)
                shim_pin = sch_to_shim_pin_map.setdefault(sch_pin, shims.Pin())
                shim_pin.name = sch_pin.name
                shim_pin.num = lib_sch_pin.number
                shim_pin.orientation = shims.angle_to_orientation(lib_sch_pin.at.r)
                shim_pin.part = shim_part

                # TODO: ideas:
                # - stub powery things
                # - override from symbol layout info trait
                shim_pin.stub = False
                if fab_power_if := fab_pin.represents.get_parent_of_type(
                    F.ElectricPower
                ):
                    shim_pin.fab_is_gnd = fab_pin.represents is fab_power_if.lv
                    shim_pin.fab_is_pwr = fab_pin.represents is fab_power_if.hv
                else:
                    shim_pin.fab_is_gnd = False
                    shim_pin.fab_is_pwr = False

                shim_pin.x = mm_to_mil(lib_sch_pin.at.x)
                shim_pin.y = mm_to_mil(lib_sch_pin.at.y)
                shim_pin.fab_pin = fab_pin
                shim_pin.sch_pin = sch_pin

                shim_part.pins.append(shim_pin)

            circuit.parts.append(shim_part)

        # 2.4 generate similarity matrix
        def similarity(part: "shims.Part", other: "shims.Part", **options) -> float:
            """
            NOTE: Straight outta skidl
            Return a measure of how similar two parts are.

            Args:
                part (Part): The part to compare to for similarity.
                options (dict): Dictionary of options and settings affecting
                    similarity computation.

            Returns:
                Float value for similarity (larger means more similar).
            """

            def score_pins():
                pin_score = 0
                if len(part.pins) == len(other.pins):
                    for p_self, p_other in zip(part.ordered_pins, other.ordered_pins):
                        if p_self.is_attached(p_other):
                            pin_score += 1
                return pin_score

            # Every part starts off somewhat similar to another.
            score = 1

            if part.description == other.description:
                score += 5
            if part.name == other.name:
                score += 5
                if part.value == other.value:
                    score += 2
                score += score_pins()
            elif part.ref_prefix == other.ref_prefix:
                score += 3
                if part.value == other.value:
                    score += 2
                score += score_pins()

            return score / 3

        similarities: dict[tuple[int, int], float] = {}
        for part in circuit.parts:
            part._similarites = {}

            for other in circuit.parts:
                if part is other:
                    continue

                key = tuple(sorted((hash(part), hash(other))))

                if key not in similarities:
                    # TODO: actually compute similarity
                    # similarities[key] = similarity(part, other)
                    similarities[key] = 10

                part._similarites[other] = similarities[key]

        # 2.-1 run audit on circuit
        circuit.audit()
        return circuit

    def _apply_shim_sch_node(
        self, node: skidl_node.SchNode, sheet_tx: skidl_node.Tx = skidl_node.Tx()
    ):
        from faebryk.exporters.schematic.kicad.skidl.geometry import (
            Tx,
            tx_rot_0,
            tx_rot_90,
            tx_rot_180,
            tx_rot_270,
        )

        def get_common_rotation(part_tx: Tx) -> float | None:
            def _check(tx: Tx) -> bool:
                return (
                    math.isclose(tx.a, part_tx.a / part_tx.scale)
                    and math.isclose(tx.b, part_tx.b / part_tx.scale)
                    and math.isclose(tx.c, part_tx.c / part_tx.scale)
                    and math.isclose(tx.d, part_tx.d / part_tx.scale)
                )

            if _check(tx_rot_0):
                return 0
            elif _check(tx_rot_90):
                return 90
            elif _check(tx_rot_180):
                return 180
            elif _check(tx_rot_270):
                return 270
            return None

        mils_to_mm = Tx(a=0.0254, b=0, c=0, d=0.0254, dx=0, dy=0)

        if node.flattened:
            # Create the transformation matrix for the placement of the parts
            # in the node.
            tx = node.tx * sheet_tx * mils_to_mm
        else:
            flattened_bbox = node.internal_bbox()
            tx = skidl_sch.calc_sheet_tx(flattened_bbox) * mils_to_mm

        # TODO: Put flattened node into heirarchical block

        for part in node.parts:
            ## 2 add global labels
            part_tx = part.tx * tx
            if isinstance(part, skidl_sch.NetTerminal):
                assert isinstance(tx, skidl_node.Tx)
                pin = part.pins[0]
                pt = pin.pt * part_tx
                rotation = {
                    "R": 0,
                    "D": 90,
                    "L": 180,
                    "U": 270,
                }[skidl_sch.calc_pin_dir(pin)]
                self.insert_global_label(
                    pin.net.name,
                    at=C_xyr(x=pt.x, y=pt.y, r=rotation),
                    shape=SCH.C_global_label.E_shape.input,
                )
            else:
                ## 3. modify parts
                # unlike Skidl, we're working under the assumption that all the parts
                # are already in the schematic, we just need to move them
                part.sch_symbol.at.x = part_tx.origin.x
                part.sch_symbol.at.y = part_tx.origin.y
                part.sch_symbol.at.r = get_common_rotation(part_tx) or 0

        # 4. draw wires and junctions
        for wire in node.wires.values():
            for seg in wire:
                skild_seg_points = [p * tx for p in [seg.p1, seg.p2]]
                seg_points = [(p.x, p.y) for p in skild_seg_points]
                self.insert_wire(seg_points)

        for _, junctions in node.junctions.items():
            for junc in junctions:
                pt = junc * tx
                self.insert_junction((pt.x, pt.y))

        # 5. TODO: pin labels for stubbed nets

    def apply_shim_sch_node(self, circuit: skidl_node.SchNode):
        def dfs(node: skidl_node.SchNode):
            yield node
            for child in node.children.values():
                yield from dfs(child)

        for node in dfs(circuit):
            self._apply_shim_sch_node(node)

    def generate_schematic(self, **options: Unpack[shims.Options]):
        """Does what it says on the tin."""
        # 1. add missing symbols
        self._add_missing_symbols()

        # 2. build shim circuit
        circuit = self._build_shim_circuit()

        # 3. run skidl schematic generation
        from faebryk.exporters.schematic.kicad.skidl.gen_schematic import gen_schematic

        sch = gen_schematic(circuit, ".", "test", **options)

        # 4. transform sch according to skidl
        self.apply_shim_sch_node(sch)

        # 5. save
        return self.sch
